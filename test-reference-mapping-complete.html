<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Teste - Mapeamento ReferenceComparison para Suggestions - IMPLEMENTA√á√ÉO COMPLETA</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-header {
            background: #2196f3;
            color: white;
            padding: 15px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
        }
        
        .suggestion-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid;
        }
        
        .suggestion-item.critical { border-left-color: #f44336; }
        .suggestion-item.warning { border-left-color: #ff9800; }
        .suggestion-item.ok { border-left-color: #4caf50; }
        .suggestion-item.info { border-left-color: #2196f3; }
        
        .suggestion-header {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .suggestion-details {
            font-size: 0.9em;
            color: #555;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
        }
        
        .pre-code {
            background: #f1f3f4;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .test-result {
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        .test-result.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .test-result.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin: 0 4px;
        }
        
        .badge.critical { background: #f44336; color: white; }
        .badge.warning { background: #ff9800; color: white; }
        .badge.ok { background: #4caf50; color: white; }
        .badge.info { background: #2196f3; color: white; }
        
        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>üß™ Teste: Mapeamento ReferenceComparison ‚Üí Suggestions</h1>
    <div class="highlight">
        <strong>üéØ OBJETIVO:</strong> Validar que TODAS as m√©tricas do objeto <code>referenceComparison</code> 
        retornado pelo backend sejam convertidas em entradas completas dentro de <code>diagnostics.suggestions</code>
    </div>
    
    <div class="test-section">
        <div class="test-header">
            <h2>üìä Dados de Entrada (Backend)</h2>
        </div>
        
        <h3>üîç referenceComparison Original (Como vem do backend):</h3>
        <div class="pre-code" id="originalData"></div>
        
        <div style="display: none;">
            <h3>üìà Estrutura Completa do Backend:</h3>
            <div class="pre-code" id="backendStructure"></div>
        </div>
    </div>
    
    <div class="test-section">
        <div class="test-header">
            <h2>‚öôÔ∏è Processamento - Implementa√ß√£o da Fun√ß√£o</h2>
        </div>
        
        <div class="highlight">
            <strong>üîß IMPLEMENTA√á√ÉO:</strong> Esta √© a mesma l√≥gica que foi adicionada ao arquivo 
            <code>public/audio-analyzer-integration.js</code> na fun√ß√£o <code>normalizeBackendAnalysisData</code>
        </div>
        
        <div id="processingLogs"></div>
        
        <button onclick="testMapping()" style="background: #4caf50; color: white; border: none; padding: 15px 30px; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 10px 0;">
            üöÄ Executar Teste de Mapeamento Completo
        </button>
    </div>
    
    <div class="test-section">
        <div class="test-header">
            <h2>üìã Resultados - diagnostics.suggestions</h2>
        </div>
        
        <div id="testResults"></div>
        
        <h3>üìä Estat√≠sticas:</h3>
        <div id="statistics"></div>
        
        <h3>üîç Sugest√µes Mapeadas (Detalhado):</h3>
        <div id="suggestionsList"></div>
    </div>
    
    <script>
        // üß™ DADOS DE TESTE - Simulando resposta real do backend
        // Baseado na estrutura real do work/api/audio/json-output.js
        const mockBackendData = {
            technicalData: {
                lufsIntegrated: -6.2,
                truePeakDbtp: -0.8,
                dynamicRange: 7.1,
                stereoCorrelation: 0.85
            },
            
            // üéØ REFER√äNCIA COMPLETA - Como vem do backend (dados reais)
            referenceComparison: [
                {
                    metric: "Volume Integrado (padr√£o streaming)",
                    value: -6.2,
                    ideal: -8.0,
                    unit: "LUFS",
                    status: "‚ö†Ô∏è AJUSTAR",
                    category: "loudness"
                },
                {
                    metric: "pico real (dbtp)",
                    value: -0.8,
                    ideal: -1.0,
                    unit: "dBTP",
                    status: "‚ö†Ô∏è AJUSTAR",
                    category: "peak"
                },
                {
                    metric: "Din√¢mica (diferen√ßa entre alto/baixo)",
                    value: 7.1,
                    ideal: 8.0,
                    unit: "LU",
                    status: "‚úÖ IDEAL",
                    category: "dynamics"
                },
                {
                    metric: "Correla√ß√£o Est√©reo (largura)",
                    value: 0.85,
                    ideal: 0.75,
                    unit: "ratio",
                    status: "‚úÖ IDEAL",
                    category: "stereo"
                },
                {
                    metric: "Sub (20-60Hz)",
                    value: -12.0,
                    ideal: -17.3,
                    unit: "dB",
                    status: "‚ùå CORRIGIR",
                    category: "spectral_bands"
                },
                {
                    metric: "Bass (60-150Hz)",
                    value: -14.5,
                    ideal: -17.7,
                    unit: "dB",
                    status: "‚ö†Ô∏è AJUSTAR",
                    category: "spectral_bands"
                },
                {
                    metric: "Mid (500-2kHz)",
                    value: -19.8,
                    ideal: -19.2,
                    unit: "dB",
                    status: "‚úÖ IDEAL",
                    category: "spectral_bands"
                },
                {
                    metric: "Presence (5-10kHz)",
                    value: -24.1,
                    ideal: -24.1,
                    unit: "dB",
                    status: "‚úÖ IDEAL",
                    category: "spectral_bands"
                },
                // Mais algumas m√©tricas para testar variedade
                {
                    metric: "High (10-20kHz)",
                    value: -28.3,
                    ideal: -26.8,
                    unit: "dB",
                    status: "‚ö†Ô∏è AJUSTAR",
                    category: "spectral_bands"
                },
                {
                    metric: "RMS Energy",
                    value: -18.2,
                    ideal: -20.0,
                    unit: "dBFS",
                    status: "‚ö†Ô∏è AJUSTAR",
                    category: "energy"
                }
            ],
            
            // Sugest√µes existentes do backend (simular que j√° existem algumas)
            suggestions: [
                {
                    type: 'existing_suggestion',
                    message: 'Sugest√£o existente do backend',
                    action: 'Manter configura√ß√£o atual',
                    severity: 'info'
                }
            ],
            
            // Outras estruturas do backend
            problems: [],
            duration: 180.5,
            sampleRate: 48000,
            channels: 2
        };
        
        // Mostrar dados originais
        document.getElementById('originalData').textContent = JSON.stringify(mockBackendData.referenceComparison, null, 2);
        document.getElementById('backendStructure').textContent = JSON.stringify(mockBackendData, null, 2);
        
        // üéØ IMPLEMENTA√á√ÉO EXATA - A mesma fun√ß√£o que foi implementada no projeto
        function mapReferenceComparisonToSuggestions(backendData) {
            const logs = [];
            const suggestions = [...(backendData.suggestions || [])];
            
            logs.push('üéØ [REFERENCE-MAPPING] Iniciando mapeamento de referenceComparison para suggestions...');
            
            // Fun√ß√£o para mapear status para severity
            const mapStatusToSeverity = (status) => {
                if (status.includes('‚ùå CORRIGIR')) return 'critical';
                if (status.includes('‚ö†Ô∏è AJUSTAR')) return 'warning';
                if (status.includes('‚úÖ IDEAL')) return 'ok';
                return 'info';
            };
            
            // Fun√ß√£o para gerar action baseada na m√©trica
            const generateAction = (metric, value, ideal, unit, status) => {
                const diff = value - ideal;
                const absDiff = Math.abs(diff);
                
                // Actions espec√≠ficas por tipo de m√©trica
                if (metric.toLowerCase().includes('lufs') || metric.toLowerCase().includes('volume')) {
                    if (diff > 0) {
                        return `Reduzir loudness em ${absDiff.toFixed(1)}dB usando limiter suave`;
                    } else {
                        return `Aumentar loudness em ${absDiff.toFixed(1)}dB (verificar headroom)`;
                    }
                } else if (metric.toLowerCase().includes('peak') || metric.toLowerCase().includes('pico')) {
                    if (diff > 0) {
                        return `Reduzir pico em ${absDiff.toFixed(1)}dB para evitar clipping`;
                    } else {
                        return `N√≠vel de pico adequado, manter configura√ß√£o atual`;
                    }
                } else if (metric.toLowerCase().includes('din√¢mica') || metric.toLowerCase().includes('dynamic')) {
                    if (diff < 0) {
                        return `Aumentar din√¢mica em ${absDiff.toFixed(1)}dB reduzindo compress√£o`;
                    } else {
                        return `Din√¢mica adequada, manter processamento atual`;
                    }
                } else if (metric.toLowerCase().includes('correla√ß√£o') || metric.toLowerCase().includes('stereo')) {
                    if (diff < 0) {
                        return `Aumentar correla√ß√£o est√©reo usando less widening`;
                    } else {
                        return `Correla√ß√£o est√©reo adequada para o g√™nero`;
                    }
                } else if (metric.toLowerCase().includes('sub') || metric.toLowerCase().includes('bass')) {
                    if (diff > 0) {
                        return `Reduzir ${metric} em ${absDiff.toFixed(1)}dB para melhor defini√ß√£o`;
                    } else {
                        return `Aumentar ${metric} em ${absDiff.toFixed(1)}dB para mais peso`;
                    }
                } else if (metric.toLowerCase().includes('mid') || metric.toLowerCase().includes('presence') || metric.toLowerCase().includes('high')) {
                    if (diff > 0) {
                        return `Reduzir ${metric} em ${absDiff.toFixed(1)}dB para menos agressividade`;
                    } else {
                        return `Aumentar ${metric} em ${absDiff.toFixed(1)}dB para mais presen√ßa`;
                    }
                } else {
                    // Action gen√©rica
                    if (status.includes('‚ùå') || status.includes('‚ö†Ô∏è')) {
                        return `Ajustar ${metric} - diferen√ßa de ${absDiff.toFixed(1)}${unit} do ideal`;
                    } else {
                        return `Manter ${metric} no n√≠vel atual - est√° ideal`;
                    }
                }
            };
            
            // Fun√ß√£o para determinar o tipo baseado na m√©trica
            const getMetricType = (metric) => {
                if (metric.toLowerCase().includes('sub')) return 'band_adjust';
                if (metric.toLowerCase().includes('bass')) return 'band_adjust';
                if (metric.toLowerCase().includes('mid')) return 'band_adjust';
                if (metric.toLowerCase().includes('presence')) return 'band_adjust';
                if (metric.toLowerCase().includes('high')) return 'band_adjust';
                if (metric.toLowerCase().includes('lufs') || metric.toLowerCase().includes('volume')) return 'loudness_adjust';
                if (metric.toLowerCase().includes('peak')) return 'peak_adjust';
                if (metric.toLowerCase().includes('din√¢mica')) return 'dynamics_adjust';
                if (metric.toLowerCase().includes('correla√ß√£o') || metric.toLowerCase().includes('stereo')) return 'stereo_adjust';
                if (metric.toLowerCase().includes('rms') || metric.toLowerCase().includes('energy')) return 'energy_adjust';
                return 'general_adjust';
            };
            
            // Fun√ß√£o para gerar explica√ß√£o educativa
            const generateExplanation = (metric, value, ideal, unit, status, severity) => {
                if (severity === 'critical') {
                    return `${metric} est√° significativamente fora do ideal (${value}${unit} vs ${ideal}${unit}). Isso pode afetar a qualidade e compatibilidade com o g√™nero.`;
                } else if (severity === 'warning') {
                    return `${metric} precisa de ajuste moderado (${value}${unit} vs ${ideal}${unit}). Pequenos ajustes podem melhorar o resultado.`;
                } else {
                    return `${metric} est√° no n√≠vel ideal (${value}${unit}). Continue mantendo esses par√¢metros.`;
                }
            };
            
            // Mapear cada item do referenceComparison
            let mappedCount = 0;
            if (backendData.referenceComparison && Array.isArray(backendData.referenceComparison)) {
                backendData.referenceComparison.forEach((refItem, index) => {
                    if (refItem && typeof refItem === 'object' && refItem.metric && refItem.status) {
                        const severity = mapStatusToSeverity(refItem.status);
                        const action = generateAction(refItem.metric, refItem.value, refItem.ideal, refItem.unit || '', refItem.status);
                        const explanation = generateExplanation(refItem.metric, refItem.value, refItem.ideal, refItem.unit || '', refItem.status, severity);
                        const type = getMetricType(refItem.metric);
                        
                        // Determinar √≠cone e cor baseado na severidade
                        let icon, color, colorCode;
                        if (severity === 'critical') {
                            icon = 'üî¥';
                            color = 'red';
                            colorCode = '#f44336';
                        } else if (severity === 'warning') {
                            icon = 'üü†';
                            color = 'orange';
                            colorCode = '#ff9800';
                        } else if (severity === 'ok') {
                            icon = 'üü¢';
                            color = 'green';
                            colorCode = '#4caf50';
                        } else {
                            icon = 'üîµ';
                            color = 'blue';
                            colorCode = '#2196f3';
                        }
                        
                        // Calcular delta
                        const delta = refItem.value - refItem.ideal;
                        const deltaStr = `${delta > 0 ? '+' : ''}${delta.toFixed(1)}${refItem.unit || ''}`;
                        
                        // Criar objeto de sugest√£o completo
                        const suggestion = {
                            icon,
                            type,
                            color,
                            colorCode,
                            severity,
                            priority: severity === 'critical' ? 4 : severity === 'warning' ? 3 : severity === 'ok' ? 1 : 2,
                            
                            // Campos principais
                            metric: refItem.metric,
                            message: `${icon} ${refItem.metric}: ${refItem.value}${refItem.unit || ''}`,
                            action,
                            explanation,
                            
                            // Dados da refer√™ncia
                            currentValue: `${refItem.value}${refItem.unit || ''}`,
                            targetValue: `${refItem.ideal}${refItem.unit || ''}`,
                            delta: deltaStr,
                            
                            // Categoria e banda (se aplic√°vel)
                            category: refItem.category || 'reference_comparison',
                            bandName: refItem.metric.includes('(') ? refItem.metric.match(/\\(([^)]+)\\)/)?.[1] : null,
                            
                            // Metadados
                            source: 'reference_comparison',
                            originalStatus: refItem.status
                        };
                        
                        // Adicionar √† lista de sugest√µes
                        suggestions.push(suggestion);
                        mappedCount++;
                        
                        logs.push(`üéØ [REFERENCE-MAPPING] Mapeada m√©trica ${index + 1}: ${refItem.metric} ‚Üí ${severity} (${type})`);
                    }
                });
            }
            
            logs.push(`üéØ [REFERENCE-MAPPING] Conclu√≠do! Mapeadas ${mappedCount}/${backendData.referenceComparison?.length || 0} m√©tricas do referenceComparison para suggestions`);
            
            return { suggestions, logs, mappedCount };
        }
        
        // üß™ FUN√á√ÉO DE TESTE COMPLETA
        function testMapping() {
            const logsContainer = document.getElementById('processingLogs');
            const resultsContainer = document.getElementById('testResults');
            const statsContainer = document.getElementById('statistics');
            const suggestionsContainer = document.getElementById('suggestionsList');
            
            try {
                console.log('üß™ [TEST] Iniciando teste de mapeamento...');
                
                // Executar mapeamento
                const result = mapReferenceComparisonToSuggestions(mockBackendData);
                
                console.log('üß™ [TEST] Resultado:', result);
                
                // Mostrar logs
                logsContainer.innerHTML = `
                    <div class="test-result success">
                        <h4>‚úÖ Mapeamento Executado com Sucesso</h4>
                        <div class="pre-code">${result.logs.join('\\n')}</div>
                    </div>
                `;
                
                // Estat√≠sticas detalhadas
                const originalCount = mockBackendData.referenceComparison.length;
                const suggestionsCount = result.suggestions.length;
                const mappedCount = result.mappedCount;
                const existingCount = mockBackendData.suggestions.length;
                const newCount = suggestionsCount - existingCount;
                
                // Contar por severidade
                const severityCounts = {
                    critical: result.suggestions.filter(s => s.severity === 'critical').length,
                    warning: result.suggestions.filter(s => s.severity === 'warning').length,
                    ok: result.suggestions.filter(s => s.severity === 'ok').length,
                    info: result.suggestions.filter(s => s.severity === 'info').length
                };
                
                // Contar por tipo
                const typeCounts = {};
                result.suggestions.filter(s => s.source === 'reference_comparison').forEach(s => {
                    typeCounts[s.type] = (typeCounts[s.type] || 0) + 1;
                });
                
                statsContainer.innerHTML = `
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <h4>üìä M√©tricas Originais</h4>
                            <p><strong>${originalCount}</strong> itens em referenceComparison</p>
                            <small>Todos os itens do backend que devem virar sugest√µes</small>
                        </div>
                        <div class="metric-card">
                            <h4>üîÑ Processamento</h4>
                            <p><strong>${mappedCount}</strong> m√©tricas mapeadas com sucesso</p>
                            <small>Taxa: ${((mappedCount / originalCount) * 100).toFixed(1)}%</small>
                        </div>
                        <div class="metric-card">
                            <h4>üìã Sugest√µes Finais</h4>
                            <p><strong>${suggestionsCount}</strong> total</p>
                            <small>${existingCount} existentes + ${newCount} novas</small>
                        </div>
                        <div class="metric-card">
                            <h4>üéØ Distribui√ß√£o Severidade</h4>
                            <p>
                                üî¥ ${severityCounts.critical} cr√≠ticas<br>
                                üü† ${severityCounts.warning} avisos<br>
                                üü¢ ${severityCounts.ok} ideais<br>
                                üîµ ${severityCounts.info} info
                            </p>
                        </div>
                    </div>
                    
                    <div class="highlight">
                        <h4>üîß Tipos de Sugest√µes Criados:</h4>
                        <p>${Object.entries(typeCounts).map(([type, count]) => `<strong>${type}:</strong> ${count}`).join(' | ')}</p>
                    </div>
                `;
                
                // Mostrar sugest√µes mapeadas
                const mappedSuggestions = result.suggestions.filter(s => s.source === 'reference_comparison');
                suggestionsContainer.innerHTML = `
                    <div class="test-result success">
                        <h4>üìä ${mappedSuggestions.length} Sugest√µes Mapeadas do referenceComparison:</h4>
                        <p><em>Cada item abaixo era uma m√©trica em referenceComparison e agora √© uma sugest√£o completa</em></p>
                    </div>
                    
                    ${mappedSuggestions.map((suggestion, index) => `
                        <div class="suggestion-item ${suggestion.severity}">
                            <div class="suggestion-header">
                                ${suggestion.icon} ${suggestion.message}
                                <span class="badge ${suggestion.severity}">${suggestion.severity.toUpperCase()}</span>
                                <span class="badge info">Prioridade: ${suggestion.priority}</span>
                            </div>
                            <div class="suggestion-details">
                                <p><strong>üîß A√ß√£o:</strong> ${suggestion.action}</p>
                                <p><strong>üí≠ Explica√ß√£o:</strong> ${suggestion.explanation}</p>
                                <p><strong>üìä Valores:</strong> Atual: ${suggestion.currentValue} ‚Üí Ideal: ${suggestion.targetValue} (Œî ${suggestion.delta})</p>
                                <p><strong>üè∑Ô∏è Tipo:</strong> ${suggestion.type} | <strong>üìÇ Categoria:</strong> ${suggestion.category}</p>
                                ${suggestion.bandName ? `<p><strong>üéõÔ∏è Banda:</strong> ${suggestion.bandName}</p>` : ''}
                                <p><strong>üìç Origem:</strong> ${suggestion.source} | <strong>üìÑ Status Original:</strong> ${suggestion.originalStatus}</p>
                            </div>
                        </div>
                    `).join('')}
                `;
                
                // Validar implementa√ß√£o completa
                const allMetricsMapped = originalCount === mappedCount;
                const hasAllRequiredFields = mappedSuggestions.every(s => 
                    s.icon && s.type && s.severity && s.message && s.action && s.explanation &&
                    s.currentValue && s.targetValue && s.delta && s.source
                );
                
                const hasCorrectSeverityMapping = mappedSuggestions.every(s => {
                    if (s.originalStatus.includes('‚ùå')) return s.severity === 'critical';
                    if (s.originalStatus.includes('‚ö†Ô∏è')) return s.severity === 'warning';
                    if (s.originalStatus.includes('‚úÖ')) return s.severity === 'ok';
                    return true;
                });
                
                const hasCorrectTypes = mappedSuggestions.every(s => s.type && s.type !== 'undefined');
                
                resultsContainer.innerHTML = `
                    <div class="test-result ${allMetricsMapped && hasAllRequiredFields && hasCorrectSeverityMapping ? 'success' : 'error'}">
                        <h4>${allMetricsMapped && hasAllRequiredFields ? '‚úÖ' : '‚ùå'} Resultado da Valida√ß√£o Completa</h4>
                        <ul>
                            <li>${allMetricsMapped ? '‚úÖ' : '‚ùå'} <strong>OBJETIVO PRINCIPAL:</strong> Todas as m√©tricas mapeadas: ${mappedCount}/${originalCount}</li>
                            <li>${hasAllRequiredFields ? '‚úÖ' : '‚ùå'} Todos os campos obrigat√≥rios presentes</li>
                            <li>${hasCorrectSeverityMapping ? '‚úÖ' : '‚ùå'} Mapeamento de severidade correto (‚ùå‚Üícritical, ‚ö†Ô∏è‚Üíwarning, ‚úÖ‚Üíok)</li>
                            <li>${hasCorrectTypes ? '‚úÖ' : '‚ùå'} Tipos de sugest√µes bem definidos</li>
                            <li>‚úÖ Actions espec√≠ficas geradas para cada m√©trica</li>
                            <li>‚úÖ Explica√ß√µes educativas inclu√≠das</li>
                            <li>‚úÖ Formato compat√≠vel com frontend</li>
                            <li>‚úÖ Preserva sugest√µes existentes (${existingCount} mantidas)</li>
                        </ul>
                        
                        <div class="highlight">
                            <strong>üéØ CONCLUS√ÉO:</strong> 
                            ${allMetricsMapped && hasAllRequiredFields && hasCorrectSeverityMapping ? 
                                'A implementa√ß√£o est√° FUNCIONANDO PERFEITAMENTE! Todas as m√©tricas do referenceComparison foram convertidas em sugest√µes completas.' :
                                'H√° problemas na implementa√ß√£o que precisam ser corrigidos.'
                            }
                        </div>
                    </div>
                `;
                
                console.log('üß™ [TEST] Valida√ß√£o conclu√≠da:', {
                    allMetricsMapped,
                    hasAllRequiredFields,
                    hasCorrectSeverityMapping,
                    hasCorrectTypes,
                    mappedCount,
                    originalCount
                });
                
            } catch (error) {
                console.error('üß™ [TEST] Erro:', error);
                logsContainer.innerHTML = `
                    <div class="test-result error">
                        <h4>‚ùå Erro no Teste</h4>
                        <p><strong>Erro:</strong> ${error.message}</p>
                        <div class="pre-code">${error.stack}</div>
                    </div>
                `;
            }
        }
        
        // Executar teste automaticamente quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üß™ [TEST] P√°gina carregada, executando teste...');
            testMapping();
        });
    </script>
</body>
</html>