<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧪 Teste de Mapeamento Corrigido - SoundyAI</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .json-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .metric-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .metric-item {
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        .metric-item.success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        .metric-item.missing {
            background: #f8d7da;
            border-left-color: #dc3545;
        }
        .metric-item.found {
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 10px;
        }
        .badge-success { background: #28a745; color: white; }
        .badge-danger { background: #dc3545; color: white; }
        .badge-info { background: #17a2b8; color: white; }
        h1, h2 { color: #333; }
        .highlight { background: #fff3cd; padding: 2px 4px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>🧪 Teste de Mapeamento Corrigido</h1>
    <p><strong>Testando:</strong> Se a função normalizeBackendAnalysisData corrigida consegue mapear corretamente o JSON real do backend.</p>

    <div class="test-section">
        <h2>📥 JSON Original do Backend (Seu Exemplo)</h2>
        <div id="originalJson" class="json-display"></div>
    </div>

    <div class="test-section">
        <h2>📊 Resultado do Mapeamento Corrigido</h2>
        <div id="mappingResults"></div>
    </div>

    <div class="test-section">
        <h2>🎯 Dados Técnicos Mapeados</h2>
        <div id="technicalData" class="json-display"></div>
    </div>

    <script>
        // JSON exato fornecido pelo usuário
        const realBackendJson = {
            "ok": true,
            "rms": {
                "hasData": true,
                "frameCount": 1902
            },
            "file": "uploads/1757888586761.wav",
            "mode": "genre",
            "score": 97.9,
            "stereo": {
                "width": 0.156,
                "balance": 0,
                "correlation": 0.986,
                "hasPhaseIssues": false,
                "isMonoCompatible": false
            },
            "_worker": {
                "source": "pipeline_complete"
            },
            "scoring": {
                "method": "equal_weight_v3",
                "bonuses": {},
                "breakdown": {},
                "penalties": [
                    {
                        "n": 0,
                        "p": 0,
                        "u": 0,
                        "w": 0.4865,
                        "key": "lufsIntegrated",
                        "status": "OK",
                        "severity": null
                    },
                    {
                        "n": 0,
                        "p": 0,
                        "u": 0,
                        "w": 0.045,
                        "key": "lra",
                        "status": "OK",
                        "severity": null
                    },
                    {
                        "n": 1.609,
                        "p": 0.0839,
                        "u": 0.2218,
                        "w": 0.3784,
                        "key": "truePeakDbtp",
                        "status": "ALTO",
                        "severity": "media"
                    },
                    {
                        "n": 0,
                        "p": 0,
                        "u": 0,
                        "w": 0.045,
                        "key": "stereoCorrelation",
                        "status": "OK",
                        "severity": null
                    },
                    {
                        "n": 1.48,
                        "p": 0.0088,
                        "u": 0.196,
                        "w": 0.045,
                        "key": "stereoWidth",
                        "status": "BAIXO",
                        "severity": "media"
                    }
                ]
            },
            "loudness": {
                "lra": 7.5,
                "unit": "LUFS",
                "momentary": -9.7,
                "shortTerm": -13.2,
                "integrated": -13.9
            },
            "metadata": {
                "jobId": "1493ac10-bb56-4934-b35d-3d4b540d247b",
                "stage": "completed",
                "fileName": "1757888586761.wav",
                "fileSize": 33533954,
                "timestamp": "2025-09-14T22:23:25.855Z",
                "buildVersion": "5.4.1-fail-fast",
                "phaseBreakdown": {
                    "total": 10327,
                    "phase1_decode": 1131,
                    "phase4_json_output": 6,
                    "phase2_segmentation": 1308,
                    "phase3_core_metrics": 7882
                },
                "processingTime": 10327,
                "pipelineVersion": "5.1-5.4-corrected"
            },
            "spectral": {
                "hasData": true,
                "frameCount": 1000
            },
            "truePeak": {
                "unit": "dBTP",
                "maxDbtp": 3,
                "maxLinear": 1.416
            },
            "analyzedAt": "2025-09-14T22:23:25.856Z",
            "performance": {
                "backendPhase": "5.1-5.4",
                "workerTimestamp": "2025-09-14T22:23:25.856Z",
                "workerTotalTimeMs": 10327
            },
            "classification": "Referência Mundial"
        };

        // Função normalizeBackendAnalysisData CORRIGIDA
        function normalizeBackendAnalysisDataCORRIGIDA(backendData) {
            console.log('🔧 [NORMALIZE] Iniciando normalização dos dados do backend:', backendData);
            
            // Se já está no formato correto, retornar como está
            if (backendData.technicalData && backendData.technicalData.peak !== undefined) {
                console.log('📊 [NORMALIZE] Dados já estão normalizados');
                return backendData;
            }
            
            // Criar estrutura normalizada - SEM FALLBACKS FICTÍCIOS
            const normalized = {
                ...backendData,
                technicalData: backendData.technicalData || {},
                problems: backendData.problems || [],
                suggestions: backendData.suggestions || [],
                duration: backendData.duration || null,
                sampleRate: backendData.sampleRate || null,
                channels: backendData.channels || null
            };
            
            // 🎯 MAPEAR MÉTRICAS BÁSICAS - SEM FALLBACKS FICTÍCIOS
            const tech = normalized.technicalData;
            const source = backendData.technicalData || backendData.metrics || backendData;
            
            console.log('🔍 [NORMALIZE] Dados de origem recebidos:', source);
            console.log('🔍 [NORMALIZE] Estrutura completa do backend:', backendData);
            
            // Função para pegar valor real ou null (sem fallbacks fictícios)
            const getRealValue = (...paths) => {
                for (const path of paths) {
                    const value = path.split('.').reduce((obj, key) => obj?.[key], source);
                    if (Number.isFinite(value)) {
                        return value;
                    }
                    // NOVO: Também verificar na estrutura raiz do backendData
                    const rootValue = path.split('.').reduce((obj, key) => obj?.[key], backendData);
                    if (Number.isFinite(rootValue)) {
                        return rootValue;
                    }
                }
                return null; // Retorna null se não há valor real
            };
            
            // Peak e RMS - APENAS VALORES REAIS
            tech.peak = getRealValue('peak', 'peak_db', 'peakLevel');
            tech.rms = getRealValue('rms', 'rms_db', 'rmsLevel');
            tech.rmsLevel = tech.rms;
            
            // Dynamic Range - APENAS VALORES REAIS
            tech.dynamicRange = getRealValue('dynamicRange', 'dynamic_range', 'dr');
            
            // Crest Factor - APENAS VALORES REAIS
            tech.crestFactor = getRealValue('crestFactor', 'crest_factor');
            
            // True Peak - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.truePeakDbtp = getRealValue('truePeakDbtp', 'true_peak_dbtp', 'truePeak') || 
                               (backendData.truePeak?.maxDbtp && Number.isFinite(backendData.truePeak.maxDbtp) ? backendData.truePeak.maxDbtp : null);
            
            // LUFS - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.lufsIntegrated = getRealValue('lufsIntegrated', 'lufs_integrated', 'lufs') ||
                                 (backendData.loudness?.integrated && Number.isFinite(backendData.loudness.integrated) ? backendData.loudness.integrated : null);
            
            tech.lufsShortTerm = getRealValue('lufsShortTerm', 'lufs_short_term') ||
                                (backendData.loudness?.shortTerm && Number.isFinite(backendData.loudness.shortTerm) ? backendData.loudness.shortTerm : null);
            
            tech.lufsMomentary = getRealValue('lufsMomentary', 'lufs_momentary') ||
                                (backendData.loudness?.momentary && Number.isFinite(backendData.loudness.momentary) ? backendData.loudness.momentary : null);
            
            // LRA - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.lra = getRealValue('lra', 'loudnessRange') ||
                      (backendData.loudness?.lra && Number.isFinite(backendData.loudness.lra) ? backendData.loudness.lra : null);
            
            // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                                    (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
            
            tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                              (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);
            
            tech.balanceLR = getRealValue('balanceLR', 'balance_lr') ||
                            (backendData.stereo?.balance && Number.isFinite(backendData.stereo.balance) ? backendData.stereo.balance : null);

            // 🔢 SCORES E QUALIDADE - MAPEAMENTO CORRETO PARA NOVA ESTRUTURA
            normalized.qualityOverall = backendData.score && Number.isFinite(backendData.score) ? backendData.score : null;
            
            // 📊 DADOS AUXILIARES DO NOVO FORMATO
            if (backendData.metadata) {
                normalized.processingMs = backendData.metadata.processingTime || backendData.performance?.workerTotalTimeMs || null;
                normalized.fileName = backendData.metadata.fileName || null;
                normalized.fileSize = backendData.metadata.fileSize || null;
                normalized.buildVersion = backendData.metadata.buildVersion || null;
                normalized.pipelineVersion = backendData.metadata.pipelineVersion || null;
            }
            
            if (backendData.classification) {
                normalized.classification = backendData.classification;
            }
            
            // 🎯 DADOS DE SCORING DETALHADOS
            if (backendData.scoring) {
                normalized.scoring = backendData.scoring;
                console.log('📊 [NORMALIZE] Dados de scoring encontrados:', backendData.scoring);
            }
            
            console.log('✅ [NORMALIZE] Normalização concluída:', {
                hasTechnicalData: !!normalized.technicalData,
                qualityScore: normalized.qualityOverall,
                hasScoring: !!normalized.scoring,
                classification: normalized.classification
            });
            
            return normalized;
        }

        function runTest() {
            console.log('🧪 Iniciando teste de mapeamento...');

            // Exibir JSON original
            document.getElementById('originalJson').textContent = JSON.stringify(realBackendJson, null, 2);

            // Executar normalização corrigida
            const normalizedResult = normalizeBackendAnalysisDataCORRIGIDA(realBackendJson);

            // Exibir dados técnicos mapeados
            document.getElementById('technicalData').textContent = JSON.stringify(normalizedResult.technicalData, null, 2);

            // Analisar métricas críticas
            const criticalMetrics = [
                { key: 'truePeakDbtp', expectedValue: 3, source: 'truePeak.maxDbtp' },
                { key: 'lufsIntegrated', expectedValue: -13.9, source: 'loudness.integrated' },
                { key: 'lufsShortTerm', expectedValue: -13.2, source: 'loudness.shortTerm' },
                { key: 'lufsMomentary', expectedValue: -9.7, source: 'loudness.momentary' },
                { key: 'lra', expectedValue: 7.5, source: 'loudness.lra' },
                { key: 'stereoCorrelation', expectedValue: 0.986, source: 'stereo.correlation' },
                { key: 'stereoWidth', expectedValue: 0.156, source: 'stereo.width' },
                { key: 'balanceLR', expectedValue: 0, source: 'stereo.balance' }
            ];

            let successCount = 0;
            let totalMetrics = criticalMetrics.length;

            const resultsHtml = criticalMetrics.map(metric => {
                const actualValue = normalizedResult.technicalData[metric.key];
                const isSuccess = Number.isFinite(actualValue) && Math.abs(actualValue - metric.expectedValue) < 0.001;
                
                if (isSuccess) successCount++;

                const statusClass = isSuccess ? 'success' : (actualValue === null ? 'missing' : 'found');
                const statusBadge = isSuccess ? 
                    `<span class="status-badge badge-success">✓ Mapeado</span>` :
                    actualValue === null ?
                    `<span class="status-badge badge-danger">✗ Ausente</span>` :
                    `<span class="status-badge badge-info">? Valor diferente</span>`;

                return `
                    <div class="metric-item ${statusClass}">
                        <h4>${metric.key} ${statusBadge}</h4>
                        <p><strong>Origem:</strong> <span class="highlight">${metric.source}</span></p>
                        <p><strong>Esperado:</strong> ${metric.expectedValue}</p>
                        <p><strong>Obtido:</strong> ${actualValue}</p>
                        ${isSuccess ? '<p><strong>✅ Status:</strong> Mapeamento correto!</p>' : ''}
                    </div>
                `;
            }).join('');

            // Verificar score geral
            const scoreMapping = normalizedResult.qualityOverall === realBackendJson.score;
            const scoreHtml = `
                <div class="metric-item ${scoreMapping ? 'success' : 'missing'}">
                    <h4>Score Geral ${scoreMapping ? '<span class="status-badge badge-success">✓ Mapeado</span>' : '<span class="status-badge badge-danger">✗ Falhou</span>'}</h4>
                    <p><strong>Origem:</strong> <span class="highlight">score</span></p>
                    <p><strong>Esperado:</strong> ${realBackendJson.score}</p>
                    <p><strong>Obtido:</strong> ${normalizedResult.qualityOverall}</p>
                </div>
            `;

            document.getElementById('mappingResults').innerHTML = `
                <div class="metric-comparison">
                    ${resultsHtml}
                    ${scoreHtml}
                </div>
                <div style="background: #e9ecef; padding: 15px; border-radius: 6px; margin-top: 20px;">
                    <h3>📊 Resumo do Teste</h3>
                    <p><strong>Métricas Mapeadas Corretamente:</strong> ${successCount + (scoreMapping ? 1 : 0)}/${totalMetrics + 1}</p>
                    <p><strong>Taxa de Sucesso:</strong> ${Math.round(((successCount + (scoreMapping ? 1 : 0))/(totalMetrics + 1)) * 100)}%</p>
                    <p><strong>Status:</strong> ${(successCount >= totalMetrics * 0.8) ? '✅ MAPEAMENTO FUNCIONANDO' : '❌ PROBLEMAS NO MAPEAMENTO'}</p>
                </div>
            `;

            return {
                success: successCount >= totalMetrics * 0.8,
                mappedMetrics: successCount,
                totalMetrics: totalMetrics,
                scoreMapping: scoreMapping
            };
        }

        // Executar teste quando a página carregar
        document.addEventListener('DOMContentLoaded', () => {
            const result = runTest();
            console.log('🎯 Resultado do teste:', result);
        });
    </script>
</body>
</html>