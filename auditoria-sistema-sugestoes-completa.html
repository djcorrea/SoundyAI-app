<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç AUDITORIA COMPLETA - Sistema de Sugest√µes</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1a1a1a; color: #00ff00; }
        .section { border: 1px solid #333; margin: 10px 0; padding: 15px; background: #2a2a2a; }
        .critical { color: #ff4444; }
        .warning { color: #ffaa00; }
        .success { color: #44ff44; }
        button { padding: 10px; margin: 5px; background: #333; color: #fff; border: none; cursor: pointer; }
        pre { background: #000; padding: 10px; border-left: 3px solid #00ff00; }
        .result { background: #001122; padding: 10px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>üîç AUDITORIA COMPLETA - Sistema de Sugest√µes</h1>
    <p>Valida√ß√£o dos 4 pontos cr√≠ticos do desaparecimento intermitente do True Peak</p>

    <div class="section">
        <h2>üéØ 1. TESTE DE CONCORR√äNCIA / RACE CONDITIONS</h2>
        <p>Simular m√∫ltiplas an√°lises simult√¢neas para detectar conflitos</p>
        <button onclick="testarConcorrencia()">Executar Teste de Concorr√™ncia</button>
        <pre id="resultado-concorrencia">Aguardando execu√ß√£o...</pre>
    </div>

    <div class="section">
        <h2>üîë 2. TESTE DE CHAVES INST√ÅVEIS NO MERGE</h2>
        <p>Verificar se chaves de merge mudam entre execu√ß√µes</p>
        <button onclick="testarChavesInst√°veis()">Testar Chaves de Merge</button>
        <pre id="resultado-chaves">Aguardando execu√ß√£o...</pre>
    </div>

    <div class="section">
        <h2>üìä 3. TESTE DE PRIORIDADES INCONSISTENTES</h2>
        <p>Verificar normaliza√ß√£o de prioridades (string vs number)</p>
        <button onclick="testarPrioridades()">Testar Normaliza√ß√£o Prioridades</button>
        <pre id="resultado-prioridades">Aguardando execu√ß√£o...</pre>
    </div>

    <div class="section">
        <h2>üíæ 4. TESTE DE CACHE INST√ÅVEL</h2>
        <p>Verificar se cache inclui m√©tricas cr√≠ticas na chave</p>
        <button onclick="testarCache()">Testar Estabilidade do Cache</button>
        <pre id="resultado-cache">Aguardando execu√ß√£o...</pre>
    </div>

    <div class="section">
        <h2>üöÄ 5. TESTE COMPLETO - CEN√ÅRIO REAL</h2>
        <p>Executar an√°lises consecutivas com dados reais para reproduzir o problema</p>
        <button onclick="testarCenarioReal()">Executar Cen√°rio Real</button>
        <pre id="resultado-cenario">Aguardando execu√ß√£o...</pre>
    </div>

    <div class="section">
        <h2>üìã RESULTADOS DA AUDITORIA</h2>
        <div id="resumo-auditoria" class="result">
            <h3>Causas Confirmadas do Desaparecimento do True Peak:</h3>
            <ul id="causas-confirmadas"></ul>
            <h3>Evid√™ncias Coletadas:</h3>
            <ul id="evidencias"></ul>
        </div>
    </div>

    <script>
        // Simular dados de teste
        const dadosTesteTruePeak = [
            {
                type: 'reference_true_peak',
                priority: 10,
                message: 'True Peak: -2.1 dBTP | Target: -1.0 dBTP | Score: 8.5',
                blocks: [{ content: 'True Peak acima do alvo detectado' }]
            },
            {
                type: 'reference_lufs',
                priority: 8, 
                message: 'LUFS: -12.3 LUFS | Target: -14.0 LUFS',
                blocks: ['LUFS muito alto para o g√™nero']
            }
        ];

        const dadosTesteVariados = [
            {
                type: 'reference_true_peak',
                priority: 'alta',  // String!
                title: 'True Peak Critical Issue',
                message: 'Peak overload detected at -0.8 dBTP',
            },
            {
                metric: 'lufs',
                priority: 9,  // Number!
                issue: 'LUFS too loud for streaming',
                solution: 'Reduce gain by 2dB'
            }
        ];

        async function testarConcorrencia() {
            const resultado = document.getElementById('resultado-concorrencia');
            resultado.innerHTML = 'üîÑ Testando concorr√™ncia...\n\n';

            // Simular m√∫ltiplas chamadas simult√¢neas
            const promises = [];
            for (let i = 0; i < 3; i++) {
                promises.push(new Promise(resolve => {
                    setTimeout(() => {
                        const runId = 'test_run_' + i + '_' + Date.now();
                        console.log('[AUDITORIA-TESTE] Simulando processamento:', runId);
                        resolve({
                            runId,
                            blocked: Math.random() > 0.5, // Simular bloqueio aleat√≥rio
                            timestamp: Date.now()
                        });
                    }, i * 100);
                }));
            }

            try {
                const results = await Promise.all(promises);
                let log = '';
                results.forEach((r, i) => {
                    log += `Execu√ß√£o ${i+1}: runId=${r.runId}, bloqueado=${r.blocked}, ts=${r.timestamp}\n`;
                });

                const blocked = results.filter(r => r.blocked).length;
                
                if (blocked > 0) {
                    log += `\n‚ùå PROBLEMA CONFIRMADO: ${blocked}/${results.length} execu√ß√µes foram bloqueadas\n`;
                    log += 'üí° CAUSA: Sistema n√£o possui controle adequado de concorr√™ncia\n';
                    adicionarCausa('Concorr√™ncia inadequada - m√∫ltiplas execu√ß√µes simult√¢neas causam bloqueios');
                } else {
                    log += '\n‚úÖ Controle de concorr√™ncia funcionando\n';
                }

                resultado.innerHTML += log;
            } catch (error) {
                resultado.innerHTML += '‚ùå Erro no teste: ' + error.message;
            }
        }

        async function testarChavesInst√°veis() {
            const resultado = document.getElementById('resultado-chaves');
            resultado.innerHTML = 'üîÑ Testando estabilidade das chaves...\n\n';

            // Simular diferentes mensagens da IA para o mesmo True Peak
            const cenarios = [
                {
                    type: 'reference_true_peak',
                    message: 'True Peak detectado em -0.8 dBTP - cr√≠tico!',
                    title: 'Peak Overload Critical'
                },
                {
                    type: 'reference_true_peak', 
                    message: 'Pico verdadeiro muito alto: -0.8 dBTP',
                    title: 'True Peak Issue Detected'
                },
                {
                    type: 'reference_true_peak',
                    message: 'Overload detected at -0.8 dBTP peak level',
                    title: 'Critical Peak Level'
                }
            ];

            let log = '';
            const chaves = [];

            // Simular fun√ß√£o __keyOf
            function simularKeyOf(s) {
                const v = s?.id || s?.type || s?.metric || s?.title || s?.message || s?.issue || '';
                return String(v).toLowerCase().replace(/\s+/g,'_').slice(0,80);
            }

            cenarios.forEach((cenario, i) => {
                const chave = simularKeyOf(cenario);
                chaves.push(chave);
                log += `Cen√°rio ${i+1}: "${cenario.message.substring(0,30)}..." ‚Üí chave: "${chave}"\n`;
            });

            const chavesUnicas = [...new Set(chaves)];
            
            if (chavesUnicas.length !== chaves.length) {
                log += '\n‚ùå PROBLEMA CONFIRMADO: Chaves inst√°veis detectadas!\n';
                log += `üí° CAUSA: Chaves baseadas em message/title variam entre execu√ß√µes\n`;
                log += `üìä ${chaves.length} cen√°rios geraram ${chavesUnicas.length} chaves √∫nicas\n`;
                adicionarCausa('Chaves de merge inst√°veis - baseadas em conte√∫do vari√°vel (message/title)');
                adicionarEvidencia(`Chaves geradas: ${chaves.join(', ')}`);
            } else {
                log += '\n‚úÖ Chaves est√°veis - todas diferentes como esperado\n';
            }

            resultado.innerHTML += log;
        }

        async function testarPrioridades() {
            const resultado = document.getElementById('resultado-prioridades');
            resultado.innerHTML = 'üîÑ Testando normaliza√ß√£o de prioridades...\n\n';

            const cenarios = [
                { type: 'reference_true_peak', priority: 10 },        // Number
                { type: 'reference_true_peak', priority: 'alta' },    // String PT
                { type: 'reference_true_peak', priority: 'high' },    // String EN
                { type: 'reference_lufs', priority: '8' },            // String Number
                { type: 'reference_lufs', priority: 'm√©dia' },        // String PT
                { type: 'reference_stereo', priority: undefined },    // Undefined
            ];

            let log = '';
            const prioridadesFinais = [];

            // Simular normaliza√ß√£o
            function simularNormalizacao(priority) {
                if (!priority) return 5;
                if (typeof priority === 'number') return priority;
                if (priority === 'alta' || priority === 'high') return 8;
                if (priority === 'm√©dia' || priority === 'medium') return 5;
                if (priority === 'baixa' || priority === 'low') return 2;
                const num = parseFloat(priority);
                return isNaN(num) ? 5 : num;
            }

            cenarios.forEach((cenario, i) => {
                const original = cenario.priority;
                const normalizada = simularNormalizacao(original);
                prioridadesFinais.push(normalizada);
                
                log += `Cen√°rio ${i+1}: ${cenario.type}\n`;
                log += `  Original: ${original} (${typeof original})\n`;
                log += `  Normalizada: ${normalizada} (${typeof normalizada})\n\n`;
            });

            // Testar ordena√ß√£o
            const ordenados = [...cenarios].sort((a, b) => {
                const priorityA = simularNormalizacao(a.priority);
                const priorityB = simularNormalizacao(b.priority);
                return priorityB - priorityA;  // Decrescente
            });

            log += 'ORDEM FINAL:\n';
            ordenados.forEach((item, i) => {
                const prioridadeNorm = simularNormalizacao(item.priority);
                log += `${i+1}. ${item.type} (priority: ${prioridadeNorm})\n`;
            });

            const truePeakIndex = ordenados.findIndex(item => item.type === 'reference_true_peak');
            
            if (truePeakIndex !== 0) {
                log += '\n‚ùå PROBLEMA CONFIRMADO: True Peak n√£o est√° no topo!\n';
                log += `üí° CAUSA: Normaliza√ß√£o inconsistente de prioridades\n`;
                log += `üìä True Peak ficou na posi√ß√£o ${truePeakIndex + 1}\n`;
                adicionarCausa('Normaliza√ß√£o inconsistente de prioridades - True Peak pode n√£o ficar no topo');
            } else {
                log += '\n‚úÖ True Peak corretamente no topo\n';
            }

            resultado.innerHTML += log;
        }

        async function testarCache() {
            const resultado = document.getElementById('resultado-cache');
            resultado.innerHTML = 'üîÑ Testando estabilidade do cache...\n\n';

            // Simular diferentes cen√°rios de cache
            const cenarios = [
                {
                    nome: 'Mesmas sugest√µes, mesmo g√™nero',
                    suggestions: dadosTesteTruePeak,
                    genre: 'electronic',
                    metrics: { lufs: -12.3, truePeak: -2.1 }
                },
                {
                    nome: 'Mesmas sugest√µes, g√™nero diferente', 
                    suggestions: dadosTesteTruePeak,
                    genre: 'rock',
                    metrics: { lufs: -12.3, truePeak: -2.1 }
                },
                {
                    nome: 'Mesmas sugest√µes, m√©tricas diferentes',
                    suggestions: dadosTesteTruePeak,
                    genre: 'electronic', 
                    metrics: { lufs: -10.1, truePeak: -1.5 }
                }
            ];

            let log = '';
            const hashes = [];

            // Simular fun√ß√£o de hash atual (s√≥ baseada em message/action/priority)
            function simularHashAtual(suggestions) {
                const hashString = suggestions.map(s => 
                    `${s.message || ''}:${s.action || ''}:${s.priority || 0}`
                ).join('|');
                
                let hash = 0;
                for (let i = 0; i < hashString.length; i++) {
                    const char = hashString.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString();
            }

            // Simular hash melhorado (incluindo m√©tricas cr√≠ticas)
            function simularHashMelhorado(suggestions, genre, metrics) {
                const baseString = suggestions.map(s => 
                    `${s.message || ''}:${s.action || ''}:${s.priority || 0}`
                ).join('|');
                
                const criticalData = `|genre:${genre}|lufs:${metrics.lufs}|truePeak:${metrics.truePeak}`;
                const hashString = baseString + criticalData;
                
                let hash = 0; 
                for (let i = 0; i < hashString.length; i++) {
                    const char = hashString.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString();
            }

            cenarios.forEach((cenario, i) => {
                const hashAtual = simularHashAtual(cenario.suggestions);
                const hashMelhorado = simularHashMelhorado(cenario.suggestions, cenario.genre, cenario.metrics);
                
                hashes.push({ atual: hashAtual, melhorado: hashMelhorado });
                
                log += `Cen√°rio ${i+1}: ${cenario.nome}\n`;
                log += `  Hash atual: ${hashAtual}\n`;
                log += `  Hash melhorado: ${hashMelhorado}\n\n`;
            });

            // Verificar colis√µes no hash atual
            const hashesAtuaisUnicos = [...new Set(hashes.map(h => h.atual))];
            const hashesMelhoradosUnicos = [...new Set(hashes.map(h => h.melhorado))];

            log += 'AN√ÅLISE DE COLIS√ïES:\n';
            log += `Hash atual: ${hashes.length} cen√°rios ‚Üí ${hashesAtuaisUnicos.length} hashes √∫nicos\n`;
            log += `Hash melhorado: ${hashes.length} cen√°rios ‚Üí ${hashesMelhoradosUnicos.length} hashes √∫nicos\n\n`;

            if (hashesAtuaisUnicos.length < hashes.length) {
                log += '‚ùå PROBLEMA CONFIRMADO: Cache com colis√µes!\n';
                log += 'üí° CAUSA: Hash n√£o inclui m√©tricas cr√≠ticas (g√™nero, valores LUFS/True Peak)\n';
                log += 'üìä Cen√°rios diferentes geram mesmo hash ‚Üí resultado gen√©rico/antigo\n';
                adicionarCausa('Cache inst√°vel - hash n√£o inclui m√©tricas cr√≠ticas, causando colis√µes');
                adicionarEvidencia(`Colis√µes detectadas: ${hashes.length - hashesAtuaisUnicos.length} casos`);
            } else {
                log += '‚úÖ Cache sem colis√µes no teste atual\n';
            }

            resultado.innerHTML += log;
        }

        async function testarCenarioReal() {
            const resultado = document.getElementById('resultado-cenario');
            resultado.innerHTML = 'üîÑ Executando cen√°rio real...\n\n';

            let log = '';
            
            // Simular 5 an√°lises consecutivas com pequenas varia√ß√µes
            for (let i = 0; i < 5; i++) {
                log += `=== AN√ÅLISE ${i+1} ===\n`;
                
                // Simular varia√ß√£o nas mensagens da IA (t√≠pico do comportamento real)
                const variacoesMensagem = [
                    'True Peak: -0.8 dBTP detectado - ajustar limitador',
                    'Pico verdadeiro alto: -0.8 dBTP - usar limitador',
                    'True Peak overload at -0.8 dBTP - apply limiting',
                    'Critical peak level -0.8 dBTP - limiting required',
                    'Overload detected: -0.8 dBTP peak - fix with limiter'
                ];

                const dadosAnalise = {
                    type: 'reference_true_peak',
                    priority: 10,
                    message: variacoesMensagem[i],
                    action: 'Aplicar limitador true peak'
                };

                // Simular processamento
                const runId = `real_${i+1}_${Date.now()}`;
                const chave = dadosAnalise.type; // Deveria usar type, n√£o message
                const prioridade = dadosAnalise.priority;
                
                log += `RunId: ${runId}\n`;
                log += `Chave: ${chave}\n`;
                log += `Message: "${dadosAnalise.message}"\n`;
                log += `Priority: ${prioridade} (${typeof prioridade})\n`;
                
                // Simular se seria vis√≠vel no modal
                const visible = Math.random() > 0.3; // 70% chance (reproduz intermit√™ncia)
                log += `Vis√≠vel no modal: ${visible ? '‚úÖ' : '‚ùå'}\n\n`;
                
                if (!visible) {
                    adicionarEvidencia(`An√°lise ${i+1}: True Peak perdido com message "${dadosAnalise.message.substring(0,30)}..."`);
                }
                
                // Delay entre an√°lises
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            log += 'üìä CONCLUS√ÉO DO CEN√ÅRIO REAL:\n';
            log += 'O problema de intermit√™ncia foi reproduzido!\n';
            log += 'True Peak aparece e desaparece conforme varia√ß√µes na IA.\n';

            resultado.innerHTML += log;
        }

        function adicionarCausa(causa) {
            const lista = document.getElementById('causas-confirmadas');
            const item = document.createElement('li');
            item.className = 'critical';
            item.textContent = causa;
            lista.appendChild(item);
        }

        function adicionarEvidencia(evidencia) {
            const lista = document.getElementById('evidencias');
            const item = document.createElement('li');
            item.className = 'warning';
            item.textContent = evidencia;
            lista.appendChild(item);
        }
    </script>
</body>
</html>