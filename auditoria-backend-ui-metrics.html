<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Auditoria: Backend JSON vs UI Display</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.2em;
        }
        
        .audit-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }
        
        .metric-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 15px 0;
        }
        
        .backend-column, .ui-column, .status-column {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
        }
        
        .backend-column {
            border-left: 5px solid #27ae60;
        }
        
        .ui-column {
            border-left: 5px solid #3498db;
        }
        
        .status-column {
            border-left: 5px solid #e74c3c;
        }
        
        .metric-title {
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .metric-key {
            font-family: 'Courier New', monospace;
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 2px 0;
            display: block;
            font-size: 0.9em;
        }
        
        .metric-value {
            color: #2980b9;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .status-ok {
            color: #27ae60;
            font-weight: bold;
        }
        
        .status-error {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .status-warning {
            color: #f39c12;
            font-weight: bold;
        }
        
        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .json-viewer {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-size: 0.9em;
            margin: 10px 0;
        }
        
        .interceptor-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2c3e50;
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 0.9em;
            z-index: 1000;
        }
        
        .fake-value {
            background: #ffebee;
            color: #c62828;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #ef5350;
            font-weight: bold;
        }
        
        .real-value {
            background: #e8f5e8;
            color: #2e7d32;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #4caf50;
            font-weight: bold;
        }
        
        .missing-value {
            background: #fff3e0;
            color: #f57c00;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #ff9800;
            font-weight: bold;
        }
        
        .audit-summary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .test-controls {
            text-align: center;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <div class="interceptor-status" id="interceptorStatus">
        üîç Interceptor: Aguardando...
    </div>
    
    <div class="container">
        <h1>üîç Auditoria: Backend JSON vs UI Display</h1>
        
        <div class="test-controls">
            <button class="btn" onclick="startInterceptor()">üéØ Iniciar Interceptor</button>
            <button class="btn" onclick="simulateAnalysis()">üéµ Simular An√°lise</button>
            <button class="btn" onclick="compareWithRealBackend()">üîß Comparar com Backend Real</button>
            <button class="btn" onclick="clearResults()">üóëÔ∏è Limpar Resultados</button>
        </div>
        
        <div class="audit-summary" id="auditSummary">
            <h3>üìä Status da Auditoria</h3>
            <p>Execute uma an√°lise para iniciar a auditoria das m√©tricas</p>
        </div>
        
        <div id="auditResults"></div>
        
        <div class="audit-section">
            <h3>üéØ Estrutura JSON Esperada do Backend (Corrigida)</h3>
            <div class="json-viewer" id="expectedStructure">
Estrutura JSON esperada baseada no core-metrics.js:

{
  "fft": {
    "magnitude": [...],
    "phase": [...]
  },
  "spectralBands": {
    "bands": {
      "sub": { "percentage": 8.5, "energy": 0.024, "frequencyRange": "20-60Hz" },
      "bass": { "percentage": 18.2, "energy": 0.156, "frequencyRange": "60-150Hz" },
      "lowMid": { "percentage": 22.1, "energy": 0.198, "frequencyRange": "150-500Hz" },
      "mid": { "percentage": 24.7, "energy": 0.234, "frequencyRange": "500-2000Hz" },
      "highMid": { "percentage": 15.8, "energy": 0.142, "frequencyRange": "2000-5000Hz" },
      "presence": { "percentage": 8.9, "energy": 0.078, "frequencyRange": "5000-10000Hz" },
      "air": { "percentage": 1.8, "energy": 0.015, "frequencyRange": "10000-20000Hz" }
    },
    "totalPercentage": 100.0,
    "algorithm": "RMS_7_Band_Normalized"
  },
  "spectralCentroid": {
    "centroidHz": 2847.3,
    "brightnessCategory": "Neutro",
    "algorithm": "Weighted_Frequency_RMS"
  },
  "lufs": {
    "integrated": -14.2,
    "shortTerm": -13.8,
    "momentary": -12.5,
    "lra": 5.2,
    "algorithm": "ITU_R_BS_1770_4"
  },
  "truePeak": {
    "maxDbtp": -1.2,
    "maxLeft": -1.4,
    "maxRight": -1.2,
    "algorithm": "4x_Oversampling"
  },
  "stereo": {
    "correlation": 0.73,
    "width": 0.54,
    "correlationCategory": "Correlacionado",
    "widthCategory": "Moderado",
    "algorithm": "Corrected_Stereo_Metrics"
  },
  "dynamics": {
    "dynamicRange": 8.4,
    "crestFactor": 12.6,
    "lra": 5.2,
    "algorithm": "Professional_Dynamics_V1"
  }
}
            </div>
        </div>
    </div>

    <script>
        let interceptorActive = false;
        let originalFetch = null;
        let lastBackendResponse = null;
        let lastUIRender = null;
        
        // Mapeamento das m√©tricas esperadas
        const METRIC_MAPPINGS = {
            // LUFS e Loudness
            'lufs_integrated': 'lufs.integrated',
            'lufs_short_term': 'lufs.shortTerm', 
            'lufs_momentary': 'lufs.momentary',
            'lra': 'lufs.lra',
            
            // True Peak
            'truePeakDbtp': 'truePeak.maxDbtp',
            'truePeakLeft': 'truePeak.maxLeft',
            'truePeakRight': 'truePeak.maxRight',
            
            // Din√¢mica
            'dynamic_range': 'dynamics.dynamicRange',
            'crest_factor': 'dynamics.crestFactor',
            'dynamicRange': 'dynamics.dynamicRange',
            'crestFactor': 'dynamics.crestFactor',
            
            // Est√©reo
            'stereo_correlation': 'stereo.correlation',
            'stereo_width': 'stereo.width',
            'stereoCorrelation': 'stereo.correlation',
            'stereoWidth': 'stereo.width',
            
            // Spectral
            'spectral_centroid': 'spectralCentroid.centroidHz',
            'spectralCentroid': 'spectralCentroid.centroidHz',
            
            // Bandas espectrais
            'spectral_bands': 'spectralBands.bands',
            'tonalBalance': 'spectralBands.bands'
        };
        
        function updateStatus(message, color = '#3498db') {
            const status = document.getElementById('interceptorStatus');
            status.textContent = message;
            status.style.background = color;
        }
        
        function startInterceptor() {
            if (interceptorActive) {
                stopInterceptor();
                return;
            }
            
            interceptorActive = true;
            originalFetch = window.fetch;
            
            // Interceptar todas as chamadas fetch
            window.fetch = async function(...args) {
                const response = await originalFetch.apply(this, args);
                
                // Interceptar chamadas da API de √°udio
                if (args[0].includes('/api/audio/analyze') || args[0].includes('/api/jobs/')) {
                    try {
                        const clonedResponse = response.clone();
                        const jsonData = await clonedResponse.json();
                        
                        if (jsonData.success && jsonData.analysis) {
                            console.log('üéØ BACKEND RESPONSE INTERCEPTED:', jsonData);
                            lastBackendResponse = jsonData.analysis;
                            analyzeMappings(jsonData.analysis);
                            updateStatus('‚úÖ Resposta interceptada!', '#27ae60');
                        } else if (jsonData.analysis || jsonData.technicalData) {
                            // Capturar estruturas alternativas
                            console.log('üéØ ALTERNATIVE STRUCTURE INTERCEPTED:', jsonData);
                            lastBackendResponse = jsonData;
                            analyzeMappings(jsonData);
                            updateStatus('‚úÖ Estrutura alternativa interceptada!', '#f39c12');
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erro ao interceptar JSON:', error);
                    }
                }
                
                return response;
            };
            
            updateStatus('üîç Interceptor ativo', '#27ae60');
            document.querySelector('button[onclick="startInterceptor()"]').textContent = '‚èπÔ∏è Parar Interceptor';
        }
        
        function stopInterceptor() {
            if (originalFetch) {
                window.fetch = originalFetch;
                originalFetch = null;
            }
            interceptorActive = false;
            updateStatus('üîç Interceptor: Aguardando...', '#3498db');
            document.querySelector('button[onclick="startInterceptor()"]').textContent = 'üéØ Iniciar Interceptor';
        }
        
        function analyzeMappings(backendData) {
            const results = document.getElementById('auditResults');
            const auditData = [];
            
            // Fun√ß√£o para buscar valor no objeto aninhado
            function getNestedValue(obj, path) {
                return path.split('.').reduce((current, key) => current?.[key], obj);
            }
            
            // Analisar cada mapeamento
            for (const [uiKey, backendPath] of Object.entries(METRIC_MAPPINGS)) {
                const backendValue = getNestedValue(backendData, backendPath);
                const legacyValue = getNestedValue(backendData.technicalData || {}, uiKey);
                
                auditData.push({
                    uiKey,
                    backendPath,
                    backendValue,
                    legacyValue,
                    hasValue: backendValue !== undefined && backendValue !== null,
                    hasLegacy: legacyValue !== undefined && legacyValue !== null,
                    isNumeric: typeof backendValue === 'number' && isFinite(backendValue)
                });
            }
            
            // Renderizar resultados
            results.innerHTML = `
                <div class="audit-section">
                    <h3>üîç Auditoria das M√©tricas</h3>
                    <div class="metric-comparison">
                        <div class="backend-column">
                            <div class="metric-title">üéØ Backend (Novo)</div>
                            ${auditData.map(item => `
                                <div class="metric-key">${item.backendPath}</div>
                                <div class="metric-value ${item.hasValue ? 'real-value' : 'missing-value'}">
                                    ${item.hasValue ? item.backendValue : 'MISSING'}
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="ui-column">
                            <div class="metric-title">üñ•Ô∏è UI (Legado)</div>
                            ${auditData.map(item => `
                                <div class="metric-key">${item.uiKey}</div>
                                <div class="metric-value ${item.hasLegacy ? 'real-value' : 'missing-value'}">
                                    ${item.hasLegacy ? item.legacyValue : 'MISSING'}
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="status-column">
                            <div class="metric-title">üìä Status</div>
                            ${auditData.map(item => {
                                let status = '';
                                let statusClass = '';
                                
                                if (item.hasValue && item.isNumeric) {
                                    status = '‚úÖ OK';
                                    statusClass = 'status-ok';
                                } else if (item.hasLegacy) {
                                    status = '‚ö†Ô∏è Legacy Only';
                                    statusClass = 'status-warning';
                                } else {
                                    status = '‚ùå Missing';
                                    statusClass = 'status-error';
                                }
                                
                                return `
                                    <div style="height: 20px;"></div>
                                    <div class="${statusClass}">${status}</div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="audit-section">
                    <h3>üìã JSON Completo Capturado</h3>
                    <div class="json-viewer">${JSON.stringify(backendData, null, 2)}</div>
                </div>
            `;
            
            // Atualizar resumo
            const totalMetrics = auditData.length;
            const okMetrics = auditData.filter(item => item.hasValue && item.isNumeric).length;
            const warningMetrics = auditData.filter(item => !item.hasValue && item.hasLegacy).length;
            const errorMetrics = auditData.filter(item => !item.hasValue && !item.hasLegacy).length;
            
            document.getElementById('auditSummary').innerHTML = `
                <h3>üìä Resumo da Auditoria</h3>
                <p><strong>Total de m√©tricas:</strong> ${totalMetrics}</p>
                <p><strong>‚úÖ Corretas (novo backend):</strong> ${okMetrics}</p>
                <p><strong>‚ö†Ô∏è Apenas legado:</strong> ${warningMetrics}</p>
                <p><strong>‚ùå Ausentes:</strong> ${errorMetrics}</p>
                <p><strong>Taxa de sucesso:</strong> ${((okMetrics / totalMetrics) * 100).toFixed(1)}%</p>
            `;
        }
        
        function simulateAnalysis() {
            // Simular uma resposta do backend para teste
            const mockResponse = {
                success: true,
                analysis: {
                    fft: { magnitude: [], phase: [] },
                    spectralBands: {
                        bands: {
                            sub: { percentage: 8.5, energy: 0.024, frequencyRange: "20-60Hz" },
                            bass: { percentage: 18.2, energy: 0.156, frequencyRange: "60-150Hz" },
                            lowMid: { percentage: 22.1, energy: 0.198, frequencyRange: "150-500Hz" },
                            mid: { percentage: 24.7, energy: 0.234, frequencyRange: "500-2000Hz" },
                            highMid: { percentage: 15.8, energy: 0.142, frequencyRange: "2000-5000Hz" },
                            presence: { percentage: 8.9, energy: 0.078, frequencyRange: "5000-10000Hz" },
                            air: { percentage: 1.8, energy: 0.015, frequencyRange: "10000-20000Hz" }
                        },
                        totalPercentage: 100.0
                    },
                    spectralCentroid: {
                        centroidHz: 2847.3,
                        brightnessCategory: "Neutro"
                    },
                    lufs: {
                        integrated: -14.2,
                        shortTerm: -13.8,
                        momentary: -12.5,
                        lra: 5.2
                    },
                    truePeak: {
                        maxDbtp: -1.2,
                        maxLeft: -1.4,
                        maxRight: -1.2
                    },
                    stereo: {
                        correlation: 0.73,
                        width: 0.54
                    },
                    dynamics: {
                        dynamicRange: 8.4,
                        crestFactor: 12.6,
                        lra: 5.2
                    },
                    // Dados legados para compara√ß√£o
                    technicalData: {
                        lufs_integrated: -14.2,
                        truePeakDbtp: -1.2,
                        dynamicRange: 8.4,
                        crestFactor: 12.6,
                        stereoCorrelation: 0.73,
                        stereoWidth: 0.54,
                        spectralCentroid: 2847.3
                    }
                }
            };
            
            console.log('üß™ SIMULA√á√ÉO DE AN√ÅLISE:', mockResponse.analysis);
            lastBackendResponse = mockResponse.analysis;
            analyzeMappings(mockResponse.analysis);
            updateStatus('üß™ Simula√ß√£o executada', '#9b59b6');
        }
        
        async function compareWithRealBackend() {
            if (!lastBackendResponse) {
                alert('‚ùå Nenhuma resposta do backend capturada ainda. Execute uma an√°lise primeiro ou use a simula√ß√£o.');
                return;
            }
            
            // Aqui voc√™ pode implementar l√≥gica para comparar com chamadas reais
            console.log('üîß Comparando com backend real...', lastBackendResponse);
            
            // Simular verifica√ß√£o de inconsist√™ncias
            const inconsistencies = findInconsistencies(lastBackendResponse);
            
            if (inconsistencies.length > 0) {
                alert(`‚ö†Ô∏è Encontradas ${inconsistencies.length} inconsist√™ncias!\nVerifique o console para detalhes.`);
                console.warn('üö® INCONSIST√äNCIAS ENCONTRADAS:', inconsistencies);
            } else {
                alert('‚úÖ Nenhuma inconsist√™ncia encontrada!');
            }
        }
        
        function findInconsistencies(data) {
            const inconsistencies = [];
            
            // Verificar valores placeholder comuns
            const commonPlaceholders = [-60, 0, null, undefined];
            
            function checkValue(value, path) {
                if (commonPlaceholders.includes(value)) {
                    inconsistencies.push(`Valor placeholder encontrado em ${path}: ${value}`);
                }
                
                if (typeof value === 'number' && !isFinite(value)) {
                    inconsistencies.push(`Valor n√£o finito encontrado em ${path}: ${value}`);
                }
            }
            
            // Verificar recursivamente
            function traverse(obj, currentPath = '') {
                for (const [key, value] of Object.entries(obj)) {
                    const path = currentPath ? `${currentPath}.${key}` : key;
                    
                    if (typeof value === 'object' && value !== null) {
                        traverse(value, path);
                    } else {
                        checkValue(value, path);
                    }
                }
            }
            
            traverse(data);
            return inconsistencies;
        }
        
        function clearResults() {
            document.getElementById('auditResults').innerHTML = '';
            document.getElementById('auditSummary').innerHTML = `
                <h3>üìä Status da Auditoria</h3>
                <p>Execute uma an√°lise para iniciar a auditoria das m√©tricas</p>
            `;
            lastBackendResponse = null;
            lastUIRender = null;
        }
        
        // Inicializa√ß√£o autom√°tica
        window.addEventListener('load', function() {
            console.log('üîç Auditoria Backend vs UI carregada');
            console.log('üí° Use startInterceptor() para capturar respostas da API');
            
            // Auto-iniciar o interceptor
            setTimeout(() => {
                startInterceptor();
            }, 1000);
        });
    </script>
</body>
</html>