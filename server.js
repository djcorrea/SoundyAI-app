// server.js
import express from "express";
import cors from "cors";
import path from "path";
import { fileURLToPath } from "url";
import dotenv from "dotenv";

// üîë IMPORTANTE: Carregar .env ANTES de importar outros m√≥dulos
dotenv.config();

// üöÄ RAILWAY OPTIMIZATION: Logs cr√≠ticos m√≠nimos no boot
console.log("üèóÔ∏è [RAILWAY] Iniciando SoundyAI Server...");
console.log("üåê [ENV] PORT:", process.env.PORT || 'not-set');
console.log("üîß [ENV] NODE_ENV:", process.env.NODE_ENV || 'development');

const app = express();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// üöÄ RAILWAY: Configura√ß√£o b√°sica EXPRESS (r√°pida)
app.use(cors());
app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ extended: true, limit: "50mb" }));

// üéØ RAILWAY FIX: Health check INSTANT√ÇNEO (prioridade m√°xima)
app.get("/", (req, res) => {
  res.status(200).json({
    status: "‚úÖ SoundyAI API Online",
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    version: "1.0.0",
    port: process.env.PORT || 8080,
    uptime: Math.floor(process.uptime())
  });
});

// üöÄ RAILWAY: Configurar servidor IMEDIATAMENTE
const PORT = process.env.PORT || 8080;
const HOST = '0.0.0.0';

console.log(`üöÄ [BOOT] Iniciando servidor na porta ${PORT}...`);
console.log(`üåê [BOOT] Host: ${HOST}`);

const server = app.listen(PORT, HOST, () => {
  console.log(`\nüéâ [SUCCESS] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
  console.log(`‚úÖ [SUCCESS] SoundyAI Server ONLINE!`);
  console.log(`üöÄ Servidor SoundyAI rodando em http://${HOST}:${PORT}`);
  console.log(`üîó [HEALTH] Health check: http://${HOST}:${PORT}/`);
  console.log(`üïê [BOOT] Tempo de boot: ${Math.floor(process.uptime())}s`);
  console.log(`üéØ [RAILWAY] Health check pronto - sem 502!`);
  console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
  
  // üöÄ FASE 2: Inicializa√ß√£o ASS√çNCRONA de componentes pesados
  initializeHeavyComponents();
});

// üîß FUN√á√ÉO PARA INICIALIZAR COMPONENTES PESADOS AP√ìS SERVER ONLINE
async function initializeHeavyComponents() {
  console.log('üîß [ASYNC-INIT] Iniciando componentes ass√≠ncronos...');
  
  try {
    // Import din√¢mico de m√≥dulos pesados
    const [
      analyzeRoute,
      jobsRoute,
      analyzeController,
      analyzeStatus,
      fetch
    ] = await Promise.all([
      import("./api/audio/analyze.js"),
      import("./api/jobs/[id].js"),
      import("./api/analyze.controller.js"),
      import("./api/analyze.status.js"),
      import("node-fetch")
    ]);

    // üîç [RAILWAY] Verifica√ß√£o de vari√°veis cr√≠ticas
    console.log('\nüîß [ENV-CHECK] Verificando vari√°veis cr√≠ticas:');
    const criticalChecks = [
      { name: 'REDIS_HOST', value: process.env.REDIS_HOST, required: true },
      { name: 'REDIS_PORT', value: process.env.REDIS_PORT, required: true },
      { name: 'DATABASE_URL', value: process.env.DATABASE_URL, required: true },
      { name: 'OPENAI_API_KEY', value: process.env.OPENAI_API_KEY, required: true },
      { name: 'MP_ACCESS_TOKEN', value: process.env.MP_ACCESS_TOKEN, required: true }
    ];

    let missingCritical = 0;
    criticalChecks.forEach(check => {
      const exists = check.value && check.value !== '';
      const status = exists ? '‚úÖ' : '‚ùå';
      const display = exists ? 'configurada' : 'N√ÉO CONFIGURADA';
      console.log(`   ${status} ${check.name}: ${display}`);
      if (check.required && !exists) missingCritical++;
    });

    if (missingCritical > 0) {
      console.warn(`\n‚ö†Ô∏è [INIT] ${missingCritical} vari√°veis cr√≠ticas faltando (funcionalidade limitada)`);
    } else {
      console.log('\n‚úÖ [INIT] Todas as vari√°veis cr√≠ticas configuradas!');
    }

    // üëâ Configurar rotas b√°sicas de navega√ß√£o
    app.get("/landing", (req, res) => {
      res.sendFile(path.join(__dirname, "public", "landing.html"));
    });

    app.get(["/index", "/index.html", "/app", "/home"], (req, res) => {
      res.sendFile(path.join(__dirname, "public", "index.html"));
    });

    // üëâ Servir arquivos est√°ticos
    app.use(
      express.static(path.join(__dirname, "public"), {
        index: false,
      })
    );

    // üîß Import din√¢mico das rotas da API (n√£o bloqueia boot)
    const [
      cancelSubscriptionRoute,
      chatWithImagesRoute,
      chatRoute,
      createPreferenceRoute,
      deleteAccountRoute,
      mercadopagoRoute,
      uploadAudioRoute,
      uploadImageRoute,
      voiceMessageRoute,
      webhookRoute,
      presignRoute
    ] = await Promise.all([
      import("./api/cancel-subscription.js"),
      import("./api/chat-with-images.js"),
      import("./api/chat.js"),
      import("./api/create-preference.js"),
      import("./api/delete-account.js"),
      import("./api/mercadopago.js"),
      import("./api/upload-audio.js"),
      import("./api/upload-image.js"),
      import("./api/voice-message.js"),
      import("./api/webhook.js"),
      import("./api/presign.js")
    ]);

    // Montar rotas da API
    app.use("/api/cancel-subscription", cancelSubscriptionRoute.default);
    app.use("/api/chat-with-images", chatWithImagesRoute.default);
    app.use("/api/chat", chatRoute.default);
    app.use("/api/create-preference", createPreferenceRoute.default);
    app.use("/api/delete-account", deleteAccountRoute.default);
    app.use("/api/mercadopago", mercadopagoRoute.default);
    app.use("/api/upload-audio", uploadAudioRoute.default);
    app.use("/api/upload", uploadImageRoute.default);
    app.use("/api/voice", voiceMessageRoute.default);
    app.use("/api/webhook", webhookRoute.default);
    app.use("/api", presignRoute.default);

    // Rotas de an√°lise (componentes pesados)
    app.use("/api/audio", analyzeRoute.default);
    app.use("/api/jobs", jobsRoute.default);

    // üöÄ SISTEMA DE FILAS BULLMQ
    app.use("/api/analyze", analyzeController.default);
    app.use("/api/analyze", analyzeStatus.default);

    // ---------- ROTA DE CONFIGURA√á√ÉO DA API KEY ----------
    app.get("/api/config", (req, res) => {
      const openaiApiKey = process.env.OPENAI_API_KEY;
      
      if (openaiApiKey && openaiApiKey !== 'your_openai_api_key_here') {
        const masked = openaiApiKey.substring(0, 10) + '...';
        console.log('üîë [CONFIG-API] API Key dispon√≠vel:', masked);
        
        res.json({
          openaiApiKey: openaiApiKey,
          aiModel: process.env.AI_MODEL || 'gpt-3.5-turbo',
          configured: true
        });
      } else {
        console.warn('‚ö†Ô∏è [CONFIG-API] API Key N√ÉO configurada');
        res.json({
          openaiApiKey: 'not-configured',
          configured: false
        });
      }
    });

    // ---------- ROTA DE SUGEST√ïES IA ----------
    app.post("/api/suggestions", async (req, res) => {
      try {
        const { suggestions, metrics, genre } = req.body;

        console.log(`üöÄ [AI-API] Recebidas ${suggestions?.length || 0} sugest√µes para processamento`);

        if (!suggestions || !Array.isArray(suggestions) || suggestions.length === 0) {
          console.error("‚ùå [AI-API] Lista de sugest√µes inv√°lida");
          return res.status(400).json({ 
            error: "Lista de sugest√µes √© obrigat√≥ria e n√£o pode estar vazia",
            received: suggestions
          });
        }

        const openaiApiKey = process.env.OPENAI_API_KEY;
        if (!openaiApiKey || openaiApiKey === 'your_openai_api_key_here') {
          console.error("‚ö†Ô∏è [AI-API] OpenAI API Key n√£o configurada");
          return res.status(503).json({
            success: false,
            error: 'API Key da IA n√£o configurada',
            source: 'error',
            message: 'Configure OPENAI_API_KEY nas vari√°veis de ambiente'
          });
        }

        console.log(`üìã [AI-API] Construindo prompt para ${suggestions.length} sugest√µes do g√™nero: ${genre || 'geral'}`);

        const prompt = buildSuggestionPrompt(suggestions, metrics, genre);
        console.log(`ü§ñ [AI-API] Enviando prompt para OpenAI...`);

        const openaiResponse = await fetch.default('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openaiApiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            messages: [
              {
                role: 'system',
                content: `Voc√™ √© um ENGENHEIRO DE MIXAGEM/MASTERIZA√á√ÉO de n√≠vel Grammy especializado em produ√ß√£o eletr√¥nica.

üéØ MISS√ÉO: Gerar sugest√µes ULTRA-PR√ÅTICAS, COERENTES e RICAS EM DETALHES.

‚ö†Ô∏è REGRAS DE COER√äNCIA ABSOLUTA:
1. "problema" DEVE conter: Nome EXATO da m√©trica/banda + valor medido + refer√™ncia ideal + diferen√ßa
2. "causa" DEVE explicar: POR QU√ä esse valor espec√≠fico causa problema (t√©cnico + musical)
3. "solucao" DEVE conter: Passo a passo DETALHADO com valores exatos de ajuste

‚ö†Ô∏è FORMATO JSON:
- Responda EXCLUSIVAMENTE com JSON V√ÅLIDO (sem markdown, sem texto extra)
- ARRAY com exatamente N itens (N = n√∫mero de sugest√µes recebidas)
- Estrutura obrigat√≥ria:
{
  "problema": "[Nome Exato da M√©trica] est√° em [Valor Medido] quando deveria estar em [Valor Ideal], diferen√ßa de [Delta] (ex: 'Bass (60-150Hz) est√° em -31.8 dB quando deveria estar entre -31 e -25 dB, ou seja, 0.8 dB abaixo do m√≠nimo')",
  "causa": "Explica√ß√£o DIRETA de por que esse valor ESPEC√çFICO causa problema (ex: 'Bass -31.8 dB est√° abafado demais, fazendo o kick perder punch e energia. Isso reduz impacto em sistemas de som e deixa a faixa sem peso nos graves')",
  "solucao": "Instru√ß√µes RICAS E DETALHADAS: '1. Abrir [Plugin Espec√≠fico] no canal [X]. 2. Selecionar banda [Y]. 3. Configurar Freq: [valor]Hz, Gain: +[valor]dB, Q: [valor]. 4. Ajustar at√© [resultado esperado]. 5. A/B test com refer√™ncia.' SEMPRE indique valores EXATOS de corte/boost em dB",
  "dica_extra": "Truque profissional adicional com contexto do g√™nero musical",
  "plugin": "Nome comercial real (ex: FabFilter Pro-Q3 $179) + alternativa gr√°tis (ex: TDR Nova GE gr√°tis)",
  "resultado": "Benef√≠cio MENSUR√ÅVEL e AUD√çVEL (ex: 'Kick +35% mais presente, bass com peso adequado, mix equilibrado com refer√™ncias do g√™nero')"
}

üéØ DIRETRIZES FINAIS:
- Use SEMPRE valores EXATOS dos dados fornecidos
- "problema" = m√©trica + valor atual + valor ideal + diferen√ßa matem√°tica
- "causa" = impacto t√©cnico + impacto musical desse valor ESPEC√çFICO
- "solucao" = passo a passo RICO com valores precisos de ajuste
- Mencione o g√™nero musical quando relevante
- Indique EXATAMENTE quanto cortar/boostar (ex: "reduzir -2.5 dB em 150Hz com Q=2.0")
- Plugins: sempre nome comercial + pre√ßo + alternativa gr√°tis
`
              },
              {
                role: 'user', 
                content: prompt
              }
            ],
            temperature: 0.4,
            max_tokens: 4500,
            top_p: 0.95,
            frequency_penalty: 0.2,
            presence_penalty: 0.1
          })
        });

        if (!openaiResponse.ok) {
          console.error("‚ùå Erro na API da OpenAI:", openaiResponse.status, openaiResponse.statusText);
          throw new Error(`OpenAI API retornou ${openaiResponse.status}`);
        }

        const openaiData = await openaiResponse.json();
        let aiSuggestion = openaiData.choices[0]?.message?.content || "";

        aiSuggestion = aiSuggestion
          .replace(/```json/gi, "")
          .replace(/```/g, "")
          .replace(/[\u0000-\u001F]+/g, "")
          .trim();

        if (!aiSuggestion) {
          throw new Error('Resposta vazia da IA');
        }

        const expected = suggestions.length;
        const { items: parsedItems, repaired } = safeParseEnrichedArray(aiSuggestion, expected);
        console.log(`[AI-PROCESSING] JSON ${repaired ? 'REPARADO' : 'OK'} - itens parseados: ${parsedItems.length}/${expected}`);

        let enhancedSuggestions = ensureCardinality(parsedItems, suggestions);

        let normalizedCount = 0;
        enhancedSuggestions = enhancedSuggestions.map((sug) => {
          const isAI = sug.ai_enhanced === true;
          const rootPriority = typeof sug.priority === 'string' ? sug.priority : (isAI ? 'alta' : undefined);
          const meta = sug.metadata || {};
          const metaPriority = typeof meta.priority === 'string' ? meta.priority : (isAI ? 'alta' : undefined);
          if (isAI && (rootPriority !== 'alta' || metaPriority !== 'alta')) normalizedCount++;
          return {
            ...sug,
            priority: rootPriority || (isAI ? 'alta' : 'm√©dia'),
            metadata: { ...meta, priority: metaPriority || (isAI ? 'alta' : 'm√©dia') },
          };
        });
        console.log(`[AI-NORMALIZE] priority aplicados (alta) nas enriquecidas: ${normalizedCount}`);

        console.log(`‚úÖ [AI-API] Processamento conclu√≠do:`, {
          suggestionsOriginais: suggestions.length,
          suggestionsEnriquecidas: enhancedSuggestions.length,
          sucessoTotal: enhancedSuggestions.length === suggestions.length ? 'SIM' : 'PARCIAL'
        });

        const finalEnhanced = enhancedSuggestions.map((sug) => ({
          ...sug,
          metadata: {
            ...(sug.metadata || {}),
            priority: typeof sug?.metadata?.priority === 'string' ? sug.metadata.priority : 'alta',
          },
        }));

        res.json({
          success: true,
          enhancedSuggestions: finalEnhanced,
          source: 'ai',
          message: `${finalEnhanced.length} sugest√µes enriquecidas pela IA`,
          metadata: {
            originalCount: suggestions.length,
            enhancedCount: finalEnhanced.length,
            genre: genre || 'n√£o especificado',
            processingTime: Date.now(),
            aiSuccess: finalEnhanced.filter(s=>s.ai_enhanced === true).length,
            aiErrors: Math.max(0, suggestions.length - finalEnhanced.filter(s=>s.ai_enhanced === true).length)
          }
        });

      } catch (error) {
        console.error("‚ùå [AI-API] Erro cr√≠tico no processamento:", error.message);
        const originals = Array.isArray(req.body?.suggestions) ? req.body.suggestions : [];
        const fallback = originals.map((s) => fallbackFromOriginal(s));
        console.log(`[AI-PROCESSING] Fallback total aplicado: ${fallback.length}/${originals.length}`);
        res.status(200).json({
          success: true,
          enhancedSuggestions: fallback,
          source: 'ai',
          message: `${fallback.length} sugest√µes (fallback) enviadas`,
          metadata: {
            originalCount: originals.length,
            enhancedCount: fallback.length,
            aiSuccess: 0,
            aiErrors: originals.length
          }
        });
      }
    });

    // üëâ Fallback SPA
    app.get("*", (req, res, next) => {
      if (req.path.startsWith("/api/")) return next();
      res.sendFile(path.join(__dirname, "public", "index.html"));
    });

    // üö® MIDDLEWARE DE ERROR HANDLING GLOBAL
    app.use((err, req, res, next) => {
      console.error('üí• [ERROR] Erro n√£o tratado:', err.message);
      console.error('üîç [ERROR] Stack:', err.stack);
      console.error('üìç [ERROR] URL:', req.url);
      
      res.status(err.status || 500).json({
        error: 'Erro interno do servidor',
        message: process.env.NODE_ENV === 'development' ? err.message : 'Algo deu errado',
        timestamp: new Date().toISOString(),
        path: req.path
      });
    });

    // üö® MIDDLEWARE 404 - DEVE VIR POR √öLTIMO
    app.use((req, res) => {
      console.log(`‚ö†Ô∏è [404] Rota n√£o encontrada: ${req.method} ${req.path}`);
      res.status(404).json({
        error: 'Rota n√£o encontrada',
        method: req.method,
        path: req.path,
        timestamp: new Date().toISOString()
      });
    });

    // üß™ DESENVOLVIMENTO: Executar testes se n√£o for produ√ß√£o
    if (process.env.NODE_ENV !== 'production') {
      console.log('üîß [DEV] Executando testes de valida√ß√£o...');
      try {
        testRealisticSuggestions();
        console.log('‚úÖ [DEV] Testes conclu√≠dos com sucesso');
      } catch (error) {
        console.error('‚ùå [DEV] Erro nos testes:', error.message);
      }
    }

    console.log('\nüìã [STATUS] Sistema totalmente inicializado:');
    console.log(`   ‚úÖ Express server running`);
    console.log(`   ‚úÖ Health check instant response`);
    console.log(`   ‚úÖ API routes mounted`);
    console.log(`   ‚úÖ Static files serving`);
    console.log(`   ‚úÖ Error handling middleware`);
    console.log(`   ‚úÖ 404 fallback route`);
    console.log('\nüéØ [READY] Sistema totalmente operacional!');

  } catch (error) {
    console.error('‚ùå [INIT-ERROR] Erro na inicializa√ß√£o de componentes pesados:', error.message);
    console.log('‚ö†Ô∏è [INIT-ERROR] Servidor continua funcionando com funcionalidade limitada');
  }
}

// ---------- ROTA DE CONFIGURA√á√ÉO DA API KEY (RAILWAY) ----------
app.get("/api/config", (req, res) => {
  const openaiApiKey = process.env.OPENAI_API_KEY;
  
  // Nunca expor a chave completa, apenas confirmar que existe
  if (openaiApiKey && openaiApiKey !== 'your_openai_api_key_here') {
    // Retornar apenas os primeiros 10 caracteres + hash para valida√ß√£o
    const masked = openaiApiKey.substring(0, 10) + '...';
    console.log('üîë [CONFIG-API] API Key dispon√≠vel:', masked);
    
    res.json({
      openaiApiKey: openaiApiKey, // üö® FRONTEND PRECISA DA CHAVE COMPLETA PARA CHAMAR OPENAI
      aiModel: process.env.AI_MODEL || 'gpt-3.5-turbo',
      configured: true
    });
  } else {
    console.warn('‚ö†Ô∏è [CONFIG-API] API Key N√ÉO configurada no Railway');
    res.json({
      openaiApiKey: 'not-configured',
      configured: false
    });
  }
});

// ---------- ROTA REVOLUCION√ÅRIA DE SUGEST√ïES IA ----------
app.post("/api/suggestions", async (req, res) => {
  try {
    const { suggestions, metrics, genre } = req.body;

    console.log(`üöÄ [AI-API] Recebidas ${suggestions?.length || 0} sugest√µes para processamento`);

    // Valida√ß√£o dos dados de entrada
    if (!suggestions || !Array.isArray(suggestions) || suggestions.length === 0) {
      console.error("‚ùå [AI-API] Lista de sugest√µes inv√°lida");
      return res.status(400).json({ 
        error: "Lista de sugest√µes √© obrigat√≥ria e n√£o pode estar vazia",
        received: suggestions
      });
    }

    // Se n√£o tiver API key, retornar erro (n√£o fallback)
    const openaiApiKey = process.env.OPENAI_API_KEY;
    if (!openaiApiKey || openaiApiKey === 'your_openai_api_key_here') {
      console.error("‚ö†Ô∏è [AI-API] OpenAI API Key n√£o configurada");
      return res.status(503).json({
        success: false,
        error: 'API Key da IA n√£o configurada',
        source: 'error',
        message: 'Configure OPENAI_API_KEY nas vari√°veis de ambiente'
      });
    }

    console.log(`üìã [AI-API] Construindo prompt para ${suggestions.length} sugest√µes do g√™nero: ${genre || 'geral'}`);

    // Construir prompt para TODAS as sugest√µes
    const prompt = buildSuggestionPrompt(suggestions, metrics, genre);

    console.log(`ü§ñ [AI-API] Enviando prompt para OpenAI...`);

    // Chamar OpenAI
    const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini', // üöÄ UPGRADE: Modelo mais inteligente e barato,
        messages: [
          {
            role: 'system',
                        content: `Voc√™ √© um ENGENHEIRO DE MIXAGEM/MASTERIZA√á√ÉO de n√≠vel Grammy especializado em produ√ß√£o eletr√¥nica.

üéØ MISS√ÉO: Gerar sugest√µes ULTRA-PR√ÅTICAS, COERENTES e RICAS EM DETALHES.

‚ö†Ô∏è REGRAS DE COER√äNCIA ABSOLUTA:
1. "problema" DEVE conter: Nome EXATO da m√©trica/banda + valor medido + refer√™ncia ideal + diferen√ßa
2. "causa" DEVE explicar: POR QU√ä esse valor espec√≠fico causa problema (t√©cnico + musical)
3. "solucao" DEVE conter: Passo a passo DETALHADO com valores exatos de ajuste

‚ö†Ô∏è FORMATO JSON:
- Responda EXCLUSIVAMENTE com JSON V√ÅLIDO (sem markdown, sem texto extra)
- ARRAY com exatamente N itens (N = n√∫mero de sugest√µes recebidas)
- Estrutura obrigat√≥ria:
{
  "problema": "[Nome Exato da M√©trica] est√° em [Valor Medido] quando deveria estar em [Valor Ideal], diferen√ßa de [Delta] (ex: 'Bass (60-150Hz) est√° em -31.8 dB quando deveria estar entre -31 e -25 dB, ou seja, 0.8 dB abaixo do m√≠nimo')",
  "causa": "Explica√ß√£o DIRETA de por que esse valor ESPEC√çFICO causa problema (ex: 'Bass -31.8 dB est√° abafado demais, fazendo o kick perder punch e energia. Isso reduz impacto em sistemas de som e deixa a faixa sem peso nos graves')",
  "solucao": "Instru√ß√µes RICAS E DETALHADAS: '1. Abrir [Plugin Espec√≠fico] no canal [X]. 2. Selecionar banda [Y]. 3. Configurar Freq: [valor]Hz, Gain: +[valor]dB, Q: [valor]. 4. Ajustar at√© [resultado esperado]. 5. A/B test com refer√™ncia.' SEMPRE indique valores EXATOS de corte/boost em dB",
  "dica_extra": "Truque profissional adicional com contexto do g√™nero musical",
  "plugin": "Nome comercial real (ex: FabFilter Pro-Q3 $179) + alternativa gr√°tis (ex: TDR Nova GE gr√°tis)",
  "resultado": "Benef√≠cio MENSUR√ÅVEL e AUD√çVEL (ex: 'Kick +35% mais presente, bass com peso adequado, mix equilibrado com refer√™ncias do g√™nero')"
}

üìä EXEMPLOS DE COER√äNCIA:

‚ùå ERRADO (gen√©rico):
{
  "problema": "LUFS fora do ideal",
  "causa": "Pode resultar em mix com baixa presen√ßa",
  "solucao": "Considere aumentar entre 4.0 a 5.0 LUFS"
}

‚úÖ CORRETO (espec√≠fico e coerente):
{
  "problema": "LUFS Integrado est√° em -16.5 dB quando deveria estar em -10.5 dB para Tech House, diferen√ßa de -6.0 dB (muito baixo)",
  "causa": "LUFS -16.5 dB faz a faixa soar 40% mais fraca que competidores em playlists. O limitador est√° ajustado muito conservador, deixando +6 dB de headroom n√£o utilizado. Isso reduz impacto, energia e competitividade em sistemas de som",
  "solucao": "1. Abrir Limiter no √∫ltimo slot do Master (FabFilter Pro-L2 ou TDR Limiter 6 GE). 2. Configurar True Peak Ceiling: -1.0 dBTP. 3. Ativar Lookahead: 4ms e Oversampling: 4x. 4. Aumentar Output Gain gradualmente em +6.0 dB. 5. Monitorar LUFS Meter at√© atingir -10.5 LUFS. 6. Se houver pumping, reduzir Attack para 1ms. 7. A/B test com 3 refer√™ncias comerciais",
  "plugin": "FabFilter Pro-L2 ($199) ou TDR Limiter 6 GE (gr√°tis)",
  "resultado": "Loudness competitivo de -10.5 LUFS, +40% de impacto percebido, mix com energia igual a faixas top 100"
}

üéØ DIRETRIZES FINAIS:
- Use SEMPRE valores EXATOS dos dados fornecidos
- "problema" = m√©trica + valor atual + valor ideal + diferen√ßa matem√°tica
- "causa" = impacto t√©cnico + impacto musical desse valor ESPEC√çFICO
- "solucao" = passo a passo RICO com valores precisos de ajuste
- Mencione o g√™nero musical quando relevante
- Indique EXATAMENTE quanto cortar/boostar (ex: "reduzir -2.5 dB em 150Hz com Q=2.0")
- Plugins: sempre nome comercial + pre√ßo + alternativa gr√°tis
`
          },
          {
            role: 'user', 
            content: prompt
          }
        ],
        temperature: 0.4,
        max_tokens: 4500, // üöÄ Mais tokens para respostas detalhadas
        top_p: 0.95,
        frequency_penalty: 0.2,
        presence_penalty: 0.1
      })
    });

    if (!openaiResponse.ok) {
      console.error("‚ùå Erro na API da OpenAI:", openaiResponse.status, openaiResponse.statusText);
      throw new Error(`OpenAI API retornou ${openaiResponse.status}`);
    }

    const openaiData = await openaiResponse.json();
    let aiSuggestion = openaiData.choices[0]?.message?.content || "";

    // üîí Sanitiza√ß√£o extra antes do parse
    aiSuggestion = aiSuggestion
      .replace(/```json/gi, "")
      .replace(/```/g, "")
      .replace(/[\u0000-\u001F]+/g, "")
      .trim();

    if (!aiSuggestion) {
      throw new Error('Resposta vazia da IA');
    }

    // Processar resposta da IA (JSON array com itens enriquecidos)
    const expected = suggestions.length;
    const { items: parsedItems, repaired } = safeParseEnrichedArray(aiSuggestion, expected);
    console.log(`[AI-PROCESSING] JSON ${repaired ? 'REPARADO' : 'OK'} - itens parseados: ${parsedItems.length}/${expected}`);

    // Garantir cardinalidade: preencher faltantes com fallback das originais
    let enhancedSuggestions = ensureCardinality(parsedItems, suggestions);

    // Normaliza√ß√£o de prioridade
    let normalizedCount = 0;
    enhancedSuggestions = enhancedSuggestions.map((sug) => {
      const isAI = sug.ai_enhanced === true;
      const rootPriority = typeof sug.priority === 'string' ? sug.priority : (isAI ? 'alta' : undefined);
      const meta = sug.metadata || {};
      const metaPriority = typeof meta.priority === 'string' ? meta.priority : (isAI ? 'alta' : undefined);
      if (isAI && (rootPriority !== 'alta' || metaPriority !== 'alta')) normalizedCount++;
      return {
        ...sug,
        priority: rootPriority || (isAI ? 'alta' : 'm√©dia'),
        metadata: { ...meta, priority: metaPriority || (isAI ? 'alta' : 'm√©dia') },
      };
    });
    console.log(`[AI-NORMALIZE] priority aplicados (alta) nas enriquecidas: ${normalizedCount}`);

    console.log(`‚úÖ [AI-API] Processamento conclu√≠do:`, {
      suggestionsOriginais: suggestions.length,
      suggestionsEnriquecidas: enhancedSuggestions.length,
      sucessoTotal: enhancedSuggestions.length === suggestions.length ? 'SIM' : 'PARCIAL'
    });

    // Garantir que todas t√™m priority string antes de enviar
    const finalEnhanced = enhancedSuggestions.map((sug) => ({
      ...sug,
      metadata: {
        ...(sug.metadata || {}),
        priority: typeof sug?.metadata?.priority === 'string' ? sug.metadata.priority : 'alta',
      },
    }));

    res.json({
      success: true,
      enhancedSuggestions: finalEnhanced,
      source: 'ai',
      message: `${finalEnhanced.length} sugest√µes enriquecidas pela IA`,
      metadata: {
        originalCount: suggestions.length,
        enhancedCount: finalEnhanced.length,
        genre: genre || 'n√£o especificado',
        processingTime: Date.now(),
        aiSuccess: finalEnhanced.filter(s=>s.ai_enhanced === true).length,
        aiErrors: Math.max(0, suggestions.length - finalEnhanced.filter(s=>s.ai_enhanced === true).length)
      }
    });

  } catch (error) {
    console.error("‚ùå [AI-API] Erro cr√≠tico no processamento:", error.message);
    const originals = Array.isArray(req.body?.suggestions) ? req.body.suggestions : [];
    const fallback = originals.map((s) => fallbackFromOriginal(s));
    console.log(`[AI-PROCESSING] Fallback total aplicado: ${fallback.length}/${originals.length}`);
    res.status(200).json({
      success: true,
      enhancedSuggestions: fallback,
      source: 'ai',
      message: `${fallback.length} sugest√µes (fallback) enviadas`,
      metadata: {
        originalCount: originals.length,
        enhancedCount: fallback.length,
        aiSuccess: 0,
        aiErrors: originals.length
      }
    });
  }
});

// üéõÔ∏è Fun√ß√£o auxiliar para garantir caps por banda (limites m√°ximos em dB)
function clampDeltaByBand(band, delta) {
  const caps = {
    sub: 6, bass: 6, low_mid: 5, mid: 5, high_mid: 5, presence: 5, air: 4,
    lowMid: 5, highMid: 5, presenca: 5, brilho: 4
  };
  
  const maxCap = caps[band] || 5;
  return Math.max(-maxCap, Math.min(maxCap, delta));
}

// üìä Fun√ß√£o para calcular ajuste proporcional baseado no delta
function calculateProportionalAdjustment(delta, band) {
  const caps = {
    sub: 6, bass: 6, low_mid: 5, mid: 5, high_mid: 5, presence: 5, air: 4,
    lowMid: 5, highMid: 5, presenca: 5, brilho: 4
  };
  
  const clampedDelta = clampDeltaByBand(band, delta);
  const absDelta = Math.abs(clampedDelta);
  
  let minAdjust, maxAdjust;
  
  if (absDelta <= 3) {
    minAdjust = Math.max(1, Math.floor(absDelta * 0.3));
    maxAdjust = Math.max(2, Math.ceil(absDelta * 0.6));
  } else if (absDelta <= 6) {
    minAdjust = Math.max(2, Math.floor(absDelta * 0.5));
    maxAdjust = Math.max(3, Math.ceil(absDelta * 0.75));
  } else {
    minAdjust = Math.max(3, Math.floor(absDelta * 0.75));
    maxAdjust = Math.min(caps[band] || 5, Math.ceil(absDelta * 1.0));
  }
  
  const maxCap = caps[band] || 5;
  minAdjust = Math.min(minAdjust, maxCap);
  maxAdjust = Math.min(maxAdjust, maxCap);
  
  const sign = clampedDelta >= 0 ? '+' : '-';
  
  return {
    range: `${sign}${minAdjust} a ${sign}${maxAdjust} dB`,
    direction: clampedDelta > 0 ? 'refor√ßar' : 'reduzir',
    intensity: absDelta <= 3 ? 'suavemente' : absDelta <= 6 ? 'moderadamente' : 'com mais √™nfase'
  };
}

// üîß Fun√ß√£o para preprocessar sugest√µes aplicando caps e calculando ajustes proporcionais
function preprocessSuggestions(suggestions) {
  return suggestions.map((s, i) => {
    let enhancedSuggestion = { ...s };
    
    if (s.technical && s.technical.delta && s.subtype) {
      const band = s.subtype.toLowerCase();
      const adjustment = calculateProportionalAdjustment(s.technical.delta, band);
      
      enhancedSuggestion.adjustmentGuide = {
        originalDelta: s.technical.delta,
        suggestedRange: adjustment.range,
        direction: adjustment.direction,
        intensity: adjustment.intensity,
        band: band
      };
    }
    
    return enhancedSuggestion;
  });
}

// Fun√ß√£o para construir o prompt da IA
function buildSuggestionPrompt(suggestions, metrics, genre) {
  const preprocessedSuggestions = preprocessSuggestions(suggestions);
  
  const suggestionsList = preprocessedSuggestions.map((s, i) => {
    let baseSuggestion = `${i + 1}. ${s.message || s.title || 'Sugest√£o'} - ${s.action || s.description || 'Sem a√ß√£o definida'}`;
    
    if (s.adjustmentGuide) {
      baseSuggestion += ` [AJUSTE CALCULADO: ${s.adjustmentGuide.direction} ${s.adjustmentGuide.suggestedRange} na banda ${s.adjustmentGuide.band}]`;
    }
    
    baseSuggestion += ` (Prioridade: ${s.priority || 5}, Confian√ßa: ${s.confidence || 0.5})`;
    return baseSuggestion;
  }).join('\n');

  const metricsInfo = metrics ? `
üîä AN√ÅLISE ESPECTRAL DETALHADA:
- LUFS Integrado: ${metrics.lufsIntegrated || 'N/A'} dB
- True Peak: ${metrics.truePeakDbtp || 'N/A'} dBTP
- Dynamic Range: ${metrics.dynamicRange || 'N/A'} LU
- Correla√ß√£o Est√©reo: ${metrics.stereoCorrelation || 'N/A'}
- LRA: ${metrics.lra || 'N/A'} LU
` : '';

  const genreContext = getGenreContext(genre);
  const expected = suggestions.length;
  
  return `
üéõÔ∏è ANALISE ESTAS DETEC√á√ïES PARA ${(genre || 'm√∫sica geral').toUpperCase()} E GERE SUGEST√ïES REALISTAS E EDUCATIVAS.

‚ö†Ô∏è REGRAS ABSOLUTAS:
- Responda EXCLUSIVAMENTE com um JSON V√ÅLIDO (ARRAY com exatamente ${expected} itens).
- Sugest√µes devem ser sempre EDUCATIVAS e ORIENTATIVAS, nunca imperativas.
- Ajustes PROPORCIONAIS √† diferen√ßa medida (quanto maior o delta, maior o ajuste).
- NUNCA sugerir mais que os limites por banda:
  ‚Ä¢ Sub/Bass (20‚Äì150Hz): m√°ximo ¬±6 dB
  ‚Ä¢ M√©dios (150Hz‚Äì5kHz): m√°ximo ¬±5 dB  
  ‚Ä¢ Agudos (5kHz+): m√°ximo ¬±4 dB
- Sempre incluir faixa de dB em formato "entre -X e -Y dB" ou "entre +X e +Y dB".
- NUNCA valores fixos, sempre ranges orientativos.

üéØ SUGEST√ïES ORIGINAIS DETECTADAS:
${suggestionsList}

üîä CONTEXTO T√âCNICO DETALHADO:
${metricsInfo}

üéµ DIRETRIZES ESPEC√çFICAS DO G√äNERO:
${genreContext}
`;
}

// Fun√ß√£o para obter contexto educativo e musical do g√™nero
function getGenreContext(genre) {
  const contexts = {
    funk_mandela: `
üéµ CONTEXTO FUNK MANDELA - LINGUAGEM E PRIORIDADES:
- LINGUAGEM: Use termos do funk ("grave pesado", "vocal cristalino", "pancada no peito")
- SUB/BASS (20-150Hz): PRIORIT√ÅRIO - Deve "bater no peito" sem mascarar o kick
- M√âDIOS (200Hz-2kHz): Vocal sempre em evid√™ncia, cuidado com m√°scara
- AGUDOS (5-15kHz): Controlado, nunca agressivo
- TARGETS: DR 4-6 | True Peak -1dBTP | LUFS -8 a -12`,
    
    trance: `
üéµ CONTEXTO TRANCE - LINGUAGEM E PRIORIDADES:  
- LINGUAGEM: Use termos eletr√¥nicos ("kick punchy", "lead cortante", "atmosfera ampla")
- SUB (20-60Hz): Limpo e controlado para n√£o competir com kick
- KICK (60-120Hz): Deve ser o protagonista dos graves
- LEADS (2-8kHz): Brilhantes mas n√£o agressivos, com espa√ßo para vocal
- TARGETS: DR 3-5 | True Peak -0.5dBTP | LUFS -6 a -9`,
    
    electronic: `
üéµ CONTEXTO ELETR√îNICO GERAL:
- LINGUAGEM: "Precis√£o digital", "punch eletr√¥nico", "clareza sint√©tica"
- SUB (20-80Hz): Controlado digitalmente, mono perfeito
- M√âDIOS: Separa√ß√£o precisa entre elementos sint√©ticos  
- AGUDOS: Cristalinos mas n√£o met√°licos
- TARGETS: DR 4-8 | True Peak -1dBTP | LUFS -8 a -12`,

    hip_hop: `
üéµ CONTEXTO HIP HOP:
- LINGUAGEM: "Boom bap", "vocal na frente", "groove pesado"
- SUB/KICK: Deve "bater forte" sem distor√ß√£o
- VOCAL: SEMPRE protagonista, clareza total
- SAMPLES: Preserve car√°ter original, evite over-processing
- TARGETS: DR 5-8 | True Peak -1dBTP | LUFS -9 a -13`
  };
  
  return contexts[genre] || contexts[detectGenreType(genre)] || `
üéµ CONTEXTO MUSICAL GERAL:
- LINGUAGEM: Seja educativo e musical, evite jarg√µes t√©cnicos pesados
- GRAVES: Balance presen√ßa vs. limpeza, preserve groove natural
- M√âDIOS: Foque na inteligibilidade, evite m√°scara entre elementos
- AGUDOS: Brilho sem agressividade, preserve naturalidade
- FILOSOFIA: "Realce a musicalidade, preserve a emo√ß√£o"
- RESULTADO: "Mix equilibrado, musical e profissional"`;
}

// Fun√ß√£o auxiliar para detectar tipo de g√™nero
function detectGenreType(genre) {
  if (!genre) return null;
  
  const genreLower = genre.toLowerCase();
  
  if (genreLower.includes('funk') || genreLower.includes('mandela')) return 'funk_mandela';
  if (genreLower.includes('trance') || genreLower.includes('progressive')) return 'trance';  
  if (genreLower.includes('brux') || genreLower.includes('ambient')) return 'bruxaria';
  if (genreLower.includes('electronic') || genreLower.includes('edm') || genreLower.includes('house')) return 'electronic';
  if (genreLower.includes('hip') || genreLower.includes('rap') || genreLower.includes('trap')) return 'hip_hop';
  
  return null;
}

// üß™ Fun√ß√£o de teste para validar caps e proporcionalidade
function testRealisticSuggestions() {
  console.log('üß™ [TESTE] Validando sistema de caps e proporcionalidade...');
  
  const testCases = [
    { band: 'sub', delta: -2.5, expected: 'ajuste m√≠nimo (1-2 dB)' },
    { band: 'bass', delta: -7.0, expected: 'ajuste m√°ximo limitado ao cap (6 dB)' },
    { band: 'mid', delta: 4.5, expected: 'ajuste intermedi√°rio (2-4 dB)' },
    { band: 'presence', delta: -12.0, expected: 'ajuste m√°ximo limitado ao cap (5 dB)' },
    { band: 'air', delta: 2.0, expected: 'ajuste m√≠nimo (1-2 dB)' }
  ];
  
  testCases.forEach(test => {
    const clampedDelta = clampDeltaByBand(test.band, test.delta);
    const adjustment = calculateProportionalAdjustment(test.delta, test.band);
    
    console.log(`üìä Banda: ${test.band} | Delta original: ${test.delta} dB`);
    console.log(`   ‚úÇÔ∏è Delta limitado: ${clampedDelta} dB`);
    console.log(`   üéØ Ajuste sugerido: ${adjustment.range}`);
    console.log(`   üìù Esperado: ${test.expected}`);
    console.log(`   ‚úÖ Status: ${Math.abs(clampedDelta) <= (test.band === 'air' ? 4 : test.band.includes('mid') || test.band === 'presence' ? 5 : 6) ? 'PASSOU' : 'FALHOU'}\n`);
  });
  
  return true;
}

// Helpers de parse e fallback
function safeParseEnrichedArray(aiContent, expectedLength) {
  let repaired = false;
  try {
    const clean = aiContent.replace(/```json\n?|```/g, '').trim();
    const parsed = JSON.parse(clean);
    if (Array.isArray(parsed)) return { items: parsed, repaired };
    if (parsed && Array.isArray(parsed.suggestions)) return { items: parsed.suggestions, repaired };
    throw new Error('Formato inv√°lido: n√£o √© array');
  } catch (e1) {
    try {
      const onlyArray = extractJsonArray(aiContent);
      const fixed = fixTrailingCommas(onlyArray);
      const parsed2 = JSON.parse(fixed);
      repaired = true;
      if (Array.isArray(parsed2)) return { items: parsed2, repaired };
      return { items: [], repaired };
    } catch (e2) {
      console.error('[AI-PROCESSING] Falha no parse/reparo de JSON:', e1.message, '|', e2.message);
      return { items: [], repaired };
    }
  }
}

function extractJsonArray(text) {
  const start = text.indexOf('[');
  const end = text.lastIndexOf(']');
  if (start === -1 || end === -1 || end <= start) throw new Error('Array n√£o encontrado');
  return text.slice(start, end + 1);
}

function fixTrailingCommas(jsonStr) {
  return jsonStr
    .replace(/,\s*([\]}])/g, '$1')
    .replace(/\u0000/g, '');
}

function ensureCardinality(parsedItems, originalSuggestions) {
  const expected = originalSuggestions.length;
  const result = [];
  for (let i = 0; i < expected; i++) {
    const aiItem = parsedItems[i];
    if (aiItem && typeof aiItem === 'object') {
      result.push(normalizeEnrichedItem(aiItem, true));
    } else {
      result.push(fallbackFromOriginal(originalSuggestions[i]));
    }
  }
  return result;
}

function normalizeEnrichedItem(item, aiEnhanced) {
  return {
    problema: item.problema || '',
    causa: item.causa || '',
    solucao: item.solucao || '',
    dica_extra: item.dica_extra || '',
    plugin: item.plugin || '',
    resultado: item.resultado || '',
    ai_enhanced: aiEnhanced === true,
    priority: 'alta',
    metadata: { priority: 'alta' }
  };
}

function fallbackFromOriginal(s) {
  return {
    problema: `‚ö†Ô∏è ${s.message || s.title || 'Problema detectado'}`,
    causa: 'An√°lise autom√°tica identificou desvio dos padr√µes de refer√™ncia',
    solucao: `üõ†Ô∏è ${s.action || s.description || 'Ajuste recomendado pelo sistema'}`,
    dica_extra: 'üí° Valide em diferentes sistemas de √°udio',
    plugin: 'üéπ EQ/Compressor nativo da DAW ou gratuito',
    resultado: '‚úÖ Melhoria de clareza e compatibilidade',
    ai_enhanced: false,
    priority: 'm√©dia',
    metadata: { priority: 'm√©dia' }
  };
}

// üõ°Ô∏è RAILWAY: Graceful shutdown handling
process.on('SIGTERM', () => {
  console.log('üì° [SHUTDOWN] SIGTERM recebido, encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ [SHUTDOWN] Servidor encerrado gracefully');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('üì° [SHUTDOWN] SIGINT recebido, encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ [SHUTDOWN] Servidor encerrado gracefully');
    process.exit(0);
  });
});

// üö® RAILWAY: Error handling para crashes
process.on('uncaughtException', (error) => {
  console.error('üí• [CRASH] Uncaught Exception:', error);
  console.error('üîç [CRASH] Stack:', error.stack);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• [CRASH] Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

export default app;