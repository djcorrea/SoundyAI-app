<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste - RestauraÃ§Ã£o Mensagens IA</title>
    <!-- Sistema Centralizado de Logs -->
    <script src="logger.js"></script>
    <script>
        // Importar funÃ§Ãµes do logger para escopo global
        const { log, warn, error, info, debug } = window.logger;
    </script>
</head>
<body>
    <h1>ğŸ”§ Teste - RestauraÃ§Ã£o das Mensagens da IA</h1>
    <p>Abra o console (F12) e observe os logs de auditoria:</p>
    
    <div id="log-container">
        <h3>ğŸš¨ Problema Identificado e Corrigido:</h3>
        <ol>
            <li>âŒ <strong>validateAndNormalizeSuggestions</strong> estava APAGANDO s.message</li>
            <li>âŒ SubstituÃ­a por estrutura limitada: {metric, issue, solution, priority, confidence}</li>
            <li>âœ… <strong>CORRIGIDO:</strong> Agora preserva TODOS os campos originais</li>
            <li>âœ… <strong>Logs adicionados:</strong> Rastreamento completo do fluxo</li>
            <li>âœ… <strong>Campos garantidos:</strong> message, action, title nunca undefined</li>
        </ol>
    </div>

    <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px;">
        <h4>ğŸ§ª CenÃ¡rios de Teste:</h4>
        <button onclick="testValidateFunction()">ğŸ” Validar funÃ§Ã£o corrigida</button>
        <button onclick="testPayloadBuild()">ğŸ“¦ ConstruÃ§Ã£o de payload</button>
        <button onclick="testCompletePipeline()">ğŸš€ Pipeline completo</button>
        <button onclick="testTruePeakFlow()">âš¡ Fluxo True Peak</button>
        <button onclick="testValidationChecklist()">âœ… Checklist final</button>
        <button onclick="console.clear()">ğŸ§¹ Limpar Console</button>
    </div>

    <div id="result-display" style="margin: 20px 0; padding: 15px; background: #e7f3ff; border-radius: 5px;">
        <h4>ğŸ“Š Resultado do Ãšltimo Teste:</h4>
        <div id="result-content">Nenhum teste executado ainda.</div>
    </div>

    <script>
        // Simular validateAndNormalizeSuggestions CORRIGIDO
        function simulateValidateAndNormalize(suggestions) {
            log('[AUDIT-PRE] validateAndNormalizeSuggestions - ENTRADA:', JSON.stringify(suggestions, null, 2));
            
            const validSuggestions = suggestions.filter(suggestion => {
                const hasContent = suggestion && (suggestion.message || suggestion.issue || suggestion.title);
                if (!hasContent) {
                    warn('âš ï¸ SugestÃ£o invÃ¡lida (sem conteÃºdo):', suggestion);
                    return false;
                }
                return true;
            }).map(suggestion => {
                // ğŸ”§ PRESERVAR TODOS OS CAMPOS ORIGINAIS + Normalizar estrutura para backend
                return {
                    // ğŸ¯ CAMPOS ORIGINAIS PRESERVADOS (CRÃTICO!)
                    ...suggestion,
                    
                    // ğŸ“‹ CAMPOS NORMALIZADOS PARA BACKEND (sem sobrescrever originais)
                    metric: suggestion.metric || suggestion.type || 'geral',
                    issue: suggestion.issue || suggestion.message || suggestion.title || 'Problema detectado',
                    solution: suggestion.solution || suggestion.action || suggestion.description || 'Ajuste recomendado',
                    priority: suggestion.priority || 5,
                    confidence: suggestion.confidence || 0.7,
                    
                    // ğŸ›¡ï¸ GARANTIR QUE CAMPOS CRÃTICOS NUNCA SEJAM UNDEFINED
                    message: suggestion.message || suggestion.issue || suggestion.title,
                    action: suggestion.action || suggestion.solution || suggestion.description,
                    title: suggestion.title || suggestion.message || suggestion.issue
                };
            });

            log('[AUDIT-POST] validateAndNormalizeSuggestions - SAÃDA:', JSON.stringify(validSuggestions, null, 2));
            log('âœ… SugestÃµes validadas E PRESERVADAS:', {
                original: suggestions.length,
                valid: validSuggestions.length,
                preservedFields: validSuggestions.map(s => ({ 
                    hasMessage: !!s.message, 
                    hasAction: !!s.action,
                    hasTitle: !!s.title,
                    messagePreview: s.message?.substring(0, 50) + '...' 
                }))
            });

            return validSuggestions;
        }

        // Simular buildValidPayload CORRIGIDO
        function simulateBuildValidPayload(suggestions, metrics, genre) {
            log('[AUDIT-PRE] buildValidPayload - ENTRADA:', JSON.stringify(suggestions, null, 2));
            
            const formattedSuggestions = suggestions.map((suggestion, index) => {
                const problemText = suggestion.message || suggestion.issue || suggestion.title || 'Problema detectado';
                const actionText = suggestion.action || suggestion.solution || suggestion.description || 'Ajuste recomendado';
                
                let priority = suggestion.priority || 2;
                if (typeof priority !== 'number') {
                    if (priority === 'alta' || priority === 'high') priority = 1;
                    else if (priority === 'mÃ©dia' || priority === 'medium') priority = 2; 
                    else if (priority === 'baixa' || priority === 'low') priority = 3;
                    else priority = 2;
                }
                
                priority = Math.max(1, Math.min(3, Math.floor(priority)));
                
                return {
                    // ğŸ”§ USAR CAMPOS ORIGINAIS COMO PRIORIDADE
                    message: problemText,
                    action: actionText, 
                    priority: priority,
                    confidence: suggestion.confidence || 0.8,
                    
                    // ğŸ›¡ï¸ PRESERVAR CAMPOS ORIGINAIS PARA RETORNO
                    originalMessage: suggestion.message,
                    originalAction: suggestion.action,
                    originalTitle: suggestion.title
                };
            });
            
            const payload = {
                suggestions: formattedSuggestions,
                metrics: metrics || {},
                genre: genre || 'geral'
            };

            log('[AUDIT-POST] buildValidPayload - SAÃDA:', JSON.stringify(payload, null, 2));
            log('ğŸ“¦ Payload para backend construÃ­do COM PRESERVAÃ‡ÃƒO:', {
                suggestionsCount: payload.suggestions.length,
                preservedMessages: payload.suggestions.map(s => ({ 
                    message: s.message, 
                    originalMessage: s.originalMessage,
                    hasOriginal: !!s.originalMessage 
                }))
            });

            return payload;
        }

        // Simular merge corrigido
        function simulateCorrectedMerge(validSuggestions, enhancedSuggestions) {
            log('[AUDIT-PRE-MERGE] enhancedSuggestions da API:', JSON.stringify(enhancedSuggestions, null, 2));
            log('[AUDIT-PRE-MERGE] validSuggestions para merge:', JSON.stringify(validSuggestions, null, 2));
            
            return enhancedSuggestions.map((s, i) => {
                const original = validSuggestions[i] || {};
                const meta = s.metadata || {};
                const content = meta.content || {};
                
                const resolvedMessage =
                    s.message ||                           // ğŸ¯ PRIORIDADE 1: IA direta
                    original.message ||                    // ğŸ“‹ PRIORIDADE 2: Original  
                    meta.message ||                        // ğŸ” Outras fontes...
                    (meta.original && meta.original.message) ||
                    (meta.enriched && meta.enriched.message) ||
                    (content.original && content.original.message) ||
                    (content.enriched && content.enriched.message);

                const resolvedAction =
                    s.action ||
                    original.action ||
                    meta.action ||
                    (meta.original && meta.original.action) ||
                    (meta.enriched && meta.enriched.action);

                return {
                    ai_enhanced: true,
                    ...original,
                    ...s,
                    hasOriginalMessage: !!resolvedMessage,
                    messageSource: resolvedMessage ? "restored" : "fallback",
                    message: resolvedMessage || "âš ï¸ Mensagem perdida na integraÃ§Ã£o.",
                    title: resolvedMessage || "âš ï¸ Mensagem perdida na integraÃ§Ã£o.",
                    action: resolvedAction,
                    priority: s.priority || original.priority || 1,
                    confidence: s.confidence || original.confidence || 0.9,
                };
            });
        }

        function displayResult(scenarioName, results, successCriteria) {
            const div = document.getElementById('result-content');
            
            div.innerHTML = `
                <div><strong>CenÃ¡rio:</strong> ${scenarioName}</div>
                <div><strong>CritÃ©rios de sucesso:</strong> ${successCriteria}</div>
                <div><strong>Resultados:</strong></div>
                <ul>
                    ${results.map(r => `<li>${r.success ? 'âœ…' : 'âŒ'} ${r.description}</li>`).join('')}
                </ul>
                <div style="margin-top: 10px;"><strong>Status geral:</strong> ${results.every(r => r.success) ? 'âœ… TODOS OS TESTES PASSARAM' : 'âŒ ALGUNS TESTES FALHARAM'}</div>
            `;
        }

        function testValidateFunction() {
            log('ğŸ” CenÃ¡rio: Validar funÃ§Ã£o validateAndNormalizeSuggestions corrigida');
            
            const inputSuggestions = [
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (1.2 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar FabFilter Pro-L2 com threshold suave",
                    priority: 1,
                    confidence: 0.95,
                    type: "true_peak"
                },
                {
                    message: "ğŸ“Š LUFS muito baixo para streaming",
                    action: "Aumentar gain em +3 dB",
                    priority: 2,
                    confidence: 0.8
                }
            ];
            
            const validated = simulateValidateAndNormalize(inputSuggestions);
            
            const results = [
                {
                    success: validated.every(s => !!s.message),
                    description: `Todos mantÃªm message: ${validated.every(s => !!s.message)}`
                },
                {
                    success: validated[0].message.includes("True Peak"),
                    description: `True Peak preservado: "${validated[0].message.substring(0, 40)}..."`
                },
                {
                    success: validated.every(s => !!s.action),
                    description: `Todos mantÃªm action: ${validated.every(s => !!s.action)}`
                },
                {
                    success: validated.every(s => s.priority && s.confidence),
                    description: `Priority/confidence preservados: ${validated.every(s => s.priority && s.confidence)}`
                }
            ];
            
            log('ğŸ” Validate function test:', results);
            
            displayResult("FunÃ§Ã£o validateAndNormalizeSuggestions", results, "Todos os campos originais devem ser preservados");
        }

        function testPayloadBuild() {
            log('ğŸ“¦ CenÃ¡rio: ConstruÃ§Ã£o de payload com preservaÃ§Ã£o');
            
            const suggestions = [
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA",
                    action: "Aplicar limitador",
                    priority: 1,
                    confidence: 0.95
                }
            ];
            
            const payload = simulateBuildValidPayload(suggestions, {}, 'electronic');
            
            const results = [
                {
                    success: payload.suggestions[0].message.includes("True Peak"),
                    description: `Message no payload: "${payload.suggestions[0].message}"`
                },
                {
                    success: !!payload.suggestions[0].originalMessage,
                    description: `originalMessage preservado: ${!!payload.suggestions[0].originalMessage}`
                },
                {
                    success: payload.suggestions[0].originalMessage === "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA",
                    description: `Original exato: ${payload.suggestions[0].originalMessage === "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA"}`
                }
            ];
            
            log('ğŸ“¦ Payload build test:', results);
            
            displayResult("ConstruÃ§Ã£o de payload", results, "originalMessage deve ser preservado para retorno da API");
        }

        function testCompletePipeline() {
            log('ğŸš€ CenÃ¡rio: Pipeline completo com preservaÃ§Ã£o');
            
            // 1. Input original
            const originalSuggestions = [
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (1.2 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar FabFilter Pro-L2",
                    priority: 1
                }
            ];
            
            // 2. ValidaÃ§Ã£o e normalizaÃ§Ã£o
            const validated = simulateValidateAndNormalize(originalSuggestions);
            
            // 3. ConstruÃ§Ã£o do payload
            const payload = simulateBuildValidPayload(validated, {}, 'electronic');
            
            // 4. Simular resposta da API (preservando originalMessage)
            const apiResponse = {
                enhancedSuggestions: [
                    {
                        message: payload.suggestions[0].originalMessage, // API retorna original
                        action: "Aplicar limitador suave FabFilter Pro-L2 com threshold em -1.0 dB",
                        priority: 1,
                        confidence: 0.95,
                        metadata: {
                            processing: "enhanced"
                        }
                    }
                ]
            };
            
            // 5. Merge
            const merged = simulateCorrectedMerge(validated, apiResponse.enhancedSuggestions);
            
            const results = [
                {
                    success: validated[0].message.includes("True Peak"),
                    description: `Etapa 1 - ValidaÃ§Ã£o preservou: ${validated[0].message.includes("True Peak")}`
                },
                {
                    success: !!payload.suggestions[0].originalMessage,
                    description: `Etapa 2 - Payload tem originalMessage: ${!!payload.suggestions[0].originalMessage}`
                },
                {
                    success: apiResponse.enhancedSuggestions[0].message.includes("True Peak"),
                    description: `Etapa 3 - API retornou correto: ${apiResponse.enhancedSuggestions[0].message.includes("True Peak")}`
                },
                {
                    success: merged[0].hasOriginalMessage && merged[0].messageSource === "restored",
                    description: `Etapa 4 - Merge bem-sucedido: hasOriginalMessage=${merged[0].hasOriginalMessage}, messageSource=${merged[0].messageSource}`
                }
            ];
            
            log('ğŸš€ Complete pipeline test:', {
                originalInput: originalSuggestions[0].message,
                afterValidation: validated[0].message,
                payloadOriginal: payload.suggestions[0].originalMessage,
                apiResponse: apiResponse.enhancedSuggestions[0].message,
                finalMerged: merged[0].message,
                success: results.every(r => r.success)
            });
            
            displayResult("Pipeline completo", results, "Mensagem deve ser preservada em todas as etapas");
        }

        function testTruePeakFlow() {
            log('âš¡ CenÃ¡rio: Fluxo especÃ­fico True Peak');
            
            const truePeakSuggestion = {
                message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (2.6 dBTP â†’ -1.0 dBTP)",
                action: "Limiter nativo da DAW ou FabFilter Pro-L2 com threshold em -1.0 dB",
                priority: 1,
                confidence: 0.98,
                metric: "true_peak",
                value: 2.6,
                target: -1.0
            };
            
            // Simular fluxo completo
            const validated = simulateValidateAndNormalize([truePeakSuggestion]);
            const payload = simulateBuildValidPayload(validated, {}, 'electronic');
            
            // Simular resposta da API enriquecida
            const enhancedResponse = [{
                message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (2.6 dBTP â†’ -1.0 dBTP)",
                action: "Aplicar limitador suave FabFilter Pro-L2 com threshold em -1.0 dB para prevenir clipping digital",
                priority: 1,
                confidence: 0.98,
                blocks: {
                    problem: "True Peak detectado em 2.6 dBTP",
                    cause: "Limitador muito agressivo ou ausente",
                    solution: "Aplicar limitador suave",
                    tip: "Use look-ahead para suavizar picos",
                    plugin: "FabFilter Pro-L2 ou limitador nativo da DAW",
                    result: "True Peak reduzido para -1.0 dBTP"
                }
            }];
            
            const merged = simulateCorrectedMerge(validated, enhancedResponse);
            
            const results = [
                {
                    success: merged[0].message.includes("True Peak") && merged[0].message.includes("2.6 dBTP"),
                    description: `Mensagem completa preservada: "${merged[0].message}"`
                },
                {
                    success: merged[0].action.includes("FabFilter"),
                    description: `Plugin especÃ­fico: "${merged[0].action}"`
                },
                {
                    success: merged[0].hasOriginalMessage === true,
                    description: `hasOriginalMessage: ${merged[0].hasOriginalMessage}`
                },
                {
                    success: merged[0].messageSource === "restored",
                    description: `messageSource: ${merged[0].messageSource}`
                },
                {
                    success: !merged[0].message.includes("âš ï¸ Mensagem perdida"),
                    description: `Sem fallback de erro: ${!merged[0].message.includes("âš ï¸ Mensagem perdida")}`
                }
            ];
            
            log('âš¡ True Peak flow test:', merged[0]);
            
            displayResult("Fluxo True Peak", results, "True Peak deve manter todos os detalhes e nunca usar fallback");
        }

        function testValidationChecklist() {
            log('âœ… CenÃ¡rio: Checklist de validaÃ§Ã£o final');
            
            // Simular caso mais complexo
            const complexSuggestions = [
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (2.6 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar FabFilter Pro-L2",
                    priority: 1
                },
                {
                    message: "ğŸ“Š LUFS adequado para streaming (-14.2 LUFS)",
                    action: "Manter nÃ­veis atuais",
                    priority: 2
                }
            ];
            
            const validated = simulateValidateAndNormalize(complexSuggestions);
            const payload = simulateBuildValidPayload(validated, {}, 'electronic');
            
            const enhancedResponse = [
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (2.6 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar limitador FabFilter Pro-L2",
                    priority: 1
                },
                {
                    message: "ğŸ“Š LUFS adequado para streaming (-14.2 LUFS)",
                    action: "NÃ­veis perfeitos para Spotify/Apple Music",
                    priority: 2
                }
            ];
            
            const merged = simulateCorrectedMerge(validated, enhancedResponse);
            const sorted = merged.sort((a, b) => {
                if (a.message?.includes("True Peak") && !b.message?.includes("True Peak")) return -1;
                if (!a.message?.includes("True Peak") && b.message?.includes("True Peak")) return 1;
                return (a.priority || 1) - (b.priority || 1);
            });
            
            const checklist = [
                {
                    success: !sorted.some(s => s.message.includes("âš ï¸ Mensagem perdida")),
                    description: "âŒ Nenhum 'âš ï¸ Mensagem perdida na integraÃ§Ã£o' Ã© exibido"
                },
                {
                    success: sorted[0].message.includes("True Peak"),
                    description: "âš¡ True Peak aparece no topo com texto prioritÃ¡rio correto"
                },
                {
                    success: sorted.every(s => s.hasOriginalMessage === true),
                    description: "âœ… hasOriginalMessage: true no log"
                },
                {
                    success: sorted.every(s => s.messageSource === "restored"),
                    description: "âœ… messageSource: 'restored' no log"
                },
                {
                    success: sorted.every(s => s.message && s.title && s.message === s.title),
                    description: "âœ… Nenhum campo vÃ¡lido Ã© apagado (message = title)"
                },
                {
                    success: sorted.some(s => s.action?.includes("FabFilter")),
                    description: "ğŸ¹ Plugin especÃ­fico preservado na action"
                }
            ];
            
            log('âœ… Final validation checklist:', {
                allPassed: checklist.every(c => c.success),
                results: checklist,
                finalSuggestions: sorted.map(s => ({
                    message: s.message.substring(0, 60),
                    hasOriginalMessage: s.hasOriginalMessage,
                    messageSource: s.messageSource
                }))
            });
            
            displayResult("Checklist final de validaÃ§Ã£o", checklist, "Todos os critÃ©rios devem passar para confirmaÃ§Ã£o da correÃ§Ã£o");
        }

        // Log inicial
        log("ğŸ”§ [RESTORE] Teste de restauraÃ§Ã£o de mensagens IA iniciado");
        log("ğŸš¨ Problema identificado: validateAndNormalizeSuggestions apagava s.message");
        log("âœ… CorreÃ§Ã£o aplicada: PreservaÃ§Ã£o de TODOS os campos originais");
        log("ğŸ¯ Meta: hasOriginalMessage: true + messageSource: 'restored'");
    </script>
</body>
</html>