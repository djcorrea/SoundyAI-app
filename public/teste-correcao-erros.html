<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔧 Teste de Correção de Erros - SoundyAI</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f8f9fa;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .result {
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        h1, h2 { color: #333; }
        #console-output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>🔧 Teste de Correção de Erros</h1>
    <p><strong>Objetivo:</strong> Verificar se os erros no console foram corrigidos após as modificações na função normalizeBackendAnalysisData.</p>

    <div class="test-section">
        <h2>📋 Console Output</h2>
        <div id="console-output"></div>
    </div>

    <div class="test-section">
        <h2>🧪 Resultados dos Testes</h2>
        <div id="test-results"></div>
    </div>

    <script>
        // Capturar logs do console
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        let consoleOutput = [];
        
        const captureConsole = (level, args) => {
            const timestamp = new Date().toISOString().substr(11, 12);
            consoleOutput.push(`[${timestamp}] ${level.toUpperCase()}: ${args.join(' ')}`);
            updateConsoleDisplay();
        };
        
        console.log = (...args) => {
            originalLog(...args);
            captureConsole('log', args);
        };
        
        console.error = (...args) => {
            originalError(...args);
            captureConsole('error', args);
        };
        
        console.warn = (...args) => {
            originalWarn(...args);
            captureConsole('warn', args);
        };
        
        function updateConsoleDisplay() {
            document.getElementById('console-output').textContent = consoleOutput.join('\n');
        }

        // JSON do backend para teste
        const testJson = {
            "ok": true,
            "rms": {
                "hasData": true,
                "frameCount": 1902
            },
            "file": "uploads/1757888586761.wav",
            "mode": "genre",
            "score": 97.9,
            "stereo": {
                "width": 0.156,
                "balance": 0,
                "correlation": 0.986,
                "hasPhaseIssues": false,
                "isMonoCompatible": false
            },
            "loudness": {
                "lra": 7.5,
                "unit": "LUFS",
                "momentary": -9.7,
                "shortTerm": -13.2,
                "integrated": -13.9
            },
            "truePeak": {
                "unit": "dBTP",
                "maxDbtp": 3,
                "maxLinear": 1.416
            },
            "analyzedAt": "2025-09-14T22:23:25.856Z",
            "classification": "Referência Mundial"
        };

        // Função normalizeBackendAnalysisData CORRIGIDA
        function normalizeBackendAnalysisDataCORRIGIDA(backendData) {
            console.log('🔧 [NORMALIZE] Iniciando normalização dos dados do backend:', backendData);
            
            // Se já está no formato correto, retornar como está
            if (backendData.technicalData && backendData.technicalData.peak !== undefined) {
                console.log('📊 [NORMALIZE] Dados já estão normalizados');
                return backendData;
            }
            
            // Criar estrutura normalizada - SEM FALLBACKS FICTÍCIOS
            const normalized = {
                ...backendData,
                technicalData: backendData.technicalData || {},
                problems: backendData.problems || [],
                suggestions: backendData.suggestions || [],
                duration: backendData.duration || null,
                sampleRate: backendData.sampleRate || null,
                channels: backendData.channels || null
            };
            
            // 🎯 MAPEAR MÉTRICAS BÁSICAS - SEM FALLBACKS FICTÍCIOS
            const tech = normalized.technicalData;
            const source = backendData.technicalData || backendData.metrics || backendData;
            
            console.log('🔍 [NORMALIZE] Dados de origem recebidos:', source);
            console.log('🔍 [NORMALIZE] Estrutura completa do backend:', backendData);
            
            // Função para pegar valor real ou null (sem fallbacks fictícios)
            const getRealValue = (...paths) => {
                for (const path of paths) {
                    const value = path.split('.').reduce((obj, key) => obj?.[key], source);
                    if (Number.isFinite(value)) {
                        return value;
                    }
                    // NOVO: Também verificar na estrutura raiz do backendData
                    const rootValue = path.split('.').reduce((obj, key) => obj?.[key], backendData);
                    if (Number.isFinite(rootValue)) {
                        return rootValue;
                    }
                }
                return null; // Retorna null se não há valor real
            };
            
            // True Peak - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.truePeakDbtp = getRealValue('truePeakDbtp', 'true_peak_dbtp', 'truePeak') || 
                               (backendData.truePeak?.maxDbtp && Number.isFinite(backendData.truePeak.maxDbtp) ? backendData.truePeak.maxDbtp : null);
            
            // LUFS - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.lufsIntegrated = getRealValue('lufsIntegrated', 'lufs_integrated', 'lufs') ||
                                 (backendData.loudness?.integrated && Number.isFinite(backendData.loudness.integrated) ? backendData.loudness.integrated : null);
            
            // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
            tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                                    (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
            
            tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                              (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);

            // 🔢 SCORES E QUALIDADE - MAPEAMENTO CORRETO PARA NOVA ESTRUTURA
            normalized.qualityOverall = backendData.score && Number.isFinite(backendData.score) ? backendData.score : null;
            
            // Outros campos não definidos mas que não devem causar erro
            tech.peak = null;
            tech.rms = null;
            tech.dynamicRange = null;
            tech.clippingSamples = null;
            tech.dcOffset = null;
            tech.thdPercent = null;
            
            // 🚨 PROBLEMAS - APENAS SE VALORES EXISTEM
            if (normalized.problems.length === 0) {
                if (Number.isFinite(tech.clippingSamples) && tech.clippingSamples > 0) {
                    normalized.problems.push({
                        type: 'clipping',
                        message: `Clipping detectado (${tech.clippingSamples} samples)`,
                        solution: 'Reduzir o ganho geral ou usar limitador',
                        severity: 'high'
                    });
                }
                
                if (Number.isFinite(tech.dcOffset) && Math.abs(tech.dcOffset) > 0.01) {
                    normalized.problems.push({
                        type: 'dc_offset', 
                        message: `DC Offset detectado (${tech.dcOffset.toFixed(4)})`,
                        solution: 'Aplicar filtro DC remove',
                        severity: 'medium'
                    });
                }
                
                if (Number.isFinite(tech.thdPercent) && tech.thdPercent > 1) {
                    normalized.problems.push({
                        type: 'thd',
                        message: `THD elevado (${tech.thdPercent.toFixed(2)}%)`,
                        solution: 'Verificar saturação e distorção',
                        severity: 'medium'
                    });
                }
            }
            
            // 💡 SUGESTÕES - APENAS SE VALORES EXISTEM
            if (normalized.suggestions.length === 0) {
                if (Number.isFinite(tech.dynamicRange) && tech.dynamicRange < 8) {
                    normalized.suggestions.push({
                        type: 'dynamics',
                        message: 'Faixa dinâmica baixa detectada',
                        action: 'Considerar reduzir compressão/limitação',
                        details: `DR atual: ${tech.dynamicRange.toFixed(1)}dB`
                    });
                }
                
                if (Number.isFinite(tech.stereoCorrelation) && tech.stereoCorrelation > 0.9) {
                    normalized.suggestions.push({
                        type: 'stereo',
                        message: 'Imagem estéreo muito estreita',
                        action: 'Aumentar espacialização estéreo',
                        details: `Correlação: ${tech.stereoCorrelation.toFixed(3)}`
                    });
                }
                
                if (Number.isFinite(tech.lufsIntegrated) && tech.lufsIntegrated < -30) {
                    normalized.suggestions.push({
                        type: 'loudness',
                        message: 'Loudness muito baixo',
                        action: 'Aumentar volume geral',
                        details: `LUFS atual: ${tech.lufsIntegrated.toFixed(1)}`
                    });
                }
            }
            
            console.log('✅ [NORMALIZE] Normalização concluída sem erros');
            
            return normalized;
        }

        function runTest() {
            const results = [];
            let hasErrors = false;
            
            try {
                console.log('🧪 Iniciando teste de correção de erros...');
                
                // Limpar console output
                consoleOutput = [];
                
                // Executar normalização
                const result = normalizeBackendAnalysisDataCORRIGIDA(testJson);
                
                results.push({
                    type: 'success',
                    message: '✅ Função executou sem erros JavaScript'
                });
                
                // Verificar se os campos esperados foram mapeados
                if (Number.isFinite(result.technicalData.truePeakDbtp)) {
                    results.push({
                        type: 'success',
                        message: `✅ True Peak mapeado corretamente: ${result.technicalData.truePeakDbtp} dBTP`
                    });
                }
                
                if (Number.isFinite(result.technicalData.lufsIntegrated)) {
                    results.push({
                        type: 'success',
                        message: `✅ LUFS Integrado mapeado corretamente: ${result.technicalData.lufsIntegrated} LUFS`
                    });
                }
                
                if (Number.isFinite(result.technicalData.stereoCorrelation)) {
                    results.push({
                        type: 'success',
                        message: `✅ Correlação Estéreo mapeada corretamente: ${result.technicalData.stereoCorrelation}`
                    });
                }
                
                // Verificar se não há erros nos logs
                const errorLogs = consoleOutput.filter(log => log.includes('ERROR') || log.includes('error'));
                if (errorLogs.length === 0) {
                    results.push({
                        type: 'success',
                        message: '✅ Nenhum erro detectado nos logs do console'
                    });
                } else {
                    hasErrors = true;
                    results.push({
                        type: 'error',
                        message: `❌ ${errorLogs.length} erro(s) detectado(s) no console`
                    });
                }
                
            } catch (error) {
                hasErrors = true;
                results.push({
                    type: 'error',
                    message: `❌ Erro JavaScript: ${error.message}`
                });
                console.error('Erro capturado:', error);
            }
            
            // Exibir resultados
            const resultsHtml = results.map(result => `
                <div class="result ${result.type}">
                    ${result.message}
                </div>
            `).join('');
            
            const summaryHtml = `
                <div class="result ${hasErrors ? 'error' : 'success'}">
                    <h3>📊 RESUMO FINAL</h3>
                    <p><strong>Status:</strong> ${hasErrors ? '❌ ERROS DETECTADOS' : '✅ TESTE PASSOU'}</p>
                    <p><strong>Resultado:</strong> ${hasErrors ? 'Ainda há problemas que precisam ser corrigidos' : 'Função corrigida com sucesso!'}</p>
                </div>
            `;
            
            document.getElementById('test-results').innerHTML = summaryHtml + resultsHtml;
            
            return !hasErrors;
        }

        // Executar teste quando a página carregar
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const success = runTest();
                console.log('🎯 Teste finalizado. Sucesso:', success);
            }, 1000);
        });
    </script>
</body>
</html>