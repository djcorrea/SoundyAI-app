// ğŸµ AUDIO ANALYZER INTEGRATION - VERSÃƒO REFATORADA
// Sistema de anÃ¡lise 100% baseado em processamento no back-end (Railway + Bucket)
// âš ï¸ REMOÃ‡ÃƒO COMPLETA: Web Audio API, AudioContext, processamento local
// âœ… NOVO FLUXO: Presigned URL â†’ Upload â†’ Job Creation â†’ Status Polling

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ GENRE TARGETS UTILS - FONTE ÃšNICA DE VERDADE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * Extrai genre targets de uma anÃ¡lise
 * ÃšNICA FONTE OFICIAL: analysis.data.genreTargets
 * @param {Object} analysis - Objeto de anÃ¡lise normalizado
 * @returns {Object|null} Targets do gÃªnero ou null
 */
function extractGenreTargetsFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-UTILS] ğŸ” Extraindo targets da anÃ¡lise');
    
    // ğŸ¯ PRIORIDADE 1: analysis.data.genreTargets (BACKEND OFICIAL)
    if (analysis?.data?.genreTargets) {
        console.log('[GENRE-TARGETS-UTILS] âœ… Targets encontrados em analysis.data.genreTargets');
        console.log('[GENRE-TARGETS-UTILS] Keys:', Object.keys(analysis.data.genreTargets));
        return analysis.data.genreTargets;
    }
    
    // ğŸ¯ PRIORIDADE 2: analysis.genreTargets (fallback direto)
    if (analysis?.genreTargets) {
        console.log('[GENRE-TARGETS-UTILS] âš ï¸ Targets encontrados em analysis.genreTargets (fallback)');
        console.log('[GENRE-TARGETS-UTILS] Keys:', Object.keys(analysis.genreTargets));
        return analysis.genreTargets;
    }
    
    // ğŸ¯ PRIORIDADE 3: analysis.data.targets (nomenclatura alternativa)
    if (analysis?.data?.targets) {
        console.log('[GENRE-TARGETS-UTILS] âš ï¸ Targets encontrados em analysis.data.targets (nomenclatura antiga)');
        console.log('[GENRE-TARGETS-UTILS] Keys:', Object.keys(analysis.data.targets));
        return analysis.data.targets;
    }
    
    console.warn('[GENRE-TARGETS-UTILS] âŒ Nenhum target encontrado na anÃ¡lise');
    console.warn('[GENRE-TARGETS-UTILS] analysis.data:', analysis?.data);
    console.warn('[GENRE-TARGETS-UTILS] analysis.genreTargets:', analysis?.genreTargets);
    return null;
}

/**
 * Extrai gÃªnero de uma anÃ¡lise
 * ÃšNICA FONTE OFICIAL: analysis.data.genre
 * @param {Object} analysis - Objeto de anÃ¡lise normalizado
 * @returns {string|null} Nome do gÃªnero ou null
 */
function extractGenreFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-UTILS] ğŸµ Extraindo gÃªnero da anÃ¡lise');
    
    // ğŸ¯ PRIORIDADE 1: analysis.data.genre (BACKEND OFICIAL)
    if (analysis?.data?.genre) {
        console.log('[GENRE-TARGETS-UTILS] âœ… GÃªnero encontrado em analysis.data.genre:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // ğŸ¯ PRIORIDADE 2: analysis.genre (fallback direto)
    if (analysis?.genre) {
        console.log('[GENRE-TARGETS-UTILS] âš ï¸ GÃªnero encontrado em analysis.genre (fallback):', analysis.genre);
        return analysis.genre;
    }
    
    // ğŸ¯ PRIORIDADE 3: analysis.metadata.genre
    if (analysis?.metadata?.genre) {
        console.log('[GENRE-TARGETS-UTILS] âš ï¸ GÃªnero encontrado em analysis.metadata.genre (fallback):', analysis.metadata.genre);
        return analysis.metadata.genre;
    }
    
    console.warn('[GENRE-TARGETS-UTILS] âŒ Nenhum gÃªnero encontrado na anÃ¡lise');
    return null;
}

console.log('âœ… Genre Targets Utils carregado');

// ğŸ” AUDITORIA DE STORAGE - Sistema de detecÃ§Ã£o de inconsistÃªncias
(function initStorageAudit() {
    console.group('%c[AUDITORIA-STORAGE] ğŸ§  Inicializando sistema de auditoria de storage', 'color:#A974FF;font-weight:bold;font-size:14px;');
    
    // 1ï¸âƒ£ Verificar localStorage atual
    const localRefJobId = localStorage.getItem('referenceJobId');
    const localRefAnalysis = localStorage.getItem('referenceAnalysis');
    
    console.log('%c[AUDITORIA-STORAGE] ğŸ“¦ localStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', localRefJobId || 'âŒ vazio');
    console.log('   referenceAnalysis:', localRefAnalysis ? `âœ… ${localRefAnalysis.length} bytes` : 'âŒ vazio');
    
    // 2ï¸âƒ£ Verificar sessionStorage atual
    const sessionRefJobId = sessionStorage.getItem('referenceJobId');
    const sessionRefAnalysis = sessionStorage.getItem('referenceAnalysis');
    const sessionCurrentJobId = sessionStorage.getItem('currentJobId');
    
    console.log('%c[AUDITORIA-STORAGE] ğŸ“¦ sessionStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', sessionRefJobId || 'âŒ vazio');
    console.log('   referenceAnalysis:', sessionRefAnalysis ? `âœ… ${sessionRefAnalysis.length} bytes` : 'âŒ vazio');
    console.log('   currentJobId:', sessionCurrentJobId || 'âŒ vazio');
    
    // 3ï¸âƒ£ Verificar variÃ¡veis globais
    console.log('%c[AUDITORIA-STORAGE] ğŸŒ VariÃ¡veis globais:', 'color:#FFD700;font-weight:bold;');
    console.log('   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'âŒ undefined');
    console.log('   window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__ || 'âŒ undefined');
    
    // 4ï¸âƒ£ Detectar inconsistÃªncias
    console.log('%c[AUDITORIA-STORAGE] ğŸ” AnÃ¡lise de consistÃªncia:', 'color:#A974FF;font-weight:bold;');
    
    if (localRefJobId && !sessionRefJobId) {
        console.log('%c   âš ï¸ PROBLEMA: referenceJobId apenas em localStorage', 'color:#FF5555;font-weight:bold;');
        console.log('   âš ï¸ Risco: Compartilhamento entre abas (localStorage Ã© global)');
        console.log('   âœ… SoluÃ§Ã£o: Migrar para sessionStorage (isolamento por aba)');
    }
    
    if (localRefJobId && sessionRefJobId && localRefJobId !== sessionRefJobId) {
        console.log('%c   âŒ INCONSISTÃŠNCIA CRÃTICA: JobIds diferentes!', 'color:#FF5555;font-weight:bold;');
        console.log('   localStorage.referenceJobId:', localRefJobId);
        console.log('   sessionStorage.referenceJobId:', sessionRefJobId);
    }
    
    if (!localRefJobId && !sessionRefJobId && !window.__REFERENCE_JOB_ID__) {
        console.log('%c   âœ… Estado limpo - sem referÃªncia ativa', 'color:#00FF88;');
    }
    
    if (localRefJobId || sessionRefJobId || window.__REFERENCE_JOB_ID__) {
        console.log('%c   ğŸ“Š ReferÃªncia ativa detectada:', 'color:#00C9FF;');
        console.log('   Prioridade: sessionStorage > window > localStorage');
    }
    
    console.groupEnd();
    
    // 5ï¸âƒ£ Criar utilitÃ¡rio global de storage com fallback
    window.StorageManager = {
        // Salvar referenceJobId
        setReferenceJobId(jobId) {
            console.log('%c[STORAGE-MANAGER] ğŸ’¾ Salvando referenceJobId:', 'color:#00FF88;font-weight:bold;', jobId);
            try {
                sessionStorage.setItem('referenceJobId', jobId);
                console.log('   âœ… Salvo em sessionStorage (isolado por aba)');
            } catch (e) {
                console.warn('   âš ï¸ Falha no sessionStorage, usando localStorage como fallback:', e.message);
                localStorage.setItem('referenceJobId', jobId);
            }
        },
        
        // Ler referenceJobId (prioridade: sessionStorage > window > localStorage)
        getReferenceJobId() {
            const sessionId = sessionStorage.getItem('referenceJobId');
            const windowId = window.__REFERENCE_JOB_ID__;
            const localId = localStorage.getItem('referenceJobId');
            
            const result = sessionId || windowId || localId;
            
            console.log('%c[STORAGE-MANAGER] ğŸ“– Lendo referenceJobId:', 'color:#FFD700;', result || 'âŒ nÃ£o encontrado');
            console.log('   sessionStorage:', sessionId || 'âŒ');
            console.log('   window.__REFERENCE_JOB_ID__:', windowId || 'âŒ');
            console.log('   localStorage:', localId || 'âŒ');
            
            return result;
        },
        
        // Salvar referenceAnalysis
        setReferenceAnalysis(analysis) {
            const json = JSON.stringify(analysis);
            console.log('%c[STORAGE-MANAGER] ğŸ’¾ Salvando referenceAnalysis:', 'color:#00FF88;font-weight:bold;', `${json.length} bytes`);
            try {
                sessionStorage.setItem('referenceAnalysis', json);
                console.log('   âœ… Salvo em sessionStorage');
            } catch (e) {
                console.warn('   âš ï¸ Falha no sessionStorage (quota?), usando localStorage:', e.message);
                try {
                    localStorage.setItem('referenceAnalysis', json);
                } catch (e2) {
                    console.error('   âŒ Falha em ambos storages:', e2.message);
                }
            }
        },
        
        // Ler referenceAnalysis
        getReferenceAnalysis() {
            const sessionData = sessionStorage.getItem('referenceAnalysis');
            const localData = localStorage.getItem('referenceAnalysis');
            
            const result = sessionData || localData;
            
            if (result) {
                try {
                    const parsed = JSON.parse(result);
                    console.log('%c[STORAGE-MANAGER] ğŸ“– referenceAnalysis recuperado:', 'color:#FFD700;', 
                        `${result.length} bytes`, 
                        sessionData ? '(sessionStorage)' : '(localStorage fallback)');
                    return parsed;
                } catch (e) {
                    console.error('%c[STORAGE-MANAGER] âŒ Erro ao parsear referenceAnalysis:', 'color:#FF5555;', e.message);
                    return null;
                }
            }
            
            console.log('%c[STORAGE-MANAGER] ğŸ“– referenceAnalysis:', 'color:#FFD700;', 'âŒ nÃ£o encontrado');
            return null;
        },
        
        // Limpar referÃªncia
        clearReference() {
            console.log('%c[STORAGE-MANAGER] ğŸ—‘ï¸ Limpando referÃªncia...', 'color:#FF9500;font-weight:bold;');
            try {
                sessionStorage.removeItem('referenceJobId');
                sessionStorage.removeItem('referenceAnalysis');
                console.log('   âœ… sessionStorage limpo');
            } catch (e) {
                console.warn('   âš ï¸ Erro ao limpar sessionStorage:', e.message);
            }
            
            try {
                localStorage.removeItem('referenceJobId');
                localStorage.removeItem('referenceAnalysis');
                console.log('   âœ… localStorage limpo');
            } catch (e) {
                console.warn('   âš ï¸ Erro ao limpar localStorage:', e.message);
            }
            
            delete window.__REFERENCE_JOB_ID__;
            console.log('   âœ… window.__REFERENCE_JOB_ID__ removido');
        }
    };
    
    console.log('%c[AUDITORIA-STORAGE] âœ… Sistema de storage auditado e StorageManager criado', 'color:#00FF88;font-weight:bold;');
})();

// ========================================
// ğŸ†” VIRTUAL IDS E ÃNDICE DE PAPÃ‰IS (ANTI-SELF-COMPARE)
// ========================================
// SoluÃ§Ã£o definitiva: Virtual ID composto por jobId + role (USER ou REF)
// Mesmo que backend reutilize jobId, o VID mantÃ©m separaÃ§Ã£o por papel
window.CacheIndex ??= { USER: null, REF: null };

// ========================================
// ğŸ§  SISTEMA DE ARMAZENAMENTO ISOLADO FINAL
// ========================================
/**
 * Sistema simplificado e definitivo para armazenamento de anÃ¡lises.
 * Duas variÃ¡veis isoladas: primeira e segunda mÃºsica.
 * NUNCA mais usar window.__FIRST_ANALYSIS_FROZEN__ ou stateV3.reference.
 */
window.SoundyAI_Store = {
    first: null,   // primeira mÃºsica
    second: null,  // segunda mÃºsica
};

/**
 * Salva primeira anÃ¡lise (referÃªncia)
 * @param {object} data - Dados da anÃ¡lise
 */
function saveFirstAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.first = JSON.parse(JSON.stringify(data));
    
    console.log('âœ… [STORE] Primeira anÃ¡lise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.first?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.first?.technicalData?.lufsIntegrated);
}

/**
 * Salva segunda anÃ¡lise (comparaÃ§Ã£o)
 * @param {object} data - Dados da anÃ¡lise
 */
function saveSecondAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.second = JSON.parse(JSON.stringify(data));
    
    console.log('âœ… [STORE] Segunda anÃ¡lise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.second?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.second?.technicalData?.lufsIntegrated);
}

// ========================================
// ğŸ”¬ GERADOR DE SUGESTÃ•ES COMPARATIVAS A vs B
// ========================================

/**
 * Gera sugestÃµes de IA baseadas no delta entre duas anÃ¡lises (A vs B)
 * @param {object} userAnalysis - AnÃ¡lise da faixa atual (B)
 * @param {object} refAnalysis - AnÃ¡lise da referÃªncia (A)
 * @returns {array} - Array de sugestÃµes comparativas enriquecidas
 */
function buildComparativeAISuggestions(userAnalysis, refAnalysis) {
    console.log('[A/B-SUGGESTIONS] ğŸ”¬ Gerando sugestÃµes comparativas...');
    
    if (!userAnalysis || !refAnalysis) {
        console.warn('[A/B-SUGGESTIONS] âš ï¸ AnÃ¡lises incompletas - abortando geraÃ§Ã£o');
        return [];
    }

    // ğŸ” Leitura segura de mÃ©tricas (mÃºltiplos caminhos possÃ­veis)
    const extractMetric = (analysis, metric) => {
        const paths = {
            lufs: [
                analysis?.lufsIntegrated,
                analysis?.avgLoudness,
                analysis?.loudness?.integrated,
                analysis?.technicalData?.lufsIntegrated,
                analysis?.metrics?.loudness?.integrated
            ],
            lra: [
                analysis?.lra,
                analysis?.loudness?.lra,
                analysis?.technicalData?.lra,
                analysis?.metrics?.loudness?.lra
            ],
            tp: [
                analysis?.truePeakDbtp,
                analysis?.truePeak,
                analysis?.loudness?.truePeak,
                analysis?.truePeak?.maxDbtp,
                analysis?.technicalData?.truePeakDbtp,
                analysis?.metrics?.truePeak?.maxDbtp
            ],
            dr: [
                analysis?.dynamicRange,
                analysis?.dynamics?.dynamicRange,
                analysis?.dynamics?.range,
                analysis?.technicalData?.dynamicRange,
                analysis?.metrics?.dynamics?.range
            ],
            cf: [
                analysis?.crestFactor,
                analysis?.dynamics?.crestFactor,
                analysis?.dynamics?.crest,
                analysis?.technicalData?.crestFactor,
                analysis?.metrics?.dynamics?.crest
            ]
        };

        const values = paths[metric] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) {
                return val;
            }
        }
        return null;
    };

    // ğŸ“Š Extrair mÃ©tricas de ambas anÃ¡lises
    const U = {
        lufs: extractMetric(userAnalysis, 'lufs'),
        lra: extractMetric(userAnalysis, 'lra'),
        tp: extractMetric(userAnalysis, 'tp'),
        dr: extractMetric(userAnalysis, 'dr'),
        cf: extractMetric(userAnalysis, 'cf')
    };

    const R = {
        lufs: extractMetric(refAnalysis, 'lufs'),
        lra: extractMetric(refAnalysis, 'lra'),
        tp: extractMetric(refAnalysis, 'tp'),
        dr: extractMetric(refAnalysis, 'dr'),
        cf: extractMetric(refAnalysis, 'cf')
    };

    console.log('[A/B-SUGGESTIONS] ğŸ“Š MÃ©tricas extraÃ­das:', {
        user: U,
        reference: R
    });

    // ğŸ”¢ Calcular deltas (B - A)
    const Î” = {
        lufs: (U.lufs !== null && R.lufs !== null) ? (U.lufs - R.lufs) : null,
        lra: (U.lra !== null && R.lra !== null) ? (U.lra - R.lra) : null,
        tp: (U.tp !== null && R.tp !== null) ? (U.tp - R.tp) : null,
        dr: (U.dr !== null && R.dr !== null) ? (U.dr - R.dr) : null,
        cf: (U.cf !== null && R.cf !== null) ? (U.cf - R.cf) : null
    };

    console.log('[A/B-SUGGESTIONS] ğŸ”¢ Deltas calculados:', Î”);

    // ğŸšï¸ Thresholds de relevÃ¢ncia
    const TH = {
        lufs: 1.0,    // 1 LUFS = diferenÃ§a percebÃ­vel
        lra: 0.5,     // 0.5 LU = mudanÃ§a na dinÃ¢mica
        tp: 0.3,      // 0.3 dBTP = diferenÃ§a em headroom
        dr: 0.7,      // 0.7 dB = mudanÃ§a no range dinÃ¢mico
        cf: 0.7       // 0.7 = mudanÃ§a em transientes
    };

    const suggestions = [];

    // ==========================================
    // 1ï¸âƒ£ LOUDNESS (LUFS Integrado)
    // ==========================================
    if (Î”.lufs !== null && Math.abs(Î”.lufs) >= TH.lufs) {
        const maisBaixo = Î”.lufs < 0;
        const severidade = Math.abs(Î”.lufs) >= 3 ? "CRÃTICA" : (Math.abs(Î”.lufs) >= 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "Loudness (A vs B)",
            severidade: severidade,
            problema: `Sua faixa estÃ¡ ${maisBaixo ? "mais baixa" : "mais alta"} que a referÃªncia em ${Math.abs(Î”.lufs).toFixed(2)} LUFS. Faixa atual: ${U.lufs?.toFixed(2)} LUFS vs ReferÃªncia: ${R.lufs?.toFixed(2)} LUFS.`,
            causaProvavel: maisBaixo
                ? "Gain staging conservador na masterizaÃ§Ã£o ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo ou ganho de entrada muito alto.",
            solucao: maisBaixo
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Î”.lufs).toFixed(1)} dB. Use um limiter com ceiling adequado (-0.3 dBTP) e ajuste o input gain atÃ© atingir ${R.lufs?.toFixed(1)} LUFS.`
                : `Reduza o input gain do limiter em ${Math.abs(Î”.lufs).toFixed(1)} dB. Reequilibre os buses para evitar compressÃ£o excessiva e mantenha o ceiling em -1.0 dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer, Waves L2",
            dicaExtra: "Compare trechos equivalentes (drop/refrÃ£o) entre as faixas. Use medidores de loudness (Youlean, LUFS Meter) para monitoramento em tempo real.",
            parametros: {
                alvoLUFS: R.lufs,
                diferenca: Î”.lufs,
                ajusteSugerido: maisBaixo ? `+${Math.abs(Î”.lufs).toFixed(1)} dB` : `-${Math.abs(Î”.lufs).toFixed(1)} dB`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 2ï¸âƒ£ TRUE PEAK
    // ==========================================
    if (Î”.tp !== null && Math.abs(Î”.tp) >= TH.tp) {
        const maisAlto = Î”.tp > 0;
        const severidade = Math.abs(Î”.tp) >= 1.0 ? "CRÃTICA" : (Math.abs(Î”.tp) >= 0.5 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "True Peak (A vs B)",
            severidade: severidade,
            problema: `True Peak ${maisAlto ? "maior" : "menor"} que a referÃªncia em ${Math.abs(Î”.tp).toFixed(2)} dBTP. Faixa atual: ${U.tp?.toFixed(2)} dBTP vs ReferÃªncia: ${R.tp?.toFixed(2)} dBTP.`,
            causaProvavel: maisAlto 
                ? "Inter-sample peaks causados por limiter sem oversampling adequado ou clipping digital." 
                : "Headroom excessivo nÃ£o aproveitado - potencial de ganho adicional.",
            solucao: maisAlto
                ? `Ajuste o ceiling do limiter para mÃ¡ximo de -1.0 dBTP. Habilite oversampling 4x ou superior e revise o release time para evitar distorÃ§Ã£o intersample.`
                : `VocÃª pode aumentar o ceiling em atÃ© ${Math.abs(Î”.tp).toFixed(1)} dB mantendo margem segura. Ajuste para aproximadamente ${R.tp?.toFixed(1)} dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x-32x), iZotope Ozone Maximizer, Waves L2 Ultramaximizer",
            dicaExtra: "Use medidores de true peak (TT Dynamic Range Meter) e sempre mantenha -0.5 a -1.0 dBTP para distribuiÃ§Ã£o em streaming (Spotify, Apple Music).",
            parametros: {
                alvoTP: R.tp,
                diferenca: Î”.tp,
                ceilingRecomendado: maisAlto ? "-1.0 dBTP" : `${R.tp?.toFixed(1)} dBTP`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 3ï¸âƒ£ LRA (Loudness Range - Macro DinÃ¢mica)
    // ==========================================
    if (Î”.lra !== null && Math.abs(Î”.lra) >= TH.lra) {
        const maisEstatica = Î”.lra < 0;
        const severidade = Math.abs(Î”.lra) >= 2.0 ? "ALTA" : (Math.abs(Î”.lra) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "LRA / DinÃ¢mica Macro (A vs B)",
            severidade: severidade,
            problema: `Sua LRA estÃ¡ ${maisEstatica ? "mais baixa" : "mais alta"} que a referÃªncia em ${Math.abs(Î”.lra).toFixed(2)} LU. Faixa atual: ${U.lra?.toFixed(2)} LU vs ReferÃªncia: ${R.lra?.toFixed(2)} LU.`,
            causaProvavel: maisEstatica 
                ? "CompressÃ£o e limiting excessivos reduzindo contraste dinÃ¢mico entre seÃ§Ãµes." 
                : "DiferenÃ§as de arranjo, automaÃ§Ã£o de volume ou menos processamento dinÃ¢mico.",
            solucao: maisEstatica
                ? `Reduza ratio/threshold dos compressores de bus em 2-3 dB. Use automaÃ§Ã£o de volume para criar contrastes entre intro/verso/refrÃ£o/drop. Alivie o limiter para preservar dinÃ¢mica.`
                : `Ajuste levemente o bus compressor (ratio 2:1-3:1, attack 30ms, release auto) para apertar a macro dinÃ¢mica. Considere sidechain compression em elementos rÃ­tmicos.`,
            pluginRecomendado: "SSL Bus Compressor, Glue Compressor (Ableton), API 2500, VCA compressor",
            dicaExtra: "LRA ideal para mÃºsica eletrÃ´nica: 3-6 LU. Para rock/pop: 6-10 LU. Use automaÃ§Ã£o de ganho antes de processar para moldar a dinÃ¢mica desejada.",
            parametros: {
                alvoLRA: R.lra,
                diferenca: Î”.lra,
                tipoProcessamento: maisEstatica ? "Aliviar compressÃ£o" : "Apertar dinÃ¢mica"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 4ï¸âƒ£ DYNAMIC RANGE (DR)
    // ==========================================
    if (Î”.dr !== null && Math.abs(Î”.dr) >= TH.dr) {
        const severidade = Math.abs(Î”.dr) >= 2.0 ? "ALTA" : (Math.abs(Î”.dr) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "Dynamic Range (A vs B)",
            severidade: severidade,
            problema: `Dynamic Range difere em ${Math.abs(Î”.dr).toFixed(2)} dB da referÃªncia. Faixa atual: ${U.dr?.toFixed(2)} dB vs ReferÃªncia: ${R.dr?.toFixed(2)} dB.`,
            causaProvavel: "RelaÃ§Ã£o entre picos e RMS (mÃ©dia de energia) diferente da referÃªncia devido a processamento dinÃ¢mico distinto.",
            solucao: `Ajuste compressÃ£o nos subgrupos (drums, bass, synths) para aproximar DR de ${R.dr?.toFixed(1)} dB. Use clippers transparentes antes do limiter para controlar transientes sem perder corpo.`,
            pluginRecomendado: "Clipper transparente (StandardCLIP, K-Clip), bus compressor multi-banda",
            dicaExtra: "DR tÃ­pico por gÃªnero: EDM (4-6 dB), Pop (6-8 dB), Rock (8-12 dB). Valores muito baixos (<4 dB) indicam overprocessing.",
            parametros: {
                alvoDR: R.dr,
                diferenca: Î”.dr,
                drIdeal: R.dr?.toFixed(1) + " dB"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 5ï¸âƒ£ CREST FACTOR (RelaÃ§Ã£o Pico/RMS)
    // ==========================================
    if (Î”.cf !== null && Math.abs(Î”.cf) >= TH.cf) {
        const severidade = Math.abs(Î”.cf) >= 1.5 ? "MODERADA" : "LEVE";
        
        suggestions.push({
            categoria: "Crest Factor (A vs B)",
            severidade: severidade,
            problema: `Crest Factor difere em ${Math.abs(Î”.cf).toFixed(2)} dB da referÃªncia. Faixa atual: ${U.cf?.toFixed(2)} vs ReferÃªncia: ${R.cf?.toFixed(2)}.`,
            causaProvavel: "Transientes (kicks, snares, attacks) com intensidades diferentes entre as faixas.",
            solucao: `Ajuste attack/release de compressores para aproximar punch da referÃªncia. Use transient shapers para moldar ataques de percussÃ£o. CF alvo: ${R.cf?.toFixed(1)}.`,
            pluginRecomendado: "SPL Transient Designer, Oxford Transmod, Waves Trans-X, saturaÃ§Ã£o sutil (decapitator)",
            dicaExtra: "CF alto = mais transientes (>10 dB). CF baixo = som mais constante (<6 dB). Use saturaÃ§Ã£o para adicionar harmÃ´nicos e corpo sem aumentar picos.",
            parametros: {
                alvoCF: R.cf,
                diferenca: Î”.cf,
                ajusteTransientes: Î”.cf < 0 ? "Aumentar ataques" : "Suavizar transientes"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // ğŸ“Š RESULTADO FINAL
    // ==========================================
    console.log(`[A/B-SUGGESTIONS] âœ… Geradas ${suggestions.length} sugestÃµes comparativas`);
    
    if (suggestions.length > 0) {
        console.log('[A/B-SUGGESTIONS] ğŸ“‹ Resumo das sugestÃµes:', 
            suggestions.map(s => `${s.categoria} (${s.severidade})`).join(', ')
        );
    }

    // Limitar a 5 sugestÃµes mais relevantes (ordenadas por severidade)
    const severityOrder = { "CRÃTICA": 0, "ALTA": 1, "MODERADA": 2, "IMPORTANTE": 3, "LEVE": 4 };
    return suggestions
        .sort((a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5))
        .slice(0, 5);
}

// ========================================
// ğŸ¤– SISTEMA DE ESPERA POR ENRIQUECIMENTO IA
// ========================================

/**
 * Aguarda o enriquecimento IA (aiSuggestions) estar disponÃ­vel
 * @param {string} jobId - ID do job para consultar
 * @param {number} timeout - Tempo mÃ¡ximo de espera em ms (padrÃ£o: 10000ms = 10s)
 * @param {number} pollInterval - Intervalo entre consultas em ms (padrÃ£o: 1000ms = 1s)
 * @returns {Promise<object|null>} - Dados enriquecidos ou null se timeout
 */
async function waitForAIEnrichment(jobId, timeout = 10000, pollInterval = 1000) {
    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('[AI-SYNC] â³ Aguardando enriquecimento IA...');
    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('[AI-SYNC] ğŸ†” Job ID:', jobId);
    console.log('[AI-SYNC] â±ï¸ Timeout:', timeout, 'ms');
    console.log('[AI-SYNC] ğŸ”„ Poll interval:', pollInterval, 'ms');
    
    const startTime = Date.now();
    let attempt = 0;
    
    while (Date.now() - startTime < timeout) {
        attempt++;
        const elapsed = Date.now() - startTime;
        
        console.log(`[AI-SYNC] ğŸ” Tentativa ${attempt} (${elapsed}ms/${timeout}ms)...`);
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`);
            
            if (!response.ok) {
                console.warn(`[AI-SYNC] âš ï¸ HTTP ${response.status} - Tentando novamente...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
            }
            
            const data = await response.json();
            
            console.log(`[AI-SYNC] ğŸ“¦ Resposta recebida (tentativa ${attempt}):`, {
                hasAiSuggestions: Array.isArray(data.aiSuggestions),
                aiSuggestionsLength: data.aiSuggestions?.length || 0,
                hasSuggestions: Array.isArray(data.suggestions),
                suggestionsLength: data.suggestions?.length || 0,
                status: data.status
            });
            
            // âœ… VERIFICAÃ‡ÃƒO: aiSuggestions existe E tem conteÃºdo
            if (Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                // Verificar se pelo menos 1 tem aiEnhanced: true
                const aiEnhancedCount = data.aiSuggestions.filter(s => s.aiEnhanced === true).length;
                
                console.log(`[AI-SYNC] ğŸ¯ aiSuggestions encontrado:`, {
                    total: data.aiSuggestions.length,
                    aiEnhanced: aiEnhancedCount
                });
                
                if (aiEnhancedCount > 0) {
                    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('[AI-SYNC] âœ…âœ…âœ… ENRIQUECIMENTO IA CONCLUÃDO! âœ…âœ…âœ…');
                    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('[AI-SYNC] ğŸ“Š Total:', data.aiSuggestions.length, 'sugestÃµes');
                    console.log('[AI-SYNC] ğŸ¤– Marcadas como aiEnhanced:', aiEnhancedCount);
                    console.log('[AI-SYNC] â±ï¸ Tempo decorrido:', Date.now() - startTime, 'ms');
                    console.log('[AI-SYNC] ğŸ“‹ Sample da primeira:', {
                        aiEnhanced: data.aiSuggestions[0]?.aiEnhanced,
                        categoria: data.aiSuggestions[0]?.categoria,
                        nivel: data.aiSuggestions[0]?.nivel,
                        hasProblema: !!data.aiSuggestions[0]?.problema,
                        hasSolucao: !!data.aiSuggestions[0]?.solucao
                    });
                    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    
                    return data;
                } else {
                    console.warn(`[AI-SYNC] âš ï¸ aiSuggestions existe mas nenhum tem aiEnhanced: true`);
                    console.warn(`[AI-SYNC] âš ï¸ Aguardando processamento IA completar...`);
                }
            } else {
                console.log(`[AI-SYNC] â³ aiSuggestions ainda nÃ£o disponÃ­vel, aguardando...`);
            }
            
        } catch (error) {
            console.error(`[AI-SYNC] âŒ Erro na tentativa ${attempt}:`, error.message);
        }
        
        // Aguardar antes da prÃ³xima tentativa
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout atingido
    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('[AI-SYNC] â±ï¸ TIMEOUT ATINGIDO');
    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.warn('[AI-SYNC] âš ï¸ Enriquecimento IA nÃ£o completou dentro do tempo limite');
    console.warn('[AI-SYNC] âš ï¸ Total de tentativas:', attempt);
    console.warn('[AI-SYNC] âš ï¸ Tempo decorrido:', Date.now() - startTime, 'ms');
    console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    return null;
}

/**
 * Mostra spinner visual de carregamento IA
 * @param {string} message - Mensagem a exibir
 */
function showAILoadingSpinner(message = 'Conectando Ã  IA...') {
    console.log('[AI-UI][SPINNER] ğŸ”„ Mostrando spinner:', message);
    
    // Tentar inserir no elemento de status do modal se existir
    const statusElement = document.querySelector('#ai-enrichment-status') || 
                         document.querySelector('.modal-status') ||
                         document.querySelector('.analysis-status');
    
    if (statusElement) {
        statusElement.innerHTML = `
            <div class="ai-loading-spinner" id="aiEnrichmentSpinner">
                <div class="spinner-icon">ğŸ”„</div>
                <div class="spinner-message">${message}</div>
                <div class="spinner-dots">
                    <span class="dot">â—</span>
                    <span class="dot">â—</span>
                    <span class="dot">â—</span>
                </div>
            </div>
        `;
        
        // Adicionar animaÃ§Ã£o via CSS inline
        const style = document.createElement('style');
        style.textContent = `
            .ai-loading-spinner {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background: rgba(0, 0, 0, 0.05);
                border-radius: 8px;
                margin: 10px 0;
            }
            .spinner-icon {
                font-size: 32px;
                animation: spin 2s linear infinite;
            }
            .spinner-message {
                font-size: 14px;
                color: #666;
                margin: 10px 0 5px 0;
                font-weight: 500;
            }
            .spinner-dots {
                display: flex;
                gap: 4px;
            }
            .spinner-dots .dot {
                font-size: 8px;
                animation: pulse 1.5s ease-in-out infinite;
            }
            .spinner-dots .dot:nth-child(2) {
                animation-delay: 0.2s;
            }
            .spinner-dots .dot:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
        `;
        
        if (!document.getElementById('aiSpinnerStyles')) {
            style.id = 'aiSpinnerStyles';
            document.head.appendChild(style);
        }
    } else {
        console.warn('[AI-UI][SPINNER] âš ï¸ Elemento de status nÃ£o encontrado');
    }
}

/**
 * Remove spinner visual de carregamento IA
 */
function hideAILoadingSpinner() {
    console.log('[AI-UI][SPINNER] âœ… Removendo spinner');
    
    const spinner = document.getElementById('aiEnrichmentSpinner');
    if (spinner) {
        spinner.remove();
    }
}

/**
 * ObtÃ©m par de anÃ¡lises para comparaÃ§Ã£o
 * @returns {object|null} { ref, curr } ou null se alguma anÃ¡lise estiver faltando
 */
function getComparisonPair() {
    const ref = window.SoundyAI_Store.first;
    const curr = window.SoundyAI_Store.second;
    
    if (!ref || !curr) {
        console.warn('âš ï¸ [STORE] Ainda falta uma das anÃ¡lises para comparar');
        console.warn('   - first:', !!ref);
        console.warn('   - second:', !!curr);
        return null;
    }
    
    console.log('ğŸ“¦ [STORE] Par de anÃ¡lises obtido');
    console.log('   - ref.jobId:', ref?.jobId);
    console.log('   - curr.jobId:', curr?.jobId);
    console.log('   - ref.fileName:', ref?.fileName || ref?.metadata?.fileName);
    console.log('   - curr.fileName:', curr?.fileName || curr?.metadata?.fileName);
    
    // ğŸ”’ AUDITORIA AUTOMÃTICA
    console.table({
        refJob: ref?.jobId,
        currJob: curr?.jobId,
        refName: ref?.fileName || ref?.metadata?.fileName,
        currName: curr?.fileName || curr?.metadata?.fileName,
        sameJob: ref?.jobId === curr?.jobId,
        sameName: (ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)
    });
    
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA
    if (ref?.jobId === curr?.jobId) {
        console.error('ğŸš¨ [STORE-ERROR] CONTAMINAÃ‡ÃƒO DETECTADA!');
        console.error('   JobIds sÃ£o IGUAIS:', ref.jobId);
        console.error('   Isso NÃƒO DEVERIA ACONTECER com sistema isolado');
        console.trace();
    }
    
    if ((ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)) {
        console.error('ğŸš¨ [STORE-ERROR] NOMES DE ARQUIVO IGUAIS!');
        console.error('   FileName:', ref?.fileName || ref?.metadata?.fileName);
        console.error('   PossÃ­vel self-compare ou upload duplicado');
        console.trace();
    }
    
    return { ref, curr };
}

// ========================================
// ğŸ”§ UTILIDADES DE CLONAGEM PROFUNDA
// ========================================
/**
 * Clone profundo seguro - tenta structuredClone, fallback para JSON
 * @param {*} obj - Objeto a ser clonado
 * @returns {*} Clone independente ou objeto original (Ãºltimo recurso)
 */
function cloneDeepSafe(obj) {
  if (!obj) return obj;
  try { return structuredClone(obj); } catch {}
  try { return JSON.parse(JSON.stringify(obj)); } catch {}
  return obj; // Ãºltimo recurso (nÃ£o deve acontecer)
}

// ========================================
// ğŸ”’ PASSO 2: PROTEÃ‡ÃƒO DE JOBID (ANTI-CONTAMINAÃ‡ÃƒO)
// ========================================
/**
 * Protege window.__CURRENT_JOB_ID__ contra sobrescrita acidental
 * Bloqueia tentativas de contaminar com __REFERENCE_JOB_ID__
 */
function protectCurrentJobId(initialValue) {
    // Armazena valor privado
    let _currentJobId = initialValue;
    
    // Redefine a propriedade com getter/setter protegido
    Object.defineProperty(window, '__CURRENT_JOB_ID__', {
        configurable: true,
        enumerable: true,
        set: function(value) {
            console.group('âš ï¸ [PROTECTION] Tentativa de alterar currentJobId');
            console.log('   - Valor antigo:', _currentJobId);
            console.log('   - Valor novo:', value);
            console.trace('   - Stack trace:');
            console.groupEnd();
            
            // BLOQUEIO: Se tentar contaminar com referenceJobId
            if (value && value === window.__REFERENCE_JOB_ID__) {
                console.error('âŒ [PROTECTION] BLOQUEADO! Tentativa de contaminar currentJobId com referenceJobId!');
                console.error('âŒ [PROTECTION] Mantendo valor original:', _currentJobId);
                return; // BLOQUEIA a alteraÃ§Ã£o
            }
            
            // BLOQUEIO: Se jÃ¡ tiver valor e tentar alterar sem justificativa
            if (_currentJobId && value && _currentJobId !== value) {
                console.warn('âš ï¸ [PROTECTION] Sobrescrita de currentJobId detectada!');
                console.warn('   Antigo:', _currentJobId);
                console.warn('   Novo:', value);
            }
            
            _currentJobId = value;
            console.log('âœ… [PROTECTION] currentJobId atualizado:', _currentJobId);
        },
        get: function() {
            return _currentJobId;
        }
    });
    
    console.log('ğŸ”’ [PROTECTION] ProteÃ§Ã£o de currentJobId ativada com valor inicial:', initialValue);
}

// ========================================
// ğŸ›¡ï¸ PASSO 3: FUNÃ‡ÃƒO SEGURA PARA OBTER JOBID
// ========================================
/**
 * Retorna o jobId correto baseado no modo, com proteÃ§Ã£o contra contaminaÃ§Ã£o
 * @param {string} mode - 'reference' ou 'genre'
 * @returns {string|null} jobId seguro
 */
/**
 * âš ï¸ DEPRECATED - USE getCorrectJobId() INSTEAD
 * Esta funÃ§Ã£o estÃ¡ DEPRECADA e serÃ¡ removida em versÃµes futuras.
 * MOTIVO: Acessa localStorage diretamente sem validaÃ§Ã£o, causando bug de comparaÃ§Ã£o com mesma mÃºsica.
 * @deprecated Use getCorrectJobId(context) em vez disso
 */
function getJobIdSafely(mode) {
    console.error('âš ï¸ [DEPRECATED] getJobIdSafely() estÃ¡ DEPRECADA! Use getCorrectJobId() em vez disso.');
    console.trace('ğŸ” [DEPRECATED] Stack trace de quem chamou a funÃ§Ã£o deprecada:');
    
    // Redirecionar para a funÃ§Ã£o correta
    if (mode === 'reference') {
        return getCorrectJobId('reference');
    } else if (mode === 'storage') {
        return getCorrectJobId('storage');
    } else {
        return getCorrectJobId('current');
    }
}

// ========================================
// ğŸ¯ FUNÃ‡ÃƒO UTILITÃRIA CRÃTICA: getCorrectJobId
// ========================================
/**
 * Retorna o jobId correto baseado no contexto
 * NUNCA use localStorage.getItem('referenceJobId') diretamente!
 * SEMPRE use esta funÃ§Ã£o!
 * 
 * @param {string} context - 'user'|'second'|'current' = segunda mÃºsica
 *                          'reference'|'first' = primeira mÃºsica
 *                          'storage' = fallback para localStorage
 * @returns {string|null} jobId correto para o contexto
 */
function getCorrectJobId(context) {
    const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
    
    console.group(`ğŸ¯ [GET-CORRECT-JOBID] Contexto: ${context}`);
    console.log('   - Modo atual:', mode);
    console.log('   - window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - sessionStorage.currentJobId:', sessionStorage.getItem('currentJobId'));
    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    
    if (mode === 'reference') {
        // Em modo reference, temos dois jobIds diferentes
        const currentJobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId');
        
        // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager para ler referenceJobId
        const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
        
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: NUNCA retornar jobIds iguais
        if (currentJobId && referenceJobId && currentJobId === referenceJobId) {
            console.error('âŒ [CRITICAL] JobIds sÃ£o iguais! Isso NÃƒO deveria acontecer!');
            console.error('   currentJobId:', currentJobId);
            console.error('   referenceJobId:', referenceJobId);
            console.error('   context:', context);
            console.trace();
            
            // Tenta recuperar do sessionStorage
            const recoveredJobId = sessionStorage.getItem('currentJobId');
            if (recoveredJobId && recoveredJobId !== referenceJobId) {
                console.warn('âš ï¸ [RECOVERY] JobId recuperado do sessionStorage:', recoveredJobId);
                window.__CURRENT_JOB_ID__ = recoveredJobId;
                console.groupEnd();
                return recoveredJobId;
            }
            
            throw new Error('FATAL: JobIds iguais em modo reference - contaminaÃ§Ã£o detectada!');
        }
        
        // Decide qual jobId usar baseado no contexto
        let selectedJobId;
        if (context === 'user' || context === 'second' || context === 'current') {
            selectedJobId = currentJobId;
            console.log('âœ… [JOB-ID] Retornando currentJobId (segunda mÃºsica):', selectedJobId);
        } else if (context === 'reference' || context === 'first') {
            selectedJobId = referenceJobId;
            console.log('âœ… [JOB-ID] Retornando referenceJobId (primeira mÃºsica):', selectedJobId);
        } else if (context === 'storage') {
            // Fallback para localStorage (compatibilidade)
            selectedJobId = referenceJobId;
            console.warn('âš ï¸ [JOB-ID] Contexto "storage" - retornando referenceJobId:', selectedJobId);
        } else {
            console.warn('âš ï¸ [JOB-ID] Contexto nÃ£o especificado:', context);
            selectedJobId = currentJobId; // Default: segunda mÃºsica
            console.log('   - Default: retornando currentJobId:', selectedJobId);
        }
        
        console.groupEnd();
        return selectedJobId;
    } else {
        // Modo normal: sÃ³ existe um jobId
        const jobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId') || localStorage.getItem('currentJobId');
        console.log('âœ… [JOB-ID] Modo normal - retornando:', jobId);
        console.groupEnd();
        return jobId;
    }
}

// ========================================
// ğŸ”„ HIDRATAÃ‡ÃƒO DE REFERÃŠNCIA (CorreÃ§Ã£o 1)
// ========================================
/**
 * Garante que a referÃªncia esteja hidratada e disponÃ­vel para comparaÃ§Ã£o A/B.
 * Fonte de verdade: AnalysisCache âœ FirstAnalysisStore âœ __FIRST_ANALYSIS_FROZEN__
 * @returns {Object} { ok: boolean, reason?: string, refId?: string, hasBands?: boolean, file?: string }
 */
function ensureReferenceHydrated() {
  try {
    const mode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
    // ğŸ¯ CORREÃ‡ÃƒO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');

    if (mode !== 'reference' || !refId) {
      return { ok: false, reason: 'no-ref-mode-or-id' };
    }

    // Fonte de verdade: AnalysisCache âœ FirstAnalysisStore âœ __FIRST_ANALYSIS_FROZEN__
    const cache = window.AnalysisCache;
    let ref = cache?.get?.(refId) || window.FirstAnalysisStore?.get?.() || window.__FIRST_ANALYSIS_FROZEN__;

    if (!ref) {
      return { ok: false, reason: 'no-ref-object' };
    }

    // deep clone SEM compartilhar metadata/bands
    const refClone = (typeof structuredClone === 'function') 
      ? structuredClone(ref) 
      : JSON.parse(JSON.stringify(ref));

    // Normalizar shape esperado (bands/technicalData/metadata)
    if (!refClone.bands && refClone.spectralBands) {
      refClone.bands = refClone.spectralBands;
    }

    // Publicar referÃªncia consistente no escopo global
    window.referenceAnalysisData = refClone;
    window.__FIRST_ANALYSIS_FROZEN__ = (typeof structuredClone === 'function') 
      ? structuredClone(refClone) 
      : JSON.parse(JSON.stringify(refClone));

    // SinalizaÃ§Ã£o
    console.log('[ensureReferenceHydrated] âœ… ReferÃªncia hidratada:', {
      refId,
      hasBands: !!refClone?.bands,
      file: refClone?.metadata?.fileName || refClone?.fileName
    });

    return { 
      ok: true, 
      refId, 
      hasBands: !!refClone?.bands, 
      file: refClone?.metadata?.fileName || refClone?.fileName 
    };
  } catch (e) {
    console.warn('[ensureReferenceHydrated] âŒ erro', e);
    return { ok: false, reason: 'exception', error: String(e) };
  }
}

// ========================================
// ğŸ›¡ï¸ GUARDIÃƒO GLOBAL: aiUIController Stub
// ========================================
/**
 * Garante que aiUIController sempre existe, mesmo antes do carregamento completo.
 * Cria stub temporÃ¡rio que Ã© substituÃ­do quando o controller real Ã© carregado.
 */
(function ensureAIUIController() {
  if (!window.aiUIController) {
    console.warn('[SAFE-BOOT] aiUIController ausente - criando stub temporario.');

    window.aiUIController = {
      renderMetricCards: () => console.warn('[STUB] renderMetricCards chamado antes da carga real.'),
      renderScoreSection: () => console.warn('[STUB] renderScoreSection chamado antes da carga real.'),
      renderSuggestions: () => console.warn('[STUB] renderSuggestions chamado antes da carga real.'),
      renderFinalScoreAtTop: () => console.warn('[STUB] renderFinalScoreAtTop chamado antes da carga real.'),
      checkForAISuggestions: () => console.warn('[STUB] checkForAISuggestions chamado antes da carga real.')
    };
  }

  // Espera ate o real ser carregado (quando o modulo UI inicializa)
  const observer = new MutationObserver(() => {
    if (window.aiUIController?.__ready) {
      console.log('[SAFE-BOOT] âœ… aiUIController real detectado, removendo stub.');
      
      // ========================================
      // âœ… AUDITORIA DE COMPATIBILIDADE
      // ========================================
      const requiredFunctions = [
        'renderMetricCards',
        'renderScoreSection',
        'renderSuggestions',
        'renderFinalScoreAtTop',
        'checkForAISuggestions'
      ];
      
      const missingFunctions = requiredFunctions.filter(
        fn => typeof window.aiUIController[fn] !== 'function'
      );
      
      if (missingFunctions.length === 0) {
        console.log('[COMPAT] âœ… aiUIController detectado com todas as funÃ§Ãµes esperadas');
        console.log('[COMPAT] FunÃ§Ãµes disponÃ­veis:', requiredFunctions);
      } else {
        console.error('[COMPAT-FAIL] âŒ FunÃ§Ãµes ausentes:', missingFunctions);
        console.error('[COMPAT-FAIL] Tipo de aiUIController:', typeof window.aiUIController);
        console.error('[COMPAT-FAIL] ProtÃ³tipo:', Object.getPrototypeOf(window.aiUIController));
      }
      
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
})();

// ========================================
// âœ… CORREÃ‡ÃƒO 4: Alias Seguro para aiUIController
// ========================================
// Garantir que funÃ§Ãµes legadas estejam disponÃ­veis como fallback
(function createAIUIControllerAliases() {
  if (!window.aiUIController) window.aiUIController = {};
  
  // Se renderMetricCards nÃ£o existe mas existe funÃ§Ã£o global, criar alias
  if (typeof window.aiUIController.renderMetricCards !== 'function' && 
      typeof window.renderMetricCards === 'function') {
    window.aiUIController.renderMetricCards = (...args) => window.renderMetricCards(...args);
    console.log('[ALIAS] âœ… Criado alias: aiUIController.renderMetricCards â†’ renderMetricCards');
  }
  
  if (typeof window.aiUIController.renderScoreSection !== 'function' && 
      typeof window.renderScoreSection === 'function') {
    window.aiUIController.renderScoreSection = (...args) => window.renderScoreSection(...args);
    console.log('[ALIAS] âœ… Criado alias: aiUIController.renderScoreSection â†’ renderScoreSection');
  }
  
  if (typeof window.aiUIController.renderSuggestions !== 'function' && 
      typeof window.renderSuggestions === 'function') {
    window.aiUIController.renderSuggestions = (...args) => window.renderSuggestions(...args);
    console.log('[ALIAS] âœ… Criado alias: aiUIController.renderSuggestions â†’ renderSuggestions');
  }
  
  if (typeof window.aiUIController.renderFinalScoreAtTop !== 'function' && 
      typeof window.renderFinalScoreAtTop === 'function') {
    window.aiUIController.renderFinalScoreAtTop = (...args) => window.renderFinalScoreAtTop(...args);
    console.log('[ALIAS] âœ… Criado alias: aiUIController.renderFinalScoreAtTop â†’ renderFinalScoreAtTop');
  }
})();

// ğŸ“ Carregar gerador de texto didÃ¡tico
if (typeof window !== 'undefined' && !window.SuggestionTextGenerator) {
    const script = document.createElement('script');
    script.src = 'suggestion-text-generator.js';
    script.async = true;
    script.onload = () => {
        console.log('[AudioIntegration] Gerador de texto didÃ¡tico carregado');
    };
    script.onerror = () => {
        console.warn('[AudioIntegration] Falha ao carregar gerador de texto didÃ¡tico');
    };
    document.head.appendChild(script);
}

// Debug flag (silencia logs em produÃ§Ã£o; defina window.DEBUG_ANALYZER = true para habilitar)
const __DEBUG_ANALYZER__ = true; // ğŸ”§ TEMPORÃRIO: Ativado para debug do problema
const __dbg = (...a) => { if (__DEBUG_ANALYZER__) console.log('[AUDIO-DEBUG]', ...a); };
const __dwrn = (...a) => { if (__DEBUG_ANALYZER__) console.warn('[AUDIO-WARN]', ...a); };

// ========================================
// ğŸ—‚ï¸ STORES GLOBAIS: AnalysisCache + FirstAnalysisStore
// ========================================
(function initGlobalStores() {
  if (!window.AnalysisCache) {
    // ğŸ”§ ImplementaÃ§Ã£o segura sem recursÃ£o infinita
    const _data = new Map();
    
    window.AnalysisCache = {
      _data: _data,
      
      get(key) {
        if (!key) return null;
        const value = this._data.get(key);
        return value ? cloneDeepSafe(value) : null;
      },
      
      set(key, value) {
        if (!key || !value) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(value)));
      },
      
      has(key) {
        return key ? this._data.has(key) : false;
      },
      
      delete(key) {
        return this._data.delete(key);
      },
      
      clear() {
        this._data.clear();
        console.log('[CACHE] ğŸ—‘ï¸ clear');
      },
      
      // ğŸ”§ API ESTENDIDA: Suporta Virtual IDs (vid) ou jobId simples
      put(keyOrAnalysis, analysis) {
        // Suporta: put(vid, analysis) ou put(analysis)
        let key, data;
        if (typeof keyOrAnalysis === 'string' && analysis) {
          key = keyOrAnalysis; // Virtual ID explÃ­cito
          data = analysis;
        } else {
          data = keyOrAnalysis;
          key = data?.jobId || data?.id; // Backward compatibility
        }
        
        if (!key || !data) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(data)));
        console.log('[CACHE] âœ… put', { 
          vid: key, 
          file: data?.fileName || data?.metadata?.fileName,
          isVirtualId: key.includes('::')
        });
      },
      
      ids() {
        return Array.from(this._data.keys());
      }
    };
    
    console.log('[BOOT] AnalysisCache âœ… (Virtual ID support, no recursion)');
  }

  if (!window.FirstAnalysisStore) {
    const _state = {
      user: null,      // Primeira faixa (USER)
      userVid: null,   // Virtual ID do user
      userJobId: null, // jobId original do user
      ref: null,       // Segunda faixa (REF)
      refVid: null,    // Virtual ID da ref
      refJobId: null   // jobId original da ref
    };

    window.FirstAnalysisStore = {
      // ========================================
      // ğŸ¯ API POR PAPEL (USER/REF)
      // ========================================
      setUser(analysis, vid, jobId) {
        if (_state.user) {
          console.warn('[FIRST-STORE] âš ï¸ USER jÃ¡ existe - nÃ£o sobrescrever');
          return; // set-once para user
        }
        _state.user = analysis;
        _state.userVid = vid;
        _state.userJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] âœ… setUser', { 
          vid, 
          jobId: _state.userJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      setRef(analysis, vid, jobId) {
        // REF pode ser sobrescrito (usuÃ¡rio pode trocar segunda faixa)
        _state.ref = analysis;
        _state.refVid = vid;
        _state.refJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] âœ… setRef', { 
          vid, 
          jobId: _state.refJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      getUser() {
        if (_state.user) return _state.user;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.USER);
          console.log('[FIRST-STORE] â™»ï¸ RESTORE USER from cache', { vid: window.CacheIndex.USER });
          return restored;
        }
        return null;
      },
      
      getRef() {
        if (_state.ref) return _state.ref;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.REF && window.AnalysisCache?.has(window.CacheIndex.REF)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.REF);
          console.log('[FIRST-STORE] â™»ï¸ RESTORE REF from cache', { vid: window.CacheIndex.REF });
          return restored;
        }
        return null;
      },
      
      has() { 
        return !!_state.user || !!(window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER));
      },
      
      // ========================================
      // ğŸ”§ COMPATIBILIDADE COM API ANTIGA
      // ========================================
      set(analysis) {
        // Backward compatibility: se nÃ£o tem user, assume que Ã© o primeiro
        if (!_state.user) {
          const jobId = analysis?.jobId || analysis?.id;
          const vid = `${jobId}::USER`;
          this.setUser(analysis, vid, jobId);
          window.CacheIndex.USER = vid;
          
          // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager ao invÃ©s de localStorage direto
          try { 
            window.StorageManager.setReferenceJobId(jobId || '');
          } catch (e) {
            console.warn('[FIRST-STORE] âš ï¸ Falha ao salvar referenceJobId:', e);
          }
        } else {
          console.warn('[FIRST-STORE] âš ï¸ set() chamado mas USER jÃ¡ existe - use setRef()');
        }
      },
      
      get() {
        // Backward compatibility: retorna user (primeira faixa)
        return this.getUser();
      },
      
      id() { return _state.userJobId; },
      jobId() { return _state.userJobId; },
      
      clear() { 
        _state.user = null;
        _state.userVid = null;
        _state.userJobId = null;
        _state.ref = null;
        _state.refVid = null;
        _state.refJobId = null;
        window.CacheIndex.USER = null;
        window.CacheIndex.REF = null;
        
        // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager
        try { 
          window.StorageManager.clearReference();
        } catch (e) {
          console.warn('[FIRST-STORE] âš ï¸ Falha ao limpar referÃªncia:', e);
        }
        
        console.log('[FIRST-STORE] ğŸ—‘ï¸ clear (USER + REF)');
      },
      
      // ========================================
      // ğŸ“Š DEBUG
      // ========================================
      _debug() {
        return {
          hasUser: !!_state.user,
          hasRef: !!_state.ref,
          userVid: _state.userVid,
          refVid: _state.refVid,
          userJobId: _state.userJobId,
          refJobId: _state.refJobId,
          cacheIndexUser: window.CacheIndex.USER,
          cacheIndexRef: window.CacheIndex.REF
        };
      }
    };
    console.log('[BOOT] FirstAnalysisStore âœ… (Role-based: USER/REF)');
  }
})();

// Alias global para compatibilidade com cÃ³digo existente
const FirstAnalysisStore = window.FirstAnalysisStore;

// ========================================
// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: Cache por Papel (Role)
// ========================================
/**
 * Salva resultado de anÃ¡lise com Virtual ID baseado no papel (USER ou REF)
 * @param {Object} result - Resultado da anÃ¡lise do backend
 * @param {Object} options - { isSecondTrack: boolean }
 * @returns {Object} { vid: string, clone: Object }
 */
function cacheResultByRole(result, { isSecondTrack }) {
  // Normalizar dados do backend
  const base = normalizeBackendAnalysisData(result);
  
  // Clone profundo para evitar mutaÃ§Ãµes
  const clone = (typeof structuredClone === 'function') 
    ? structuredClone(base) 
    : JSON.parse(JSON.stringify(base));
  
  // Criar Virtual ID: jobId + papel (USER ou REF)
  const jobId = result.jobId || result.id;
  const role = isSecondTrack ? 'REF' : 'USER';
  const vid = `${jobId}::${role}`;
  
  // Salvar no cache com VID
  window.AnalysisCache.put(vid, clone);
  
  // Atualizar Ã­ndice de papÃ©is
  if (isSecondTrack) {
    window.CacheIndex.REF = vid;
  } else {
    window.CacheIndex.USER = vid;
  }
  
  console.log('[VID] âœ… Cached by role', { 
    vid, 
    role, 
    jobId, 
    file: clone?.fileName || clone?.metadata?.fileName,
    isSecondTrack
  });
  
  return { vid, clone };
}

// ï¿½ï¸ GUARDS: Isolamento de jobIds para evitar self-compare
// Recebe objetos jÃ¡ clonados e garante que refFull tenha jobId Ãºnico se necessÃ¡rio
function refHardGuards({ userFull, refFull, secondAnalysis }) {
    // ========================================
    // âœ… CORREÃ‡ÃƒO 4: ValidaÃ§Ã£o de entrada
    // ========================================
    if (!userFull) {
        console.warn('[refHardGuards] âš ï¸ userFull invÃ¡lido');
        return { ok: false, reason: 'invalid-user' };
    }
    if (!refFull) {
        console.warn('[refHardGuards] âš ï¸ refFull invÃ¡lido');
        return { ok: false, reason: 'invalid-ref' };
    }

    const userId = userFull?.jobId || userFull?.id;
    const refId = refFull?.jobId || refFull?.id;
    const secondId = secondAnalysis?.jobId || secondAnalysis?.id;

    // Se jobIds sÃ£o iguais, forÃ§a isolamento adicionando sufixo __ref
    if (userId && refId && userId === refId) {
        console.warn('[GUARD] âš ï¸ jobIds iguais, isolando referÃªncia com sufixo __ref');
        // Clone para evitar mutaÃ§Ã£o do original
        refFull = (typeof structuredClone === 'function')
            ? structuredClone(refFull)
            : JSON.parse(JSON.stringify(refFull));
        refFull.jobId = `${refId}__ref`; // forÃ§a ID diferente
    }

    console.log('[GUARD] âœ… userJobId:', userId, '| refJobId:', refFull?.jobId || refFull?.id);
    return { ok: true, userFull, refFull };
}

// ï¿½ğŸ”’ CLONE PROFUNDO SEGURO (sem loops circulares)
// Substitui JSON.parse(JSON.stringify()) com proteÃ§Ã£o contra referÃªncias circulares
function deepCloneSafe(obj, seen = new WeakMap()) {
    // Primitivos e null retornam direto
    if (obj === null || typeof obj !== 'object') return obj;
    
    // Se jÃ¡ visitamos este objeto, retornar clone existente (evita loop infinito)
    if (seen.has(obj)) return seen.get(obj);
    
    // Criar estrutura base (array ou objeto)
    const clone = Array.isArray(obj) ? [] : {};
    
    // Registrar no mapa ANTES de clonar propriedades (previne recursÃ£o infinita)
    seen.set(obj, clone);
    
    // Clonar cada propriedade recursivamente
    for (const key in obj) {
        // Ignorar propriedades especÃ­ficas que causam loops circulares
        if (key === '_referenceAnalysis') {
            console.log('[DEEP-CLONE] âš ï¸ Propriedade circular ignorada:', key);
            continue;
        }
        
        // Verificar se propriedade Ã© prÃ³pria (nÃ£o herdada)
        if (Object.hasOwn(obj, key)) {
            clone[key] = deepCloneSafe(obj[key], seen);
        }
    }
    
    return clone;
}

// ï¿½ STRINGIFY SEGURO (sem loops circulares)
// Substitui JSON.stringify() com proteÃ§Ã£o contra referÃªncias circulares
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (key, value) => {
        // Detectar e marcar referÃªncias circulares
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
        }
        
        // Omitir propriedades especÃ­ficas que causam loops
        if (key === "_referenceAnalysis" || key === "referenceAnalysis") {
            return "[OmittedRef]";
        }
        
        // Omitir propriedades privadas (comeÃ§am com _)
        if (key && key.startsWith("_")) {
            return undefined;
        }
        
        return value;
    }, 2); // IndentaÃ§Ã£o de 2 espaÃ§os para legibilidade
}

// ï¿½ğŸ›¡ï¸ HELPER: Comparador robusto de faixas (evita falso self-compare)
function areSameTrack(a, b) {
    if (!a || !b) return false;

    // Prioridade 1: jobId
    const aj = a.jobId || a.id;
    const bj = b.jobId || b.id;
    if (aj && bj) return aj === bj;

    // Prioridade 2: fileKey
    if (a.fileKey && b.fileKey) return a.fileKey === b.fileKey;

    // Prioridade 3: fileName + sampleRate + duraÃ§Ã£o aproximada
    const nameEqual = a.fileName && b.fileName && a.fileName === b.fileName;
    const srA = a.sampleRate || a.metadata?.sampleRate;
    const srB = b.sampleRate || b.metadata?.sampleRate;
    const durA = a.duration || a.metadata?.duration;
    const durB = b.duration || b.metadata?.duration;
    if (nameEqual && srA && srB && srA === srB) {
        const diff = Math.abs((durA || 0) - (durB || 0));
        return diff < 0.2;
    }

    return false;
}

// =============== CLONE & SANITIZE (SEM CICLOS) ===============
function safeDeepClone(obj, cache = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (cache.has(obj)) return cache.get(obj);

    if (Array.isArray(obj)) {
        const arr = [];
        cache.set(obj, arr);
        obj.forEach(v => arr.push(safeDeepClone(v, cache)));
        return arr;
    }

    const clone = {};
    cache.set(obj, clone);

    for (const key of Object.keys(obj)) {
        // Remove referÃªncias internas e funÃ§Ãµes
        if (key.startsWith('_') || typeof obj[key] === 'function' || typeof obj[key] === 'symbol') continue;
        clone[key] = safeDeepClone(obj[key], cache);
    }

    return clone;
}

// Reduz o objeto de anÃ¡lise para apenas o necessÃ¡rio
function pickAnalysisFields(a) {
    if (!a) return a;
    const s = safeDeepClone(a);
    return {
        id: s.id ?? s.jobId,
        jobId: s.jobId ?? s.id,
        fileKey: s.fileKey,
        fileName: s.fileName,
        loudness: s.loudness,
        dynamics: s.dynamics,
        spectral: s.spectral,
        metrics: s.metrics,
        technicalData: s.technicalData,
        bands: s.bands,
        spectralBands: s.spectralBands,
        metadata: s.metadata,
    };
}

// NormalizaÃ§Ã£o segura (copia antes de processar)
function normalizeSafe(raw) {
    return normalizeBackendAnalysisData(pickAnalysisFields(raw));
}

// ğŸ†” SISTEMA runId - FunÃ§Ã£o utilitÃ¡ria centralizada
function generateAnalysisRunId(context = 'ui') {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${context}_${timestamp}_${random}`;
}

// ğŸ›¡ï¸ HELPER: Preparar options com runId de forma segura
function prepareAnalysisOptions(baseOptions = {}, context = 'analysis') {
    // Gerar runId se nÃ£o fornecido
    if (!baseOptions.runId) {
        baseOptions.runId = generateAnalysisRunId(context);
    }
    
    // Configurar variÃ¡vel global para UI_GATE
    window.__CURRENT_ANALYSIS_RUN_ID__ = baseOptions.runId;
    
    __dbg(`ğŸ†” [runId] Preparado para anÃ¡lise: ${baseOptions.runId} (contexto: ${context})`);
    
    return { ...baseOptions };
}

// ğŸ” FUNÃ‡ÃƒO DE DIAGNÃ“STICO DO FLUXO DE REFERÃŠNCIA
window.diagnosticReferenceFlow = function() {
    console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    console.log('%cğŸ” DIAGNÃ“STICO COMPLETO DO FLUXO DE REFERÃŠNCIA', 'color:#00FFFF;font-weight:bold;');
    console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    
    console.log('%cğŸ“Š Estado Atual:', 'color:#FFD700;font-weight:bold;');
    console.log('  Mode:', currentAnalysisMode);
    console.log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'null');
    console.log('  localStorage.referenceJobId:', localStorage.getItem('referenceJobId') || 'null');
    
    console.log('%cğŸ—‚ï¸ Estado Global:', 'color:#FFD700;font-weight:bold;');
    console.log('  window.__soundyState:', window.__soundyState);
    console.log('  previousAnalysis:', window.__soundyState?.previousAnalysis?.jobId || 'null');
    console.log('  userAnalysis:', window.__soundyState?.userAnalysis?.jobId || 'null');
    console.log('  referenceAnalysis:', window.__soundyState?.referenceAnalysis?.jobId || 'null');
    
    console.log('%cğŸ’¾ Dados de ReferÃªncia:', 'color:#FFD700;font-weight:bold;');
    console.log('  FirstAnalysisStore:', FirstAnalysisStore.has() ? 'PRESENTE' : 'null');
    console.log('  window.referenceComparisonMetrics:', window.referenceComparisonMetrics ? 'PRESENTE' : 'null');
    
    console.log('%cğŸ¯ DiagnÃ³stico:', 'color:#00FF00;font-weight:bold;');
    // ğŸ¯ CORREÃ‡ÃƒO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');
    if (currentAnalysisMode === 'reference') {
        if (!refId) {
            console.log('  âœ… Primeira mÃºsica - pronto para receber segunda');
        } else {
            console.log('  âœ… Aguardando segunda mÃºsica');
            console.log(`  ğŸ“Œ Job ID da primeira: ${refId}`);
        }
    } else {
        console.log('  â„¹ï¸ Modo atual nÃ£o Ã© "reference"');
    }
    
    console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    console.log('%cğŸ’¡ Para testar:', 'color:#FFFF00;');
    console.log('  1. FaÃ§a upload da primeira mÃºsica');
    console.log('  2. Verifique se [REF-SAVE âœ…] aparece');
    console.log('  3. FaÃ§a upload da segunda mÃºsica');
    console.log('  4. Verifique se [REF-LOAD âœ…] e [REF-FIX-PAYLOAD] aparecem');
    console.log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
};

let currentModalAnalysis = null;
let __audioIntegrationInitialized = false; // evita listeners duplicados
let __refDataCache = {}; // cache por gÃªnero
let __activeRefData = null; // dados do gÃªnero atual
let __genreManifest = null; // manifesto de gÃªneros (opcional)
let __activeRefGenre = null; // chave do gÃªnero atualmente carregado em __activeRefData
let __refDerivedStats = {}; // estatÃ­sticas agregadas (ex: mÃ©dia stereo) por gÃªnero

// ğŸ¯ MODO REFERÃŠNCIA - VariÃ¡veis globais
let currentAnalysisMode = 'genre'; // 'genre' | 'reference'
let referenceStepState = {
    currentStep: 'userAudio', // 'userAudio' | 'referenceAudio' | 'analysis'
    userAudioFile: null,
    referenceAudioFile: null,
    userAnalysis: null,
    referenceAnalysis: null
};

// ========================================
// ğŸ”¥ STATE MACHINE - VIEW MODE CONTROLLER
// ========================================
// Controla qual UI deve ser renderizada (gÃªnero vs referÃªncia)
// Impede contaminaÃ§Ã£o entre modos
window.__soundyViewMode = window.__soundyViewMode || "genre";

function setViewMode(mode) {
    const validModes = ["genre", "reference"];
    if (!validModes.includes(mode)) {
        console.error("[VIEW-MODE] âŒ Modo invÃ¡lido:", mode);
        return;
    }
    
    const oldMode = window.__soundyViewMode;
    window.__soundyViewMode = mode;
    
    console.log(`%c[VIEW-MODE] ğŸ”„ Alterado: ${oldMode} â†’ ${mode}`, 'color:#00D9FF;font-weight:bold;font-size:13px;');
    
    // Limpar estado do modo anterior
    if (mode === "genre" && oldMode === "reference") {
        console.log("[VIEW-MODE] ğŸ§¹ Limpando estado de referÃªncia ao mudar para gÃªnero");
        resetReferenceStateFully();
    }
}

function getViewMode() {
    return window.__soundyViewMode || "genre";
}

// ğŸ”’ GUARD: Bloqueia execuÃ§Ã£o de UI de referÃªncia no modo gÃªnero
function canRunReferenceUI(analysis) {
    const viewMode = getViewMode();
    
    // Regra 1: ViewMode deve ser "reference"
    if (viewMode !== "reference") {
        console.log(`%c[REFERENCE-GUARD] ğŸš« Bloqueando UI de referÃªncia`, 'color:#FF6B6B;font-weight:bold;');
        console.log(`[REFERENCE-GUARD]    viewMode atual: "${viewMode}" (esperado: "reference")`);
        return false;
    }
    
    // Regra 2: AnÃ¡lise deve existir
    if (!analysis) {
        console.log('[REFERENCE-GUARD] ğŸš« Bloqueando: analysis nÃ£o existe');
        return false;
    }
    
    // Regra 3: Deve ter dados de referÃªncia
    const hasRefComparison = !!analysis.referenceComparison;
    const hasRefJobId = !!analysis.referenceJobId || !!analysis.metadata?.referenceJobId || !!window.__REFERENCE_JOB_ID__;
    const hasRefData = !!window.referenceAnalysisData;
    
    if (!hasRefComparison && !hasRefJobId && !hasRefData) {
        console.log('[REFERENCE-GUARD] ğŸš« Bloqueando: sem dados de referÃªncia');
        console.log('[REFERENCE-GUARD]    referenceComparison:', hasRefComparison);
        console.log('[REFERENCE-GUARD]    referenceJobId:', hasRefJobId);
        console.log('[REFERENCE-GUARD]    referenceAnalysisData:', hasRefData);
        return false;
    }
    
    // Regra 4: Mode deve ser "reference"
    if (analysis.mode !== 'reference' && analysis.isReferenceBase !== true) {
        console.log('[REFERENCE-GUARD] ğŸš« Bloqueando: analysis.mode nÃ£o Ã© "reference"');
        console.log('[REFERENCE-GUARD]    analysis.mode:', analysis.mode);
        console.log('[REFERENCE-GUARD]    analysis.isReferenceBase:', analysis.isReferenceBase);
        return false;
    }
    
    console.log('%c[REFERENCE-GUARD] âœ… Permitindo UI de referÃªncia', 'color:#00FF88;font-weight:bold;');
    return true;
}

// ğŸ¯ COMPARAÃ‡ÃƒO ENTRE FAIXAS - Armazenamento da primeira anÃ¡lise
window.lastReferenceJobId = null;
// âŒ REMOVER: window.referenceAnalysisData agora Ã© definido como getter read-only dinamicamente
// quando a primeira anÃ¡lise Ã© salva via FirstAnalysisStore.setOnce()

// ğŸ¯ COMPARAÃ‡ÃƒO ENTRE FAIXAS - MÃ©tricas de comparaÃ§Ã£o (substitui __activeRefData quando em modo reference)
let referenceComparisonMetrics = null;

// ğŸ¯ JOBS - Sistema de acompanhamento de jobs remotos
let currentJobId = null;
let jobPollingInterval = null;

// ğŸ¯ FunÃ§Ãµes de Acessibilidade e GestÃ£o de Modais

function openModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no primeiro botÃ£o
        const firstButton = modal.querySelector('.mode-card button');
        if (firstButton) {
            firstButton.focus();
        }
        
        // Adicionar listener para ESC
        document.addEventListener('keydown', handleModalEscapeKey);
        
        // Trap focus no modal
        trapFocus(modal);
    }
}

function closeModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        
        // Remover listeners
        document.removeEventListener('keydown', handleModalEscapeKey);
        
        // Retornar foco para o botÃ£o que abriu o modal
        const audioAnalysisBtn = document.querySelector('button[onclick="openAudioModal()"]');
        if (audioAnalysisBtn) {
            audioAnalysisBtn.focus();
        }
    }
}

function handleModalEscapeKey(e) {
    if (e.key === 'Escape') {
        closeModeSelectionModal();
    }
}

function trapFocus(modal) {
    const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const handleTabKey = (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
            } else if (!e.shiftKey && document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
            }
        }
    };
    
    modal.addEventListener('keydown', handleTabKey);
}

// ğŸ¯ FunÃ§Ã£o Principal de SeleÃ§Ã£o de Modo
function selectAnalysisMode(mode) {
    console.log('ğŸ¯ Modo selecionado:', mode);
    
    // ========================================
    // ğŸ”¥ BARREIRA 4: LIMPEZA AO SELECIONAR MODO GÃŠNERO
    // ========================================
    if (mode === 'genre') {
        console.log('%c[GENRE-BARRIER] ğŸš§ BARREIRA 4 ATIVADA: Modo gÃªnero selecionado', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
        
        // ğŸ”¥ EXECUTAR LIMPEZA COMPLETA do estado de referÃªncia
        resetReferenceStateFully();
        
        console.log('%c[GENRE-BARRIER] âœ… BARREIRA 4 CONCLUÃDA: Estado limpo ao selecionar gÃªnero', 'color:#00FF88;font-weight:bold;');
    }
    
    // Armazenar modo selecionado
    window.currentAnalysisMode = mode;
    
    // Fechar modal de seleÃ§Ã£o
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // Modo tradicional - abrir modal de anÃ¡lise normal
        openAnalysisModalForMode('genre');
    } else if (mode === 'reference') {
        // Modo referÃªncia - abrir interface especÃ­fica
        openAnalysisModalForMode('reference');
    }
}

// ğŸ¯ Modal de AnÃ¡lise por ReferÃªncia
function openReferenceAnalysisModal() {
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        // Configurar modal para modo referÃªncia
        const modalContent = modal.querySelector('.modal-content');
        const title = modalContent.querySelector('h2');
        const steps = document.getElementById('referenceProgressSteps');
        
        if (title) {
            title.textContent = 'ğŸµ AnÃ¡lise por MÃºsica de ReferÃªncia';
        }
        
        // Mostrar passos do progresso
        if (steps) {
            steps.style.display = 'block';
            updateProgressStep(1); // Primeiro passo ativo
        }
        
        // Modificar texto do botÃ£o de upload
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn) {
            uploadBtn.textContent = 'ğŸ“¤ Upload da MÃºsica Original';
            uploadBtn.onclick = () => handleReferenceFileSelection('original');
        }
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no botÃ£o de upload
        if (uploadBtn) {
            uploadBtn.focus();
        }
    }
}

// ğŸ¯ GestÃ£o de Progresso para Modo ReferÃªncia
function updateProgressStep(step) {
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((stepEl, index) => {
        const stepNumber = index + 1;
        stepEl.classList.remove('active', 'completed');
        
        if (stepNumber < step) {
            stepEl.classList.add('completed');
        } else if (stepNumber === step) {
            stepEl.classList.add('active');
        }
    });
}

// ï¿½ SISTEMA DE UPLOAD E ANÃLISE REMOTA
// âœ… FLUXO OFICIAL: Presigned URL â†’ Upload â†’ Job Creation â†’ Status Polling

// ï¿½ğŸ¯ SeleÃ§Ã£o de Arquivos para Modo ReferÃªncia (fileKeys apenas)
let uploadedFiles = {
    original: null,
    reference: null
};

/**
 * âœ… OBTER URL PRÃ‰-ASSINADA DO BACKEND
/**
 * Obter URL prÃ©-assinada do backend
/**
 * ğŸš€ OBTER URL PRÃ‰-ASSINADA DO BACKEND
 * @param {File} file - Arquivo para upload
 * @returns {Promise<{uploadUrl: string, fileKey: string}>}
 */
async function getPresignedUrl(file) {
  try {
    // Extrair extensÃ£o do arquivo
    const ext = file.name.split('.').pop().toLowerCase();

    __dbg('ğŸŒ Solicitando URL prÃ©-assinada...', {
      filename: file.name,
      ext,
           size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
    });

    // âœ… Agora manda "ext" 
    const response = await fetch(`/api/presign?ext=${encodeURIComponent(ext)}`, {
  method: "GET",
  headers: {
    "Accept": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao obter URL de upload: ${response.status} - ${errorText}`);
    }

    const data = await response.json();

    if (!data.uploadUrl || !data.fileKey) {
      throw new Error('Resposta invÃ¡lida do servidor: uploadUrl ou fileKey ausente');
    }

    return {
      uploadUrl: data.uploadUrl,
      fileKey: data.fileKey
    };
  } catch (error) {
    console.error('âŒ Erro ao obter URL prÃ©-assinada:', error);
    throw new Error(`Falha ao gerar URL de upload: ${error.message}`);
  }
}



/**
 * âœ… UPLOAD DIRETO PARA BUCKET VIA URL PRÃ‰-ASSINADA
 * @param {string} uploadUrl - URL prÃ©-assinada para upload
 * @param {File} file - Arquivo para upload
 * @returns {Promise<void>}
 */
async function uploadToBucket(uploadUrl, file) {
  try {
    __dbg('ğŸ“¤ Iniciando upload para bucket...', { 
      filename: file.name,
      size: `${(file.size / 1024 / 1024).toFixed(2)}MB`,
      url: uploadUrl.substring(0, 50) + '...'
    });

    showUploadProgress(`Enviando ${file.name} para anÃ¡lise...`);

    // ğŸ‘‡ sem headers, sÃ³ body = file
   const response = await fetch(uploadUrl, {
  method: "PUT",
  body: file
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
    }

    __dbg('âœ… Upload para bucket concluÃ­do com sucesso');
    showUploadProgress(`Upload concluÃ­do! Processando ${file.name}...`);

  } catch (error) {
    console.error('âŒ Erro no upload para bucket:', error);
    throw new Error(`Falha ao enviar arquivo para anÃ¡lise: ${error.message}`);
  }
}


/**
 * âœ… CRIAR JOB DE ANÃLISE NO BACKEND
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} mode - Modo de anÃ¡lise ('genre' ou 'reference')
 * @param {string} fileName - Nome original do arquivo
 * @returns {Promise<{jobId: string, success: boolean}>}
 */
async function createAnalysisJob(fileKey, mode, fileName) {
    try {
        __dbg('ğŸ”§ Criando job de anÃ¡lise...', { fileKey, mode, fileName });

        // ğŸ”§ FIX CRÃTICO: Detectar se Ã© primeira ou segunda mÃºsica no modo referÃªncia
        // ğŸ¯ CORREÃ‡ÃƒO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
        console.group('ğŸ” [AUDIT-LOCALSTORAGE] createAnalysisJob - Leitura de referenceJobId');
        console.log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        console.log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
        
        // ğŸ¯ USA FUNÃ‡ÃƒO SEGURA ao invÃ©s de acesso direto
        let referenceJobId = getCorrectJobId('reference'); // Primeira mÃºsica
        
        console.log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
        console.log('   - Mode:', mode);
        console.trace('   - Stack trace:');
        console.groupEnd();
        
        let actualMode = mode;
        let isReferenceBase = false; // ğŸ”§ FIX: Flag para diferenciar primeira mÃºsica da referÃªncia
        
        // ğŸ¯ CORREÃ‡ÃƒO DO FLUXO: Primeira mÃºsica como "genre", segunda como "reference"
        if (mode === 'reference') {
            // ğŸ”„ RECUPERAÃ‡ÃƒO: Tentar restaurar referenceJobId de mÃºltiplas fontes
            if (!referenceJobId && window.__soundyState?.previousAnalysis?.jobId) {
                referenceJobId = window.__soundyState.previousAnalysis.jobId;
                console.log('[REF-LOAD âœ…] Reference Job ID restaurado do estado:', referenceJobId);
            }

            if (referenceJobId) {
                // TEM referenceJobId = Ã‰ A SEGUNDA MÃšSICA
                actualMode = 'reference'; // MantÃ©m "reference"
                isReferenceBase = false; // Segunda mÃºsica nÃ£o Ã© base
                console.log('[MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('[MODE âœ…] SEGUNDA mÃºsica detectada');
                console.log('[MODE âœ…] Mode enviado: "reference"');
                console.log(`[MODE âœ…] Reference Job ID: ${referenceJobId}`);
                console.log('[MODE âœ…] ComparaÃ§Ã£o A/B serÃ¡ realizada no backend');
                console.log('[MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            } else {
                // NÃƒO TEM referenceJobId = Ã‰ A PRIMEIRA MÃšSICA
                actualMode = 'genre'; // Envia como "genre" para anÃ¡lise normal
                isReferenceBase = true; // ğŸ”§ FIX: Marcar como primeira mÃºsica da referÃªncia
                console.log('[MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('[MODE âœ…] PRIMEIRA mÃºsica detectada');
                console.log('[MODE âœ…] Mode enviado: "genre" (base para comparaÃ§Ã£o)');
                console.log('[MODE âœ…] isReferenceBase: true (diferencia de anÃ¡lise de gÃªnero pura)');
                console.log('[MODE âœ…] Esta anÃ¡lise serÃ¡ salva como referÃªncia');
                console.log('[MODE âœ…] PrÃ³xima mÃºsica serÃ¡ comparada com esta');
                console.log('[MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            }
        }
        
        // ğŸ”’ PATCH: PRESERVAR GÃŠNERO ANTES DE MONTAR PAYLOAD
        preserveGenreState();
        
        // ğŸ¯ Usar SEMPRE o __CURRENT_SELECTED_GENRE (nÃ£o o dropdown)
        let finalGenre = window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE;
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair targets da anÃ¡lise anterior se disponÃ­vel
        let finalTargets = null;
        
        // Prioridade 1: Se hÃ¡ anÃ¡lise anterior, extrair targets dela (FONTE OFICIAL)
        const previousAnalysis = window.currentAnalysisData || window.__soundyState?.previousAnalysis;
        if (previousAnalysis) {
            console.log('[CREATE-JOB] ğŸ¯ Extraindo targets da anÃ¡lise anterior (FONTE OFICIAL)');
            finalTargets = extractGenreTargetsFromAnalysis(previousAnalysis);
            if (finalTargets) {
                console.log('[CREATE-JOB] âœ… Targets extraÃ­dos de analysis.data.genreTargets:', Object.keys(finalTargets));
            }
        }
        
        // Prioridade 2 (FALLBACK): Usar variÃ¡veis globais
        if (!finalTargets) {
            console.warn('[CREATE-JOB] âš ï¸ FALLBACK: Usando targets das variÃ¡veis globais');
            finalTargets = window.__CURRENT_GENRE_TARGETS || window.currentGenreTargets || window.__activeRefData?.targets;
        }
        
        // ğŸ”’ ValidaÃ§Ã£o robusta â€” nunca deixar vir vazio
        if (!finalGenre || typeof finalGenre !== "string" || finalGenre.trim() === "") {
            // Ãšltima tentativa: buscar do dropdown
            const genreSelect = document.getElementById('audioRefGenreSelect');
            finalGenre = genreSelect?.value || "default";
        }
        
        // Sanitizar
        finalGenre = finalGenre.trim();
        
        // âœ… GARANTIR que targets sejam incluÃ­dos no payload
        if (finalTargets) {
            console.log('âœ… [CREATE-JOB] Targets de gÃªnero incluÃ­dos no payload:', {
                genre: finalGenre,
                hasTargets: !!finalTargets,
                targetKeys: Object.keys(finalTargets),
                targetSource: window.__activeRefData?.targetSource
            });
        } else {
            console.warn('âš ï¸ [CREATE-JOB] Nenhum target encontrado para gÃªnero:', finalGenre);
        }
        
        // LOG obrigatÃ³rio
        console.log("[GENRE FINAL PAYLOAD]", {
            finalGenre,
            hasTargets: !!finalTargets,
            targetCount: finalTargets ? Object.keys(finalTargets).length : 0,
            refGenre: window.PROD_AI_REF_GENRE,
            currentSelected: window.__CURRENT_SELECTED_GENRE
        });

        // Montar payload com modo correto
        const payload = {
            fileKey: fileKey,
            mode: actualMode,
            fileName: fileName,
            isReferenceBase: isReferenceBase,
            genre: finalGenre, // ğŸ”’ PATCH: Usar finalGenre sempre
            genreTargets: finalTargets, // ğŸ”’ PATCH: Incluir targets
            hasTargets: !!finalTargets // ğŸ”’ PATCH: Flag indicando presenÃ§a de targets
        };
        
        // ğŸ”¥ GUARD PREVENTIVO: NUNCA enviar sem gÃªnero ou targets
        if (!payload.genre || !payload.genreTargets) {
            const errorMsg = `[GENRE-ERROR] GÃªnero ou targets ausentes antes do envio do job. Genre: ${payload.genre}, HasTargets: ${!!payload.genreTargets}`;
            console.error(errorMsg);
            throw new Error(errorMsg);
        }
        
        console.log('[GENRE-GUARD] âœ… Payload validado:', {
            genre: payload.genre,
            hasTargets: payload.hasTargets,
            targetCount: payload.genreTargets ? Object.keys(payload.genreTargets).length : 0
        });
        
        // Adicionar referenceJobId apenas se existir
        if (referenceJobId && actualMode === 'reference') {
            payload.referenceJobId = referenceJobId;
            
            console.log('[REF-PAYLOAD âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('[REF-PAYLOAD âœ…] Payload COM referenceJobId:');
            console.log(`[REF-PAYLOAD âœ…]   mode: "${actualMode}"`);
            console.log(`[REF-PAYLOAD âœ…]   referenceJobId: "${referenceJobId}"`);
            console.log(`[REF-PAYLOAD âœ…]   fileName: "${fileName}"`);
            console.log('[REF-PAYLOAD âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        } else if (mode === 'reference' && !referenceJobId) {
            console.log('[REF-PAYLOAD âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('[REF-PAYLOAD âœ…] Payload SEM referenceJobId (primeira mÃºsica):');
            console.log(`[REF-PAYLOAD âœ…]   mode: "${actualMode}" (anÃ¡lise base)`);
            console.log(`[REF-PAYLOAD âœ…]   isReferenceBase: ${isReferenceBase}`);
            console.log(`[REF-PAYLOAD âœ…]   fileName: "${fileName}"`);
            console.log('[REF-PAYLOAD âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        }

        // ğŸ” LOG FINAL: Mostrar payload completo antes do envio com cores
        console.log('%c[REF-FIX-VERIFY]', 'color:#00FFFF;font-weight:bold;', { mode, referenceJobId });
        console.log('%c[REF-FIX-PAYLOAD]', 'color:#7A3FFF;font-weight:bold;', payload);
        
        console.log('[FIX_REFID_PAYLOAD] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('[FIX_REFID_PAYLOAD] Payload final sendo enviado para /api/audio/analyze:');
        console.log('[FIX_REFID_PAYLOAD]', JSON.stringify(payload, null, 2));
        console.log('[FIX_REFID_PAYLOAD] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // ğŸ”’ LOG OBRIGATÃ“RIO ANTES DO FETCH
        console.log("[GENRE FINAL PAYLOAD SENT]", payload);

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro ao criar job: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        if (!data.success || !data.jobId) {
            throw new Error('Resposta invÃ¡lida do servidor: jobId ausente');
        }

        __dbg('âœ… Job de anÃ¡lise criado:', { 
            jobId: data.jobId,
            mode: data.mode,
            fileKey: data.fileKey
        });

        return {
            jobId: data.jobId,
            success: true
        };

    } catch (error) {
        console.error('âŒ Erro ao criar job de anÃ¡lise:', error);
        throw new Error(`Falha ao criar job de anÃ¡lise: ${error.message}`);
    }
}

/**
 * âœ… ACOMPANHAR STATUS DO JOB DE ANÃLISE
 * @param {string} jobId - ID do job
 * @returns {Promise<Object>} - Resultado da anÃ¡lise quando completa
 */
async function pollJobStatus(jobId) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 60; // 5 minutos mÃ¡ximo (5s * 60 = 300s)
        let initialQueuePosition = null;
        
        const poll = async () => {
            try {
                attempts++;
                __dbg(`ğŸ”„ Verificando status do job (tentativa ${attempts}/${maxAttempts})...`);

                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao verificar status: ${response.status}`);
                }

                const jobData = await response.json();
                
                __dbg(`ğŸ“Š Status do job:`, { 
                    status: jobData.status, 
                    progress: jobData.progress || 'N/A' 
                });

                // Calcular progresso baseado na posiÃ§Ã£o da fila
                let calculatedProgress = 0;
                let progressMessage = 'ğŸš€ Inicializando...';
                
                // Obter status da fila se disponÃ­vel
                const queueStatus = window.getAudioQueueStatus ? window.getAudioQueueStatus() : null;
                
                if (jobData.status === 'queued') {
                    // Job na fila - calcular posiÃ§Ã£o
                    if (queueStatus && queueStatus.queue) {
                        const totalInQueue = queueStatus.queue.total || 0;
                        
                        // Armazenar posiÃ§Ã£o inicial na primeira tentativa
                        if (initialQueuePosition === null) {
                            initialQueuePosition = totalInQueue;
                        }
                        
                        // Calcular progresso: quanto mais prÃ³ximo de 0, mais perto de processar
                        if (initialQueuePosition > 0) {
                            calculatedProgress = Math.min(
                                Math.max(
                                    ((initialQueuePosition - totalInQueue) / initialQueuePosition) * 50, // 0-50% enquanto na fila
                                    5 // MÃ­nimo 5%
                                ),
                                50
                            );
                        } else {
                            calculatedProgress = 10;
                        }
                        
                        progressMessage = `â³ Na fila... PosiÃ§Ã£o: ${totalInQueue + 1} | Processando: ${queueStatus.running || 0}`;
                    } else {
                        calculatedProgress = 10;
                        progressMessage = 'â³ Aguardando processamento...';
                    }
                } else if (jobData.status === 'processing') {
                    // Job processando - 50% a 95%
                    if (jobData.progress) {
                        // Se o backend enviar progresso especÃ­fico, usar e mapear para 50-95%
                        calculatedProgress = 50 + (jobData.progress * 0.45);
                    } else {
                        // Progresso incremental baseado em tentativas
                        calculatedProgress = 50 + Math.min((attempts - (initialQueuePosition || 0)) * 5, 45);
                    }
                    progressMessage = 'ğŸ”„ Analisando Ã¡udio...';
                } else if (jobData.status === 'completed' || jobData.status === 'done') {
                    calculatedProgress = 100;
                    progressMessage = 'âœ… AnÃ¡lise concluÃ­da!';
                }

                // Atualizar progresso na UI
                updateModalProgress(calculatedProgress, progressMessage);

                if (jobData.status === 'completed' || jobData.status === 'done') {
                    __dbg('âœ… Job concluÃ­do com sucesso');
                    
                    // ğŸ¯ NOVO: Verificar modo e decidir fluxo
                    const jobResult = jobData.result || jobData.results || jobData;
                    jobResult.jobId = jobId; // Incluir jobId no resultado
                    jobResult.mode = jobData.mode; // Incluir mode no resultado
                    
                    resolve(jobResult);
                    return;
                }

                if (jobData.status === 'failed' || jobData.status === 'error') {
                    const errorMsg = jobData.error || 'Erro desconhecido no processamento';
                    reject(new Error(`Falha na anÃ¡lise: ${errorMsg}`));
                    return;
                }

                // Status 'queued', 'processing', etc. - continuar polling
                if (attempts >= maxAttempts) {
                    reject(new Error('Timeout: AnÃ¡lise demorou mais que o esperado'));
                    return;
                }

                // Aguardar 5 segundos antes da prÃ³xima verificaÃ§Ã£o
                setTimeout(poll, 5000);

            } catch (error) {
                console.error('âŒ Erro no polling:', error);
                reject(error);
            }
        };

        // Iniciar polling
        poll();
    });
}

/**
 * Mostrar progresso de upload na UI
 * @param {string} message - Mensagem de progresso
 */
function showUploadProgress(message) {
    const progressText = document.getElementById('audioProgressText');
    if (progressText) {
        progressText.innerHTML = `ğŸŒ ${message}`;
    }
}

/**
 * Atualizar progresso do modal de anÃ¡lise
 * @param {number} percentage - Porcentagem (0-100)
 * @param {string} message - Mensagem de status
 */
function updateModalProgress(percentage, message) {
    const progressText = document.getElementById('audioProgressText');
    const progressBar = document.getElementById('audioProgressFill') || document.querySelector('.progress-fill');
    
    if (progressText) {
        progressText.innerHTML = `${message}`;
    }
    
    if (progressBar) {
        // Garantir que a porcentagem estÃ¡ entre 0 e 100
        const clampedPercentage = Math.min(Math.max(percentage, 0), 100);
        progressBar.style.width = `${clampedPercentage}%`;
        
        __dbg(`ğŸ“Š Progresso atualizado: ${clampedPercentage.toFixed(1)}%`);
    }
}

/**
 * âœ… NOVA IMPLEMENTAÃ‡ÃƒO: SeleÃ§Ã£o de arquivo de referÃªncia com presigned URL
 * @param {string} type - Tipo do arquivo ('original' ou 'reference')
 */
function handleReferenceFileSelection(type) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.wav,.flac,.mp3,.m4a';
    input.style.display = 'none';

    input.onchange = async function (e) {
        const file = e.target.files[0];
        if (file) {
            try {
                // Validar arquivo
                if (file.size > 120 * 1024 * 1024) {
                    alert('âŒ Arquivo muito grande. Limite: 120MB');
                    return;
                }

                __dbg(`ğŸ¯ Processando arquivo ${type} com presigned URL:`, file.name);

                // ğŸŒ NOVO FLUXO: Presigned URL â†’ Upload â†’ Job Creation â†’ Polling
                
                // 1. Obter URL prÃ©-assinada
                const { uploadUrl, fileKey } = await getPresignedUrl(file);
                
                // 2. Upload direto para bucket
                await uploadToBucket(uploadUrl, file);
                
                // 3. Criar job de anÃ¡lise
                const { jobId } = await createAnalysisJob(fileKey, 'reference', file.name);
                
                // 4. Aguardar resultado da anÃ¡lise
                const analysisResult = await pollJobStatus(jobId);
                
                // ğŸ” LOG DE DEBUG: Verificar se anÃ¡lise estÃ¡ completa
                console.log('ğŸ” [DEBUG] AnÃ¡lise retornada do polling:', {
                    hasResult: !!analysisResult,
                    hasTechnicalData: !!analysisResult?.technicalData,
                    avgLoudness: analysisResult?.technicalData?.avgLoudness,
                    lufsIntegrated: analysisResult?.technicalData?.lufsIntegrated,
                    truePeakDbtp: analysisResult?.technicalData?.truePeakDbtp,
                    dynamicRange: analysisResult?.technicalData?.dynamicRange
                });
                
                // ğŸ§© AUDITORIA 1: Verificar se displayModalResults estÃ¡ disponÃ­vel
                console.log("[AUDITORIA] displayModalResults:", typeof window.displayModalResults);
                
                // Mostrar resultados no modal (com validaÃ§Ã£o interna de mÃ©tricas)
                const tryShowModal = (result, attempts = 0) => {
                    if (typeof window.displayModalResults === "function") {
                        console.log("âœ… [AUDITORIA] displayModalResults encontrada, exibindo modal...");
                        console.log("âœ… [RETRY_SUCCESS] Tentativa", attempts + 1, "bem-sucedida, chamando displayModalResults");
                        console.log("[DISPLAY] Metrics modal triggered from tryShowModal");
                        displayModalResults(result);
                    } else if (attempts < 10) {
                        console.warn("[AUDITORIA] displayModalResults nÃ£o disponÃ­vel, tentativa", attempts + 1);
                        setTimeout(() => tryShowModal(result, attempts + 1), 500);
                    } else {
                        console.error("[AUDITORIA] Falha ao exibir modal apÃ³s mÃºltiplas tentativas");
                        // Fallback: tentar exibir em modal simples
                        alert("AnÃ¡lise concluÃ­da, mas modal nÃ£o pÃ´de ser exibido. Verifique o console para dados.");
                        console.log("[AUDITORIA] Dados da anÃ¡lise:", result);
                    }
                };
                
                tryShowModal(analysisResult);

                // 5. Armazenar resultado
                uploadedFiles[type] = {
                    fileKey: fileKey,
                    fileName: file.name,
                    analysisResult: analysisResult
                };

                console.log(`âœ… Arquivo ${type} processado com sucesso:`, file.name, "fileKey:", fileKey);

                // Atualizar interface
                updateFileStatus(type, file.name);

                // AvanÃ§ar fluxo
                if (type === "original") {
                    updateProgressStep(2);
                    promptReferenceFile();
                } else if (type === "reference") {
                    updateProgressStep(3);
                    enableAnalysisButton();
                }

            } catch (error) {
                console.error(`âŒ Erro no processamento do arquivo ${type}:`, error);
                alert(`âŒ Erro ao processar arquivo: ${error.message}`);

                // Abrir modal de anÃ¡lise em caso de erro
                abrirModalDeAnalise("Erro ao processar arquivo para anÃ¡lise.");
            }
        }
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}


function updateFileStatus(type, filename) {
    const statusContainer = document.getElementById('fileUploadStatus');
    if (!statusContainer) return;
    
    let statusDiv = statusContainer.querySelector(`#${type}FileStatus`);
    if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = `${type}FileStatus`;
        statusDiv.className = 'file-status';
        statusContainer.appendChild(statusDiv);
    }
    
    const label = type === 'original' ? 'ğŸµ MÃºsica Original' : 'ğŸ¯ ReferÃªncia';
    statusDiv.innerHTML = `
        <div class="file-item">
            <span class="file-label">${label}:</span>
            <span class="file-name">${filename}</span>
            <span class="file-check">âœ…</span>
        </div>
    `;
}

function promptReferenceFile() {
    const modal = document.getElementById('audioAnalysisModal');
    const uploadBtn = modal.querySelector('#uploadButton');
    
    if (uploadBtn) {
        uploadBtn.textContent = 'ğŸ¯ Upload da MÃºsica de ReferÃªncia';
        uploadBtn.onclick = () => handleReferenceFileSelection('reference');
    }
}

function enableAnalysisButton() {
    const modal = document.getElementById('audioAnalysisModal');
    let analyzeBtn = modal.querySelector('#analyzeReferenceBtn');
    
    if (!analyzeBtn) {
        analyzeBtn = document.createElement('button');
        analyzeBtn.id = 'analyzeReferenceBtn';
        analyzeBtn.className = 'btn btn-primary';
        analyzeBtn.textContent = 'ğŸ”¬ Iniciar AnÃ¡lise Comparativa';
        analyzeBtn.onclick = startReferenceAnalysis;
        
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn && uploadBtn.parentNode) {
            uploadBtn.parentNode.insertBefore(analyzeBtn, uploadBtn.nextSibling);
        }
    }
    
    analyzeBtn.style.display = 'block';
    analyzeBtn.disabled = false;
}

// ğŸ¯ AnÃ¡lise Comparativa
async function startReferenceAnalysis() {
    if (!uploadedFiles.original || !uploadedFiles.reference) {
        alert('âŒ Por favor, faÃ§a upload de ambos os arquivos');
        return;
    }

    updateProgressStep(4);

    try {
        showAnalysisProgress();

        // ğŸ¯ Extrair gÃªnero selecionado do dropdown
        const genreSelect = document.getElementById('audioRefGenreSelect');
        let selectedGenre = genreSelect?.value;
        
        // ğŸ¯ CORREÃ‡ÃƒO: Validar se Ã© string nÃ£o-vazia antes de fallback
        if (!selectedGenre || selectedGenre.trim() === '') {
            selectedGenre = window.PROD_AI_REF_GENRE || 'default';
        }
        
        console.log('[TRACE-GENRE][FRONTEND-REF] ğŸµ GÃªnero para anÃ¡lise de referÃªncia:', {
            'genreSelect.value': genreSelect?.value,
            'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE,
            'selectedGenre (final)': selectedGenre
        });

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                originalKey: uploadedFiles.original,
                referenceKey: uploadedFiles.reference,
                mode: 'reference',
                genre: selectedGenre // ğŸ¯ FIX CRÃTICO: GÃªnero agora incluÃ­do
            })
        });

        if (!response.ok) {
            throw new Error(`Erro na anÃ¡lise: ${response.status}`);
        }

        const result = await response.json();
        displayReferenceComparison(result);

    } catch (error) {
        console.error('âŒ Erro na anÃ¡lise:', error);
        alert('âŒ Erro durante a anÃ¡lise. Tente novamente.');
    }
}


function showAnalysisProgress() {
    const modal = document.getElementById('audioAnalysisModal');
    const content = modal.querySelector('.modal-content');
    
    // Criar overlay de progresso
    const progressOverlay = document.createElement('div');
    progressOverlay.id = 'analysisProgressOverlay';
    progressOverlay.className = 'analysis-progress-overlay';
    progressOverlay.innerHTML = `
        <div class="progress-content">
            <div class="spinner"></div>
            <h3>ğŸ”¬ Analisando Arquivos...</h3>
            <p>Processando caracterÃ­sticas espectrais e comparando com referÃªncia...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
        </div>
    `;
    
    content.appendChild(progressOverlay);
}

function displayReferenceComparison(data) {
    const modal = document.getElementById('audioAnalysisModal');
    const progressOverlay = document.getElementById('analysisProgressOverlay');
    
    // Remover overlay de progresso
    if (progressOverlay) {
        progressOverlay.remove();
    }
    
    // Criar seÃ§Ã£o de resultados
    const resultsSection = document.createElement('div');
    resultsSection.id = 'referenceResults';
    resultsSection.className = 'reference-results';
    
    resultsSection.innerHTML = generateComparisonHTML(data);
    
    const content = modal.querySelector('.modal-content');
    content.appendChild(resultsSection);
    
    // Scroll para resultados
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

function generateComparisonHTML(data) {
    const { original, reference, comparison } = data;
    
    return `
        <div class="comparison-header">
            <h3>ğŸ“Š AnÃ¡lise Comparativa ConcluÃ­da</h3>
            <div class="overall-similarity">
                <span class="similarity-label">Similaridade Geral:</span>
                <span class="similarity-score ${getSimilarityClass(comparison.overallSimilarity)}">
                    ${comparison.overallSimilarity}%
                </span>
            </div>
        </div>
        
        <div class="comparison-grid">
            <div class="comparison-section">
                <h4>ğŸµ MÃºsica Original</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(original)}
                </div>
            </div>
            
            <div class="comparison-section">
                <h4>ğŸ¯ MÃºsica de ReferÃªncia</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(reference)}
                </div>
            </div>
        </div>
        
        <div class="differences-section">
            <h4>ğŸ” Principais DiferenÃ§as</h4>
            <div class="differences-grid">
                ${generateDifferencesGrid(comparison.differences)}
            </div>
        </div>
        
        <div class="suggestions-section">
            <h4>ğŸ’¡ SugestÃµes de Melhoria</h4>
            <div class="suggestions-list">
                ${generateSuggestionsList(comparison.suggestions)}
            </div>
        </div>
    `;
}

function generateAudioAnalysisCard(analysis) {
    return `
        <div class="spectral-info">
            <div class="info-item">
                <span class="label">FrequÃªncia Fundamental:</span>
                <span class="value">${analysis.fundamentalFreq} Hz</span>
            </div>
            <div class="info-item">
                <span class="label">Faixa DinÃ¢mica:</span>
                <span class="value">${analysis.dynamicRange} dB</span>
            </div>
            <div class="info-item">
                <span class="label">Stereo Width:</span>
                <span class="value">${analysis.stereoWidth}%</span>
            </div>
        </div>
        
        <!-- REMOVED: Bandas de FrequÃªncia duplicada - consolidada nas mÃ©tricas avanÃ§adas -->
        <!-- frequency-bands section removed to avoid duplication -->
    `;
}

function generateDifferencesGrid(differences) {
    return differences.map(diff => `
        <div class="difference-item ${diff.severity}">
            <div class="diff-header">
                <span class="diff-parameter">${diff.parameter}</span>
                <span class="diff-value">${diff.difference}</span>
            </div>
            <div class="diff-description">${diff.description}</div>
        </div>
    `).join('');
}

function generateSuggestionsList(suggestions) {
    return suggestions.map(suggestion => `
        <div class="suggestion-item">
            <div class="suggestion-title">${suggestion.title}</div>
            <div class="suggestion-description">${suggestion.description}</div>
            <div class="suggestion-priority priority-${suggestion.priority}">
                Prioridade: ${suggestion.priority.toUpperCase()}
            </div>
        </div>
    `).join('');
}

function getSimilarityClass(similarity) {
    if (similarity >= 80) return 'high-similarity';
    if (similarity >= 60) return 'medium-similarity';
    return 'low-similarity';
}

// ğŸ¯ ExposiÃ§Ã£o de FunÃ§Ãµes Globais
window.openModeSelectionModal = openModeSelectionModal;
window.closeModeSelectionModal = closeModeSelectionModal;
window.selectAnalysisMode = selectAnalysisMode;

//! DEBUG: FunÃ§Ã£o de debug global para forÃ§ar recarga
window.forceReloadRefs = async function(genre = 'funk_bruxaria') {
    console.log('ğŸ”„ FORÃ‡A RECARGA DE REFERÃŠNCIAS:', genre);
    
    // Limpar tudo
    delete window.__refDataCache;
    window.__refDataCache = {};
    window.REFS_BYPASS_CACHE = true;
    window.__activeRefData = null;
    window.__activeRefGenre = null;
    delete window.PROD_AI_REF_DATA;
    
    console.log('ğŸ’¥ Cache limpo, forÃ§ando reload...');
    
    try {
        const result = await loadReferenceData(genre);
        console.log('âœ… Recarga forÃ§ada concluÃ­da:', {
            version: result.version,
            lufs_target: result.lufs_target,
            true_peak_target: result.true_peak_target,
            presenca_band: result.bands?.presenca?.target_db
        });
        
        // Resetar flag
        window.REFS_BYPASS_CACHE = false;
        return result;
    } catch (error) {
        console.error('ğŸ’¥ Erro na recarga forÃ§ada:', error);
        window.REFS_BYPASS_CACHE = false;
        throw error;
    }
};

// ğŸ” FunÃ§Ã£o de DiagnÃ³stico de ReferÃªncias (somente dev)
window.diagnosRefSources = function(genre = null) {
    const targetGenre = genre || __activeRefGenre || 'funk_bruxaria';
    const currentData = __activeRefData;
    const cached = __refDataCache[targetGenre];
    
    console.log('ğŸ¯ REFERÃŠNCIAS DIAGNÃ“STICO COMPLETO:', {
        requestedGenre: targetGenre,
        activeGenre: __activeRefGenre,
        currentSource: currentData ? 'loaded' : 'none',
        cacheExists: !!cached,
        REFS_ALLOW_NETWORK: typeof window !== 'undefined' ? window.REFS_ALLOW_NETWORK : 'undefined',
        currentData: currentData ? {
            version: currentData.version,
            num_tracks: currentData.num_tracks,
            lufs_target: currentData.lufs_target,
            true_peak_target: currentData.true_peak_target,
            stereo_target: currentData.stereo_target,
            sub_band: currentData.bands?.sub?.target_db,
            presenca_band: currentData.bands?.presenca?.target_db
        } : null
    });
    
    // Test fetch do JSON externo
    const testUrl = `/refs/out/${targetGenre}.json?v=diagnostic`;
    fetch(testUrl).then(r => r.json()).then(j => {
        const data = j[targetGenre];
        console.log('ğŸŒ EXTERNAL JSON TEST:', {
            url: testUrl,
            success: true,
            version: data?.version,
            num_tracks: data?.num_tracks,
            lufs_target: data?.lufs_target,
            true_peak_target: data?.true_peak_target,
            stereo_target: data?.stereo_target
        });
    }).catch(e => console.log('âŒ EXTERNAL JSON FAILED:', testUrl, e.message));
    
    return { targetGenre, currentData, cached };
};

// =============== ETAPA 2: Robustez & Completeness Helpers ===============
// Central logging para mÃ©tricas ausentes / NaN (evita console spam e facilita auditoria)
function __logMetricAnomaly(kind, key, context={}) {
    try {
        if (typeof window === 'undefined') return;
        const store = (window.__METRIC_ANOMALIES__ = window.__METRIC_ANOMALIES__ || []);
        const stamp = Date.now();
        store.push({ t: stamp, kind, key, ctx: context });
        if (window.DEBUG_ANALYZER) console.warn('[METRIC_ANOMALY]', kind, key, context);
        // Limitar tamanho
        if (store.length > 500) store.splice(0, store.length - 500);
    } catch {}
}

// Placeholder seguro para valores nÃ£o finitos (exibe 'â€”' e loga uma vez por chave por render)
function safeDisplayNumber(val, key, decimals=2) {
    if (!Number.isFinite(val)) { __logMetricAnomaly('non_finite', key); return 'â€”'; }
    return val.toFixed(decimals);
}

// ğŸ†• FunÃ§Ã£o para exibir estruturas complexas das novas mÃ©tricas
function safeDisplayComplexMetric(metric, type = 'generic') {
    if (!metric || typeof metric !== 'object') return 'â€”';
    
    switch (type) {
        case 'frequency':
            // Para dominantFrequencies
            if (metric.value !== undefined) {
                const unit = metric.unit || 'Hz';
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(1) : 'â€”';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        case 'dcOffset':
            // Para dcOffset com canais L/R
            if (metric.detailed && (metric.detailed.L !== undefined || metric.detailed.R !== undefined)) {
                const L = Number.isFinite(metric.detailed.L) ? metric.detailed.L.toFixed(4) : 'â€”';
                const R = Number.isFinite(metric.detailed.R) ? metric.detailed.R.toFixed(4) : 'â€”';
                return `L: ${L}, R: ${R}`;
            } else if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(4) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        case 'spectral':
            // Para spectralUniformity
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(3) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        default:
            // Generic: tentar exibir value ou primeiro campo numÃ©rico
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(2) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
    }
}

// InvalidaÃ§Ã£o ampla de caches derivados quando gÃªnero mudar
function invalidateReferenceDerivedCaches() {
    try {
        if (typeof window === 'undefined') return;
        delete window.PROD_AI_REF_DATA; // forÃ§a reuso atualizado
    } catch {}
}

// Enriquecimento de objeto de referÃªncia: preencher lacunas e padronizar escala
function enrichReferenceObject(refObj, genreKey) {
    try {
        if (!refObj || typeof refObj !== 'object') return refObj;
        
        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Mapear hybrid_processing para propriedades root
        if (refObj.hybrid_processing && typeof refObj.hybrid_processing === 'object') {
            const hybrid = refObj.hybrid_processing;
            
            // Mapear original_metrics
            if (hybrid.original_metrics && typeof hybrid.original_metrics === 'object') {
                refObj.original_metrics = hybrid.original_metrics;
                
                // Mapear mÃ©tricas individuais para compatibilidade
                if (hybrid.original_metrics.lufs_integrated !== undefined) {
                    refObj.lufs_target = hybrid.original_metrics.lufs_integrated;
                }
                if (hybrid.original_metrics.true_peak_dbtp !== undefined) {
                    refObj.true_peak_target = hybrid.original_metrics.true_peak_dbtp;
                }
                if (hybrid.original_metrics.dynamic_range !== undefined) {
                    refObj.dr_target = hybrid.original_metrics.dynamic_range;
                }
                if (hybrid.original_metrics.stereo_correlation !== undefined) {
                    refObj.stereo_target = hybrid.original_metrics.stereo_correlation;
                }
                if (hybrid.original_metrics.lra !== undefined) {
                    refObj.lra_target = hybrid.original_metrics.lra;
                }
            }
            
            // Mapear spectral_bands (prioridade sobre legacy)
            if (hybrid.spectral_bands && typeof hybrid.spectral_bands === 'object') {
                refObj.spectral_bands = hybrid.spectral_bands;
                // TambÃ©m atribuir a 'bands' para compatibilidade
                if (!refObj.bands) {
                    refObj.bands = hybrid.spectral_bands;
                }
            }
        }
        
        // CORREÃ‡ÃƒO CRÃTICA: Mapear legacy_compatibility para propriedades root (fallback)
        if (refObj.legacy_compatibility && typeof refObj.legacy_compatibility === 'object') {
            const legacy = refObj.legacy_compatibility;
            
            // Mapear propriedades principais (apenas se nÃ£o foram definidas por hybrid)
            if (legacy.lufs_target !== undefined && refObj.lufs_target === undefined) refObj.lufs_target = legacy.lufs_target;
            if (legacy.tol_lufs !== undefined) refObj.tol_lufs = legacy.tol_lufs;
            if (legacy.true_peak_target !== undefined && refObj.true_peak_target === undefined) refObj.true_peak_target = legacy.true_peak_target;
            if (legacy.tol_true_peak !== undefined) refObj.tol_true_peak = legacy.tol_true_peak;
            if (legacy.dr_target !== undefined && refObj.dr_target === undefined) refObj.dr_target = legacy.dr_target;
            if (legacy.tol_dr !== undefined) refObj.tol_dr = legacy.tol_dr;
            if (legacy.lra_target !== undefined && refObj.lra_target === undefined) refObj.lra_target = legacy.lra_target;
            if (legacy.tol_lra !== undefined) refObj.tol_lra = legacy.tol_lra;
            if (legacy.stereo_target !== undefined && refObj.stereo_target === undefined) refObj.stereo_target = legacy.stereo_target;
            if (legacy.tol_stereo !== undefined) refObj.tol_stereo = legacy.tol_stereo;
            
            // Mapear bandas de frequÃªncia (apenas se nÃ£o foram definidas por hybrid)
            if (legacy.bands && typeof legacy.bands === 'object' && !refObj.bands) {
                refObj.bands = legacy.bands;
            }
        }
        
        // Feature flag geral
        const enabled = (typeof window === 'undefined') || window.ENABLE_REF_ENRICHMENT !== false;
        if (!enabled) return refObj;
        // Definir escala default se ausente
        if (!refObj.scale) refObj.scale = 'log_ratio_db';
        // Preencher stereo_target se ausente usando estatÃ­sticas agregadas (Etapa 2)
        if (refObj.stereo_target == null) {
            try {
                const g = (genreKey||'').toLowerCase();
                const stat = __refDerivedStats[g];
                if (stat && Number.isFinite(stat.avgStereo) && stat.countStereo >= 2) {
                    refObj.stereo_target = stat.avgStereo;
                    refObj.__stereo_filled = 'dataset_avg';
                } else {
                    // fallback heurÃ­stico
                    refObj.stereo_target = g.includes('trance') ? 0.17 : (g.includes('funk') ? 0.12 : 0.15);
                    refObj.__stereo_filled = 'heuristic';
                }
                refObj.tol_stereo = refObj.tol_stereo == null ? 0.08 : refObj.tol_stereo;
            } catch { /* noop */ }
        }
        // Garantir tol_stereo razoÃ¡vel
        if (refObj.tol_stereo == null) refObj.tol_stereo = 0.08;
        // Bandas: marcar N/A para target_db null e permitir comparaÃ§Ã£o ignorando
        if (refObj.bands && typeof refObj.bands === 'object') {
            for (const [k,v] of Object.entries(refObj.bands)) {
                if (!v || typeof v !== 'object') continue;
                if (v.target_db == null) {
                    v._target_na = true; // flag para UI
                }
            }
        }
        // NormalizaÃ§Ã£o opcional antecipada (apenas ajuste de metadado; cÃ¡lculo real feito no analyzer)
        if (window && window.PRE_NORMALIZE_REF_BANDS === true && refObj.bands) {
            const vals = Object.values(refObj.bands).map(b=>b&&Number.isFinite(b.target_db)?b.target_db:null).filter(v=>v!=null);
            const negRatio = vals.filter(v=>v<0).length/Math.max(1,vals.length);
            const posRatio = vals.filter(v=>v>0).length/Math.max(1,vals.length);
            // Se maioria positiva mas queremos alinhar a negativos, apenas anotar
            if (posRatio>0.7 && negRatio<0.3) refObj.__scale_mismatch_hint = 'positive_targets_vs_negative_measurements';
        }
    } catch (e) { console.warn('[refEnrich] falha', e); }
    return refObj;
}

// Fallback embutido inline para evitar 404 em produÃ§Ã£o
// ğŸ›ï¸ ATUALIZADO: Funk Mandela 2025-08-fixed-flex (18/08/2025) - Estrutura Fixed/Flex Implementada
const __INLINE_EMBEDDED_REFS__ = {
    manifest: { genres: [
        { key: 'trance', label: 'Trance' },
        { key: 'funk_mandela', label: 'Funk Mandela' },
        { key: 'funk_bruxaria', label: 'Funk Bruxaria' },
        { key: 'funk_automotivo', label: 'Funk Automotivo' },
        { key: 'eletronico', label: 'EletrÃ´nico' },
        { key: 'eletrofunk', label: 'Eletrofunk' },
        { key: 'funk_consciente', label: 'Funk Consciente' },
        { key: 'trap', label: 'Trap' }
    ]},
    byGenre: {
        trance: { lufs_target: -14, tol_lufs: 0.5, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 9.4, tol_dr: 0.8, lra_target: 10.7, tol_lra: 2.7, stereo_target: 0.17, tol_stereo: 0.03, bands: { sub:{target_db:-17.3,tol_db:2.5}, low_bass:{target_db:-14.6,tol_db:4.3}, upper_bass:{target_db:-14.8,tol_db:2.5}, low_mid:{target_db:-12.6,tol_db:3.7}, mid:{target_db:-12,tol_db:4.0}, high_mid:{target_db:-20.2,tol_db:3.6}, brilho:{target_db:-24.7,tol_db:2.5}, presenca:{target_db:-32.1,tol_db:3.6} } },
    // Perfil atualizado Funk Mandela 2025-08-mandela-targets.4-tolerances-updated - TOLERÃ‚NCIAS BIDIRECIONAIS ATUALIZADAS
    funk_mandela:   { 
        version: "2025-08-mandela-targets.4-tolerances-updated", 
        lufs_target: -8.0, tol_lufs: 2.5, tol_lufs_min: 2.5, tol_lufs_max: 2.5, 
        true_peak_target: -0.8, tol_true_peak: 1.0, true_peak_streaming_max: -1.2, true_peak_baile_max: -0.1, 
        dr_target: 8.0, tol_dr: 3.0, // Atualizado para Â±3.0 unidades
        lra_target: 9.0, lra_min: 6.5, lra_max: 11.5, tol_lra: 2.5, 
        stereo_target: 0.60, tol_stereo: 0.25, stereo_width_target: 0.20, stereo_width_tol: 0.25, // CorrelaÃ§Ã£o 0.60 Â± 0.25
        low_end_mono_cutoff: 100, clipping_sample_pct_max: 0.02, vocal_band_min_delta: -1.5,
        fixed: {
            lufs: { integrated: { target: -8.0, tolerance: 2.5 } },
            rms: { policy: "deriveFromLUFS" },
            truePeak: { streamingMax: -1.2, baileMax: -0.1, target: -8.0 },
            dynamicRange: { crest: { target: 8.0, min: 5.0, max: 11.0 } },
            lowEnd: { mono: { cutoffHz: 100 } },
            vocalPresence: { bandHz: [1000, 4000], vocalBandMinDeltaDb: -1.5 }
        },
        flex: {
            clipping: { samplePctMax: 0.02 },
            lra: { min: 6.5, max: 11.5, target: 9.0 },
            stereo: { correlation: { min: 0.35, max: 0.85 }, width: { min: 0.075, max: 0.325 } }
        },
        pattern_rules: { 
            hard_constraints: ["lufs", "truePeak", "dynamicRange", "lowEnd", "vocalPresence"], 
            soft_constraints: ["clipping", "lra", "stereo", "tonalCurve"] 
        }, 
        bands: { 
            sub:{target_db:-7.2,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            low_bass:{target_db:-8.9,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            upper_bass:{target_db:-12.8,tol_db:2.5,severity:"soft",range_hz:"120-200"}, 
            low_mid:{target_db:-9.2,tol_db:2.0,severity:"soft",range_hz:"200-500"}, 
            mid:{target_db:-6.8,tol_db:1.5,severity:"hard",vocal_presence_range:true,range_hz:"500-2000"}, 
            high_mid:{target_db:-12.3,tol_db:1.5,severity:"soft",range_hz:"2000-4000"}, 
            brilho:{target_db:-16.2,tol_db:2.0,severity:"soft",range_hz:"4000-8000"}, 
            presenca:{target_db:-19.1,tol_db:2.5,severity:"hard",vocal_presence_range:true,range_hz:"8000-12000"} 
        } 
    },
        funk_bruxaria: { 
            version: "1.0.1",
            generated_at: "2025-08-23T18:03:37.143Z",
            num_tracks: 29,
            lufs_target: -14,
            tol_lufs: 0.5,
            true_peak_target: -1.0,
            tol_true_peak: 1.0,
            dr_target: 7.4,
            tol_dr: 1.3,
            lra_target: 8.4,
            tol_lra: 2.8,
            stereo_target: 0.3,
            tol_stereo: 0.1,
            calor_target: -11.95,
            brilho_target: -17.69,
            clareza_target: -1.21,
            bands: {
                sub: { target_db: -12.5, tol_db: 3 },
                low_bass: { target_db: -15.2, tol_db: 3 },
                upper_bass: { target_db: -15.2, tol_db: 2.3 },
                low_mid: { target_db: -12, tol_db: 1.7 },
                mid: { target_db: -8.7, tol_db: 1.7 },
                high_mid: { target_db: -14.5, tol_db: 2.8 },
                brilho: { target_db: -17.7, tol_db: 2.2 },
                presenca: { target_db: -26.7, tol_db: 2.8 }
            }
        },
        funk_automotivo:{ lufs_target: -8,  tol_lufs: 1.2, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 8.1, tol_dr: 2.0, lra_target: 6.6, tol_lra: 4.0, stereo_target: 0.3, tol_stereo: 0.15, bands: { sub:{target_db:-7.6,tol_db:6.0}, low_bass:{target_db:-6.6,tol_db:4.5}, upper_bass:{target_db:-11.4,tol_db:3.5}, low_mid:{target_db:-8.2,tol_db:3.5}, mid:{target_db:-6.7,tol_db:3.0}, high_mid:{target_db:-12.8,tol_db:4.5}, brilho:{target_db:-16.6,tol_db:4.5}, presenca:{target_db:-22.7,tol_db:5.0} } },
        eletronico:     { 
            version: "1.0.1",
            lufs_target: -14, tol_lufs: 0.5, tol_lufs_min: 0.5, tol_lufs_max: 0.5,  
            true_peak_target: -1.0, tol_true_peak: 1.0, true_peak_streaming_max: -1.0, true_peak_baile_max: 0.0,
            dr_target: 10.1, tol_dr: 1.4, 
            lra_target: 5.2, lra_min: 1.2, lra_max: 9.2, tol_lra: 4, 
            stereo_target: 0.19, tol_stereo: 0.07, stereo_width_mids_highs_tolerance: "moderate",
            low_end_mono_cutoff: 80, clipping_sample_pct_max: 0.01, vocal_band_min_delta: -2.0,
            bands: { 
                sub:{target_db:-12.5,tol_db:3}, 
                low_bass:{target_db:-10.6,tol_db:3}, 
                upper_bass:{target_db:-13.7,tol_db:3}, 
                low_mid:{target_db:-12.1,tol_db:2.7}, 
                mid:{target_db:-11.8,tol_db:2.4}, 
                high_mid:{target_db:-19.1,tol_db:2.3}, 
                brilho:{target_db:-19.1,tol_db:2}, 
                presenca:{target_db:-24,tol_db:3} 
            } 
        },
        eletrofunk:     { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.12, tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        funk_consciente:{ lufs_target: -12, tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 10, tol_dr: 2, lra_target: 7, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        trap:           { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-16,tol_db:5.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } }
    }
};

// Construir estatÃ­sticas agregadas (mÃ©dia stereo por gÃªnero) a partir de refs carregadas
function buildAggregatedRefStats() {
    try {
        const map = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre;
        if (!map) return;
        for (const [g, data] of Object.entries(map)) {
            if (!data || typeof data !== 'object') continue;
            // stereo_target jÃ¡ definido conta; se null ignorar
            if (Number.isFinite(data.stereo_target)) {
                const st = (__refDerivedStats[g] = __refDerivedStats[g] || { sumStereo:0, countStereo:0 });
                st.sumStereo += data.stereo_target; st.countStereo += 1;
            }
        }
        for (const [g, st] of Object.entries(__refDerivedStats)) {
            if (st.countStereo > 0) st.avgStereo = st.sumStereo / st.countStereo;
        }
    } catch (e) { if (window.DEBUG_ANALYZER) console.warn('buildAggregatedRefStats fail', e); }
}

// Carregar dinamicamente o fallback embutido se necessÃ¡rio
async function ensureEmbeddedRefsReady(timeoutMs = 2500) {
    try {
        if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
        // Se nÃ£o for explicitamente permitido, nÃ£o tentar carregar pela rede para evitar 404
        if (!(typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true)) return false;
        // Injetar script apenas uma vez
        if (typeof document !== 'undefined' && !document.getElementById('embeddedRefsScript')) {
            const s = document.createElement('script');
            s.id = 'embeddedRefsScript';
            s.src = '/refs/embedded-refs.js?v=' + Date.now();
            s.async = true;
            document.head.appendChild(s);
        }
        // Esperar atÃ© ficar disponÃ­vel ou timeout
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
            await new Promise(r => setTimeout(r, 100));
        }
        return (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) ? true : false;
    } catch { return false; }
}

// Helper: buscar JSON tentando mÃºltiplos caminhos (resiliente a diferenÃ§as local x produÃ§Ã£o)
async function fetchRefJsonWithFallback(paths) {
    let lastErr = null;
    for (const p of paths) {
        if (!p) continue;
        try {
            // ğŸ¯ CORREÃ‡ÃƒO: Usar window.location.origin para garantir caminho absoluto no deploy
            const baseUrl = (typeof window !== 'undefined' && window.location) 
                ? window.location.origin 
                : '';
            
            // Se o path jÃ¡ Ã© absoluto (comeÃ§a com http), nÃ£o adicionar origin
            const fullUrl = p.startsWith('http') ? p : `${baseUrl}${p.startsWith('/') ? '' : '/'}${p}`;
            
            // Cache-busting para evitar CDN retornar 404 ou versÃµes antigas
            const hasQ = fullUrl.includes('?');
            const url = fullUrl + (hasQ ? '&' : '?') + 'v=' + Date.now();
            
            if (__DEBUG_ANALYZER__) console.log('[refs] tentando fetch:', url);
            
            const res = await fetch(url, {
                cache: 'no-store',
                headers: { 
                    'Cache-Control': 'no-cache', 
                    'Pragma': 'no-cache',
                    'Accept': 'application/json'
                }
            });
            
            if (res.ok) {
                // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA: Verificar Content-Type
                const contentType = res.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    console.warn('[refs] âš ï¸ Content-Type incorreto:', contentType, 'em', p);
                    console.warn('[refs] Esperado: application/json, recebido HTML provavelmente');
                    throw new Error(`Content-Type invÃ¡lido: ${contentType} (esperado JSON)`);
                }
                
                if (__DEBUG_ANALYZER__) console.log('[refs] OK:', p);
                
                // Verificar se a resposta tem conteÃºdo JSON vÃ¡lido
                const text = await res.text();
                
                // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA: Detectar HTML no lugar de JSON
                if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                    console.error('[refs] âŒ ERRO: Servidor retornou HTML ao invÃ©s de JSON em', p);
                    console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                    throw new Error(`HTML retornado ao invÃ©s de JSON em ${p}`);
                }
                
                if (text.trim()) {
                    try {
                        const json = JSON.parse(text);
                        console.log('[refs] âœ… JSON vÃ¡lido carregado de:', p);
                        return json;
                    } catch (jsonError) {
                        console.error('[refs] âŒ JSON invÃ¡lido em', p);
                        console.error('[refs] Erro:', jsonError.message);
                        console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                        throw new Error(`JSON invÃ¡lido em ${p}: ${jsonError.message}`);
                    }
                } else {
                    console.warn('[refs] Resposta vazia em', p);
                    throw new Error(`Resposta vazia em ${p}`);
                }
            } else {
                if (__DEBUG_ANALYZER__) console.warn('[refs] Falha', res.status, 'em', p);
                lastErr = new Error(`HTTP ${res.status} @ ${p}`);
            }
        } catch (e) {
            if (__DEBUG_ANALYZER__) console.warn('[refs] Erro fetch', p, e?.message || e);
            lastErr = e;
        }
    }
    throw lastErr || new Error('Falha ao carregar JSON de referÃªncia (todas as rotas testadas)');
}

// ğŸ“š Carregar manifesto de gÃªneros (opcional). Se ausente, manter fallback.
async function loadGenreManifest() {
    // 1) Preferir embutido em window, depois inline
    try {
        const winEmb = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.manifest) || null;
        if (winEmb && Array.isArray(winEmb.genres)) { __genreManifest = winEmb.genres; return __genreManifest; }
    } catch {}
    if (!__genreManifest && __INLINE_EMBEDDED_REFS__?.manifest?.genres?.length) {
        __genreManifest = __INLINE_EMBEDDED_REFS__.manifest.genres;
        return __genreManifest;
    }
    // 2) Se permitido, tentar rede
    if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
        try {
            const json = await fetchRefJsonWithFallback([
                `/refs/out/genres.json`,
                `refs/out/genres.json`,
                `./refs/out/genres.json`,
                `../refs/out/genres.json`
            ]);
            if (json && Array.isArray(json.genres)) { __genreManifest = json.genres; return __genreManifest; }
        } catch (e) { __dwrn('Manifesto via rede indisponÃ­vel:', e.message || e); }
    }
    return __genreManifest || null;
}

// ğŸ·ï¸ Popular o <select> com base no manifesto, mantendo fallback e preservando seleÃ§Ã£o
function populateGenreSelect(manifestGenres) {
    const sel = document.getElementById('audioRefGenreSelect');
    if (!sel) return;
    if (!Array.isArray(manifestGenres) || manifestGenres.length === 0) {
        // Nada a fazer (fallback jÃ¡ em HTML)
        // Ainda assim, garantir que o gÃªnero ativo esteja presente como opÃ§Ã£o
        ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
        return;
    }
    // Salvar valor atual (se houver)
    const current = sel.value;
    // Limpar opÃ§Ãµes atuais e reconstruir
    while (sel.options.length) sel.remove(0);
    for (const g of manifestGenres) {
        if (!g || !g.key) continue;
        const opt = document.createElement('option');
        opt.value = String(g.key);
        opt.textContent = String(g.label || labelizeKey(g.key));
        sel.appendChild(opt);
    }
    // Garantir que gÃªnero ativo via URL/localStorage esteja presente
    ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
    // Restaurar seleÃ§Ã£o (priorizar PROD_AI_REF_GENRE > current > primeira opÃ§Ã£o)
    const target = window.PROD_AI_REF_GENRE || current || (sel.options[0] && sel.options[0].value);
    if (target) sel.value = target;
}

// ğŸ”¤ Converter chave em rÃ³tulo amigÃ¡vel (ex.: "funk_mandela" â†’ "Funk Mandela")
function labelizeKey(key) {
    if (!key) return '';
    return String(key)
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\b\w/g, c => c.toUpperCase());
}

// âœ… Garantir que a opÃ§Ã£o do gÃªnero ativo exista no select (para casos via URL)
function ensureActiveGenreOption(selectEl, genreKey) {
    if (!selectEl || !genreKey) return;
    const exists = Array.from(selectEl.options).some(o => o.value === genreKey);
    if (!exists) {
        const opt = document.createElement('option');
        opt.value = String(genreKey);
        opt.textContent = labelizeKey(genreKey);
        selectEl.appendChild(opt);
    }
}

/**
 * ğŸ¯ NOVA FUNÃ‡ÃƒO: Extrair targets de gÃªnero do JSON
 * Formato esperado do JSON:
 * {
 *   "nome_genero": {
 *     "version": "...",
 *     "hybrid_processing": {
 *       "original_metrics": {...},
 *       "spectral_bands": {...}  â† PRIORIDADE 1
 *     },
 *     "legacy_compatibility": {
 *       "bands": {...}  â† PRIORIDADE 2
 *     },
 *     "bands": {...}  â† PRIORIDADE 3 (fallback)
 *   }
 * }
 */
function extractGenreTargets(json, genreName) {
    console.log('[EXTRACT-TARGETS] ğŸ” Extraindo targets para:', genreName);
    console.log('[EXTRACT-TARGETS] ğŸ“¦ JSON recebido:', json);
    
    // 1. Identificar o root real do gÃªnero
    let root = null;
    
    // Tentar: json[genreName]
    if (json && typeof json === 'object' && json[genreName]) {
        root = json[genreName];
        console.log('[EXTRACT-TARGETS] âœ… Root encontrado em json[genreName]');
    }
    // Tentar: json jÃ¡ Ã© o root (quando vem de cache ou embedded)
    else if (json && typeof json === 'object' && json.version) {
        root = json;
        console.log('[EXTRACT-TARGETS] âœ… JSON jÃ¡ Ã© o root (tem version)');
    }
    // Tentar: primeiro objeto no JSON
    else if (json && typeof json === 'object') {
        const firstKey = Object.keys(json)[0];
        if (firstKey && json[firstKey] && typeof json[firstKey] === 'object') {
            root = json[firstKey];
            console.log('[EXTRACT-TARGETS] âœ… Root encontrado na primeira chave:', firstKey);
        }
    }
    
    if (!root) {
        console.error('[EXTRACT-TARGETS] âŒ Root nÃ£o encontrado no JSON');
        return null;
    }
    
    console.log('[EXTRACT-TARGETS] ğŸ“Š Root identificado:', {
        version: root.version,
        hasHybridProcessing: !!root.hybrid_processing,
        hasLegacyCompatibility: !!root.legacy_compatibility,
        hasBands: !!root.bands
    });
    
    // 2. Buscar targets na ordem de prioridade
    let targets = null;
    let source = null;
    
    // PRIORIDADE 1: hybrid_processing.spectral_bands
    if (root.hybrid_processing?.spectral_bands) {
        targets = root.hybrid_processing.spectral_bands;
        source = 'hybrid_processing.spectral_bands';
        console.log('[EXTRACT-TARGETS] âœ… Targets encontrados em hybrid_processing.spectral_bands');
    }
    // PRIORIDADE 2: legacy_compatibility.bands
    else if (root.legacy_compatibility?.bands) {
        targets = root.legacy_compatibility.bands;
        source = 'legacy_compatibility.bands';
        console.log('[EXTRACT-TARGETS] âœ… Targets encontrados em legacy_compatibility.bands');
    }
    // PRIORIDADE 3: bands (fallback)
    else if (root.bands) {
        targets = root.bands;
        source = 'bands';
        console.log('[EXTRACT-TARGETS] âœ… Targets encontrados em bands (fallback)');
    }
    // PRIORIDADE 4: hybrid_processing.original_metrics (Ãºltimo recurso)
    else if (root.hybrid_processing?.original_metrics) {
        targets = root.hybrid_processing.original_metrics;
        source = 'hybrid_processing.original_metrics';
        console.log('[EXTRACT-TARGETS] âš ï¸ Usando original_metrics como Ãºltimo recurso');
    }
    
    if (!targets) {
        console.error('[EXTRACT-TARGETS] âŒ Nenhum target encontrado no JSON');
        console.error('[EXTRACT-TARGETS] ğŸ“¦ Root completo:', root);
        return null;
    }
    
    // 3. Criar objeto de resultado completo
    const result = {
        ...root,
        targets: targets,
        targetSource: source
    };
    
    console.log('[EXTRACT-TARGETS] âœ… ExtraÃ§Ã£o completa:', {
        genre: genreName,
        source: source,
        version: root.version,
        targetKeys: Object.keys(targets),
        lufs_target: root.lufs_target,
        true_peak_target: root.true_peak_target,
        dr_target: root.dr_target,
        stereo_target: root.stereo_target
    });
    
    return result;
}

async function loadReferenceData(genre) {
    try {
        // Se feature flag de invalidar cache por troca de escala/gÃªnero estiver ativa, ignorar cache salvo
        const bypassCache = (typeof window !== 'undefined' && window.REFS_BYPASS_CACHE === true);
        if (!bypassCache && __refDataCache[genre]) {
            __activeRefData = __refDataCache[genre];
            __activeRefGenre = genre;
            
            // âœ… Log detalhado dos targets carregados do cache
            console.log('[LOAD-REF] ğŸ“¦ Carregado do cache:', {
                genre: genre,
                hasTargets: !!__activeRefData?.targets,
                targetKeys: __activeRefData?.targets ? Object.keys(__activeRefData.targets) : [],
                targetSource: __activeRefData?.targetSource
            });
            
            updateRefStatus('âœ” referÃªncias (cache)', '#0d6efd');
            return __activeRefData;
        }
        if (bypassCache) {
            delete __refDataCache[genre];
        }
        updateRefStatus('â³ carregando...', '#996600');
        
        console.log('ğŸ” DEBUG loadReferenceData inÃ­cio:', { genre, bypassCache });
        
        // PRIORIDADE CORRIGIDA: external > embedded > fallback
        // 1) Tentar carregar JSON externo primeiro (sempre, independente de REFS_ALLOW_NETWORK)
        console.log('ğŸŒ Tentando carregar JSON externo primeiro...');
        try {
            const version = Date.now(); // Force cache bust
            const json = await fetchRefJsonWithFallback([
                `/refs/out/${genre}.json?v=${version}`,
                `refs/out/${genre}.json?v=${version}`,
                `./refs/out/${genre}.json?v=${version}`,
                `../refs/out/${genre}.json?v=${version}`
            ]);
            
            // âœ… NOVA LÃ“GICA: Usar extractGenreTargets para processar JSON
            const extractedData = extractGenreTargets(json, genre);
            
            if (extractedData && typeof extractedData === 'object' && extractedData.version) {
                const enrichedNet = enrichReferenceObject(extractedData, genre);
                __refDataCache[genre] = enrichedNet;
                __activeRefData = enrichedNet;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedNet;
                window.__activeRefData = enrichedNet; // âœ… Garantir disponibilidade global
                
                // âœ… Log detalhado mostrando targets reais
                console.log('ğŸ¯ REFS DIAGNOSTIC (EXTERNAL):', {
                    genre,
                    source: 'external',
                    path: `/refs/out/${genre}.json`,
                    version: extractedData.version,
                    num_tracks: extractedData.num_tracks,
                    lufs_target: extractedData.lufs_target,
                    true_peak_target: extractedData.true_peak_target,
                    stereo_target: extractedData.stereo_target,
                    targetSource: extractedData.targetSource,
                    targetKeys: extractedData.targets ? Object.keys(extractedData.targets) : [],
                    firstTarget: extractedData.targets ? Object.values(extractedData.targets)[0] : null
                });
                
                console.log('âœ… [GENRE_MODAL] Targets de gÃªnero carregados:', {
                    genre: genre,
                    hasTargets: !!extractedData.targets,
                    targetCount: extractedData.targets ? Object.keys(extractedData.targets).length : 0,
                    targetSample: extractedData.targets ? Object.keys(extractedData.targets).slice(0, 3) : []
                });
                
                updateRefStatus('âœ” referÃªncias aplicadas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedNet;
            }
        } catch (netError) {
            console.log('âŒ External refs failed:', netError.message);
            console.log('ğŸ”„ Fallback para embedded refs...');
            
            // ğŸ”¥ CORREÃ‡ÃƒO LOOP INFINITO: ForÃ§ar refsReady se refs internas jÃ¡ carregaram
            if (!window.refsReady && window.embeddedRefsLoaded) {
                window.refsReady = true;
                console.log("âš ï¸ [refs] refsReady forÃ§ado como true apÃ³s fallback com erro de fetch externo");
            }
        }
        
        // 2) Fallback para referÃªncias embutidas (embedded)
        const embWin = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre && window.__EMBEDDED_REFS__.byGenre[genre]) || null;
        const embInline = __INLINE_EMBEDDED_REFS__?.byGenre?.[genre] || null;
        const useData = embWin || embInline;
        if (useData && typeof useData === 'object') {
            // âœ… NOVA LÃ“GICA: Extrair targets corretamente
            const extractedData = extractGenreTargets(useData, genre);
            
            if (extractedData) {
                const enriched = enrichReferenceObject(structuredClone(extractedData), genre);
                __refDataCache[genre] = enriched;
                __activeRefData = enriched;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enriched;
                window.__activeRefData = enriched; // âœ… Garantir disponibilidade global
                
                // âœ… Log detalhado mostrando targets reais
                console.log('ğŸ¯ REFS DIAGNOSTIC (EMBEDDED):', {
                    genre,
                    source: 'embedded',
                    path: embWin ? 'window.__EMBEDDED_REFS__' : '__INLINE_EMBEDDED_REFS__',
                    version: extractedData.version || 'embedded',
                    num_tracks: extractedData.num_tracks || 'unknown',
                    lufs_target: extractedData.lufs_target,
                    true_peak_target: extractedData.true_peak_target,
                    stereo_target: extractedData.stereo_target,
                    targetSource: extractedData.targetSource,
                    targetKeys: extractedData.targets ? Object.keys(extractedData.targets) : [],
                    firstTarget: extractedData.targets ? Object.values(extractedData.targets)[0] : null
                });
                
                console.log('âœ… [GENRE_MODAL] Targets de gÃªnero carregados:', {
                    genre: genre,
                    hasTargets: !!extractedData.targets,
                    targetCount: extractedData.targets ? Object.keys(extractedData.targets).length : 0,
                    targetSample: extractedData.targets ? Object.keys(extractedData.targets).slice(0, 3) : []
                });
                
                updateRefStatus('âœ” referÃªncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enriched;
            }
        }
        
        // 3) Se ainda nada funcionou e REFS_ALLOW_NETWORK estÃ¡ ativo (legacy path)
        if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
            console.log('âš ï¸ Using legacy REFS_ALLOW_NETWORK path - should not happen with new logic');
        }
        
        // 4) Ãšltimo recurso: trance inline (fallback)
        const fallback = __INLINE_EMBEDDED_REFS__?.byGenre?.trance;
        if (fallback) {
            const enrichedFb = enrichReferenceObject(structuredClone(fallback), 'trance');
            __refDataCache['trance'] = enrichedFb;
            __activeRefData = enrichedFb;
            __activeRefGenre = 'trance';
            window.PROD_AI_REF_DATA = enrichedFb;
            
            // Log de diagnÃ³stico
            console.log('ğŸ¯ REFS DIAGNOSTIC:', {
                genre,
                source: 'fallback',
                path: '__INLINE_EMBEDDED_REFS__.trance',
                version: 'fallback',
                num_tracks: fallback.num_tracks || 'unknown',
                lufs_target: fallback.lufs_target,
                true_peak_target: fallback.true_peak_target,
                stereo_target: fallback.stereo_target
            });
            
            updateRefStatus('âœ” referÃªncias embutidas (fallback)', '#0d6efd');
            try { buildAggregatedRefStats(); } catch {}
            return enrichedFb;
        }
        throw new Error('Sem referÃªncias disponÃ­veis');
    } catch (e) {
        console.warn('Falha ao carregar referÃªncias', genre, e);
        // Fallback: tentar EMBEDDED
        try {
            const embMap = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre || {};
            const emb = embMap[genre];
            if (emb && typeof emb === 'object') {
                const enrichedEmb = enrichReferenceObject(structuredClone(emb), genre);
                __refDataCache[genre] = enrichedEmb;
                __activeRefData = enrichedEmb;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedEmb;
                updateRefStatus('âœ” referÃªncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmb;
            }
            // Se o gÃªnero especÃ­fico nÃ£o existir, usar um padrÃ£o seguro (trance) se disponÃ­vel
            if (embMap && embMap.trance) {
                const enrichedEmbTr = enrichReferenceObject(structuredClone(embMap.trance), 'trance');
                __refDataCache['trance'] = enrichedEmbTr;
                __activeRefData = enrichedEmbTr;
                __activeRefGenre = 'trance';
                window.PROD_AI_REF_DATA = enrichedEmbTr;
                updateRefStatus('âœ” referÃªncias embutidas (fallback)', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmbTr;
            }
        } catch(_) {}
        updateRefStatus('âš  falha refs', '#992222');
        return null;
    }
}

function updateRefStatus(text, color) {
    const el = document.getElementById('audioRefStatus');
    if (el) { el.textContent = text; el.style.background = color || '#1f2b40'; }
}

/**
 * ğŸ”’ FUNÃ‡ÃƒO DE PRESERVAÃ‡ÃƒO DE GÃŠNERO
 * Garante que o gÃªnero selecionado NUNCA seja perdido em resets
 */
function preserveGenreState(sourceAnalysis = null) {
    console.log('[PRESERVE-GENRE] ğŸ”’ Preservando estado do gÃªnero');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Se foi passada uma anÃ¡lise, extrair targets dela primeiro
    if (sourceAnalysis) {
        console.log('[PRESERVE-GENRE] ğŸ¯ AnÃ¡lise fornecida - extraindo genre e targets (FONTE OFICIAL)');
        
        const extractedGenre = extractGenreFromAnalysis(sourceAnalysis);
        const extractedTargets = extractGenreTargetsFromAnalysis(sourceAnalysis);
        
        if (extractedGenre) {
            window.__CURRENT_SELECTED_GENRE = extractedGenre;
            window.PROD_AI_REF_GENRE = extractedGenre;
            console.log('[PRESERVE-GENRE] âœ… GÃªnero extraÃ­do de analysis.data.genre:', extractedGenre);
        }
        
        if (extractedTargets) {
            window.__CURRENT_GENRE_TARGETS = extractedTargets;
            window.currentGenreTargets = extractedTargets;
            console.log('[PRESERVE-GENRE] âœ… Targets extraÃ­dos de analysis.data.genreTargets:', Object.keys(extractedTargets));
        }
        
        // Se conseguiu extrair ambos, retornar
        if (extractedGenre && extractedTargets) {
            return;
        }
    }
    
    // Se __CURRENT_SELECTED_GENRE jÃ¡ existe, nÃ£o precisa restaurar
    if (window.__CURRENT_SELECTED_GENRE) {
        console.log('[PRESERVE-GENRE] âœ… __CURRENT_SELECTED_GENRE jÃ¡ existe:', window.__CURRENT_SELECTED_GENRE);
        return;
    }

    // Se o CURRENT nÃ£o existir, restaurar do refGenre
    if (window.PROD_AI_REF_GENRE) {
        window.__CURRENT_SELECTED_GENRE = window.PROD_AI_REF_GENRE;
        console.log('[PRESERVE-GENRE] âœ… __CURRENT_SELECTED_GENRE restaurado de PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
    }

    // Reatribuir targets
    if (window.__CURRENT_GENRE_TARGETS) {
        window.currentGenreTargets = window.__CURRENT_GENRE_TARGETS;
        console.log('[PRESERVE-GENRE] âœ… currentGenreTargets restaurado de __CURRENT_GENRE_TARGETS');
    }
}

function applyGenreSelection(genre) {
    if (!genre) return Promise.resolve();
    window.PROD_AI_REF_GENRE = genre;
    localStorage.setItem('prodai_ref_genre', genre);
    // InvalidaÃ§Ã£o de cache opcional
    if (typeof window !== 'undefined' && window.INVALIDATE_REF_CACHE_ON_GENRE_CHANGE === true) {
        try { delete __refDataCache[genre]; } catch {}
        invalidateReferenceDerivedCaches();
    }
    
    // ğŸ¯ FORÃ‡AR invalidaÃ§Ã£o para garantir nova referÃªncia
    try { 
        delete __refDataCache[genre]; 
        invalidateReferenceDerivedCaches();
        console.log('âœ… Cache invalidado para gÃªnero:', genre);
    } catch(e) { console.warn('âš ï¸ Falha na invalidaÃ§Ã£o:', e); }
    
    // Carregar refs e, se jÃ¡ houver anÃ¡lise no modal, atualizar sugestÃµes de referÃªncia e re-renderizar
    return loadReferenceData(genre).then(() => {
        // ğŸ”’ PATCH: Salvar gÃªnero e targets em TODAS as variÃ¡veis globais
        window.__CURRENT_SELECTED_GENRE = genre;
        window.PROD_AI_REF_GENRE = genre;
        
        // Extrair targets do __activeRefData carregado
        if (window.__activeRefData?.targets) {
            window.__CURRENT_GENRE_TARGETS = window.__activeRefData.targets;
            window.currentGenreTargets = window.__activeRefData.targets;
            console.log('[APPLY-GENRE] âœ… GÃªnero e targets salvos:', {
                genre: genre,
                hasTargets: true,
                targetKeys: Object.keys(window.__activeRefData.targets)
            });
        } else {
            console.warn('[APPLY-GENRE] âš ï¸ Targets nÃ£o encontrados em __activeRefData');
        }
        
        try {
            if (typeof currentModalAnalysis === 'object' && currentModalAnalysis) {
                // ğŸ¯ NOVO: Recalcular score com nova referÃªncia
                try {
                    if (typeof window !== 'undefined' && window.computeMixScore && __refData) {
                        currentModalAnalysis.qualityOverall = window.computeMixScore(currentModalAnalysis.technicalData, __refData);
                        console.log('âœ… Score recalculado para novo gÃªnero:', currentModalAnalysis.qualityOverall);
                    }
                } catch(e) { console.warn('âŒ Falha ao recalcular score:', e); }
                
                // Recalcular sugestÃµes reference_* com as novas tolerÃ¢ncias
                try { updateReferenceSuggestions(currentModalAnalysis); } catch(e) { console.warn('updateReferenceSuggestions falhou', e); }
                // Re-renderizaÃ§Ã£o completa para refletir sugestÃµes e comparaÃ§Ãµes
                try { 
                    // ğŸ”’ UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
                    const analysisRunId = currentModalAnalysis?.runId || currentModalAnalysis?.metadata?.runId;
                    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
                    
                    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                        console.warn(`ğŸš« [UI_GATE] Re-render cancelado - anÃ¡lise obsoleta (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
                        return;
                    }
                    
                    displayModalResults(currentModalAnalysis); 
                } catch(e) { console.warn('re-render modal falhou', e); }
            }
        } catch (e) { console.warn('re-render comparaÃ§Ã£o falhou', e); }
    });
}
// Expor global
if (typeof window !== 'undefined') {
    window.applyGenreSelection = applyGenreSelection;
}

// Health check utilitÃ¡rio (Etapa 2) â€“ avalia estabilidade das mÃ©tricas em mÃºltiplos runs
if (typeof window !== 'undefined' && !window.__audioHealthCheck) {
    window.__audioHealthCheck = async function(file, opts = {}) {
        const runs = opts.runs || 3;
        const delayMs = opts.delayMs || 0;
        const out = { runs: [], spreads: {}, anomalies: [] };
        for (let i=0;i<runs;i++) {
            const t0 = performance.now();
            // ğŸ†” CORREÃ‡ÃƒO: Adicionar runId para funÃ§Ãµes de health check
            const healthOptions = prepareAnalysisOptions({}, `health_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, healthOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufsIntegrated: res?.technicalData?.lufsIntegrated,
                truePeakDbtp: res?.technicalData?.truePeakDbtp,
                dynamicRange: res?.technicalData?.dynamicRange,
                lra: res?.technicalData?.lra,
                stereoCorrelation: res?.technicalData?.stereoCorrelation,
                processingMs: (res?.processingMs ?? (t1 - t0))
            });
            if (delayMs) await new Promise(r=>setTimeout(r, delayMs));
        }
        const collect = (key) => out.runs.map(r=>r[key]).filter(v=>Number.isFinite(v));
        const stats = (arr) => arr.length?{min:Math.min(...arr),max:Math.max(...arr),spread:Math.max(...arr)-Math.min(...arr)}:null;
        ['lufsIntegrated','truePeakDbtp','dynamicRange','lra','stereoCorrelation','processingMs'].forEach(k=>{
            out.spreads[k] = stats(collect(k));
        });
        // Anomalias agrupadas (do logger central)
        try { out.anomalies = (window.__METRIC_ANOMALIES__||[]).slice(-100); } catch {}
        return out;
    };
}

// ================== ACCEPTANCE TEST HARNESS (Etapa 3) ==================
// âš ï¸ REMOVIDO: Testes que dependem de Web Audio API
// TODO: Implementar testes baseados em anÃ¡lise remota se necessÃ¡rio

if (typeof window !== 'undefined' && !window.__runAcceptanceAudioTests) {
    window.__runAcceptanceAudioTests = async function(opts = {}) {
        console.warn('âš ï¸ Testes de aceitaÃ§Ã£o de Ã¡udio foram removidos devido Ã  migraÃ§Ã£o para anÃ¡lise remota');
        return { 
            skipped: true, 
            reason: 'Web Audio API removida - usar testes de backend' 
        };
    };
}

// Inicializar quando DOM carregar
document.addEventListener('DOMContentLoaded', function() {
    initializeAudioAnalyzerIntegration();
});


function initializeAudioAnalyzerIntegration() {
    if (__audioIntegrationInitialized) {
        __dbg('â„¹ï¸ IntegraÃ§Ã£o do Audio Analyzer jÃ¡ inicializada. Ignorando chamada duplicada.');
        return;
    }
    __audioIntegrationInitialized = true;
    __dbg('ğŸµ Inicializando integraÃ§Ã£o do Audio Analyzer...');
    // Habilitar flag de referÃªncia por gÃªnero via parÃ¢metro de URL (ex.: ?refgenre=trance)
    try {
        if (typeof window !== 'undefined') {
            const params = new URLSearchParams(window.location.search);
            const rg = params.get('refgenre');
            if (rg && !window.PROD_AI_REF_GENRE) {
                window.PROD_AI_REF_GENRE = String(rg).trim().toLowerCase();
                __dbg(`[REF-GÃŠNERO] Ativado via URL: ${window.PROD_AI_REF_GENRE}`);
            }
            // Flags de controle por URL (nÃ£o alteram CSS)
            if (params.has('surgical')) {
                const v = params.get('surgical');
                window.USE_SURGICAL_EQ = !(v === '0' || v === 'false');
                __dbg(`[FLAG] USE_SURGICAL_EQ = ${window.USE_SURGICAL_EQ}`);
            }
            if (params.has('useLog')) {
                const v = params.get('useLog');
                window.USE_LOG_BAND_ENERGIES = (v === '1' || v === 'true');
                __dbg(`[FLAG] USE_LOG_BAND_ENERGIES = ${window.USE_LOG_BAND_ENERGIES}`);
            }
            if (params.has('adv')) {
                const v = params.get('adv');
                const on = !(v === '0' || v === 'false');
                window.USE_ADVANCED_METRICS = on;
                window.USE_ADVANCED_LOUDNESS = on;
                window.USE_ADVANCED_TRUEPEAK = on;
                window.USE_ADVANCED_SPECTRUM = on;
                __dbg(`[FLAG] ADVANCED = ${on}`);
            }
            if (params.has('debug')) {
                const v = params.get('debug');
                window.DEBUG_ANALYZER = (v === '1' || v === 'true');
                __dbg(`[FLAG] DEBUG_ANALYZER = ${window.DEBUG_ANALYZER}`);
            }
            // Preferir mÃ©tricas avanÃ§adas (ITU/oversampling) quando disponÃ­veis, sem sobrescrever configs do usuÃ¡rio
            if (typeof window.PREFER_ADVANCED_METRICS === 'undefined') {
                window.PREFER_ADVANCED_METRICS = true;
                __dbg('[FLAG] PREFER_ADVANCED_METRICS = true (auto)');
            }
        }
    } catch (_) { /* noop */ }
    
    // Restaurar gÃªnero salvo
    try {
        const saved = localStorage.getItem('prodai_ref_genre');
        if (!window.PROD_AI_REF_GENRE && saved) window.PROD_AI_REF_GENRE = saved;
    } catch {}

    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (genreSelect) {
        // Popular dinamicamente a partir do manifesto, mantendo fallback
        loadGenreManifest().then(() => {
            populateGenreSelect(__genreManifest);
            // Listener de mudanÃ§a (garantir apenas um)
            genreSelect.onchange = () => applyGenreSelection(genreSelect.value);
            // Aplicar seleÃ§Ã£o atual
            const selected = genreSelect.value || window.PROD_AI_REF_GENRE;
            applyGenreSelection(selected);
        });
    }

    // BotÃ£o de anÃ¡lise de mÃºsica (novo design)
    const musicAnalysisBtn = document.getElementById('musicAnalysisBtn');
    if (musicAnalysisBtn) {
        musicAnalysisBtn.addEventListener('click', openAudioModal);
        __dbg('âœ… BotÃ£o de AnÃ¡lise de MÃºsica configurado');
    }
    
    // Modal de Ã¡udio
    setupAudioModal();
    
    __dbg('ğŸµ Audio Analyzer Integration carregada com sucesso!');
    
    // ğŸ§  Aguarda refs e cache ficarem prontos antes de liberar o ForceActivator
    function waitForRefsAndCacheBeforeReady() {
        const checkReady = () => {
            const ready = !!(window.audioAnalyzer && window.CACHE_CTX_AWARE_V1_API && window.refsReady);
            console.log("â³ [READY-CHECK] Estado atual:", {
                audioAnalyzer: !!window.audioAnalyzer,
                CACHE_CTX_AWARE_V1_API: !!window.CACHE_CTX_AWARE_V1_API,
                refsReady: !!window.refsReady
            });
            if (ready) {
                console.log("âœ… [GLOBAL] Todos os sistemas prontos. Disparando analysisReady...");
                const evt = new Event("analysisReady");
                document.dispatchEvent(evt);
                return true;
            }
            return false;
        };

        if (!checkReady()) {
            const interval = setInterval(() => {
                if (checkReady()) clearInterval(interval);
            }, 300);
        }
    }

    // ğŸ”¥ Chamar a funÃ§Ã£o de espera no ponto onde estava o dispatch antigo:
    waitForRefsAndCacheBeforeReady();

    // Aplicar estilos aprimorados ao seletor de gÃªnero
    try { injectRefGenreStyles(); } catch(e) { /* silencioso */ }
    
    // ğŸ†• Inicializar Modal de GÃªnero Musical
    try { initGenreModal(); } catch(e) { console.warn('Falha ao inicializar modal de gÃªnero:', e); }
}

// ============================================================================
// ï¿½ MODAL DE BOAS-VINDAS Ã€ ANÃLISE - NOVO SISTEMA
// ============================================================================

/**
 * ğŸŒŸ Abrir modal de boas-vindas
 * Modal inicial que apresenta o sistema e direciona para o guia tÃ©cnico
 */
function openWelcomeModal() {
    __dbg('ğŸ‰ Abrindo modal de boas-vindas Ã  anÃ¡lise...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) {
        console.error('âŒ Modal de boas-vindas nÃ£o encontrado no DOM');
        return;
    }
    
    // Abrir modal com animaÃ§Ã£o
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    
    // Foco no modal para acessibilidade
    requestAnimationFrame(() => {
        modal.focus();
        
        // Foco no primeiro botÃ£o
        const firstBtn = modal.querySelector('.welcome-btn.primary');
        if (firstBtn) {
            firstBtn.focus();
        }
    });
    
    __dbg('âœ… Modal de boas-vindas aberto com sucesso');
}

/**
 * âŒ Fechar modal de boas-vindas
 */
function closeWelcomeModal() {
    __dbg('âŒ Fechando modal de boas-vindas...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    __dbg('âœ… Modal de boas-vindas fechado');
}

/**
 * ğŸ“– Abrir guia tÃ©cnico em nova aba
 */
function openTechnicalGuide() {
    __dbg('ğŸ“– Abrindo guia tÃ©cnico de anÃ¡lise...');
    
    // Abrir guia na mesma pasta (public/)
    window.open('guia-tecnico-analise.html', '_blank', 'noopener,noreferrer');
    
    // NÃ£o fecha o modal - usuÃ¡rio pode ler o guia e voltar
    __dbg('âœ… Guia tÃ©cnico aberto em nova aba');
}

/**
 * â–¶ï¸ Prosseguir para anÃ¡lise (fechar modal de boas-vindas e continuar fluxo)
 */
function proceedToAnalysis() {
    __dbg('â–¶ï¸ Prosseguindo para anÃ¡lise...');
    
    // Fechar modal de boas-vindas
    closeWelcomeModal();
    
    // Continuar com o fluxo original
    const isReferenceEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
    
    if (isReferenceEnabled) {
        // Abrir modal de seleÃ§Ã£o de modo
        openModeSelectionModal();
    } else {
        // Ir direto para modo gÃªnero
        selectAnalysisMode('genre');
    }
    
    __dbg('âœ… Fluxo de anÃ¡lise continuado');
}

// Expor funÃ§Ãµes globalmente para uso nos onclick do HTML
window.openWelcomeModal = openWelcomeModal;
window.closeWelcomeModal = closeWelcomeModal;
window.openTechnicalGuide = openTechnicalGuide;
window.proceedToAnalysis = proceedToAnalysis;

/**
 * âŒ¨ï¸ Configurar acessibilidade do modal de boas-vindas
 */
function setupWelcomeModalAccessibility() {
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) return;
    
    // ESC para fechar
    document.addEventListener('keydown', function handleWelcomeEscape(e) {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeWelcomeModal();
        }
    });
    
    // Tab navigation (trap focus)
    modal.addEventListener('keydown', function handleWelcomeTabNav(e) {
        if (e.key !== 'Tab') return;
        
        const focusableElements = modal.querySelectorAll(
            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
        }
    });
    
    __dbg('âŒ¨ï¸ Acessibilidade do modal de boas-vindas configurada');
}

// Inicializar acessibilidade quando DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupWelcomeModalAccessibility);
} else {
    setupWelcomeModalAccessibility();
}

// ============================================================================

// ğŸµ Abrir modal de anÃ¡lise de Ã¡udio (MODIFICADO para usar novo fluxo)
function openAudioModal() {
    window.logReferenceEvent('open_modal_requested');
    
    // ğŸŒŸ NOVO: Abrir modal de boas-vindas PRIMEIRO
    openWelcomeModal();
}

// ğŸ¯ NOVO: Abrir modal secundÃ¡rio para upload da mÃºsica de referÃªncia
function openReferenceUploadModal(referenceJobId, firstAnalysisResult) {
    __dbg('ğŸ¯ Abrindo modal secundÃ¡rio para mÃºsica de referÃªncia', { referenceJobId });
    
    // ğŸ¯ PROTEÃ‡ÃƒO: Garantir que primeira anÃ¡lise estÃ¡ completa
    if (!firstAnalysisResult) {
        console.error('âŒ [PROTECTION] Primeira anÃ¡lise nÃ£o estÃ¡ completa - abortando abertura do modal de referÃªncia');
        alert('âš ï¸ A primeira anÃ¡lise ainda nÃ£o foi concluÃ­da. Por favor, aguarde.');
        return;
    }
    
    // ğŸ¯ PROTEÃ‡ÃƒO: Validar que hÃ¡ dados essenciais
    if (!firstAnalysisResult.technicalData) {
        console.error('âŒ [PROTECTION] Primeira anÃ¡lise nÃ£o contÃ©m technicalData - dados incompletos');
        alert('âš ï¸ A primeira anÃ¡lise nÃ£o foi concluÃ­da corretamente. Por favor, tente novamente.');
        return;
    }
    
    console.log('âœ… [PROTECTION] Primeira anÃ¡lise validada com sucesso:', {
        hasJobId: !!referenceJobId,
        hasTechnicalData: !!firstAnalysisResult.technicalData,
        hasScore: !!firstAnalysisResult.score
    });
    
    window.logReferenceEvent('reference_upload_modal_opened', { referenceJobId });
    
    // ğŸ¯ PERSISTIR DADOS DA PRIMEIRA FAIXA
    window.__REFERENCE_JOB_ID__ = referenceJobId;
    
    // ï¿½ HARD-GUARD: Salvar primeira anÃ¡lise no FirstAnalysisStore (IMUTÃVEL)
    console.log('[FirstAnalysisStore] ğŸ”’ Salvando primeira anÃ¡lise no store imutÃ¡vel...');
    
    // âœ… USAR NOVA API: FirstAnalysisStore.set() - clonagem interna
    FirstAnalysisStore.set(firstAnalysisResult);
    
    // âŒ REMOVER: NÃ£o usar mais window.referenceAnalysisData / window.__FIRST_ANALYSIS_RESULT__
    // A ÃšNICA fonte de verdade Ã© FirstAnalysisStore
    
    window.lastReferenceJobId = referenceJobId;
    
    console.log('âœ… [COMPARE-MODE] Primeira faixa salva:', {
        jobId: referenceJobId,
        score: firstAnalysisResult?.score,
        lufs: firstAnalysisResult?.technicalData?.lufsIntegrated,
        storeProtected: FirstAnalysisStore.has()
    });
    
    // ğŸ”¥ FIX-REFERENCE: NÃƒO chamar reset completo - apenas limpar UI visualmente
    // closeAudioModal();   // âŒ REMOVIDO - deletava __REFERENCE_JOB_ID__
    // resetModalState();   // âŒ REMOVIDO - deletava __REFERENCE_JOB_ID__

    // Resetar apenas UI (sem limpar flags globais)
    const uploadAreaFirst = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');

    if (uploadAreaFirst) uploadAreaFirst.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';

    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';

    console.log('[FIX-REFERENCE] Modal reaberto SEM limpar flags de referÃªncia');
    
    // ğŸ¯ CORREÃ‡ÃƒO: Manter modo 'reference' para segunda mÃºsica tambÃ©m
    // O backend identifica que Ã© comparaÃ§Ã£o pela presenÃ§a do referenceJobId
    currentAnalysisMode = 'reference';
    
    // Abrir modal novamente
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('âŒ Modal de anÃ¡lise de Ã¡udio nÃ£o encontrado');
        return;
    }
    
    // Atualizar tÃ­tulo e instruÃ§Ãµes do modal
    const modalTitle = document.getElementById('audioModalTitle');
    const modalSubtitle = document.getElementById('audioModalSubtitle');
    
    if (modalTitle) {
        modalTitle.innerHTML = 'ğŸ¯ Upload da MÃºsica de ReferÃªncia';
    }
    
    if (modalSubtitle) {
        modalSubtitle.innerHTML = '<span id="audioModeIndicator">Etapa 2/2: Envie a mÃºsica de referÃªncia para comparaÃ§Ã£o</span>';
        modalSubtitle.style.display = 'block';
    }
    
    // Atualizar mensagem na Ã¡rea de upload
    const uploadAreaSecond = document.getElementById('audioUploadArea');
    if (uploadAreaSecond) {
        const uploadContent = uploadAreaSecond.querySelector('.upload-content h4');
        if (uploadContent) {
            uploadContent.textContent = 'Enviar mÃºsica de referÃªncia';
        }
        
        const uploadDescription = uploadAreaSecond.querySelector('.upload-content p');
        if (uploadDescription) {
            uploadDescription.textContent = 'Arraste a mÃºsica de referÃªncia aqui ou clique para selecionar';
        }
    }
    
    // Mostrar modal
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    
    __dbg('âœ… Modal secundÃ¡rio de referÃªncia aberto');
}

// ğŸ¯ NOVO: Modal de SeleÃ§Ã£o de Modo
function openModeSelectionModal() {
    __dbg('ï¿½ Abrindo modal de seleÃ§Ã£o de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (!modal) {
        console.error('Modal de seleÃ§Ã£o de modo nÃ£o encontrado');
        return;
    }
    
    // Verificar se modo referÃªncia estÃ¡ habilitado e mostrar/esconder botÃ£o
    const referenceModeBtn = document.getElementById('referenceModeBtn');
    if (referenceModeBtn) {
        const isEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
        referenceModeBtn.style.display = isEnabled ? 'flex' : 'none';
        
        if (!isEnabled) {
            referenceModeBtn.disabled = true;
        }
    }
    
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('mode_selection_modal_opened');
}

function closeModeSelectionModal() {
    __dbg('âŒ Fechando modal de seleÃ§Ã£o de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    window.logReferenceEvent('mode_selection_modal_closed');
}

// ğŸ¯ NOVO: Selecionar modo de anÃ¡lise
function selectAnalysisMode(mode) {
    window.logReferenceEvent('analysis_mode_selected', { mode });
    
    if (mode === 'reference' && !window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED) {
        alert('Modo de anÃ¡lise por referÃªncia nÃ£o estÃ¡ disponÃ­vel no momento.');
        return;
    }
    
    currentAnalysisMode = mode;
    
    // Fechar modal de seleÃ§Ã£o de modo
    closeModeSelectionModal();
    
    // Abrir modal de anÃ¡lise configurado para o modo selecionado
    openAnalysisModalForMode(mode);
}

// ï¿½ NOVO MODAL DE GÃŠNERO MUSICAL - Sistema completo
// Feature flag para controlar ativaÃ§Ã£o
window.FEATURE_NEW_GENRE_MODAL = true; // Definir como false para usar seletor antigo

// ğŸµ FunÃ§Ãµes do Modal de GÃªnero Musical
function openGenreModal() {
    __dbg('[GENRE_MODAL] Abrindo modal de seleÃ§Ã£o de gÃªnero...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal nÃ£o encontrado no DOM');
        return;
    }
    
    // Injetar estilos se ainda nÃ£o foi feito
    injectGenreModalStyles();
    
    // ğŸ”§ CORREÃ‡ÃƒO FLASH BRANCO: Prepaint para evitar primeiro frame errado
    modal.classList.add('prepaint');  // Cards invisÃ­veis enquanto CSS aplica
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
    
    // Libera a transiÃ§Ã£o sÃ³ de opacity no prÃ³ximo frame
    requestAnimationFrame(() => {
        modal.classList.remove('prepaint');
        
        // Foco no primeiro botÃ£o de gÃªnero
        const firstGenreCard = modal.querySelector('.genre-card');
        if (firstGenreCard) {
            firstGenreCard.focus();
        }
    });
    
    // Adicionar listeners de teclado
    modal.addEventListener('keydown', handleGenreModalKeydown);
    
    __dbg('[GENRE_MODAL] Modal aberto com sucesso (sem flash branco)');
}

function closeGenreModal() {
    __dbg('[GENRE_MODAL] Fechando modal de seleÃ§Ã£o de gÃªnero...');
    
    const modal = document.getElementById('newGenreModal');
    if (modal) {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        
        // Remover listeners
        modal.removeEventListener('keydown', handleGenreModalKeydown);
    }
    
    __dbg('[GENRE_MODAL] Modal fechado');
}

function handleGenreModalKeydown(e) {
    if (e.key === 'Escape') {
        closeGenreModal();
    }
}

// ğŸ¯ InicializaÃ§Ã£o do Modal de GÃªnero
function initGenreModal() {
    __dbg('[GENRE_MODAL] Inicializando sistema do modal...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.warn('[GENRE_MODAL] Modal nÃ£o encontrado, inicializaÃ§Ã£o cancelada');
        return;
    }
    
    const genreCards = modal.querySelectorAll('.genre-card');
    const closeBtn = modal.querySelector('[data-close]');
    
    // ğŸ¯ Handler de clique nos gÃªneros
    genreCards.forEach(card => {
        card.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const genre = card.dataset.genre;
            if (!genre) {
                console.error('[GENRE_MODAL] GÃªnero nÃ£o definido no card');
                return;
            }
            
            __dbg('[GENRE_MODAL] GÃªnero selecionado:', genre);
            
            // ğŸ”¥ REUTILIZAR EXATAMENTE: Chamar applyGenreSelection como especificado
            if (typeof applyGenreSelection === 'function') {
                // âœ… CORREÃ‡ÃƒO CRÃTICA: Aguardar carregamento completo dos targets
                await applyGenreSelection(genre);
                
                // âœ… Log detalhado mostrando targets reais
                console.log('âœ… [GENRE_MODAL] Targets de gÃªnero carregados:', {
                    genre: genre,
                    hasActiveRefData: !!window.__activeRefData,
                    hasTargets: !!window.__activeRefData?.targets,
                    targetSource: window.__activeRefData?.targetSource,
                    targetKeys: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets) : [],
                    targetSample: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets).slice(0, 3) : [],
                    lufs_target: window.__activeRefData?.lufs_target,
                    true_peak_target: window.__activeRefData?.true_peak_target,
                    version: window.__activeRefData?.version
                });
                
                __dbg('[GENRE_MODAL] âœ… applyGenreSelection concluÃ­do com sucesso');
            } else {
                console.error('[GENRE_MODAL] applyGenreSelection nÃ£o estÃ¡ disponÃ­vel');
                return;
            }
            
            // ğŸ”¥ Fechar modal conforme especificaÃ§Ã£o
            closeGenreModal();
            
            // ğŸ”¥ CONTINUAR FLUXO: Abrir modal de upload automaticamente
            // âœ… CORREÃ‡ÃƒO: Removido setTimeout - targets jÃ¡ estÃ£o carregados
            openAnalysisModalForGenre();
        });
    });
    
    // Handler do botÃ£o fechar
    if (closeBtn) {
        closeBtn.addEventListener('click', closeGenreModal);
    }
    
    // Fechar clicando no fundo
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeGenreModal();
        }
    });
    
    __dbg('[GENRE_MODAL] Sistema inicializado com sucesso');
}

// ğŸ¯ Abrir modal de anÃ¡lise apÃ³s seleÃ§Ã£o de gÃªnero
function openAnalysisModalForGenre() {
    __dbg('[GENRE_MODAL] Abrindo modal de anÃ¡lise para gÃªnero selecionado...');
    
    // Usar o fluxo normal do modal de anÃ¡lise
    window.currentAnalysisMode = 'genre';
    
    // ğŸ¯ LIMPAR estado de referÃªncia ao entrar em modo genre (conforme solicitado)
    const state = window.__soundyState || {};
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        console.log('âœ… [GENRE-CLEANUP] Estado de referÃªncia limpo ao iniciar modo genre');
    }
    window.__soundyState = state;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal de anÃ¡lise nÃ£o encontrado');
        return;
    }
    
    // Configurar modal para modo gÃªnero
    configureModalForMode('genre');
    
    modal.style.display = 'flex';
    
    // âœ… CORREÃ‡ÃƒO CRÃTICA: NÃƒO resetar gÃªnero/targets aqui!
    // Apenas limpar estado visual de upload (preserva gÃªnero selecionado)
    clearAudioOnlyState();
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    __dbg('[GENRE_MODAL] Modal de anÃ¡lise aberto (gÃªnero preservado)');
}

// Expor funÃ§Ãµes globalmente
window.openGenreModal = openGenreModal;
window.closeGenreModal = closeGenreModal;

// ï¿½ğŸ¯ NOVO: Abrir modal de anÃ¡lise configurado para o modo
function openAnalysisModalForMode(mode) {
    __dbg(`ğŸµ Abrindo modal de anÃ¡lise para modo: ${mode}`);
    
    // ğŸ†• FEATURE FLAG: Verificar se deve usar novo modal de gÃªnero
    if (mode === 'genre' && window.FEATURE_NEW_GENRE_MODAL === true) {
        __dbg('ğŸ¨ Usando novo modal de gÃªnero musical');
        openGenreModal();
        return;
    }
    
    // CORREÃ‡ÃƒO CRÃTICA: Definir window.currentAnalysisMode sempre que o modal for aberto
    window.currentAnalysisMode = mode;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('Modal de anÃ¡lise nÃ£o encontrado');
        return;
    }
    
    // Configurar modal baseado no modo
    configureModalForMode(mode);
    
    // Reset state especÃ­fico do modo
    if (mode === 'reference') {
        resetReferenceState();
    }
    
    modal.style.display = 'flex';
    
    // âœ… CORREÃ‡ÃƒO: Reset seletivo baseado no modo
    if (mode === 'genre') {
        // Modo gÃªnero: apenas limpar visual (preserva gÃªnero)
        clearAudioOnlyState();
    } else {
        // Modo referÃªncia: reset completo
        resetModalState();
    }
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('analysis_modal_opened', { mode });
}

// ğŸ¯ NOVO: Configurar modal baseado no modo selecionado
function configureModalForMode(mode) {
    const title = document.getElementById('audioModalTitle');
    const subtitle = document.getElementById('audioModalSubtitle');
    const modeIndicator = document.getElementById('audioModeIndicator');
    const genreContainer = document.getElementById('audioRefGenreContainer');
    const progressSteps = document.getElementById('referenceProgressSteps');
    
    if (mode === 'genre') {
        // Modo GÃªnero: comportamento original
        if (title) title.textContent = 'ğŸµ AnÃ¡lise de Ãudio';
        if (subtitle) subtitle.style.display = 'none';
        if (genreContainer) genreContainer.style.display = 'flex';
        if (progressSteps) progressSteps.style.display = 'none';
        
        // ğŸ”§ FIX: Limpar dados de referÃªncia ao trocar para modo genre
        if (window.__referenceComparisonActive) {
            console.log('[MODE_CHANGE] Trocando de REFERENCE para GENRE - limpando dados');
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            window.__referenceComparisonActive = false;
            
            console.log('[MODE_CHANGE] âœ… Dados de referÃªncia limpos para modo GENRE');
        }
        
    } else if (mode === 'reference') {
        // Modo ReferÃªncia: interface especÃ­fica
        if (title) title.textContent = 'ğŸ¯ AnÃ¡lise por ReferÃªncia';
        if (subtitle) {
            subtitle.style.display = 'block';
            if (modeIndicator) {
                modeIndicator.textContent = 'ComparaÃ§Ã£o direta entre suas mÃºsicas';
            }
        }
        if (genreContainer) genreContainer.style.display = 'none';
        if (progressSteps) progressSteps.style.display = 'flex';
        
        // Configurar steps iniciais
        updateReferenceStep('userAudio');
    }
}

// ğŸ¯ NOVO: Reset estado do modo referÃªncia (compatibilidade)
function resetReferenceState() {
    referenceStepState = {
        currentStep: 'userAudio',
        userAudioFile: null,
        referenceAudioFile: null,
        userAnalysis: null,
        referenceAnalysis: null
    };
    
    window.logReferenceEvent('reference_state_reset');
}

// ğŸ¯ FUNÃ‡ÃƒO AUXILIAR: Obter gÃªnero ativo de mÃºltiplas fontes
function getActiveGenre(analysis, fallback) {
    const genre = analysis?.genre ||
                 analysis?.genreId ||
                 analysis?.metadata?.genre ||
                 window.__CURRENT_GENRE ||
                 window.__soundyState?.render?.genre ||
                 window.__activeUserGenre ||
                 window.PROD_AI_REF_GENRE ||
                 fallback;
    
    console.log('[GET-ACTIVE-GENRE] GÃªnero detectado:', genre, '(fallback:', fallback, ')');
    return genre;
}

// ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Limpeza COMPLETA do estado de referÃªncia para modo gÃªnero
function resetReferenceStateFully(preserveGenre) {
    // âœ… PROTEÃ‡ÃƒO: NÃ£o limpar targets no modo gÃªnero
    const currentMode = window.currentAnalysisMode;
    if (currentMode === 'genre') {
        console.log('%c[GENRE-ISOLATION] ğŸ›¡ï¸ Modo GENRE detectado - IGNORANDO reset de referÃªncia', 'color:#FFD700;font-weight:bold;font-size:14px;');
        console.log('[GENRE-ISOLATION] âœ… Targets de gÃªnero preservados (reset bloqueado)');
        return; // NÃƒO executar reset no modo gÃªnero
    }
    
    console.group('%c[GENRE-ISOLATION] ğŸ§¹ Limpeza completa do estado de referÃªncia', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
    
    // ===============================================================
    // ğŸ”’ BLOCO 1 â€” PRESERVAR GÃŠNERO ANTES DO RESET (MÃšLTIPLAS FONTES)
    // ===============================================================
    let __PRESERVED_GENRE__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ = preserveGenre ||
                             window.__CURRENT_SELECTED_GENRE ||
                             window.PROD_AI_REF_GENRE ||
                             (genreSelect ? genreSelect.value : null) ||
                             window.__CURRENT_GENRE ||
                             window.__soundyState?.render?.genre ||
                             window.__activeUserGenre;

        console.log("[SAFE-RESET] âš ï¸ Preservando gÃªnero selecionado:", __PRESERVED_GENRE__);
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao capturar gÃªnero antes do reset:", e);
    }
    
    // ğŸ¯ SALVAR GÃŠNERO ANTES DE LIMPAR (compatibilidade com cÃ³digo existente)
    const __savedGenre = __PRESERVED_GENRE__;
    
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] ğŸ’¾ Salvando gÃªnero antes da limpeza:', __savedGenre);
    }
    
    // 1ï¸âƒ£ Limpar variÃ¡veis globais window - CRÃTICO
    console.log('[GENRE-ISOLATION] 1ï¸âƒ£ Limpando variÃ¡veis globais window...');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Salvar targets do gÃªnero preservado ANTES de limpar
    let __savedGenreTargets = null;
    if (__savedGenre) {
        // PROD_AI_REF_DATA pode ser dicionÃ¡rio ou objeto Ãºnico
        if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object') {
            if (window.PROD_AI_REF_DATA[__savedGenre]) {
                // Estrutura de dicionÃ¡rio
                __savedGenreTargets = window.PROD_AI_REF_DATA[__savedGenre];
                console.log('[GENRE-ISOLATION] ğŸ’¾ Targets do gÃªnero salvos (dicionÃ¡rio):', __savedGenre);
            } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
                // Objeto Ãºnico
                __savedGenreTargets = window.PROD_AI_REF_DATA;
                console.log('[GENRE-ISOLATION] ğŸ’¾ Targets salvos (objeto Ãºnico):', __savedGenre);
            }
        }
        // Fallback para __activeRefData
        if (!__savedGenreTargets && window.__activeRefData) {
            __savedGenreTargets = window.__activeRefData;
            console.log('[GENRE-ISOLATION] ğŸ’¾ Targets salvos de __activeRefData:', __savedGenre);
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar PROD_AI_REF_DATA para false (nÃ£o delete)
    window.PROD_AI_REF_DATA = false;
    console.log('   âœ… window.PROD_AI_REF_DATA: false');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Restaurar targets do gÃªnero preservado
    if (__savedGenre && __savedGenreTargets) {
        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
            window.PROD_AI_REF_DATA = {};
        }
        window.PROD_AI_REF_DATA[__savedGenre] = __savedGenreTargets;
        window.__activeRefData = __savedGenreTargets;
        console.log(`[GENRE-ISOLATION] ğŸ”„ Targets restaurados para gÃªnero: ${__savedGenre}`);
        console.log('   âœ… window.PROD_AI_REF_DATA[' + __savedGenre + ']: restaurado');
        console.log('   âœ… window.__activeRefData: restaurado com targets do gÃªnero');
    } else {
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __activeRefData apenas se nÃ£o houver gÃªnero preservado
        window.__activeRefData = null;
        console.log('   âœ… window.__activeRefData: null');
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __REFERENCE_JOB_ID__
    delete window.__REFERENCE_JOB_ID__;
    console.log('   âœ… window.__REFERENCE_JOB_ID__: removido');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __REFERENCE_FILE_KEY__
    window.__REFERENCE_FILE_KEY__ = null;
    console.log('   âœ… window.__REFERENCE_FILE_KEY__: null');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __CURRENT_JOB_ID__
    window.__CURRENT_JOB_ID__ = null;
    console.log('   âœ… window.__CURRENT_JOB_ID__: null');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __activeUserData
    window.__activeUserData = null;
    console.log('   âœ… window.__activeUserData: null');
    
    delete window.referenceAnalysisData;
    window.__referenceComparisonActive = false;
    window.__FIRST_ANALYSIS_FROZEN__ = undefined;
    console.log('   âœ… window.referenceAnalysisData: removido');
    console.log('   âœ… window.__referenceComparisonActive: false');
    
    // 2ï¸âƒ£ Limpar __soundyState
    console.log('[GENRE-ISOLATION] 2ï¸âƒ£ Limpando window.__soundyState...');
    if (window.__soundyState) {
        delete window.__soundyState.reference;
        delete window.__soundyState.referenceAnalysis;
        delete window.__soundyState.previousAnalysis;
        if (window.__soundyState.render) {
            window.__soundyState.render.mode = 'genre';
        }
        console.log('   âœ… __soundyState.reference: removido');
        console.log('   âœ… __soundyState.referenceAnalysis: removido');
        console.log('   âœ… __soundyState.render.mode: forÃ§ado para "genre"');
    }
    
    // 3ï¸âƒ£ Limpar localStorage
    console.log('[GENRE-ISOLATION] 3ï¸âƒ£ Limpando localStorage...');
    try {
        localStorage.removeItem('referenceJobId');
        localStorage.removeItem('referenceAnalysis');
        console.log('   âœ… localStorage.referenceJobId: removido');
        console.log('   âœ… localStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   âš ï¸ Falha ao limpar localStorage:', e.message);
    }
    
    // 4ï¸âƒ£ Limpar sessionStorage
    console.log('[GENRE-ISOLATION] 4ï¸âƒ£ Limpando sessionStorage...');
    try {
        sessionStorage.removeItem('referenceJobId');
        sessionStorage.removeItem('referenceAnalysis');
        console.log('   âœ… sessionStorage.referenceJobId: removido');
        console.log('   âœ… sessionStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   âš ï¸ Falha ao limpar sessionStorage:', e.message);
    }
    
    // 5ï¸âƒ£ Limpar Store (se existir)
    console.log('[GENRE-ISOLATION] 5ï¸âƒ£ Limpando SoundyAI_Store...');
    if (window.SoundyAI_Store) {
        delete window.SoundyAI_Store.first;
        delete window.SoundyAI_Store.second;
        console.log('   âœ… SoundyAI_Store.first: removido');
        console.log('   âœ… SoundyAI_Store.second: removido');
    }
    
    // 6ï¸âƒ£ Resetar referenceStepState
    console.log('[GENRE-ISOLATION] 6ï¸âƒ£ Resetando referenceStepState...');
    if (typeof referenceStepState !== 'undefined') {
        referenceStepState = {
            currentStep: 'userAudio',
            userAudioFile: null,
            referenceAudioFile: null,
            userAnalysis: null,
            referenceAnalysis: null
        };
        console.log('   âœ… referenceStepState: resetado');
    }
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Resetar flag de renderizaÃ§Ã£o de IA
    // Permite que o mÃ³dulo de sugestÃµes seja re-renderizado apÃ³s limpeza
    console.log('[GENRE-ISOLATION] 7ï¸âƒ£ Resetando flags de renderizaÃ§Ã£o de IA...');
    window.__AI_RENDER_COMPLETED__ = false;
    console.log('   âœ… window.__AI_RENDER_COMPLETED__: false (permitir re-renderizaÃ§Ã£o)');
    
    // ğŸ¯ RESTAURAR GÃŠNERO APÃ“S LIMPEZA
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] ğŸ”„ Restaurando gÃªnero:', __savedGenre);
        window.__CURRENT_GENRE = __savedGenre;
        
        if (!window.__soundyState) {
            window.__soundyState = {};
        }
        if (!window.__soundyState.render) {
            window.__soundyState.render = {};
        }
        
        window.__soundyState.render.genre = __savedGenre;
        window.__activeUserGenre = __savedGenre;
        window.PROD_AI_REF_GENRE = __savedGenre;  // âœ… CORREÃ‡ÃƒO: Sincronizar PROD_AI_REF_GENRE
        
        console.log('   âœ… window.__CURRENT_GENRE:', __savedGenre);
        console.log('   âœ… window.__soundyState.render.genre:', __savedGenre);
        console.log('   âœ… window.__activeUserGenre:', __savedGenre);
        console.log('   âœ… window.PROD_AI_REF_GENRE:', __savedGenre);
    }
    
    // ===============================================================
    // ğŸ”’ BLOCO 3 â€” RESTAURAR GÃŠNERO NO DROPDOWN APÃ“S O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;
            window.__CURRENT_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            console.log("[SAFE-RESET] âœ… GÃªnero restaurado no dropdown apÃ³s reset:", __PRESERVED_GENRE__);
        } else {
            console.warn("[SAFE-RESET] âš ï¸ Nenhum gÃªnero vÃ¡lido preservado para dropdown.");
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar gÃªnero no dropdown:", e);
    }
    
    console.log('%c[GENRE-ISOLATION] âœ… Estado de referÃªncia completamente limpo', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

// ========================================
// ğŸ”¥ UI HELPERS - SHOW/HIDE SEÃ‡Ã•ES
// ========================================

function hideReferenceUI() {
    console.log('[UI-CONTROL] ğŸ™ˆ Ocultando elementos de UI de referÃªncia...');
    
    // Ocultar elementos especÃ­ficos de referÃªncia
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    âœ… Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showGenreUI() {
    console.log('[UI-CONTROL] ğŸ‘ï¸ Exibindo elementos de UI de gÃªnero...');
    
    // Exibir elementos especÃ­ficos de gÃªnero
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    âœ… Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

function hideGenreUI() {
    console.log('[UI-CONTROL] ğŸ™ˆ Ocultando elementos de UI de gÃªnero...');
    
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    âœ… Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showReferenceUI() {
    console.log('[UI-CONTROL] ğŸ‘ï¸ Exibindo elementos de UI de referÃªncia...');
    
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    âœ… Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

// ========================================
// ğŸ”¥ RENDERIZAÃ‡ÃƒO ISOLADA DE GÃŠNERO
// ========================================

// ğŸ¯ MÃ“DULO DE CONVERSÃƒO DE BANDAS (EXCLUSIVO PARA MODO GÃŠNERO)
// ========================================
/**
 * Converte nomes de bandas do backend para o formato esperado pelos targets de gÃªnero.
 * 
 * Backend envia: sub, bass, lowMid, mid, highMid, presence, air
 * Targets esperam: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
 * 
 * âš ï¸ USO EXCLUSIVO: Apenas para analysis.mode === "genre"
 * âŒ NUNCA usar para: mode === "reference", A/B, referenceComparison
 * 
 * @param {Object} bands - Bandas do backend (analysis.bands)
 * @returns {Object} Bandas convertidas para formato de targets de gÃªnero
 */
// ğŸ¯ SISTEMA DE ALIAS DE BANDAS (branch imersao)
const BAND_ALIASES = {
    'bass': ['low_bass', 'upper_bass'],
    'lowMid': ['low_mid'],
    'highMid': ['high_mid'],
    'presence': ['presenca'],
    'air': ['brilho']
};

/**
 * Busca banda com suporte a alias (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} bandsObject - Objeto com bandas
 * @returns {Object|null} Dados da banda ou null
 */
function searchBandWithAlias(bandKey, bandsObject) {
    if (!bandsObject || typeof bandsObject !== 'object') return null;
    
    // 1. Busca direta
    if (bandsObject[bandKey]) {
        return bandsObject[bandKey];
    }
    
    // 2. Busca por alias
    const aliases = BAND_ALIASES[bandKey];
    if (aliases) {
        for (const alias of aliases) {
            if (bandsObject[alias]) {
                console.log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias}`);
                return bandsObject[alias];
            }
        }
    }
    
    return null;
}

/**
 * Busca banda em mÃºltiplas fontes com cascata (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @returns {Object|null} Dados da banda com source
 */
/**
 * Normaliza nomes de bandas do backend para formato dos targets de gÃªnero.
 * Backend: ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air']
 * Targets: ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca']
 */
function normalizeGenreBandName(name) {
    const map = {
        'bass': 'low_bass',
        'lowMid': 'low_mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho',
        'sub': 'sub',
        'mid': 'mid'
        // 'totalPercentage' serÃ¡ ignorado (nÃ£o estÃ¡ no map)
    };
    return map[name] || name;
}

function getBandDataWithCascade(bandKey, analysis) {
    // 1. Prioridade: analysis.metrics.bands (centralizado)
    if (analysis.metrics?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.metrics.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'centralized' 
            };
        }
    }
    
    // 2. Fallback: tech.bandEnergies (legado)
    if (analysis.technicalData?.bandEnergies) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bandEnergies);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'legacy' 
            };
        }
    }
    
    // 3. Fallback: tech.spectralBands
    if (analysis.technicalData?.spectralBands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectralBands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectral' 
            };
        }
    }
    
    return null;
}

function mapBackendBandsToGenreBands(bands) {
    if (!bands || typeof bands !== 'object') {
        console.warn('[BAND-MAPPER] âš ï¸ Bandas invÃ¡lidas recebidas:', bands);
        return {};
    }
    
    console.group('[BAND-MAPPER] ğŸ”„ Convertendo bandas do backend para formato de gÃªnero');
    console.log('[BAND-MAPPER] Bandas originais (backend):', Object.keys(bands));
    
    const mapped = {
        // Mapeamento direto (mesma chave)
        sub: bands.sub || null,
        mid: bands.mid || null,
        
        // ConversÃµes necessÃ¡rias
        low_bass: bands.bass || null,           // bass â†’ low_bass
        upper_bass: null,                       // âŒ nÃ£o existe no backend atual
        low_mid: bands.lowMid || null,          // lowMid â†’ low_mid
        high_mid: bands.highMid || null,        // highMid â†’ high_mid
        brilho: bands.air || null,              // air â†’ brilho
        presenca: bands.presence || null        // presence â†’ presenca
    };
    
    console.log('[BAND-MAPPER] Bandas convertidas (targets):', Object.keys(mapped).filter(k => mapped[k] !== null));
    console.log('[BAND-MAPPER] Bandas ausentes:', Object.keys(mapped).filter(k => mapped[k] === null));
    console.groupEnd();
    
    return mapped;
}

/**
 * Aplica conversÃ£o de bandas EXCLUSIVAMENTE para modo gÃªnero.
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @returns {Object} AnÃ¡lise com bandas convertidas (analysis.genreBands)
 */
function applyGenreBandConversion(analysis) {
    // ğŸ›¡ï¸ GUARD: Apenas para modo gÃªnero
    if (analysis?.mode !== 'genre') {
        console.log('[BAND-MAPPER] â­ï¸ Modo nÃ£o Ã© gÃªnero, pulando conversÃ£o');
        return analysis;
    }
    
    console.group('[BAND-MAPPER] ğŸ¯ Aplicando conversÃ£o de bandas para modo GÃŠNERO');
    console.log('[BAND-MAPPER] Mode:', analysis.mode);
    console.log('[BAND-MAPPER] Bandas originais:', analysis.bands ? Object.keys(analysis.bands) : 'N/A');
    
    // Converter bandas do backend para formato de targets
    if (analysis.bands) {
        analysis.genreBands = mapBackendBandsToGenreBands(analysis.bands);
        console.log('[BAND-MAPPER] âœ… analysis.genreBands criado com', Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null).length, 'bandas');
    } else {
        console.warn('[BAND-MAPPER] âš ï¸ analysis.bands nÃ£o disponÃ­vel');
        analysis.genreBands = {};
    }
    
    console.groupEnd();
    return analysis;
}

function renderGenreView(analysis) {
    console.group('%c[GENRE-VIEW] ğŸ¨ Renderizando UI exclusiva de gÃªnero', 'color:#00C9FF;font-weight:bold;font-size:14px;');
    
    // ğŸ”¥ ISOLAMENTO TOTAL: Limpar TODAS as variÃ¡veis de referÃªncia
    console.log('[GENRE-VIEW] ğŸ§¹ LIMPANDO variÃ¡veis de referÃªncia...');
    analysis.referenceComparison = undefined;
    analysis.referenceComparisonMetrics = undefined;
    window.referenceComparisonMetrics = null;
    console.log('[GENRE-VIEW] âœ… VariÃ¡veis de referÃªncia limpas');
    
    // 1ï¸âƒ£ Validar anÃ¡lise
    if (!analysis) {
        console.error('[GENRE-VIEW] âŒ ERRO: AnÃ¡lise nÃ£o fornecida');
        console.groupEnd();
        return;
    }
    
    // 2ï¸âƒ£ Garantir limpeza completa
    console.log('[GENRE-VIEW] 1ï¸âƒ£ Executando limpeza preventiva...');
    // ğŸ¯ PRESERVAR GÃŠNERO durante o reset
    const genreToPreserve = getActiveGenre(analysis, window.PROD_AI_REF_GENRE);
    resetReferenceStateFully(genreToPreserve);
    
    // ğŸ¯ GARANTIR que analysis.genre estÃ¡ definido
    if (genreToPreserve && !analysis.genre) {
        analysis.genre = genreToPreserve;
    }
    
    // 3ï¸âƒ£ Configurar ViewMode
    console.log('[GENRE-VIEW] 2ï¸âƒ£ Configurando ViewMode...');
    setViewMode("genre");
    
    // 4ï¸âƒ£ Controlar UI visibility
    console.log('[GENRE-VIEW] 3ï¸âƒ£ Controlando visibilidade de UI...');
    hideReferenceUI();
    showGenreUI();
    
    // 5ï¸âƒ£ Obter gÃªnero
    const genre = analysis.metadata?.genre || 
                  analysis.genreId || 
                  analysis.classification || 
                  window.PROD_AI_REF_GENRE || 
                  window.__selectedGenre || 
                  window.__activeRefGenre ||
                  'default';
    
    console.log('[GENRE-VIEW] 4ï¸âƒ£ GÃªnero identificado:', genre);
    
    // ğŸ¯ CONVERSÃƒO DE BANDAS: Backend â†’ Targets de gÃªnero
    console.log('[GENRE-VIEW] ğŸ”„ Aplicando conversÃ£o de bandas...');
    applyGenreBandConversion(analysis);
    console.log('[GENRE-VIEW] âœ… Bandas convertidas:', analysis.genreBands ? Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null) : 'N/A');
    
    // 6ï¸âƒ£ Obter targets de gÃªnero
    // ğŸ”¥ CORREÃ‡ÃƒO: PROD_AI_REF_DATA pode ser um objeto Ãºnico OU um dicionÃ¡rio
    let genreTargets = null;
    
    if (window.PROD_AI_REF_DATA) {
        if (typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
            // Estrutura de dicionÃ¡rio: { genre1: {...}, genre2: {...} }
            genreTargets = window.PROD_AI_REF_DATA[genre];
            console.log('[GENRE-VIEW] ğŸ“¦ Targets obtidos de PROD_AI_REF_DATA[genre] (dicionÃ¡rio)');
        } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
            // Objeto Ãºnico diretamente atribuÃ­do
            genreTargets = window.PROD_AI_REF_DATA;
            console.log('[GENRE-VIEW] ğŸ“¦ Targets obtidos de PROD_AI_REF_DATA (objeto Ãºnico)');
        }
    }
    
    // Fallback para __activeRefData
    if (!genreTargets && window.__activeRefData) {
        genreTargets = window.__activeRefData;
        console.log('[GENRE-VIEW] ğŸ“¦ Targets obtidos de __activeRefData (fallback)');
    }
    
    if (!genreTargets) {
        console.error('[GENRE-VIEW] âŒ CRÃTICO: Targets de gÃªnero nÃ£o disponÃ­veis - ABORTANDO');
        console.error('[GENRE-VIEW]    window.PROD_AI_REF_DATA:', window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    window.__activeRefData:', window.__activeRefData);
        console.error('[GENRE-VIEW]    Tipo PROD_AI_REF_DATA:', typeof window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    analysis.referenceComparison:', analysis.referenceComparison);
        console.error('[GENRE-VIEW] ğŸ” DIAGNÃ“STICO: Verificar se targets foram carregados antes de displayModalResults');
        console.groupEnd();
        return; // âŒ ABORTAR se nÃ£o houver targets
    } else {
        console.log('[GENRE-VIEW] 5ï¸âƒ£ Targets encontrados:', {
            hasBands: !!genreTargets?.bands,
            bandsCount: genreTargets?.bands ? Object.keys(genreTargets.bands).length : 0,
            hasLegacyCompatibility: !!genreTargets?.legacy_compatibility,
            hasLufsTarget: genreTargets?.lufs_target !== undefined,
            bandas: genreTargets?.bands ? Object.keys(genreTargets.bands) : 'N/A'
        });
    }
    
    // 7ï¸âƒ£ Renderizar tabela de comparaÃ§Ã£o de gÃªnero
    console.log('[GENRE-VIEW] 6ï¸âƒ£ Renderizando tabela de comparaÃ§Ã£o...');
    console.log('[GENRE-VIEW] ğŸ¯ GARANTIA: Chamando renderGenreComparisonTable com targets validados');
    console.log('[GENRE-VIEW] ğŸ” AUDIT: Targets sendo passados:', {
        hasHybridProcessing: !!genreTargets?.hybrid_processing,
        hasSpectralBands: !!genreTargets?.hybrid_processing?.spectral_bands,
        spectralBandsKeys: genreTargets?.hybrid_processing?.spectral_bands ? Object.keys(genreTargets.hybrid_processing.spectral_bands) : 'N/A'
    });
    
    renderGenreComparisonTable({
        analysis,
        genre,
        targets: genreTargets
    });
    
    console.log('[GENRE-VIEW] ğŸ¯ GARANTIA: renderGenreComparisonTable executado');
    console.log('[GENRE-VIEW] ğŸ” AUDIT: Verificando se #referenceComparisons foi preenchido...');
    
    const refCompContainer = document.getElementById('referenceComparisons');
    if (refCompContainer) {
        console.log('[GENRE-VIEW] âœ… Container encontrado:', {
            innerHTML: refCompContainer.innerHTML.length > 0 ? `${refCompContainer.innerHTML.length} chars` : 'VAZIO',
            display: window.getComputedStyle(refCompContainer).display,
            visibility: window.getComputedStyle(refCompContainer).visibility,
            opacity: window.getComputedStyle(refCompContainer).opacity
        });
    } else {
        console.error('[GENRE-VIEW] âŒ Container #referenceComparisons NÃƒO ENCONTRADO!');
    }
    
    console.log('%c[GENRE-VIEW] âœ… RenderizaÃ§Ã£o de gÃªnero concluÃ­da', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

function renderGenreComparisonTable(options) {
    const { analysis, genre, targets } = options;
    
    console.group('[GENRE-TABLE] ğŸ“Š RENDERIZAÃ‡ÃƒO COMPLETA DE GÃŠNERO');
    console.log('[GENRE-TABLE] ğŸ¯ GÃªnero:', genre);
    console.log('[GENRE-TABLE] ğŸ“ Targets recebidos (parÃ¢metro):', targets);
    
    // ğŸ›¡ï¸ GUARD: Apenas para modo gÃªnero
    if (analysis?.mode !== 'genre') {
        console.warn('[GENRE-TABLE] â­ï¸ Modo nÃ£o Ã© gÃªnero, abortando renderizaÃ§Ã£o');
        console.groupEnd();
        return;
    }
    
    // Buscar container
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('[GENRE-TABLE] âŒ Container #referenceComparisons nÃ£o encontrado!');
        console.groupEnd();
        return;
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair targets SEMPRE de analysis.data.genreTargets primeiro
    console.log('[GENRE-TABLE] ğŸ¯ Extraindo targets da anÃ¡lise (FONTE OFICIAL)');
    let genreData = extractGenreTargetsFromAnalysis(analysis);
    
    // Fallback: usar parÃ¢metro targets se analysis nÃ£o tiver
    if (!genreData) {
        console.warn('[GENRE-TABLE] âš ï¸ FALLBACK: Usando targets do parÃ¢metro (analysis.data.genreTargets nÃ£o disponÃ­vel)');
        genreData = targets;
    }
    
    // Se targets for um objeto com chaves de gÃªnero, extrair o correto
    if (genreData && genreData[genre]) {
        console.log('[GENRE-TABLE] ğŸ“¦ Extraindo targets especÃ­ficos do gÃªnero:', genre);
        genreData = genreData[genre];
    }
    
    if (!genreData) {
        console.error('[GENRE-TABLE] âŒ CRÃTICO: Nenhum target disponÃ­vel!');
        console.error('[GENRE-TABLE]    - analysis.data.genreTargets:', !!analysis?.data?.genreTargets);
        console.error('[GENRE-TABLE]    - targets parameter:', !!targets);
        console.groupEnd();
        return;
    }
    
    console.log('[GENRE-TABLE] ğŸ“¦ Genre data:', {
        lufs_target: genreData.lufs_target,
        true_peak_target: genreData.true_peak_target,
        dr_target: genreData.dr_target,
        lra_target: genreData.lra_target,
        stereo_target: genreData.stereo_target,
        tol_lufs: genreData.tol_lufs,
        tol_true_peak: genreData.tol_true_peak,
        tol_dr: genreData.tol_dr,
        tol_lra: genreData.tol_lra,
        tol_stereo: genreData.tol_stereo,
        hasBands: !!genreData.bands
    });
    
    // ğŸ¯ EXTRAIR VALORES DO ANALYSIS (mesmas fontes usadas em calculateScore)
    const lufsIntegrated = analysis.loudness?.integrated ?? analysis.technicalData?.lufsIntegrated ?? null;
    const truePeakDbtp = analysis.truePeakDbtp ?? analysis.truePeak?.maxDbtp ?? analysis.technicalData?.truePeakDbtp ?? null;
    const dynamicRange = analysis.dynamicRange ?? analysis.dynamics?.range ?? analysis.technicalData?.dynamicRange ?? null;
    const lra = analysis.lra ?? analysis.loudness?.lra ?? analysis.technicalData?.lra ?? null;
    const stereoCorrelation = analysis.stereoCorrelation ?? analysis.stereo?.correlation ?? analysis.technicalData?.stereoCorrelation ?? null;
    
    console.log('[GENRE-TABLE] ğŸ“Š Valores extraÃ­dos do analysis:', {
        lufsIntegrated,
        truePeakDbtp,
        dynamicRange,
        lra,
        stereoCorrelation
    });
    
    // ğŸ¯ EXTRAIR BANDAS (mesma fonte usada em calculateFrequencyScore)
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;
    const userBands = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
    
    console.log('[GENRE-TABLE] ğŸµ Bandas do usuÃ¡rio:', userBands ? Object.keys(userBands) : 'N/A');
    
    const targetBands = genreData.bands || {};
    
    console.log('[GENRE-TABLE] ğŸ¯ Target bands:', Object.keys(targetBands));
    
    // ğŸ¯ HELPER: Calcular severidade e aÃ§Ã£o baseado em diferenÃ§a e tolerÃ¢ncia
    const calcSeverity = (value, target, tolerance) => {
        if (target === null || target === undefined || !Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados' };
        }
        
        const diff = value - target;
        const absDiff = Math.abs(diff);
        
        if (absDiff <= tolerance) {
            return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff };
        } else if (absDiff <= tolerance * 2) {
            const action = diff > 0 ? `âš ï¸ Reduzir ${absDiff.toFixed(1)}` : `âš ï¸ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ATENÃ‡ÃƒO', severityClass: 'caution', action, diff };
        } else if (absDiff <= tolerance * 3) {
            const action = diff > 0 ? `ğŸŸ¡ Reduzir ${absDiff.toFixed(1)}` : `ğŸŸ¡ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ALTA', severityClass: 'warning', action, diff };
        } else {
            const action = diff > 0 ? `ğŸ”´ Reduzir ${absDiff.toFixed(1)}` : `ğŸ”´ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'CRÃTICA', severityClass: 'critical', action, diff };
        }
    };
    
    // Construir linhas da tabela
    const rows = [];
    let metricsCount = 0;
    let bandsCount = 0;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1ï¸âƒ£ MÃ‰TRICAS PRINCIPAIS (LUFS, TRUE PEAK, DR, LRA, STEREO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ğŸ”Š LUFS Integrado
    if (genreData.lufs_target !== null && genreData.lufs_target !== undefined) {
        const lufsValue = lufsIntegrated;
        if (Number.isFinite(lufsValue)) {
            const result = calcSeverity(lufsValue, genreData.lufs_target, genreData.tol_lufs || 1.0);
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">ğŸ”Š Loudness (LUFS)</td>
                    <td class="metric-value">${lufsValue.toFixed(2)} LUFS</td>
                    <td class="metric-target">${genreData.lufs_target.toFixed(1)} LUFS</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            metricsCount++;
            console.log(`[GENRE-TABLE] âœ… LUFS: ${lufsValue.toFixed(2)} | Target: ${genreData.lufs_target} | ${result.severity}`);
        }
    }
    
    // ğŸšï¸ True Peak
    if (genreData.true_peak_target !== null && genreData.true_peak_target !== undefined) {
        const tpValue = truePeakDbtp;
        if (Number.isFinite(tpValue)) {
            const result = calcSeverity(tpValue, genreData.true_peak_target, genreData.tol_true_peak || 0.5);
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">ğŸšï¸ Pico Real (dBTP)</td>
                    <td class="metric-value">${tpValue.toFixed(2)} dBTP</td>
                    <td class="metric-target">${genreData.true_peak_target.toFixed(1)} dBTP</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            metricsCount++;
            console.log(`[GENRE-TABLE] âœ… True Peak: ${tpValue.toFixed(2)} | Target: ${genreData.true_peak_target} | ${result.severity}`);
        }
    }
    
    // ğŸ“Š Dynamic Range (DR)
    if (genreData.dr_target !== null && genreData.dr_target !== undefined) {
        const drValue = dynamicRange;
        if (Number.isFinite(drValue)) {
            const result = calcSeverity(drValue, genreData.dr_target, genreData.tol_dr || 1.0);
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">ğŸ“Š DinÃ¢mica (DR)</td>
                    <td class="metric-value">${drValue.toFixed(2)} DR</td>
                    <td class="metric-target">${genreData.dr_target.toFixed(1)} DR</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            metricsCount++;
            console.log(`[GENRE-TABLE] âœ… DR: ${drValue.toFixed(2)} | Target: ${genreData.dr_target} | ${result.severity}`);
        }
    }
    
    // ğŸ“ˆ Loudness Range (LRA)
    if (genreData.lra_target !== null && genreData.lra_target !== undefined) {
        const lraValue = lra;
        if (Number.isFinite(lraValue)) {
            const result = calcSeverity(lraValue, genreData.lra_target, genreData.tol_lra || 2.0);
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">ğŸ“ˆ LRA (Faixa de Loudness)</td>
                    <td class="metric-value">${lraValue.toFixed(2)} LU</td>
                    <td class="metric-target">${genreData.lra_target.toFixed(1)} LU</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            metricsCount++;
            console.log(`[GENRE-TABLE] âœ… LRA: ${lraValue.toFixed(2)} | Target: ${genreData.lra_target} | ${result.severity}`);
        }
    }
    
    // ğŸ§ Stereo Correlation
    if (genreData.stereo_target !== null && genreData.stereo_target !== undefined) {
        const stereoValue = stereoCorrelation;
        if (Number.isFinite(stereoValue)) {
            const result = calcSeverity(stereoValue, genreData.stereo_target, genreData.tol_stereo || 0.1);
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">ğŸ§ Imagem EstÃ©reo</td>
                    <td class="metric-value">${stereoValue.toFixed(3)}</td>
                    <td class="metric-target">${genreData.stereo_target.toFixed(3)}</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(3)}</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            metricsCount++;
            console.log(`[GENRE-TABLE] âœ… Stereo: ${stereoValue.toFixed(3)} | Target: ${genreData.stereo_target} | ${result.severity}`);
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2ï¸âƒ£ BANDAS ESPECTRAIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const nomesBandas = {
        sub: 'ğŸ”‰ Sub (20-60 Hz)',
        low_bass: 'ğŸ”Š Bass (60-120 Hz)',
        upper_bass: 'ğŸ”Š Upper Bass (120-250 Hz)',
        low_mid: 'ğŸµ Low Mid (250-500 Hz)',
        mid: 'ğŸµ Mid (500-2k Hz)',
        high_mid: 'ğŸ¸ High Mid (2k-4k Hz)',
        brilho: 'âœ¨ Brilho (4k-10k Hz)',
        presenca: 'ğŸ’ PresenÃ§a (10k-20k Hz)'
    };
    
    // ğŸ¯ ITERAR SOBRE AS BANDAS DO USUÃRIO (backend) e mapear para targets
    if (userBands && Object.keys(userBands).length > 0) {
        Object.keys(userBands).forEach(backendKey => {
            // Ignorar 'totalPercentage'
            if (backendKey === 'totalPercentage') {
                return;
            }
            
            // ğŸ”„ NORMALIZAR nome da banda do backend para target
            const targetKey = normalizeGenreBandName(backendKey);
            const targetBand = targetBands[targetKey];
            
            // Verificar se existe target para essa banda
            if (!targetBand) {
                console.log(`[GENRE-TABLE] â­ï¸ Pulando banda sem target: ${backendKey} â†’ ${targetKey}`);
                return;
            }
            
            // Verificar se o target tem valor vÃ¡lido
            if (targetBand.target_db === null || targetBand.target_db === undefined) {
                console.log(`[GENRE-TABLE] â­ï¸ Pulando banda com target null: ${targetKey}`);
                return;
            }
            
            const bandData = userBands[backendKey];
            const energyDb = bandData.energy_db ?? bandData.rms_db ?? (typeof bandData === 'number' ? bandData : null);
            
            if (!Number.isFinite(energyDb)) {
                console.log(`[GENRE-TABLE] ğŸ”‡ Banda sem valor vÃ¡lido: ${backendKey}`);
                return;
            }
            
            const targetValue = targetBand.target_db;
            const tolerance = targetBand.tol_db || 2.0;
            
            const result = calcSeverity(energyDb, targetValue, tolerance);
            
            const nomeAmigavel = nomesBandas[targetKey] || targetKey;
            
            rows.push(`
                <tr class="genre-row ${result.severityClass}">
                    <td class="metric-name">${nomeAmigavel}</td>
                    <td class="metric-value">${energyDb.toFixed(2)} dB</td>
                    <td class="metric-target">${targetValue.toFixed(1)} dB</td>
                    <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)} dB</td>
                    <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                    <td class="metric-action ${result.severityClass}">${result.action}</td>
                </tr>
            `);
            bandsCount++;
            console.log(`[GENRE-TABLE] âœ… ${nomeAmigavel}: ${energyDb.toFixed(2)} dB | Target: ${targetValue.toFixed(1)} | ${result.severity}`);
        });
    }
    
    // Renderizar HTML completo
    const tableHTML = `
        <div class="card genre-comparison-classic" style="margin-top:12px;">
            <div class="card-title">COMPARAÃ‡ÃƒO COM ${genre.toUpperCase()}</div>
            <table class="classic-genre-table">
                <thead>
                    <tr>
                        <th>MÃ©trica</th>
                        <th>Valor</th>
                        <th>Alvo</th>
                        <th>DiferenÃ§a</th>
                        <th>Severidade</th>
                        <th>AÃ§Ã£o Sugerida</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.join('')}
                </tbody>
            </table>
        </div>
    `;
    
    // ğŸ”¥ AUDITORIA CRÃTICA: Verificar container ANTES de inserir HTML
    console.log('[GENRE-TABLE-AUDIT] ğŸ” ANTES de innerHTML:', {
        containerExists: !!container,
        containerVisible: container ? window.getComputedStyle(container).display : 'N/A',
        containerOpacity: container ? window.getComputedStyle(container).opacity : 'N/A',
        containerParent: container ? container.parentElement?.id : 'N/A',
        tableHTMLLength: tableHTML.length,
        rowsCount: rows.length
    });
    
    container.innerHTML = tableHTML;
    
    // ğŸ”¥ AUDITORIA CRÃTICA: Verificar container DEPOIS de inserir HTML
    console.log('[GENRE-TABLE-AUDIT] ğŸ” DEPOIS de innerHTML:', {
        containerInnerHTMLLength: container.innerHTML.length,
        containerFirstChild: container.firstChild ? container.firstChild.className : 'N/A',
        tableExists: !!container.querySelector('.classic-genre-table'),
        rowsInDOM: container.querySelectorAll('tr').length
    });
    
    // ForÃ§ar visibilidade
    container.classList.remove('hidden');
    container.style.display = 'block';
    container.style.visibility = 'visible';
    container.style.opacity = '1';
    
    // ğŸ”¥ AUDITORIA FINAL: Verificar visibilidade computada
    const computedStyle = window.getComputedStyle(container);
    console.log('[GENRE-TABLE-AUDIT] ğŸ” VISIBILIDADE FINAL:', {
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        opacity: computedStyle.opacity,
        height: computedStyle.height,
        overflow: computedStyle.overflow
    });
    
    // ğŸ¨ INJETAR ESTILOS CSS PARA TABELA CLÃSSICA DE GÃŠNERO (branch imersao)
    if (!document.getElementById('classicGenreTableStyles')) {
        const style = document.createElement('style');
        style.id = 'classicGenreTableStyles';
        style.textContent = `
            /* ğŸ¯ TABELA CLÃSSICA DE GÃŠNERO */
            .genre-comparison-classic {
                background: linear-gradient(135deg, rgba(14, 20, 34, 0.95), rgba(31, 43, 64, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 16px;
                padding: 24px;
                margin-top: 16px;
            }
            
            .classic-genre-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }
            
            .classic-genre-table thead {
                background: rgba(0, 102, 255, 0.15);
                border-bottom: 2px solid rgba(36, 157, 255, 0.4);
            }
            
            .classic-genre-table th {
                font-weight: 600;
                padding: 12px 16px;
                text-align: center;
                font-size: 12px;
                color: #00f0ff;
                letter-spacing: 0.5px;
                text-transform: uppercase;
            }
            
            .classic-genre-table th:first-child {
                text-align: left;
            }
            
            .classic-genre-table td {
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                color: #f5f7fa;
                text-align: center;
            }
            
            .classic-genre-table td:first-child {
                text-align: left;
                font-weight: 500;
            }
            
            .classic-genre-table tr:last-child td {
                border-bottom: 0;
            }
            
            .classic-genre-table tbody tr:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            
            /* ğŸ¨ CORES DE SEVERIDADE */
            .classic-genre-table .genre-row.ok {
                background: rgba(82, 247, 173, 0.08);
            }
            
            .classic-genre-table .genre-row.caution {
                background: rgba(255, 206, 77, 0.08);
            }
            
            .classic-genre-table .genre-row.warning {
                background: rgba(255, 165, 0, 0.08);
            }
            
            .classic-genre-table .genre-row.critical {
                background: rgba(255, 123, 123, 0.08);
            }
            
            .classic-genre-table .metric-severity.ok {
                color: #52f7ad;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.caution {
                color: #ffce4d;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.warning {
                color: #ffa500;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.critical {
                color: #ff7b7b;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-action {
                font-size: 12px;
            }
            
            .classic-genre-table .metric-diff.positive {
                color: #ffa500;
            }
            
            .classic-genre-table .metric-diff.negative {
                color: #00d4ff;
            }
            
            /* ğŸ¯ MOBILE RESPONSIVO - TABELA GÃŠNERO */
            @media (max-width: 768px) {
                .genre-comparison-classic {
                    padding: 12px !important;
                    border-radius: 12px !important;
                    overflow-x: hidden !important;
                }
                
                .classic-genre-table {
                    table-layout: fixed !important;
                    width: 100% !important;
                    font-size: 10px !important;
                    overflow-x: auto !important;
                    display: block !important;
                }
                
                .classic-genre-table thead,
                .classic-genre-table tbody,
                .classic-genre-table tr {
                    display: table !important;
                    width: 100% !important;
                    table-layout: fixed !important;
                }
                
                .classic-genre-table th {
                    padding: 8px 4px !important;
                    font-size: 9px !important;
                    letter-spacing: 0.3px !important;
                    line-height: 1.2 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table td {
                    padding: 8px 4px !important;
                    font-size: 10px !important;
                    line-height: 1.3 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table th:nth-child(1),
                .classic-genre-table td:nth-child(1) {
                    width: 22% !important;
                    text-align: left !important;
                }
                
                .classic-genre-table th:nth-child(2),
                .classic-genre-table td:nth-child(2),
                .classic-genre-table th:nth-child(3),
                .classic-genre-table td:nth-child(3),
                .classic-genre-table th:nth-child(4),
                .classic-genre-table td:nth-child(4) {
                    width: 14% !important;
                }
                
                .classic-genre-table th:nth-child(5),
                .classic-genre-table td:nth-child(5) {
                    width: 15% !important;
                }
                
                .classic-genre-table th:nth-child(6),
                .classic-genre-table td:nth-child(6) {
                    width: 21% !important;
                }
                
                .classic-genre-table td .icon,
                .classic-genre-table td i,
                .classic-genre-table td svg {
                    width: 12px !important;
                    height: 12px !important;
                    font-size: 12px !important;
                }
                
                .classic-genre-table .metric-severity {
                    font-size: 9px !important;
                    font-weight: 600 !important;
                }
                
                .classic-genre-table .metric-action {
                    font-size: 9px !important;
                }
                
                .classic-genre-table .metric-diff {
                    font-size: 9px !important;
                }
                
                .genre-comparison-classic .card-title {
                    font-size: 13px !important;
                    padding: 8px 0 !important;
                }
            }
        `;
        document.head.appendChild(style);
        console.log('[GENRE-TABLE] ğŸ¨ Estilos CSS injetados');
    }
    
    console.log('[GENRE-TABLE] âœ… Tabela COMPLETA renderizada:', {
        metricas: metricsCount,
        bandas: bandsCount,
        totalLinhas: rows.length
    });
    console.groupEnd();
}

// ğŸ¯ NOVO: Atualizar step ativo no modo referÃªncia
function updateReferenceStep(step) {
    const steps = ['userAudio', 'referenceAudio', 'analysis'];
    const stepElements = {
        userAudio: document.getElementById('stepUserAudio'),
        referenceAudio: document.getElementById('stepReferenceAudio'),
        analysis: document.getElementById('stepAnalysis')
    };
    
    // Reset todos os steps
    Object.values(stepElements).forEach(el => {
        if (el) {
            el.classList.remove('active', 'completed');
        }
    });
    
    // Marcar steps anteriores como completed
    const currentIndex = steps.indexOf(step);
    for (let i = 0; i < currentIndex; i++) {
        const stepElement = stepElements[steps[i]];
        if (stepElement) {
            stepElement.classList.add('completed');
        }
    }
    
    // Marcar step atual como active
    const currentElement = stepElements[step];
    if (currentElement) {
        currentElement.classList.add('active');
    }
    
    referenceStepState.currentStep = step;
    
    window.logReferenceEvent('reference_step_updated', { step, currentIndex });
}

// âŒ Fechar modal de anÃ¡lise de Ã¡udio
function closeAudioModal() {
    __dbg('âŒ Fechando modal de anÃ¡lise de Ã¡udio...');
    
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        currentModalAnalysis = null;
        resetModalState();
        
        // ğŸ”§ CORREÃ‡ÃƒO: Garantir que o modal pode ser usado novamente
        // Limpar cache de arquivos para forÃ§ar novo processamento
        const fileInput = document.getElementById('modalAudioFileInput');
        if (fileInput) {
            fileInput.value = ''; // Limpar input para permitir re-seleÃ§Ã£o do mesmo arquivo
        }
        
        // Resetar flags globais para prÃ³xima anÃ¡lise
        if (typeof window !== 'undefined') {
            delete window.__AUDIO_ADVANCED_READY__;
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        
        // ğŸ”§ FIX: Verificar se hÃ¡ comparaÃ§Ã£o ativa antes de limpar
        const hasActiveComparison = window.__referenceComparisonActive === true;
        
        if (!hasActiveComparison) {
            // ğŸ§¹ LIMPEZA COMPLETA: Apenas se nÃ£o houver comparaÃ§Ã£o ativa
            // ğŸ”’ HARD-GUARD: Limpar FirstAnalysisStore (Ãºnica fonte de verdade)
            FirstAnalysisStore.clear();
            
            // âŒ REMOVER: window.referenceAnalysisData agora Ã© read-only (nÃ£o pode ser setado)
            // Ele sempre aponta para FirstAnalysisStore.get(), que acabamos de limpar
            
            referenceComparisonMetrics = null;
            window.lastReferenceJobId = null;
            
            // Limpar IDs de referÃªncia
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            
            console.log('[CLEANUP] closeAudioModal: LIMPEZA TOTAL (sem comparaÃ§Ã£o ativa)');
            console.log('[CLEANUP] FirstAnalysisStore limpo - window.referenceAnalysisData agora retorna null');
        } else {
            // Preservar dados de referÃªncia
            console.log('[CLEANUP] closeAudioModal: PRESERVANDO referÃªncia (comparaÃ§Ã£o ativa)');
            console.log('[CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
            console.log('[CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
        }
        
        // Limpeza de state global (sempre limpar estado temporÃ¡rio de renderizaÃ§Ã£o)
        const state = window.__soundyState || {};
        if (state.reference) {
            state.reference.analysis = null;
            state.reference.isSecondTrack = false;
            // NÃƒO limpar jobId se houver comparaÃ§Ã£o ativa
            if (!hasActiveComparison) {
                state.reference.jobId = null;
                state.reference.userAnalysis = null;
                state.reference.referenceAnalysis = null;
            }
        }
        
        // Limpar anÃ¡lises temporÃ¡rias mas preservar previousAnalysis se necessÃ¡rio
        state.userAnalysis = null;
        state.referenceAnalysis = null;
        if (!hasActiveComparison) {
            state.previousAnalysis = null;
        }
        
        state.render = state.render || {};
        state.render.mode = null;
        
        window.__soundyState = state;
        
        __dbg('âœ… Modal resetado e pronto para prÃ³xima anÃ¡lise');
    }
}

// ğŸ”„ Reset estado do modal
/**
 * ğŸ†• NOVA FUNÃ‡ÃƒO: Limpa APENAS estado visual de upload
 * NÃƒO toca em gÃªnero, targets ou localStorage
 * Usada ao abrir modal de anÃ¡lise (preserva seleÃ§Ã£o de gÃªnero)
 */
function clearAudioOnlyState() {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    const fileInput = document.getElementById('modalAudioFileInput');

    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    if (fileInput) fileInput.value = '';

    console.log('[AUDIO-RESET] âœ… Apenas estado de Ã¡udio foi limpo (gÃªnero preservado)');
    console.log('[AUDIO-RESET] ğŸ“Š GÃªnero mantido:', {
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE,
        __CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        hasTargets: !!window.__activeRefData
    });
}

function resetModalState() {
    __dbg('ğŸ”„ Resetando estado do modal...');
    
    // ğŸ”’ PATCH: PRESERVAR GÃŠNERO ANTES DE QUALQUER OPERAÃ‡ÃƒO
    preserveGenreState();
    
    // ===============================================================
    // ğŸ”’ BLOCO 1 â€” PRESERVAR GÃŠNERO ANTES DO RESET
    // ===============================================================
    let __PRESERVED_GENRE__ = null;
    let __PRESERVED_TARGETS__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ =
            window.__CURRENT_SELECTED_GENRE ||
            window.PROD_AI_REF_GENRE ||
            (genreSelect ? genreSelect.value : null);
        
        __PRESERVED_TARGETS__ =
            window.__CURRENT_GENRE_TARGETS ||
            window.currentGenreTargets ||
            window.__activeRefData?.targets;

        console.log("[SAFE-RESET] âš ï¸ Preservando gÃªnero selecionado:", __PRESERVED_GENRE__);
        console.log("[SAFE-RESET] âš ï¸ Preservando targets:", __PRESERVED_TARGETS__ ? Object.keys(__PRESERVED_TARGETS__) : 'null');
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao capturar gÃªnero antes do reset:", e);
    }
    
    // Mostrar Ã¡rea de upload
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    // Reset progress
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    currentModalAnalysis = null;
    
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';
    
    // ğŸ§© CORREÃ‡ÃƒO #4: Reset completo de estado (limpeza total)
    const state = window.__soundyState || {};
    
    // Limpar completamente estado de referÃªncia
    state.reference = null;
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    // Limpar modo de renderizaÃ§Ã£o
    if (!state.render) state.render = {};
    state.render.mode = null;
    
    window.__soundyState = state;
    
    // ğŸ”¥ FIX-REFERENCE: Verificar se estamos aguardando segunda mÃºsica ANTES de limpar
    const isAwaitingSecondTrack = currentAnalysisMode === 'reference' && window.__REFERENCE_JOB_ID__;
    
    console.log('[FIX_REFID_RESET] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`[FIX_REFID_RESET] Mode atual: ${currentAnalysisMode}`);
    console.log(`[FIX_REFID_RESET] Reference Job ID existe: ${window.__REFERENCE_JOB_ID__ ? 'SIM' : 'NÃƒO'}`);
    console.log(`[FIX_REFID_RESET] Aguardando segunda mÃºsica: ${isAwaitingSecondTrack ? 'SIM' : 'NÃƒO'}`);

    if (!isAwaitingSecondTrack) {
        // ğŸ§¼ LIMPEZA COMPLETA: SÃ³ limpar se NÃƒO estivermos aguardando segunda mÃºsica
        window.__REFERENCE_JOB_ID__ = null;
        window.referenceComparisonMetrics = null;
        window.lastReferenceJobId = null;
        delete window.__REFERENCE_JOB_ID__;
        localStorage.removeItem('referenceJobId');
        
        // âœ… LIMPAR FirstAnalysisStore
        FirstAnalysisStore.clear();
        
        console.log('[FIX_REFID_RESET] Estado limpo completamente âœ…');
        console.log('[FIX_REFID_RESET] Limpeza incluiu: window, localStorage e estado global');
        console.log('[FIX_REFID_RESET] Flags de referÃªncia LIMPAS (modo nÃ£o-reference)');
    } else {
        // Preservar IDs de referÃªncia para segunda mÃºsica
        console.log('[FIX_REFID_RESET] âš ï¸ PRESERVANDO flags de referÃªncia!');
        console.log(`[FIX_REFID_RESET] Reference Job ID mantido: ${window.__REFERENCE_JOB_ID__}`);
        console.log(`[FIX_REFID_RESET] localStorage.referenceJobId: ${localStorage.getItem('referenceJobId')}`);
        console.log('[FIX_REFID_RESET] Aguardando upload da segunda mÃºsica...');
    }
    console.log('[FIX_REFID_RESET] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    // Flags internas
    delete window.__AUDIO_ADVANCED_READY__;
    delete window.__MODAL_ANALYSIS_IN_PROGRESS__;    console.log('[CLEANUP] resetModalState: estado global/flags limpos');
    
    // ===============================================================
    // ğŸ”’ BLOCO 3 â€” RESTAURAR GÃŠNERO E TARGETS APÃ“S O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            console.log("[SAFE-RESET] âœ… GÃªnero restaurado apÃ³s reset:", __PRESERVED_GENRE__);
        } else {
            console.warn("[SAFE-RESET] âš ï¸ Nenhum gÃªnero vÃ¡lido preservado.");
        }
        
        // ğŸ”’ PATCH: RESTAURAR TARGETS TAMBÃ‰M
        if (__PRESERVED_TARGETS__) {
            window.__CURRENT_GENRE_TARGETS = __PRESERVED_TARGETS__;
            window.currentGenreTargets = __PRESERVED_TARGETS__;
            console.log("[SAFE-RESET] âœ… Targets restaurados apÃ³s reset:", Object.keys(__PRESERVED_TARGETS__));
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar gÃªnero:", e);
    }
    
    __dbg('âœ… Estado do modal resetado completamente');
}

// âš™ï¸ Configurar modal de Ã¡udio
function setupAudioModal() {
    const modal = document.getElementById('audioAnalysisModal');
    const fileInput = document.getElementById('modalAudioFileInput');
    const uploadArea = document.getElementById('audioUploadArea');
    
    if (!modal || !fileInput || !uploadArea) {
        __dwrn('âš ï¸ Elementos do modal nÃ£o encontrados');
        return;
    }
    
    // Fechar modal clicando fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeAudioModal();
        }
    });
    
    // Fechar modal com ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeAudioModal();
        }
    });
    
    // Detectar se Ã© dispositivo mÃ³vel
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (!isMobile) {
        // Drag and Drop (apenas para desktop)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleModalFileSelection(files[0]);
            }
        });
    }
    
    // File input change event
    fileInput.addEventListener('change', (e) => {
        __dbg('ğŸ“ File input change triggered');
        if (e.target.files.length > 0) {
            __dbg('ğŸ“ File selected:', e.target.files[0].name);
            handleModalFileSelection(e.target.files[0]);
        }
    });
    
    // NÃ£o adicionar nenhum listener JS ao botÃ£o/label de upload!
    uploadArea.onclick = null;
    
    __dbg('âœ… Modal de Ã¡udio configurado com sucesso');
}

// ğŸ“ Processar arquivo selecionado no modal
async function handleModalFileSelection(file) {
    __dbg('ğŸ“ Arquivo selecionado no modal:', file.name);
    
    // ========================================
    // ğŸ”’ DECLARAÃ‡ÃƒO DE ESCOPO GLOBAL: normalizedFirst
    // ========================================
    // Garantir que normalizedFirst sempre exista no escopo da funÃ§Ã£o
    let normalizedFirst = window.__FIRST_ANALYSIS_FROZEN__ 
        ? structuredClone(window.__FIRST_ANALYSIS_FROZEN__) 
        : null;
    
    // ğŸ”§ CORREÃ‡ÃƒO: Prevenir mÃºltiplas anÃ¡lises simultÃ¢neas
    if (typeof window !== 'undefined' && window.__MODAL_ANALYSIS_IN_PROGRESS__) {
        __dbg('âš ï¸ AnÃ¡lise jÃ¡ em progresso, ignorando nova seleÃ§Ã£o');
        return;
    }
    
    try {
        // Marcar anÃ¡lise em progresso
        if (typeof window !== 'undefined') {
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = true;
        }
        
        // ValidaÃ§Ã£o comum de arquivo
        if (!validateAudioFile(file)) {
            return; // validateAudioFile jÃ¡ mostra erro
        }
        
        // ğŸŒ NOVO FLUXO COMPLETO: Presigned URL â†’ Upload â†’ Job Creation â†’ Polling
        __dbg('ğŸŒ Iniciando fluxo de anÃ¡lise remota completo...');
        
        // Mostrar loading
        hideUploadArea();
        showAnalysisLoading();
        showUploadProgress(`Preparando upload de ${file.name}...`);
        
        // ğŸŒ ETAPA 1: Obter URL prÃ©-assinada
        const { uploadUrl, fileKey } = await getPresignedUrl(file);
        
        // ğŸŒ ETAPA 2: Upload direto para bucket
        await uploadToBucket(uploadUrl, file);
        
        // ğŸŒ ETAPA 3: Criar job de anÃ¡lise no backend
        const { jobId } = await createAnalysisJob(fileKey, currentAnalysisMode, file.name);
        
        // ğŸŒ ETAPA 4: Acompanhar progresso e aguardar resultado
        showUploadProgress(`Analisando ${file.name}... Aguarde.`);
        const analysisResult = await pollJobStatus(jobId);
        
        // ğŸŒ ETAPA 5: Processar resultado baseado no modo e contexto
        // ğŸ¯ FLUXO CORRIGIDO: Identificar se Ã© primeira ou segunda mÃºsica
        const jobMode = analysisResult.mode || currentAnalysisMode;
        const isSecondTrack = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
        
        // ğŸ” AUDITORIA: Estado ANTES de processar resultado
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ“Œ handleModalFileSelection - INÃCIO');
        console.log('âš™ï¸ FunÃ§Ã£o: handleModalFileSelection');
        console.log('ğŸ“ Arquivo:', file.name);
        console.log('ğŸ¯ Modo atual:', currentAnalysisMode);
        console.log('ğŸ”‘ jobId retornado:', jobId);
        console.log('ğŸ“Š analysisResult recebido:', {
            jobId: analysisResult?.jobId,
            fileName: analysisResult?.fileName || analysisResult?.metadata?.fileName,
            lufs: analysisResult?.technicalData?.lufsIntegrated,
            mode: analysisResult?.mode
        });
        console.log('ğŸŒ Estado global ANTES de processar:');
        console.log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        const firstAnalysis = FirstAnalysisStore.get();
        console.log('  FirstAnalysisStore:', firstAnalysis ? {
            fileName: firstAnalysis?.fileName || firstAnalysis?.metadata?.fileName,
            jobId: firstAnalysis?.jobId
        } : 'null');
        console.log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
            fileName: window.__soundyState.previousAnalysis?.fileName || window.__soundyState.previousAnalysis?.metadata?.fileName,
            jobId: window.__soundyState.previousAnalysis?.jobId
        } : 'null');
        console.groupEnd();
        
        console.log('[AUDIO-DEBUG] ğŸ¯ Modo do job:', jobMode);
        console.log('[AUDIO-DEBUG] ğŸ¯ Ã‰ segunda faixa?', isSecondTrack);
        console.log('[AUDIO-DEBUG] ğŸ¯ Reference Job ID armazenado:', window.__REFERENCE_JOB_ID__);
        console.log('[AUDIO-DEBUG] ğŸ¯ FirstAnalysisStore:', FirstAnalysisStore.has());
        console.log('[AUDIO-DEBUG] ğŸ¯ Current mode:', currentAnalysisMode);
        
        // ğŸ”§ FIX: Primeira mÃºsica vem como "genre" (modo base), segunda como "reference"
        const isFirstReferenceTrack = currentAnalysisMode === 'reference' && !isSecondTrack;
        
        if (isFirstReferenceTrack) {
            // PRIMEIRA mÃºsica em modo reference: abrir modal para mÃºsica de referÃªncia
            __dbg('ğŸ¯ Primeira mÃºsica analisada - abrindo modal para segunda');
            
            // ========================================
            // ğŸ”’ SALVAR PRIMEIRA ANÃLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel USER
            const { vid: userVid, clone: userClone } = cacheResultByRole(analysisResult, { isSecondTrack: false });
            
            // ğŸ’¾ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveFirstAnalysis(userClone || analysisResult);
            
            // Atualizar normalizedFirst para uso nos logs e modal
            if (!normalizedFirst && userClone) {
                normalizedFirst = userClone;
                window.__FIRST_ANALYSIS_FROZEN__ = structuredClone(normalizedFirst); // Mantido para compatibilidade
                console.log('[SCOPE] âœ… normalizedFirst inicializado com userClone');
            }
            
            if (!window.FirstAnalysisStore?.has()) {
                // Salvar como USER no FirstAnalysisStore
                FirstAnalysisStore.setUser(userClone, userVid, analysisResult.jobId);
                window.__REFERENCE_JOB_ID__ = analysisResult.jobId;
                
                console.log('[A/B] ğŸ§Š primeira faixa salva com VID', {
                    vid: userVid,
                    jobId: analysisResult.jobId, 
                    file: userClone?.fileName || userClone?.metadata?.fileName,
                    role: 'USER'
                });
            }
            
            // ğŸ” AUDITORIA: Estado APÃ“S salvar primeira anÃ¡lise
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ’¾ Primeira AnÃ¡lise SALVA');
            console.log('âš™ï¸ Contexto: Salvamento da primeira faixa');
            console.log('ğŸ“Š analysisResult (original):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const storedFirst = FirstAnalysisStore.get();
            console.log('ğŸ”’ FirstAnalysisStore (clone):', {
                jobId: storedFirst?.jobId,
                fileName: storedFirst?.metadata?.fileName || storedFirst?.fileName,
                lufs: storedFirst?.technicalData?.lufsIntegrated,
                sameAsOriginal: false // sempre retorna clone
            });
            console.log('ğŸ’¡ VerificaÃ§Ã£o de isolamento:');
            console.log('  FirstAnalysisStore.get() !== analysisResult?', storedFirst !== analysisResult);
            console.log('  FirstAnalysisStore retorna clones:', true);
            console.groupEnd();
            
            // ========================================
            // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO: Garantir que normalizedFirst existe
            // ========================================
            if (!normalizedFirst) {
                console.warn('[WARN] normalizedFirst ausente â€” usando fallback do FirstAnalysisStore.');
                normalizedFirst = structuredClone(FirstAnalysisStore.getUser() || {});
            }
            
            console.log('[REF-SAVE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('[REF-SAVE âœ…] Primeira mÃºsica processada com sucesso!');
            console.log(`[REF-SAVE âœ…] Job ID salvo globalmente: ${normalizedFirst?.jobId || 'unknown'}`);
            console.log('[REF-SAVE âœ…] Locais de salvamento:');
            console.log('[REF-SAVE âœ…]   - window.__REFERENCE_JOB_ID__');
            console.log('[REF-SAVE âœ…]   - localStorage.referenceJobId');
            console.log('[REF-SAVE âœ…]   - window.AnalysisCache (imutÃ¡vel)');
            console.log('[REF-SAVE âœ…]   - window.FirstAnalysisStore (imutÃ¡vel + clonagem automÃ¡tica)');
            console.log(`[REF-SAVE âœ…] File Name: ${normalizedFirst?.metadata?.fileName || normalizedFirst?.fileName || 'unknown'}`);
            console.log(`[REF-SAVE âœ…] LUFS: ${normalizedFirst?.technicalData?.lufsIntegrated || 'N/A'} LUFS`);
            console.log(`[REF-SAVE âœ…] DR: ${normalizedFirst?.technicalData?.dynamicRange || 'N/A'} dB`);
            console.log('[REF-SAVE âœ…] Este ID serÃ¡ usado na segunda mÃºsica');
            console.log('[REF-SAVE âœ…] Primeira anÃ¡lise salva e congelada.');
            console.log('[REF-SAVE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            if (normalizedFirst && normalizedFirst.jobId) {
                openReferenceUploadModal(normalizedFirst.jobId, normalizedFirst);
            } else {
                console.error('[ERROR] âŒ NÃ£o foi possÃ­vel abrir modal: normalizedFirst invÃ¡lido');
            }
        } else if (isSecondTrack) {
            // ğŸ”¥ FORÃ‡AR: Se tem jobId de referÃªncia, SEMPRE tratar como segunda track
            console.log('ğŸŸ¢ğŸŸ¢ğŸŸ¢ [SEGUNDA-TRACK-DETECTADA-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸŸ¢ [FORCE] isSecondTrack TRUE - entrando em bloco A/B');
            console.log('ğŸŸ¢ [FORCE] jobMode (pode ser null):', jobMode);
            console.log('ğŸŸ¢ [FORCE] currentAnalysisMode (pode ser genre):', currentAnalysisMode);
            console.log('ğŸŸ¢ [FORCE] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('ğŸŸ¢ [FORCE] IGNORANDO jobMode - usando APENAS isSecondTrack como critÃ©rio');
            console.log('ğŸŸ¢ğŸŸ¢ğŸŸ¢ [SEGUNDA-TRACK-DETECTADA-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            // SEGUNDA mÃºsica em modo reference: mostrar resultado comparativo
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] âœ… Sistema ENTROU no bloco de segunda track!');
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] jobMode:', jobMode);
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] currentAnalysisMode:', currentAnalysisMode);
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] isSecondTrack:', isSecondTrack);
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] analysisResult.jobId:', analysisResult?.jobId);
            console.log('ğŸŸ¢ [SEGUNDA-TRACK] Aguardando processamento... (se nÃ£o aparecer erro abaixo, fluxo estÃ¡ correto)');
            console.log('ğŸŸ¢ğŸŸ¢ğŸŸ¢ [SEGUNDA-TRACK-DETECTADA] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ¯ [COMPARE-MODE] Segunda mÃºsica analisada - exibindo comparaÃ§Ã£o entre faixas');
            console.log('âœ… [COMPARE-MODE] Tabela comparativa serÃ¡ exibida');
            console.log(`âœ… [COMPARE-MODE] jobMode: ${jobMode}, currentMode: ${currentAnalysisMode}, isSecond: ${isSecondTrack}`);
            __dbg('ğŸ¯ Segunda mÃºsica analisada - exibindo resultado comparativo');
            
            // ========================================
            // ğŸ”’ SALVAR SEGUNDA ANÃLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel REF
            const { vid: refVid, clone: refClone } = cacheResultByRole(analysisResult, { isSecondTrack: true });
            
            // ğŸ’¾ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveSecondAnalysis(refClone || analysisResult);
            
            // Salvar como REF no FirstAnalysisStore (mantido para compatibilidade)
            FirstAnalysisStore.setRef(refClone, refVid, analysisResult.jobId);
            
            console.log('[A/B] ğŸ§Š segunda faixa salva com VID', {
                vid: refVid,
                jobId: analysisResult.jobId,
                file: refClone?.fileName || refClone?.metadata?.fileName,
                role: 'REF'
            });
            
            // ï¿½ AUDITORIA: Estado ANTES de construir estrutura A/B
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ¯ Segunda AnÃ¡lise RECEBIDA');
            console.log('âš™ï¸ Contexto: RecepÃ§Ã£o da segunda faixa');
            console.log('ğŸ“Š analysisResult (2Âª faixa):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const frozenFirst = FirstAnalysisStore.get();
            console.log('ğŸ”’ FirstAnalysisStore (1Âª faixa congelada):', {
                jobId: frozenFirst?.jobId,
                fileName: frozenFirst?.metadata?.fileName,
                lufs: frozenFirst?.technicalData?.lufsIntegrated
            });
            console.log('ğŸ’¾ window.__soundyState.previousAnalysis (1Âª faixa):', {
                jobId: window.__soundyState?.previousAnalysis?.jobId,
                fileName: window.__soundyState?.previousAnalysis?.metadata?.fileName,
                lufs: window.__soundyState?.previousAnalysis?.technicalData?.lufsIntegrated,
                objectId: window.__soundyState?.previousAnalysis
            });
            console.log('âš ï¸ CHECKPOINT CRÃTICO: Verificar se objetos sÃ£o distintos');
            console.log('  analysisResult !== previousAnalysis?', analysisResult !== window.__soundyState?.previousAnalysis);
            console.log('  analysisResult !== FirstAnalysisStore?', analysisResult !== FirstAnalysisStore.get());
            console.groupEnd();
            
            // ï¿½ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Primeira mÃºsica Ã© ATUAL (sua faixa), segunda Ã© REFERÃŠNCIA (alvo)
            const state = window.__soundyState || {};
            
            // ğŸ§Š PROTEÃ‡ÃƒO ANTIFALSA ATUALIZAÃ‡ÃƒO DA REFERÃŠNCIA
            if (state?.render?.mode === 'reference' && window.__FIRST_ANALYSIS_FROZEN__) {
                console.warn('[STATE-FIX] ğŸ”’ Bloqueando sobrescrita de referÃªncia - usando cÃ³pia congelada');
                console.warn('[STATE-FIX]   __FIRST_ANALYSIS_FROZEN__:', window.__FIRST_ANALYSIS_FROZEN__?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
                console.warn('[STATE-FIX]   analysisResult (2Âª faixa):', analysisResult?.fileName || analysisResult?.metadata?.fileName);
                
                // Garantir que previousAnalysis aponte para o frozen
                if (!state.previousAnalysis || state.previousAnalysis.jobId === analysisResult.jobId) {
                    console.warn('[STATE-FIX] âš ï¸ Corrigindo previousAnalysis contaminado');
                    state.previousAnalysis = JSON.parse(JSON.stringify(window.__FIRST_ANALYSIS_FROZEN__));
                }
            }
            
            if (state.previousAnalysis) {
                // âœ… SEMÃ‚NTICA CORRETA DO FLUXO A/B:
                // - Primeira faixa (previousAnalysis) = userAnalysis (SUA MÃšSICA/ATUAL)
                // - Segunda faixa (analysisResult) = referenceAnalysis (ALVO/REFERÃŠNCIA a alcanÃ§ar)
                
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone obrigatÃ³rio
                console.log('[STATE-FIX] ğŸ”’ Criando deep clones para evitar contaminaÃ§Ã£o de estado');
                state.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));      // 1Âª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));         // 2Âª = faixa de referÃªncia (alvo)
                
                // ğŸ¯ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));    // 1Âª faixa (sua mÃºsica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));       // 2Âª faixa (referÃªncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ… [REFERENCE-A/B-CORRECTED] AtribuiÃ§Ã£o correta A/B:');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª Faixa (ATUAL/SUA MÃšSICA):', state.previousAnalysis.fileName || state.previousAnalysis.metadata?.fileName || '1Âª Faixa');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª Faixa (REFERÃŠNCIA/ALVO):', analysisResult.fileName || analysisResult.metadata?.fileName || '2Âª Faixa');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   ComparaÃ§Ã£o: SUA MÃšSICA vs REFERÃŠNCIA');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   Modal mostrarÃ¡: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª tem bandas:', !!state.userAnalysis?.technicalData?.spectral_balance);
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª tem bandas:', !!state.referenceAnalysis?.technicalData?.spectral_balance);
                console.log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // ğŸ” AUDITORIA: Estado APÃ“S construir estrutura A/B
                console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ”§ Estrutura A/B CONSTRUÃDA');
                console.log('âš™ï¸ Contexto: Estrutura state.reference montada');
                console.log('ğŸ“Š state.userAnalysis (1Âª faixa - SUA MÃšSICA):', {
                    jobId: state.userAnalysis?.jobId,
                    fileName: state.userAnalysis?.metadata?.fileName || state.userAnalysis?.fileName,
                    lufs: state.userAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.userAnalysis
                });
                console.log('ğŸ“Š state.referenceAnalysis (2Âª faixa - REFERÃŠNCIA):', {
                    jobId: state.referenceAnalysis?.jobId,
                    fileName: state.referenceAnalysis?.metadata?.fileName || state.referenceAnalysis?.fileName,
                    lufs: state.referenceAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.referenceAnalysis
                });
                console.log('âš ï¸ VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
                console.log('  state.userAnalysis === state.referenceAnalysis?', state.userAnalysis === state.referenceAnalysis);
                console.log('  state.userAnalysis === analysisResult?', state.userAnalysis === analysisResult);
                console.log('  state.userAnalysis === state.previousAnalysis?', state.userAnalysis === state.previousAnalysis);
                console.log('  state.referenceAnalysis === analysisResult?', state.referenceAnalysis === analysisResult);
                console.log('ğŸ’¡ PrÃ³ximo passo: Normalizar analysisResult antes de enviar para displayModalResults');
                console.groupEnd();
                
                // ğŸ¯ LOG AUDIT-MODE-FLOW (conforme solicitado)
                console.log('[AUDIT-MODE-FLOW]', {
                    mode: 'reference',
                    isSecondTrack: state.reference.isSecondTrack,
                    refJobId: state.reference.jobId,
                    hasUserAnalysis: !!state.userAnalysis,
                    hasReferenceAnalysis: !!state.referenceAnalysis
                });
                
                // ğŸ¯ LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            } else if (FirstAnalysisStore.has()) {
                // ğŸ”¥ FALLBACK: Primeira mÃºsica Ã© ATUAL (sua faixa), segunda Ã© REFERÃŠNCIA (alvo)
                const firstAnalysis = FirstAnalysisStore.get(); // sempre clone
                
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone obrigatÃ³rio
                console.log('[STATE-FIX] ğŸ”’ FALLBACK - Criando deep clones para evitar contaminaÃ§Ã£o');
                state.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));    // 1Âª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                 // 2Âª = referÃªncia (alvo)
                
                // ğŸ¯ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));  // 1Âª faixa (sua mÃºsica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                // 2Âª faixa (referÃªncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ… [REFERENCE-A/B-CORRECTED] Fallback - AtribuiÃ§Ã£o correta A/B:');
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª Faixa (ATUAL/SUA MÃšSICA):', firstAnalysis?.fileName);
                console.log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª Faixa (REFERÃŠNCIA/ALVO):', analysisResult.fileName);
                console.log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // ğŸ¯ LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userTrack: state.userAnalysis?.fileName || 'Sua mÃºsica (atual)',
                    referenceTrack: state.referenceAnalysis?.fileName || 'Faixa de referÃªncia (alvo)',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            }
            
            // ğŸš¨ AUDIT_REF_FIX: NÃƒO chamar handleGenreAnalysisWithResult em modo reference!
            // Esta funÃ§Ã£o limpa o estado e forÃ§a mode='genre', quebrando o fluxo A/B
            
            // PRESERVAR modo reference atÃ© o final (reutilizar state jÃ¡ declarado acima)
            if (!state.render) state.render = {};
            state.render.mode = 'reference';
            window.__soundyState = state;
            
            console.log('[AUDIT_REF_FIX] Preservando modo reference atÃ© final da renderizaÃ§Ã£o');
            console.log('[MODE LOCKED] reference - handleGenreAnalysisWithResult PULADO');
            
            // ğŸ” AUDITORIA: Estado ANTES de normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] âš™ï¸ ANTES de normalizeBackendAnalysisData');
            console.log('âš™ï¸ Contexto: Prestes a normalizar analysisResult (2Âª faixa)');
            console.log('ğŸ“Š analysisResult (ANTES de normalizar):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const checkFirst = FirstAnalysisStore.get();
            console.log('ğŸ”’ FirstAnalysisStore (NÃƒO deve mudar):', {
                jobId: checkFirst?.jobId,
                fileName: checkFirst?.metadata?.fileName,
                lufs: checkFirst?.technicalData?.lufsIntegrated
            });
            console.log('âš ï¸ PONTO CRÃTICO: normalizeBackendAnalysisData() vai modificar analysisResult?');
            console.groupEnd();
            
            // Normalizar dados do backend
            const normalizedResult = normalizeBackendAnalysisData(analysisResult);
            
            // ï¿½ POPULAR CACHE COM RESULTADO NORMALIZADO
            AnalysisCache.put(normalizedResult);
            
            // ï¿½ğŸ” AUDITORIA: Estado APÃ“S normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS de normalizeBackendAnalysisData');
            console.log('âš™ï¸ Contexto: NormalizaÃ§Ã£o concluÃ­da');
            console.log('ğŸ“Š normalizedResult (resultado da normalizaÃ§Ã£o):', {
                jobId: normalizedResult?.jobId,
                fileName: normalizedResult?.metadata?.fileName || normalizedResult?.fileName,
                lufs: normalizedResult?.technicalData?.lufsIntegrated,
                objectId: normalizedResult,
                sameAsOriginal: normalizedResult === analysisResult
            });
            console.log('ğŸ“Š analysisResult (APÃ“S normalizaÃ§Ã£o - pode ter mudado?):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            console.log('ğŸ”’ window.__FIRST_ANALYSIS_FROZEN__ (deve estar INTACTO):', {
                jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
                fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
                lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
                isFrozen: Object.isFrozen(window.__FIRST_ANALYSIS_FROZEN__)
            });
            console.log('ğŸ’¡ PrÃ³ximo: Enviar normalizedResult para displayModalResults()');
            console.groupEnd();
            
            // ï¿½ PARTE 3.4: Garantir atribuiÃ§Ã£o correta ANTES de displayModalResults
            // ğŸ”§ PARTE 1: Normalize reference comparison structure
            if (state.render.mode === "reference" && analysisResult && state.previousAnalysis) {
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone para evitar mutaÃ§Ã£o
                console.log('[STATE-FIX] ğŸ”’ Normalizando com deep clones');
                const firstResult = JSON.parse(JSON.stringify(state.previousAnalysis));
                const secondResult = JSON.parse(JSON.stringify(analysisResult));

                const normalizedUser = {
                    fileName: firstResult.fileName || firstResult.metadata?.fileName,
                    bands: firstResult.spectralBands || firstResult.bands || firstResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: firstResult.loudness?.integrated ?? firstResult.lufsIntegrated,
                        dr: firstResult.dynamics?.dr ?? firstResult.dynamicRange,
                        peak: firstResult.truePeak?.dbtp ?? firstResult.truePeakDbtp
                    }
                };

                const normalizedRef = {
                    fileName: secondResult.fileName || secondResult.metadata?.fileName,
                    bands: secondResult.spectralBands || secondResult.bands || secondResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: secondResult.loudness?.integrated ?? secondResult.lufsIntegrated,
                        dr: secondResult.dynamics?.dr ?? secondResult.dynamicRange,
                        peak: secondResult.truePeak?.dbtp ?? secondResult.truePeakDbtp
                    }
                };

                // ğŸ§Š PROTEÃ‡ÃƒO: Usar deep clone para state.reference
                state.reference = {
                    mode: "reference",
                    isSecondTrack: true,
                    userAnalysis: JSON.parse(JSON.stringify(normalizedUser)),
                    referenceAnalysis: JSON.parse(JSON.stringify(normalizedRef)),
                    analysis: {
                        bands: JSON.parse(JSON.stringify(normalizedRef.bands))
                    }
                };

                state.render.mode = 'reference';
                window.__soundyState = state;
                console.log("[REF-FIX] Estrutura final corrigida", state.reference);
            }
            
            // ğŸ”¥ FORCE MODE REFERENCE EXPLICITAMENTE ANTES DE displayModalResults
            state.render = state.render || {};
            state.render.mode = 'reference';
            currentAnalysisMode = 'reference';
            window.__soundyState = state;
            
            console.log('ğŸ”¥ğŸ”¥ğŸ”¥ [MODE-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ”¥ [MODE-FORCE] âœ… Modo FORÃ‡ADO para reference antes de displayModalResults');
            console.log('ğŸ”¥ [MODE-FORCE] state.render.mode:', state.render.mode);
            console.log('ğŸ”¥ [MODE-FORCE] currentAnalysisMode:', currentAnalysisMode);
            console.log('ğŸ”¥ [MODE-FORCE] window.__soundyState.render.mode:', window.__soundyState.render.mode);
            console.log('ğŸ”¥ğŸ”¥ğŸ”¥ [MODE-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ”¥ CORREÃ‡ÃƒO: Preparar dados para comparaÃ§Ã£o A/B correta
            console.log('[REFERENCE-FLOW] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('[REFERENCE-FLOW] Segunda mÃºsica concluÃ­da - montando comparaÃ§Ã£o A/B');
            
            // ï¿½ PASSO 2: ATIVAR PROTEÃ‡ÃƒO DE CURRENTJOBID
            const currentJobId = normalizedResult?.jobId || analysisResult?.jobId;
            // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager
            const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
            
            if (currentJobId) {
                console.log('ğŸ”’ [PROTECTION] Ativando proteÃ§Ã£o para currentJobId:', currentJobId);
                console.log('ğŸ” [PROTECTION] ReferenceJobId:', referenceJobId);
                
                // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que jobIds sÃ£o DIFERENTES
                if (currentJobId === referenceJobId) {
                    console.error('âŒ [MODAL-FILE] ERRO CRÃTICO: Backend retornou mesmo jobId!');
                    console.error('   currentJobId:', currentJobId);
                    console.error('   referenceJobId:', referenceJobId);
                    console.trace();
                    alert('ERRO: O backend retornou o mesmo jobId da primeira mÃºsica. Tente novamente.');
                    return;
                }
                
                console.log('âœ… [MODAL-FILE] Segunda mÃºsica analisada:');
                console.log('   Novo currentJobId:', currentJobId);
                console.log('   ReferenceJobId:', referenceJobId);
                console.log('   SÃ£o diferentes?', currentJobId !== referenceJobId ? 'âœ… SIM' : 'âŒ NÃƒO');
                
                // Salvar em mÃºltiplas camadas de proteÃ§Ã£o
                window.__CURRENT_JOB_ID__ = currentJobId;
                sessionStorage.setItem('currentJobId', currentJobId);
                
                protectCurrentJobId(currentJobId);
                console.log('âœ… [PROTECTION] ProteÃ§Ã£o ativada - currentJobId protegido contra contaminaÃ§Ã£o');
                console.log('âœ… [PROTECTION] sessionStorage.currentJobId salvo:', sessionStorage.getItem('currentJobId'));
            } else {
                console.warn('âš ï¸ [PROTECTION] currentJobId nÃ£o encontrado, proteÃ§Ã£o nÃ£o ativada');
            }
            
            // ï¿½ğŸ›¡ï¸ DEEP CLONE OBRIGATÃ“RIO: Evitar contaminaÃ§Ã£o de ponteiros que causa falso self-compare
            console.log('[DEEP-CLONE-GUARD] ğŸ”’ Clonando userAnalysis para evitar compartilhamento de metadata');
            const userAnalysis = structuredClone(state.previousAnalysis || state.userAnalysis);
            
            console.log('[DEEP-CLONE-GUARD] ğŸ”’ Clonando referenceAnalysisData para evitar compartilhamento de metadata');
            const referenceAnalysisData = structuredClone(normalizedResult || state.referenceAnalysis);
            
            // ğŸ” VALIDAÃ‡ÃƒO CRÃTICA: Confirmar que os clones sÃ£o independentes
            console.groupCollapsed('[INTEGRITY-CHECK] ğŸ”’ ValidaÃ§Ã£o de Clones Independentes');
            console.log('âœ… userAnalysis !== referenceAnalysisData?', userAnalysis !== referenceAnalysisData);
            console.log('âœ… userAnalysis.metadata !== referenceAnalysisData.metadata?', userAnalysis?.metadata !== referenceAnalysisData?.metadata);
            console.log('ğŸ“ userFileName:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('ğŸ“ refFileName:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('ğŸ†” userJobId:', userAnalysis?.jobId || userAnalysis?.id);
            console.log('ğŸ†” refJobId:', referenceAnalysisData?.jobId || referenceAnalysisData?.id);
            console.log('âš ï¸ Nomes iguais?', (userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName));
            console.log('âš ï¸ JobIds iguais?', (userAnalysis?.jobId || userAnalysis?.id) === (referenceAnalysisData?.jobId || referenceAnalysisData?.id));
            
            if ((userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName)) {
                console.error('ğŸš¨ CONTAMINAÃ‡ÃƒO DETECTADA: userFileName === refFileName!');
                console.error('ğŸš¨ Isso indica que os clones NÃƒO sÃ£o independentes ou que a fonte estÃ¡ contaminada!');
            } else {
                console.log('âœ… INTEGRIDADE CONFIRMADA: Arquivos sÃ£o diferentes');
            }
            console.groupEnd();
            
            console.log('[REFERENCE-COMPARE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('[REFERENCE-COMPARE] 1Âª FAIXA (SUA MÃšSICA):');
            console.log('[REFERENCE-COMPARE]   Nome:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!userAnalysis?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', userAnalysis?.technicalData?.spectral_balance ? 'SIM' : 'NÃƒO');
            console.log('[REFERENCE-COMPARE]   bandas:', userAnalysis?.technicalData?.spectral_balance ? Object.keys(userAnalysis.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', userAnalysis?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] 2Âª FAIXA (REFERÃŠNCIA):');
            console.log('[REFERENCE-COMPARE]   Nome:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!referenceAnalysisData?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', referenceAnalysisData?.technicalData?.spectral_balance ? 'SIM' : 'NÃƒO');
            console.log('[REFERENCE-COMPARE]   bandas:', referenceAnalysisData?.technicalData?.spectral_balance ? Object.keys(referenceAnalysisData.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', referenceAnalysisData?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Marcar no normalizedResult que Ã© modo referÃªncia com dados corretos
            normalizedResult._isReferenceMode = true;
            // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CIRCULAR: usar clone seguro para evitar loops
            normalizedResult._userAnalysis = deepCloneSafe(userAnalysis);
            normalizedResult._referenceAnalysis = deepCloneSafe(referenceAnalysisData);
            
            // ==== CHECKPOINT AUDITORIA REF-CONTAMINAÃ‡ÃƒO ====
            console.group("[AUDITORIA REF-CONTAMINAÃ‡ÃƒO]");
            console.log("ğŸŒ window.referenceAnalysisData:", window.referenceAnalysisData?.metadata?.fileName || window.referenceAnalysisData?.fileName);
            console.log("ğŸ§Š __FIRST_ANALYSIS_FROZEN__:", window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.fileName);
            console.log("ğŸ“¦ analysis.metadata.fileName:", normalizedResult?.metadata?.fileName);
            console.groupEnd();
            
            // ========================================
            // ğŸ§  OBTER PAR DE ANÃLISES DO STORE ISOLADO
            // ========================================
            console.log('[STORE-FLOW] Obtendo par de anÃ¡lises do store isolado');
            const comparisonPair = getComparisonPair();
            
            if (comparisonPair) {
                console.log('âœ… [STORE-FLOW] Par obtido com sucesso');
                console.log('   - ref.jobId:', comparisonPair.ref?.jobId);
                console.log('   - curr.jobId:', comparisonPair.curr?.jobId);
                console.log('   - ref.fileName:', comparisonPair.ref?.fileName || comparisonPair.ref?.metadata?.fileName);
                console.log('   - curr.fileName:', comparisonPair.curr?.fileName || comparisonPair.curr?.metadata?.fileName);
                
                // âœ… USAR DADOS DO STORE COMO FONTE DE VERDADE
                normalizedResult._comparisonPair = comparisonPair;
                normalizedResult._useStoreData = true;
                
                console.log('ğŸ¯ [STORE-FLOW] Dados do store anexados ao normalizedResult');
            } else {
                console.warn('âš ï¸ [STORE-FLOW] Store nÃ£o pronto, usando dados legados');
            }
            
            console.log("[SAFE-MODAL] âœ… Fluxo reference intacto, iniciando renderizaÃ§Ã£o final.");
            
            // ========================================
            // ğŸ¤– AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL
            // ========================================
            console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[AI-SYNC] ğŸ” Verificando status do enriquecimento IA...');
            console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // Verificar se aiSuggestions jÃ¡ estÃ¡ presente
            const hasAISuggestions = Array.isArray(normalizedResult.aiSuggestions) && 
                                     normalizedResult.aiSuggestions.length > 0 &&
                                     normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
            
            console.log('[AI-SYNC] ğŸ“Š Estado atual:', {
                hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
                aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
                aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
                jobId: normalizedResult.jobId
            });
            
            if (!hasAISuggestions) {
                console.log('[AI-SYNC] â³ aiSuggestions nÃ£o estÃ¡ pronto, aguardando enriquecimento...');
                
                // Mostrar spinner visual
                showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');
                
                try {
                    // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                    const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                    
                    if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                        // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                        normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        
                        console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        console.log('[AI-SYNC] âœ… Enriquecimento IA mesclado com sucesso!');
                        console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        console.log('[AI-SYNC] ğŸ“Š Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                        console.log('[AI-SYNC] ğŸ¤– Marcadas como aiEnhanced:', 
                            normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                        
                        // Atualizar cache com dados enriquecidos
                        AnalysisCache.put(normalizedResult);
                        
                    } else {
                        console.warn('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        console.warn('[AI-SYNC] âš ï¸ Enriquecimento IA nÃ£o completou a tempo');
                        console.warn('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        console.warn('[AI-SYNC] â„¹ï¸ Modal serÃ¡ exibido com sugestÃµes base');
                        console.warn('[AI-SYNC] â„¹ï¸ IA pode estar desabilitada ou sobrecarregada');
                    }
                    
                } catch (syncError) {
                    console.error('[AI-SYNC] âŒ Erro ao aguardar enriquecimento IA:', syncError);
                    console.warn('[AI-SYNC] â„¹ï¸ Continuando com sugestÃµes base...');
                } finally {
                    // Remover spinner
                    hideAILoadingSpinner();
                }
                
            } else {
                console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('[AI-SYNC] âœ… aiSuggestions jÃ¡ presente no resultado!');
                console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('[AI-SYNC] â„¹ï¸ NÃ£o Ã© necessÃ¡rio aguardar, exibindo imediatamente');
            }
            
            console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[AI-SYNC] ğŸ¬ Iniciando renderizaÃ§Ã£o do modal...');
            console.log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // ========================================
            // âœ… CORREÃ‡ÃƒO: Aguardar enriquecimento IA antes de abrir modal
            // ========================================
            if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
                console.log('[AI-SYNC] â³ Enriquecimento IA ausente â€” aguardando resposta...');
                showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');

                try {
                    const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                    if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                        normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        console.log(`[AI-SYNC] âœ… SugestÃµes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                    } else {
                        console.warn('[AI-SYNC] âš ï¸ Timeout ou IA nÃ£o retornou sugestÃµes vÃ¡lidas. Fallback para sugestÃµes base.');
                    }
                } catch (error) {
                    console.error('[AI-SYNC] âŒ Erro ao aguardar sugestÃµes enriquecidas:', error);
                } finally {
                    hideAILoadingSpinner();
                }
            }

            // âœ… Agora sim, exibe o modal com ou sem IA (fallback incluso)
            await displayModalResults(normalizedResult);
            console.log('[FIX-REFERENCE] Modal aberto apÃ³s segunda anÃ¡lise');
            
            // ğŸ” VALIDAÃ‡ÃƒO FINAL: Confirmar que __FIRST_ANALYSIS_FROZEN__ permanece intacto
            console.groupCollapsed('[POST-RENDER-VALIDATION] ğŸ”’ VerificaÃ§Ã£o Final de Integridade');
            console.log('ğŸ§Š __FIRST_ANALYSIS_FROZEN__ APÃ“S segunda anÃ¡lise:');
            console.log('   fileName:', window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
            console.log('   jobId:', window.__FIRST_ANALYSIS_FROZEN__?.jobId);
            console.log('   Ã‰ o mesmo que normalizedResult?', window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId);
            
            if (window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId) {
                console.error('ğŸš¨ FALHA CRÃTICA: __FIRST_ANALYSIS_FROZEN__ foi sobrescrito pela segunda anÃ¡lise!');
            } else {
                console.log('âœ… INTEGRIDADE MANTIDA: __FIRST_ANALYSIS_FROZEN__ permanece intacto');
            }
            console.groupEnd();
            
            // ========================================
            // âœ… CORREÃ‡ÃƒO 1: EARLY RETURN - Impedir limpeza no modo reference
            // ========================================
            if (currentAnalysisMode === 'reference' || jobMode === 'reference') {
                console.log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ… [CLEANUP] MODO REFERENCE ATIVO - Limpeza bloqueada por early return');
                console.log('âœ… [CLEANUP] ReferÃªncia PRESERVADA intacta:');
                console.log('âœ… [CLEANUP]   - currentAnalysisMode:', currentAnalysisMode);
                console.log('âœ… [CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
                console.log('âœ… [CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('âœ… [CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
                console.log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Marcar que hÃ¡ uma comparaÃ§Ã£o ativa
                window.__referenceComparisonActive = true;
                
                // EARLY RETURN: NÃ£o executa nenhuma limpeza
                // Continua para o prÃ³ximo bloco de cÃ³digo sem deletar nada
            } else {
                // Modo normal (genre): limpar normalmente
                delete window.__REFERENCE_JOB_ID__;
                delete window.__FIRST_ANALYSIS_RESULT__;
                localStorage.removeItem('referenceJobId');
                
                console.log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ… [CLEANUP] ReferÃªncia removida (modo genre)');
                console.log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            }
            
            // ğŸ”’ MANTÃ‰M: window.referenceAnalysisData e referenceComparisonMetrics para renderizaÃ§Ã£o
        } else {
            // Modo genre: anÃ¡lise por gÃªnero tradicional
            __dbg('ğŸ¯ Exibindo resultado por gÃªnero');
            await handleGenreAnalysisWithResult(analysisResult, file.name);
        }

    } catch (error) {
        console.error('ğŸ”´ğŸ”´ğŸ”´ [ERRO-CRÃTICO-CAPTURADO] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.error('ğŸ”´ [ERRO-CRÃTICO] Erro capturado no handleModalFileSelection!');
        console.error('ğŸ”´ [ERRO-CRÃTICO] Este erro estÃ¡ RESETANDO currentAnalysisMode para "genre"!');
        console.error('ğŸ”´ [ERRO-CRÃTICO] Error message:', error.message);
        console.error('ğŸ”´ [ERRO-CRÃTICO] Error stack:', error.stack);
        console.error('ğŸ”´ [ERRO-CRÃTICO] currentAnalysisMode ANTES:', currentAnalysisMode);
        console.error('ğŸ”´ [ERRO-CRÃTICO] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        console.error('ğŸ”´ [ERRO-CRÃTICO] isSecondTrack:', window.__REFERENCE_JOB_ID__ !== null);
        console.error('ğŸ”´ [ERRO-CRÃTICO] FEATURE_FLAGS?.FALLBACK_TO_GENRE:', window.FEATURE_FLAGS?.FALLBACK_TO_GENRE);
        console.error('ğŸ”´ğŸ”´ğŸ”´ [ERRO-CRÃTICO-CAPTURADO] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.error('âŒ Erro na anÃ¡lise do modal:', error);
        
        // âœ… STEP 4/6: Bloquear fallback para genre em caso de self-compare ou circular structure
        const msg = String(error?.message || '');
        if (msg.includes('Self-compare') || msg.includes('circular structure')) {
            console.warn('[REF-FLOW] Erro de self-compare/circular structure â€” ignorando fallback pra genre.');
            showModalError('Erro de comparaÃ§Ã£o detectado. Aguardando nova anÃ¡lise...');
            return; // Aborta sem resetar modo
        }
        
        // ========================================
        // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Nunca resetar modo se hÃ¡ primeira anÃ¡lise vÃ¡lida
        // ========================================
        if (window.FEATURE_FLAGS?.FALLBACK_TO_GENRE && currentAnalysisMode === 'reference') {
            // NÃƒO altere currentAnalysisMode se houver referÃªncia vÃ¡lida salva
            if (!window.FirstAnalysisStore?.has()) {
                console.warn('[REF-FLOW] Erro real + sem primeira anÃ¡lise â€” fallback ativado.');
                
                window.logReferenceEvent('error_fallback_to_genre', { 
                    error: error.message,
                    originalMode: currentAnalysisMode 
                });
                
                showModalError('Erro na anÃ¡lise por referÃªncia. Redirecionando para anÃ¡lise por gÃªnero...');
                
                setTimeout(() => {
                    currentAnalysisMode = 'genre';
                    configureModalForMode('genre');
                }, 2000);
            } else {
                console.warn('[REF-FLOW] Erro capturado, mas primeira anÃ¡lise existe â€” mantendo modo reference');
                console.warn('[FALLBACK] Degradando visual apenas, nÃ£o alterando modo global');
                showModalError('Erro temporÃ¡rio na anÃ¡lise. Tente fazer upload da segunda faixa novamente.');
            }
        } else {
            // Determinar tipo de erro para mensagem mais especÃ­fica
            let errorMessage = error.message;
            if (error.message.includes('Falha ao gerar URL de upload')) {
                errorMessage = 'Falha ao gerar URL de upload. Verifique sua conexÃ£o e tente novamente.';
            } else if (error.message.includes('Falha ao enviar arquivo para anÃ¡lise')) {
                errorMessage = 'Falha ao enviar arquivo para anÃ¡lise. Verifique sua conexÃ£o e tente novamente.';
            }
            
            showModalError(`Erro ao processar arquivo: ${errorMessage}`);
        }
    } finally {
        // ğŸµ WAV CLEANUP: Limpar otimizaÃ§Ãµes WAV em caso de erro
        try {
            if (window.wavMobileOptimizer) {
                window.wavMobileOptimizer.cleanupWAVOptimizations();
            }
        } catch (cleanupError) {
            console.warn('WAV cleanup error in finally (non-critical):', cleanupError);
        }
        
        // ğŸ”§ CORREÃ‡ÃƒO: Sempre limpar flag de anÃ¡lise em progresso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('âœ… Flag de anÃ¡lise em progresso removida');
    }
}

// ï¿½ NOVAS FUNÃ‡Ã•ES: AnÃ¡lise baseada em fileKey (pÃ³s-upload remoto)

/**
 * Processar anÃ¡lise por referÃªncia usando fileKey
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
// ğŸŒ NOVAS FUNÃ‡Ã•ES: AnÃ¡lise baseada em resultado remoto

/**
 * Processar anÃ¡lise por referÃªncia usando resultado remoto
 * @param {Object} analysisResult - Resultado da anÃ¡lise remota
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
async function handleReferenceAnalysisWithResult(analysisResult, fileKey, fileName) {
    __dbg('ğŸ¯ Processando anÃ¡lise por referÃªncia com resultado remoto:', { fileKey, fileName });
    
    window.logReferenceEvent('reference_analysis_with_result_started', { 
        fileKey,
        fileName 
    });
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de anÃ¡lise invÃ¡lido recebido do servidor');
        }
        
        updateModalProgress(90, 'ğŸ¯ Aplicando resultado da anÃ¡lise...');
        
        // Determinar se Ã© arquivo original ou de referÃªncia
        const isReference = currentAnalysisMode === 'reference' && uploadedFiles.original;
        const fileType = isReference ? 'reference' : 'original';
        
        // Armazenar resultado
        uploadedFiles[fileType] = {
            fileKey: fileKey,
            fileName: fileName,
            analysisResult: analysisResult
        };
        
        __dbg(`âœ… Arquivo ${fileType} armazenado:`, uploadedFiles[fileType]);
        
        // Atualizar display na interface
        updateReferenceFileDisplay(fileType, fileName);
        
        // Log do evento
        window.logReferenceEvent('reference_file_processed', {
            fileType,
            fileName,
            hasResult: !!analysisResult
        });
        
        // Verificar se ambos os arquivos estÃ£o prontos para comparaÃ§Ã£o
        if (uploadedFiles.original && uploadedFiles.reference) {
            enableReferenceComparison();
            updateModalProgress(100, 'âœ… Ambos os arquivos analisados! ComparaÃ§Ã£o disponÃ­vel.');
            
        
        }
        
    } catch (error) {
        console.error('âŒ Erro ao processar anÃ¡lise por referÃªncia:', error);
        window.logReferenceEvent('reference_analysis_error', { 
            error: error.message,
            fileKey,
            fileName 
        });
        throw error;
    }
}

/**
 * Processar anÃ¡lise por gÃªnero usando resultado remoto
 * @param {Object} analysisResult - Resultado da anÃ¡lise remota
 * @param {string} fileName - Nome original do arquivo
 */
async function handleGenreAnalysisWithResult(analysisResult, fileName) {
    __dbg('ğŸµ Processando anÃ¡lise por gÃªnero com resultado remoto:', { fileName });
    
    // ğŸ§© AUDIT_REF_FIX: Verificar se NÃƒO estamos em modo reference antes de limpar
    const state = window.__soundyState || {};
    const currentMode = state?.render?.mode || currentAnalysisMode;
    const isSecondTrack = state?.reference?.isSecondTrack || false;
    
    // ğŸš¨ PROTEÃ‡ÃƒO: NÃƒO limpar estado se estivermos em modo reference
    if (currentMode === 'reference' && isSecondTrack) {
        console.warn('âš ï¸ [AUDIT_REF_FIX] handleGenreAnalysisWithResult chamado em modo reference!');
        console.warn('âš ï¸ [AUDIT_REF_FIX] ABORTANDO limpeza para preservar dados A/B');
        console.log('[MODE LOCKED] reference - limpeza de estado BLOQUEADA');
        
        // Normalizar e retornar sem modificar estado
        const normalizedResult = normalizeBackendAnalysisData(analysisResult);
        
        // ğŸ”’ POPULAR CACHE COM RESULTADO NORMALIZADO
        AnalysisCache.put(normalizedResult);
        
        return normalizedResult;
    }
    
    // ğŸ§© CORREÃ‡ÃƒO #1: Limpeza completa APENAS em modo Genre genuÃ­no
    
    // Limpar completamente estado de referÃªncia
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        state.reference.userAnalysis = null;
        state.reference.referenceAnalysis = null;
    }
    
    // ForÃ§ar modo gÃªnero explicitamente
    if (!state.render) state.render = {};
    state.render.mode = 'genre';
    
    window.__soundyState = state;
    
    // ğŸ”’ HARD-GUARD: Limpar FirstAnalysisStore (Ãºnica fonte de verdade)
    FirstAnalysisStore.clear();
    console.log('[CLEANUP] handleGenreAnalysisWithResult: FirstAnalysisStore limpo');
    
    // âŒ REMOVER: window.referenceAnalysisData agora Ã© read-only (nÃ£o pode ser setado)
    window.referenceComparisonMetrics = null;
    window.lastReferenceJobId = null;
    
    console.log('ğŸšï¸ [FIX-GENRE] Estado completamente limpo, modo forÃ§ado para "genre"');
    
    // ğŸ”’ PATCH: PRESERVAR GÃŠNERO APÃ“S LIMPEZA
    preserveGenreState();
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de anÃ¡lise invÃ¡lido recebido do servidor');
        }
        
        updateModalProgress(90, 'ğŸµ Aplicando resultado da anÃ¡lise...');
        
        // ğŸ”§ CORREÃ‡ÃƒO: Normalizar dados do backend antes de usar
        const normalizedResult = normalizeBackendAnalysisData(analysisResult);
        
        // ğŸ”’ POPULAR CACHE COM RESULTADO NORMALIZADO
        AnalysisCache.put(normalizedResult);
        
        // ========================================
        // ğŸ”¥ BARREIRA 3: LIMPEZA NO RECEBIMENTO DE ANÃLISE
        // ========================================
        // Se o backend retornar mode: "genre", garantir limpeza ANTES de processar
        const isGenreModeFromBackend = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreModeFromBackend) {
            console.log('%c[GENRE-BARRIER] ğŸš§ BARREIRA 3 ATIVADA: AnÃ¡lise de gÃªnero recebida do backend', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
            console.log('[GENRE-BARRIER] normalizedResult.mode:', normalizedResult.mode);
            console.log('[GENRE-BARRIER] normalizedResult.isReferenceBase:', normalizedResult.isReferenceBase);
            
            // ğŸ”¥ EXECUTAR LIMPEZA COMPLETA
            // ğŸ¯ PRESERVAR GÃŠNERO durante o reset
            const genreToPreserve = getActiveGenre(normalizedResult, window.PROD_AI_REF_GENRE);
            console.log('[GENRE-BARRIER] GÃªnero a preservar:', genreToPreserve);
            resetReferenceStateFully(genreToPreserve);
            
            // ğŸ¯ GARANTIR que normalizedResult.genre estÃ¡ definido
            if (genreToPreserve && !normalizedResult.genre) {
                normalizedResult.genre = genreToPreserve;
                console.log('[GENRE-BARRIER] normalizedResult.genre restaurado:', genreToPreserve);
            }
            
            // ğŸ”’ CONFIGURAR VIEW MODE
            setViewMode("genre");
            
            // ğŸ”’ FORÃ‡AR MODO GÃŠNERO
            window.currentAnalysisMode = 'genre';
            
            console.log('%c[GENRE-BARRIER] âœ… BARREIRA 3 CONCLUÃDA: Estado limpo antes de processar anÃ¡lise', 'color:#00FF88;font-weight:bold;');
        } else if (normalizedResult.mode === 'reference' || normalizedResult.isReferenceBase === true) {
            // Modo referÃªncia: configurar ViewMode
            console.log('[REFERENCE-MODE] Configurando ViewMode para "reference" (backend retornou mode: "reference")');
            setViewMode("reference");
        }
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA: Carregar targets de gÃªnero baseado em MODE, nÃ£o em referenceComparison
        const isGenreMode = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreMode) {
            console.log('[GENRE-TARGETS] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[GENRE-TARGETS] ğŸµ MODO GÃŠNERO PURO DETECTADO');
            console.log('[GENRE-TARGETS] mode:', normalizedResult.mode);
            console.log('[GENRE-TARGETS] isReferenceBase:', normalizedResult.isReferenceBase);
            console.log('[GENRE-TARGETS] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // ğŸ”’ LIMPAR referenceComparison residual de sessÃµes anteriores
            if (normalizedResult.referenceComparison) {
                console.log('[GENRE-TARGETS] âš ï¸ referenceComparison residual detectado - removendo');
                delete normalizedResult.referenceComparison;
            }
            
            // Carregar targets de gÃªnero de /refs/out/
            // ğŸ¯ CORREÃ‡ÃƒO: Usar getActiveGenre ao invÃ©s de fallback direto para "default"
            const genreId = getActiveGenre(normalizedResult, null);
            
            if (!genreId) {
                console.warn('[GENRE-TARGETS] âš ï¸ Nenhum gÃªnero detectado - pulando carregamento de targets');
                console.warn('[GENRE-TARGETS] Fontes verificadas:', {
                    'normalizedResult.genre': normalizedResult.genre,
                    'normalizedResult.genreId': normalizedResult.genreId,
                    'normalizedResult.metadata?.genre': normalizedResult.metadata?.genre,
                    'window.__CURRENT_GENRE': window.__CURRENT_GENRE,
                    'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE
                });
            } else {
                console.log(`[GENRE-TARGETS] Carregando targets para gÃªnero: ${genreId}`);
            }
            
            // ğŸ¯ VALIDAÃ‡ÃƒO: SÃ³ carregar se genreId for vÃ¡lido (nÃ£o vazio, nÃ£o 'default')
            if (genreId && genreId !== 'default') {
                try {
                    const response = await fetch(`/refs/out/${genreId}.json`);
                    if (response.ok) {
                        const rawJson = await response.json();
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Extrair o objeto interno do JSON
                        // O JSON tem estrutura: { "genreId": { ...dados... } }
                        const rootKey = Object.keys(rawJson)[0];
                        let targets = rawJson[rootKey] || rawJson;
                        
                        console.log('[GENRE-TARGETS] ğŸ“¦ JSON bruto carregado:', { 
                            rootKey, 
                            hasRootKey: !!rootKey,
                            targetKeys: Object.keys(targets)
                        });
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Enriquecer targets usando enrichReferenceObject
                        targets = enrichReferenceObject(targets, genreId);
                        console.log('[GENRE-TARGETS] ğŸ”§ Targets enriquecidos via enrichReferenceObject');
                        
                        // ğŸ” DIAGNÃ“STICO: Logs detalhados da estrutura apÃ³s enriquecimento
                        console.log('[GENRE-TARGETS] ğŸ“Š Estrutura targets (APÃ“S enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasSpectralBands: !!targets?.spectral_bands,
                            spectralBandsCount: targets?.spectral_bands ? Object.keys(targets.spectral_bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasOriginalMetrics: !!targets?.original_metrics,
                            hasLufsTarget: targets?.lufs_target !== undefined,
                            hasTruePeakTarget: targets?.true_peak_target !== undefined,
                            hasDrTarget: targets?.dr_target !== undefined,
                            hasStereoTarget: targets?.stereo_target !== undefined
                        });
                        
                        // ğŸ” DIAGNÃ“STICO: Amostra das bandas
                        if (targets?.bands) {
                            const sampleBand = Object.keys(targets.bands)[0];
                            console.log('[GENRE-TARGETS] ğŸ“‹ Amostra de banda:', sampleBand, targets.bands[sampleBand]);
                        }
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Criar referenceComparisonMetrics para UI
                        normalizedResult.referenceComparisonMetrics = {
                            bands: targets.bands || targets.spectral_bands,
                            spectralBands: targets.spectral_bands || targets.bands,
                            legacyBands: targets.legacy_compatibility?.bands,
                            originalMetrics: targets.original_metrics || targets.hybrid_processing?.original_metrics,
                            lufs_target: targets.lufs_target,
                            true_peak_target: targets.true_peak_target,
                            dr_target: targets.dr_target,
                            stereo_target: targets.stereo_target,
                            lra_target: targets.lra_target
                        };
                        console.log('[GENRE-TARGETS] ğŸ“¦ referenceComparisonMetrics criado:', {
                            hasBands: !!normalizedResult.referenceComparisonMetrics.bands,
                            hasOriginalMetrics: !!normalizedResult.referenceComparisonMetrics.originalMetrics
                        });
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Atribuir targets a TODAS as variÃ¡veis globais
                        normalizedResult.referenceComparison = targets;
                        
                        // âœ… CORREÃ‡ÃƒO: Inicializar window.PROD_AI_REF_DATA como objeto se for false
                        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
                            window.PROD_AI_REF_DATA = {};
                            console.log('[GENRE-TARGETS] ğŸ”§ Inicializando window.PROD_AI_REF_DATA como objeto');
                        }
                        
                        // âœ… CORREÃ‡ÃƒO: Atribuir targets ao gÃªnero especÃ­fico
                        window.PROD_AI_REF_DATA[genreId] = targets;
                        console.log(`[GENRE-TARGETS] ğŸ“¦ window.PROD_AI_REF_DATA['${genreId}'] atribuÃ­do`);
                        
                        // âœ… CORREÃ‡ÃƒO: Atualizar __activeRefData
                        window.__activeRefData = targets;
                        console.log('[GENRE-TARGETS] ğŸ“¦ window.__activeRefData atualizado');
                        
                        // âœ… CORREÃ‡ÃƒO: Sincronizar gÃªnero ativo
                        window.__CURRENT_GENRE = genreId;
                        console.log(`[GENRE-TARGETS] ğŸ¯ window.__CURRENT_GENRE = '${genreId}'`);
                        
                        console.log(`[GENRE-TARGETS] âœ… Targets carregados e enriquecidos para ${genreId}`);
                        console.log('[GENRE-TARGETS] ğŸ“Š Estrutura targets (APÃ“S enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasLufsTarget: !!targets?.lufs_target,
                            hasTruePeakTarget: !!targets?.true_peak_target,
                            hasDrTarget: !!targets?.dr_target,
                            hasStereoTarget: !!targets?.stereo_target
                        });
                        console.log('[GENRE-TARGETS] ğŸ“‹ Targets.bands:', targets?.bands);
                    } else {
                        console.warn(`[GENRE-TARGETS] âš ï¸ Arquivo nÃ£o encontrado: /refs/out/${genreId}.json (${response.status})`);
                        console.warn(`[GENRE-TARGETS] Continuando sem targets especÃ­ficos do gÃªnero`);
                    }
                } catch (err) {
                    console.error("[GENRE-TARGETS] âŒ Erro ao carregar targets de gÃªnero:", err);
                    console.error("[GENRE-TARGETS] Continuando com targets padrÃ£o ou sem targets");
                }
            } else {
                console.warn('[GENRE-TARGETS] âš ï¸ GenreId invÃ¡lido ou "default" - pulando fetch:', genreId);
            }
        } else {
            console.log("[GENRE-TARGETS] âš ï¸ NÃ£o Ã© modo gÃªnero puro - pulando carregamento de targets");
            console.log("[GENRE-TARGETS] mode:", normalizedResult.mode);
            console.log("[GENRE-TARGETS] isReferenceBase:", normalizedResult.isReferenceBase);
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Gerar sugestÃµes no primeiro load
        if (__activeRefData && !normalizedResult._suggestionsGenerated) {
            console.log('ğŸ¯ [SUGGESTIONS] Engine chamado no primeiro load');
            try {
                updateReferenceSuggestions(normalizedResult, __activeRefData);
                normalizedResult._suggestionsGenerated = true;
                console.log(`ğŸ¯ [SUGGESTIONS] ${normalizedResult.suggestions?.length || 0} sugestÃµes geradas no primeiro load`);
            } catch (error) {
                console.error('âŒ [SUGGESTIONS] Erro ao gerar sugestÃµes no primeiro load:', error);
            }
        } else if (!__activeRefData) {
            console.log('ğŸ¯ [SUGGESTIONS] Dados de referÃªncia nÃ£o disponÃ­veis para gerar sugestÃµes');
        } else {
            console.log('ğŸ¯ [SUGGESTIONS] SugestÃµes jÃ¡ foram geradas anteriormente');
        }

        // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Sempre mostrar interface IA apÃ³s sugestÃµes serem processadas
        if (normalizedResult.suggestions && normalizedResult.suggestions.length > 0) {
            setTimeout(() => {
                console.log(`ğŸš€ [AI-UI-FORCE] Tentando forÃ§ar interface IA aparecer com ${normalizedResult.suggestions.length} sugestÃµes`);
                
                // Verificar mÃºltiplas formas de chamar a interface IA
                if (window.aiUIController) {
                    console.log(`ğŸš€ [AI-UI-FORCE] Usando aiUIController existente`);
                    window.aiUIController.checkForAISuggestions(normalizedResult, true);
                } else if (window.forceShowAISuggestions) {
                    console.log(`ğŸš€ [AI-UI-FORCE] Usando forceShowAISuggestions como fallback`);
                    window.forceShowAISuggestions(normalizedResult);
                } else {
                    console.warn('âš ï¸ [AI-UI-FORCE] Nenhum mÃ©todo de interface IA encontrado, criando interface bÃ¡sica...');
                    
                    // Criar interface bÃ¡sica na hora
                    const aiSection = document.createElement('div');
                    aiSection.id = 'ai-suggestions-section';
                    aiSection.style.cssText = `
                        margin: 20px 0; padding: 20px; border: 2px solid #4CAF50;
                        border-radius: 10px; background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
                        color: white; font-family: Arial, sans-serif;
                    `;
                    aiSection.innerHTML = `
                        <h3 style="color: #4CAF50; margin: 0 0 15px 0;">ğŸ¤– SugestÃµes Inteligentes</h3>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <p style="margin: 0 0 10px 0; color: #A5D6A7;">
                                ğŸ’¡ Interface IA carregada com ${normalizedResult.suggestions.length} sugestÃµes
                            </p>
                            <p style="margin: 0; font-size: 14px; color: #81C784;">
                                Configure uma API Key da OpenAI para sugestÃµes inteligentes personalizadas.
                            </p>
                            <button onclick="if(window.promptForAPIKey) window.promptForAPIKey(); else alert('Configure API Key da OpenAI para ativar IA')" 
                                    style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                âš™ï¸ Configurar IA
                            </button>
                        </div>
                    `;
                    
                    // Inserir na interface
                    const modal = document.getElementById('audioAnalysisModal');
                    const content = modal?.querySelector('.modal-content');
                    if (content) {
                        // Remover seÃ§Ã£o anterior se existir
                        const existing = content.querySelector('#ai-suggestions-section');
                        if (existing) existing.remove();
                        
                        // Adicionar nova seÃ§Ã£o
                        content.appendChild(aiSection);
                        console.log('âœ… [AI-UI-FORCE] Interface IA bÃ¡sica criada e inserida');
                    } else {
                        console.error('âŒ [AI-UI-FORCE] Modal nÃ£o encontrado para inserir interface');
                    }
                }
            }, 500); // Delay para garantir que o DOM esteja renderizado
        }
        
        // Definir como anÃ¡lise atual do modal
        currentModalAnalysis = normalizedResult;
        
        // ğŸ¯ ALIAS GLOBAL PARA RELATÃ“RIOS (Fonte de Verdade Ãšnica)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = normalizedResult;
            
            // Criar namespace global unificado
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = normalizedResult;
            
            console.log('âœ… [PDF-READY] AnÃ¡lise armazenada globalmente:', {
                hasGlobalAlias: !!window.__soundyAI.analysis,
                fileName: normalizedResult.metadata?.fileName || normalizedResult.fileName,
                score: normalizedResult.score,
                hasMetrics: !!(normalizedResult.loudness || normalizedResult.technicalData)
            });
        }
        
        updateModalProgress(100, `âœ… AnÃ¡lise de ${fileName} concluÃ­da!`);
        
        // ========================================
        // ğŸ¤– AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL (MODO GENRE)
        // ========================================
        console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('[AI-SYNC][GENRE] ğŸ” Verificando status do enriquecimento IA...');
        console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        // Verificar se aiSuggestions jÃ¡ estÃ¡ presente
        const hasAISuggestionsGenre = Array.isArray(normalizedResult.aiSuggestions) && 
                                      normalizedResult.aiSuggestions.length > 0 &&
                                      normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
        
        console.log('[AI-SYNC][GENRE] ğŸ“Š Estado atual:', {
            hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
            aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
            aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
            jobId: normalizedResult.jobId
        });
        
        if (!hasAISuggestionsGenre) {
            console.log('[AI-SYNC][GENRE] â³ aiSuggestions nÃ£o estÃ¡ pronto, aguardando enriquecimento...');
            
            // Mostrar spinner visual
            showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');
            
            try {
                // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                const enrichedDataGenre = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                
                if (enrichedDataGenre && enrichedDataGenre.aiSuggestions && enrichedDataGenre.aiSuggestions.length > 0) {
                    // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                    normalizedResult.aiSuggestions = enrichedDataGenre.aiSuggestions;
                    
                    console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('[AI-SYNC][GENRE] âœ… Enriquecimento IA mesclado com sucesso!');
                    console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('[AI-SYNC][GENRE] ğŸ“Š Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                    console.log('[AI-SYNC][GENRE] ğŸ¤– Marcadas como aiEnhanced:', 
                        normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                    
                    // Atualizar cache com dados enriquecidos
                    AnalysisCache.put(normalizedResult);
                    
                } else {
                    console.warn('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.warn('[AI-SYNC][GENRE] âš ï¸ Enriquecimento IA nÃ£o completou a tempo');
                    console.warn('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.warn('[AI-SYNC][GENRE] â„¹ï¸ Modal serÃ¡ exibido com sugestÃµes base');
                    console.warn('[AI-SYNC][GENRE] â„¹ï¸ IA pode estar desabilitada ou sobrecarregada');
                }
                
            } catch (syncErrorGenre) {
                console.error('[AI-SYNC][GENRE] âŒ Erro ao aguardar enriquecimento IA:', syncErrorGenre);
                console.warn('[AI-SYNC][GENRE] â„¹ï¸ Continuando com sugestÃµes base...');
            } finally {
                // Remover spinner
                hideAILoadingSpinner();
            }
            
        } else {
            console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[AI-SYNC][GENRE] âœ… aiSuggestions jÃ¡ presente no resultado!');
            console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            console.log('[AI-SYNC][GENRE] â„¹ï¸ NÃ£o Ã© necessÃ¡rio aguardar, exibindo imediatamente');
        }
        
        console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('[AI-SYNC][GENRE] ğŸ¬ Iniciando renderizaÃ§Ã£o do modal...');
        console.log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        // ========================================
        // âœ… CORREÃ‡ÃƒO: Aguardar enriquecimento IA antes de abrir modal (MODO GENRE)
        // ========================================
        if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
            console.log('[AI-SYNC][GENRE] â³ Enriquecimento IA ausente â€” aguardando resposta...');
            showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');

            try {
                const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                    normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                    console.log(`[AI-SYNC][GENRE] âœ… SugestÃµes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                } else {
                    console.warn('[AI-SYNC][GENRE] âš ï¸ Timeout ou IA nÃ£o retornou sugestÃµes vÃ¡lidas. Fallback para sugestÃµes base.');
                }
            } catch (error) {
                console.error('[AI-SYNC][GENRE] âŒ Erro ao aguardar sugestÃµes enriquecidas:', error);
            } finally {
                hideAILoadingSpinner();
            }
        }
        
        // âœ… Agora sim, exibe o modal com ou sem IA (fallback incluso)
        // ğŸ›¡ï¸ VERIFICAÃ‡ÃƒO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            await displayModalResults(normalizedResult);
            console.log("[DISPLAY] Modal aberto com sucesso (modo genre)");
        } else {
            console.error('âŒ [MODAL_MONITOR] FunÃ§Ã£o displayModalResults nÃ£o encontrada');
        }
        
    } catch (error) {
        console.error('âŒ Erro ao processar anÃ¡lise por gÃªnero:', error);
        throw error;
    }
}

/**
 * Atualizar display de arquivo de referÃªncia na interface
 * @param {string} fileType - Tipo do arquivo ('original' ou 'reference')
 * @param {string} fileName - Nome do arquivo
 */
function updateReferenceFileDisplay(fileType, fileName) {
    const displayElement = document.getElementById(`${fileType}FileDisplay`);
    if (displayElement) {
        displayElement.textContent = fileName;
        displayElement.style.display = 'block';
    }
    
    // Atualizar tambÃ©m elementos relacionados
    const labelElement = document.querySelector(`label[for="${fileType}FileInput"]`);
    if (labelElement) {
        labelElement.style.opacity = '0.7';
    }
}

/**
 * Habilitar botÃ£o de comparaÃ§Ã£o de referÃªncia
 */
function enableReferenceComparison() {
    const compareButton = document.getElementById('compareButton');
    if (compareButton) {
        compareButton.disabled = false;
        compareButton.style.opacity = '1';
        compareButton.style.cursor = 'pointer';
    }
    
    // Atualizar indicador visual
    const indicator = document.querySelector('.reference-ready-indicator');
    if (indicator) {
        indicator.style.display = 'block';
    }
}


/**
 * Mostrar mensagem do prÃ³ximo passo
 * @param {string} message - Mensagem a ser exibida
 */
function showNextStepMessage(message) {
    console.log(`â¡ï¸ ${message}`);
    
    // Implementar notificaÃ§Ã£o visual se necessÃ¡rio
    const notification = document.createElement('div');
    notification.className = 'next-step-notification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    // Remover apÃ³s 5 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 5000);
}

// ï¿½ğŸ¯ NOVO: ValidaÃ§Ã£o comum de arquivo
function validateAudioFile(file) {
    const MAX_UPLOAD_MB = 60;
    const MAX_UPLOAD_SIZE = MAX_UPLOAD_MB * 1024 * 1024;
    
    // Formatos aceitos: WAV, FLAC, MP3 (simplificado)
    const allowedTypes = ['audio/wav', 'audio/flac', 'audio/mpeg', 'audio/mp3'];
    const allowedExtensions = ['.wav', '.flac', '.mp3'];
    
    // Validar tipo de arquivo
    const isValidType = allowedTypes.includes(file.type.toLowerCase()) || 
                       allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
    
    if (!isValidType) {
        showModalError(`Formato nÃ£o suportado. Apenas WAV, FLAC e MP3 sÃ£o aceitos.
                      ğŸ’¡ Prefira WAV ou FLAC para maior precisÃ£o na anÃ¡lise.`);
        return false;
    }
    
    // Validar tamanho (novo limite: 60MB)
    if (file.size > MAX_UPLOAD_SIZE) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        showModalError(`Arquivo muito grande: ${sizeInMB}MB. 
                      Limite mÃ¡ximo: ${MAX_UPLOAD_MB}MB.`);
        return false;
    }
    
    // ğŸµ WAV MOBILE WARNING: Avisar sobre demora em arquivos WAV grandes no mobile
    const isWAV = file.name.toLowerCase().endsWith('.wav') || file.type.includes('wav');
    const isMobile = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
    const isLargeWAV = isWAV && file.size > 20 * 1024 * 1024; // >20MB
    
    if (isLargeWAV && isMobile) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        const estimatedTime = Math.ceil(file.size / (2 * 1024 * 1024)); // ~2MB/s no mobile
        
        console.warn(`â±ï¸ WAV grande no mobile: ${sizeInMB}MB - tempo estimado: ${estimatedTime}s`);
        
        // Mostrar aviso nÃ£o-bloqueante
        setTimeout(() => {
            if (document.getElementById('audioProgressText')) {
                document.getElementById('audioProgressText').innerHTML = 
                    `â±ï¸ Arquivo WAV grande (${sizeInMB}MB)<br>Tempo estimado: ${estimatedTime}-${estimatedTime*2}s<br>Aguarde...`;
            }
        }, 1000);
    }
    
    // Mostrar recomendaÃ§Ã£o para MP3
    if (file.type === 'audio/mpeg' || file.type === 'audio/mp3' || file.name.toLowerCase().endsWith('.mp3')) {
        console.log('ğŸ’¡ MP3 detectado - RecomendaÃ§Ã£o: Use WAV ou FLAC para maior precisÃ£o');
    }
    
    return true;
}

// ğŸ¯ NOVO: Processar arquivo no modo referÃªncia
async function handleReferenceFileSelection(file) {
    window.logReferenceEvent('reference_file_selected', { 
        step: referenceStepState.currentStep,
        fileName: file.name,
        fileSize: file.size 
    });
    
    if (referenceStepState.currentStep === 'userAudio') {
        // Primeiro arquivo: mÃºsica do usuÃ¡rio
        referenceStepState.userAudioFile = file;
        
        // ğŸ› DIAGNÃ“STICO: Verificar se estÃ¡ carregando dados de gÃªnero no modo referÃªncia
        console.log('ğŸ” [DIAGNÃ“STICO] Analisando USER audio em modo referÃªncia');
        console.log('ğŸ” [DIAGNÃ“STICO] Current mode:', window.currentAnalysisMode);
        console.log('ğŸ” [DIAGNÃ“STICO] Genre ativo antes da anÃ¡lise:', window.PROD_AI_REF_GENRE);
        console.log('ğŸ” [DIAGNÃ“STICO] Active ref data:', !!__activeRefData);
        
        // Analisar arquivo do usuÃ¡rio
        showModalLoading();
        updateModalProgress(10, 'ğŸµ Analisando sua mÃºsica...');
        
        // ğŸ¯ CORREÃ‡ÃƒO TOTAL: Analisar arquivo do usuÃ¡rio SEM aplicar targets
        const userAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparaÃ§Ãµes
          debugModeReference: true,
          // Garantir mesmas configuraÃ§Ãµes para ambos os arquivos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId
        const userOptionsWithRunId = prepareAnalysisOptions(userAnalysisOptions, 'user_ref');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, userOptionsWithRunId);
        
        // ğŸ› VALIDAÃ‡ÃƒO: Verificar que nÃ£o hÃ¡ comparaÃ§Ã£o com gÃªnero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('âš ï¸ [AVISO] AnÃ¡lise do usuÃ¡rio contaminada com comparaÃ§Ã£o/score');
        }
        
        console.log('ğŸ” [DIAGNÃ“STICO] User analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        referenceStepState.userAnalysis = analysis;
        
        // AvanÃ§ar para prÃ³ximo step
        updateReferenceStep('referenceAudio');
        updateUploadAreaForReferenceStep();
        
        window.logReferenceEvent('user_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
        
    } else if (referenceStepState.currentStep === 'referenceAudio') {
        // Segundo arquivo: mÃºsica de referÃªncia
        referenceStepState.referenceAudioFile = file;
        
        // ğŸ› DIAGNÃ“STICO: Verificar anÃ¡lise do arquivo de referÃªncia
        console.log('ğŸ” [DIAGNÃ“STICO] Analisando REFERENCE audio em modo referÃªncia');
        console.log('ğŸ” [DIAGNÃ“STICO] Current mode:', window.currentAnalysisMode);
        console.log('ğŸ” [DIAGNÃ“STICO] Genre ativo antes da anÃ¡lise:', window.PROD_AI_REF_GENRE);
        
        // Analisar arquivo de referÃªncia (extraÃ§Ã£o de mÃ©tricas com MESMAS configuraÃ§Ãµes)
        showModalLoading();
        updateModalProgress(50, 'ğŸ¯ Analisando mÃºsica de referÃªncia...');
        
        // ğŸ¯ CORREÃ‡ÃƒO TOTAL: Usar EXATAMENTE as mesmas configuraÃ§Ãµes do usuÃ¡rio
        const refAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparaÃ§Ãµes
          debugModeReference: true,
          // ğŸ¯ GARANTIR parÃ¢metros idÃªnticos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId
        const refOptionsWithRunId = prepareAnalysisOptions(refAnalysisOptions, 'ref_audio');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, refOptionsWithRunId);
        
        // ğŸ› VALIDAÃ‡ÃƒO: Verificar que nÃ£o hÃ¡ comparaÃ§Ã£o com gÃªnero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('âš ï¸ [AVISO] AnÃ¡lise da referÃªncia contaminada com comparaÃ§Ã£o/score');
        }
        
        console.log('ğŸ” [DIAGNÃ“STICO] Reference analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        // ğŸ¯ VALIDAÃ‡ÃƒO: Verificar se conseguimos extrair mÃ©tricas vÃ¡lidas
        const referenceMetrics = {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp
        };
        
        // ğŸš¨ ERRO CLARO: Falhar se nÃ£o conseguir extrair mÃ©tricas
        if (!Number.isFinite(referenceMetrics.lufs)) {
          throw new Error('REFERENCE_METRICS_FAILED: NÃ£o foi possÃ­vel extrair mÃ©tricas LUFS da mÃºsica de referÃªncia. Verifique se o arquivo Ã© vÃ¡lido.');
        }
        
        if (!Number.isFinite(referenceMetrics.stereoCorrelation)) {
          throw new Error('REFERENCE_METRICS_FAILED: NÃ£o foi possÃ­vel extrair correlaÃ§Ã£o estÃ©reo da mÃºsica de referÃªncia.');
        }
        
        console.log('âœ… [SUCESSO] MÃ©tricas da referÃªncia extraÃ­das:', referenceMetrics);
        
        referenceStepState.referenceAnalysis = analysis;
        referenceStepState.referenceMetrics = referenceMetrics;
        
        // Executar comparaÃ§Ã£o
        updateReferenceStep('analysis');
        await performReferenceComparison();
        
        // ğŸ¯ EXIBIR resultados da anÃ¡lise por referÃªncia
        const finalAnalysis = referenceStepState.finalAnalysis;
        
        updateModalProgress(100, 'âœ… AnÃ¡lise por referÃªncia concluÃ­da!');
        
        // ğŸ¯ LOGS finais de validaÃ§Ã£o
        console.log('ğŸ‰ [ANÃLISE POR REFERÃŠNCIA] ConcluÃ­da com sucesso:');
        console.log('  - Baseline source:', finalAnalysis.comparison?.baseline_source);
        console.log('  - LUFS difference:', finalAnalysis.comparison?.loudness?.difference?.toFixed(2));
        console.log('  - SugestÃµes:', finalAnalysis.suggestions?.length || 0);
        console.log('  - Sem gÃªnero:', !finalAnalysis.genre);
        
        // Exibir modal de resultados
        displayReferenceResults(finalAnalysis);
        
        window.logReferenceEvent('reference_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
    }
}

// ğŸ¯ NOVO: Processar arquivo no modo gÃªnero (comportamento original)
async function handleGenreFileSelection(file) {
    // ğŸ› DIAGNÃ“STICO: Confirmar que este Ã© o modo gÃªnero
    console.log('ğŸ” [DIAGNÃ“STICO] handleGenreFileSelection - modo:', window.currentAnalysisMode);
    console.log('ğŸ” [DIAGNÃ“STICO] Este deveria ser APENAS modo gÃªnero!');
    
    __dbg('ğŸ”„ Iniciando nova anÃ¡lise - forÃ§ando exibiÃ§Ã£o do loading');
    showModalLoading();
    updateModalProgress(10, 'âš¡ Carregando Algoritmos AvanÃ§ados...');
    
    // Aguardar audio analyzer carregar se necessÃ¡rio
    if (!window.audioAnalyzer) {
        __dbg('â³ Aguardando Audio Analyzer carregar...');
        updateModalProgress(30, 'ğŸ”§ Inicializando V2 Engine...');
        await waitForAudioAnalyzer();
    }

    // ğŸ› CORREÃ‡ÃƒO CRÃTICA: SÃ³ carregar referÃªncias de gÃªnero se estivermos NO MODO GÃŠNERO
    if (window.currentAnalysisMode === 'genre') {
        // ğŸ¯ FALLBACK SEGURO: Restaurar gÃªnero do localStorage se nÃ£o estiver setado
        if (!window.PROD_AI_REF_GENRE) {
            const savedGenre = localStorage.getItem('prodai_ref_genre');
            if (savedGenre) {
                console.log('ğŸ”§ [GENRE-FALLBACK] Restaurando gÃªnero do localStorage:', savedGenre);
                window.PROD_AI_REF_GENRE = savedGenre;
            } else {
                console.error('âŒ [GENRE-CRITICAL] GÃªnero nÃ£o encontrado - modo gÃªnero sem targets');
            }
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: RESETAR ESTADO DE REFERÃŠNCIA ANTES DE CARREGAR TARGETS DE GÃŠNERO
        // ğŸ¯ PRESERVAR GÃŠNERO durante o reset
        const currentGenre = window.PROD_AI_REF_GENRE || window.__CURRENT_GENRE;
        console.log('ğŸ§¹ [GENRE-MODE] Resetando estado de referÃªncia antes de carregar targets...');
        console.log('ğŸ§¹ [GENRE-MODE] GÃªnero preservado:', currentGenre);
        resetReferenceStateFully(currentGenre);
        
        // Garantir que referÃªncias do gÃªnero selecionado estejam carregadas antes da anÃ¡lise
        try {
            const genre = window.PROD_AI_REF_GENRE;
            console.log('ğŸ” [DIAGNÃ“STICO] Carregando referÃªncias de gÃªnero:', genre);
            
            // âœ… CORREÃ‡ÃƒO: Sempre carregar targets se gÃªnero existir
            if (genre) {
                updateModalProgress(25, `ğŸ“š Carregando referÃªncias: ${genre}...`);
                await loadReferenceData(genre);
                updateModalProgress(30, 'ğŸ“š ReferÃªncias ok');
                
                // âœ… VALIDAÃ‡ÃƒO: Confirmar que targets foram carregados
                if (!window.__activeRefData) {
                    console.error('âŒ [GENRE-CRITICAL] Falha ao carregar targets de gÃªnero');
                } else {
                    console.log('âœ… [GENRE-SUCCESS] Targets carregados:', {
                        genre,
                        hasBands: !!window.__activeRefData.bands,
                        lufsTarget: window.__activeRefData.lufs_target
                    });
                }
            }
        } catch (e) { 
            console.error('âŒ [GENRE-ERROR] Erro ao carregar referÃªncias de gÃªnero:', e);
        }
    } else {
        console.log('ğŸ” [DIAGNÃ“STICO] PULAR carregamento de referÃªncias - modo nÃ£o Ã© gÃªnero');
    }
    
    // Analisar arquivo
    __dbg('ğŸ”¬ Iniciando anÃ¡lise...');
    updateModalProgress(40, 'ğŸµ Processando Waveform Digital...');
    
    // ï¿½ WAV MOBILE OPTIMIZATION: Aplicar otimizaÃ§Ãµes especÃ­ficas para WAV
    try {
        // Carregar otimizador WAV se nÃ£o estiver disponÃ­vel
        if (typeof window.wavMobileOptimizer === 'undefined') {
            const optimizerScript = document.createElement('script');
            optimizerScript.src = '/lib/audio/wav-mobile-optimizer.js';
            optimizerScript.type = 'module';
            document.head.appendChild(optimizerScript);
            
            // Aguardar carregamento com timeout
            await new Promise((resolve) => {
                optimizerScript.onload = () => {
                    console.log('ğŸµ WAV optimizer carregado');
                    resolve();
                };
                optimizerScript.onerror = () => {
                    console.warn('âš ï¸ WAV optimizer falhou ao carregar');
                    resolve();
                };
                setTimeout(resolve, 1500); // fallback timeout
            });
        }
        
        // Aplicar otimizaÃ§Ãµes se disponÃ­vel
        if (window.wavMobileOptimizer) {
            const wavAnalysis = window.wavMobileOptimizer.applyWAVOptimizations(file);
            if (wavAnalysis.requiresOptimization) {
                updateModalProgress(45, `ğŸµ WAV ${wavAnalysis.sizeInMB}MB - otimizaÃ§Ã£o mobile ativa...`);
                console.log('ğŸµ WAV mobile optimizations applied:', wavAnalysis);
            }
        }
    } catch (optimizerError) {
        console.warn('âš ï¸ WAV optimizer failed, continuing with standard processing:', optimizerError);
    }
    
    // ï¿½ğŸ¯ CORREÃ‡ÃƒO: Passar modo correto para anÃ¡lise
    const analysisOptions = { 
      mode: window.currentAnalysisMode || 'genre' 
    };
    // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId para anÃ¡lise principal
    const optionsWithRunId = prepareAnalysisOptions(analysisOptions, 'main');
    const analysis = await window.audioAnalyzer.analyzeAudioFile(file, optionsWithRunId);
    currentModalAnalysis = analysis;
    
    // ğŸµ WAV CLEANUP: Limpar otimizaÃ§Ãµes WAV apÃ³s conclusÃ£o
    try {
        if (window.wavMobileOptimizer) {
            window.wavMobileOptimizer.cleanupWAVOptimizations();
        }
    } catch (cleanupError) {
        console.warn('WAV cleanup error (non-critical):', cleanupError);
    }
    
    __dbg('âœ… AnÃ¡lise concluÃ­da:', analysis);
    
    updateModalProgress(90, 'ğŸ§  Computando MÃ©tricas AvanÃ§adas...');
    
    // Aguardar um pouco para melhor UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    updateModalProgress(100, 'âœ¨ AnÃ¡lise Completa - Pronto!');
    
    // Mostrar resultados
    setTimeout(() => {
        // ğŸ”’ FASE 2 UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
        const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
        const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
        
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`ğŸš« [UI_GATE] AnÃ¡lise cancelada - nÃ£o renderizar UI (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
            return;
        }
        
        // Telemetria: verificar elementos alvo antes de preencher o modal
        const exists = {
            audioUploadArea: !!document.getElementById('audioUploadArea'),
            audioAnalysisLoading: !!document.getElementById('audioAnalysisLoading'),
            audioAnalysisResults: !!document.getElementById('audioAnalysisResults'),
            modalTechnicalData: !!document.getElementById('modalTechnicalData')
        };
        __dbg('ğŸ›°ï¸ [Telemetry] Front antes de preencher modal (existÃªncia de elementos):', exists);
        
        // ğŸ”’ UI GATE: Verificar novamente antes de renderizar
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`ğŸš« [UI_GATE] VerificaÃ§Ã£o dupla - anÃ¡lise cancelada durante delay`);
            return;
        }
        
        // ğŸ›¡ï¸ VERIFICAÃ‡ÃƒO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            displayModalResults(analysis);
        } else {
            console.warn('âš ï¸ [MODAL_MONITOR] FunÃ§Ã£o displayModalResults nÃ£o encontrada, aguardando carregamento...');
            // Tentar novamente em 1 segundo
            setTimeout(() => {
                if (typeof displayModalResults === 'function') {
                    displayModalResults(analysis);
                } else {
                    console.error('âŒ [MODAL_MONITOR] Timeout - funÃ§Ã£o displayModalResults nÃ£o encontrada apÃ³s espera');
                }
            }, 1000);
        }
        
        // ğŸ”§ CORREÃ‡ÃƒO: Limpar flag de anÃ¡lise em progresso apÃ³s sucesso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('âœ… AnÃ¡lise concluÃ­da com sucesso - flag removida');
    }, 800);
}

// ğŸ¯ NOVO: Atualizar upload area para step de referÃªncia
function updateUploadAreaForReferenceStep() {
    const uploadArea = document.getElementById('audioUploadArea');
    if (!uploadArea) return;
    
    const uploadContent = uploadArea.querySelector('.upload-content');
    if (!uploadContent) return;
    
    // Limpar input de arquivo
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) {
        fileInput.value = '';
    }
    
    // Atualizar conteÃºdo baseado no step
    if (referenceStepState.currentStep === 'referenceAudio') {
        const icon = uploadContent.querySelector('.upload-icon');
        const title = uploadContent.querySelector('h4');
        const description = uploadContent.querySelector('p:not(.supported-formats):not(.format-recommendation)');
        
        if (icon) icon.textContent = 'ğŸ¯';
        if (title) title.textContent = 'MÃºsica de ReferÃªncia';
        if (description) description.textContent = 'Agora selecione a mÃºsica que servirÃ¡ como referÃªncia para comparaÃ§Ã£o';
    }
    
    // Mostrar upload area novamente
    uploadArea.style.display = 'block';
    
    // Esconder loading
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) loading.style.display = 'none';
    
    window.logReferenceEvent('upload_area_updated', { 
        step: referenceStepState.currentStep 
    });
}

// ğŸ¯ REESCRITA COMPLETA: ComparaÃ§Ã£o baseada exclusivamente na referÃªncia
async function performReferenceComparison() {
    window.logReferenceEvent('reference_comparison_started');
    
    try {
        updateModalProgress(70, 'ğŸ”„ Comparando as duas mÃºsicas...');
        
        const userAnalysis = referenceStepState.userAnalysis;
        const refAnalysis = referenceStepState.referenceAnalysis;
        const referenceMetrics = referenceStepState.referenceMetrics;
        
        if (!userAnalysis || !refAnalysis || !referenceMetrics) {
            throw new Error('COMPARISON_DATA_MISSING: AnÃ¡lises ou mÃ©tricas de referÃªncia nÃ£o encontradas');
        }
        
        // ğŸ¯ EXTRAIR mÃ©tricas do usuÃ¡rio (anÃ¡lise pura, sem comparaÃ§Ãµes)
        const userMetrics = {
            lufs: userAnalysis.technicalData?.lufsIntegrated,
            stereoCorrelation: userAnalysis.technicalData?.stereoCorrelation,
            dynamicRange: userAnalysis.technicalData?.dynamicRange,
            truePeak: userAnalysis.technicalData?.truePeakDbtp
        };
        
        // ğŸš¨ VALIDAÃ‡ÃƒO: Verificar mÃ©tricas do usuÃ¡rio
        if (!Number.isFinite(userMetrics.lufs)) {
            throw new Error('USER_METRICS_FAILED: NÃ£o foi possÃ­vel extrair mÃ©tricas LUFS da sua mÃºsica');
        }
        
        console.log('ğŸ” [COMPARAÃ‡ÃƒO] MÃ©tricas extraÃ­das:');
        console.log('  - UsuÃ¡rio:', userMetrics);
        console.log('  - ReferÃªncia:', referenceMetrics);
        
        // ğŸ¯ CALCULAR diferenÃ§as PURAS (referÃªncia como baseline)
        const differences = {
            lufs: userMetrics.lufs - referenceMetrics.lufs,
            stereoCorrelation: userMetrics.stereoCorrelation - referenceMetrics.stereoCorrelation,
            dynamicRange: userMetrics.dynamicRange - referenceMetrics.dynamicRange,
            truePeak: userMetrics.truePeak - referenceMetrics.truePeak
        };
        
        console.log('ğŸ” [COMPARAÃ‡ÃƒO] DiferenÃ§as calculadas:', differences);
        
        // ğŸ¯ GERAR sugestÃµes baseadas APENAS na referÃªncia
        const referenceSuggestions = [];
        const THRESHOLD = 0.2; // Ignorar diferenÃ§as menores que 0.2dB
        
        // Loudness (LUFS) - ğŸš¨ COM VERIFICAÃ‡ÃƒO DE HEADROOM SEGURO
        if (Math.abs(differences.lufs) > THRESHOLD) {
            const action = differences.lufs > 0 ? 'Diminuir' : 'Aumentar';
            const direction = differences.lufs > 0 ? 'decrease' : 'increase';
            const adjustmentDb = Math.abs(differences.lufs);
            
            // ğŸ”’ Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                const userTruePeak = userMetrics.truePeak;
                const clippingSamples = userAnalysis.technical?.clippingSamples || 0;
                const isClipped = clippingSamples > 0;
                const headroomSafetyMargin = -0.6; // Target true peak seguro
                
                // ğŸš¨ REGRA 1: Se CLIPPED, nÃ£o sugerir aumento
                if (isClipped) {
                    console.log(`[REF-HEADROOM] ğŸš¨ Clipping detectado - nÃ£o sugerindo aumento de ${adjustmentDb.toFixed(1)}dB`);
                    referenceSuggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: `ImpossÃ­vel igualar referÃªncia - Ã¡udio tem clipping`,
                        action: `Primeiro resolver clipping, depois ajustar para referÃªncia`,
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        baseline_source: 'reference_audio',
                        warning: `Clipping detectado (${clippingSamples} samples)`
                    });
                } 
                // ğŸš¨ REGRA 2: Verificar headroom disponÃ­vel
                else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        referenceSuggestions.push({
                            type: 'reference_loudness',
                            message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar Ã  mÃºsica de referÃªncia`,
                            action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            baseline_source: 'reference_audio',
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponÃ­vel`
                        });
                    } else {
                        console.log(`[REF-HEADROOM] âš ï¸ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB - bloqueando`);
                        referenceSuggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: `ImpossÃ­vel igualar referÃªncia - sem headroom suficiente`,
                            action: `True Peak ${userTruePeak.toFixed(1)}dBTP permite apenas +${availableHeadroom.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            baseline_source: 'reference_audio',
                            warning: `NecessÃ¡rio ${adjustmentDb.toFixed(1)}dB mas sÃ³ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    referenceSuggestions.push({
                        type: 'reference_loudness_conservative',
                        message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar referÃªncia (verificar clipping)`,
                        action: `${action} volume CUIDADOSAMENTE em ${adjustmentDb.toFixed(1)}dB`,
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        baseline_source: 'reference_audio',
                        warning: 'Sem dados True Peak - verifique clipping apÃ³s ajuste'
                    });
                }
            } else {
                // Diminuir Ã© sempre seguro
                referenceSuggestions.push({
                    type: 'reference_loudness',
                    message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar Ã  mÃºsica de referÃªncia`,
                    action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction,
                    baseline_source: 'reference_audio'
                });
            }
        }
        
        // Dynamic Range
        if (Math.abs(differences.dynamicRange) > THRESHOLD) {
            const action = differences.dynamicRange > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_dynamics',
                message: `${action} range dinÃ¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB para igualar Ã  referÃªncia`,
                action: `${action} range dinÃ¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.dynamicRange),
                baseline_source: 'reference_audio'
            });
        }
        
        // Stereo Correlation
        if (Math.abs(differences.stereoCorrelation) > 0.05) { // 5% threshold para correlaÃ§Ã£o
            const action = differences.stereoCorrelation > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_stereo',
                message: `${action} correlaÃ§Ã£o estÃ©reo para igualar Ã  referÃªncia (diferenÃ§a: ${(differences.stereoCorrelation * 100).toFixed(1)}%)`,
                action: `Ajustar correlaÃ§Ã£o estÃ©reo`,
                frequency_range: 'N/A',
                baseline_source: 'reference_audio'
            });
        }
        
        // Pico Real
        if (Math.abs(differences.truePeak) > THRESHOLD) {
            const action = differences.truePeak > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_peak',
                message: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB para igualar Ã  referÃªncia`,
                action: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.truePeak),
                baseline_source: 'reference_audio'
            });
        }
        
        console.log(`ğŸ” [COMPARAÃ‡ÃƒO] SugestÃµes geradas: ${referenceSuggestions.length}`);
        
        // ğŸ¯ CRIAR anÃ¡lise final com comparaÃ§Ã£o pura
        const finalAnalysis = {
            ...userAnalysis,
            comparison: {
                mode: 'reference',
                baseline_source: 'reference_audio',
                loudness: {
                    user: userMetrics.lufs,
                    reference: referenceMetrics.lufs,
                    difference: differences.lufs,
                    baseline: referenceMetrics.lufs
                },
                dynamics: {
                    user: userMetrics.dynamicRange,
                    reference: referenceMetrics.dynamicRange,
                    difference: differences.dynamicRange,
                    baseline: referenceMetrics.dynamicRange
                },
                stereo: {
                    user: userMetrics.stereoCorrelation,
                    reference: referenceMetrics.stereoCorrelation,
                    difference: differences.stereoCorrelation,
                    baseline: referenceMetrics.stereoCorrelation
                },
                peak: {
                    user: userMetrics.truePeak,
                    reference: referenceMetrics.truePeak,
                    difference: differences.truePeak,
                    baseline: referenceMetrics.truePeak
                }
            },
            suggestions: referenceSuggestions,
            // ğŸš« NUNCA usar gÃªnero em modo referÃªncia
            genre: null,
            mixScore: null, // NÃ£o gerar score baseado em gÃªnero
            mixClassification: null
        };
        
        // ğŸ¯ LOGS de validaÃ§Ã£o final
        console.log('ğŸ‰ [SUCESSO] ComparaÃ§Ã£o por referÃªncia concluÃ­da:');
        console.log('  - Modo:', finalAnalysis.comparison.mode);
        console.log('  - Baseline source:', finalAnalysis.comparison.baseline_source);
        console.log('  - SugestÃµes:', referenceSuggestions.length);
        console.log('  - Sem contaminaÃ§Ã£o de gÃªnero:', !finalAnalysis.genre);
        
        referenceStepState.finalAnalysis = finalAnalysis;
        console.log('ğŸ” [DIAGNÃ“STICO] Reference analysis tem comparaÃ§Ã£o com gÃªnero:', !!refAnalysis.comparison);
        
        // ğŸ¯ NOVO: Verificar se anÃ¡lises estÃ£o "limpas" (sem contaminar com gÃªnero)
        const userClean = !userAnalysis.comparison && !userAnalysis.reference;
        const refClean = !refAnalysis.comparison && !refAnalysis.reference;
        console.log('ğŸ” [DIAGNÃ“STICO] User analysis clean (sem gÃªnero):', userClean);
        console.log('ğŸ” [DIAGNÃ“STICO] Reference analysis clean (sem gÃªnero):', refClean);
        
        // Gerar comparaÃ§Ã£o
        const comparison = generateComparison(userAnalysis, refAnalysis);
        
        // ğŸ› DIAGNÃ“STICO: Verificar se comparison estÃ¡ usando os dados corretos
        console.log('ğŸ” [DIAGNÃ“STICO] Comparison gerada:', comparison);
        console.log('ğŸ” [DIAGNÃ“STICO] baseline_source: reference_audio (confirmed)');
        
        // Gerar sugestÃµes baseadas na comparaÃ§Ã£o
        const suggestions = generateReferenceSuggestions(comparison);
        
        // ğŸ› DIAGNÃ“STICO: Verificar se sugestÃµes sÃ£o baseadas apenas na comparison
        console.log('ğŸ” [DIAGNÃ“STICO] SugestÃµes geradas (count):', suggestions.length);
        console.log('ğŸ” [DIAGNÃ“STICO] Primeiro tipo de sugestÃ£o:', suggestions[0]?.type);
        
        // Criar anÃ¡lise combinada para exibiÃ§Ã£o
        const combinedAnalysis = {
            ...userAnalysis,
            comparison,
            suggestions: [...(userAnalysis.suggestions || []), ...suggestions],
            analysisMode: 'reference',
            referenceFile: referenceStepState.referenceAudioFile.name,
            userFile: referenceStepState.userAudioFile.name,
            // ğŸ¯ NOVO: Incluir mÃ©tricas da referÃªncia para renderReferenceComparisons
            referenceMetrics: {
                lufs: refAnalysis.technicalData?.lufsIntegrated,
                truePeakDbtp: refAnalysis.technicalData?.truePeakDbtp,
                dynamicRange: refAnalysis.technicalData?.dynamicRange,
                lra: refAnalysis.technicalData?.lra,
                stereoCorrelation: refAnalysis.technicalData?.stereoCorrelation,
                // ğŸ”§ CORREÃ‡ÃƒO: Criar estrutura de bands compatÃ­vel
                bands: refAnalysis.technicalData?.bandEnergies ? (() => {
                    const refBands = {};
                    const refBandEnergies = refAnalysis.technicalData.bandEnergies;
                    
                    // Criar estrutura de bands usando as mÃ©tricas da referÃªncia como targets
                    Object.entries(refBandEnergies).forEach(([bandName, bandData]) => {
                        if (bandData && Number.isFinite(bandData.rms_db)) {
                            refBands[bandName] = {
                                target_db: bandData.rms_db,  // Usar valor da referÃªncia como target
                                tol_db: 3.0,  // TolerÃ¢ncia padrÃ£o
                                _target_na: false
                            };
                        }
                    });
                    
                    return refBands;
                })() : null
            },
            // ğŸ› DIAGNÃ“STICO: Adicionar metadados para diagnÃ³stico
            _diagnostic: {
                baseline_source: 'reference_audio',
                mode: 'reference',
                userLufs: userAnalysis.technicalData?.lufsIntegrated,
                referenceLufs: refAnalysis.technicalData?.lufsIntegrated,
                difference: comparison.loudness?.difference,
                genreActive: window.PROD_AI_REF_GENRE,
                useGenreTargets: false,
                // ğŸ¯ NOVO: InformaÃ§Ãµes de normalizaÃ§Ã£o e janela
                usedWindowSeconds: 30, // TODO: pegar do analyzer quando implementado
                normalizedLUFS: {
                    user: userAnalysis.technicalData?.lufsIntegrated,
                    ref: refAnalysis.technicalData?.lufsIntegrated
                },
                analysisTimestamp: new Date().toISOString()
            }
        };
        
        console.log('ğŸ” [DIAGNÃ“STICO] Combined analysis diagnostic:', combinedAnalysis._diagnostic);
        
        currentModalAnalysis = combinedAnalysis;
        
        // ğŸ¯ ALIAS GLOBAL PARA RELATÃ“RIOS (Modo ReferÃªncia)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = combinedAnalysis;
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = combinedAnalysis;
            
            console.log('âœ… [PDF-READY] ComparaÃ§Ã£o armazenada globalmente:', {
                mode: 'reference',
                hasComparison: !!combinedAnalysis.comparison,
                userFile: combinedAnalysis.userFile,
                referenceFile: combinedAnalysis.referenceFile
            });
        }
        
        updateModalProgress(100, 'âœ¨ ComparaÃ§Ã£o Completa!');
        
        // Mostrar resultados
        setTimeout(() => {
            // ğŸ”’ UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
            const analysisRunId = combinedAnalysis?.runId || combinedAnalysis?.metadata?.runId;
            const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
            
            if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                console.warn(`ğŸš« [UI_GATE] ComparaÃ§Ã£o cancelada - nÃ£o renderizar UI (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
                return;
            }
            
            displayModalResults(combinedAnalysis);
            window.logReferenceEvent('reference_comparison_completed');
        }, 800);
        
    } catch (error) {
        console.error('âŒ Erro na comparaÃ§Ã£o:', error);
        window.logReferenceEvent('reference_comparison_error', { error: error.message });
        showModalError(`Erro na comparaÃ§Ã£o: ${error.message}`);
    }
}

// ğŸ¯ NOVO: Gerar comparaÃ§Ã£o entre duas anÃ¡lises
function generateComparison(userAnalysis, refAnalysis) {
    const userTech = userAnalysis.technicalData || {};
    const refTech = refAnalysis.technicalData || {};
    
    return {
        loudness: {
            user: userTech.lufsIntegrated || null,
            reference: refTech.lufsIntegrated || null,
            difference: (userTech.lufsIntegrated && refTech.lufsIntegrated) 
                ? userTech.lufsIntegrated - refTech.lufsIntegrated 
                : null
        },
        dynamics: {
            user: userTech.lra || userTech.crestFactor || null,
            reference: refTech.lra || refTech.crestFactor || null,
            difference: (userTech.lra && refTech.lra) 
                ? userTech.lra - refTech.lra 
                : null
        },
        stereo: {
            user: userTech.stereoCorrelation || null,
            reference: refTech.stereoCorrelation || null,
            difference: (userTech.stereoCorrelation && refTech.stereoCorrelation) 
                ? userTech.stereoCorrelation - refTech.stereoCorrelation 
                : null
        },
        spectral: compareSpectralData(userTech, refTech)
    };
}

// ğŸ¯ NOVO: Comparar dados espectrais
function compareSpectralData(userTech, refTech) {
    const bandNames = ['subBass', 'bass', 'lowMid', 'mid', 'upperMid', 'presence', 'brilliance', 'air'];
    const comparisons = {};
    
    bandNames.forEach(band => {
        const userValue = userTech[`${band}Energy`] || userTech[`energy_${band}`] || null;
        const refValue = refTech[`${band}Energy`] || refTech[`energy_${band}`] || null;
        
        if (userValue !== null && refValue !== null) {
            comparisons[band] = {
                user: userValue,
                reference: refValue,
                difference: userValue - refValue
            };
        }
    });
    
    return comparisons;
}

// ğŸ¯ NOVO: Gerar sugestÃµes baseadas na comparaÃ§Ã£o
function generateReferenceSuggestions(comparison) {
    // ğŸ› DIAGNÃ“STICO: Logs para verificar fonte dos dados
    console.log('ğŸ” [DIAGNÃ“STICO] generateReferenceSuggestions called with:', comparison);
    console.log('ğŸ” [DIAGNÃ“STICO] Usando APENAS dados da comparison, nÃ£o genre targets');
    console.log('ğŸ” [DIAGNÃ“STICO] Genre ativo (NÃƒO usado):', window.PROD_AI_REF_GENRE);
    
    const suggestions = [];
    
    // SugestÃµes de loudness - ğŸš¨ COM VERIFICAÃ‡ÃƒO DE HEADROOM SEGURO
    if (comparison.loudness.difference !== null) {
        const diff = comparison.loudness.difference;
        console.log('ğŸ” [DIAGNÃ“STICO] Loudness difference:', diff);
        
        if (Math.abs(diff) > 1) {
            const adjustmentDb = Math.abs(diff);
            const direction = diff > 0 ? 'decrease' : 'increase';
            
            // ğŸ”’ Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                // Tentar acessar dados do usuÃ¡rio para verificaÃ§Ã£o de headroom
                const userTruePeak = comparison.userTruePeak || null;
                const userClipping = comparison.userClipping || 0;
                const isClipped = userClipping > 0;
                const headroomSafetyMargin = -0.6;
                
                if (isClipped) {
                    console.log(`[REF-HEADROOM] ğŸš¨ Clipping detectado - bloqueando aumento de ${adjustmentDb.toFixed(1)}dB`);
                    suggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: 'ImpossÃ­vel igualar referÃªncia - Ã¡udio tem clipping',
                        action: 'Primeiro resolver clipping, depois ajustar para referÃªncia',
                        explanation: 'Clipping detectado impede aumento seguro',
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        warning: `Clipping detectado (${userClipping} samples)`
                    });
                } else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        const suggestion = {
                            type: 'reference_loudness',
                            message: 'Sua mÃºsica estÃ¡ mais baixa que a referÃªncia',
                            action: `Aumentar volume em ${adjustmentDb.toFixed(1)}dB`,
                            explanation: 'Para match de loudness com a referÃªncia',
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponÃ­vel`
                        };
                        suggestions.push(suggestion);
                    } else {
                        console.log(`[REF-HEADROOM] âš ï¸ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB`);
                        suggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: 'ImpossÃ­vel igualar referÃªncia - sem headroom suficiente',
                            action: `True Peak permite apenas +${availableHeadroom.toFixed(1)}dB (necessÃ¡rio ${adjustmentDb.toFixed(1)}dB)`,
                            explanation: 'Aumentar mais causaria clipping (True Peak > -0.6 dBTP)',
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            warning: `NecessÃ¡rio ${adjustmentDb.toFixed(1)}dB mas sÃ³ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    suggestions.push({
                        type: 'reference_loudness_conservative',
                        message: 'Sua mÃºsica estÃ¡ mais baixa que a referÃªncia (verificar clipping)',
                        action: `Aumentar CUIDADOSAMENTE volume em ${adjustmentDb.toFixed(1)}dB`,
                        explanation: 'Sem dados True Peak - risco de clipping',
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        warning: 'Verifique clipping apÃ³s ajuste'
                    });
                }
            } else {
                // Diminuir Ã© sempre seguro
                const suggestion = {
                    type: 'reference_loudness',
                    message: 'Sua mÃºsica estÃ¡ mais alta que a referÃªncia',
                    action: `Diminuir volume em ${adjustmentDb.toFixed(1)}dB`,
                    explanation: 'Para match de loudness com a referÃªncia',
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction
                };
                suggestions.push(suggestion);
            }
            
            console.log('ğŸ” [DIAGNÃ“STICO] SugestÃ£o de loudness processada com headroom check');
        }
    }
    
    // SugestÃµes espectrais
    Object.entries(comparison.spectral).forEach(([band, data]) => {
        console.log(`ğŸ” [DIAGNÃ“STICO] Spectral band ${band}:`, data);
        
        if (Math.abs(data.difference) > 2) {
            const freqRanges = {
                subBass: '20-60 Hz',
                bass: '60-250 Hz',
                lowMid: '250-500 Hz',
                mid: '500-2k Hz',
                upperMid: '2k-4k Hz',
                presence: '4k-6k Hz',
                brilliance: '6k-12k Hz',
                air: '12k-20k Hz'
            };
            
            const suggestion = {
                type: 'reference_spectral',
                message: data.difference > 0 ? `Muito ${band} comparado Ã  referÃªncia` : `Pouco ${band} comparado Ã  referÃªncia`,
                action: data.difference > 0 ? `Cortar ${band}` : `RealÃ§ar ${band}`,
                explanation: `Para match espectral com a referÃªncia`,
                frequency_range: freqRanges[band] || 'N/A',
                adjustment_db: Math.abs(data.difference),
                direction: data.difference > 0 ? 'cut' : 'boost',
                q_factor: 1.0
            };
            
            console.log(`ğŸ” [DIAGNÃ“STICO] Adicionando sugestÃ£o espectral para ${band}:`, suggestion);
            suggestions.push(suggestion);
        }
    });
    
    console.log('ğŸ” [DIAGNÃ“STICO] Total sugestÃµes geradas:', suggestions.length);
    console.log('ğŸ” [DIAGNÃ“STICO] baseline_source: reference_audio (confirmed)');
    
    return suggestions;
}

// ğŸ¯ NOVO: Adicionar seÃ§Ã£o de comparaÃ§Ã£o com referÃªncia
function addReferenceComparisonSection(analysis) {
    const results = document.getElementById('audioAnalysisResults');
    if (!results) return;
    
    const comparison = analysis.comparison;
    const userFile = analysis.userFile || 'Sua mÃºsica';
    const referenceFile = analysis.referenceFile || 'MÃºsica de referÃªncia';
    
    // Criar seÃ§Ã£o de comparaÃ§Ã£o
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'reference-comparison-section';
    comparisonSection.innerHTML = `
        <div class="comparison-header">
            <h4>ğŸ¯ ComparaÃ§Ã£o com ReferÃªncia</h4>
            <div class="comparison-files">
                <span class="file-indicator user">ğŸ“„ ${userFile}</span>
                <span class="vs-indicator">vs</span>
                <span class="file-indicator reference">ğŸ¯ ${referenceFile}</span>
            </div>
        </div>
        
        <div class="comparison-content">
            <div class="comparison-grid">
                ${generateComparisonRow('Loudness', comparison.loudness, 'LUFS')}
                ${generateComparisonRow('Faixa DinÃ¢mica', comparison.dynamics, 'dB')}
                ${generateComparisonRow('CorrelaÃ§Ã£o EstÃ©reo', comparison.stereo, '')}
            </div>
            
            ${comparison.spectral && Object.keys(comparison.spectral).length > 0 ? `
                <div class="spectral-comparison">
                    <h5>ğŸ“Š AnÃ¡lise Espectral</h5>
                    <div class="spectral-grid">
                        ${Object.entries(comparison.spectral).map(([band, data]) => 
                            generateSpectralComparisonCard(band, data)
                        ).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
    
    // Inserir no inÃ­cio da seÃ§Ã£o de resultados
    const resultsHeader = results.querySelector('.results-header');
    if (resultsHeader) {
        resultsHeader.insertAdjacentElement('afterend', comparisonSection);
    } else {
        results.insertBefore(comparisonSection, results.firstChild);
    }
    
    window.logReferenceEvent('comparison_section_displayed');
}

// ğŸ¯ NOVO: Gerar linha de comparaÃ§Ã£o
function generateComparisonRow(label, comparisonData, unit) {
    if (!comparisonData || comparisonData.difference === null) {
        return `
            <div class="comparison-row unavailable">
                <div class="comparison-label">${label}</div>
                <div class="comparison-values">
                    <span class="comparison-unavailable">Dados insuficientes</span>
                </div>
            </div>
        `;
    }
    
    const userValue = comparisonData.user?.toFixed?.(1) || comparisonData.user || 'â€”';
    const refValue = comparisonData.reference?.toFixed?.(1) || comparisonData.reference || 'â€”';
    const diff = comparisonData.difference?.toFixed?.(1) || 'â€”';
    const diffClass = comparisonData.difference > 0 ? 'positive' : comparisonData.difference < 0 ? 'negative' : 'neutral';
    
    return `
        <div class="comparison-row">
            <div class="comparison-label">${label}</div>
            <div class="comparison-values">
                <div class="value-pair">
                    <span class="user-value">${userValue}${unit}</span>
                    <span class="ref-value">${refValue}${unit}</span>
                </div>
                <div class="difference-indicator ${diffClass}">
                    ${diff > 0 ? '+' : ''}${diff}${unit}
                </div>
            </div>
        </div>
    `;
}

// ğŸ¯ NOVO: Gerar card de comparaÃ§Ã£o espectral
function generateSpectralComparisonCard(band, data) {
    const bandNames = {
        subBass: 'Sub Bass',
        bass: 'Bass',
        lowMid: 'Low Mid',
        mid: 'Mid',
        upperMid: 'Upper Mid',
        presence: 'Presence',
        brilliance: 'Brilliance',
        air: 'Air'
    };
    
    const friendlyName = bandNames[band] || band;
    const diff = data.difference?.toFixed?.(1) || 'â€”';
    const diffClass = data.difference > 2 ? 'high-positive' : 
                      data.difference > 0.5 ? 'positive' : 
                      data.difference < -2 ? 'high-negative' : 
                      data.difference < -0.5 ? 'negative' : 'neutral';
    
    return `
        <div class="spectral-card ${diffClass}">
            <div class="spectral-band-name">${friendlyName}</div>
            <div class="spectral-difference">${diff > 0 ? '+' : ''}${diff}dB</div>
        </div>
    `;
}

// â³ Aguardar Audio Analyzer carregar
function waitForAudioAnalyzer() {
    return new Promise((resolve) => {
        if (window.audioAnalyzer) {
            resolve();
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (window.audioAnalyzer) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
        
        // Timeout apÃ³s 10 segundos
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
        }, 10000);
    });
}

// ï¿½ Atualizar progresso no modal
function updateModalProgress(percentage, message) {
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
    
    if (progressText) {
        progressText.textContent = message || `${percentage}%`;
    }
    
    __dbg(`ğŸ“ˆ Progresso: ${percentage}% - ${message}`);
}

// âŒ Mostrar erro no modal
function showModalError(message) {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    if (results) {
        results.style.display = 'block';
        results.innerHTML = `
            <div style="color: #ff4444; text-align: center; padding: 30px;">
                <div style="font-size: 3em; margin-bottom: 15px;">âš ï¸</div>
                <h3 style="margin: 0 0 15px 0; color: #ff4444;">Erro na AnÃ¡lise</h3>
                <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">${message}</p>
                <button onclick="resetModalState()" style="
                    background: #ff4444; 
                    color: white; 
                    border: none; 
                    padding: 12px 25px; 
                    border-radius: 6px; 
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: background 0.3s;
                " onmouseover="this.style.background='#ff3333'" 
                   onmouseout="this.style.background='#ff4444'">
                    Tentar Novamente
                </button>
            </div>
        `;
    }
}

// ï¿½ğŸ”„ Mostrar loading no modal
function showModalLoading() {
    __dbg('ğŸ”„ Exibindo tela de loading no modal...');
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    // ğŸ”§ CORREÃ‡ÃƒO: Garantir que o loading seja exibido corretamente
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    }
    if (results) {
        results.style.display = 'none';
        __dbg('âœ… Results area ocultada');
    }
    if (loading) {
        loading.style.display = 'block';
        __dbg('âœ… Loading area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
    
    // Reset progress
    updateModalProgress(0, 'ğŸ”„ Inicializando Engine de AnÃ¡lise...');
    __dbg('âœ… Progresso resetado e loading configurado');
}

// ğŸ“ˆ Simular progresso
// (funÃ§Ã£o de simulaÃ§Ã£o de progresso removida â€” nÃ£o utilizada)

// ğŸ“Š Mostrar resultados no modal
// ğŸ“Š Mostrar resultados no modal
async function displayModalResults(analysis) {
    console.log('[DEBUG-DISPLAY] ğŸ§  InÃ­cio displayModalResults()');

    // ========================================
    // âœ… CORREÃ‡ÃƒO 2: RESTAURAÃ‡ÃƒO DE DADOS DE REFERÃŠNCIA
    // ========================================
    // Verifica se dados de referÃªncia foram perdidos e restaura do cache
    
    // ğŸ¯ CORREÃ‡ÃƒO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
    console.group('ğŸ” [AUDIT-LOCALSTORAGE] displayModalResults - Leitura de referenceJobId');
    console.log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - Antes: window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    console.log('   - Mode:', currentAnalysisMode);
    
    // ğŸ¯ USA FUNÃ‡ÃƒO SEGURA ao invÃ©s de acesso direto
    const referenceJobId = getCorrectJobId('reference'); // Primeira mÃºsica
    
    console.log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
    console.trace('   - Stack trace:');
    console.groupEnd();
    
    if (referenceJobId && currentAnalysisMode === 'reference') {
        // Verificar se dados de referÃªncia estÃ£o ausentes
        const hasReferenceData = window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__;
        const hasFirstAnalysisStore = FirstAnalysisStore.has();
        
        if (!hasReferenceData && !hasFirstAnalysisStore) {
            console.warn('[RESTORE] âš ï¸ Dados de referÃªncia ausentes - tentando restaurar do cache');
            console.log('[RESTORE] referenceJobId:', referenceJobId);
            
            // Tentar restaurar do AnalysisCache
            if (window.AnalysisCache && window.AnalysisCache.has(referenceJobId)) {
                const cachedReference = window.AnalysisCache.get(referenceJobId);
                
                if (cachedReference) {
                    console.log('[RESTORE] âœ… ReferÃªncia encontrada no AnalysisCache');
                    
                    // Clone profundo para evitar contaminaÃ§Ã£o
                    const restoredReference = (typeof structuredClone === 'function')
                        ? structuredClone(cachedReference)
                        : JSON.parse(JSON.stringify(cachedReference));
                    
                    // Restaurar para FirstAnalysisStore
                    if (FirstAnalysisStore && typeof FirstAnalysisStore.set === 'function') {
                        FirstAnalysisStore.set(restoredReference);
                        console.log('[RESTORE] âœ… ReferÃªncia restaurada no FirstAnalysisStore');
                    }
                    
                    // Restaurar window.referenceAnalysisData
                    window.referenceAnalysisData = restoredReference;
                    window.__FIRST_ANALYSIS_FROZEN__ = Object.freeze(restoredReference);
                    
                    console.log('[RESTORE] âœ… Dados de referÃªncia completamente restaurados:', {
                        jobId: restoredReference.jobId,
                        fileName: restoredReference.metadata?.fileName || restoredReference.fileName
                    });
                } else {
                    console.error('[RESTORE] âŒ ReferÃªncia no cache estÃ¡ vazia');
                }
            } else {
                console.error('[RESTORE] âŒ ReferÃªncia nÃ£o encontrada no AnalysisCache');
                console.error('[RESTORE] Cache IDs disponÃ­veis:', window.AnalysisCache?.ids?.() || 'N/A');
            }
        } else {
            console.log('[RESTORE] âœ… Dados de referÃªncia jÃ¡ existem - restauraÃ§Ã£o nÃ£o necessÃ¡ria');
        }
    }

    // ========================================
    // âœ… PROTEÃ‡ÃƒO DEFINITIVA CONTRA ERRO DE INTERFACE
    // ========================================
    // Espera o mÃ³dulo aiUIController inicializar antes de renderizar
    let tries = 0;
    const MAX_TRIES = 30;
    const WAIT_MS = 150;

    while (
        (!window.aiUIController ||
         typeof window.aiUIController.renderMetricCards !== 'function' ||
         typeof window.aiUIController.renderScoreSection !== 'function') &&
        tries < MAX_TRIES
    ) {
        await new Promise(r => setTimeout(r, WAIT_MS));
        tries++;
        if (tries % 5 === 0) {
            console.warn(`[WAIT] aguardando aiUIController carregar... tentativa ${tries}`);
        }
    }

    // Falha definitiva â€” controller nunca carregou
    if (
        !window.aiUIController ||
        typeof window.aiUIController.renderMetricCards !== 'function'
    ) {
        console.error('[FATAL] aiUIController nÃ£o carregado apÃ³s todas as tentativas');
        alert('Erro ao carregar interface de resultados. Recarregue a pÃ¡gina.');
        return;
    }

    console.log('[SAFE] âœ… aiUIController detectado, renderizaÃ§Ã£o liberada.');

    // ========================================
    // âœ… CORREÃ‡ÃƒO 2: AB SAFETY - HidrataÃ§Ã£o e ForÃ§ar Modo Reference
    // ========================================
    const abState = ensureReferenceHydrated();
    const _modeNow = window.currentAnalysisMode || window.__soundyState?.render?.mode;

    // Se Ã© segunda faixa e temos refId vÃ¡lido, o modo Ã© obrigatoriamente 'reference'
    const isSecondTrack = !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has?.());
    if (isSecondTrack && _modeNow !== 'reference') {
        window.currentAnalysisMode = 'reference';
        if (window.__soundyState?.render) window.__soundyState.render.mode = 'reference';
        console.warn('[AB-FORCE] ForÃ§ando mode=reference porque hÃ¡ segunda faixa + referenceId.');
    }

    // Validar referÃªncia
    if (isSecondTrack && (!abState.ok || !window.referenceAnalysisData?.bands)) {
        console.error('[AB-BLOCK] ReferÃªncia nÃ£o hidratada para comparaÃ§Ã£o', abState);
        console.error('[AB-BLOCK] Segunda faixa detectada mas sem referÃªncia vÃ¡lida - abortando comparaÃ§Ã£o A/B');
        // NÃ£o degrade para genre; aborte a comparaÃ§Ã£o para evitar self-compare
        // Continue renderizando cards da segunda faixa normalmente (modo single)
    } else if (isSecondTrack) {
        console.log('[AB-SAFETY] âœ… ReferÃªncia validada:', {
            ok: abState.ok,
            refId: abState.refId,
            hasBands: abState.hasBands,
            file: abState.file
        });
    }

    // =========================================================================
    // ğŸ†” INFO: Sistema agora usa Virtual IDs (VID) para separaÃ§Ã£o por papel
    // =========================================================================
    // Mesmo que jobIds sejam iguais, Virtual IDs (jobId::USER e jobId::REF) mantÃªm separaÃ§Ã£o
    // O bloqueio de self-compare agora Ã© feito por conteÃºdo em renderReferenceComparisons
    console.log('[VID-INFO] âœ… Sistema usa Virtual IDs - jobId reutilizado nÃ£o causa self-compare', {
        currentJobId: analysis?.jobId,
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        storeHasUser: !!FirstAnalysisStore.getUser(),
        storeHasRef: !!FirstAnalysisStore.getRef()
    });
    
    // âœ… HARD-GUARD: Validar FirstAnalysisStore - se vazio, Ã© modo genre (nÃ£o reference)
    if (!FirstAnalysisStore.has()) {
        console.log('[INFO] FirstAnalysisStore vazio - modo genre (nÃ£o reference). Continuando render normalmente.');
        // âœ… NÃƒO RETORNA AQUI! Modo genre nÃ£o precisa de primeira anÃ¡lise
    } else {
        console.log('[HARD-GUARD] âœ… FirstAnalysisStore validado - primeira anÃ¡lise protegida:', {
            jobId: FirstAnalysisStore.get()?.jobId,
            fileName: FirstAnalysisStore.get()?.metadata?.fileName
        });
    }
    
    // =========================================================================
    // ï¿½ğŸš¨ DEBUG CRÃTICO: Timing e Estado dos Dados (detecta chamada prematura)
    // =========================================================================
    console.groupCollapsed("[DEBUG-DISPLAY] ğŸ§  InÃ­cio displayModalResults()");
    console.log("ğŸ“¦ analysis.metadata.fileName:", analysis?.metadata?.fileName);
    console.log("ğŸ§Š FirstAnalysisStore:", FirstAnalysisStore.has() ? FirstAnalysisStore.get()?.metadata?.fileName : 'null');
    console.log("ğŸ“Š analysis.metrics:", !!analysis?.metrics, "technicalData:", !!analysis?.technicalData);
    const storedFirstForDebug = FirstAnalysisStore.get();
    console.log("ğŸ“Š first.metrics:", !!storedFirstForDebug?.metrics, "technicalData:", !!storedFirstForDebug?.technicalData);
    console.groupEnd();
    
    // =========================================================================
    // ğŸš¨ AUDITORIA COMPLETA EM TEMPO DE EXECUÃ‡ÃƒO - DESCOBRIR POR QUE NÃƒO RENDERIZA
    // =========================================================================
    try {
        console.groupCollapsed('[AUDITORIA_REFERENCE_MODE] ğŸ” INVESTIGAÃ‡ÃƒO COMPLETA');
        console.log('[STEP 1] ğŸ” Modo recebido:', analysis?.mode);
        console.log('[STEP 2] ğŸ” ContÃ©m metrics?', !!analysis?.metrics);
        console.log('[STEP 3] ğŸ” ContÃ©m technicalData?', !!analysis?.technicalData);
        console.log('[STEP 4] ğŸ” ContÃ©m suggestions?', !!analysis?.suggestions);
        console.log('[STEP 5] ğŸ” FunÃ§Ãµes disponÃ­veis:', {
            renderMetricCards: typeof window.renderMetricCards,
            renderScoreSection: typeof window.renderScoreSection,
            renderSuggestions: typeof window.renderSuggestions,
            renderFinalScoreAtTop: typeof window.renderFinalScoreAtTop,
            renderAdvancedMetrics: typeof window.renderAdvancedMetrics,
        });
        console.log('[STEP 6] ğŸ” analysis (safe):', safeStringify(analysis || {}));
        console.groupEnd();
    } catch (e) {
        console.warn('[AUDITORIA_REFERENCE_MODE] âš ï¸ Falha ao logar analysis:', e.message);
    }
    
    // ğŸ” AUDITORIA: Estado AO ENTRAR em displayModalResults
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸš€ displayModalResults - ENTRADA');
    console.log('âš™ï¸ FunÃ§Ã£o: displayModalResults');
    console.log('ğŸ“Š analysis (parÃ¢metro recebido):', {
        jobId: analysis?.jobId,
        fileName: analysis?.metadata?.fileName || analysis?.fileName,
        lufs: analysis?.technicalData?.lufsIntegrated,
        mode: analysis?.mode,
        objectId: analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis
    });
    console.log('ğŸ§ analysis.userAnalysis:', analysis?.userAnalysis ? {
        fileName: analysis.userAnalysis?.metadata?.fileName || analysis.userAnalysis?.fileName,
        jobId: analysis.userAnalysis?.jobId,
        lufs: analysis.userAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.userAnalysis
    } : 'null');
    console.log('ğŸ§ analysis.referenceAnalysis:', analysis?.referenceAnalysis ? {
        fileName: analysis.referenceAnalysis?.metadata?.fileName || analysis.referenceAnalysis?.fileName,
        jobId: analysis.referenceAnalysis?.jobId,
        lufs: analysis.referenceAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.referenceAnalysis
    } : 'null');
    console.log('ğŸŒ Estado global atual:');
    const storedFirstForAudit = FirstAnalysisStore.get();
    console.log('  FirstAnalysisStore:', storedFirstForAudit ? {
        fileName: storedFirstForAudit.metadata?.fileName,
        jobId: storedFirstForAudit.jobId,
        lufs: storedFirstForAudit.technicalData?.lufsIntegrated
    } : 'null');
    console.log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
        fileName: window.__soundyState.previousAnalysis?.metadata?.fileName || window.__soundyState.previousAnalysis?.fileName,
        jobId: window.__soundyState.previousAnalysis?.jobId
    } : 'null');
    console.log('âš ï¸ VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
    console.log('  analysis.userAnalysis === analysis.referenceAnalysis?', analysis?.userAnalysis === analysis?.referenceAnalysis);
    console.groupEnd();
    
    // ğŸ¯ LOG INICIAL PARA CONFIRMAR CHAMADA DA FUNÃ‡ÃƒO APÃ“S CORREÃ‡Ã•ES
    console.log("âœ… [DISPLAY_MODAL] FunÃ§Ã£o displayModalResults chamada com dados:", analysis);
    console.log("âœ… [DISPLAY_MODAL] Estrutura dos dados recebidos:", Object.keys(analysis || {}));
    
    // ğŸ”’ PROTEÃ‡ÃƒO MODO REFERENCE: Evitar sobrescrita por interceptores
    if (analysis && analysis.mode === "reference") {
        const previous = window.__soundyState?.previousAnalysis;
        const user = analysis.userAnalysis || previous;
        const ref = analysis.referenceAnalysis || 
                    window.__soundyState?.referenceAnalysis || 
                    window.__soundyState?.reference?.referenceAnalysis || 
                    null;

        console.log("[REFERENCE-FLOW âœ…] ComparaÃ§Ã£o direta A/B antes da renderizaÃ§Ã£o:", {
            userTrack: user?.fileName || user?.metadata?.fileName,
            referenceTrack: ref?.fileName || ref?.metadata?.fileName,
            hasUserBands: !!(user?.technicalData?.spectral_balance || user?.bands),
            hasRefBands: !!(ref?.technicalData?.spectral_balance || ref?.bands),
        });

        // ğŸ”’ ProteÃ§Ã£o contra sobrescrita por interceptores
        if (user) Object.freeze(user);
        if (ref) Object.freeze(ref);

        const payload = {
            mode: "reference",
            userAnalysis: user,
            referenceAnalysis: ref,
        };

        // ==== PATCH 3: DEFINITIVO - FirstAnalysisStore + refHardGuards ====
        const first = FirstAnalysisStore.get();
        
        if (!first) {
            console.error('[A/B] âŒ Primeira anÃ¡lise nÃ£o encontrada no FirstAnalysisStore');
            console.warn('[A/B] âš ï¸ Renderizando apenas segunda anÃ¡lise como single');
            
            // Renderiza apenas a segunda como single (fallback seguro)
            if (typeof window.aiUIController !== 'undefined') {
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            return; // nÃ£o prossegue sem primeira anÃ¡lise
        }

        // âœ… MONTAGEM A/B COM ISOLAMENTO COMPLETO
        let userFull = first; // 1Âª faixa (jÃ¡ Ã© clone do FirstAnalysisStore.get())
        let refFull = (typeof structuredClone === 'function')
            ? structuredClone(analysis)
            : JSON.parse(JSON.stringify(analysis)); // 2Âª faixa (clone explÃ­cito)

        // ï¿½ï¸ APLICAR GUARDS: Isola jobIds se forem iguais
        ({ userFull, refFull } = refHardGuards({ userFull, refFull }));

        // ğŸ”¬ GERAR SUGESTÃ•ES COMPARATIVAS A vs B (se ainda nÃ£o existirem)
        const hasExistingSuggestions = Array.isArray(userFull?.aiSuggestions) && userFull.aiSuggestions.length > 0;
        
        if (!hasExistingSuggestions) {
            console.log('[A/B-FLOW] ğŸ”¬ Gerando sugestÃµes comparativas A vs B...');
            const comparativeSuggestions = buildComparativeAISuggestions(userFull, refFull);
            
            if (comparativeSuggestions.length > 0) {
                // Injetar sugestÃµes comparativas no userFull
                userFull.aiSuggestions = comparativeSuggestions;
                userFull.hasEnriched = true;
                userFull.mode = "compare";
                
                console.log('[A/B-FLOW] âœ… SugestÃµes comparativas injetadas:', {
                    quantidade: comparativeSuggestions.length,
                    categorias: comparativeSuggestions.map(s => s.categoria).join(', ')
                });
            } else {
                console.warn('[A/B-FLOW] âš ï¸ Nenhuma sugestÃ£o comparativa gerada - mÃ©tricas insuficientes');
            }
        } else {
            console.log('[A/B-FLOW] â„¹ï¸ SugestÃµes jÃ¡ existem - pulando geraÃ§Ã£o comparativa');
        }

        // âœ… RENDER COMPLETO (nunca aborta por contaminaÃ§Ã£o - trabalha direto nos objetos)
        if (typeof window.aiUIController !== 'undefined') {
            window.aiUIController.renderMetricCards({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderScoreSection({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderSuggestions({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderFinalScoreAtTop({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.checkForAISuggestions({ mode: 'reference', user: userFull, reference: refFull });
        }

        console.log('[A/B-END] âœ…', {
            userFile: userFull?.fileName || userFull?.metadata?.fileName,
            refFile: refFull?.fileName || refFull?.metadata?.fileName,
            userId: userFull?.jobId || userFull?.id,
            refId: refFull?.jobId || refFull?.id
        });
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA DA AUDITORIA (linha 4502)
        // REMOVIDO return prematuro que bloqueava:
        // - NormalizaÃ§Ã£o de dados (linha 4822)
        // - CÃ¡lculo de scores (linha 4889)
        // - RenderizaÃ§Ã£o de cards (linha 6623)
        // - renderFinalScoreAtTop() (linha 6620)
        // - advancedMetricsCard() (linha 6636)
        // âŒ return; â† REMOVIDO
        
        console.log('[AUDIT-CORRECTION] âœ… Fluxo continuarÃ¡ para renderizar cards, scores e sugestÃµes');
        console.log('[AUDIT-CORRECTION] âœ… Return prematuro removido - pipeline completo ativado');
    }
    
    // [AUDIT-FLOW-CHECK] Verificar se chegou aqui (deveria chegar sempre, inclusive no modo reference)
    console.log('[AUDIT-FLOW-CHECK] âœ… Fluxo continua apÃ³s bloco reference - modo:', analysis?.mode);
    
    // ğŸ”’ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que mÃ©tricas essenciais estÃ£o presentes
    // CORRIGIDO: Verificar novos caminhos do backend Redis
    const hasEssentialMetrics = (
        analysis?.technicalData && 
        (
            Number.isFinite(analysis.technicalData.lufsIntegrated) ||
            Number.isFinite(analysis.technicalData.lufs_integrated) ||
            Number.isFinite(analysis.technicalData.avgLoudness) ||
            Number.isFinite(analysis.technicalData.dynamicRange) ||
            // NOVOS CAMINHOS: Estrutura do backend Redis
            Number.isFinite(analysis.loudness?.integrated) ||
            Number.isFinite(analysis.technicalData?.dr) ||
            // Fallback: Se tem score, provavelmente tem dados vÃ¡lidos
            Number.isFinite(analysis.score)
        )
    );
    
    if (!hasEssentialMetrics) {
        console.warn('âš ï¸ [UI_GATE] Aguardando mÃ©tricas essenciais... anÃ¡lise incompleta:', analysis);
        console.log('ğŸ” [UI_GATE] Debug - estrutura recebida:', {
            technicalData: analysis?.technicalData,
            loudness: analysis?.loudness,
            score: analysis?.score,
            hasScore: Number.isFinite(analysis?.score)
        });
        
        // CORREÃ‡ÃƒO: Verificar se Ã© estrutura nova mas vÃ¡lida
        if (analysis?.loudness || analysis?.technicalData || Number.isFinite(analysis?.score)) {
            console.warn("âš ï¸ [UI_GATE] Estrutura nova detectada, prosseguindo com dados disponÃ­veis");
        } else {
            console.warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: hasEssentialMetrics falhou - mode:', analysis?.mode);
            console.warn('[AUDITORIA_TIMING] normalizeBackendAnalysisData terminado?', !!window.currentAnalysisData);
            console.warn('[AUDITORIA_TIMING] displayModalResults chamado?', performance.now());
            // Tentar novamente em 2 segundos apenas se realmente nÃ£o hÃ¡ dados
            setTimeout(() => displayModalResults(analysis), 2000);
            return;
        }
    }
    
    console.log('âœ… [UI_GATE] MÃ©tricas essenciais presentes, exibindo resultados');
    
    // ğŸ”¥ CORREÃ‡ÃƒO COMPARAÃ‡ÃƒO A/B: Usar _userAnalysis (1Âª faixa = sua mÃºsica) para cards/mÃ©tricas
    if (analysis._isReferenceMode && analysis._userAnalysis && analysis._referenceAnalysis) {
        console.log('[REFERENCE-DISPLAY] ğŸ¯ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('[REFERENCE-DISPLAY] ğŸ¯ Modo A/B detectado - ConfiguraÃ§Ã£o correta:');
        console.log('[REFERENCE-DISPLAY] âœ… 1Âª faixa (SUA MÃšSICA/ATUAL):', analysis._userAnalysis?.fileName || analysis._userAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] âœ… 2Âª faixa (REFERÃŠNCIA/ALVO):', analysis._referenceAnalysis?.fileName || analysis._referenceAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] ğŸ“Š Cards principais: mostrarÃ£o mÃ©tricas da SUA MÃšSICA (1Âª faixa)');
        console.log('[REFERENCE-DISPLAY] ğŸ“Š Tabela comparativa: SUA MÃšSICA (esquerda) vs REFERÃŠNCIA (direita)');
        console.log('[REFERENCE-DISPLAY] ğŸ¯ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // Salvar anÃ¡lise de referÃªncia antes de substituir
        const originalReferenceAnalysis = analysis._referenceAnalysis;
        
        // SUBSTITUIR analysis pelos dados da PRIMEIRA faixa (sua mÃºsica/atual) para renderizaÃ§Ã£o dos cards
        const firstTrackAnalysis = analysis._userAnalysis;
        
        // Copiar propriedades importantes
        analysis = {
            ...firstTrackAnalysis,
            _isReferenceMode: true,
            _userAnalysis: firstTrackAnalysis,
            _referenceAnalysis: originalReferenceAnalysis,
            mode: 'reference' // Manter modo para lÃ³gica posterior
        };
        
        console.log('[REFERENCE-DISPLAY âœ…] Analysis substituÃ­do por dados da sua mÃºsica (1Âª faixa)');
        console.log('[REFERENCE-DISPLAY] MÃ©tricas da SUA MÃšSICA a serem exibidas nos cards:', {
            lufs: analysis.technicalData?.lufsIntegrated || analysis.loudness?.integrated,
            dr: analysis.technicalData?.dynamicRange || analysis.technicalData?.dr,
            tp: analysis.technicalData?.truePeakDbtp || analysis.truePeak?.maxDbtp
        });
    }
    
    // ğŸ¯ DETECÃ‡ÃƒO DE MODO COMPARAÃ‡ÃƒO ENTRE FAIXAS
    const isSecondTrackCheck = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
    const mode = analysis?.mode || currentAnalysisMode;
    
    // ğŸ”´ğŸ”´ğŸ”´ DIAGNÃ“STICO CRÃTICO: Por que nÃ£o estÃ¡ entrando no bloco A/B?
    console.log('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB] Valores das variÃ¡veis da condicional:');
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   analysis?.mode:', analysis?.mode);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   currentAnalysisMode:', currentAnalysisMode);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   mode (final):', mode);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   isSecondTrackCheck:', isSecondTrackCheck);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB] Condicional serÃ¡:', mode === 'reference' && isSecondTrackCheck);
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   mode === "reference"?', mode === 'reference');
    console.log('ğŸ”´ [DIAGNÃ“STICO-AB]   isSecondTrackCheck?', isSecondTrackCheck);
    console.log('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    // ğŸ¯ DEFINIR MODO NO ESTADO ANTES DE QUALQUER CÃLCULO
    const state = window.__soundyState || {};
    state.render = state.render || {};
    
    // ğŸ”´ FIX CRÃTICO: Remover verificaÃ§Ã£o de window.__FIRST_ANALYSIS_FROZEN__ da condicional
    // para permitir entrada no bloco e fazer recuperaÃ§Ã£o automÃ¡tica
    if (mode === 'reference' && isSecondTrackCheck) {
        console.log('ğŸ¯ [COMPARE-MODE] Modo reference detectado - Segunda faixa chegou');
        console.log('ğŸ“Š [COMPARE-MODE] window.__FIRST_ANALYSIS_FROZEN__ existe?', !!window.__FIRST_ANALYSIS_FROZEN__);
        console.log('ğŸ“Š [COMPARE-MODE] Segunda faixa:', analysis);
        
        // ğŸ¯ DEFINIR MODO REFERENCE NO ESTADO
        state.render.mode = 'reference';
        window.__soundyState = state;
        console.log('âœ… [COMPARE-MODE] Modo definido como REFERENCE no estado');
        
        // ğŸ¯ CRIAR ESTRUTURA DE COMPARAÃ‡ÃƒO ENTRE FAIXAS COM CÃ“PIA DEFENSIVA
        
        // ğŸ” AUDITORIA: Estado ANTES de deepCloneSafe + normalizeBackendAnalysisData
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ”’ ANTES deepCloneSafe + normalize');
        console.log('âš™ï¸ Contexto: Prestes a criar refNormalized e currNormalized');
        console.log('ğŸ“Š window.__FIRST_ANALYSIS_FROZEN__ (1Âª faixa):', {
            fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
            jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
            lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
            objectId: window.__FIRST_ANALYSIS_FROZEN__
        });
        console.log('ğŸ“Š analysis (2Âª faixa):', {
            fileName: analysis?.metadata?.fileName || analysis?.fileName,
            jobId: analysis?.jobId,
            lufs: analysis?.technicalData?.lufsIntegrated,
            objectId: analysis
        });
        console.log('ğŸ’¡ OperaÃ§Ã£o: deepCloneSafe() + normalizeBackendAnalysisData()');
        console.groupEnd();
        
        // ========================================
        // ğŸ§  PRIORIZAR DADOS DO STORE ISOLADO (FONTE DE VERDADE)
        // ========================================
        let refNormalized, currNormalized;
        
        // ğŸ”’ PRIORIDADE ABSOLUTA: Verificar SoundyAI_Store PRIMEIRO
        const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
        
        if (storeHasBoth) {
            console.log('ğŸ¯ [STORE-ABSOLUTE-PRIORITY] âœ… Store tem ambas anÃ¡lises - USANDO COMO FONTE ÃšNICA');
            console.log('   - Store.first.jobId:', window.SoundyAI_Store.first?.jobId);
            console.log('   - Store.second.jobId:', window.SoundyAI_Store.second?.jobId);
            console.log('   - Store.first.fileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
            console.log('   - Store.second.fileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
            
            // Normalizar dados do store (nÃ£o do comparisonPair que pode estar desatualizado)
            refNormalized = normalizeSafe(window.SoundyAI_Store.first);   // Primeira mÃºsica
            currNormalized = normalizeSafe(window.SoundyAI_Store.second); // Segunda mÃºsica
            
            console.log('âœ… [STORE-ABSOLUTE-PRIORITY] Dados do store normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
            
            // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Detectar contaminaÃ§Ã£o no store
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('ğŸš¨ [STORE-ERROR] âŒ CONTAMINAÃ‡ÃƒO NO STORE DETECTADA!');
                console.error('   - JobIds sÃ£o IGUAIS:', window.SoundyAI_Store.first.jobId);
                console.error('   - Isso indica bug no salvamento dos dados');
                console.trace();
            }
            
        } else if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('ğŸ¯ [STORE-PRIORITY] Usando dados do comparisonPair (anexado ao analysis)');
            const pair = analysis._comparisonPair;
            
            // Normalizar dados do comparisonPair
            refNormalized = normalizeSafe(pair.ref);   // Primeira mÃºsica (referÃªncia)
            currNormalized = normalizeSafe(pair.curr); // Segunda mÃºsica (atual)
            
            console.log('âœ… [STORE-PRIORITY] Dados do comparisonPair normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
        } else {
            console.log('âš ï¸ [LEGACY-MODE] Store nÃ£o disponÃ­vel, usando modo legado');
            console.warn('âš ï¸ [LEGACY-WARN] ATENÃ‡ÃƒO: Modo legado pode ter contaminaÃ§Ã£o!');
            
            // ğŸ”’ HARD-GUARD: Usar FirstAnalysisStore.get() (Ãºnica fonte de verdade - modo legado)
            const firstAnalysis = FirstAnalysisStore.get();
            
            console.log('ğŸ”´ [AUDIT-CRITICAL] ANTES de criar refNormalized/currNormalized:');
            console.log('  FirstAnalysisStore.has():', FirstAnalysisStore.has());
            console.log('  firstAnalysis.metadata?.fileName:', firstAnalysis?.metadata?.fileName);
            console.log('  firstAnalysis.jobId:', firstAnalysis?.jobId);
            console.log('  analysis.metadata?.fileName:', analysis?.metadata?.fileName);
            console.log('  analysis.jobId:', analysis?.jobId);
            console.log('  ğŸš¨ SÃƒO O MESMO ARQUIVO?', firstAnalysis?.metadata?.fileName === analysis?.metadata?.fileName);
            console.log('  ğŸš¨ SÃƒO O MESMO JOBID?', firstAnalysis?.jobId === analysis?.jobId);
            
            // âœ… STEP 2/6 REFATORADO: NormalizaÃ§Ã£o segura sem ciclos (modo legado)
            console.log('[NORMALIZE-DEFENSIVE] ğŸ”’ Criando cÃ³pia isolada da 1Âª faixa (normalizeSafe)');
            refNormalized = normalizeSafe(firstAnalysis);
            
            console.log('[NORMALIZE-DEFENSIVE] ğŸ”’ Criando cÃ³pia isolada da 2Âª faixa (normalizeSafe)');
            currNormalized = normalizeSafe(analysis);
        }
        
        // ========================================
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA ABSOLUTA: ABORTAR SE JOBIDS IGUAIS
        // ========================================
        const refFileName = refNormalized?.metadata?.fileName || refNormalized?.fileName;
        const currFileName = currNormalized?.metadata?.fileName || currNormalized?.fileName;
        const refJobId = refNormalized?.jobId || refNormalized?.id;
        const currJobId = currNormalized?.jobId || currNormalized?.id;
        
        console.groupCollapsed('[PRE-VALIDATION] ğŸ” VerificaÃ§Ã£o de Integridade dos Objetos');
        console.log('ğŸ“ Arquivo 1 (ref):', refFileName);
        console.log('ğŸ“ Arquivo 2 (curr):', currFileName);
        console.log('ğŸ†” JobId 1 (ref):', refJobId);
        console.log('ğŸ†” JobId 2 (curr):', currJobId);
        console.log('âš ï¸ Nomes iguais?', refFileName === currFileName);
        console.log('âš ï¸ JobIds iguais?', refJobId === currJobId);
        console.log('âš ï¸ Objetos sÃ£o mesma referÃªncia?', refNormalized === currNormalized);
        console.log('âš ï¸ Metadata sÃ£o mesma referÃªncia?', refNormalized?.metadata === currNormalized?.metadata);
        console.groupEnd();
        
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Se jobIds forem iguais, ABORTAR IMEDIATAMENTE
        if (refJobId && currJobId && refJobId === currJobId) {
            console.error('ğŸš¨ğŸš¨ğŸš¨ [CRITICAL-ERROR] JOBIDS IGUAIS DETECTADOS! ğŸš¨ğŸš¨ğŸš¨');
            console.error('   - refJobId:', refJobId);
            console.error('   - currJobId:', currJobId);
            console.error('   - refFileName:', refFileName);
            console.error('   - currFileName:', currFileName);
            console.error('   - Sistema estÃ¡ tentando comparar a mÃºsica consigo mesma!');
            console.error('   - ABORTANDO renderizaÃ§Ã£o para evitar dados incorretos');
            console.trace();
            
            // Mostrar alerta ao usuÃ¡rio
            alert('âŒ ERRO CRÃTICO: Sistema detectou que estÃ¡ tentando comparar a mesma mÃºsica.\n\n' +
                  'JobId 1: ' + refJobId + '\n' +
                  'JobId 2: ' + currJobId + '\n\n' +
                  'Por favor, recarregue a pÃ¡gina e tente novamente com duas mÃºsicas DIFERENTES.');
            
            // ABORTAR renderizaÃ§Ã£o
            return;
        }
        
        console.log('âœ… [VALIDATION-PASS] JobIds sÃ£o diferentes - prosseguindo com renderizaÃ§Ã£o');
        
        // ğŸ›¡ï¸ ProteÃ§Ã£o contra auto-comparaÃ§Ã£o e renderizaÃ§Ã£o segura
        let isSelfCompare = false;
        
        // ========================================
        // ğŸ”§ VALIDAÃ‡ÃƒO INTELIGENTE: Usar jobId e VID em vez de apenas fileName
        // ========================================
        const sameFileName = refFileName === currFileName;
        const sameJobId = !!(refJobId && currJobId && refJobId === currJobId);
        
        // Verificar Virtual IDs (mais confiÃ¡vel que fileName)
        const refVid = refNormalized?.vid || window.CacheIndex?.REF;
        const currVid = currNormalized?.vid || window.CacheIndex?.USER;
        const sameVid = !!(refVid && currVid && refVid === currVid);
        
        // Fallback: areSameTrack() para validaÃ§Ã£o tÃ©cnica
        const sameTrack = areSameTrack(refNormalized, currNormalized);
        
        console.groupCollapsed('[SMART-VALIDATION] ğŸ§  AnÃ¡lise de Self-Compare (VID-aware)');
        console.log('ğŸ“‹ AnÃ¡lise completa:', {
            sameFileName,
            sameJobId,
            refVid,
            currVid,
            sameVid,
            sameTrack,
            decisao: (sameJobId || sameVid) 
                ? 'SELF-COMPARE REAL (jobId ou VID idÃªntico)' 
                : (sameFileName && !sameJobId && !sameVid) 
                    ? 'MESMO ARQUIVO, IDs DIFERENTES â†’ OK (nÃ£o Ã© self-compare)' 
                    : 'ARQUIVOS DIFERENTES'
        });
        console.groupEnd();
        
        // Self-compare detectado se: jobId OU VID idÃªnticos
        if (sameJobId || sameVid) {
            console.warn('[REF-GUARD] âš ï¸ Self-compare REAL detectado â€” marcando flag mas CONTINUANDO renderizaÃ§Ã£o A/B.');
            isSelfCompare = true;
            
            // ğŸ”¥ Marcar no estado que Ã© self-compare (sem interromper fluxo)
            if (!state.render) state.render = {};
            state.render.isSelfCompare = true;
            
            console.log('[REF-GUARD] ğŸ”„ Self-compare confirmado:', {
                sameJobId: sameJobId ? refJobId : false,
                sameVid: sameVid ? refVid : false,
                note: 'Score serÃ¡ 100% mas renderizaÃ§Ã£o continua'
            });
        } else if (sameFileName && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] âœ… Mesmo arquivo mas IDs diferentes â†’ NÃ£o Ã© self-compare, continuando normalmente');
        } else if (sameTrack && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] âš ï¸ areSameTrack() detectou semelhanÃ§a mas IDs sÃ£o diferentes â†’ Continuando normalmente');
        } else {
            console.log('[REF-GUARD] âœ… ValidaÃ§Ã£o passou - faixas sÃ£o diferentes');
        }
        
        // âœ… REVALIDAÃ‡ÃƒO: Garantir que nÃ£o Ã© falso-positivo
        // Se chegou aqui com isSelfCompare mas VIDs sÃ£o diferentes, corrigir
        if (isSelfCompare && refVid !== currVid) {
            console.warn('[REF-GUARD] â Corrigido selfCompare falso-positivo (VIDs diferentes):', {
                refVid,
                currVid,
                refFile: refFileName,
                currFile: currFileName
            });
            isSelfCompare = false;
            if (state.render) state.render.isSelfCompare = false;
        }
        
        // ğŸ› DEBUG A/B
        console.log('[DEBUG-A/B]', {
            ref: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            curr: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            same: areSameTrack(refNormalized, currNormalized),
        });
        
        // ğŸ” AUDITORIA: Estado APÃ“S criar refNormalized e currNormalized
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS refNormalized + currNormalized');
        console.log('âš™ï¸ Contexto: Clones normalizados criados');
        console.log('ğŸ“Š refNormalized (1Âª faixa normalizada):', {
            fileName: refNormalized?.metadata?.fileName,
            jobId: refNormalized?.jobId,
            lufs: refNormalized?.technicalData?.lufsIntegrated,
            objectId: refNormalized
        });
        console.log('ğŸ“Š currNormalized (2Âª faixa normalizada):', {
            fileName: currNormalized?.metadata?.fileName,
            jobId: currNormalized?.jobId,
            lufs: currNormalized?.technicalData?.lufsIntegrated,
            objectId: currNormalized
        });
        console.log('âš ï¸ VERIFICAÃ‡ÃƒO DE ISOLAMENTO:');
        console.log('  refNormalized !== currNormalized?', refNormalized !== currNormalized);
        console.log('  refNormalized !== window.__FIRST_ANALYSIS_FROZEN__?', refNormalized !== window.__FIRST_ANALYSIS_FROZEN__);
        console.log('  currNormalized !== analysis?', currNormalized !== analysis);
        console.log('  refNormalized.metadata?.fileName:', refNormalized?.metadata?.fileName);
        console.log('  currNormalized.metadata?.fileName:', currNormalized?.metadata?.fileName);
        console.log('  ğŸš¨ SAME FILE?', refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName);
        
        // ğŸ”´ VALIDAÃ‡ÃƒO CRÃTICA: Se os arquivos sÃ£o iguais, ABORTAR imediatamente
        if (refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName) {
            console.error('ğŸ”´ [AUDITORIA_STATE_FLOW] âŒâŒâŒ CONTAMINAÃ‡ÃƒO CONFIRMADA âŒâŒâŒ');
            console.error('ğŸ”´ refNormalized e currNormalized tÃªm O MESMO ARQUIVO!');
            console.error('ğŸ”´ Isso significa que window.__FIRST_ANALYSIS_FROZEN__ foi contaminado!');
            console.error('ğŸ”´ Sistema estÃ¡ comparando a mÃºsica consigo mesma!');
            console.table({
                'refNormalized.fileName': refNormalized?.metadata?.fileName,
                'refNormalized.jobId': refNormalized?.jobId,
                'currNormalized.fileName': currNormalized?.metadata?.fileName,
                'currNormalized.jobId': currNormalized?.jobId,
                'sameFile': refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName,
                'sameJobId': refNormalized?.jobId === currNormalized?.jobId
            });
        }
        console.groupEnd();
        
        // [REF-FLOW] Construindo mÃ©tricas A/B
        // âœ… SEMÃ‚NTICA CORRETA:
        // - refNormalized = 1Âª faixa = SUA MÃšSICA (atual) = userAnalysis
        // - currNormalized = 2Âª faixa = REFERÃŠNCIA (alvo a alcanÃ§ar) = referenceAnalysis
        
        // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: SÃ³ criar se ainda nÃ£o existir
        if (!referenceComparisonMetrics) {
            console.log('[STATE-FIX] âœ… Criando referenceComparisonMetrics pela primeira vez');
            referenceComparisonMetrics = {
                // ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                userTrack: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),        // 1Âª faixa (sua mÃºsica/atual)
                referenceTrack: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2Âª faixa (referÃªncia/alvo)
                
                userTrackFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceTrackFull: JSON.parse(JSON.stringify(currNormalized || null)),
                
                // LEGADO: manter por compatibilidade (mapeamento correto)
                user: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),       // 1Âª = sua mÃºsica (atual)
                reference: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2Âª = referÃªncia (alvo)
                userFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceFull: JSON.parse(JSON.stringify(currNormalized || null))
            };
        } else {
            console.warn('[STATE-FIX] âš ï¸ referenceComparisonMetrics jÃ¡ inicializado, nÃ£o sobrescrevendo');
            console.warn('[STATE-FIX]   Mantendo dados originais:', {
                userFile: referenceComparisonMetrics.userFull?.fileName || referenceComparisonMetrics.userFull?.metadata?.fileName,
                refFile: referenceComparisonMetrics.referenceFull?.fileName || referenceComparisonMetrics.referenceFull?.metadata?.fileName
            });
        }
        
        console.log('[REF-FLOW] âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('[REF-FLOW] âœ… MÃ©tricas A/B construÃ­das corretamente:');
        console.log('[REF-FLOW] âœ…   SUA MÃšSICA (1Âª):', refNormalized.metadata?.fileName);
        console.log('[REF-FLOW] âœ…   LUFS:', referenceComparisonMetrics.userTrack?.lufsIntegrated);
        console.log('[REF-FLOW] âœ…   REFERÃŠNCIA (2Âª):', currNormalized.metadata?.fileName);
        console.log('[REF-FLOW] âœ…   LUFS:', referenceComparisonMetrics.referenceTrack?.lufsIntegrated);
        console.log('[REF-FLOW] âœ…   Tabela: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
        console.log('[REF-FLOW] âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        console.log('[ASSERT] reference mode', {
            userIsFirst: !!(state?.userAnalysis || refNormalized),
            refIsSecond: !!(state?.referenceAnalysis || currNormalized)
        });
        
        // ğŸ§© PROTEÃ‡ÃƒO CONTRA DADOS INCOMPLETOS
        if (!currNormalized?.technicalData?.spectral_balance) {
            console.warn("âš ï¸ [REF-FIX] spectral_balance ausente em currNormalized, reconstruindo...");
            if (currNormalized?.bands) {
                currNormalized.technicalData.spectral_balance = currNormalized.bands;
            } else if (currNormalized?.technicalData?.bandEnergies) {
                currNormalized.technicalData.spectral_balance = currNormalized.technicalData.bandEnergies;
            } else {
                console.warn("âš ï¸ [REF-FIX] Criando estrutura vazia para currNormalized");
                if (!currNormalized.technicalData) currNormalized.technicalData = {};
                currNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }

        if (!refNormalized?.technicalData?.spectral_balance) {
            console.warn("âš ï¸ [REF-FIX] spectral_balance ausente em refNormalized, reconstruindo...");
            if (refNormalized?.bands) {
                refNormalized.technicalData.spectral_balance = refNormalized.bands;
            } else if (refNormalized?.technicalData?.bandEnergies) {
                refNormalized.technicalData.spectral_balance = refNormalized.technicalData.bandEnergies;
            } else {
                console.warn("âš ï¸ [REF-FIX] Criando estrutura vazia para refNormalized");
                if (!refNormalized.technicalData) refNormalized.technicalData = {};
                refNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }
        
        // ğŸ§© LOG DE AUDITORIA DETALHADO
        console.log("[ASSERT_REF_FLOW âœ…]", {
            userTrack: refNormalized?.metadata?.fileName || "primeira faixa",
            referenceTrack: currNormalized?.metadata?.fileName || "segunda faixa",
            userBands: Object.keys(refNormalized?.technicalData?.spectral_balance || {}),
            referenceBands: Object.keys(currNormalized?.technicalData?.spectral_balance || {})
        });
        
        // ğŸ§© PROTEÃ‡ÃƒO NO displayModalResults: ValidaÃ§Ã£o de referenceTrack
        if (!currNormalized?.metadata?.fileName && !currNormalized?.fileName) {
            console.warn("âš ï¸ [DISPLAY_MODAL_FIX] Reference track com dados incompletos â€” continuando com fallback...");
            // âŒ REMOVIDO: return que bloqueava renderizaÃ§Ã£o
            // Agora continua o fluxo com dados disponÃ­veis, mesmo que incompletos
        }
        
        // ğŸ§© CORREÃ‡ÃƒO #6: Chamada ÃšNICA de renderizaÃ§Ã£o (remover duplicaÃ§Ã£o)
        // SEMÃ‚NTICA CORRETA:
        // - userAnalysis = 1Âª faixa (SUA MÃšSICA - atual)
        // - referenceAnalysis = 2Âª faixa (REFERÃŠNCIA - alvo)
        
        // ğŸ” [A/B-DEBUG] Dados ANTES de renderReferenceComparisons
        console.log("[A/B-DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        console.log("[A/B-DEBUG] Dados antes do SAFE_RENDER_REF:");
        console.log("[A/B-DEBUG] refNormalized (1Âª faixa - SUA MÃšSICA):", {
            fileName: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            hasBands: !!refNormalized?.bands,
            hasSpectralBalance: !!refNormalized?.technicalData?.spectral_balance,
            bandsKeys: refNormalized?.bands ? Object.keys(refNormalized.bands) : [],
            spectralBalanceKeys: refNormalized?.technicalData?.spectral_balance ? Object.keys(refNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] currNormalized (2Âª faixa - REFERÃŠNCIA):", {
            fileName: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            hasBands: !!currNormalized?.bands,
            hasSpectralBalance: !!currNormalized?.technicalData?.spectral_balance,
            bandsKeys: currNormalized?.bands ? Object.keys(currNormalized.bands) : [],
            spectralBalanceKeys: currNormalized?.technicalData?.spectral_balance ? Object.keys(currNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // âœ… GARANTIR que bands esteja no nÃ­vel correto (userAnalysis.bands e referenceAnalysis.bands)
        if (!refNormalized.bands && refNormalized?.technicalData?.spectral_balance) {
            refNormalized.bands = refNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] âœ… Bandas copiadas de technicalData.spectral_balance para bands (userAnalysis)");
        }
        
        if (!currNormalized.bands && currNormalized?.technicalData?.spectral_balance) {
            currNormalized.bands = currNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] âœ… Bandas copiadas de technicalData.spectral_balance para bands (referenceAnalysis)");
        }
        
        console.log("[A/B-DEBUG] âœ… Bandas finais:", {
            userBandsLength: refNormalized?.bands ? Object.keys(refNormalized.bands).length : 0,
            referenceBandsLength: currNormalized?.bands ? Object.keys(currNormalized.bands).length : 0
        });
        
        // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone antes de renderizar
        console.log('[STATE-FIX] ğŸ”’ Criando frozen clones para renderReferenceComparisons');
        const frozenRef = JSON.parse(JSON.stringify(refNormalized));
        const frozenCurr = JSON.parse(JSON.stringify(currNormalized));
        
        // ğŸ” AUDITORIA DE INTEGRIDADE
        console.log('[STATE-INTEGRITY]', {
            refJobId: frozenRef.jobId,
            currJobId: frozenCurr.jobId,
            refFile: frozenRef.fileName || frozenRef.metadata?.fileName,
            currFile: frozenCurr.fileName || frozenCurr.metadata?.fileName,
            sameJob: frozenRef.jobId === frozenCurr.jobId,
            sameFile: (frozenRef.fileName || frozenRef.metadata?.fileName) === (frozenCurr.fileName || frozenCurr.metadata?.fileName),
            areIndependent: frozenRef !== frozenCurr,
            metadataIndependent: frozenRef.metadata !== frozenCurr.metadata
        });
        
        // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que jobIds sÃ£o DIFERENTES antes de renderizar
        console.group('ğŸ” [DISPLAY-MODAL] ValidaÃ§Ã£o de JobIds antes de renderizar');
        console.log('   - frozenRef.jobId:', frozenRef.jobId);
        console.log('   - frozenCurr.jobId:', frozenCurr.jobId);
        console.log('   - SÃ£o diferentes?', frozenRef.jobId !== frozenCurr.jobId);
        
        // Validar com getCorrectJobId() tambÃ©m
        const expectedCurrentJobId = getCorrectJobId('current');
        const expectedReferenceJobId = getCorrectJobId('reference');
        console.log('   - getCorrectJobId("current"):', expectedCurrentJobId);
        console.log('   - getCorrectJobId("reference"):', expectedReferenceJobId);
        console.log('   - Esses tambÃ©m sÃ£o diferentes?', expectedCurrentJobId !== expectedReferenceJobId);
        
        if (frozenRef.jobId === frozenCurr.jobId) {
            console.error('âŒ [DISPLAY-MODAL] ERRO: frozenRef e frozenCurr tÃªm o MESMO jobId!');
            console.error('   Isso significa que os dados estÃ£o contaminados!');
            console.trace();
            console.groupEnd();
            
            // Tentar recuperar usando getCorrectJobId
            console.warn('ğŸ”„ [DISPLAY-MODAL] Tentando recuperar dados corretos...');
            // Por enquanto, ABORTAR para evitar renderizaÃ§Ã£o incorreta
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o. Os dados estÃ£o contaminados. Recarregue a pÃ¡gina.');
            return;
        }
        
        console.log('âœ… [DISPLAY-MODAL] JobIds sÃ£o diferentes - prosseguindo com renderizaÃ§Ã£o');
        console.groupEnd();
        
        // ========================================
        // ğŸ§  USAR DADOS DO STORE SE DISPONÃVEL
        // ========================================
        let renderUserAnalysis, renderRefAnalysis;
        
        if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('ğŸ¯ [RENDER-STORE] Usando dados do store isolado para renderizaÃ§Ã£o');
            renderUserAnalysis = frozenRef;   // JÃ¡ Ã© clone de comparisonPair.ref
            renderRefAnalysis = frozenCurr;   // JÃ¡ Ã© clone de comparisonPair.curr
        } else {
            console.log('âš ï¸ [RENDER-LEGACY] Usando dados legados para renderizaÃ§Ã£o');
            renderUserAnalysis = frozenRef;
            renderRefAnalysis = frozenCurr;
        }
        
        // ğŸ¯ [METRICS-DEBUG] LOG CRÃTICO DAS MÃ‰TRICAS ANTES DE RENDERIZAR
        console.group('ğŸ¯ [METRICS-DEBUG] MÃ©tricas ANTES de renderReferenceComparisons');
        console.table({
            'User LUFS': renderUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': renderRefAnalysis?.technicalData?.lufsIntegrated,
            'User DR': renderUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': renderRefAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': renderUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': renderRefAnalysis?.technicalData?.truePeakDbtp,
            'User JobId': renderUserAnalysis?.jobId,
            'Ref JobId': renderRefAnalysis?.jobId,
            'User File': renderUserAnalysis?.fileName || renderUserAnalysis?.metadata?.fileName,
            'Ref File': renderRefAnalysis?.fileName || renderRefAnalysis?.metadata?.fileName
        });
        console.log('âœ… [METRICS-DEBUG] Se os valores acima forem IGUAIS, hÃ¡ contaminaÃ§Ã£o!');
        console.groupEnd();
        
        renderReferenceComparisons({
            mode: 'reference',
            userAnalysis: renderUserAnalysis,        // 1Âª faixa (sua mÃºsica) - CLONE INDEPENDENTE
            referenceAnalysis: renderRefAnalysis,    // 2Âª faixa (referÃªncia) - CLONE INDEPENDENTE
            analysis: {
                userAnalysis: renderUserAnalysis,
                referenceAnalysis: renderRefAnalysis
            },
            _useStoreData: analysis?._useStoreData  // Propagar flag
        });
        
        // âŒ REMOVIDO: renderTrackComparisonTable() - causava duplicaÃ§Ã£o
        // renderReferenceComparisons() jÃ¡ renderiza tudo
        console.log('âœ… [REFERENCE-RENDER] RenderizaÃ§Ã£o Ãºnica completa (sem duplicaÃ§Ã£o)');
        
        // Atualizar window.latestAnalysis para compatibilidade com IA e PDF
        window.latestAnalysis = {
            mode: "comparison",
            reference: window.referenceAnalysisData,
            current: analysis,
            scores: analysis.scores || {}
        };
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA: NÃƒO retornar aqui!
        // Continuar para renderizar cards, scores e sugestÃµes
        console.log('[AUDIT-FIX] âœ… Continuando renderizaÃ§Ã£o completa (cards, scores, sugestÃµes)');
        
        // ğŸ¯ GARANTIR que sugestÃµes de IA sejam chamadas tambÃ©m no modo reference
        console.log('[AUDIT-FIX] ğŸ¤– Iniciando renderizaÃ§Ã£o de sugestÃµes de IA no modo reference');
        
        // âœ… CORREÃ‡ÃƒO: Garantir que analysisForSuggestions inclua suggestions completas
        const analysisForSuggestions = {
            ...(refNormalized || analysis),
            // âœ… Preservar suggestions da anÃ¡lise (pode vir do backend ou frontend)
            suggestions: 
                (refNormalized || analysis)?.suggestions || 
                (refNormalized || analysis)?.userAnalysis?.suggestions || 
                analysis?.suggestions ||
                [],
            mode: 'reference'
        };
        
        console.log('[SUG-AUDIT] reference deltas ready:', !!analysis.referenceComparison);
        console.log('[AUDIT-FIX] ğŸ“Š analysisForSuggestions preparado:', {
            hasSuggestions: !!analysisForSuggestions.suggestions,
            suggestionsLength: analysisForSuggestions.suggestions?.length || 0,
            mode: analysisForSuggestions.mode,
            hasReferenceComparison: !!analysisForSuggestions.referenceComparison
        });
        
        // ğŸ”¥ Chamada ao displayModalResults no fluxo normal (nÃ£o self-compare)
        if (typeof AISuggestionsIntegration?.displayModalResults === 'function') {
            AISuggestionsIntegration.displayModalResults(currNormalized);
        }
        
        // Chamar sugestÃµes de IA apÃ³s pequeno delay para garantir que DOM estÃ¡ pronto
        setTimeout(() => {
            if (window.aiUIController) {
                // ğŸ” PASSO 1: LOG CRÃTICO ANTES de checkForAISuggestions
                console.group('ğŸ” [PRE-AI-SUGGESTIONS] Estado ANTES de checkForAISuggestions');
                console.log('   - currentJobId (segunda mÃºsica):', window.__CURRENT_JOB_ID__);
                console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('   - analysisForSuggestions:', {
                    jobId: analysisForSuggestions?.jobId,
                    fileName: analysisForSuggestions?.fileName || analysisForSuggestions?.metadata?.fileName,
                    hasSuggestions: !!analysisForSuggestions?.suggestions,
                    suggestionsLength: analysisForSuggestions?.suggestions?.length || 0
                });
                
                // ğŸ” [AUDITORIA_DOM] Verificar estado do DOM de sugestÃµes
                const aiSection = document.getElementById('aiSuggestionsExpanded');
                const aiContent = document.getElementById('aiExpandedGrid');
                const existingSuggestions = aiContent?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                
                console.log('   [AUDITORIA_DOM] Estado ANTES:', {
                    aiSection: !!aiSection,
                    aiSectionVisible: aiSection?.style?.display !== 'none',
                    aiContent: !!aiContent,
                    suggestionsExistentes: existingSuggestions
                });
                console.groupEnd();
                
                console.log('[AUDIT-FIX] âœ… Chamando aiUIController.checkForAISuggestions');
                console.log('[AUDIT-FIX] Passando analysisForSuggestions com', analysisForSuggestions?.suggestions?.length || 0, 'sugestÃµes');
                window.aiUIController.checkForAISuggestions(analysisForSuggestions, true);
                
                // ğŸ” PASSO 2: LOG CRÃTICO DEPOIS de checkForAISuggestions
                setTimeout(() => {
                    console.group('ğŸ” [POST-AI-SUGGESTIONS] Estado DEPOIS de checkForAISuggestions');
                    console.log('   - currentJobId:', window.__CURRENT_JOB_ID__);
                    console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                    console.log('   - MUDOU?', window.__CURRENT_JOB_ID__ === window.__REFERENCE_JOB_ID__ ? 'âŒ CONTAMINADO!' : 'âœ… Intacto');
                    
                    // ğŸ” [AUDITORIA_DOM] Verificar estado do DOM de sugestÃµes DEPOIS
                    const aiSectionAfter = document.getElementById('aiSuggestionsExpanded');
                    const aiContentAfter = document.getElementById('aiExpandedGrid');
                    const cardsAfter = aiContentAfter?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                    
                    console.log('   [AUDITORIA_DOM] Estado DEPOIS:', {
                        aiSection: !!aiSectionAfter,
                        aiSectionVisible: aiSectionAfter?.style?.display !== 'none',
                        aiContent: !!aiContentAfter,
                        cards: cardsAfter
                    });
                    
                    if (cardsAfter === 0) {
                        console.error('   [AUDITORIA_DOM] âŒ NENHUM CARD FOI RENDERIZADO!');
                        console.error('   [AUDITORIA_DOM] PossÃ­veis causas:');
                        console.error('   [AUDITORIA_DOM]   1. analysisForSuggestions nÃ£o tem suggestions[]');
                        console.error('   [AUDITORIA_DOM]   2. FunÃ§Ã£o checkForAISuggestions retornou cedo');
                        console.error('   [AUDITORIA_DOM]   3. Erro no renderCompactPreview()');
                    } else {
                        console.log('   [AUDITORIA_DOM] âœ…', cardsAfter, 'cards renderizados com sucesso!');
                    }
                    console.groupEnd();
                }, 100); // Delay pequeno para dar tempo de renderizar
            } else if (window.forceShowAISuggestions) {
                console.log('[AUDIT-FIX] âœ… Chamando forceShowAISuggestions');
                window.forceShowAISuggestions(analysisForSuggestions);
            } else {
                console.warn('[AUDIT-FIX] âš ï¸ Nenhuma funÃ§Ã£o de IA disponÃ­vel');
            }
        }, 800);
        
        // âš ï¸ IMPORTANTE: NÃ£o usar return aqui - continuar fluxo normal
        // return; // â† REMOVIDO
    }
    else {
        // ğŸ”´ DIAGNÃ“STICO: Por que NÃƒO entrou no bloco A/B?
        console.error('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] NÃƒO ENTROU NO BLOCO A/B!');
        console.error('ğŸ”´ [DIAGNÃ“STICO-AB] Motivo:');
        if (mode !== 'reference') {
            console.error('ğŸ”´ [DIAGNÃ“STICO-AB]   âŒ mode !== "reference" (mode =', mode, ')');
        }
        if (!isSecondTrack) {
            console.error('ğŸ”´ [DIAGNÃ“STICO-AB]   âŒ isSecondTrack = false');
            console.error('ğŸ”´ [DIAGNÃ“STICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        }
        console.error('ğŸ”´ [DIAGNÃ“STICO-AB] Sistema VAI RENDERIZAR EM MODO SINGLE-TRACK!');
        console.error('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO: Definir modo baseado no contexto real da anÃ¡lise
    // NÃƒO forÃ§ar genre se for primeira faixa de referÃªncia
    if (mode === 'reference' && !isSecondTrack) {
        // Primeira faixa em modo reference - manter modo reference mas nÃ£o renderizar ainda
        state.render.mode = 'reference';
        console.log('âœ… [REFERENCE-FIRST] Primeira faixa de referÃªncia - aguardando segunda');
    } else if (mode !== 'reference' || (mode === 'reference' && !window.referenceAnalysisData)) {
        // ğŸ” PARTE 3.3: Trava do modo Reference â€” NÃƒO forÃ§ar genre se estamos em fluxo de referÃªncia
        const isReferenceFlowLocked =
            (state?.reference?.isSecondTrack === true) ||
            (!!window.__REFERENCE_JOB_ID__ && state?.render?.mode === "reference");

        if (!isReferenceFlowLocked) {
            // Modo genre genuÃ­no
            state.render.mode = 'genre';
            console.log('âœ… [GENRE-MODE] Modo definido como GENRE no estado');
            
            // Limpar dados de referÃªncia para evitar contaminaÃ§Ã£o APENAS em modo genre
            if (state.reference) {
                state.reference.isSecondTrack = false;
                state.reference.analysis = null;
            }
        } else {
            console.log('ğŸ”’ [REF-LOCK] Modo reference travado â€” genre forÃ§ado bloqueado');
        }
    }
    window.__soundyState = state;
    
    // ğŸ”’ UI GATE: VerificaÃ§Ã£o final antes de renderizar
    const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
    
    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
        console.warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado: analysisRunId !== currentRunId', { analysisRunId, currentRunId, mode: analysis?.mode });
        console.warn(`ğŸš« [UI_GATE] displayModalResults cancelado - anÃ¡lise obsoleta (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
        return;
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const technicalData = document.getElementById('modalTechnicalData');
    
    if (!results || !technicalData) {
        console.warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado: !results || !technicalData', { hasResults: !!results, hasTechnicalData: !!technicalData, mode: analysis?.mode });
        console.error('âŒ Elementos de resultado nÃ£o encontrados');
        return;
    }
    
    console.log('[AUDIT-FLOW-CHECK] âœ… Todos os gates passaram - continuando para renderizaÃ§Ã£o');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Abrir modal ANTES de renderizar modo gÃªnero
    // O container #referenceComparisons sÃ³ existe DEPOIS do modal ser aberto
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    results.style.display = 'block';
    console.log('[MODAL-OPEN] âœ… Modal aberto - results.style.display = "block"');
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Normalizar dados do backend para compatibilidade com front-end
    // âœ… PATCH: NormalizaÃ§Ã£o redundante REMOVIDA - dados jÃ¡ normalizados em handleModalFileSelection
    if (analysis && typeof analysis === 'object') {
        console.log('[AUDITORIA-RMS-LUFS] Verificando estado dos dados (jÃ¡ normalizados):', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.rms': analysis?.technicalData?.rms,
            'energy.rms': analysis?.energy?.rms,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'loudness.integrated': analysis?.loudness?.integrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
        });
        
        // ğŸš« PATCH: NormalizaÃ§Ã£o redundante REMOVIDA para evitar contaminaÃ§Ã£o
        // âŒ analysis = normalizeBackendAnalysisData(analysis);
        console.log('[NORMALIZE-SKIP] âœ… Evitando re-normalizaÃ§Ã£o destrutiva - dados jÃ¡ normalizados em handleModalFileSelection');
        console.log('[NORMALIZE-SKIP] âœ… Preservando integridade de referenceComparisonMetrics');
        
        console.log('[AUDITORIA-RMS-LUFS] Dados preservados:', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'loudness.integrated': analysis?.loudness?.integrated,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp,
            'energy.rms': analysis?.energy?.rms
        });
        console.log('ğŸ“Š [DEBUG] Dados preservados para exibiÃ§Ã£o:', analysis);
        
        // ğŸ¯ RECALCULAR hasReferenceComparisonMetrics APÃ“S NORMALIZAÃ‡ÃƒO
        const state = window.__soundyState || {};
        state.hasReferenceComparisonMetrics = computeHasReferenceComparisonMetrics(analysis);
        window.__soundyState = state;
        console.log('[ASSERT] hasReferenceComparisonMetrics recalculado apÃ³s normalizaÃ§Ã£o:', state.hasReferenceComparisonMetrics);
        
        // ğŸ›¡ï¸ PASSO 2: GARANTIR analysis.referenceComparison EXISTE
        if (!analysis.referenceComparison) {
            analysis.referenceComparison = {};
            console.log('ğŸ›¡ï¸ [PASSO 2] Criado analysis.referenceComparison vazio');
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Preencher targets de GÃŠNERO completos
        const mode = analysis?.mode || currentAnalysisMode || 'genre';
        const isGenreMode = mode === 'genre';
        
        if (isGenreMode) {
            // Obter targets de gÃªnero de mÃºltiplas fontes
            const genreTargets = window.__activeRefData || 
                                window.PROD_AI_REF_DATA?.[analysis.genre] || 
                                window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE] || 
                                {};
            
            console.log('ğŸ¯ [GENRE-TARGETS-MERGE] Mesclando targets de gÃªnero:', {
                hasGenreTargets: !!genreTargets,
                hasBands: !!(genreTargets.bands),
                source: window.__activeRefData ? '__activeRefData' : 'PROD_AI_REF_DATA'
            });
            
            if (genreTargets && Object.keys(genreTargets).length > 0) {
                // Fonte primÃ¡ria: referenceComparison ou referenceComparisonMetrics
                const src = genreTargets.referenceComparison || 
                           genreTargets.referenceComparisonMetrics || 
                           genreTargets;
                
                // âœ… CRÃTICO: Mesclar TODOS os targets incluindo bandas
                if (src.lufs_target != null)   analysis.referenceComparison.lufs_target   = src.lufs_target;
                if (src.tp_target != null)     analysis.referenceComparison.tp_target     = src.tp_target;
                if (src.dr_target != null)     analysis.referenceComparison.dr_target     = src.dr_target;
                if (src.lra_target != null)    analysis.referenceComparison.lra_target    = src.lra_target;
                if (src.stereo_target != null) analysis.referenceComparison.stereo_target = src.stereo_target;
                
                // âœ… CRÃTICO: Incluir BANDAS de gÃªnero
                if (src.bands && Object.keys(src.bands).length > 0) {
                    analysis.referenceComparison.bands = src.bands;
                    console.log('âœ… [GENRE-BANDS-MERGED] Bandas de gÃªnero incluÃ­das:', Object.keys(src.bands));
                }
                
                // Marcar como targets de gÃªnero
                analysis.referenceComparison._isGenreMode = true;
                analysis.referenceComparison._genreTargetsLoaded = true;
            } else {
                console.warn('âš ï¸ [GENRE-TARGETS-MERGE] Targets de gÃªnero nÃ£o encontrados, usando fallback');
                // Fallback com valores padrÃ£o
                if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = -14;
                if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = -1;
                if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = 8;
                if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = 6;
                if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = 0.1;
            }
        } else {
            // Modo referÃªncia: usar fallback simples
            const genreTargets = __activeRefData || {};
            if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = genreTargets.lufs_target ?? -14;
            if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = genreTargets.true_peak_target ?? -1;
            if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = genreTargets.dr_target ?? 8;
            if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = genreTargets.lra_target ?? 6;
            if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = genreTargets.stereo_target ?? 0.1;
        }
        
        console.log('âœ… [PASSO 2] analysis.referenceComparison garantido:', {
            hasBands: !!analysis.referenceComparison.bands,
            bandsCount: analysis.referenceComparison.bands ? Object.keys(analysis.referenceComparison.bands).length : 0,
            isGenreMode: analysis.referenceComparison._isGenreMode,
            targets: {
                lufs: analysis.referenceComparison.lufs_target,
                tp: analysis.referenceComparison.tp_target,
                dr: analysis.referenceComparison.dr_target
            }
        });
    }
    
    /* =========[ BLOCO: SCORES A/B â€“ substitui 4888â€“5050 ]========= */

    /** UtilitÃ¡rios robustos (nÃ£o colidem com nomes existentes) */
    const __EPS = 1e-3;
    const __DB_EPS = 0.5; // ~0.5 dB para "iguais"
    const __MIN_BANDS = 7;

    function __num(v){ return typeof v === 'number' && isFinite(v); }
    function __ae(a,b,eps=__EPS){ return __num(a) && __num(b) && Math.abs(a-b) <= eps; }
    function __keys(o){ return o ? Object.keys(o) : []; }

    function __getBandsSafe(from) {
      // aceita objetos tipo analysis, referenceFull, technicalData.spectral_balance etc.
      if (!from) return null;

      // 1) caminhos mais provÃ¡veis
      const td = from.technicalData || from.technical_data || null;
      if (td && td.spectral_balance) return td.spectral_balance;
      if (from.metrics && from.metrics.bands) return from.metrics.bands;
      if (from.bands) return from.bands;

      // 2) objetos jÃ¡ no formato bandas
      const maybeBands = (from.sub || from.lowMid || from.low_mid) ? from : null;
      if (maybeBands) return maybeBands;

      return null;
    }

    function __normalizeBandKeys(b) {
      if (!b) return null;
      // normaliza low_mid->lowMid, high_mid->highMid etc.
      const map = {
        sub: 'sub', bass: 'bass',
        low_mid: 'lowMid', lowmid: 'lowMid', lowMid: 'lowMid',
        mid: 'mid',
        high_mid: 'highMid', highmid: 'highMid', highMid: 'highMid',
        presence: 'presence', air: 'air',
        total: 'totalPercentage', total_percentage: 'totalPercentage', totalPercentage: 'totalPercentage',
        _status: '_status'
      };
      const out = {};
      for (const k of Object.keys(b)) {
        const nk = map[k] || k;
        out[nk] = b[k];
      }
      return out;
    }

    function __bandsAreMeaningful(bands) {
      if (!bands) return false;
      const k = __keys(bands).filter(k => ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (k.length < __MIN_BANDS) return false;
      // precisa ter variaÃ§Ã£o real (evita vetor todo zero)
      const vals = k.map(k => bands[k]).filter(__num);
      if (vals.length < __MIN_BANDS) return false;
      const max = Math.max(...vals), min = Math.min(...vals);
      return isFinite(max) && isFinite(min) && (Math.abs(max - min) > 0.2); // >0.2 dB de amplitude mÃ­nima
    }

    function __bandsSimilar(a, b, epsDb = __DB_EPS) {
      if (!a || !b) return false;
      const ak = __keys(a), bk = __keys(b);
      const common = ak.filter(k => bk.includes(k) && ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (common.length < __MIN_BANDS) return false;
      let equal = 0;
      for (const k of common) {
        if (__num(a[k]) && __num(b[k]) && Math.abs(a[k] - b[k]) <= epsDb) equal++;
      }
      return equal >= __MIN_BANDS; // praticamente iguais
    }

    function __tracksLookSame(userTd, refTd, userMd, refMd, userBands, refBands) {
      // ========================================
      // ğŸ”§ CORREÃ‡ÃƒO: DetecÃ§Ã£o segura de self-compare usando jobId e VID
      // ========================================
      // Recuperar objetos completos para acessar jobId e vid
      const userFull = referenceComparisonMetrics?.userFull || {};
      const refFull = referenceComparisonMetrics?.referenceFull || {};
      
      // CritÃ©rio 1: jobId idÃªntico (mais confiÃ¡vel)
      const sameJobId = !!(userFull?.jobId && refFull?.jobId && userFull.jobId === refFull.jobId);
      
      // CritÃ©rio 2: Virtual ID idÃªntico (detecta mesmo jobId::ROLE)
      const sameVid = !!(userFull?.vid && refFull?.vid && userFull.vid === refFull.vid);
      
      // CritÃ©rio 3: Fallback - fileName idÃªntico APENAS se nÃ£o hÃ¡ jobId em nenhum dos dois
      const sameName = (
        !userFull?.jobId && 
        !refFull?.jobId && 
        !!userMd?.fileName && 
        !!refMd?.fileName && 
        userMd.fileName === refMd.fileName
      );
      
      // CritÃ©rios tÃ©cnicos (mantidos para validaÃ§Ã£o adicional)
      const sameLufs = __ae(userTd?.lufsIntegrated, refTd?.lufsIntegrated, 0.05);
      const sameTp   = __ae(userTd?.truePeakDbtp,  refTd?.truePeakDbtp,  0.05);
      const sameDr   = __ae(userTd?.dynamicRange,  refTd?.dynamicRange,  0.1);
      const sameCent = __ae(userTd?.spectralCentroidHz, refTd?.spectralCentroidHz, 5);
      const sameBands = __bandsSimilar(userBands, refBands);
      
      // Self-compare detectado se:
      // 1. jobId idÃªntico OU
      // 2. VID idÃªntico OU
      // 3. Sem jobId em ambos E fileName idÃªntico OU
      // 4. Todas as mÃ©tricas tÃ©cnicas idÃªnticas E bands similares
      const isSelfCompare = sameJobId || sameVid || sameName || (sameLufs && sameTp && sameDr && sameCent && sameBands);
      
      // Log de auditoria
      console.log("[COMPARE-FLAG] selfCompare:", isSelfCompare, {
        userJobId: userFull?.jobId || 'N/A',
        refJobId: refFull?.jobId || 'N/A',
        sameJobId,
        userVid: userFull?.vid || window.CacheIndex?.USER || 'N/A',
        refVid: refFull?.vid || window.CacheIndex?.REF || 'N/A',
        sameVid,
        userFile: userMd?.fileName || 'N/A',
        refFile: refMd?.fileName || 'N/A',
        sameName,
        technicalMatch: sameLufs && sameTp && sameDr && sameCent && sameBands,
        criteria: {
          sameJobId,
          sameVid,
          sameName,
          sameLufs,
          sameTp,
          sameDr,
          sameCent,
          sameBands
        }
      });
      
      return isSelfCompare;
    }

    /** 1) Extrai estruturas normalizadas que jÃ¡ existem nesse ponto do fluxo */
    // ğŸ”§ FIX CRÃTICO: Mudado de const para let para permitir recuperaÃ§Ã£o em caso de contaminaÃ§Ã£o
    let userFull  = referenceComparisonMetrics?.userFull;       // 1Âª faixa (sua mÃºsica)
    let refFull   = referenceComparisonMetrics?.referenceFull;  // 2Âª faixa (referÃªncia)
    
    // ï¿½ HARD-GUARD: Se userFull estÃ¡ undefined, recuperar de FirstAnalysisStore.get()
    if (!userFull && FirstAnalysisStore.has()) {
        console.warn('[SAFEGUARD] userFull estÃ¡ undefined â€” recuperando de FirstAnalysisStore');
        userFull = structuredClone(FirstAnalysisStore.get());
        console.log('[SAFEGUARD] âœ… userFull recuperado:', {
            fileName: userFull?.metadata?.fileName,
            jobId: userFull?.jobId
        });
    }

    let userTd    = referenceComparisonMetrics?.userTrack   || {};
    let refTd     = referenceComparisonMetrics?.referenceTrack || {};
    let userMd    = userFull?.metadata || {};
    let refMd     = refFull?.metadata  || {};

    // bandas A/B normalizadas + keys padronizadas
    let userBands = __normalizeBandKeys(__getBandsSafe(userFull));
    let refBands  = __normalizeBandKeys(__getBandsSafe(refFull));

    /** 2) Hard-gates antes de montar o objeto de score */
    const isReferenceMode = !!(referenceComparisonMetrics && referenceComparisonMetrics.reference);
    
    // ğŸ” LOG DE VERIFICAÃ‡ÃƒO MÃNIMO (temporÃ¡rio - conforme item 7 do plano)
    console.log('[AB-CHECK]', {
        userJobId: userFull?.jobId,
        refJobId: refFull?.jobId,
        userName: userFull?.metadata?.fileName,
        refName: refFull?.metadata?.fileName
    });
    
    // âœ… PATCH: ValidaÃ§Ã£o de integridade ANTES de calcular selfCompare
    console.log('[INTEGRITY-CHECK] Validando dados antes de calcular score:', {
        userFileName: userMd.fileName,
        refFileName: refMd.fileName,
        userLUFS: userTd.lufsIntegrated,
        refLUFS: refTd.lufsIntegrated,
        sameFile: userMd.fileName === refMd.fileName,
        sameLUFS: userTd.lufsIntegrated && refTd.lufsIntegrated ? 
            Math.abs(userTd.lufsIntegrated - refTd.lufsIntegrated) < 0.05 : false
    });
    
    // ğŸš¨ PATCH: Alerta crÃ­tico se arquivos sÃ£o iguais (contaminaÃ§Ã£o detectada)
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.error('[INTEGRITY-CHECK] âŒ FALHA CRÃTICA: userFile === refFile');
        console.error('[INTEGRITY-CHECK] âŒ ProvÃ¡vel contaminaÃ§Ã£o de dados!');
        console.error('[INTEGRITY-CHECK] âŒ Tentando recuperar de state.previousAnalysis...');
        
        // Tentar recuperar userFull de previousAnalysis
        if (state.previousAnalysis.metadata?.fileName !== refMd.fileName) {
            console.warn('[INTEGRITY-CHECK] âš ï¸ Recuperando userFull de state.previousAnalysis');
            
            // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: SEMPRE usar clone para evitar contaminaÃ§Ã£o de ponteiros
            console.log('[SAFEGUARD] Clonando state.previousAnalysis para evitar referÃªncia compartilhada');
            const recoveredUserFull = structuredClone(state.previousAnalysis);
            const recoveredUserMd = recoveredUserFull.metadata || {};
            const recoveredUserTd = recoveredUserFull.technicalData || {};
            const recoveredUserBands = __normalizeBandKeys(__getBandsSafe(recoveredUserFull));
            
            // Reatribuir variÃ¡veis recuperadas
            userFull = recoveredUserFull;
            userMd = recoveredUserMd;
            userTd = recoveredUserTd;
            userBands = recoveredUserBands;
            
            console.log('[INTEGRITY-CHECK] âœ… Dados recuperados de state.previousAnalysis:', {
                fileName: recoveredUserMd.fileName,
                lufs: recoveredUserTd.lufsIntegrated
            });
        }
    }
    
    // ğŸ” AUDITORIA: Estado ANTES de calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ¯ ANTES de __tracksLookSame (selfCompare)');
    console.log('âš™ï¸ Contexto: Prestes a calcular selfCompare');
    console.log('ğŸ“Š userMd (1Âª faixa metadata):', {
        fileName: userMd?.fileName,
        objectId: userMd
    });
    console.log('ğŸ“Š refMd (2Âª faixa metadata):', {
        fileName: refMd?.fileName,
        objectId: refMd
    });
    console.log('ğŸ“Š userTd (1Âª faixa technicalData):', {
        lufs: userTd?.lufsIntegrated,
        dr: userTd?.dynamicRange,
        objectId: userTd
    });
    console.log('ğŸ“Š refTd (2Âª faixa technicalData):', {
        lufs: refTd?.lufsIntegrated,
        dr: refTd?.dynamicRange,
        objectId: refTd
    });
    console.log('ğŸ“Š userFull (origem):', {
        fileName: userFull?.metadata?.fileName,
        jobId: userFull?.jobId,
        objectId: userFull
    });
    console.log('ğŸ“Š refFull (origem):', {
        fileName: refFull?.metadata?.fileName,
        jobId: refFull?.jobId,
        objectId: refFull
    });
    console.log('âš ï¸ PRÃ‰-VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
    console.log('  userMd.fileName === refMd.fileName?', userMd?.fileName === refMd?.fileName);
    console.log('  userFull === refFull?', userFull === refFull);
    console.log('  userTd === refTd?', userTd === refTd);
    console.groupEnd();
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Detectar e corrigir contaminaÃ§Ã£o ANTES de __tracksLookSame
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.warn('[FIX] ğŸš¨ DetecÃ§Ã£o de self-compare FALSO â€“ isolando referenceAnalysis');
        console.warn('[FIX] userFull foi contaminado com dados de refFull');
        console.warn('[FIX] Tentando recuperar de FirstAnalysisStore...');
        
        // ï¿½ HARD-GUARD: SEMPRE usar FirstAnalysisStore.get() como fonte confiÃ¡vel
        if (!FirstAnalysisStore.has()) {
            console.error('[FIX] âŒ FirstAnalysisStore vazio! Abortando recuperaÃ§Ã£o...');
            return;
        }
        
        // Recuperar primeira anÃ¡lise de fonte confiÃ¡vel (APENAS FirstAnalysisStore)
        const safeUserFull = structuredClone(FirstAnalysisStore.get());
        userFull = safeUserFull;
        userMd = safeUserFull.metadata || {};
        userTd = safeUserFull.technicalData || {};
        userBands = __normalizeBandKeys(__getBandsSafe(safeUserFull));
        
        console.log('[FIX] âœ… userFull recuperado:', {
            fileName: userMd.fileName,
            lufs: userTd.lufsIntegrated,
            source: 'FirstAnalysisStore'
        });
    }
    
    // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO FINAL: Garantir que userFull e refFull sÃ£o DIFERENTES apÃ³s todas as recuperaÃ§Ãµes
    console.group('ğŸ” [FINAL VALIDATION] VerificaÃ§Ã£o final de contaminaÃ§Ã£o');
    console.log('userMd.fileName:', userMd?.fileName);
    console.log('refMd.fileName:', refMd?.fileName);
    console.log('userFull.jobId:', userFull?.jobId);
    console.log('refFull.jobId:', refFull?.jobId);
    console.log('userFull === refFull?', userFull === refFull);
    console.log('userMd === refMd?', userMd === refMd);
    console.log('userTd === refTd?', userTd === refTd);
    console.log('userBands === refBands?', userBands === refBands);
    console.groupEnd();
    
    // âœ… VALIDAÃ‡ÃƒO FINAL: Log apenas, nÃ£o bloqueia renderizaÃ§Ã£o
    if (userMd?.fileName === refMd?.fileName || userFull?.jobId === refFull?.jobId) {
        console.warn('[INFO] âš ï¸ Mesmo jobId/fileName detectado (self-compare falso). Continuando render normalmente.');
        console.warn('[INFO] userMd.fileName:', userMd?.fileName);
        console.warn('[INFO] refMd.fileName:', refMd?.fileName);
        console.warn('[INFO] userFull.jobId:', userFull?.jobId);
        console.warn('[INFO] refFull.jobId:', refFull?.jobId);
        // âœ… NÃƒO RETORNA AQUI! Continua o fluxo para permitir renderizaÃ§Ã£o
    } else {
        console.log('[FINAL VALIDATION] âœ… Dados validados - userFull e refFull sÃ£o DIFERENTES');
    }
    
    // âœ… STEP 6/6 (FINAL): Integrity check - apenas log, nÃ£o bloqueia
    if (areSameTrack(userFull, refFull)) {
        console.warn('[INFO] âš ï¸ areSameTrack() retornou true (self-compare falso). Continuando render normalmente.');
        // âœ… NÃƒO RETORNA AQUI! Continua o fluxo para permitir renderizaÃ§Ã£o
    } else {
        console.log('[INTEGRITY CHECK] âœ… userFull e refFull sÃ£o diferentes â€” prosseguindo com cÃ¡lculo');
    }
    
    // ğŸ¯ ROOT CAUSE FIX: Detectar modo gÃªnero ANTES de calcular refBandsOK
    // Em modo gÃªnero, refBands vem de genreTargets, NÃƒO de referenceAnalysis!
    const isGenreMode = analysis?.mode === "genre" || 
                       state?.render?.mode === "genre" ||
                       (!window.__REFERENCE_JOB_ID__ && !state?.reference?.isSecondTrack);
    
    let finalRefBands = refBands;
    
    if (isGenreMode) {
        console.log('ğŸ¯ [GENRE-BANDS-FIX] Modo GÃŠNERO detectado - buscando bandas de genreTargets');
        
        // Buscar bandas dos targets de gÃªnero carregados
        const genreTargets = window.__activeRefData || 
                           analysis?.referenceComparison || 
                           (analysis?.genre ? window.PROD_AI_REF_DATA?.[analysis.genre] : null);
        
        if (genreTargets) {
            // Tentar extrair bandas de diferentes estruturas possÃ­veis
            finalRefBands = genreTargets.bands || 
                          genreTargets.legacy_compatibility?.bands ||
                          genreTargets.hybrid_processing?.spectral_bands ||
                          null;
            
            console.log('ğŸ¯ [GENRE-BANDS-FIX] Bandas de gÃªnero encontradas:', {
                source: genreTargets.bands ? 'bands' : 
                       genreTargets.legacy_compatibility?.bands ? 'legacy_compatibility.bands' :
                       genreTargets.hybrid_processing?.spectral_bands ? 'hybrid_processing.spectral_bands' : 'null',
                bands: finalRefBands ? Object.keys(finalRefBands) : 'null',
                genre: analysis?.genre
            });
        } else {
            console.warn('âš ï¸ [GENRE-BANDS-FIX] Targets de gÃªnero NÃƒO encontrados! refBands serÃ¡ null');
        }
    } else {
        console.log('ğŸ”„ [AB-MODE] Modo A/B detectado - usando refBands de referenceAnalysis');
    }
    
    const selfCompare = __tracksLookSame(userTd, refTd, userMd, refMd, userBands, finalRefBands);
    const refBandsOK  = __bandsAreMeaningful(finalRefBands);
    const userBandsOK = __bandsAreMeaningful(userBands);

    // ğŸ§ª MODO VERIFICAÃ‡ÃƒO: Log estruturado com console.table
    console.table({
        'userFile': userMd?.fileName || 'N/A',
        'refFile': refMd?.fileName || 'N/A',
        'sameFile': userMd?.fileName === refMd?.fileName,
        'userJobId': userFull?.jobId || 'N/A',
        'refJobId': refFull?.jobId || 'N/A',
        'sameJobId': userFull?.jobId === refFull?.jobId,
        'userLUFS': userTd?.lufsIntegrated || 'N/A',
        'refLUFS': refTd?.lufsIntegrated || 'N/A',
        'userBandsOK': userBandsOK,
        'refBandsOK': refBandsOK,
        'isGenreMode': isGenreMode,
        'finalRefBands': finalRefBands ? 'OK' : 'null'
    });
    
    console.log('[VERIFY_AB_ORDER]', {
      mode: state.render.mode,
      isGenreMode: isGenreMode,
      userFile: userMd.fileName, refFile: refMd.fileName,
      userLUFS: userTd.lufsIntegrated, refLUFS: refTd.lufsIntegrated,
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      refBands: refBandsOK  ? __keys(finalRefBands)  : 'ausente',
      selfCompare
    });
    
    // ğŸ” AUDITORIA: Estado APÃ“S calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS de __tracksLookSame');
    console.log('âš™ï¸ Contexto: selfCompare calculado');
    console.log('ğŸ¯ selfCompare:', selfCompare);
    console.log('ğŸ¯ refBandsOK:', refBandsOK);
    console.log('ğŸ¯ userBandsOK:', userBandsOK);
    console.log('ğŸ¯ disableFrequency serÃ¡:', !refBandsOK || !userBandsOK || selfCompare);
    if (selfCompare) {
        console.warn('âš ï¸ selfCompare TRUE detectado - score serÃ¡ 100%');
        console.warn('âš ï¸ Verificar se Ã© legÃ­timo (mesma faixa 2x) ou contaminaÃ§Ã£o');
    }
    console.groupEnd();

    /** 2.5) FUNÃ‡ÃƒO CRÃTICA: Injetar targets de gÃªnero em refData */
    function injectGenreTargetsIntoRefData(refData, genreTargets) {
        if (!refData || !genreTargets) return refData;
        
        const fields = [
            "lufs_target",
            "true_peak_target",
            "dr_target",
            "lra_target",
            "stereo_target",
            "bands",
            "tol_lufs",
            "tol_true_peak",
            "tol_dr",
            "tol_lra",
            "tol_stereo"
        ];
        
        fields.forEach(key => {
            if (genreTargets[key] !== undefined) {
                refData[key] = genreTargets[key];
            }
        });
        
        console.log("[GENRE-FIX] Targets injetados em refData:", {
            lufs_target: refData.lufs_target,
            true_peak_target: refData.true_peak_target,
            dr_target: refData.dr_target,
            stereo_target: refData.stereo_target,
            hasBands: !!refData.bands,
            bandsCount: refData.bands ? Object.keys(refData.bands).length : 0
        });
        
        return refData;
    }

    /** 3) Se referÃªncia nÃ£o Ã© vÃ¡lida ou A==B, rebaixa o score de frequÃªncia via "disable" e re-normaliza pesos */
    let disableFrequency = false;
    let referenceDataForScores = null;

    if (!refBandsOK || !userBandsOK || selfCompare) {
      disableFrequency = true;
      console.warn('âš ï¸ [SCORES-GUARD] Desativando score de FrequÃªncia:',
        { refBandsOK, userBandsOK, selfCompare, isGenreMode });

      // monta alvo somente com mÃ©tricas escalares (sem bandas)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: null, // forÃ§a desativado
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _disabledBands: true
      };
    } else {
      // fluxo normal (A/B saudÃ¡vel OU modo gÃªnero com targets)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: finalRefBands, // <- bandas reais (de referÃªncia A/B ou gÃªnero)
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true
      };
    }

    console.log('[SCORE-FIX] Bandas preparadas p/ cÃ¡lculo:', {
      disableFrequency, 
      refBands: referenceDataForScores.bands ? __keys(referenceDataForScores.bands) : 'desativado',
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      isGenreMode: isGenreMode
    });

    /** 4) CÃ¡lculo seguro com proteÃ§Ã£o de tolerÃ¢ncia e re-balanceamento de pesos */
    function __safeCalculateAnalysisScores(analysisObj, refData, genre) {
      // Protege tolerÃ¢ncias (evita tolDb=0)
      if (!refData || typeof refData !== 'object') refData = {};
      if (!__num(refData.tol_spectral) || refData.tol_spectral <= 0) refData.tol_spectral = 300;

      // ğŸ¯ CORREÃ‡ÃƒO: Detectar modo gÃªnero e targets de mÃºltiplas fontes
      const isGenreMode = analysisObj?.mode === "genre" || 
                         window.__soundyState?.render?.mode === "genre" ||
                         (getViewMode && getViewMode() === "genre");
      
      // ğŸ¯ CORREÃ‡ÃƒO: Buscar targets de gÃªnero de todas as fontes possÃ­veis
      const genreTargets = window.__activeRefData || 
                          window.PROD_AI_REF_DATA?.[analysisObj?.genre] || 
                          window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE];
      
      const genreBands = genreTargets?.bands || 
                        genreTargets?.referenceComparison?.bands ||
                        analysisObj?.referenceComparison?.bands;
      
      // âœ… CRÃTICO: hasGenreTargets deve ser true se houver targets ou bandas
      const hasGenreTargets = isGenreMode && (
        !!genreTargets || 
        !!(analysisObj?.referenceComparison?._genreTargetsLoaded) ||
        !!(analysisObj?.referenceComparison?.bands)
      );
      
      const hasRefBands = !!(genreBands && Object.keys(genreBands).length > 0);
      const refBandsOK = hasRefBands;
      
      console.log('ğŸ” [SCORES-GUARD-ENHANCED]', {
        isGenreMode,
        hasGenreTargets,
        hasRefBands,
        refBandsOK,
        analysisMode: analysisObj?.mode,
        viewMode: window.__soundyState?.render?.mode,
        refDataHasBands: !!(refData?.bands),
        genreTargetsFound: !!genreTargets,
        genreBandsCount: genreBands ? Object.keys(genreBands).length : 0,
        isReferenceMode: refData?._isReferenceMode,
        disabledBands: refData?._disabledBands
      });

      // Chama o cÃ¡lculo original
      const out = calculateAnalysisScores(analysisObj, refData, genre) || {};

      // ğŸ¯ DECISÃƒO DE DESATIVAR FREQUÃŠNCIA:
      // - Modo REFERENCE: desativar se !refData.bands ou _disabledBands
      // - Modo GENRE: NÃƒO desativar se houver targets de gÃªnero carregados
      const shouldDisableFrequency = isGenreMode 
        ? (!hasGenreTargets && (!refData.bands || refData._disabledBands)) // Modo gÃªnero: sÃ³ desativar se NÃƒO houver targets
        : (!refData.bands || refData._disabledBands); // Modo reference: desativar se sem bandas A/B
      
      if (shouldDisableFrequency) {
        const subs = out.subscores || out; // compat: alguns retornam direto
        const weights = {
          loudness: 0.32, dinamica: 0.23, frequencia: 0.0, estereo: 0.15, tecnico: 0.30 // soma = 1.0
        };
        // recomputa final de forma defensiva
        const lv = __num(subs.loudness)   ? subs.loudness   : 0;
        const dv = __num(subs.dinamica)   ? subs.dinamica   : 0;
        const ev = __num(subs.estereo)    ? subs.estereo    : 0;
        const tv = __num(subs.tecnico)    ? subs.tecnico    : 0;
        const final = Math.round(
          lv*weights.loudness + dv*weights.dinamica + ev*weights.estereo + tv*weights.tecnico
        );
        out.final = final;
        out._weightsApplied = weights;
        out._freqDisabled = true;
        console.warn('âš ï¸ [SCORES-GUARD] FrequÃªncia desativada â‡’ pesos re-normalizados', weights);
      } else if (isGenreMode && hasGenreTargets) {
        console.log('âœ… [SCORES-GUARD] Modo GÃŠNERO: FrequÃªncia ATIVADA (targets de gÃªnero disponÃ­veis)');
      }

      // Hard-cap de True Peak continua valendo (o seu jÃ¡ estÃ¡ aplicado antes)
      return out;
    }

    /** 5) EXECUTA o cÃ¡lculo com o objeto blindado */
    const detectedGenre = analysis.metadata?.genre || analysis.genre || __activeRefGenre;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” PARTE 4: TESTE DE INSPEÃ‡ÃƒO OBRIGATÃ“RIO (PRÃ‰-CÃLCULO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.group("ğŸ” [AUDIT-BACKEND-FLOW] MÃ‰TRICAS RECEBIDAS DO BACKEND");
    console.log("ğŸ“Š analysis.technicalData:", analysis.technicalData);
    console.log("ğŸ“Š analysis.metrics:", analysis.metrics);
    console.log("ğŸ”‘ Keys technicalData:", Object.keys(analysis.technicalData || {}));
    console.log("ğŸ”‘ Keys metrics:", Object.keys(analysis.metrics || {}));
    console.log("ğŸ“ MÃ©tricas especÃ­ficas:");
    console.log("  - technicalData.lufsIntegrated:", analysis.technicalData?.lufsIntegrated);
    console.log("  - metrics.lufs_integrated:", analysis.metrics?.lufs_integrated);
    console.log("  - technicalData.truePeakDbtp:", analysis.technicalData?.truePeakDbtp);
    console.log("  - metrics.true_peak_dbtp:", analysis.metrics?.true_peak_dbtp);
    console.log("  - technicalData.dynamicRange:", analysis.technicalData?.dynamicRange);
    console.log("  - metrics.dynamic_range:", analysis.metrics?.dynamic_range);
    console.log("  - technicalData.lra:", analysis.technicalData?.lra);
    console.log("  - metrics.lra:", analysis.metrics?.lra);
    console.log("  - technicalData.stereoCorrelation:", analysis.technicalData?.stereoCorrelation);
    console.log("  - metrics.stereo_correlation:", analysis.metrics?.stereo_correlation);
    console.log("  - technicalData.stereoWidth:", analysis.technicalData?.stereoWidth);
    console.log("  - metrics.stereo_width:", analysis.metrics?.stereo_width);
    console.log("ğŸ“Œ Targets para cÃ¡lculo (refData):");
    console.log("  - lufs_target:", referenceDataForScores?.lufs_target);
    console.log("  - true_peak_target:", referenceDataForScores?.true_peak_target);
    console.log("  - dr_target:", referenceDataForScores?.dr_target);
    console.log("  - lra_target:", referenceDataForScores?.lra_target);
    console.log("  - stereo_target:", referenceDataForScores?.stereo_target);
    console.log("  - bands:", referenceDataForScores?.bands ? Object.keys(referenceDataForScores.bands) : 'null');
    console.groupEnd();
    
    // ğŸ¯ [GENRE-FIX] CRÃTICO: Aplicar targets de gÃªnero antes dos scores
    // isGenreMode jÃ¡ foi declarado anteriormente (linha 9504)
    
    if (isGenreMode && window.__activeRefData) {
        console.log("[GENRE-FIX] Aplicando genreTargets a refData antes dos scores.");
        console.log("[GENRE-FIX] window.__activeRefData disponÃ­vel:", {
            lufs_target: window.__activeRefData.lufs_target,
            true_peak_target: window.__activeRefData.true_peak_target,
            dr_target: window.__activeRefData.dr_target,
            stereo_target: window.__activeRefData.stereo_target,
            hasBands: !!window.__activeRefData.bands,
            bandsCount: window.__activeRefData.bands ? Object.keys(window.__activeRefData.bands).length : 0
        });
        
        referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, window.__activeRefData);
    }
    
    // ğŸ¯ [FLOW-FIX] Calculando scores APÃ“S normalizaÃ§Ã£o de mÃ©tricas
    console.log("[FLOW-FIX] Calculando scores APÃ“S normalizaÃ§Ã£o de mÃ©tricas.");
    
    const analysisScores = __safeCalculateAnalysisScores(analysis, referenceDataForScores, detectedGenre);

    if (analysisScores) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ” TAREFA 1: AUDITORIA COMPLETA DA ESTRUTURA DE SCORES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.group('ğŸ” [AUDIT-SCORES] ESTRUTURA COMPLETA DE analysisScores');
        console.log('[AUDIT-SCORES] analysisScores bruto:', analysisScores);
        console.log('[AUDIT-SCORES] keys:', Object.keys(analysisScores || {}));
        console.log('[AUDIT-SCORES] Subscores individuais:');
        console.log('  - analysisScores.loudness:', analysisScores.loudness);
        console.log('  - analysisScores.dinamica:', analysisScores.dinamica);
        console.log('  - analysisScores.dynamics:', analysisScores.dynamics);
        console.log('  - analysisScores.estereo:', analysisScores.estereo);
        console.log('  - analysisScores.stereo:', analysisScores.stereo);
        console.log('  - analysisScores.frequency:', analysisScores.frequency);
        console.log('  - analysisScores.frequencia:', analysisScores.frequencia);
        console.log('  - analysisScores.technical:', analysisScores.technical);
        console.log('  - analysisScores.tecnico:', analysisScores.tecnico);
        console.log('  - analysisScores.subscores (objeto):', analysisScores.subscores);
        if (analysisScores.subscores) {
            console.log('    â†’ subscores.loudness:', analysisScores.subscores.loudness);
            console.log('    â†’ subscores.dynamics:', analysisScores.subscores.dynamics);
            console.log('    â†’ subscores.stereo:', analysisScores.subscores.stereo);
            console.log('    â†’ subscores.frequency:', analysisScores.subscores.frequency);
            console.log('    â†’ subscores.technical:', analysisScores.subscores.technical);
        }
        console.log('  - analysisScores.breakdown:', analysisScores.breakdown);
        console.log('  - analysisScores.final:', analysisScores.final);
        console.log('  - analysisScores.composite:', analysisScores.composite);
        
        // ğŸ” PARTE 5: DIAGNÃ“STICO FINAL - Identificar subscores NULL
        const nullScores = [];
        if (analysisScores.loudness === null || analysisScores.loudness === undefined) nullScores.push('loudness');
        if (analysisScores.dinamica === null || analysisScores.dinamica === undefined) nullScores.push('dinamica');
        if (analysisScores.estereo === null || analysisScores.estereo === undefined) nullScores.push('estereo');
        if (analysisScores.frequencia === null || analysisScores.frequencia === undefined) nullScores.push('frequencia');
        if (analysisScores.tecnico === null || analysisScores.tecnico === undefined) nullScores.push('tecnico');
        
        if (nullScores.length > 0) {
            console.error('âŒ [AUDIT-SCORES] SUBSCORES NULL DETECTADOS:', nullScores);
            console.error('âš ï¸ [AUDIT-SCORES] Causa provÃ¡vel: mÃ©tricas ausentes em analysis.metrics ou analysis.technicalData');
        } else {
            console.log('âœ… [AUDIT-SCORES] TODOS OS SUBSCORES SÃƒO VÃLIDOS');
        }
        console.groupEnd();
        
        // Adicionar scores Ã  anÃ¡lise
        analysis.scores = analysisScores;
        console.log('âœ… Scores calculados e adicionados Ã  anÃ¡lise');
        
        // TambÃ©m armazenar globalmente
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_SCORES__ = analysisScores;
        }
    } else {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel calcular scores (dados insuficientes)');
    }

    /* =========[ /BLOCO: SCORES A/B ]========= */
    
    // ğŸ”¥ REMOVIDO: Modal jÃ¡ foi aberto no inÃ­cio da funÃ§Ã£o (linha 8350)
    // Remover duplicaÃ§Ã£o de abertura do modal que estava causando problemas no modo gÃªnero
    
    // ğŸ¯ NOVO: Verificar se Ã© modo referÃªncia e adicionar seÃ§Ã£o de comparaÃ§Ã£o
    if (analysis.analysisMode === 'reference' && analysis.comparison) {
        addReferenceComparisonSection(analysis);
    }
    
    // Marcar se pacote avanÃ§ado chegou (LUFS integrado + Pico Real + LRA)
    // ğŸ” AUDITORIA: Verificar mÃºltiplos caminhos para lufsIntegrated e truePeakDbtp
    const lufsValue = analysis?.technicalData?.lufs_integrated ?? 
                     analysis?.technicalData?.lufsIntegrated ??
                     analysis?.metrics?.loudness?.integrated ??
                     analysis?.loudness?.integrated;
    
    const truePeakValue = analysis?.technicalData?.truePeakDbtp ??
                         analysis?.truePeak?.maxDbtp;
    
    const advancedReady = (
        Number.isFinite(lufsValue) && Number.isFinite(truePeakValue)
    );
    
    // ğŸ¯ LOGS DE DIAGNÃ“STICO - MÃ‰TRICAS PRINCIPAIS
    console.log('[METRICS-FIX] advancedReady:', advancedReady);
    console.log('[METRICS-FIX] LUFS=', lufsValue, {
        'technicalData.lufs_integrated': analysis?.technicalData?.lufs_integrated,
        'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
        'metrics.loudness.integrated': analysis?.metrics?.loudness?.integrated,
        'loudness.integrated': analysis?.loudness?.integrated
    });
    console.log('[METRICS-FIX] TRUEPEAK=', truePeakValue, {
        'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
        'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
    });
    
    if (typeof window !== 'undefined') window.__AUDIO_ADVANCED_READY__ = advancedReady;

    // Helpers seguros com bloqueio de fallback se advanced nÃ£o pronto
    const safeFixed = (v, d=1) => (Number.isFinite(v) ? v.toFixed(d) : 'â€”');
    const safeHz = (v) => (Number.isFinite(v) ? `${Math.round(v)} Hz` : 'â€”');
    const pct = (v, d=0) => (Number.isFinite(v) ? `${(v*100).toFixed(d)}%` : 'â€”');
    const tonalSummary = (tb) => {
        if (!tb || typeof tb !== 'object') return 'â€”';
        const parts = [];
        if (tb.sub && Number.isFinite(tb.sub.rms_db)) parts.push(`Sub ${tb.sub.rms_db.toFixed(1)}dB`);
        if (tb.low && Number.isFinite(tb.low.rms_db)) parts.push(`Low ${tb.low.rms_db.toFixed(1)}dB`);
        if (tb.mid && Number.isFinite(tb.mid.rms_db)) parts.push(`Mid ${tb.mid.rms_db.toFixed(1)}dB`);
        if (tb.high && Number.isFinite(tb.high.rms_db)) parts.push(`High ${tb.high.rms_db.toFixed(1)}dB`);
        return parts.length ? parts.join(' â€¢ ') : 'â€”';
    };

        // Layout com cards e KPIs, mantendo o container #modalTechnicalData
        const kpi = (value, label, cls='') => `
            <div class="kpi ${cls}">
                <div class="kpi-value">${value}</div>
                <div class="kpi-label">${label}</div>
            </div>`;

        const scoreKpi = Number.isFinite(analysis.qualityOverall) ? kpi(Number(analysis.qualityOverall.toFixed(1)), 'SCORE GERAL', 'kpi-score') : '';
        const timeKpi = Number.isFinite(analysis.processingMs) ? kpi(analysis.processingMs, 'TEMPO (MS)', 'kpi-time') : '';

        const src = (k) => (analysis.technicalData?._sources && analysis.technicalData._sources[k]) ? ` data-src="${analysis.technicalData._sources[k]}" title="origem: ${analysis.technicalData._sources[k]}"` : '';
        
        // ğŸ¯ MAPEAMENTO DE MÃ‰TRICAS COM TOOLTIPS
        const metricsTooltips = {
            // MÃ©tricas Principais
            'Volume mÃ©dio (rms)': 'Mostra o volume real percebido ao longo da faixa. Ajuda a saber se a mÃºsica estÃ¡ "forte" sem clipar.',
            'Loudness (lufs)': 'MÃ©dia geral de volume no padrÃ£o das plataformas de streaming. Ideal: â€“14 LUFS.',
            'Pico mÃ¡ximo (dbfs)': 'O ponto mais alto da onda sonora, Ãºtil pra evitar distorÃ§Ã£o.',
            'Pico real (dbtp)': 'Pico real detectado apÃ³s conversÃ£o digital. Deve ficar abaixo de â€“1 dBTP pra evitar clipagem.',
            'DinÃ¢mica (dr)': 'DiferenÃ§a entre os sons mais baixos e mais altos. Mais DR = mais respiro e punch.',
            'ConsistÃªncia de volume (lu)': 'Mede o quanto o volume se mantÃ©m constante. 0 LU Ã© estabilidade perfeita.',
            'Imagem estÃ©reo': 'Representa a largura e equilÃ­brio do estÃ©reo. 1 = mono, 0.9 = estÃ©reo amplo.',
            'Abertura estÃ©reo (%)': 'O quanto a faixa "abre" nos lados. Sons amplos soam mais envolventes.',
            
            // AnÃ¡lise de FrequÃªncias
            'Subgrave (20â€“60 hz)': 'RegiÃ£o das batidas mais profundas, sentida mais do que ouvida.',
            'Graves (60â€“150 hz)': 'Corpo do kick e do baixo. Cuidado pra nÃ£o embolar.',
            'MÃ©dios-graves (150â€“500 hz)': 'Base harmÃ´nica. Excesso aqui soa abafado.',
            'MÃ©dios (500 hzâ€“2 khz)': 'Clareza e presenÃ§a de vocais e instrumentos.',
            'MÃ©dios-agudos (2â€“5 khz)': 'Ataque e definiÃ§Ã£o. Muito = som agressivo.',
            'PresenÃ§a (5â€“10 khz)': 'Brilho, clareza e detalhe.',
            'Ar (10â€“20 khz)': 'SensaÃ§Ã£o de espaÃ§o e abertura.',
            'FrequÃªncia central (hz)': 'Mostra onde estÃ¡ o "centro tonal" da faixa.',
            
            // MÃ©tricas AvanÃ§adas
            'Fator de crista (crest factor)': 'DiferenÃ§a entre pico e volume mÃ©dio. Mostra o punch e headroom.',
            'Centro espectral (hz)': 'FrequÃªncia onde estÃ¡ concentrada a energia da mÃºsica.',
            'ExtensÃ£o de agudos (hz)': 'Indica atÃ© onde chegam as altas frequÃªncias.',
            'Uniformidade espectral (%)': 'Mede se o som estÃ¡ equilibrado entre graves, mÃ©dios e agudos.',
            'Bandas espectrais (n)': 'Quantidade de faixas de frequÃªncia analisadas.',
            'Kurtosis espectral': 'Mede picos anormais no espectro (distorÃ§Ã£o, harshness).',
            'Assimetria espectral': 'Mostra se o espectro estÃ¡ mais "pendendo" pros graves ou pros agudos.'
        };
        
        const row = (label, valHtml, keyForSource=null) => {
            // Usar sistema de enhancement se disponÃ­vel
            const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
                ? window.enhanceRowLabel(label, keyForSource) 
                : label;
            
            // Limpar label (trim) e capitalizar primeira letra
            const cleanLabel = enhancedLabel.trim();
            const capitalizedLabel = cleanLabel.charAt(0).toUpperCase() + cleanLabel.slice(1);
            
            // Verificar se existe tooltip para essa mÃ©trica (case-insensitive)
            const labelLowerCase = capitalizedLabel.toLowerCase();
            let tooltip = null;
            
            // Buscar tooltip comparando case-insensitive
            for (const [key, value] of Object.entries(metricsTooltips)) {
                if (key.toLowerCase() === labelLowerCase) {
                    tooltip = value;
                    break;
                }
            }
            
            // Gerar HTML do label com Ã­cone de info e tooltip
            const labelHtml = tooltip 
                ? `<div class="metric-label-container">
                     <span style="flex: 1;">${capitalizedLabel}</span>
                     <span class="metric-info-icon" 
                           data-tooltip="${tooltip.replace(/"/g, '&quot;')}"
                           onmouseenter="showMetricTooltip(this, event)"
                           onmouseleave="hideMetricTooltip()">â„¹ï¸</span>
                   </div>`
                : capitalizedLabel;
            
            return `
                <div class="data-row"${keyForSource?src(keyForSource):''}>
                    <span class="label">${labelHtml}</span>
                    <span class="value">${valHtml}</span>
                </div>`;
        };

        // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ãµes de acesso unificado com fallbacks robustos
        const getNestedValue = (obj, path) => {
            if (!obj || !path) return null;
            return path.split('.').reduce((current, key) => current?.[key], obj);
        };

        // ğŸ”§ getMetricWithFallback: Suporta mÃºltiplos caminhos de fallback em ordem de prioridade
        const getMetricWithFallback = (paths, defaultValue = null) => {
            if (!Array.isArray(paths)) paths = [paths];
            
            for (const pathConfig of paths) {
                let value = null;
                
                if (typeof pathConfig === 'string') {
                    // Caminho simples: tenta metrics > technicalData
                    value = getNestedValue(analysis.metrics, pathConfig) ?? 
                           getNestedValue(analysis.technicalData, pathConfig);
                } else if (Array.isArray(pathConfig)) {
                    // Array de caminhos aninhados: ['loudness', 'integrated']
                    value = getNestedValue(analysis, pathConfig.join('.'));
                }
                
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            
            return defaultValue;
        };

        const getMetric = (metricPath, fallbackPath = null) => {
            // Prioridade: metrics centralizadas > technicalData legado > fallback
            const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
            if (Number.isFinite(centralizedValue)) {
                // Log temporÃ¡rio para validaÃ§Ã£o
                if (typeof window !== 'undefined' && window.METRICS_UI_VALIDATION !== false) {
                    const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
                    if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                        console.warn(`ğŸ¯ METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                    }
                }
                return centralizedValue;
            }
            
            // Fallback para technicalData legado
            const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
            return Number.isFinite(legacyValue) ? legacyValue : null;
        };

        const safePct = (v) => (Number.isFinite(v) ? `${(v*100).toFixed(0)}%` : 'â€”');
        const monoCompat = (s) => s ? s : 'â€”';

        // FunÃ§Ã£o para obter o valor LUFS integrado usando mÃ©tricas centralizadas
        const getLufsIntegratedValue = () => {
            return getMetric('lufs_integrated', 'lufsIntegrated');
        };

        // ğŸ¯ FUNÃ‡ÃƒO DE STATUS DO TRUE PEAK (CORREÃ‡ÃƒO CRÃTICA)
        const getTruePeakStatus = (value) => {
            if (!Number.isFinite(value)) return { status: 'â€”', class: '' };
            
            if (value <= -1.5) return { status: 'EXCELENTE', class: 'status-excellent' };
            if (value <= -1.0) return { status: 'IDEAL', class: 'status-ideal' };
            if (value <= -0.5) return { status: 'BOM', class: 'status-good' };
            if (value <= 0.0) return { status: 'ACEITÃVEL', class: 'status-warning' };
            return { status: 'ESTOURADO', class: 'status-critical' };
        };

        const col1 = [
            // ğŸŸ£ CARD 1: MÃ‰TRICAS PRINCIPAIS - Reorganizado com fallbacks robustos
            // CONDITIONAL: Pico MÃ¡ximo - sÃ³ exibir se nÃ£o for placeholder 0.000
            (Number.isFinite(getMetric('peak_db', 'peak')) && getMetric('peak_db', 'peak') !== 0 ? row('Pico MÃ¡ximo (dBFS)', `${safeFixed(getMetric('peak_db', 'peak'))} dB`, 'peak') : ''),
            
            // ğŸ¯ Pico Real (dBTP) - com fallbacks robustos ['truePeak','maxDbtp'] > technicalData.truePeakDbtp
            (() => {
                const tpValue = getMetricWithFallback([
                    ['truePeak', 'maxDbtp'],
                    'truePeakDbtp',
                    'technicalData.truePeakDbtp'
                ]);
                console.log('[METRICS-FIX] col1 > Pico Real - advancedReady:', advancedReady, 'tpValue:', tpValue);
                if (!advancedReady) {
                    console.warn('[METRICS-FIX] col1 > Pico Real BLOQUEADO por advancedReady=false');
                    return '';
                }
                if (tpValue === null || tpValue === undefined) {
                    console.warn('[METRICS-FIX] col1 > Pico Real NÃƒO ENCONTRADO em nenhum caminho');
                    return '';
                }
                if (!Number.isFinite(tpValue)) {
                    console.warn('[METRICS-FIX] col1 > Pico Real valor invÃ¡lido:', tpValue);
                    return '';
                }
                const tpStatus = getTruePeakStatus(tpValue);
                console.log('[METRICS-FIX] col1 > Pico Real RENDERIZADO:', tpValue, 'dBTP status:', tpStatus.status);
                return row('Pico Real (dBTP)', `${safeFixed(tpValue, 2)} dBTP <span class="${tpStatus.class}">${tpStatus.status}</span>`, 'truePeakDbtp');
            })(),
            
            // ğŸ¯ Volume MÃ©dio (RMS) - energia real em dBFS
            (() => {
                const rmsValue = getMetricWithFallback([
                    ['energy', 'rms'],
                    'avgLoudness',
                    'rms',
                    'technicalData.avgLoudness',
                    'technicalData.rms'
                ]);
                console.log('[AUDITORIA-RMS-LUFS] col1 > Volume MÃ©dio (RMS) - advancedReady:', advancedReady, 'rmsValue:', rmsValue);
                
                // ğŸ¯ Exibir sempre, mesmo se 0 (valor tÃ©cnico vÃ¡lido)
                if (rmsValue === null || rmsValue === undefined) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > Volume MÃ©dio (RMS) NÃƒO ENCONTRADO - exibindo 0');
                    return row('Volume MÃ©dio (RMS)', `0.0 dBFS`, 'avgLoudness');
                }
                if (!Number.isFinite(rmsValue)) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > Volume MÃ©dio (RMS) valor invÃ¡lido:', rmsValue);
                    return row('Volume MÃ©dio (RMS)', `0.0 dBFS`, 'avgLoudness');
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > Volume MÃ©dio (RMS) RENDERIZADO:', rmsValue, 'dBFS');
                return row('Volume MÃ©dio (RMS)', `${safeFixed(rmsValue, 1)} dBFS`, 'avgLoudness');
            })(),
            
            // ğŸ¯ Loudness (LUFS) - loudness perceptiva em LUFS
            (() => {
                const lufsValue = getMetricWithFallback([
                    ['loudness', 'integrated'],
                    'lufs_integrated',
                    'lufsIntegrated',
                    'technicalData.lufsIntegrated'
                ]);
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) - advancedReady:', advancedReady, 'lufsValue:', lufsValue);
                
                if (!advancedReady) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS BLOQUEADO por advancedReady=false');
                    return '';
                }
                // ğŸ¯ Exibir sempre, mesmo se 0
                if (lufsValue === null || lufsValue === undefined) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS NÃƒO ENCONTRADO - exibindo 0');
                    return row('Loudness (LUFS)', `0.0 LUFS`, 'lufsIntegrated');
                }
                if (!Number.isFinite(lufsValue)) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS valor invÃ¡lido:', lufsValue);
                    return row('Loudness (LUFS)', `0.0 LUFS`, 'lufsIntegrated');
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) RENDERIZADO:', lufsValue, 'LUFS');
                return row('Loudness (LUFS)', `${safeFixed(lufsValue, 1)} LUFS`, 'lufsIntegrated');
            })(),
            
            row('DinÃ¢mica (DR)', `${safeFixed(getMetric('dynamic_range', 'dynamicRange'))} dB`, 'dynamicRange'),
            row('ConsistÃªncia de Volume (LU)', `${safeFixed(getMetric('lra', 'lra'))} LU`, 'lra'),
            // Imagem EstÃ©reo (movido de col2)
            row('Imagem EstÃ©reo', Number.isFinite(getMetric('stereo_correlation', 'stereoCorrelation')) ? safeFixed(getMetric('stereo_correlation', 'stereoCorrelation'), 3) : 'â€”', 'stereoCorrelation'),
            // Abertura EstÃ©reo (movido de col2)
            row('Abertura EstÃ©reo (%)', Number.isFinite(getMetric('stereo_width', 'stereoWidth')) ? `${safeFixed(getMetric('stereo_width', 'stereoWidth') * 100, 0)}%` : 'â€”', 'stereoWidth')
            ].join('');

        const col2 = (() => {
            // ğŸ”µ CARD 2: ANÃLISE DE FREQUÃŠNCIAS - Reorganizado com sub-bandas espectrais
            const rows = [];
            
            // Sub-bandas espectrais (movidas de advancedMetricsCard)
            const spectralBands = analysis.technicalData?.spectral_balance || 
                                analysis.technicalData?.spectralBands || 
                                analysis.metrics?.bands || {};
            
            if (Object.keys(spectralBands).length > 0) {
                const bandMap = {
                    sub: { name: 'Subgrave (20â€“60 Hz)', range: '20-60Hz' },
                    bass: { name: 'Graves (60â€“150 Hz)', range: '60-150Hz' },
                    lowMid: { name: 'MÃ©dios-Graves (150â€“500 Hz)', range: '150-500Hz' },
                    mid: { name: 'MÃ©dios (500 Hzâ€“2 kHz)', range: '500-2000Hz' },
                    highMid: { name: 'MÃ©dios-Agudos (2â€“5 kHz)', range: '2000-5000Hz' },
                    presence: { name: 'PresenÃ§a (5â€“10 kHz)', range: '5000-10000Hz' },
                    air: { name: 'Ar (10â€“20 kHz)', range: '10000-20000Hz' }
                };
                
                Object.keys(bandMap).forEach(bandKey => {
                    const bandData = spectralBands[bandKey];
                    if (bandData && typeof bandData === 'object') {
                        const energyDb = bandData.energy_db;
                        const percentage = bandData.percentage;
                        const status = bandData.status;
                        
                        if (status && status !== 'not_calculated') {
                            let displayValue = '';
                            if (Number.isFinite(energyDb) && Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB (${safeFixed(percentage, 1)}%)`;
                            } else if (Number.isFinite(energyDb)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB`;
                            } else if (Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(percentage, 1)}%`;
                            } else {
                                displayValue = 'nÃ£o calculado';
                            }
                            rows.push(row(bandMap[bandKey].name, displayValue, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`));
                        }
                    } else if (Number.isFinite(bandData)) {
                        rows.push(row(bandMap[bandKey].name, `${safeFixed(bandData, 1)} dB`, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`));
                    }
                });
            }
            
            // FrequÃªncia Central (mantÃ©m aqui)
            rows.push(row('FrequÃªncia Central (Hz)', Number.isFinite(getMetric('spectral_centroid', 'spectralCentroidHz')) ? safeHz(getMetric('spectral_centroid', 'spectralCentroidHz')) : 'â€”', 'spectralCentroidHz'));
            
            return rows.join('');
            // REMOVED: CorrelaÃ§Ã£o EstÃ©reo - movido para col1
            // REMOVED: Largura EstÃ©reo - movido para col1
        })();

            // ğŸ§© CORREÃ‡ÃƒO #5: Exibir frequÃªncias dominantes na UI (removido bloqueio)
            // FrequÃªncias dominantes agora visÃ­veis
            console.log('ğŸ›ï¸ [DEBUG] Exibindo mÃ©tricas de frequÃªncia na UI');
            
            const col3 = [
                // REMOVED: Dominant Frequencies UI (mantendo cÃ¡lculo interno para suggestions)
                
                // REMOVED: clipping (%) - ocultado da interface conforme solicitado
                // REMOVED: dc offset - ocultado da interface conforme solicitado
                (Number.isFinite(getMetric('thd', 'thd')) ? row('thd', `${safeFixed(getMetric('thd', 'thd'), 2)}%`, 'thd') : ''),
                
                // REMOVED: DinÃ¢mica e Fator de Crista duplicados - jÃ¡ exibidos em col1
                // REMOVED: row('CorrelaÃ§Ã£o EstÃ©reo (largura)') - duplicado de col2
                // REMOVED: row('fator de crista') - duplicado de col1
                // REMOVED: row('DinÃ¢mica (diferenÃ§a entre alto/baixo)') - duplicado de col1 com DR e LRA
                
                // REMOVED: Placeholders hardcoded - substituir por valores reais quando disponÃ­veis
                // row('crest consist', 'Î”=4.43 check', 'crestConsist'),
                // row('VariaÃ§Ã£o de Volume (consistÃªncia)', 'ok', 'volumeConsistency'),
                
                // REMOVED: Problemas - ocultado da interface conforme solicitado
                // REMOVED: SugestÃµes - movido para o final do card MÃ‰TRICAS AVANÃ‡ADAS
                // row('SugestÃµes', (analysis.suggestions?.length || 0) > 0 ? `<span class="tag tag-success">${analysis.suggestions.length} disponÃ­vel(s)</span>` : 'â€”')
                // REMOVED: col3Extras (dominant frequencies UI)
            ].join('');

            // Card extra: MÃ©tricas AvanÃ§adas (expandido para Web Audio API compatibility)
            const advancedMetricsCard = () => {
                const rows = [];
                
                // === MÃ‰TRICAS DE PICO E CLIPPING (seÃ§Ã£o principal) ===
                
                // REMOVED: True Peak (dBTP) - agora exclusivo do card MÃ‰TRICAS PRINCIPAIS
                // Se truePeakDbtp estiver mapeado no card de avanÃ§adas, remova de lÃ¡. 
                // True Peak deve existir apenas em MÃ©tricas Principais para evitar duplicaÃ§Ã£o
                
                // Picos por canal separados
                if (Number.isFinite(analysis.technicalData?.samplePeakLeftDb)) {
                    rows.push(row('Pico L (dBFS)', `${safeFixed(analysis.technicalData.samplePeakLeftDb, 1)} dBFS`, 'samplePeakLeftDb'));
                }
                if (Number.isFinite(analysis.technicalData?.samplePeakRightDb)) {
                    rows.push(row('Pico R (dBFS)', `${safeFixed(analysis.technicalData.samplePeakRightDb, 1)} dBFS`, 'samplePeakRightDb'));
                }
                
                // REMOVED: Clipping (%) - ocultado da interface conforme solicitado
                
                // REMOVED: Clipping samples - ocultado da interface conforme solicitado
                
                // REMOVED: DC OFFSET - ocultado da interface conforme solicitado
                
                // === THD (Total Harmonic Distortion) ===
                if (Number.isFinite(analysis.technicalData?.thd)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thd, 4)}%`, 'thd'));
                } else if (Number.isFinite(analysis.technicalData?.thdPercent)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thdPercent, 4)}%`, 'thdPercent'));
                }
                
                // === HEADROOM ===
                if (Number.isFinite(analysis.technicalData?.headroomDb)) {
                    rows.push(row('headroom (dB)', `${safeFixed(analysis.technicalData.headroomDb, 1)} dB`, 'headroomDb'));
                }
                
                // === FATOR DE CRISTA (movido de MÃ‰TRICAS PRINCIPAIS) ===
                const crestValue = getMetricWithFallback([
                    ['dynamics', 'crest'],
                    'crest_factor',
                    'crestFactor',
                    'technicalData.crestFactor'
                ]);
                if (Number.isFinite(crestValue)) {
                    console.log('[METRICS-FIX] advancedMetricsCard > Fator de Crista RENDERIZADO:', crestValue, 'dB');
                    rows.push(row('Fator de Crista (Crest Factor)', `${safeFixed(crestValue, 2)} dB`, 'crestFactor'));
                } else {
                    console.warn('[METRICS-FIX] advancedMetricsCard > Fator de Crista NÃƒO ENCONTRADO ou invÃ¡lido:', crestValue);
                }
                
                // ğŸŸ¢ CARD 3: MÃ‰TRICAS AVANÃ‡ADAS - Sub-bandas espectrais REMOVIDAS (movidas para col2)
                // === MÃ‰TRICAS ESPECTRAIS AVANÃ‡ADAS ===
                
                // Centro Espectral
                if (Number.isFinite(analysis.technicalData?.spectralCentroid)) {
                    rows.push(row('Centro Espectral (Hz)', `${Math.round(analysis.technicalData.spectralCentroid)} Hz`, 'spectralCentroid'));
                }
                
                // Spectral Rolloff (ExtensÃ£o de agudos)
                if (Number.isFinite(analysis.technicalData?.spectralRolloff)) {
                    rows.push(row('ExtensÃ£o de Agudos (Hz)', `${Math.round(analysis.technicalData.spectralRolloff)} Hz`, 'spectralRolloff'));
                }
                
                // Spectral Flatness (Uniformidade espectral)
                if (Number.isFinite(analysis.technicalData?.spectralFlatness)) {
                    rows.push(row('Uniformidade Espectral (%)', `${safeFixed(analysis.technicalData.spectralFlatness * 100, 1)}%`, 'spectralFlatness'));
                }
                
                // Spectral Bandwidth (Bandas espectrais)
                if (Number.isFinite(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))) {
                    rows.push(row('Bandas Espectrais (n)', `${safeHz(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))}`, 'spectralBandwidthHz'));
                }
                
                // Spectral Kurtosis
                if (Number.isFinite(analysis.technicalData?.spectralKurtosis)) {
                    rows.push(row('Kurtosis Espectral', `${safeFixed(analysis.technicalData.spectralKurtosis, 3)}`, 'spectralKurtosis'));
                }
                
                // Spectral Skewness
                if (Number.isFinite(analysis.technicalData?.spectralSkewness)) {
                    rows.push(row('Assimetria Espectral', `${safeFixed(analysis.technicalData.spectralSkewness, 3)}`, 'spectralSkewness'));
                }
                
                // === REMOVIDO: BANDAS ESPECTRAIS DETALHADAS (Sub, Bass, Low-Mid, etc.) ===
                // As sub-bandas espectrais foram movidas para o card "ANÃLISE DE FREQUÃŠNCIAS" (col2)
                // Comentado para evitar duplicaÃ§Ã£o
                
                if (false && Object.keys({}).length > 0) {
                    // REMOVIDO: CÃ³digo de bandas espectrais (sub, bass, lowMid, etc.)
                    // As sub-bandas espectrais foram movidas para col2 (ANÃLISE DE FREQUÃŠNCIAS)
                    // Este bloco foi comentado para evitar duplicaÃ§Ã£o
                }
                
                // ğŸ§© CORREÃ‡ÃƒO #5: Exibir frequÃªncias dominantes e uniformidade espectral
                // === FREQUÃŠNCIAS DOMINANTES ===
                if (Array.isArray(analysis.technicalData?.dominantFrequencies) && analysis.technicalData.dominantFrequencies.length > 0) {
                    const freqList = analysis.technicalData.dominantFrequencies
                        .slice(0, 5)
                        .map(f => `${Math.round(f)}Hz`)
                        .join(', ');
                    rows.push(row('frequÃªncias dominantes', freqList, 'dominantFrequencies'));
                    console.log('ğŸ›ï¸ [DEBUG] FrequÃªncias dominantes exibidas:', freqList);
                }
                
                // === UNIFORMIDADE ESPECTRAL ===
                if (Number.isFinite(analysis.technicalData?.spectralUniformity)) {
                    rows.push(row('uniformidade espectral', `${safeFixed(analysis.technicalData.spectralUniformity, 3)}`, 'spectralUniformity'));
                    console.log('ğŸ›ï¸ [DEBUG] Uniformidade espectral exibida:', analysis.technicalData.spectralUniformity);
                }
                
                // === ZEROS CROSSING RATE ===
                if (Number.isFinite(analysis.technicalData?.zcr)) {
                    rows.push(row('zero crossings', `${Math.round(analysis.technicalData.zcr)}`, 'zeroCrossings'));
                }
                
                // === MFCC (primeiros coeficientes) ===
                if (Array.isArray(analysis.technicalData?.mfcc) && analysis.technicalData.mfcc.length > 0) {
                    analysis.technicalData.mfcc.slice(0, 3).forEach((coeff, idx) => {
                        if (Number.isFinite(coeff)) {
                            rows.push(row(`mfcc ${idx + 1}`, `${safeFixed(coeff, 3)}`, `mfcc${idx + 1}`));
                        }
                    });
                }
                
                // === SUGESTÃ•ES DISPONÃVEIS (movido de SCORES & DIAGNÃ“STICO) ===
                const suggestionsCount = analysis.suggestions?.length || 0;
                console.log('[AUDITORIA-SUGESTOES] SugestÃµes detectadas:', suggestionsCount);
                
                if (suggestionsCount > 0) {
                    rows.push(row('SugestÃµes', `<span class="tag tag-success">${suggestionsCount} DISPONÃVEL${suggestionsCount > 1 ? 'S' : ''}</span>`, 'suggestions'));
                }
                
                return rows.join('') || row('Status', 'Sem mÃ©tricas avanÃ§adas disponÃ­veis');
            };

            // Card extra: Problemas TÃ©cnicos detalhados
            const techProblems = () => {
                const rows = [];
                let hasActualProblems = false;
                
                // ===== SEMPRE MOSTRAR TODAS AS MÃ‰TRICAS TÃ‰CNICAS =====
                
                // 1. Clipping - SEMPRE mostrar com valores reais
                const clipVal = Number.isFinite(analysis.technicalData?.clippingSamples) ? analysis.technicalData.clippingSamples : 0;
                const clipPct = Number.isFinite(analysis.technicalData?.clippingPct) ? analysis.technicalData.clippingPct : 0;
                // ğŸ¯ CLIPPING PRECEDENCE V2: Usar nova lÃ³gica de precedÃªncia
                const peak = Number.isFinite(analysis.technicalData?.peak) ? analysis.technicalData.peak : -Infinity;
                const truePeak = Number.isFinite(analysis.technicalData?.truePeakDbtp) ? analysis.technicalData.truePeakDbtp : null;
                
                // Verificar se temos dados do novo sistema de precedÃªncia
                const precedenceData = analysis.technicalData?._singleStage;
                let hasClippingProblem, clipText, clipClass;
                
                if (precedenceData && precedenceData.source === 'enhanced-clipping-v2') {
                    // ğŸš€ Usar novo sistema de precedÃªncia
                    const isClipped = precedenceData.finalState === 'CLIPPED';
                    const isTruePeakOnly = precedenceData.finalState === 'TRUE_PEAK_ONLY';
                    hasClippingProblem = isClipped || isTruePeakOnly;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = isClipped ? 'error' : 'warn'; // CLIPPED Ã© mais severo que TRUE_PEAK_ONLY
                        
                        const details = [];
                        if (isClipped) {
                            details.push(`ğŸ”´ CLIPPED: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                            if (precedenceData.precedenceApplied) {
                                details.push(`TP override: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                            }
                        } else if (isTruePeakOnly) {
                            details.push(`ğŸŸ¡ TruePeak: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        }
                        
                        if (precedenceData.clippingSamples > 0) {
                            details.push(`${precedenceData.clippingSamples} samples (${precedenceData.clippingPct.toFixed(3)}%)`);
                        }
                        
                        clipText = details.join(' | ');
                    } else {
                        // Estado limpo com novo sistema
                        const safeDetails = [];
                        safeDetails.push(`âœ… Sample: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                        safeDetails.push(`TP: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        safeDetails.push(`${precedenceData.clippingSamples} samples`);
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                } else {
                    // ğŸ”„ Fallback para sistema legado
                    const hasPeakClipping = peak > -0.1;
                    const hasTruePeakClipping = truePeak !== null && truePeak > -0.1;
                    const hasSampleClipping = clipVal > 0;
                    const hasPercentageClipping = clipPct > 0;
                    
                    hasClippingProblem = hasPeakClipping || hasTruePeakClipping || hasSampleClipping || hasPercentageClipping;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = 'warn';
                        
                        const details = [];
                        if (hasPeakClipping) details.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (hasTruePeakClipping) details.push(`TruePeak: ${truePeak.toFixed(2)}dBTP`);
                        if (hasSampleClipping) details.push(`${clipVal} samples (${clipPct.toFixed(3)}%)`);
                        
                        clipText = details.join(' | ');
                    } else {
                        const safeDetails = [];
                        safeDetails.push(`${clipVal} samples`);
                        if (peak > -Infinity) safeDetails.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (truePeak !== null) safeDetails.push(`TP: ${truePeak.toFixed(2)}dBTP`);
                        
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                }
                rows.push(row('Clipping', `<span class="${clipClass}">${clipText}</span>`, 'clippingSamples'));
                
                // 2. DC Offset - SEMPRE mostrar (usando nova estrutura)
                let dcVal, hasDcProblem, dcClass;
                if (analysis.dcOffset && Number.isFinite(analysis.dcOffset.maxAbsDC)) {
                    // Usar nova estrutura detalhada
                    dcVal = analysis.dcOffset.maxAbsDC;
                    hasDcProblem = analysis.dcOffset.needsCorrection || analysis.dcOffset.severity !== 'none';
                    dcClass = hasDcProblem ? (analysis.dcOffset.isCritical ? 'error' : 'warn') : '';
                    if (hasDcProblem) hasActualProblems = true;
                    const dcDetails = `Max: ${safeFixed(dcVal, 4)} | L: ${safeFixed(analysis.dcOffset.leftDC, 4)} | R: ${safeFixed(analysis.dcOffset.rightDC, 4)} | ${analysis.dcOffset.severity}`;
                    rows.push(row('DC Offset (Detalhado)', `<span class="${dcClass}">${dcDetails}</span>`, 'dcOffset'));
                } else {
                    // Fallback para estrutura legada
                    dcVal = Number.isFinite(analysis.technicalData?.dcOffset) ? analysis.technicalData.dcOffset : 0;
                    hasDcProblem = Math.abs(dcVal) > 0.01;
                    if (hasDcProblem) hasActualProblems = true;
                    dcClass = hasDcProblem ? 'warn' : '';
                    rows.push(row('DC Offset', `<span class="${dcClass}">${safeFixed(dcVal, 4)}</span>`, 'dcOffset'));
                }
                
                // 3. THD - SEMPRE mostrar
                const thdVal = Number.isFinite(analysis.technicalData?.thdPercent) ? analysis.technicalData.thdPercent : 0;
                const hasThdProblem = thdVal > 1.0;
                if (hasThdProblem) hasActualProblems = true;
                const thdClass = hasThdProblem ? 'warn' : '';
                rows.push(row('THD', `<span class="${thdClass}">${safeFixed(thdVal, 2)}%</span>`, 'thdPercent'));
                
                // 4. Stereo Correlation - SEMPRE mostrar
                const stereoCorr = Number.isFinite(analysis.technicalData?.stereoCorrelation) ? analysis.technicalData.stereoCorrelation : 0;
                const hasStereoProb = stereoCorr !== null && (stereoCorr < -0.3 || stereoCorr > 0.95);
                if (hasStereoProb) hasActualProblems = true;
                const stereoClass = hasStereoProb ? 'warn' : '';
                let stereoText = safeFixed(stereoCorr, 3);
                if (hasStereoProb) {
                    const status = stereoCorr < -0.3 ? 'Fora de fase' : 'Mono demais';
                    stereoText += ` (${status})`;
                }
                rows.push(row('Stereo Corr.', `<span class="${stereoClass}">${stereoText}</span>`, 'stereoCorrelation'));
                
                // 5. Fator de Crista - SEMPRE mostrar  
                const crestVal = Number.isFinite(analysis.technicalData?.crestFactor) ? analysis.technicalData.crestFactor : 0;
                const hasCrestProblem = crestVal < 6 || crestVal > 20; // Valores normais: 6-20dB
                if (hasCrestProblem) hasActualProblems = true;
                const crestClass = hasCrestProblem ? 'warn' : '';
                rows.push(row('Fator de Crista', `<span class="${crestClass}">${safeFixed(crestVal, 1)} dB</span>`, 'crestFactor'));
                
                // ConsistÃªncia (se disponÃ­vel) - mas sempre tentar mostrar
                if (analysis.metricsValidation && Object.keys(analysis.metricsValidation).length) {
                    const mv = analysis.metricsValidation;
                    const badge = (k,v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:${v==='ok'?'#143f2b':(v==='warn'?'#4d3808':'#4a1d1d')};color:${v==='ok'?'#29c182':(v==='warn'?'#ffce4d':'#ff7d7d')};margin-left:6px;">${v}</span>`;
                    
                    if (mv.dynamicRangeConsistency) {
                        rows.push(row('DR ConsistÃªncia', `Î”=${mv.dynamicRangeDelta || '0'} ${badge('dr', mv.dynamicRangeConsistency)}`));
                        if (mv.dynamicRangeConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('DR ConsistÃªncia', `<span style="opacity:0.6;">Î”=0 ${badge('dr', 'ok')}</span>`));
                    }
                    
                    if (mv.crestFactorConsistency) {
                        rows.push(row('Crest Consist.', `Î”=${mv.crestVsExpectedDelta || '0'} ${badge('cf', mv.crestFactorConsistency)}`));
                        if (mv.crestFactorConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Î”=0 ${badge('cf', 'ok')}</span>`));
                    }
                    
                    if (mv.lraPlausibility) {
                        rows.push(row('LRA PlausÃ­vel', badge('lra', mv.lraPlausibility)));
                        if (mv.lraPlausibility !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('LRA PlausÃ­vel', `<span style="opacity:0.6;">${badge('lra', 'ok')}</span>`));
                    }
                } else {
                    // Mostrar como nÃ£o disponÃ­vel/OK
                    const badge = (v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:#143f2b;color:#29c182;margin-left:6px;">${v}</span>`;
                    rows.push(row('DR ConsistÃªncia', `<span style="opacity:0.6;">Î”=0 ${badge('ok')}</span>`));
                    rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Î”=0 ${badge('ok')}</span>`));
                    rows.push(row('LRA PlausÃ­vel', `<span style="opacity:0.6;">${badge('ok')}</span>`));
                }
                
                return rows.join('');
            };

            // Card extra: DiagnÃ³stico & SugestÃµes listados
            const diagCard = () => {
                // =========================================================================
                // ğŸš¨ AUDITORIA: RENDERIZAÃ‡ÃƒO DE SUGESTÃ•ES
                // =========================================================================
                console.log('[RENDER_SUGGESTIONS] âœ… Iniciada');
                
                const blocks = [];
                
                // ğŸ” DEBUG: Verificar estado das sugestÃµes
                console.log('ğŸ” [DEBUG_SUGGESTIONS] analysis.suggestions:', analysis.suggestions);
                console.log('ğŸ” [DEBUG_SUGGESTIONS] anÃ¡lise completa de sugestÃµes:', {
                    hasAnalysis: !!analysis,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsType: typeof analysis.suggestions,
                    suggestionsLength: analysis.suggestions?.length || 0,
                    suggestionsArray: analysis.suggestions
                });

                // ğŸš€ INTEGRAÃ‡ÃƒO SISTEMA ULTRA-AVANÃ‡ADO V2: Enriquecimento direto das sugestÃµes existentes
                let enrichedSuggestions = analysis.suggestions || [];
                
                if (typeof window.UltraAdvancedSuggestionEnhancer !== 'undefined' && enrichedSuggestions.length > 0) {
                    try {
                        console.log('ğŸš€ [ULTRA_V2] Iniciando sistema ultra-avanÃ§ado V2...');
                        console.log('ğŸ“Š [ULTRA_V2] SugestÃµes para enriquecer:', enrichedSuggestions.length);
                        
                        const ultraEnhancer = new window.UltraAdvancedSuggestionEnhancer();
                        
                        // Preparar contexto de anÃ¡lise
                        const analysisContext = {
                            detectedGenre: analysis.detectedGenre || 'general',
                            lufs: analysis.lufs,
                            truePeak: analysis.truePeak,
                            lra: analysis.lra,
                            dynamics: analysis.dynamics,
                            fileName: analysis.fileName,
                            duration: analysis.duration,
                            sampleRate: analysis.sampleRate,
                            mode: analysis.mode || 'genre',
                            // âœ… MODO REFERENCE: Adicionar dados de comparaÃ§Ã£o A/B
                            referenceComparison: analysis.referenceComparison || null,
                            referenceJobId: analysis.referenceJobId || null,
                            referenceFileName: analysis.referenceFileName || null
                        };
                        
                        // âœ… Log para modo reference
                        if (analysisContext.mode === 'reference' && analysisContext.referenceComparison) {
                            console.log('[ULTRA_V2] ğŸ¯ Modo reference detectado - enriquecendo com dados de comparaÃ§Ã£o A/B');
                            console.log('[ULTRA_V2] ReferÃªncia:', analysisContext.referenceFileName);
                            console.log('[ULTRA_V2] Deltas disponÃ­veis:', Object.keys(analysisContext.referenceComparison));
                        }
                        
                        // ğŸš€ Enriquecer sugestÃµes existentes
                        const ultraResults = ultraEnhancer.enhanceExistingSuggestions(enrichedSuggestions, analysisContext);
                        
                        if (ultraResults && ultraResults.enhancedSuggestions && ultraResults.enhancedSuggestions.length > 0) {
                            enrichedSuggestions = ultraResults.enhancedSuggestions;
                            
                            console.log('âœ¨ [ULTRA_V2] Sistema ultra-avanÃ§ado V2 aplicado com sucesso!', {
                                originalCount: analysis.suggestions?.length || 0,
                                enhancedCount: enrichedSuggestions.length,
                                processingTime: ultraResults.metadata?.processingTimeMs,
                                educationalLevel: ultraResults.metadata?.educationalLevel
                            });
                            
                            // Adicionar mÃ©tricas do sistema ultra-avanÃ§ado Ã  anÃ¡lise
                            if (!analysis.enhancedMetrics) analysis.enhancedMetrics = {};
                            analysis.enhancedMetrics.ultraAdvancedSystem = {
                                applied: true,
                                version: ultraResults.metadata?.version,
                                processingTimeMs: ultraResults.metadata?.processingTimeMs,
                                enhancedCount: enrichedSuggestions.length,
                                educationalLevel: ultraResults.metadata?.educationalLevel,
                                originalCount: ultraResults.metadata?.originalCount
                            };
                            
                            // Log da primeira sugestÃ£o enriquecida para debug
                            if (enrichedSuggestions.length > 0) {
                                const firstEnhanced = enrichedSuggestions[0];
                                console.log('ğŸ“ [ULTRA_V2] Exemplo de sugestÃ£o enriquecida:', {
                                    original: firstEnhanced.message,
                                    educationalTitle: firstEnhanced.educationalContent?.title,
                                    hasDAWExamples: !!(firstEnhanced.educationalContent?.dawExamples),
                                    severity: firstEnhanced.severity?.label,
                                    priority: firstEnhanced.priority
                                });
                            }
                            
                        } else {
                            console.warn('âš ï¸ [ULTRA_V2] Sistema nÃ£o retornou sugestÃµes vÃ¡lidas:', ultraResults);
                        }
                        
                    } catch (error) {
                        console.error('âŒ [ULTRA_V2] Erro no sistema ultra-avanÃ§ado V2:', error);
                        // Manter sugestÃµes originais em caso de erro
                    }
                } else {
                    if (typeof window.UltraAdvancedSuggestionEnhancer === 'undefined') {
                        console.log('âš ï¸ [ULTRA_V2] Sistema ultra-avanÃ§ado V2 nÃ£o estÃ¡ disponÃ­vel');
                    } else {
                        console.log('âš ï¸ [ULTRA_V2] Nenhuma sugestÃ£o para processar');
                    }
                }
                
                // Atualizar analysis.suggestions com as sugestÃµes enriched
                analysis.suggestions = enrichedSuggestions;

                // Helpers para embelezar as sugestÃµes sem mudar layout/IDs
                const formatNumbers = (text, decimals = 2) => {
                    if (!text || typeof text !== 'string') return '';
                    return text.replace(/(-?\d+\.\d{3,})/g, (m) => {
                        const n = parseFloat(m);
                        return Number.isFinite(n) ? n.toFixed(decimals) : m;
                    });
                };
                const renderSuggestionItem = (sug) => {
                    // ğŸš€ PRIORIDADE: Verificar se tem conteÃºdo educacional do Sistema Ultra-AvanÃ§ado V2
                    const hasUltraV2Content = sug.educationalContent && sug.educationalContent.title;
                    
                    if (hasUltraV2Content) {
                        // ï¿½ SISTEMA ULTRA-AVANÃ‡ADO V2: Renderizar com conteÃºdo educacional completo
                        const edu = sug.educationalContent;
                        const severity = sug.severity || { level: 'medium', color: '#FF9800', label: 'Moderada' };
                        
                        // Extrair frequÃªncia se disponÃ­vel
                        const freqMatch = (edu.action || sug.action || '').match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz|khz|kHz)/i);
                        const frequency = freqMatch ? freqMatch[1] : null;
                        
                        return `
                            <div class="enhanced-card ultra-advanced-v2">
                                <div class="card-header">
                                    <h4 class="card-title">${edu.title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency}${frequency > 1000 ? 'Hz' : 'kHz'}</span>` : ''}
                                        <span class="severity-badge ${severity.level}" style="background-color: ${severity.color};">${severity.label}</span>
                                        <span class="priority-badge">P${sug.priority || 5}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: ${severity.color};">
                                    <strong>ğŸ“š ExplicaÃ§Ã£o:</strong> ${edu.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50;">
                                    <div class="card-action-title">ğŸ”§ AÃ§Ã£o Recomendada</div>
                                    <div class="card-action-content">${edu.action}</div>
                                </div>
                                
                                ${edu.dawExamples ? `
                                    <div class="card-daw-examples" style="background: rgba(33, 150, 243, 0.1); border-color: #2196F3; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                                        <div class="card-daw-title" style="font-weight: bold; margin-bottom: 8px; color: #2196F3;">ğŸ›ï¸ Exemplos por DAW</div>
                                        ${Object.entries(edu.dawExamples).map(([daw, instruction]) => 
                                            `<div style="margin-bottom: 6px;"><strong>${daw}:</strong> ${instruction}</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                                
                                ${edu.expectedResult ? `
                                    <div class="card-result" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                                        <div class="card-result-title" style="font-weight: bold; margin-bottom: 8px; color: #4CAF50;">âœ¨ Resultado Esperado</div>
                                        <div class="card-result-content">${edu.expectedResult}</div>
                                    </div>
                                ` : ''}
                                
                                ${edu.technicalDetails ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa; font-weight: bold;">ğŸ“‹ Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;">${edu.technicalDetails}</div>
                                    </details>
                                ` : ''}
                                
                                ${sug.educationalMetadata ? `
                                    <div class="educational-metadata" style="margin-top: 12px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; font-size: 11px; color: #888;">
                                        ğŸ“– Tempo de leitura: ${sug.educationalMetadata.estimatedReadTime} | 
                                        ğŸ¯ Dificuldade: ${sug.educationalMetadata.practicalDifficulty} | 
                                        ğŸ§  Conceitos: ${sug.educationalMetadata.concepts?.join(', ') || 'N/A'}
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    // ğŸ”„ FALLBACK: Sistema anterior se nÃ£o tiver conteÃºdo Ultra-AvanÃ§ado V2
                    const hasTextGenerator = typeof window.SuggestionTextGenerator !== 'undefined';
                    let didacticText = null;
                    
                    if (hasTextGenerator) {
                        try {
                            const generator = new window.SuggestionTextGenerator();
                            didacticText = generator.generateDidacticText(sug);
                        } catch (error) {
                            console.warn('[RenderSuggestion] Erro no gerador de texto:', error);
                        }
                    }
                    
                    // Usar texto didÃ¡tico se disponÃ­vel, senÃ£o usar texto original
                    const title = didacticText?.title || sug.message || '';
                    const explanation = didacticText?.explanation || sug.explanation || '';
                    const action = didacticText?.action || sug.action || '';
                    const rationale = didacticText?.rationale || '';
                    const technical = didacticText?.technical || sug.details || '';
                    
                    // ğŸ¯ SISTEMA MELHORADO: Verificar se tem informaÃ§Ãµes de severidade e prioridade
                    const hasEnhancedInfo = sug.severity && sug.priority;
                    const severityColor = hasEnhancedInfo ? sug.severity.color : '#9fb3d9';
                    const severityLevel = hasEnhancedInfo ? sug.severity.level : 'medium';
                    const severityLabel = hasEnhancedInfo ? sug.severity.label : '';
                    const priority = hasEnhancedInfo ? sug.priority : 0;
                    const confidence = hasEnhancedInfo ? sug.confidence : 1;
                    
                    // Detectar tipo de sugestÃ£o
                    const isSurgical = sug.type === 'surgical_eq' || (sug.subtype && ['sibilance', 'harshness', 'clipping'].includes(sug.subtype));
                    const isBandAdjust = sug.type === 'band_adjust';
                    const isClipping = sug.type === 'clipping' || title.toLowerCase().includes('clipping');
                    const isBalance = sug.type === 'balance' || title.toLowerCase().includes('balance');
                    
                    // Determinar classe do card
                    let cardClass = 'enhanced-card';
                    if (isSurgical) cardClass += ' surgical';
                    else if (isBandAdjust) cardClass += ' band-adjust';
                    else if (isClipping) cardClass += ' clipping';
                    else if (isBalance) cardClass += ' balance';
                    else cardClass += ' problem';
                    
                    // Extrair frequÃªncia e valores tÃ©cnicos
                    const freqMatch = (title + ' ' + action).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                    const frequency = freqMatch ? freqMatch[1] : null;
                    
                    const dbMatch = action.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                    const dbValue = dbMatch ? dbMatch[1] : null;
                    
                    const qMatch = action.match(/Q\s*[=:]?\s*(\d+(?:\.\d+)?)/i);
                    const qValue = qMatch ? qMatch[1] : null;
                    
                    // Extrair faixa de frequÃªncia se disponÃ­vel
                    const frequencyRange = sug.frequency_range || '';
                    const adjustmentDb = sug.adjustment_db;
                    
                    // ğŸš¨ VERIFICAR SE Ã‰ UM AVISO CRÃTICO
                    if (didacticText?.isCritical) {
                        return `
                            <div class="${cardClass} critical-alert">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸš¨ Problema CrÃ­tico</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge severa">CRÃTICO</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: #f44336;">
                                    <strong>âš ï¸ Problema:</strong> ${didacticText.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                    <div class="card-action-title" style="color: #f44336;">
                                        ğŸš¨ AÃ§Ã£o Urgente
                                    </div>
                                    <div class="card-action-content">${didacticText.action}</div>
                                </div>
                                
                                <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                    <div class="card-impact-title" style="color: #f44336;">âš ï¸ Por que Ã© crÃ­tico</div>
                                    <div class="card-impact-content">${didacticText.rationale}</div>
                                </div>
                            </div>`;
                    }
                    
                    if (isSurgical) {
                        // Card cirÃºrgico aprimorado
                        const context = title.replace(/\[\d+Hz\]/, '').replace(/\d+Hz/, '').trim();
                        const severity = severityLevel === 'high' ? 'alta' : (severityLevel === 'medium' ? 'moderada' : 'leve');
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸ”§ CorreÃ§Ã£o CirÃºrgica</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severity}">${severity}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>Problema detectado:</strong> ${context || explanation || 'RessonÃ¢ncia problemÃ¡tica identificada'}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸ›ï¸ AÃ§Ã£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequency || qValue || dbValue) ? `
                                    <div class="card-technical">
                                        ${frequency ? `
                                            <div class="tech-item">
                                                <div class="tech-label">FrequÃªncia</div>
                                                <div class="tech-value">${frequency} Hz</div>
                                            </div>
                                        ` : ''}
                                        ${dbValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ganho</div>
                                                <div class="tech-value">${dbValue} dB</div>
                                            </div>
                                        ` : ''}
                                        ${qValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Q Factor</div>
                                                <div class="tech-value">${qValue}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">âš ï¸ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    } 
                    
                    else if (isBandAdjust) {
                        // Card de ajuste de banda aprimorado
                        const shouldBoost = adjustmentDb > 0 || action.toLowerCase().includes('aumentar') || action.toLowerCase().includes('boost');
                        const actionIcon = shouldBoost ? 'ğŸ“ˆ' : 'ğŸ“‰';
                        const actionType = shouldBoost ? 'Boost' : 'Corte';
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">${actionIcon} Ajuste de Banda</h4>
                                    <div class="card-badges">
                                        ${frequencyRange ? `<span class="frequency-badge">${frequencyRange}</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${actionType}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>AnÃ¡lise:</strong> ${explanation || title}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸšï¸ Como Ajustar
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequencyRange || adjustmentDb) ? `
                                    <div class="card-technical">
                                        ${frequencyRange ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Faixa</div>
                                                <div class="tech-value">${frequencyRange}</div>
                                            </div>
                                        ` : ''}
                                        ${adjustmentDb ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ajuste</div>
                                                <div class="tech-value">${adjustmentDb > 0 ? '+' : ''}${adjustmentDb.toFixed(1)} dB</div>
                                            </div>
                                        ` : ''}
                                        ${sug.details ? `
                                            <div class="tech-item" style="grid-column: span 2;">
                                                <div class="tech-label">Status</div>
                                                <div class="tech-value" style="font-size: 10px;">${sug.details.replace('Atual:', '').replace('Alvo:', 'â†’')}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">ğŸ’¡ Resultado Esperado</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    else {
                        // ğŸš¨ VERIFICAR SE Ã‰ TRUE PEAK COM MENSAGEM ESPECIAL
                        const isTruePeak = sug.type === 'reference_true_peak' || sug.metricType === 'true_peak' || 
                                         title.toLowerCase().includes('true peak') || title.toLowerCase().includes('tp');
                        const hasSpecialAlert = sug.specialAlert || sug.priorityWarning;
                        
                        if (isTruePeak && hasSpecialAlert) {
                            // Card especial para True Peak com mensagem de prioridade
                            return `
                                <div class="${cardClass} true-peak-priority">
                                    <div class="card-header">
                                        <h4 class="card-title">âš¡ ${title}</h4>
                                        <div class="card-badges">
                                            <span class="priority-badge primeiro">PRIMEIRO</span>
                                            <span class="severity-badge critica">CRÃTICO</span>
                                        </div>
                                    </div>
                                    
                                    ${sug.priorityWarning ? `
                                        <div class="priority-warning" style="background: rgba(255, 193, 7, 0.2); border: 1px solid #FFC107; border-radius: 6px; padding: 12px; margin: 12px 0; color: #856404;">
                                            ${sug.priorityWarning}
                                        </div>
                                    ` : ''}
                                    
                                    ${explanation ? `
                                        <div class="card-description" style="border-left-color: #FF5722;">
                                            <strong>âš ï¸ Por que Ã© prioritÃ¡rio:</strong> ${explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(255, 87, 34, 0.1); border-color: #FF5722;">
                                        <div class="card-action-title" style="color: #FF5722;">
                                            ğŸš¨ CorreÃ§Ã£o PrioritÃ¡ria
                                        </div>
                                        <div class="card-action-content">${action}</div>
                                    </div>
                                    
                                    ${sug.why ? `
                                        <div class="card-impact" style="background: rgba(255, 87, 34, 0.05); border-color: #FF5722;">
                                            <div class="card-impact-title" style="color: #FF5722;">ğŸ”´ Motivo da Prioridade</div>
                                            <div class="card-impact-content">${sug.why}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${technical ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                        </details>
                                    ` : ''}
                                </div>`;
                        }
                        
                        // Card genÃ©rico melhorado
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸµ ${title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${severityLabel || 'info'}</span>
                                    </div>
                                </div>
                                
                                ${explanation ? `
                                    <div class="card-description">
                                        <strong>ExplicaÃ§Ã£o:</strong> ${explanation}
                                    </div>
                                ` : ''}
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸ”§ AÃ§Ã£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">âš ï¸ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    }
                };
                if ((analysis.problems?.length || 0) > 0) {
                    // ğŸ¯ FunÃ§Ã£o local para deduplicar problemas por tipo
                    const deduplicateByType = (items) => {
                        const seen = new Map();
                        const deduplicated = [];
                        for (const item of items) {
                            if (!item || !item.type) continue;
                            
                            // ğŸ¯ CORREÃ‡ÃƒO: Para band_adjust, usar type + subtype como chave Ãºnica
                            let uniqueKey = item.type;
                            if (item.type === 'band_adjust' && item.subtype) {
                                uniqueKey = `${item.type}:${item.subtype}`;
                            }
                            
                            const existing = seen.get(uniqueKey);
                            if (!existing) {
                                seen.set(uniqueKey, item);
                                deduplicated.push(item);
                            } else {
                                // Manter o mais detalhado (com mais propriedades)
                                const currentScore = Object.keys(item).length + (item.explanation ? 10 : 0) + (item.impact ? 5 : 0);
                                const existingScore = Object.keys(existing).length + (existing.explanation ? 10 : 0) + (existing.impact ? 5 : 0);
                                if (currentScore > existingScore) {
                                    seen.set(uniqueKey, item);
                                    const index = deduplicated.findIndex(d => {
                                        if (d.type === 'band_adjust' && item.type === 'band_adjust') {
                                            return d.type === item.type && d.subtype === item.subtype;
                                        }
                                        return d.type === item.type;
                                    });
                                    if (index >= 0) deduplicated[index] = item;
                                }
                            }
                        }
                        return deduplicated;
                    };
                    
                    // Aplicar deduplicaÃ§Ã£o dos problemas na UI
                    const deduplicatedProblems = deduplicateByType(analysis.problems);
                    const list = deduplicatedProblems.map(p => {
                        const msg = typeof p.message === 'string' ? p.message.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.message;
                        const sol = typeof p.solution === 'string' ? p.solution.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.solution;
                        
                        // ğŸš¨ USAR FORMATO NATIVO DOS PROBLEMAS - Evitar duplicaÃ§Ã£o do SuggestionTextGenerator
                        // Os problemas jÃ¡ tÃªm explanation, impact, frequency_range, adjustment_db, details
                        let didacticText = null; // Desabilitado para evitar duplicaÃ§Ã£o
                        
                        // Se for problema crÃ­tico (clipping, etc), usar card crÃ­tico aprimorado
                        if (p.type === 'clipping' || p.severity === 'critical' || p.severity === 'high') {
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            
                            return `
                                <div class="enhanced-card critical-alert">
                                    <div class="card-header">
                                        <h4 class="card-title">ğŸš¨ Problema CrÃ­tico</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge severa">CRÃTICO</span>
                                        </div>
                                    </div>
                                    
                                    <div class="card-description" style="border-left-color: #f44336;">
                                        <strong>âš ï¸ Problema:</strong> ${msg}
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description" style="border-left-color: #f44336; background: rgba(244, 67, 54, 0.05);">
                                            <strong>ExplicaÃ§Ã£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                        <div class="card-action-title" style="color: #f44336;">
                                            ğŸš¨ AÃ§Ã£o Urgente
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || p.adjustment_db) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">FrequÃªncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${p.adjustment_db ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${p.adjustment_db} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                            <div class="card-impact-title" style="color: #f44336;">âš ï¸ Por que Ã© crÃ­tico</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        } else {
                            // Para problemas menos crÃ­ticos, usar card padrÃ£o melhorado
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            const dbMatch = sol.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                            const dbValue = dbMatch ? dbMatch[1] : null;
                            
                            // Determinar tipo de problema
                            const problemType = p.type || 'general';
                            let cardClass = 'enhanced-card problem';
                            let problemIcon = 'âš ï¸';
                            
                            if (problemType.includes('balance')) {
                                cardClass = 'enhanced-card balance';
                                problemIcon = 'âš–ï¸';
                            } else if (problemType.includes('dc_offset')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'ğŸ“Š';
                            } else if (problemType.includes('phase')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'ğŸŒŠ';
                            }
                            
                            return `
                                <div class="${cardClass}">
                                    <div class="card-header">
                                        <h4 class="card-title">${problemIcon} ${msg}</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge moderada">problema</span>
                                        </div>
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description">
                                            <strong>ExplicaÃ§Ã£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action">
                                        <div class="card-action-title">
                                            ğŸ”§ Como Resolver
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || dbValue) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">FrequÃªncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${dbValue ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${dbValue} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact">
                                            <div class="card-impact-title">âš ï¸ Impacto</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        }
                    }).join('');
                    blocks.push(`<div class="diag-section"><div class="diag-heading">âš ï¸ Problemas Detectados:</div>${list}</div>`);
                }
                // ğŸ›‘ CARD DE SUGESTÃ•ES ANTIGAS DESATIVADO - Removido conforme solicitado
                // O card "SUGESTÃ•ES EDUCACIONAIS ULTRA-AVANÃ‡ADAS" foi desativado para limpar a UI
                // Apenas o novo sistema de sugestÃµes (que aparece no final do modal) deve ser usado
                /*
                if ((analysis.suggestions?.length || 0) > 0) {
                    // [CÃ“DIGO COMENTADO - Card de sugestÃµes antigas removido]
                }
                */
                // Subbloco opcional com diagnÃ³sticos do V2 PRO (quando disponÃ­veis)
                const v2Pro = analysis.v2Pro || analysis.v2Diagnostics; // Compatibilidade
                if (v2Pro && (typeof window === 'undefined' || window.SUGESTOES_AVANCADAS !== false)) {
                    const v2p = (v2Pro.problems || []).map(p => `
                        <div class="diag-item danger">
                            <div class="diag-title">${p.message}</div>
                            <div class="diag-tip">${p.solution || ''}</div>
                        </div>`).join('');
                    // V2 Pro removido - nÃ£o mostrar diagnÃ³sticos duplicados
                }
                console.log('[RENDER_SUGGESTIONS] âœ… Finalizada - Total de sugestÃµes:', enrichedSuggestions?.length || 0);
                return blocks.join('') || '<div class="diag-empty">Sem diagnÃ³sticos</div>';
            };

        // ğŸ¯ SUBSCORES: Corrigir mapeamento para backend Node.js
        const breakdown = analysis.scores || analysis.qualityBreakdown || {};
        
        // ğŸ¯ APLICAR CAPS EM ESTADO CLIPPED
        const precedenceData = analysis.technicalData?._singleStage;
        const isClippedState = precedenceData?.finalState === 'CLIPPED' && precedenceData?.scoreCapApplied === true;
        
        // Aplicar caps nos sub-scores se em estado CLIPPED
        const applyClippingCaps = (originalBreakdown) => {
            if (!isClippedState) return originalBreakdown;
            
            const capped = { ...originalBreakdown };
            
            // Caps especÃ­ficos para estado CLIPPED
            if (Number.isFinite(capped.loudness)) {
                capped.loudness = Math.min(capped.loudness, 70); // Loudness â‰¤ 70
            }
            if (Number.isFinite(capped.technical)) {
                capped.technical = Math.min(capped.technical, 60); // TÃ©cnico â‰¤ 60  
            }
            if (Number.isFinite(capped.dynamics)) {
                capped.dynamics = Math.min(capped.dynamics, 50); // DinÃ¢mica â‰¤ 50
            }
            
            // Frequency e Stereo podem manter valores originais (nÃ£o afetados diretamente pelo clipping)
            
            return capped;
        };
        
        const finalBreakdown = applyClippingCaps(breakdown);
        
        // FunÃ§Ã£o para renderizar score com barra de progresso
        const renderScoreWithProgress = (label, value, color = '#00ffff') => {
            const numValue = parseFloat(value) || 0;
            const displayValue = value != null ? value : 'â€”';
            
            // Indicar se o valor foi capeado (comparar com breakdown original)
            const labelKey = label.toLowerCase().replace('faixa dinÃ¢mica', 'dynamics').replace('tÃ©cnico', 'technical').replace('loudness', 'loudness').replace('frequÃªncia', 'frequency').replace('stereo', 'stereo');
            const wasCapped = isClippedState && breakdown[labelKey] && Number.isFinite(breakdown[labelKey]) && 
                             breakdown[labelKey] !== value;
            const cappedIndicator = wasCapped ? ' ğŸ”´' : '';
            
            if (value == null) {
                return `<div class="data-row">
                    <span class="label">${label}:</span>
                    <span class="value">â€”</span>
                </div>`;
            }
            
            return `<div class="data-row metric-with-progress">
                <span class="label">${label}${cappedIndicator}:</span>
                <div class="metric-value-progress">
                    <span class="value">${displayValue}/100</span>
                    <div class="progress-bar-mini">
                        <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${color}; color: ${color};"></div>
                    </div>
                </div>
            </div>`;
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ RENDERIZAR SCORE FINAL NO TOPO - VISUAL FUTURISTA
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Renderiza o score final no container dedicado no topo da anÃ¡lise
         * @param {Object} scores - Objeto contendo todos os scores
         */
        function renderFinalScoreAtTop(scores) {
            console.log('[RENDER_FINAL_SCORE] âœ… Iniciada');
            console.log('[RENDER_FINAL_SCORE] scores:', scores);
            
            if (!scores || !Number.isFinite(scores.final)) {
                console.warn('[RENDER_FINAL_SCORE] âš ï¸ Retorno antecipado - Score final nÃ£o disponÃ­vel');
                console.warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: renderFinalScoreAtTop - !scores || !Number.isFinite(scores.final)');
                return;
            }
            
            const container = document.getElementById('final-score-display');
            if (!container) {
                console.error('[RENDER_FINAL_SCORE] âš ï¸ Retorno antecipado - Container #final-score-display nÃ£o encontrado');
                console.warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: renderFinalScoreAtTop - !container');
                return;
            }
            
            console.log('[RENDER_FINAL_SCORE] âœ… Container encontrado, renderizando...');
            
            const finalScore = Math.round(scores.final);
            const percent = Math.min(Math.max(finalScore, 0), 100);
            
            // Determinar mensagem de status baseada no score
            let statusMessage = '';
            let statusClass = '';
            
            if (finalScore >= 90) {
                statusMessage = 'âœ¨ Excelente! Pronto para lanÃ§amento';
                statusClass = 'status-excellent';
            } else if (finalScore >= 75) {
                statusMessage = 'âœ… Ã“timo! Qualidade profissional';
                statusClass = 'status-good';
            } else if (finalScore >= 60) {
                statusMessage = 'âš ï¸ Bom, mas pode melhorar';
                statusClass = 'status-warning';
            } else if (finalScore >= 40) {
                statusMessage = 'ğŸ”§ Precisa de ajustes';
                statusClass = 'status-warning';
            } else {
                statusMessage = 'ğŸš¨ Necessita correÃ§Ãµes importantes';
                statusClass = 'status-poor';
            }
            
            // Renderizar HTML do score final
            container.innerHTML = `
                <div class="score-final-label">ğŸ† SCORE FINAL</div>
                <div class="score-final-value">0</div>
                <div class="score-final-bar-container">
                    <div class="score-final-bar">
                        <div class="score-final-bar-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-final-status ${statusClass}">${statusMessage}</div>
            `;
            
            // Animar contagem do score (impacto visual) - inicia apÃ³s pequeno delay
            setTimeout(() => {
                animateFinalScore(finalScore);
            }, 100);
            
            console.log('[RENDER_FINAL_SCORE] âœ… Finalizada');
        }
        
        /**
         * Anima a contagem do score final de 0 atÃ© o valor final
         * @param {number} targetScore - Score final a ser exibido
         */
        function animateFinalScore(targetScore) {
            const el = document.querySelector('.score-final-value');
            const barFill = document.querySelector('.score-final-bar-fill');
            if (!el) return;
            
            let currentScore = 0;
            const duration = 2500; // 2.5 segundos (mais lento e dramÃ¡tico)
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out cubic - mais suave)
                const eased = 1 - Math.pow(1 - progress, 3);
                currentScore = targetScore * eased;
                
                // Atualizar nÃºmero
                el.textContent = Math.floor(currentScore);
                
                // Animar barra junto (se existir)
                if (barFill) {
                    const currentPercent = Math.min(Math.max(currentScore, 0), 100);
                    barFill.style.width = `${currentPercent}%`;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    el.textContent = targetScore; // Garantir valor final exato
                    if (barFill) {
                        const finalPercent = Math.min(Math.max(targetScore, 0), 100);
                        barFill.style.width = `${finalPercent}%`;
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // ğŸ¯ RENDERIZAR SCORES DO NOVO SISTEMA
        const renderNewScores = () => {
            // Verificar se temos scores calculados
            const scores = analysis.scores;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ” TAREFA 2: AUDITORIA DE LEITURA DE SCORES NA UI
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.group('ğŸ¨ [AUDIT-RENDER] LEITURA DE SCORES NA UI');
            console.log('[AUDIT-RENDER] analysis.scores recebido pela UI:', scores);
            console.log('[AUDIT-RENDER] scores existe?', !!scores);
            console.log('[AUDIT-RENDER] scores.loudness:', scores?.loudness);
            console.log('[AUDIT-RENDER] scores.dinamica:', scores?.dinamica);
            console.log('[AUDIT-RENDER] scores.estereo:', scores?.estereo);
            console.log('[AUDIT-RENDER] scores.frequencia:', scores?.frequencia);
            console.log('[AUDIT-RENDER] scores.tecnico:', scores?.tecnico);
            console.log('[AUDIT-RENDER] scores.subscores:', scores?.subscores);
            console.groupEnd();
            
            if (!scores) {
                console.warn('âš ï¸ [AUDIT-RENDER] SCORES AUSENTES - renderizando fallback');
                return `<div class="data-row">
                    <span class="label">Sistema de Scoring:</span>
                    <span class="value">NÃ£o disponÃ­vel</span>
                </div>`;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ”§ TAREFA 3: NORMALIZAÃ‡ÃƒO DE ESTRUTURA DE SCORES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Adaptar estrutura retornada por calculateAnalysisScores para UI
            const rawScores = scores || {};
            const subs = rawScores.subscores || rawScores;
            
            const normalizedScores = {
                loudness: subs.loudness ?? rawScores.loudness ?? subs.lufs ?? null,
                dinamica: subs.dinamica ?? subs.dynamics ?? rawScores.dinamica ?? rawScores.dynamics ?? null,
                estereo: subs.estereo ?? subs.stereo ?? rawScores.estereo ?? rawScores.stereo ?? null,
                frequencia: subs.frequencia ?? subs.frequency ?? rawScores.frequencia ?? rawScores.frequency ?? null,
                tecnico: subs.tecnico ?? subs.technical ?? rawScores.tecnico ?? rawScores.technical ?? null,
                final: rawScores.final ?? rawScores.composite ?? rawScores.score ?? null,
                breakdown: rawScores.breakdown ?? null
            };
            
            console.group('âœ… [AUDIT-RENDER] SCORES NORMALIZADOS');
            console.log('[AUDIT-RENDER] normalizedScores.loudness:', normalizedScores.loudness);
            console.log('[AUDIT-RENDER] normalizedScores.dinamica:', normalizedScores.dinamica);
            console.log('[AUDIT-RENDER] normalizedScores.estereo:', normalizedScores.estereo);
            console.log('[AUDIT-RENDER] normalizedScores.frequencia:', normalizedScores.frequencia);
            console.log('[AUDIT-RENDER] normalizedScores.tecnico:', normalizedScores.tecnico);
            console.log('[AUDIT-RENDER] normalizedScores.final:', normalizedScores.final);
            
            // ğŸ” TAREFA 4: VALIDAÃ‡ÃƒO FINAL - Contagem de valores null
            const nullCount = Object.values(normalizedScores).filter(v => v === null).length;
            const validCount = Object.values(normalizedScores).filter(v => Number.isFinite(v)).length;
            console.log('ğŸ“Š [AUDIT-RENDER] VALIDAÃ‡ÃƒO:', {
                total: Object.keys(normalizedScores).length,
                validos: validCount,
                nulos: nullCount,
                status: nullCount === 0 ? 'âœ… TODOS PREENCHIDOS' : `âš ï¸ ${nullCount} NULOS`
            });
            console.groupEnd();
            
            const renderScoreProgressBar = (label, value, color = '#00ffff', emoji = 'ğŸ¯') => {
                // Se null/undefined, renderizar "â€”" e barra vazia SEM cores "ok"
                if (!Number.isFinite(value)) {
                    return `<div class="data-row metric-with-progress">
                        <span class="label">${emoji} ${label}:</span>
                        <div class="metric-value-progress">
                            <span class="value" style="color: #666; font-weight: normal;">â€”</span>
                            <div class="progress-bar-mini">
                                <div class="progress-fill-mini" style="width: 0%; background: transparent;"></div>
                            </div>
                        </div>
                    </div>`;
                }
                
                const numValue = value;
                const displayValue = Math.round(value);
                
                // Cor baseada no score
                let scoreColor = color;
                if (value >= 80) scoreColor = '#00ff92'; // Verde para scores altos
                else if (value >= 60) scoreColor = '#ffd700'; // Amarelo para scores mÃ©dios
                else if (value >= 40) scoreColor = '#ff9500'; // Laranja para scores baixos
                else scoreColor = '#ff3366'; // Vermelho para scores muito baixos
                
                return `<div class="data-row metric-with-progress">
                    <span class="label">${emoji} ${label}:</span>
                    <div class="metric-value-progress">
                        <span class="value" style="color: ${scoreColor}; font-weight: bold;">${displayValue}</span>
                        <div class="progress-bar-mini">
                            <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${scoreColor};"></div>
                        </div>
                    </div>
                </div>`;
            };
            
            // ğŸ¯ Score final REMOVIDO daqui - serÃ¡ renderizado no topo
            // âŒ NÃƒO INCLUIR O SCORE FINAL AQUI - ele tem seu prÃ³prio container no topo
            
            // âœ… Sub-scores permanecem no mesmo lugar (dentro do card Scores & DiagnÃ³stico)
            // ğŸ”§ USANDO normalizedScores ao invÃ©s de scores bruto
            const subScoresHtml = `
                ${renderScoreProgressBar('Loudness', normalizedScores.loudness, '#ff3366', 'ğŸ”Š')}
                ${renderScoreProgressBar('FrequÃªncia', normalizedScores.frequencia, '#00ffff', 'ğŸµ')}
                ${renderScoreProgressBar('EstÃ©reo', normalizedScores.estereo, '#ff6b6b', 'ğŸ§')}
                ${renderScoreProgressBar('DinÃ¢mica', normalizedScores.dinamica, '#ffd700', 'ğŸ“Š')}
                ${renderScoreProgressBar('TÃ©cnico', normalizedScores.tecnico, '#00ff92', 'ğŸ”§')}
            `;
            
            return subScoresHtml;
        };
        
        const scoreRows = renderNewScores();

        // ğŸ”¹ FunÃ§Ã£o utilitÃ¡ria: Remove nÃ³s de texto vazios (whitespace) dentro dos cards
        function normalizeCardWhitespace(root = document) {
            const cards = root.querySelectorAll('.cards-grid .card');
            cards.forEach((card) => {
                // Remove nÃ³s de texto que sejam apenas whitespace (espaÃ§os/linhas)
                const toRemove = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        toRemove.push(n);
                    }
                });
                toRemove.forEach((n) => n.parentNode.removeChild(n));
            });
        }

        // ğŸ”¹ Alias para compatibilidade com nomenclatura alternativa
        function stripEmptyTextNodesInCards(root = document) {
            root.querySelectorAll('.cards-grid .card').forEach((card) => {
                const garbage = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        garbage.push(n);
                    }
                });
                garbage.forEach((n) => n.remove());
            });
        }

        // =========================================================================
        // ğŸš¨ AUDITORIA CRÃTICA: PONTO DE RENDERIZAÃ‡ÃƒO DE CARDS
        // =========================================================================
        console.groupCollapsed('[AUDITORIA_RENDERIZACAO] ğŸ¨ RENDERIZAÃ‡ÃƒO DE CARDS');
        console.log('[RENDER_CARDS] âœ… INÃCIO - Prestes a renderizar cards');
        console.log('[RENDER_CARDS] Modo:', analysis?.mode);
        console.log('[RENDER_CARDS] ContÃ©m analysis.scores?', !!analysis?.scores);
        console.log('[RENDER_CARDS] ContÃ©m analysis.technicalData?', !!analysis?.technicalData);
        console.log('[RENDER_CARDS] technicalData disponÃ­vel no DOM?', !!document.getElementById('modalTechnicalData'));
        console.log('[RENDER_CARDS] scoreKpi length:', scoreKpi?.length || 0);
        console.log('[RENDER_CARDS] col1 length:', col1?.length || 0);
        console.log('[RENDER_CARDS] col2 length:', col2?.length || 0);
        console.groupEnd();
        
        // [AUDIT-FLOW-CHECK] Confirmar que chegou na renderizaÃ§Ã£o de cards
        console.log('[AUDIT-FLOW-CHECK] âœ… Renderizando cards - modo:', analysis?.mode);
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: RENDERIZAR SCORE FINAL NO TOPO
        // =========================================================================
        console.log('[RENDER_SCORE_TOP] âœ… Chamando renderFinalScoreAtTop');
        console.log('[RENDER_SCORE_TOP] analysis.scores:', analysis?.scores);
        
        // ğŸ¯ RENDERIZAR SCORE FINAL NO TOPO (ISOLADO)
        renderFinalScoreAtTop(analysis.scores);
        
        console.log('[RENDER_SCORE_TOP] âœ… renderFinalScoreAtTop FINALIZADO');

        console.log('[RENDER_CARDS] âœ… Atribuindo HTML ao technicalData.innerHTML');
        technicalData.innerHTML = `
            <div class="kpi-row">${scoreKpi}${timeKpi}</div>
            ${renderSmartSummary(analysis)}
            <div class="cards-grid">
                <div class="card">
                    <div class="card-title">MÃ‰TRICAS PRINCIPAIS</div>
                    ${col1}
                </div>
                <div class="card">
                    <div class="card-title">ANÃLISE DE FREQUÃŠNCIAS</div>
                    ${col2}
                </div>
                <div class="card">
                    <div class="card-title">MÃ‰TRICAS AVANÃ‡ADAS</div>
                    ${advancedMetricsCard()}
                </div>
                <div class="card">
                    <div class="card-title">SCORES & DIAGNÃ“STICO</div>
                    ${scoreRows}
                    ${col3}
                </div>
                <!-- Card "Problemas TÃ©cnicos" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">âš ï¸ Problemas TÃ©cnicos</div>
                    ${techProblems()}
                </div>
                -->
                <!-- Card "DiagnÃ³stico & SugestÃµes" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">ğŸ©º DiagnÃ³stico & SugestÃµes</div>
                    ${diagCard()}
                </div>
                -->
            </div>
        `;
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: CONFIRMAR RENDERIZAÃ‡ÃƒO NO DOM
        // =========================================================================
        console.log('[RENDER_CARDS] âœ… HTML atribuÃ­do ao technicalData.innerHTML');
        console.log('[RENDER_CARDS] Tamanho do HTML:', technicalData.innerHTML.length);
        console.log('[RENDER_CARDS] Primeiros 200 chars:', technicalData.innerHTML.substring(0, 200));
    
        // ğŸ”¹ Sanitizar DOM: Remove nÃ³s de texto vazios que criam espaÃ§o extra
        normalizeCardWhitespace(technicalData);
        stripEmptyTextNodesInCards(technicalData);
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: VERIFICAR DOM APÃ“S SANITIZAÃ‡ÃƒO
        // =========================================================================
        setTimeout(() => {
            console.groupCollapsed('[AUDITORIA_DOM] ğŸ” VERIFICAÃ‡ÃƒO DO DOM');
            console.log('[AUDITORIA_DOM] Cards:', document.querySelectorAll('.cards-grid .card').length);
            console.log('[AUDITORIA_DOM] SugestÃµes:', document.querySelectorAll('.suggestion-card').length);
            console.log('[AUDITORIA_DOM] Score containers:', document.querySelectorAll('.score-card, .final-score-display').length);
            console.log('[AUDITORIA_DOM] technicalData.innerHTML length:', document.getElementById('modalTechnicalData')?.innerHTML?.length || 0);
            console.groupEnd();
        }, 1000);
    
        // ğŸ¯ CORRIGIDO: SÃ³ renderizar referÃªncias se NÃƒO estiver em modo comparaÃ§Ã£o de faixas
        // O displayModalResults() jÃ¡ trata comparaÃ§Ã£o via renderTrackComparisonTable()
        
        // ğŸ”¥ FLAG DE CONTROLE: Impedir dupla renderizaÃ§Ã£o em modo gÃªnero
        let genreRenderComplete = false;
        
        try { 
            // ========================================
            // ğŸ”¥ MODO GÃŠNERO: RENDERIZAÃ‡ÃƒO ISOLADA
            // ========================================
            // âœ… RESTAURADO: Fluxo original que sempre funcionou
            if (analysis?.mode === "genre") {
                console.log('%c[GENRE-MODE] ğŸ¯ MODO GÃŠNERO DETECTADO - RENDERIZAÃ‡ÃƒO DIRETA', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
                console.log('[GENRE-MODE] analysis.mode:', analysis.mode);
                console.log('[GENRE-MODE] analysis.genre:', analysis.genre || analysis.metadata?.genre);
                console.log('[GENRE-MODE] window.__activeRefData:', !!window.__activeRefData);
                console.log('[GENRE-MODE] window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
                console.log('[GENRE-MODE] analysis.bands:', analysis.bands ? Object.keys(analysis.bands).length + ' bandas' : 'N/A');
                console.log('[GENRE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // âœ… CHAMAR FUNÃ‡ÃƒO DE RENDERIZAÃ‡ÃƒO DE GÃŠNERO
                renderGenreView(analysis);
                
                // ğŸ”¥ MARCAR FLAG: GÃªnero foi renderizado, NÃƒO renderizar A/B depois
                genreRenderComplete = true;
                
                console.log('%c[GENRE-MODE] âœ… RENDERIZAÃ‡ÃƒO CONCLUÃDA', 'color:#00FF88;font-weight:bold;');
                return;
            }
            
            // ========================================
            // ğŸ¯ MODO REFERÃŠNCIA: PREPARAR DADOS PARA COMPARAÃ‡ÃƒO A/B
            // ========================================
            // âœ… RESTAURADO: Fluxo original de referÃªncia mantido intacto
            const isSecondTrack = (
                analysis.mode === 'reference' &&
                window.__REFERENCE_JOB_ID__ !== null &&
                window.__REFERENCE_JOB_ID__ !== undefined
            );
            
            const mode = analysis?.mode || currentAnalysisMode;
            const state = window.__soundyState || {};
            
            console.log('ğŸ” [RENDER-FLOW] Verificando modo e decisÃ£o de renderizaÃ§Ã£o:', {
                'analysis.mode': analysis.mode,
                'analysis.isReferenceBase': analysis.isReferenceBase,
                'currentAnalysisMode': window.currentAnalysisMode,
                isSecondTrack,
                hasReferenceAnalysisData: !!window.referenceAnalysisData,
                '__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
                stateRenderMode: state.render?.mode
            });
            
            console.log('[VERIFY_RENDER_MODE]', {
                mode: state.render?.mode || 'undefined',
                usingReferenceBands: !!(state.reference?.analysis?.bands || analysis?.referenceAnalysis?.bands),
                usingGenreTargets: !!window.__activeRefData?.bands,
                genreTargetsKeys: window.__activeRefData?.bands ? Object.keys(window.__activeRefData.bands) : [],
                referenceBandsKeys: state.reference?.analysis?.bands ? Object.keys(state.reference.analysis.bands) : []
            });
            
            console.log('ğŸµ [REFERENCE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸµ [REFERENCE-MODE] MODO REFERÃŠNCIA DETECTADO');
            console.log('ğŸµ [REFERENCE-MODE] analysis.mode:', analysis.mode);
            console.log('ğŸµ [REFERENCE-MODE] analysis.isReferenceBase:', analysis.isReferenceBase);
            console.log('ğŸµ [REFERENCE-MODE] isSecondTrack:', isSecondTrack);
            console.log('ğŸµ [REFERENCE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            console.log(`ğŸ“Š [RENDER-FLOW] Preparando renderReferenceComparisons() - modo: ${compareMode}`);
            console.log('[RENDER-FLOW] mustBeReference:', mustBeReference);
            console.log('[RENDER-FLOW] __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[RENDER-FLOW] referenceAnalysisData.bands:', !!window.referenceAnalysisData?.bands);
            
            // Preparar objeto ctx com clones profundos para evitar contaminaÃ§Ã£o
            const userClone = (typeof structuredClone === 'function') 
                ? structuredClone(analysis) 
                : JSON.parse(JSON.stringify(analysis));
            
            const refClone = window.referenceAnalysisData 
                ? ((typeof structuredClone === 'function') 
                    ? structuredClone(window.referenceAnalysisData) 
                    : JSON.parse(JSON.stringify(window.referenceAnalysisData)))
                : null;
            
            const renderOpts = {
                mode: compareMode,
                user: userClone,
                ref: refClone,
                // Compatibilidade com cÃ³digo legado
                analysis: analysis,
                userAnalysis: state.userAnalysis || state.reference?.userAnalysis || userClone,
                referenceAnalysis: state.referenceAnalysis || state.reference?.referenceAnalysis || refClone
            };
            
            console.log('[RENDER-OPTS] âœ… Dados preparados:', {
                mode: renderOpts.mode,
                hasUser: !!renderOpts.user,
                hasRef: !!renderOpts.ref,
                userBands: !!renderOpts.user?.bands,
                refBands: !!renderOpts.ref?.bands
            });
            
            // ğŸ” [AUDIT-BANDS-BEFORE] Log ANTES da chamada de renderReferenceComparisons
            try {
                const refBands = renderOpts.referenceAnalysis?.bands || renderOpts.referenceAnalysis?.technicalData?.spectral_balance;
                const userBands = renderOpts.userAnalysis?.bands || renderOpts.userAnalysis?.technicalData?.spectral_balance;
                console.log('[AUDIT-BANDS-BEFORE]', {
                    hasRefBands: !!refBands,
                    hasUserBands: !!userBands,
                    refBandsType: typeof refBands,
                    userBandsType: typeof userBands,
                    refBandsKeys: refBands ? Object.keys(refBands) : [],
                    userBandsKeys: userBands ? Object.keys(userBands) : [],
                    refBandsPreview: refBands ? Object.keys(refBands).slice(0, 3) : 'N/A',
                    userBandsPreview: userBands ? Object.keys(userBands).slice(0, 3) : 'N/A',
                    renderOptsKeys: Object.keys(renderOpts)
                });
            } catch (err) {
                console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-BEFORE', err);
            }
            
            // âœ… [BANDS-FIX] Nunca espera bandas no DOM - trabalha direto nos objetos
            // Se os objetos existem, seguimos â€” processamento Ã© nos dados, nÃ£o no DOM
            const ensureBandsReady = (userFull, refFull) => {
                return !!(userFull && refFull);
            };

            // ğŸ”¥ PROTEÃ‡ÃƒO: NÃƒO renderizar A/B se gÃªnero jÃ¡ foi renderizado
            if (genreRenderComplete) {
                console.log('[GENRE-PROTECTION] âœ… Modo gÃªnero jÃ¡ renderizado - BLOQUEANDO renderizaÃ§Ã£o A/B');
            } else if (ensureBandsReady(renderOpts?.userAnalysis, renderOpts?.referenceAnalysis)) {
                renderReferenceComparisons(renderOpts);
            } else {
                console.warn('[BANDS-FIX] âš ï¸ Objetos ausentes para comparaÃ§Ã£o A/B, pulando render de referÃªncia');
            }
        } catch(e){ 
            console.error('âŒ [RENDER-FLOW] ERRO em renderReferenceComparisons:', e);
            console.error('âŒ Stack trace:', e.stack);
        }    
        try { if (window.CAIAR_ENABLED) injectValidationControls(); } catch(e){ console.warn('validation controls fail', e); }
        
        // ğŸ” VerificaÃ§Ã£o de debug: Detecta whitespace restante
        if (window.DEBUG_ANALYZER) {
            document.querySelectorAll('.cards-grid .card').forEach((card, i) => {
                const ghosts = [...card.childNodes].filter(n => n.nodeType === 3 && !/\S/.test(n.nodeValue || ''));
                if (ghosts.length) console.warn(`Card #${i+1}: whitespace nodes restantes`, ghosts);
            });
        }
        
        __dbg('ğŸ“Š Resultados exibidos no modal');
        
        // âœ… LOG FINAL DE CONFIRMAÃ‡ÃƒO
        console.log('[DISPLAY_MODAL_RESULTS] âœ…âœ…âœ… FUNÃ‡ÃƒO FINALIZADA COM SUCESSO âœ…âœ…âœ…');
        console.log('[DISPLAY_MODAL_RESULTS] Modo:', analysis?.mode);
        console.log('[DISPLAY_MODAL_RESULTS] Self-compare?', state?.render?.isSelfCompare || false);
        console.log('[DISPLAY_MODAL_RESULTS] RenderizaÃ§Ã£o completa: cards, scores, tabela A/B, sugestÃµes');
    }

    // === Controles de ValidaÃ§Ã£o (Suite Objetiva + Subjetiva) ===
    function injectValidationControls(){
        if (document.getElementById('validationControlsBar')) return;
        const host = document.getElementById('modalTechnicalData');
        if (!host) return;
        const bar = document.createElement('div');
        bar.id='validationControlsBar';
        bar.style.cssText='margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:#0f1826;padding:10px 12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;font-size:12px;';
        bar.innerHTML = `
            <strong style="letter-spacing:.5px;color:#9fc9ff;font-weight:600;">ValidaÃ§Ã£o Auditiva</strong>
            <button id="runValidationSuiteBtn" style="background:#10365a;color:#fff;border:1px solid #1e4d7a;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;">Rodar Suite (10)</button>
            <button id="openSubjectiveFormBtn" style="background:#1c2c44;color:#d6e7ff;border:1px solid #284362;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Subjetivo 1â€“5</button>
            <button id="downloadValidationReportBtn" style="background:#224d37;color:#c5ffe9;border:1px solid #2f6e4e;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Baixar RelatÃ³rio</button>
            <span id="validationStatusMsg" style="margin-left:auto;font-size:11px;opacity:.75;">Pronto</span>
        `;
        host.prepend(bar);
        // Handlers
        const btnRun = bar.querySelector('#runValidationSuiteBtn');
        const btnForm = bar.querySelector('#openSubjectiveFormBtn');
        const btnDownload = bar.querySelector('#downloadValidationReportBtn');
        const statusEl = bar.querySelector('#validationStatusMsg');
        btnRun.onclick = async ()=>{
            btnRun.disabled = true; btnRun.textContent = 'Rodando...'; statusEl.textContent = 'Executando suite...';
            try {
                const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`);
                const summary = await mod.runValidationSuite({});
                statusEl.textContent = summary? `Cobertura mÃ©dia Î” ${(summary.avgDelta*100).toFixed(1)}%` : 'Sem dados';
                btnRun.textContent = 'Suite OK';
                btnForm.disabled = false; btnDownload.disabled = false;
                // Ãrea dinÃ¢mica para formulÃ¡rio
                ensureValidationPanel();
            } catch(err){ console.error('Erro suite validaÃ§Ã£o', err); statusEl.textContent='Erro'; btnRun.textContent='Erro'; btnRun.disabled=false; }
        };
        btnForm.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); ensureValidationPanel(); mod.renderSubjectiveForm('validationPanelInner'); statusEl.textContent='FormulÃ¡rio subjetivo aberto'; } catch(e){ console.warn(e); }
        };
        btnDownload.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); const rep = mod.generateValidationReport(); if(rep){ downloadObjectAsJson(rep, 'prodai_validation_report.json'); statusEl.textContent = rep?.subjective?.pctImproved!=null? `Subj ${(rep.subjective.pctImproved*100).toFixed(0)}%`:'RelatÃ³rio gerado'; } } catch(e){ console.warn(e); }
        };
    }

    function ensureValidationPanel(){
        if (document.getElementById('validationPanel')) return;
        const container = document.createElement('div');
        container.id='validationPanel';
        container.style.cssText='margin-top:12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:#0d141f;padding:10px 12px;';
        container.innerHTML = `<div style="font-size:12px;font-weight:600;letter-spacing:.5px;color:#9fc9ff;margin-bottom:6px;">Resultados da ValidaÃ§Ã£o</div><div id='validationPanelInner' style='font-size:11px;'></div>`;
        const host = document.getElementById('modalTechnicalData');
        if (host) host.appendChild(container);
        // estilos mÃ­nimos tabela subjetiva
        if (!document.getElementById('validationStyles')){
            const st=document.createElement('style'); st.id='validationStyles'; st.textContent=`
                .subjective-table{border-collapse:collapse;width:100%;margin-top:6px;font-size:11px;}
                .subjective-table th,.subjective-table td{border:1px solid rgba(255,255,255,.08);padding:4px 6px;text-align:center;}
                .subjective-table th{background:#132132;color:#c9e4ff;font-weight:500;letter-spacing:.4px;}
                .subjective-table select{min-width:42px;}
            `; document.head.appendChild(st);
        }
    }

    function downloadObjectAsJson(obj, filename){
        try { const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250); } catch(e){ console.warn('download json fail', e); }
    }

// ===== Painel Resumo Inteligente (top 3 problemas + top 3 aÃ§Ãµes) =====
function renderSmartSummary(analysis){
    try {
        if (!(typeof window !== 'undefined' && window.CAIAR_ENABLED) || !analysis) return '';
        // Garantir plano explain (caso ainda nÃ£o anexado)
        if (!analysis.caiarExplainPlan && window.audioAnalyzer && typeof analysis === 'object') {
            try {
                // se mÃ³dulo ainda nÃ£o carregado, importar dinamicamente
                if (!window.__CAIAR_EXPLAIN_LOADING__) {
                    window.__CAIAR_EXPLAIN_LOADING__ = import('/lib/audio/features/caiar-explain.js').then(mod=>{
                        if (mod && typeof mod.generateExplainPlan === 'function') mod.generateExplainPlan(analysis);
                    }).catch(()=>null);
                }
            } catch {}
        }
        const problems = Array.isArray(analysis.problems) ? analysis.problems.slice(0,3) : [];
        // Selecionar aÃ§Ãµes: usar passos do plano explain se existir, senÃ£o derivar das sugestÃµes
        let steps = (analysis.caiarExplainPlan && Array.isArray(analysis.caiarExplainPlan.passos)) ? analysis.caiarExplainPlan.passos.slice(0,6) : [];
        if (steps.length === 0) {
            const sugg = Array.isArray(analysis.suggestions) ? analysis.suggestions.slice() : [];
            // Ordenar por prioridade DECRESCENTE (maior prioridade = menor valor numÃ©rico = vem primeiro)
            sugg.sort((a,b)=> (b.priority||999)-(a.priority||999));
            steps = sugg.slice(0,6).map((s,i)=>({
                ordem:i+1,
                titulo:s.message||'AÃ§Ã£o',
                acao:s.action||'',
                porque:s.details||s.rationale? JSON.stringify(s.rationale):'OtimizaÃ§Ã£o recomendada',
                condicao:s.condition||s.condicao||'Aplicar quando perceptÃ­vel',
                origem:s.source||s.type,
                stem:s.targetStem||null,
                parametroPrincipal: s.freqHz? (Math.round(s.freqHz)+' Hz'): (s.band||null)
            }));
        }
        const topActions = steps.slice(0,3);
        const actionItems = topActions.map(a=>{
            const stem = a.stem ? `<span class="ss-stem">${a.stem}</span>` : '';
            const param = a.parametroPrincipal ? `<span class="ss-param">${a.parametroPrincipal}</span>` : '';
            const cond = a.condicao ? `<span class="ss-cond">${a.condicao}</span>` : '';
            const whyId = 'why_'+Math.random().toString(36).slice(2);
            return `<div class="ss-action-item">
                <div class="ss-line-main">
                    <span class="ss-title">${a.titulo}</span>
                    ${stem}
                    ${param}
                </div>
                <div class="ss-line-meta">
                    ${cond}
                    <button type="button" class="ss-why-btn" data-why-target="${whyId}">Por que?</button>
                </div>
                <div class="ss-why" id="${whyId}">${a.porque || 'Melhora coerÃªncia sonora.'}</div>
            </div>`;
        }).join('');
        const problemItems = problems.map(p=>`<div class="ss-prob-item"><span class="ss-prob-msg">${p.message||''}</span></div>`).join('');
        // Expand/Collapse container
        const html = `<div class="smart-summary-card" id="smartSummaryCard">
            <div class="ss-header">
                <div class="ss-title-block">âš¡ Resumo Inteligente</div>
                <button type="button" class="ss-toggle" data-expanded="true">Colapsar</button>
            </div>
            <div class="ss-content" data-collapsible="body">
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 Problemas</div>
                    ${problemItems || '<div class="ss-empty">Nenhum problema crÃ­tico</div>'}
                </div>
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 AÃ§Ãµes</div>
                    ${actionItems || '<div class="ss-empty">Nenhuma aÃ§Ã£o prioritÃ¡ria</div>'}
                </div>
                <div class="ss-hint">Execute as aÃ§Ãµes na ordem. Tempo de entendimento < 30s.</div>
            </div>
        </div>`;
        // Injetar estilos apenas uma vez
        if (!document.getElementById('smartSummaryStyles')) {
            const st = document.createElement('style');
            st.id = 'smartSummaryStyles';
            st.textContent = `
            .smart-summary-card{margin:12px 0 4px 0;padding:14px 16px;border:1px solid rgba(255,255,255,.08);border-radius:14px;background:linear-gradient(145deg,#0f1623,#101b2e);box-shadow:0 4px 14px -4px rgba(0,0,0,.55),0 0 0 1px rgba(255,255,255,0.03);font-size:13px;}
            .smart-summary-card .ss-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;}
            .smart-summary-card .ss-title-block{font-weight:600;letter-spacing:.5px;color:#e5f1ff;font-size:13px;}
            .smart-summary-card .ss-toggle{background:#18263a;color:#d2e6ff;border:1px solid #24364e;border-radius:8px;padding:4px 10px;font-size:11px;cursor:pointer;letter-spacing:.4px;transition:background .25s,border-color .25s;}
            .smart-summary-card .ss-toggle:hover{background:#203148;}
            .smart-summary-card .ss-section{margin-top:10px;}
            .smart-summary-card .ss-section-title{font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.7px;color:#86b4ff;margin-bottom:6px;}
            .smart-summary-card .ss-prob-item{background:rgba(255,90,90,.08);border:1px solid rgba(255,90,90,.25);padding:6px 8px;border-radius:8px;margin-bottom:6px;line-height:1.3;}
            .smart-summary-card .ss-prob-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-action-item{background:#152132;border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;margin-bottom:8px;}
            .smart-summary-card .ss-action-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-line-main{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:4px;}
            .smart-summary-card .ss-title{font-weight:600;color:#fff;font-size:13px;}
            .smart-summary-card .ss-stem{background:#24364e;color:#9ac9ff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-param{background:#1c2c44;color:#d6ecff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-cond{font-size:10px;background:#223347;color:#cfe8ff;padding:2px 6px;border-radius:6px;letter-spacing:.3px;}
            .smart-summary-card .ss-line-meta{display:flex;align-items:center;gap:10px;}
            .smart-summary-card .ss-why-btn{background:none;border:0;color:#53b4ff;font-size:11px;cursor:pointer;padding:0 2px;}
            .smart-summary-card .ss-why{display:none;margin-top:6px;font-size:11px;line-height:1.4;background:#101c2b;padding:6px 8px;border:1px solid rgba(255,255,255,.05);border-radius:8px;color:#c7d8eb;}
            .smart-summary-card .ss-why.open{display:block;}
            .smart-summary-card .ss-hint{margin-top:10px;font-size:10px;opacity:.55;letter-spacing:.4px;}
            .smart-summary-card .ss-empty{opacity:.6;font-size:12px;padding:4px 2px;}
            .smart-summary-card[data-collapsed='true'] .ss-content{display:none;}
            @media (max-width:560px){.smart-summary-card{padding:12px 12px;} .smart-summary-card .ss-title{font-size:12px;} }
            `;
            document.head.appendChild(st);
            // Delegated listeners
            document.addEventListener('click', (e)=>{
                const btn = e.target.closest('.ss-toggle');
                if (btn){
                    const card = btn.closest('.smart-summary-card');
                    const expanded = btn.getAttribute('data-expanded') === 'true';
                    btn.setAttribute('data-expanded', expanded? 'false':'true');
                    btn.textContent = expanded? 'Expandir':'Colapsar';
                    if (expanded) card.setAttribute('data-collapsed','true'); else card.removeAttribute('data-collapsed');
                }
                const why = e.target.closest('.ss-why-btn');
                if (why){
                    const id = why.getAttribute('data-why-target');
                    const block = document.getElementById(id);
                    if (block){ block.classList.toggle('open'); }
                }
            }, { passive:true });
        }
        return html;
    } catch (e) { console.warn('smart summary fail', e); return ''; }
}

// ğŸ¯ HELPER: Detectar se modo reference estÃ¡ ativo (correÃ§Ã£o definitiva)
function isReferenceCompareActive(analysis, state) {
    const hasRefJob = !!(state?.referenceJobId || analysis?.referenceComparison?.baseJobId);
    const hasRefBands = !!(
        analysis?.referenceComparison ||
        analysis?.spectralBands?.reference ||
        analysis?.bands // jÃ¡ normalizado com centralizaÃ§Ã£o
    );
    const isSecondTrack = analysis?.mode === 'reference' && state?.isSecondTrack === true;

    return (isSecondTrack && hasRefJob) || (analysis?.mode === 'reference' && hasRefBands);
}

// ğŸ¯ HELPER: Calcular centro de um range {min, max}
function centerOfRange(range) {
    if (!range || typeof range.min !== 'number' || typeof range.max !== 'number') return null;
    return (range.min + range.max) / 2;
}

// ğŸ¯ HELPER: Formatar target (range ou valor) para exibiÃ§Ã£o
function formatTarget(rangeOrValue) {
    if (typeof rangeOrValue === 'number') return `${rangeOrValue.toFixed(1)} dB`;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        return `${rangeOrValue.min.toFixed(1)} a ${rangeOrValue.max.toFixed(1)} dB`;
    }
    return 'â€”';
}

// ğŸ¯ HELPER: Derivar tolerÃ¢ncia de um range ou valor
function deriveTolerance(rangeOrValue, fallback = 2.0) {
    if (typeof rangeOrValue === 'number') return fallback;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        // 1/4 da largura do range, limitado entre 0.8 e 4.5
        const span = Math.abs(rangeOrValue.max - rangeOrValue.min);
        return Math.max(0.8, Math.min(4.5, span * 0.25));
    }
    return fallback;
}

// ğŸ¯ HELPER: Computar se tem dados necessÃ¡rios para referenceComparisonMetrics
/**
 * ğŸ¯ FUNÃ‡ÃƒO CRÃTICA: Obter mÃ©tricas de comparaÃ§Ã£o ativas (modo referÃªncia OU gÃªnero)
 * 
 * Esta funÃ§Ã£o resolve o bug onde modo gÃªnero nÃ£o detectava targets carregados.
 * 
 * REGRAS:
 * 1. Modo referÃªncia: usa analysis.referenceComparisonMetrics (vem do backend)
 * 2. Modo gÃªnero: usa window.__activeRefData / window.PROD_AI_REF_DATA[genre] (carregado no front)
 * 3. Nunca quebra comportamento de modo referÃªncia existente
 * 
 * @param {Object} normalizedResult - AnÃ¡lise normalizada
 * @returns {Object|null} - MÃ©tricas de comparaÃ§Ã£o ou null
 */
function getActiveReferenceComparisonMetrics(normalizedResult) {
    // ğŸ”¥ BYPASS TOTAL: Modo gÃªnero NUNCA retorna referenceComparisonMetrics
    if (normalizedResult?.mode === 'genre') {
        console.log('[GENRE-BYPASS] getActiveReferenceComparisonMetrics: modo gÃªnero detectado, retornando null');
        return null;
    }
    
    const mode = normalizedResult?.mode || window.__soundyState?.render?.mode || 'genre';
    const genre = normalizedResult?.genre || 
                  normalizedResult?.metadata?.genre ||
                  window.__CURRENT_GENRE || 
                  window.__soundyState?.render?.genre ||
                  window.PROD_AI_REF_GENRE;

    console.group('ğŸ” [GENRE-FIX] getActiveReferenceComparisonMetrics');
    console.log('Mode:', mode);
    console.log('Genre:', genre);

    // 1ï¸âƒ£ MODO REFERÃŠNCIA: usa o que veio do backend
    if (mode === 'reference' && normalizedResult?.referenceComparisonMetrics) {
        console.log('âœ… [GENRE-FIX] Usando referenceComparisonMetrics do backend (modo reference)');
        console.log('   - Fonte: backend');
        console.log('   - Tem bands:', !!normalizedResult.referenceComparisonMetrics.bands);
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    // 2ï¸âƒ£ MODO GÃŠNERO: ğŸ¯ CORREÃ‡ÃƒO CRÃTICA - Usar analysis.data.genreTargets
    if (mode === 'genre') {
        console.log('ğŸ¯ [GENRE-TARGETS] Extraindo targets da anÃ¡lise (FONTE OFICIAL)');
        
        // ğŸ¯ PRIORIDADE 1: analysis.data.genreTargets (BACKEND OFICIAL)
        const genreTargets = extractGenreTargetsFromAnalysis(normalizedResult);
        if (genreTargets) {
            console.log('âœ… [GENRE-FIX] Usando analysis.data.genreTargets (modo genre - FONTE OFICIAL)');
            console.log('   - Fonte: analysis.data.genreTargets');
            console.log('   - Tem bands:', !!genreTargets.bands);
            console.log('   - Keys:', Object.keys(genreTargets));
            console.groupEnd();
            return genreTargets.referenceComparisonMetrics || genreTargets;
        }
        
        // ğŸ¯ PRIORIDADE 2 (FALLBACK): window.__activeRefData (global universal)
        if (window.__activeRefData) {
            console.warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando window.__activeRefData (analysis.data.genreTargets nÃ£o disponÃ­vel)');
            console.log('   - Fonte: window.__activeRefData (FALLBACK)');
            console.log('   - Tem bands:', !!window.__activeRefData.bands);
            console.log('   - Tem referenceComparisonMetrics:', !!window.__activeRefData.referenceComparisonMetrics);
            console.groupEnd();
            return window.__activeRefData.referenceComparisonMetrics || window.__activeRefData;
        }
        
        // ğŸ¯ PRIORIDADE 3 (FALLBACK): window.PROD_AI_REF_DATA[genre] (dicionÃ¡rio por gÃªnero)
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            console.warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando PROD_AI_REF_DATA[genre] (analysis.data.genreTargets nÃ£o disponÃ­vel)');
            console.log('   - Fonte: window.PROD_AI_REF_DATA[' + genre + '] (FALLBACK)');
            console.log('   - Tem bands:', !!window.PROD_AI_REF_DATA[genre].bands);
            console.groupEnd();
            const genreData = window.PROD_AI_REF_DATA[genre];
            return genreData.referenceComparisonMetrics || genreData;
        }
        
        // ğŸ¯ PRIORIDADE 4 (FALLBACK): Fallback para analysis.referenceComparisonMetrics (se existir)
        if (normalizedResult?.referenceComparisonMetrics) {
            console.warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando analysis.referenceComparisonMetrics (Ãºltimo recurso)');
            console.log('   - Fonte: analysis.referenceComparisonMetrics (FALLBACK)');
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        console.error('âŒ [GENRE-FIX] CRÃTICO: Nenhum target de gÃªnero encontrado!');
        console.error('   - analysis.data.genreTargets:', !!normalizedResult?.data?.genreTargets);
        console.error('   - window.__activeRefData:', !!window.__activeRefData);
        console.error('   - window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
        console.error('   - Genre:', genre);
        console.groupEnd();
        return null;
    }

    // 3ï¸âƒ£ FALLBACK: tentar analysis.referenceComparisonMetrics
    if (normalizedResult?.referenceComparisonMetrics) {
        console.log('âœ… [GENRE-FIX] Usando analysis.referenceComparisonMetrics (fallback genÃ©rico)');
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    console.warn('âŒ [GENRE-FIX] Nenhuma mÃ©trica de comparaÃ§Ã£o disponÃ­vel');
    console.groupEnd();
    return null;
}

function computeHasReferenceComparisonMetrics(analysis) {
    // ğŸ”¥ BYPASS TOTAL: Modo gÃªnero NUNCA tem referenceComparisonMetrics
    if (analysis?.mode === 'genre') {
        console.log('[GENRE-BYPASS] computeHasReferenceComparisonMetrics: modo gÃªnero detectado, retornando false');
        return false;
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Usar getActiveReferenceComparisonMetrics() ao invÃ©s de sÃ³ verificar analysis
    const comparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasMetrics = !!comparisonMetrics;
    
    console.log('[GENRE-FIX] computeHasReferenceComparisonMetrics:', {
        hasMetrics,
        mode: analysis?.mode,
        hasActiveRefData: !!window.__activeRefData,
        hasProdAiRefData: !!window.PROD_AI_REF_DATA
    });
    
    return hasMetrics;
}

// --- BEGIN: band target resolver (mode-aware) ---
const BAND_NORMALIZATION_MAP = {
    // normaliza chaves heterogÃªneas para um vocabulÃ¡rio comum
    low_bass: 'bass',
    upper_bass: 'bass',
    low_mid: 'lowMid',
    high_mid: 'highMid',
    brilho: 'air',
    presenca: 'presence',
    // deixe iguais as que jÃ¡ batem:
    sub: 'sub',
    bass: 'bass',
    lowMid: 'lowMid',
    mid: 'mid',
    highMid: 'highMid',
    presence: 'presence',
    air: 'air'
};

const IGNORE_BANDS = new Set(['totalPercentage', '_status', 'total', 'metadata']);

// tenta extrair nÃºmero: aceita { value }, { db }, { rms_db }, { energy_db }, nÃºmero puro etc.
function pickNumeric(val) {
    if (val == null) return null;
    if (typeof val === 'number' && Number.isFinite(val)) return val;
    if (typeof val === 'object') {
        if (typeof val.value === 'number' && Number.isFinite(val.value)) return val.value;
        if (typeof val.db === 'number' && Number.isFinite(val.db)) return val.db;
        if (typeof val.rms_db === 'number' && Number.isFinite(val.rms_db)) return val.rms_db;
        if (typeof val.energy_db === 'number' && Number.isFinite(val.energy_db)) return val.energy_db;
    }
    return null;
}

function normalizeBandKey(k) {
    return BAND_NORMALIZATION_MAP[k] || k;
}

function getReferenceBandValue(refBands, bandKey) {
    const k = normalizeBandKey(bandKey);
    const v = refBands?.[k];
    return pickNumeric(v);
}

function getGenreTargetRange(genreTargets, bandKey) {
    const k = normalizeBandKey(bandKey);
    // Suporta {min,max} ou [min,max], e fallback para target/Â±tol
    const range = genreTargets?.[k];
    if (!range) return null;

    if (Array.isArray(range) && range.length === 2) {
        return { min: range[0], max: range[1], tol: Math.abs(range[1] - range[0]) / 4 || null };
    }
    if (typeof range === 'object') {
        if (typeof range.min === 'number' && typeof range.max === 'number') {
            return { min: range.min, max: range.max, tol: (range.tol ?? (Math.abs(range.max - range.min) / 4)) || null };
        }
        if (typeof range.target_db === 'number' && typeof range.tol_db === 'number') {
            return { min: range.target_db - range.tol_db, max: range.target_db + range.tol_db, tol: range.tol_db };
        }
        if (typeof range.target === 'number' && typeof range.tol === 'number') {
            return { min: range.target - range.tol, max: range.target + range.tol, tol: range.tol };
        }
    }
    return null;
}

function formatDb(n) {
    return (typeof n === 'number' && Number.isFinite(n)) ? `${n.toFixed(1)}dB` : 'â€”';
}
// --- END: band target resolver (mode-aware) ---

// ğŸ§  NOVA PROTEÃ‡ÃƒO UNIVERSAL â€” ReferÃªncia real > gÃªnero
function resolveTargetMetric(analysis, key, fallback) {
    // 1ï¸âƒ£ Busca no objeto da anÃ¡lise de referÃªncia (segunda faixa)
    if (analysis?.referenceAnalysis?.technicalData?.[key] !== undefined) {
        console.log(`ğŸ¯ [RESOLVE] ${key} encontrado em referenceAnalysis:`, analysis.referenceAnalysis.technicalData[key]);
        return analysis.referenceAnalysis.technicalData[key];
    }
    
    // 2ï¸âƒ£ Busca no objeto da prÃ³pria anÃ¡lise (se comparando com si mesma)
    if (analysis?.technicalData?.[key] !== undefined) {
        console.log(`ğŸ¯ [RESOLVE] ${key} encontrado em technicalData:`, analysis.technicalData[key]);
        return analysis.technicalData[key];
    }
    
    // 3ï¸âƒ£ Busca no gÃªnero (estrutura antiga)
    const targetKey = `${key}_target`;
    if (analysis?.referenceComparison?.[targetKey] !== undefined) {
        console.log(`ğŸ¯ [RESOLVE] ${key} encontrado em referenceComparison.${targetKey}:`, analysis.referenceComparison[targetKey]);
        return analysis.referenceComparison[targetKey];
    }
    
    // 4ï¸âƒ£ Fallback seguro
    console.log(`ğŸ›¡ï¸ [RESOLVE] ${key} usando fallback:`, fallback);
    return fallback ?? 0;
}

// ğŸ§® PARTE 3.1: FunÃ§Ã£o de normalizaÃ§Ã£o para estrutura de referÃªncia
function normalizeReferenceShape(a) {
  if (!a) return {};
  return {
    fileName: a.fileName || a.metadata?.fileName || "Faixa desconhecida",
    bands: a.bands || a.spectralBands,
    lufsIntegrated: a.loudness?.integrated ?? a.lufsIntegrated,
    truePeakDbtp: a.truePeak?.dbtp ?? a.truePeakDbtp,
    dynamicRange: a.dynamics?.dr ?? a.dynamicRange,
    lra: a.loudness?.range ?? a.lra,
    crestFactor: a.dynamics?.crest ?? a.crestFactor
  };
}

// ğŸ”’ Global render lock para evitar ReferenceError
if (typeof window.comparisonLock === "undefined") {
    window.comparisonLock = false;
    console.log("[LOCK-INIT] comparisonLock inicializado como false");
}

// --- BEGIN: deterministic mode gate ---
function renderReferenceComparisons(ctx) {
    // ========================================
    // ğŸ¯ PASSO 0: DETECÃ‡ÃƒO DE MODO GÃŠNERO (PRIORIDADE MÃXIMA)
    // ========================================
    // ğŸ”¥ CRITICAL: Detectar modo gÃªnero ANTES de qualquer guard de referÃªncia
    const isGenreMode = ctx?.mode === "genre" || 
                       ctx?._isGenreIsolated === true ||
                       ctx?.analysis?.mode === "genre" ||
                       window.__soundyState?.render?.mode === "genre" ||
                       (typeof getViewMode === 'function' && getViewMode() === "genre");
    
    // ğŸ”¥ BYPASS TOTAL: renderReferenceComparisons NÃƒO deve renderizar NADA para modo gÃªnero
    if (isGenreMode) {
        console.group('ğŸµ [GENRE-BYPASS] ğŸš§ MODO GÃŠNERO DETECTADO');
        console.log('ğŸµ [GENRE-BYPASS] renderReferenceComparisons NÃƒO renderiza para gÃªnero');
        console.log('ğŸµ [GENRE-BYPASS] RenderizaÃ§Ã£o deve ser feita por renderGenreComparisonTable');
        console.log('ğŸµ [GENRE-BYPASS] Modo:', ctx?.mode);
        console.log('ğŸµ [GENRE-BYPASS] _isGenreIsolated:', ctx?._isGenreIsolated);
        console.log('ğŸµ [GENRE-BYPASS] analysis.mode:', ctx?.analysis?.mode);
        console.groupEnd();
        return; // âŒ BYPASS TOTAL - nÃ£o renderizar nada
    }
    
    // ========================================
    // ğŸ¯ PASSO 1: VALIDAR DADOS DO STORE SE DISPONÃVEL (MODO REFERENCE)
    // ========================================
    console.group('ğŸ¯ [RENDER-REF] VALIDAÃ‡ÃƒO DE FONTE DE DADOS');
    
    if (ctx?._useStoreData) {
        console.log('âœ… [STORE-MODE] RenderizaÃ§Ã£o usando dados do store isolado');
        console.log('   - userAnalysis.jobId:', ctx.userAnalysis?.jobId);
        console.log('   - referenceAnalysis.jobId:', ctx.referenceAnalysis?.jobId);
        
        // ValidaÃ§Ã£o de integridade do store
        if (window.SoundyAI_Store?.first && window.SoundyAI_Store?.second) {
            console.table({
                refJobId: window.SoundyAI_Store.first?.jobId,
                currJobId: window.SoundyAI_Store.second?.jobId,
                refName: window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName,
                currName: window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName,
                sameJob: window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId,
                sameName: (window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName) === 
                          (window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName)
            });
            
            // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Store NÃƒO pode ter jobIds iguais
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('ğŸš¨ [STORE-ERROR] STORE CONTAMINADO!');
                console.error('   - Store tem jobIds idÃªnticos');
                console.trace();
                console.groupEnd();
                alert('ERRO: Store contaminado detectado. Por favor, recarregue a pÃ¡gina.');
                return;
            }
            
            console.log('âœ… [STORE-VALIDATED] Store validado - dados isolados confirmados');
        } else {
            console.warn('âš ï¸ [STORE-WARN] Store nÃ£o estÃ¡ completo');
            console.log('   - Caindo para modo legado');
        }
    } else {
        console.log('âš ï¸ [LEGACY-MODE] RenderizaÃ§Ã£o usando sistema legado');
        console.log('   - Dados nÃ£o vÃªm do store isolado');
    }
    
    console.groupEnd();
    
    // ========================================
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA NO INÃCIO: Tentar recuperar jobIds corretos se necessÃ¡rio
    // ========================================
    let userJobId = ctx?.userAnalysis?.jobId || ctx?.user?.jobId;
    let refJobId = ctx?.referenceAnalysis?.jobId || ctx?.ref?.jobId;
    
    console.group('ğŸ¯ [RENDER-REF] Iniciando renderizaÃ§Ã£o com validaÃ§Ã£o');
    console.log('   userJobId recebido:', userJobId);
    console.log('   refJobId recebido:', refJobId);
    console.log('   SÃ£o iguais?', userJobId === refJobId);
    
    // Se recebeu jobIds iguais, TENTA RECUPERAR os corretos
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('âŒ [RENDER-REF] ERRO: Recebeu jobIds iguais!');
        console.error('   Tentando recuperar jobIds corretos com getCorrectJobId()...');
        
        // RECUPERA os jobIds corretos
        const recoveredCurrentJobId = getCorrectJobId('current');
        const recoveredReferenceJobId = getCorrectJobId('reference');
        
        console.log('ğŸ”„ [RENDER-REF] JobIds recuperados:');
        console.log('   Novo userJobId (current):', recoveredCurrentJobId);
        console.log('   Novo refJobId (reference):', recoveredReferenceJobId);
        console.log('   Recuperados sÃ£o diferentes?', recoveredCurrentJobId !== recoveredReferenceJobId);
        
        // Se AINDA forem iguais, ABORTA
        if (recoveredCurrentJobId === recoveredReferenceJobId) {
            console.error('âŒ [RENDER-REF] FALHA NA RECUPERAÃ‡ÃƒO!');
            console.error('   Mesmo apÃ³s getCorrectJobId(), os jobIds sÃ£o iguais');
            console.trace();
            console.groupEnd();
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o. Os jobIds sÃ£o iguais. Recarregue a pÃ¡gina.');
            return;
        }
        
        console.log('âœ… [RENDER-REF] JobIds recuperados com sucesso!');
        console.log('   Atualizando userJobId e refJobId no contexto...');
        
        // Atualizar jobIds no contexto
        userJobId = recoveredCurrentJobId;
        refJobId = recoveredReferenceJobId;
        
        // Atualizar tambÃ©m no ctx se possÃ­vel
        if (ctx?.userAnalysis) ctx.userAnalysis.jobId = userJobId;
        if (ctx?.referenceAnalysis) ctx.referenceAnalysis.jobId = refJobId;
        if (ctx?.user) ctx.user.jobId = userJobId;
        if (ctx?.ref) ctx.ref.jobId = refJobId;
    } else {
        console.log('âœ… [RENDER-REF] JobIds jÃ¡ sÃ£o diferentes - continuando normalmente');
    }
    
    console.groupEnd();
    
    // ========================================
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: NUNCA COMPARAR MESMA MÃšSICA (validaÃ§Ã£o original mantida)
    // ========================================
    console.group('ğŸš¨ [RENDER-VALIDATION] ValidaÃ§Ã£o crÃ­tica de jobIds');
    console.log('   - userJobId (apÃ³s possÃ­vel recuperaÃ§Ã£o):', userJobId);
    console.log('   - refJobId (apÃ³s possÃ­vel recuperaÃ§Ã£o):', refJobId);
    console.log('   - SÃ£o iguais?', userJobId === refJobId);
    
    // VALIDAÃ‡ÃƒO CRÃTICA: Se jobIds sÃ£o iguais, ABORTAR renderizaÃ§Ã£o
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('âŒ [RENDER] ERRO CRÃTICO: Tentando comparar mesma mÃºsica!');
        console.error('   userJobId:', userJobId);
        console.error('   refJobId:', refJobId);
        console.trace();
        
        // Tenta recuperar o jobId correto da segunda mÃºsica
        const recoveredJobId = getCorrectJobId('current'); // Segunda mÃºsica
        const firstJobId = getCorrectJobId('reference'); // Primeira mÃºsica
        
        console.log('ğŸ”„ [RENDER] Tentando recuperar jobIds corretos:');
        console.log('   - Recovered currentJobId:', recoveredJobId);
        console.log('   - Recovered referenceJobId:', firstJobId);
        
        if (recoveredJobId && firstJobId && recoveredJobId !== firstJobId) {
            console.warn('âš ï¸ [RENDER] JobIds recuperados - reconstruindo ctx');
            // Reconstruir ctx com jobIds corretos
            // Por ora, ABORTAR para evitar renderizaÃ§Ã£o incorreta
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o corretamente. Por favor, recarregue a pÃ¡gina e tente novamente.');
            console.groupEnd();
            return;
        } else {
            console.error('âŒ [RENDER] NÃ£o foi possÃ­vel recuperar jobIds corretos');
            alert('ERRO CRÃTICO: ComparaÃ§Ã£o invÃ¡lida detectada. Recarregue a pÃ¡gina.');
            console.groupEnd();
            return;
        }
    }
    
    console.log('âœ… [RENDER-VALIDATION] JobIds sÃ£o diferentes - continuando renderizaÃ§Ã£o');
    console.groupEnd();
    
    // ========================================
    // âœ… CORREÃ‡ÃƒO 3: PadronizaÃ§Ã£o de chamada e validaÃ§Ã£o de ctx
    // ========================================
    // Normalizar ctx para aceitar objeto { mode, user, ref }
    const mode = ctx?.mode || window.currentAnalysisMode || 'genre';
    const user = ctx?.user || ctx?.userAnalysis || window._lastUserAnalysis || {};
    const refData = ctx?.ref || ctx?.referenceAnalysis || window.referenceAnalysisData || {};

    // HARD-GUARD: sem bands? nÃ£o renderiza A/B para evitar self-compare
    if (mode === 'reference') {
        if (!refData?.bands || !user?.bands) {
            console.warn('[A/B-SKIP] bands ausentes (user/ref). Evitando self-compare.');
            console.warn('[SUG-AUDIT][REFERENCE] âš ï¸ Modo reference mas sem bandas - pode afetar suggestions');
            return;
        }
        
        // âœ… AUDITORIA: Verificar se suggestions estÃ£o presentes
        console.log('[SUG-AUDIT][REFERENCE] Dados recebidos:', {
            userHasSuggestions: Array.isArray(user?.suggestions),
            userSuggestionsLength: user?.suggestions?.length || 0,
            refHasSuggestions: Array.isArray(refData?.suggestions),
            refSuggestionsLength: refData?.suggestions?.length || 0
        });
    }

    // Atualizar opts para compatibilidade com cÃ³digo existente
    const opts = {
        mode: mode,
        userAnalysis: user,
        referenceAnalysis: refData,
        ...ctx // Mesclar propriedades adicionais de ctx
    };

    // ========================================
    // ğŸ›¡ï¸ BLOQUEIO DEFINITIVO DE SELF-COMPARE POR CONTEÃšDO
    // ========================================
    // Recuperar faixas do FirstAnalysisStore usando papÃ©is (USER/REF)
    const userFromStore = FirstAnalysisStore.getUser();
    const refFromStore = FirstAnalysisStore.getRef();
    
    if (!userFromStore?.bands || !refFromStore?.bands) {
        console.warn('[AB-BLOCK] âš ï¸ Bands ausentes - abortando A/B');
        return;
    }
    
    // Detectar self-compare por mÃºltiplos critÃ©rios de conteÃºdo
    const samePointer = userFromStore === refFromStore;
    const sameJobId = userFromStore?.jobId && refFromStore?.jobId && userFromStore.jobId === refFromStore.jobId;
    const sameFile = userFromStore?.metadata?.fileKey && refFromStore?.metadata?.fileKey && 
                     userFromStore.metadata.fileKey === refFromStore.metadata.fileKey;
    const sameHash = userFromStore?.objectId?.hash && refFromStore?.objectId?.hash && 
                     userFromStore.objectId.hash === refFromStore.objectId.hash;
    
    if (samePointer || sameJobId || sameFile || sameHash) {
        console.error('[AB-BLOCK] âŒ Self-compare detectado - abortando tabela A/B:', {
            samePointer,
            sameJobId: sameJobId ? `${userFromStore.jobId}` : false,
            sameFile: sameFile ? `${userFromStore.metadata.fileKey}` : false,
            sameHash: sameHash ? `${userFromStore.objectId.hash}` : false,
            userVid: window.CacheIndex.USER,
            refVid: window.CacheIndex.REF,
            userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
            refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName
        });
        return; // Aborta renderizaÃ§Ã£o A/B
    }
    
    // âœ… ValidaÃ§Ã£o passou - sÃ£o faixas diferentes
    console.log('[AB-SAFETY] âœ… Faixas validadas como diferentes:', {
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
        refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName,
        userJobId: userFromStore?.jobId,
        refJobId: refFromStore?.jobId
    });
    
    // ğŸ¯ [STORE-PRIORITY-FIX] PRIORIDADE ABSOLUTA: SoundyAI_Store > FirstAnalysisStore
    console.log('ğŸ¯ [STORE-PRIORITY-FIX] Verificando prioridade de fonte de dados...');
    
    // Verificar se SoundyAI_Store tem ambas anÃ¡lises
    const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
    
    let finalUserAnalysis, finalReferenceAnalysis;
    
    if (storeHasBoth) {
        console.log('âœ… [STORE-PRIORITY-FIX] Usando SoundyAI_Store (prioridade mÃ¡xima)');
        finalUserAnalysis = window.SoundyAI_Store.first;
        finalReferenceAnalysis = window.SoundyAI_Store.second;
        
        console.table({
            'Fonte': 'SoundyAI_Store',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId,
            'User LUFS': finalUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': finalReferenceAnalysis?.technicalData?.lufsIntegrated,
            'User DR': finalUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': finalReferenceAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': finalUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': finalReferenceAnalysis?.technicalData?.truePeakDbtp
        });
    } else {
        console.warn('âš ï¸ [STORE-PRIORITY-FIX] SoundyAI_Store incompleto, usando FirstAnalysisStore (fallback)');
        finalUserAnalysis = userFromStore;
        finalReferenceAnalysis = refFromStore;
        
        console.table({
            'Fonte': 'FirstAnalysisStore (fallback)',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId
        });
    }
    
    // Usar as faixas priorizadas (SoundyAI_Store > FirstAnalysisStore)
    opts.userAnalysis = finalUserAnalysis;
    opts.referenceAnalysis = finalReferenceAnalysis;
    
    // ========================================
    // ğŸ”§ DETECÃ‡ÃƒO SEGURA DE SELF-COMPARE (APÃ“S AB-SAFETY)
    // ========================================
    // Agora que temos os dados validados, detectar self-compare com critÃ©rios rigorosos
    const refAnalysis = opts.referenceAnalysis;
    const currAnalysis = opts.userAnalysis;
    
    const sameJob = !!(refAnalysis?.jobId && currAnalysis?.jobId && refAnalysis.jobId === currAnalysis.jobId);
    const sameVid = !!(refAnalysis?.vid && currAnalysis?.vid && refAnalysis.vid === currAnalysis.vid);
    const sameFileName = !!(refAnalysis?.fileName && currAnalysis?.fileName && refAnalysis.fileName === currAnalysis.fileName);
    const refVid = window.CacheIndex?.REF;
    const userVid = window.CacheIndex?.USER;
    
    // SÃ³ marca como selfCompare se TODAS as checagens coincidirem
    let selfCompare = false;
    if (sameJob && sameVid && sameFileName) {
        selfCompare = true;
        console.warn('[REF-GUARD] âš ï¸ Self-compare detectado (todos critÃ©rios):', { sameJob, sameVid, sameFileName });
    }
    
    // âœ… REVALIDAÃ‡ÃƒO: Limpar flag se for falso positivo
    // Se VIDs ou files sÃ£o diferentes, nÃ£o pode ser self-compare
    if (selfCompare && (userVid !== refVid || 
        (refAnalysis?.fileName || refAnalysis?.metadata?.fileName) !== (currAnalysis?.fileName || currAnalysis?.metadata?.fileName))) {
        console.warn('[REF-GUARD] â Corrigido selfCompare falso-positivo apÃ³s AB-SAFETY:', {
            userVid,
            refVid,
            userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
            refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
        });
        selfCompare = false;
    }
    
    // Marcar no opts para uso posterior
    opts.isSelfCompare = selfCompare;
    
    console.log('[SELF-COMPARE-FINAL] DecisÃ£o final:', {
        selfCompare,
        sameJob,
        sameVid,
        sameFileName,
        userVid,
        refVid,
        userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
        refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
    });
    
    // ==== STEP 3/6: refHardGuards() simplificado ====
    const guardResult = (function refHardGuards(){
        const s = window.__soundyState || {};
        
        if (!opts.userAnalysis || !opts.referenceAnalysis) {
            console.error("[REF-PATCH] Faltam dados pra A/B");
            return { abort: true, reason: 'missing-data' };
        }

        opts.usedReferenceAnalysis = true;

        if (window.__refRenderInProgress) {
            console.warn("[REF-PATCH] Render A/B em progresso â€” ignorando duplicado");
            return { abort: true, reason: 'render-in-progress' };
        }
        window.__refRenderInProgress = true;
        
        return { abort: false };
    })();
    
    // âœ… STEP 3/6: Tratar retorno de refHardGuards()
    if (guardResult && guardResult.abort) {
        console.warn(`[REF-GUARD] Abortando renderReferenceComparisons: ${guardResult.reason}`);
        return;
    }
    
    // ï¿½ [AUDIT-BANDS-IN-RENDER] Log NO INÃCIO da funÃ§Ã£o renderReferenceComparisons
    try {
        const refBandsInRender = opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance;
        const userBandsInRender = opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance;
        console.log('[AUDIT-BANDS-IN-RENDER]', {
            receivedRefBands: refBandsInRender,
            receivedUserBands: userBandsInRender,
            typeofRefBands: typeof refBandsInRender,
            typeofUserBands: typeof userBandsInRender,
            refBandsKeys: refBandsInRender ? Object.keys(refBandsInRender) : [],
            userBandsKeys: userBandsInRender ? Object.keys(userBandsInRender) : [],
            optsKeys: Object.keys(opts),
            hasUserAnalysis: !!opts.userAnalysis,
            hasReferenceAnalysis: !!opts.referenceAnalysis
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-RENDER', err);
    }
    
    // ï¿½ğŸ”’ PROTEÃ‡ÃƒO ANTI-DUPLICAÃ‡ÃƒO: Detectar se faixas sÃ£o idÃªnticas
    if (opts.userAnalysis?.fileName && opts.referenceAnalysis?.fileName &&
        opts.userAnalysis.fileName === opts.referenceAnalysis.fileName) {
        console.error("âŒ [REF-DUPE] DetecÃ§Ã£o de duplicaÃ§Ã£o â€” referÃªncia sobrescrita!");
        console.table({
            userTrack: opts.userAnalysis?.fileName,
            refTrack: opts.referenceAnalysis?.fileName,
        });
        return; // aborta renderizaÃ§Ã£o duplicada
    }
    
    // ğŸ§© Controle seguro de renderizaÃ§Ã£o
    if (window.comparisonLock) {
        console.warn("[LOCK] RenderizaÃ§Ã£o de comparaÃ§Ã£o ignorada (lock ativo)");
        return;
    }
    
    // [AUDIT-FLOW] Log ANTES do lock
    console.log("[AUDIT-FLOW] ğŸ” ANTES do lock:", {
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    window.comparisonLock = true;
    console.log("[LOCK] comparisonLock ativado");
    
    // [AUDIT-FLOW] Log DEPOIS do lock
    console.log("[AUDIT-FLOW] ğŸ” DEPOIS do lock:", {
        comparisonLock: window.comparisonLock,
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    // ğŸ”§ PARTE 2: ProteÃ§Ã£o em renderReferenceComparisons
    const globalState = window.__soundyState || {};
    const refStateCheck = globalState?.reference || {};
    const userCheck = refStateCheck.userAnalysis || opts.userAnalysis;
    const refCheck = refStateCheck.referenceAnalysis || opts.referenceAnalysis;

    if (!userCheck || !refCheck) {
        console.warn("[REF-COMP] Faltam dados de referÃªncia ou usuÃ¡rio, usando fallback seguro");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (fallback)");
        return renderGenreComparisonSafe?.();
    }

    const userTrackCheck = userCheck.fileName || userCheck.metadata?.fileName || "Faixa 1 (usuÃ¡rio)";
    const refTrackCheck = refCheck.fileName || refCheck.metadata?.fileName || "Faixa 2 (referÃªncia)";
    const userBandsCheck = userCheck.bands || userCheck.technicalData?.spectral_balance || {};
    const refBandsCheck = refCheck.bands || refCheck.technicalData?.spectral_balance || {};

    const userBandsCountCheck = userBandsCheck ? Object.keys(userBandsCheck).length : 0;
    const refBandsCountCheck = refBandsCheck ? Object.keys(refBandsCheck).length : 0;
    
    if (refBandsCountCheck === 0) {
        console.warn("[REF-COMP] referenceBands ausentes - fallback para valores brutos");
    }

    console.log("[REF-COMP] Dados validados:", { 
        userTrackCheck, 
        refTrackCheck, 
        userBandsCount: userBandsCountCheck, 
        refBandsCount: refBandsCountCheck,
        userBandsKeys: userBandsCheck ? Object.keys(userBandsCheck) : [],
        refBandsKeys: refBandsCheck ? Object.keys(refBandsCheck) : []
    });
    
    // ğŸ§© [FINAL-FIX] ValidaÃ§Ã£o real das bandas antes de renderizar
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (container ausente)");
        return;
    }
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Removido __REF_RENDER_LOCK__ que bloqueava segunda chamada legÃ­tima
    // A validaÃ§Ã£o de dados abaixo Ã© suficiente para prevenir renders incompletos
    console.log("[LOCK-FIX] âœ… Permitindo render com validaÃ§Ã£o de dados (lock duplicado removido)");
    
    // Aceita opts ou analysis (backward compatibility)
    const analysis = opts.analysis || opts;
    let comparisonData = opts?.comparisonData || {};
    
    const refBandsReal =
        comparisonData?.refBands ||
        comparisonData?.referenceAnalysis?.bands ||
        comparisonData?.referenceAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.referenceAnalysis?.bands ||
        window.__soundyState?.reference?.referenceAnalysis?.technicalData?.spectral_balance;

    const userBandsReal =
        comparisonData?.userBands ||
        comparisonData?.userAnalysis?.bands ||
        comparisonData?.userAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.userAnalysis?.bands ||
        window.__soundyState?.reference?.userAnalysis?.technicalData?.spectral_balance;

    console.log('[VALIDATION-FIX] Verificando bandas:', {
        refBandsRealKeys: refBandsReal ? Object.keys(refBandsReal) : null,
        userBandsRealKeys: userBandsReal ? Object.keys(userBandsReal) : null,
    });

    if (!refBandsReal || !userBandsReal) {
        console.error('[VALIDATION-FIX] âŒ Falha crÃ­tica: bandas nÃ£o detectadas no momento do render.');
        console.error('comparisonData:', comparisonData);
        console.error('window.__soundyState:', window.__soundyState);
        window.comparisonLock = false;
        if (typeof displayModalResultsError === 'function') {
            return displayModalResultsError('Erro na anÃ¡lise por referÃªncia (bandas nÃ£o detectadas).');
        }
        return;
    }

    // âœ… Substitui o fallback antigo
    comparisonData.refBands = refBandsReal;
    comparisonData.userBands = userBandsReal;
    console.log('[VALIDATION-FIX] âœ… Bandas restauradas para renderizaÃ§Ã£o A/B');
    
    // ğŸ§  [SAFE_REF_V3] PATCH DEFINITIVO - Construir estrutura segura ANTES de qualquer acesso
    console.groupCollapsed("ğŸ§  [SAFE_REF_V3]");
    console.log("ğŸ“¦ opts recebido:", opts);
    
    // ğŸ” Obter state global
    const stateV3 = window.__soundyState || {};
    
    // ğŸ” Obter anÃ¡lises primeiro
    const ua = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
    const ra = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
    
    // ğŸ” Construir comparaÃ§Ã£o segura com mÃºltiplas fontes
    let comparisonBase = 
        opts?.comparisonData || 
        window?.comparisonData || 
        window?.lastComparisonData || 
        {};
    
    // ğŸ¯ SEMÃ‚NTICA CORRETA:
    // - userTrack = 1Âª faixa (SUA MÃšSICA/ATUAL) = userAnalysis
    // - referenceTrack = 2Âª faixa (REFERÃŠNCIA/ALVO) = referenceAnalysis
    let comparisonSafe;
    
    if (!comparisonBase.userTrack || !comparisonBase.referenceTrack) {
        console.warn("âš ï¸ [SAFE_REF_V3] comparisonData incompleto â€” tentando reconstruir via anÃ¡lises");
        
        comparisonSafe = {
            userTrack: ua?.metadata?.fileName || ua?.fileName || "1Âª Faixa (Sua MÃºsica/Atual)",
            referenceTrack: ra?.metadata?.fileName || ra?.fileName || "2Âª Faixa (ReferÃªncia/Alvo)",
            userBands: 
                ua?.technicalData?.spectral_balance || 
                ua?.bands || 
                ua?.spectralBands || 
                null,
            refBands: 
                ra?.technicalData?.spectral_balance || 
                ra?.bands || 
                ra?.spectralBands || 
                null,
        };
    } else {
        comparisonSafe = comparisonBase;
    }
    
    // ğŸ” [AUDIT-BANDS-SAFE-V3] Log APÃ“S construÃ§Ã£o de comparisonSafe
    try {
        console.log('[AUDIT-BANDS-SAFE-V3]', {
            comparisonSafeUserBands: comparisonSafe.userBands,
            comparisonSafeRefBands: comparisonSafe.refBands,
            typeofUserBands: typeof comparisonSafe.userBands,
            typeofRefBands: typeof comparisonSafe.refBands,
            userBandsKeys: comparisonSafe.userBands ? Object.keys(comparisonSafe.userBands) : [],
            refBandsKeys: comparisonSafe.refBands ? Object.keys(comparisonSafe.refBands) : [],
            sourceUA: ua ? 'opts.userAnalysis ou state.reference.userAnalysis' : 'N/A',
            sourceRA: ra ? 'opts.referenceAnalysis ou state.reference.referenceAnalysis' : 'N/A',
            uaBands: ua?.technicalData?.spectral_balance || ua?.bands || ua?.spectralBands,
            raBands: ra?.technicalData?.spectral_balance || ra?.bands || ra?.spectralBands
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-SAFE-V3', err);
    }
    
    // Guardar globalmente (backup)
    window.lastComparisonData = comparisonSafe;
    
    // ğŸ§© Substituir opts.comparisonData quebrado
    opts.comparisonData = comparisonSafe;
    
    // ğŸ”’ Fallback hard caso ainda venha undefined
    if (!comparisonSafe.referenceTrack) {
        comparisonSafe.referenceTrack = 
            opts?.referenceAnalysis?.metadata?.fileName || 
            opts?.referenceAnalysis?.fileName ||
            stateV3?.reference?.referenceAnalysis?.metadata?.fileName || 
            "2Âª Faixa (ReferÃªncia/Alvo)";
    }
    if (!comparisonSafe.userTrack) {
        comparisonSafe.userTrack = 
            opts?.userAnalysis?.metadata?.fileName || 
            opts?.userAnalysis?.fileName ||
            stateV3?.reference?.userAnalysis?.metadata?.fileName || 
            "1Âª Faixa (Sua MÃºsica/Atual)";
    }
    
    console.log("âœ… [SAFE_REF_V3] Estrutura final reconstruÃ­da:", comparisonSafe);
    console.groupEnd();
    

    //  [PATCH V5] SCOPE GUARD DEFINITIVO - SincronizaÃ§Ã£o final antes de usar dados
    console.groupCollapsed(" [REF_FIX_V5]");
    let userTrack, referenceTrack;
    try {
        //  Verifica e sincroniza escopo de comparisonData
        // ğŸ¯ SEMÃ‚NTICA CORRETA:
        // - userTrack = 1Âª faixa (SUA MÃšSICA/ATUAL) = userAnalysis
        // - referenceTrack = 2Âª faixa (REFERÃŠNCIA/ALVO) = referenceAnalysis
        let comparisonData =
            opts?.comparisonData ||
            window?.comparisonData ||
            window?.lastComparisonData ||
            stateV3?.reference?.comparisonData ||
            comparisonSafe || // Usar comparisonSafe do Patch V3 como fallback
            {
                userTrack:
                    opts?.userAnalysis?.metadata?.fileName ||
                    opts?.userAnalysis?.fileName ||
                    stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                    "Sua MÃºsica (Atual)",
                referenceTrack:
                    opts?.referenceAnalysis?.metadata?.fileName ||
                    opts?.referenceAnalysis?.fileName ||
                    stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                    "Faixa de ReferÃªncia (Alvo)",
                userBands:
                    opts?.userAnalysis?.technicalData?.spectral_balance ||
                    opts?.userAnalysis?.bands ||
                    stateV3?.reference?.userAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.userAnalysis?.bands ||
                    {},
                refBands:
                    opts?.referenceAnalysis?.technicalData?.spectral_balance ||
                    opts?.referenceAnalysis?.bands ||
                    stateV3?.reference?.referenceAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.referenceAnalysis?.bands ||
                    {},
            };

        // ğŸ§© FIX: Preservar bandas vÃ¡lidas antes da redeclaraÃ§Ã£o
        if (comparisonData) {
            // Se jÃ¡ houver bandas vÃ¡lidas em comparisonSafe, preservar
            if (!comparisonData.refBands && comparisonSafe?.refBands) {
                comparisonData.refBands = comparisonSafe.refBands;
            }
            if (!comparisonData.userBands && comparisonSafe?.userBands) {
                comparisonData.userBands = comparisonSafe.userBands;
            }
            
            // Fallback adicional para opts se comparisonData ainda vazio
            if (!comparisonData.refBands && opts?.referenceAnalysis) {
                comparisonData.refBands =
                    opts.referenceAnalysis.bands ||
                    opts.referenceAnalysis.technicalData?.spectral_balance ||
                    window.__lastRefBands ||
                    {};
            }
            if (!comparisonData.userBands && opts?.userAnalysis) {
                comparisonData.userBands =
                    opts.userAnalysis.bands ||
                    opts.userAnalysis.technicalData?.spectral_balance ||
                    window.__lastUserBands ||
                    {};
            }
        }

        //  Atualiza referÃªncias globais
        window.comparisonData = comparisonData;
        window.lastComparisonData = comparisonData;
        opts.comparisonData = comparisonData;

        //  Cria variÃ¡veis locais seguras com fallback robusto
        // ğŸ¯ SEMÃ‚NTICA CORRETA DOS NOMES:
        userTrack = comparisonData?.userTrack || "Sua MÃºsica (Atual)";
        referenceTrack = comparisonData?.referenceTrack || "Faixa de ReferÃªncia (Alvo)";
        
        // âš¡ Fallback em cascata para garantir bandas vÃ¡lidas (incluindo persistÃªncia global)
        const localRefBands =
            window.__lastRefBands ||
            comparisonData?.refBands ||
            comparisonSafe?.refBands ||
            opts?.referenceAnalysis?.bands ||
            opts?.referenceAnalysis?.technicalData?.spectral_balance ||
            {};
        
        const localUserBands =
            window.__lastUserBands ||
            comparisonData?.userBands ||
            comparisonSafe?.userBands ||
            opts?.userAnalysis?.bands ||
            opts?.userAnalysis?.technicalData?.spectral_balance ||
            {};
        
        // [REF-COMP] âœ… Persistir bandas globalmente para uso posterior
        if (localRefBands && Object.keys(localRefBands).length > 0) window.__lastRefBands = localRefBands;
        if (localUserBands && Object.keys(localUserBands).length > 0) window.__lastUserBands = localUserBands;
        
        console.log('[REF-COMP][BANDS-FINAL-FIX] Estado de bandas apÃ³s fallback:', {
            hasRefBands: !!localRefBands && Object.keys(localRefBands).length > 0,
            hasUserBands: !!localUserBands && Object.keys(localUserBands).length > 0,
            refKeys: localRefBands ? Object.keys(localRefBands) : [],
            userKeys: localUserBands ? Object.keys(localUserBands) : []
        });

        // ğŸ” [AUDIT-REDECLARE] Log APÃ“S redeclaraÃ§Ã£o de variÃ¡veis
        try {
            console.log('[AUDIT-REDECLARE]', {
                refBandsCheck: localRefBands,
                userBandsCheck: localUserBands,
                typeofRefBands: typeof localRefBands,
                typeofUserBands: typeof localUserBands,
                refBandsKeys: localRefBands ? Object.keys(localRefBands) : [],
                userBandsKeys: localUserBands ? Object.keys(localUserBands) : [],
                refBandsIsEmpty: !localRefBands || Object.keys(localRefBands).length === 0,
                userBandsIsEmpty: !localUserBands || Object.keys(localUserBands).length === 0,
                comparisonDataRefBands: comparisonData?.refBands,
                comparisonDataUserBands: comparisonData?.userBands
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'AUDIT-REDECLARE', err);
        }

        console.log(" [REF_FIX_V5] Estrutura estabilizada:", {
            userTrack,
            referenceTrack,
            userBands: !!Object.keys(localUserBands || {}).length,
            refBands: !!Object.keys(localRefBands || {}).length,
        });

        //  Abortagem segura se algo vier undefined
        if (!referenceTrack || !userTrack) {
            console.error(" [REF_FIX_V5] referenceTrack ou userTrack ausentes!");
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (track ausente)");
            console.groupEnd();
            return;
        }

        //  Reatribui localmente para garantir escopo
        opts.referenceTrack = referenceTrack;
        opts.userTrack = userTrack;
        comparisonData.referenceTrack = referenceTrack;
        comparisonData.userTrack = userTrack;
    } catch (err) {
        console.error(" [REF_FIX_V5] Erro crÃ­tico de escopo:", err);
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (erro crÃ­tico)");
        console.groupEnd();
        return;
    }
    console.groupEnd();
    
    // ğŸ§® PARTE 3.2: ValidaÃ§Ã£o e normalizaÃ§Ã£o de anÃ¡lises
    const sRef = stateV3?.reference || {};
    const userAnalysis = opts.userAnalysis ?? sRef.userAnalysis;
    const referenceAnalysis = opts.referenceAnalysis ?? sRef.referenceAnalysis;

    if (!userAnalysis || !referenceAnalysis) {
        console.warn("[REF-COMP] Faltam anÃ¡lises; usando fallback controlado.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (anÃ¡lises ausentes)");
        return renderGenreComparisonSafe?.();
    }

    // ğŸ¯ SEMÃ‚NTICA CORRETA DOS NOMES:
    // - userAnalysis = 1Âª faixa = SUA MÃšSICA (atual)
    // - referenceAnalysis = 2Âª faixa = REFERÃŠNCIA (alvo a alcanÃ§ar)
    const userTrackNormalized = userAnalysis.fileName || userAnalysis.metadata?.fileName || sRef.userTrack || "Sua MÃºsica (Atual)";
    const refTrackNormalized = referenceAnalysis.fileName || referenceAnalysis.metadata?.fileName || sRef.referenceTrack || "Faixa de ReferÃªncia (Alvo)";
    
    // ğŸ” AUDITORIA ANTI-DUPLICAÃ‡ÃƒO: Verificar se as faixas sÃ£o distintas
    console.log('ğŸ” [AUDIT_REF_MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸ” [AUDIT_REF_MODE âœ…] ValidaÃ§Ã£o de faixas distintas:');
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   userTrack (SUA MÃšSICA):', userTrackNormalized);
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   referenceTrack (REFERÃŠNCIA):', refTrackNormalized);
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   SÃ£o idÃªnticas?', userTrackNormalized === refTrackNormalized ? 'âš ï¸ SIM - VERIFICAR FLUXO!' : 'âœ… NÃƒO');
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   userAnalysis jobId:', userAnalysis?.jobId);
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   referenceAnalysis jobId:', referenceAnalysis?.jobId);
    console.log('ğŸ” [AUDIT_REF_MODE âœ…]   JobIds idÃªnticos?', userAnalysis?.jobId === referenceAnalysis?.jobId ? 'âš ï¸ SIM - VERIFICAR!' : 'âœ… NÃƒO');
    console.log('ğŸ” [AUDIT_REF_MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    if (userTrackNormalized === refTrackNormalized) {
        console.warn("âš ï¸ [REF-COMP] As duas faixas tÃªm o mesmo nome â€” verifique o fluxo de atribuiÃ§Ã£o!");
        console.warn("âš ï¸ [REF-COMP] Dados recebidos:", {
            userAnalysis: userAnalysis,
            referenceAnalysis: referenceAnalysis
        });
    }
    
    // Evita leitura em escopos errados - ABORT se referenceTrack undefined
    if (!referenceTrack) {
        console.error("ğŸš¨ [SAFE_REF_V3] referenceTrack ainda undefined! Abortando render seguro.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (referenceTrack undefined)");
        return;
    }
    
    // âœ… LOG PARA CONFIRMAÃ‡ÃƒO FINAL
    console.log("[REF-COMPARE âœ…] DireÃ§Ã£o correta confirmada: PRIMEIRA = sua mÃºsica (atual), SEGUNDA = referÃªncia (alvo)");
    
    // [AUDIT-FLOW] Log de rastreamento PRÃ‰-EXTRAÃ‡ÃƒO
    console.log("[AUDIT-FLOW] ğŸ” PRÃ‰-EXTRAÃ‡ÃƒO de bandas:", {
        'analysis.userAnalysis?.bands': analysis.userAnalysis?.bands,
        'opts.userAnalysis?.bands': opts.userAnalysis?.bands,
        'opts.userAnalysis?.technicalData?.spectral_balance': opts.userAnalysis?.technicalData?.spectral_balance,
        'analysis.referenceAnalysis?.bands': analysis.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.bands': opts.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.technicalData?.spectral_balance': opts.referenceAnalysis?.technicalData?.spectral_balance
    });
    
    // âœ… CORREÃ‡ÃƒO V3: ExtraÃ§Ã£o unificada de bandas espectrais (aceita arrays e objetos)
    let userBandsLocal =
        analysis.userAnalysis?.bands ||
        opts.userAnalysis?.bands ||
        opts.userAnalysis?.technicalData?.spectral_balance ||
        analysis.bands ||
        analysis.referenceComparison?.userBands ||
        null;

    let refBandsLocal =
        analysis.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.technicalData?.spectral_balance ||
        analysis.referenceComparison?.refBands ||
        null;
    
    // [AUDIT-FLOW] Log PÃ“S-EXTRAÃ‡ÃƒO
    console.log("[AUDIT-FLOW] ğŸ” PÃ“S-EXTRAÃ‡ÃƒO de bandas:", {
        userBandsLocal,
        refBandsLocal,
        userBandsLocalType: userBandsLocal ? (Array.isArray(userBandsLocal) ? 'Array' : 'Object') : 'null',
        refBandsLocalType: refBandsLocal ? (Array.isArray(refBandsLocal) ? 'Array' : 'Object') : 'null'
    });
    
    // ï¿½ LOG DE DEBUG: Mostrar o que foi encontrado
    console.log("[REF-COMP] ğŸ” ExtraÃ§Ã£o inicial de bandas:", {
        userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? `Array(${userBandsLocal.length})` : `Object(${Object.keys(userBandsLocal).length})`) : 'null',
        refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? `Array(${refBandsLocal.length})` : `Object(${Object.keys(refBandsLocal).length})`) : 'null',
        sourceUser: userBandsLocal ? 'encontrado' : 'null',
        sourceRef: refBandsLocal ? 'encontrado' : 'null'
    });

    // âœ… ValidaÃ§Ã£o: Aceitar tanto arrays quanto objetos
    const hasUserBands = userBandsLocal && (
        (Array.isArray(userBandsLocal) && userBandsLocal.length > 0) ||
        (typeof userBandsLocal === 'object' && Object.keys(userBandsLocal).length > 0)
    );
    
    const hasRefBands = refBandsLocal && (
        (Array.isArray(refBandsLocal) && refBandsLocal.length > 0) ||
        (typeof refBandsLocal === 'object' && Object.keys(refBandsLocal).length > 0)
    );

    // ğŸš¨ ProteÃ§Ã£o aprimorada com fallback global
    if (!hasUserBands || !hasRefBands) {
        console.warn("[REF-COMP] âš ï¸ Bandas ausentes na estrutura principal - tentando fallback global");
        
        const globalUser = window.__soundyState?.previousAnalysis?.bands || 
                          window.__soundyState?.previousAnalysis?.technicalData?.spectral_balance ||
                          window.__soundyState?.userAnalysis?.bands || 
                          null;
        const globalRef = window.__soundyState?.referenceAnalysis?.bands || 
                         window.__soundyState?.referenceAnalysis?.technicalData?.spectral_balance ||
                         window.__soundyState?.reference?.analysis?.bands || 
                         null;
        
        const hasGlobalUser = globalUser && (
            (Array.isArray(globalUser) && globalUser.length > 0) ||
            (typeof globalUser === 'object' && Object.keys(globalUser).length > 0)
        );
        
        const hasGlobalRef = globalRef && (
            (Array.isArray(globalRef) && globalRef.length > 0) ||
            (typeof globalRef === 'object' && Object.keys(globalRef).length > 0)
        );
        
        console.log("[REF-COMP] ğŸ” Fallback global:", {
            globalUser: globalUser ? (Array.isArray(globalUser) ? `Array(${globalUser.length})` : `Object(${Object.keys(globalUser).length})`) : 'null',
            globalRef: globalRef ? (Array.isArray(globalRef) ? `Array(${globalRef.length})` : `Object(${Object.keys(globalRef).length})`) : 'null',
            hasGlobalUser,
            hasGlobalRef,
            hasPreviousAnalysis: !!window.__soundyState?.previousAnalysis,
            hasReferenceAnalysis: !!window.__soundyState?.referenceAnalysis
        });
        
        if (!hasGlobalUser || !hasGlobalRef) {
            console.error("[REF-COMP] âŒ Nenhum dado vÃ¡lido encontrado - abortando render");
            console.table({
                userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0,
                refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0,
                globalUser: globalUser ? (Array.isArray(globalUser) ? globalUser.length : Object.keys(globalUser).length) : 0,
                globalRef: globalRef ? (Array.isArray(globalRef) ? globalRef.length : Object.keys(globalRef).length) : 0,
                hasUserAnalysis: !!analysis.userAnalysis,
                hasReferenceAnalysis: !!analysis.referenceAnalysis,
                soundyStateKeys: Object.keys(window.__soundyState || {})
            });
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (sem dados vÃ¡lidos)");
            console.groupEnd();
            return;
        }
        
        // Aplicar fallback
        userBandsLocal = globalUser;
        refBandsLocal = globalRef;
        
        console.log("[REF-COMP] âœ… Fallback global aplicado com sucesso");
    }

    // Atualizar variÃ¡veis globais
    userBands = userBandsLocal;
    refBands = refBandsLocal;
    
    // [AUDIT-FLOW] Log apÃ³s atribuiÃ§Ã£o final
    console.log("[AUDIT-FLOW] ğŸ” ApÃ³s atribuiÃ§Ã£o final:", {
        userBands,
        refBands,
        userBandsIsValid: !!(userBandsLocal && (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length)),
        refBandsIsValid: !!(refBandsLocal && (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length))
    });
    
    // âœ… LOG FINAL CONSOLIDADO
    const userBandsCount = userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0;
    const refBandsCount = refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0;
    
    console.log("[REF-COMP] âœ… Bandas detectadas:", {
        userBands: userBandsCount,
        refBands: refBandsCount,
        userBandsType: userBands ? (Array.isArray(userBands) ? 'Array' : 'Object') : 'null',
        refBandsType: refBands ? (Array.isArray(refBands) ? 'Array' : 'Object') : 'null',
        source: hasUserBands && hasRefBands ? 'analysis-principal' : 'fallback-global'
    });
    
    console.log("âœ… [SAFE_REF_V3] Tracks resolvidas:", { 
        userTrack, 
        referenceTrack, 
        userBands: !!userBands, 
        refBands: !!refBands,
        userBandsCount,
        refBandsCount
    });
    
    // ğŸ§  SAFEGUARD FINAL: VerificaÃ§Ã£o crÃ­tica antes de qualquer renderizaÃ§Ã£o
    if (opts?.mode === "reference") {
        // SAFEGUARD: garantir que spectral_balance exista na estrutura
        if (opts?.referenceAnalysis && !opts?.referenceAnalysis?.technicalData?.spectral_balance) {
            console.warn("âš ï¸ [SAFEGUARD] spectral_balance ausente em referenceAnalysis â€” aplicando patch.");
            if (!opts.referenceAnalysis.technicalData) opts.referenceAnalysis.technicalData = {};
            opts.referenceAnalysis.technicalData.spectral_balance = refBands;
        }
        
        if (opts?.userAnalysis && !opts?.userAnalysis?.technicalData?.spectral_balance) {
            console.warn("âš ï¸ [SAFEGUARD] spectral_balance ausente em userAnalysis â€” aplicando patch.");
            if (!opts.userAnalysis.technicalData) opts.userAnalysis.technicalData = {};
            opts.userAnalysis.technicalData.spectral_balance = userBands;
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Fonte da verdade vem do caller - NÃƒO usar fallback 'genre'
    // Reusar stateV3 jÃ¡ declarado no patch V3 acima
    
    // ğŸš¨ PRIORIDADE DE DETECÃ‡ÃƒO DO MODO (sem fallback automÃ¡tico para genre):
    // 1. opts.mode (passado explicitamente pelo caller)
    // 2. stateV3.render.mode (jÃ¡ configurado anteriormente)
    // 3. stateV3.reference.isSecondTrack = true â†’ forÃ§ar 'reference'
    // 4. Ãšltimo recurso: 'genre'
    let explicitMode = opts.mode || stateV3?.render?.mode;
    
    // ğŸ¯ Se segunda faixa estÃ¡ ativa, FORÃ‡AR modo reference
    if (stateV3.reference?.isSecondTrack === true && !explicitMode) {
        explicitMode = 'reference';
        console.log('ğŸ”¥ [MODE-OVERRIDE] Segunda faixa detectada - forÃ§ando modo reference');
    }
    
    // Fallback final apenas se realmente necessÃ¡rio
    if (!explicitMode) {
        explicitMode = 'genre';
        console.warn('âš ï¸ [MODE-FALLBACK] Nenhum modo detectado - usando genre como fallback');
    }
    
    const isReferenceMode = (opts?.mode === 'reference') 
        || (stateV3?.render?.mode === 'reference') 
        || (stateV3?.reference?.isSecondTrack === true && !opts?.mode);
    
    if (isReferenceMode) console.log('[REF-FLOW] renderReferenceComparisons in reference mode');
    
    const isReference = explicitMode === 'reference';
    
    // Salvar modo no estado (NÃƒO sobrescrever se jÃ¡ for reference)
    stateV3.render = stateV3.render || {};
    if (stateV3.render.mode !== 'reference' || explicitMode === 'reference') {
        stateV3.render.mode = explicitMode;
    }
    window.__soundyState = stateV3;
    
    // (Opcional) Log assertivo
    console.log('[RENDER-REF] MODO SELECIONADO:', explicitMode.toUpperCase());
    console.log('[ASSERT] mode=', explicitMode, 'isSecondTrack=', stateV3?.reference?.isSecondTrack, 'refJobId=', stateV3?.reference?.jobId);
    console.log('[ASSERT] opts.mode=', opts.mode, 'stateV3.render.mode=', stateV3.render.mode);
    
    // ğŸš¨ CRÃTICO: NÃƒO reavaliar "se tem ref" para mudar o modo
    // O modo Ã© determinÃ­stico e vem do caller
    const renderMode = explicitMode;
    
    // ğŸ¯ PATCH 5: Asserts de validaÃ§Ã£o de modo (NÃƒO ABORTAM, apenas logam)
    if (renderMode === 'reference') {
        if (!stateV3?.reference?.analysis?.bands) {
            console.warn('âš ï¸ [ASSERT-MAIN] Modo reference sem stateV3.reference.analysis.bands - pode usar fallback');
        }
        if (!stateV3?.reference?.isSecondTrack) {
            console.warn('âš ï¸ [ASSERT-MAIN] Modo reference sem flag isSecondTrack');
        }
        if (!stateV3?.reference?.analysis) {
            console.warn('âš ï¸ [CRITICAL] Modo reference configurado mas sem dados de referÃªncia no stateV3!');
            console.warn('âš ï¸ stateV3.reference:', stateV3?.reference);
        }
    } else if (renderMode === 'genre') {
        if (!window.__activeRefData?.bands) {
            console.warn('âš ï¸ [ASSERT-MAIN] Modo genre sem __activeRefData.bands - tentando fallback');
            console.warn('âš ï¸ __activeRefData:', window.__activeRefData);
        }
    }
    console.log('âœ… [PATCH-5] Asserts de modo executados:', { renderMode, hasRefBands: !!(stateV3?.reference?.analysis?.bands), hasGenreBands: !!(window.__activeRefData?.bands) });
    
    // ğŸš¨ REMOVIDO: DetecÃ§Ã£o legacy automÃ¡tica (causava auto-switch indevido)
    // O modo agora Ã© determinÃ­stico e vem do caller via opts.mode
    // NÃƒO tentar "adivinhar" o modo baseado em analysis.mode ou estruturas
    
    // ğŸ¯ CORREÃ‡ÃƒO: Definir hasNewStructure e hasOldStructure ANTES de usar
    const hasNewStructure = !!(analysis?.referenceAnalysis?.technicalData || analysis?.metrics);
    const hasOldStructure = !!(analysis?.referenceComparison && !hasNewStructure);
    
    let ref, titleText, userMetrics;
    
    // ğŸ” [AUDITORIA_REF] Log de detecÃ§Ã£o crÃ­tica
    console.log('[AUDITORIA_REF] DetecÃ§Ã£o de modo:', {
        'analysis.mode': analysis.mode,
        'isReferenceMode': isReferenceMode,
        'hasNewStructure': hasNewStructure,
        'hasOldStructure': hasOldStructure,
        'window.__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
        'referenceAnalysisData': !!window.referenceAnalysisData
    });
    
    // ğŸ¯ USAR renderMode PARA DECIDIR O FLUXO (nÃ£o isReferenceMode)
    if (renderMode === 'reference') {
        console.log('[AUDITORIA_REF] Modo referÃªncia detectado â€“ exibindo comparaÃ§Ã£o A/B entre faixas');
        
        // ğŸ”¥ PRIORIDADE MÃXIMA: Usar nova estrutura corrigida (userAnalysis/referenceAnalysis)
        if (opts.userAnalysis && opts.referenceAnalysis) {
            console.log('ğŸ”¥ [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ”¥ [REF-CORRECTED] Usando estrutura corrigida: opts.userAnalysis + opts.referenceAnalysis');
            console.log('ğŸ”¥ [REF-CORRECTED] userAnalysis existe:', !!opts.userAnalysis);
            console.log('ğŸ”¥ [REF-CORRECTED] referenceAnalysis existe:', !!opts.referenceAnalysis);
            console.log('ğŸ”¥ [REF-CORRECTED] userAnalysis.technicalData:', !!opts.userAnalysis.technicalData);
            console.log('ğŸ”¥ [REF-CORRECTED] referenceAnalysis.technicalData:', !!opts.referenceAnalysis.technicalData);
            console.log('ğŸ”¥ [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            const userTech = opts.userAnalysis.technicalData || {};
            const refTech = opts.referenceAnalysis.technicalData || {};
            
            // ğŸ” DIAGNÃ“STICO: Verificar estrutura das bandas
            console.log('ğŸ” [DIAGNÃ“STICO] userTech.spectral_balance:', userTech.spectral_balance);
            console.log('ğŸ” [DIAGNÃ“STICO] refTech.spectral_balance:', refTech.spectral_balance);
            console.log('ğŸ” [DIAGNÃ“STICO] userTech.bandEnergies:', userTech.bandEnergies);
            console.log('ğŸ” [DIAGNÃ“STICO] refTech.bandEnergies:', refTech.bandEnergies);
            console.log('ğŸ” [DIAGNÃ“STICO] userTech.bands:', userTech.bands);
            console.log('ğŸ” [DIAGNÃ“STICO] refTech.bands:', refTech.bands);
            
            userMetrics = userTech;
            ref = {
                // Valores BRUTOS da segunda faixa (referÃªncia/alvo)
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.spectral_balance ?? refTech.bandEnergies ?? refTech.bands ?? null
            };
            
            // ğŸ¯ SEMÃ‚NTICA CORRETA NO TÃTULO:
            // 1Âª faixa = sua mÃºsica (atual) | 2Âª faixa = referÃªncia (alvo)
            const userFileName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || 'Sua MÃºsica';
            const refFileName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || 'ReferÃªncia';
            titleText = `ï¿½ ComparaÃ§Ã£o da sua faixa com a referÃªncia:\nAtual: ${userFileName}\nReferÃªncia: ${refFileName}`;
            
            console.log('âœ… [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('âœ… [REF-CORRECTED] Dados A/B extraÃ­dos corretamente:');
            console.log('âœ… [REF-CORRECTED]   SUA MÃšSICA (1Âª):', opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName);
            console.log('âœ… [REF-CORRECTED]   Bandas:', Object.keys(userMetrics.spectral_balance || {}));
            console.log('âœ… [REF-CORRECTED]   LUFS:', userMetrics.lufsIntegrated);
            console.log('âœ… [REF-CORRECTED]   REFERÃŠNCIA (2Âª):', opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName);
            console.log('âœ… [REF-CORRECTED]   Bandas:', Object.keys(ref.bands || {}));
            console.log('âœ… [REF-CORRECTED]   LUFS:', ref.lufs_target);
            console.log('âœ… [REF-CORRECTED]   Tabela: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
            console.log('âœ… [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ¯ LOG ASSERT_REF_FLOW
            console.log("[ASSERT_REF_FLOW âœ…]", {
                mode: 'reference',
                userTrack: opts.userAnalysis?.fileName || opts.userAnalysis?.metadata?.fileName,
                referenceTrack: opts.referenceAnalysis?.fileName || opts.referenceAnalysis?.metadata?.fileName,
                userBands: Object.keys(userMetrics.spectral_balance || {}),
                refBands: Object.keys(ref.bands || {}),
                userLUFS: userMetrics.lufsIntegrated,
                refLUFS: ref.lufs_target
            });
        }
        // ğŸ¯ PRIORIDADE 0 (FALLBACK): analysis.referenceAnalysis (estrutura antiga)
        else if (analysis.referenceAnalysis && analysis.referenceAnalysis.technicalData) {
            console.log('âœ… [REF-COMP] Usando real reference analysis as target (primeira faixa)');
            
            const refTech = analysis.referenceAnalysis.technicalData;
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.bandEnergies ?? refTech.spectral_balance ?? refTech.bands ?? null
            };
            
            titleText = `ğŸµ ${analysis.referenceAnalysis.fileName || analysis.referenceAnalysis.metadata?.fileName || 'Faixa Base'}`;
            
            console.log('ğŸ“Š [REF-COMP] baseBands/refBands resolved from referenceAnalysis:', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                hasBands: !!ref.bands,
                bandsKeys: ref.bands ? Object.keys(ref.bands) : []
            });
            console.log('âœ… [REF-COMP] Using real reference analysis as target');
        }
        // ğŸ¯ PRIORIDADE 1 (FALLBACK): analysis.referenceBands (estrutura centralizada)
        else if (analysis.referenceBands && analysis.mode === 'reference') {
            console.log('âœ… [RENDER-REF] Usando analysis.referenceBands (estrutura centralizada)');
            
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: analysis.referenceBands.lufsIntegrated || analysis.referenceBands.lufs_integrated,
                true_peak_target: analysis.referenceBands.truePeakDbtp || analysis.referenceBands.true_peak_dbtp,
                dr_target: analysis.referenceBands.dynamicRange || analysis.referenceBands.dynamic_range,
                lra_target: analysis.referenceBands.lra,
                stereo_target: analysis.referenceBands.stereoCorrelation || analysis.referenceBands.stereo_correlation,
                stereo_width_target: analysis.referenceBands.stereoWidth || analysis.referenceBands.stereo_width,
                spectral_centroid_target: analysis.referenceBands.spectralCentroidHz || analysis.referenceBands.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: analysis.referenceBands.spectral_balance || analysis.referenceBands.bands || null
            };
            
            titleText = `ğŸµ Faixa de ReferÃªncia`;
            
            console.log('ğŸ“Š [RENDER-REF] ReferÃªncia (referenceBands):', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: ref.bands
            });
        }
        // ===== PRIORIDADE 2: NOVA ESTRUTURA (userTrack/referenceTrack) =====
        else if (hasNewStructure) {
            // ğŸ§  [PATCH V4] REFERENCE SCOPE LOCK FIX - Estabilizar escopo antes de render
            try {
                console.groupCollapsed("ğŸ§  [REF_SCOPE_LOCK]");
                console.log("ğŸ“¦ Contexto atual antes do render:", { opts, stateV3 });

                // ğŸ”’ Buscar dados de comparaÃ§Ã£o em todos os escopos possÃ­veis
                let comparisonLock =
                    opts?.comparisonData ||
                    window?.lastComparisonData ||
                    stateV3?.reference?.comparisonData ||
                    {
                        userTrack:
                            opts?.userAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                            "Faixa do UsuÃ¡rio",
                        referenceTrack:
                            opts?.referenceAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                            "Faixa de ReferÃªncia",
                        userBands:
                            opts?.userAnalysis?.bands ||
                            stateV3?.reference?.userAnalysis?.bands ||
                            {},
                        refBands:
                            opts?.referenceAnalysis?.bands ||
                            stateV3?.reference?.referenceAnalysis?.bands ||
                            {},
                    };

                // ğŸ” Corrigir se ainda estiver faltando algo
                if (!comparisonLock.referenceTrack) {
                    comparisonLock.referenceTrack =
                        opts?.referenceAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                        "Faixa de ReferÃªncia";
                }
                if (!comparisonLock.userTrack) {
                    comparisonLock.userTrack =
                        opts?.userAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                        "Faixa do UsuÃ¡rio";
                }

                // ğŸ”’ Salvar globalmente para persistir escopo
                window.lastComparisonData = comparisonLock;

                console.log("âœ… [REF_SCOPE_LOCK] Estrutura estabilizada:", comparisonLock);
                console.groupEnd();

                // ğŸ§© Reatribuir variÃ¡veis seguras locais
                const userTrackLock = comparisonLock.userTrack;
                const referenceTrackLock = comparisonLock.referenceTrack;
                const userBandsLock = comparisonLock.userBands;
                const refBandsLock = comparisonLock.refBands;

                // Se ainda nÃ£o tiver bandas, abortar render seguro
                if (!refBandsLock || Object.keys(refBandsLock).length === 0) {
                    console.error(
                        "ğŸš¨ [REF_SCOPE_LOCK] refBands ausente, abortando renderizaÃ§Ã£o segura."
                    );
                    window.__REF_RENDER_LOCK__ = false;
                    window.comparisonLock = false;
                    console.log("[LOCK] comparisonLock liberado (refBands ausente)");
                    return;
                }

                // âœ… Reaplicar no escopo principal
                opts.comparisonData = comparisonLock;
                window.comparisonData = comparisonLock;
            } catch (err) {
                console.error("ğŸ’¥ [REF_SCOPE_LOCK] Erro crÃ­tico ao reestabelecer escopo:", err);
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (erro escopo)");
                return;
            }
            
            console.log('âœ… [RENDER-REF] Usando NOVA estrutura (userTrack/referenceTrack)');
            
            // ğŸ§© Fix final do modal A/B - usar dados corretos de comparisonLock
            const refFile = 
                comparisonLock?.refFile ||
                comparisonLock?.referenceTrack ||
                opts?.referenceAnalysis?.fileName ||
                opts?.referenceAnalysis?.metadata?.fileName ||
                stateV3?.reference?.referenceAnalysis?.fileName ||
                "Faixa de referÃªncia";

            const userFile = 
                comparisonLock?.userFile ||
                comparisonLock?.userTrack ||
                opts?.userAnalysis?.fileName ||
                opts?.userAnalysis?.metadata?.fileName ||
                stateV3?.reference?.userAnalysis?.fileName ||
                "Faixa do usuÃ¡rio";

            console.log("[REF-FIX-FINAL] referenceTrackName resolvido:", refFile);
            console.log("[REF-FIX-FINAL] userTrackName resolvido:", userFile);
            
            // Extrair mÃ©tricas de opts ou stateV3
            const refAnalysis = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
            const userAnalysisData = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
            
            if (!refAnalysis || !userAnalysisData) {
                console.error("ğŸ’¥ [REF-FIX-FINAL] AnÃ¡lises nÃ£o encontradas, abortando");
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (anÃ¡lises nÃ£o encontradas)");
                return;
            }
            
            const refMetrics = refAnalysis.metrics || refAnalysis;
            userMetrics = userAnalysisData.metrics || userAnalysisData;
            
            ref = {
                lufs_target: refMetrics.lufs || refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.peak || refMetrics.truePeakDbtp,
                dr_target: refMetrics.dr || refMetrics.dynamicRange,
                lra_target: refMetrics.lra,
                stereo_target: refMetrics.stereoCorrelation,
                stereo_width_target: refMetrics.stereoWidth,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refAnalysis.bands || comparisonLock?.refBands || {}
            };
            
            titleText = `ğŸµ ${refFile}`;
            
            console.log('ğŸ“Š [RENDER-REF] ReferÃªncia:', {
                fileName: refFile,
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: Object.keys(ref.bands || {}).length
            });
            console.log('ğŸ“Š [RENDER-REF] UsuÃ¡rio:', {
                fileName: userFile,
                lufs: userMetrics.lufs || userMetrics.lufsIntegrated,
                dr: userMetrics.dr || userMetrics.dynamicRange
            });
        }
        // ===== ESTRUTURA ANTIGA (retrocompatibilidade) =====
        else if (hasOldStructure) {
            console.log('âš ï¸ [RENDER-REF] Usando estrutura ANTIGA (referenceMetrics) - considerar migraÃ§Ã£o');
            
            const refMetrics = analysis.referenceComparison.referenceMetrics;
            ref = {
                lufs_target: refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.truePeakDbtp,
                dr_target: refMetrics.dynamicRange,
                lra_target: refMetrics.lra || 6,
                stereo_target: refMetrics.stereoCorrelation,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: null
            };
            titleText = "ğŸµ Faixa de ReferÃªncia";
            
            console.log('ğŸ¯ [RENDER-REF] Usando mÃ©tricas de referÃªncia real:', refMetrics);
        }
    } else if (renderMode === 'genre') {
        // ===== MODO GÃŠNERO =====
        // ğŸ¯ SÃ“ LOGA "MODO GÃŠNERO" SE REALMENTE FOR GENRE
        console.log('ğŸµ [RENDER-REF] MODO GÃŠNERO');
        
        // ğŸ¯ LOG DE VERIFICAÃ‡ÃƒO: Garantir que targets de gÃªnero sejam usados
        console.log('[TARGET-RESOLVE] Modo GENRE confirmado - buscando targets de gÃªnero:', {
            hasWindowActiveRefData: !!window.__activeRefData,
            hasProdAiRefData: !!window.PROD_AI_REF_DATA,
            genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
        });
        
        // ğŸ¯ CORREÃ‡ÃƒO: Fallback seguro para __activeRefData com mÃºltiplas tentativas
        let __activeRefData = window.__activeRefData;
        
        // Tentativa 1: Usar dados globais
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('âš ï¸ [GENRE-MODE] __activeRefData nÃ£o disponÃ­vel, tentando PROD_AI_REF_DATA...');
            __activeRefData = window.PROD_AI_REF_DATA;
        }
        
        // Tentativa 2: Usar dados do analysis
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('âš ï¸ [GENRE-MODE] PROD_AI_REF_DATA nÃ£o disponÃ­vel, tentando analysis...');
            __activeRefData = analysis?.referenceComparison 
                || analysis?.genreTargets 
                || state?.genreTargets;
        }
        
        // Tentativa 3: Criar estrutura mÃ­nima
        if (!__activeRefData || !__activeRefData.bands) {
            console.error('âŒ [GENRE-MODE] NENHUMA FONTE DE DADOS DE GÃŠNERO ENCONTRADA!');
            console.error('âŒ Debug:', {
                hasWindowActiveRefData: !!window.__activeRefData,
                hasProdAiRefData: !!window.PROD_AI_REF_DATA,
                hasAnalysisRefComparison: !!analysis?.referenceComparison,
                genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
            });
            
            container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;opacity:.6">
                <strong style="color:#ff6b6b;">âš ï¸ ReferÃªncias de gÃªnero nÃ£o carregadas</strong><br>
                <span style="font-size:11px;">Tente recarregar a pÃ¡gina ou selecionar outro gÃªnero</span>
            </div>`; 
            return; 
        }
        
        // ğŸš¨ CORREÃ‡ÃƒO CRÃTICA: NÃƒO usar referenceComparisonMetrics no modo genre
        // Apenas usar targets de gÃªnero
        ref = __activeRefData;
        titleText = window.PROD_AI_REF_GENRE || window.__activeRefGenre || 'GÃªnero Musical';
        userMetrics = analysis.technicalData || {};
        
        console.log('âœ… [GENRE-MODE] Usando targets de gÃªnero:', {
            genre: titleText,
            hasBands: !!ref.bands,
            bandsCount: ref.bands ? Object.keys(ref.bands).length : 0,
            bandsList: ref.bands ? Object.keys(ref.bands) : [],
            source: window.__activeRefData ? 'window.__activeRefData' : (window.PROD_AI_REF_DATA ? 'PROD_AI_REF_DATA' : 'analysis')
        });
    } else {
        // FALLBACK: NÃ£o deveria cair aqui
        console.warn('âš ï¸ [RENDER-REF] MODO INDETERMINADO - renderMode:', renderMode);
        container.innerHTML = '<div style="font-size:12px;opacity:.6">Modo de anÃ¡lise nÃ£o identificado</div>'; 
        return;
    }
    
    // ğŸ¯ SOBRESCREVER com referenceComparisonMetrics APENAS se modo for 'reference'
    if (renderMode === 'reference' && referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('ğŸ¯ [RENDER-REF] MODO REFERÃŠNCIA â€” COMPARAÃ‡ÃƒO ENTRE FAIXAS ATIVADA');
        console.log('âœ… [RENDER-REF] Sobrescrevendo com referenceComparisonMetrics');
        
        const targetMetrics = referenceComparisonMetrics.reference;
        userMetrics = referenceComparisonMetrics.user;
        
        ref = {
            lufs_target: targetMetrics.lufsIntegrated || targetMetrics.lufs_integrated,
            true_peak_target: targetMetrics.truePeakDbtp || targetMetrics.true_peak_dbtp,
            dr_target: targetMetrics.dynamicRange || targetMetrics.dynamic_range,
            lra_target: targetMetrics.lra,
            stereo_target: targetMetrics.stereoCorrelation || targetMetrics.stereo_correlation,
            stereo_width_target: targetMetrics.stereoWidth || targetMetrics.stereo_width,
            spectral_centroid_target: targetMetrics.spectralCentroidHz || targetMetrics.spectral_centroid,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300,
            bands: targetMetrics.spectral_balance || null
        };
        
        // ğŸ¯ SEMÃ‚NTICA CORRETA: referenceFull = 2Âª faixa (referÃªncia/alvo)
        const userFileName = referenceComparisonMetrics.userFull?.metadata?.fileName || referenceComparisonMetrics.userFull?.fileName || 'Sua MÃºsica';
        const refFileName = referenceComparisonMetrics.referenceFull?.metadata?.fileName || referenceComparisonMetrics.referenceFull?.fileName || 'ReferÃªncia';
        titleText = `ğŸ§ ComparaÃ§Ã£o da sua faixa com a referÃªncia:\nAtual: ${userFileName}\nReferÃªncia: ${refFileName}`;
        
        // ğŸ¯ ASSERT CRÃTICO: Verificar se bands estÃ£o disponÃ­veis no modo reference
        console.log('[ASSERT_REF_DATA]', ref.bands ? 'âœ… Reference bands loaded' : 'âŒ Missing bands');
        if (!ref.bands) {
            console.error('ğŸš¨ [CRITICAL] Modo reference sem bandas! Bloqueando fallback de gÃªnero.');
            console.error('ğŸš¨ Debug:', {
                hasTargetMetrics: !!targetMetrics,
                targetMetricsKeys: targetMetrics ? Object.keys(targetMetrics) : [],
                hasSpectralBalance: !!targetMetrics?.spectral_balance,
                hasReferenceComparisonMetrics: !!referenceComparisonMetrics,
                referenceFullKeys: referenceComparisonMetrics.referenceFull ? Object.keys(referenceComparisonMetrics.referenceFull) : []
            });
        }
    } else if (renderMode === 'genre' && referenceComparisonMetrics) {
        // ğŸš¨ LOG DE SEGURANÃ‡A: Confirmar que modo genre NÃƒO usa referenceComparisonMetrics
        console.log('âœ… [GENRE-MODE] referenceComparisonMetrics IGNORADO no modo gÃªnero (correto)');
    }
    
    // ğŸ¯ Priorizar userMetrics (nova estrutura) sobre technicalData (legado)
    const tech = userMetrics || analysis.technicalData || {};
    
    console.log('ğŸ“Š [RENDER-REF] Fonte de mÃ©tricas do usuÃ¡rio:', userMetrics ? 'userMetrics (nova estrutura)' : 'technicalData (legado)');
    console.log('ğŸ“Š [RENDER-REF] Modo final confirmado:', renderMode);
    console.log('ğŸ“Š [RENDER-REF] ref.bands disponÃ­vel:', !!ref?.bands, 'keys:', ref?.bands ? Object.keys(ref.bands).length : 0);
    
    // Mapeamento de mÃ©tricas - RESTAURAR TABELA COMPLETA
    const rows = [];
    const addedLabels = new Set(); // ğŸ¯ Controle de duplicaÃ§Ã£o por nome
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
    const pushRow = (label, val, target, tol, unit='') => {
        // âœ… Epsilon para comparaÃ§Ãµes float precisas
        const EPS = 1e-6;
        
        // ğŸ¯ PREVENÃ‡ÃƒO DE DUPLICATAS: evitar bandas com mesmo nome
        if (addedLabels.has(label)) {
            console.warn(`âš ï¸ Duplicata evitada: ${label}`);
            return;
        }
        addedLabels.add(label);
        // Usar sistema de enhancement se disponÃ­vel
        const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
            ? window.enhanceRowLabel(label, label.toLowerCase().replace(/[^a-z]/g, '')) 
            : label;
            
        // Tratar target null ou NaN como N/A explicitamente
        const targetIsNA = (target == null || target === '' || (typeof target==='number' && !Number.isFinite(target)));
        if (!Number.isFinite(val) && targetIsNA) return; // nada Ãºtil
        if (targetIsNA) {
            rows.push(`<tr>
                <td>${enhancedLabel}</td>
                <td>${Number.isFinite(val)?nf(val)+unit:'â€”'}</td>
                <td colspan="2" style="opacity:.55">N/A</td>
            </tr>`);
            return;
        }
        // ğŸ¯ CORRIGIDO: CÃ¡lculo de diferenÃ§a usando centerOfRange para ranges
        let diff = null;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max) && Number.isFinite(val)) {
            // Target Ã© um range: usar centro do range para cÃ¡lculo de delta
            const targetForDelta = centerOfRange(target);
            if (typeof targetForDelta === 'number' && Number.isFinite(targetForDelta)) {
                diff = val - targetForDelta;
            } else {
                // Fallback: distÃ¢ncia para o range
                const minNorm = Math.min(target.min, target.max);
                const maxNorm = Math.max(target.min, target.max);
                
                if (val >= minNorm - EPS && val <= maxNorm + EPS) {
                    diff = 0; // Dentro do range
                } else if (val < minNorm) {
                    diff = val - minNorm;
                } else {
                    diff = val - maxNorm;
                }
            }
        } else if (Number.isFinite(val) && Number.isFinite(target)) {
            // Target fixo: diferenÃ§a tradicional
            diff = val - target;
        } else {
            // ğŸ¯ Sem crash se target nÃ£o for vÃ¡lido
            diff = null;
        }
        
        // âœ… Sistema de 3 cores com epsilon
        let diffCell;
        if (!Number.isFinite(diff)) {
            // Sem dados vÃ¡lidos â†’ vermelho
            diffCell = '<td class="warn" style="text-align: center; padding: 8px;"><div style="font-size: 12px; font-weight: 600;">Corrigir</div></td>';
        } else if (tol === 0) {
            // LÃ³gica para bandas espectrais (tol=0)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= EPS) {
                // âœ… DENTRO DO RANGE â†’ Verde
                cssClass = 'ok';
                statusText = 'Ideal';
            } else if (absDiff <= 1.0 + EPS) {
                // âš ï¸ Fora por atÃ© 1dB â†’ Amarelo
                cssClass = 'yellow';
                statusText = 'Ajuste leve';
            } else if (absDiff <= 3.0 + EPS) {
                // âš ï¸ Fora por atÃ© 3dB â†’ Amarelo (era laranja)
                cssClass = 'yellow';
                statusText = 'Ajustar';
            } else {
                // âŒ Fora por >3dB â†’ Vermelho
                cssClass = 'warn';
                statusText = 'Corrigir';
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else if (!Number.isFinite(tol) || tol < 0) {
            // Fallback: tolerÃ¢ncia padrÃ£o com epsilon
            const defaultTol = 1.0;
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            console.warn(`âš ï¸ [TOLERANCE_FALLBACK] MÃ©trica "${label}" sem tolerÃ¢ncia vÃ¡lida (tol=${tol}). Usando tolerÃ¢ncia padrÃ£o: ${defaultTol}`);
            
            if (absDiff <= defaultTol + EPS) {
                // âœ… ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / defaultTol;
                if (multiplicador <= 2 + EPS) {
                    // âš ï¸ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // âŒ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else {
            // LÃ³gica padrÃ£o com epsilon (LUFS, TP, DR, etc.)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= tol + EPS) {
                // âœ… ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / tol;
                if (multiplicador <= 2 + EPS) {
                    // âš ï¸ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // âŒ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        }
        
        // ğŸ¯ NOVO: RenderizaÃ§Ã£o hÃ­brida para targets fixos e ranges
        let targetDisplay;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max)) {
            // Target Ã© um range: exibir "min dB a max dB"
            targetDisplay = `${nf(target.min)}${unit} a ${nf(target.max)}${unit}`;
        } else if (Number.isFinite(target)) {
            // Target Ã© um valor fixo: exibir "valor dB"
            targetDisplay = `${nf(target)}${unit}`;
        } else {
            // Target nÃ£o definido
            targetDisplay = 'N/A';
        }
        
        // Adicionar tolerÃ¢ncia se disponÃ­vel (apenas para targets fixos)
        const tolDisplay = (typeof target !== 'object' && tol != null) ? 
            `<span class="tol">Â±${nf(tol,2)}</span>` : '';
        
        rows.push(`<tr>
            <td>${enhancedLabel}</td>
            <td>${Number.isFinite(val)?nf(val)+unit:'â€”'}</td>
            <td>${targetDisplay}${tolDisplay}</td>
            ${diffCell}
        </tr>`);
    };
    // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ã£o de acesso para comparaÃ§Ã£o por referÃªncia
    const getMetricForRef = (metricPath, fallbackPath = null) => {
        // Prioridade: analysis.metrics > tech (technicalData) > fallback
        const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
        if (Number.isFinite(centralizedValue)) {
            // Log temporÃ¡rio para validaÃ§Ã£o
            if (typeof window !== 'undefined' && window.METRICS_REF_VALIDATION !== false) {
                const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
                if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                    console.warn(`ğŸ¯ REF_METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                }
            }
            return centralizedValue;
        }
        
        // Fallback para technicalData legado
        const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
        return Number.isFinite(legacyValue) ? legacyValue : null;
    };
    
    const getNestedValue = (obj, path) => {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    };
    
    // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ã£o de acesso para comparaÃ§Ã£o por referÃªncia
    // Usar somente mÃ©tricas reais (sem fallback para RMS/Peak, que tÃªm unidades e conceitos distintos)
    // FunÃ§Ã£o para obter o valor LUFS integrado usando mÃ©tricas centralizadas
    const getLufsIntegratedValue = () => {
        return getMetricForRef('lufs_integrated', 'lufsIntegrated');
    };
    
    // ğŸ§  NOVA PROTEÃ‡ÃƒO UNIVERSAL â€” Usa resolveTargetMetric para buscar referÃªncia real > gÃªnero
    const lufsTarget = resolveTargetMetric(analysis, "lufsIntegrated", -14);
    const tpTarget = resolveTargetMetric(analysis, "truePeakDbtp", -1);
    const drTarget = resolveTargetMetric(analysis, "dynamicRange", 8);
    const lraTarget = resolveTargetMetric(analysis, "lra", 6);
    const stereoTarget = resolveTargetMetric(analysis, "stereoCorrelation", 0.1);
    const spectralTarget = resolveTargetMetric(analysis, "spectralCentroidHz", null);
    
    // TolerÃ¢ncias ainda vÃªm de ref (ou padrÃ£o)
    const tolLufs = (ref && ref.tol_lufs !== undefined) ? ref.tol_lufs : 0.5;
    const tolTp = (ref && ref.tol_true_peak !== undefined) ? ref.tol_true_peak : 0.3;
    const tolDr = (ref && ref.tol_dr !== undefined) ? ref.tol_dr : 1.0;
    const tolLra = (ref && ref.tol_lra !== undefined) ? ref.tol_lra : 1.0;
    const tolStereo = (ref && ref.tol_stereo !== undefined) ? ref.tol_stereo : 0.08;
    const tolSpectral = (ref && ref.tol_spectral !== undefined) ? ref.tol_spectral : 300;
    
    console.log('ğŸ§  [RESOLVE-TARGETS] Targets universais resolvidos:', { 
        lufsTarget, tpTarget, drTarget, lraTarget, stereoTarget, spectralTarget 
    });
    
    // ADICIONAR TODAS AS MÃ‰TRICAS PRINCIPAIS
    pushRow('Loudness Integrado (LUFS)', getLufsIntegratedValue(), lufsTarget, tolLufs, ' LUFS');
    pushRow('Pico Real (dBTP)', getMetricForRef('true_peak_dbtp', 'truePeakDbtp'), tpTarget, tolTp, ' dBTP');
    pushRow('DR', getMetricForRef('dynamic_range', 'dynamicRange'), drTarget, tolDr, '');
    pushRow('Faixa de Loudness â€“ LRA (LU)', getMetricForRef('lra'), lraTarget, tolLra, ' LU');
    pushRow('Stereo Corr.', getMetricForRef('stereo_correlation', 'stereoCorrelation'), stereoTarget, tolStereo, '');
    
    // ğŸ¯ ADICIONAR SPECTRAL CENTROID SE MODO REFERÃŠNCIA (usa resolveTargetMetric)
    if (isReferenceMode && spectralTarget !== null) {
        pushRow('Centro Espectral (Hz)', getMetricForRef('spectral_centroid', 'spectralCentroidHz'), 
                spectralTarget, tolSpectral, ' Hz');
    }
    
    // Bandas detalhadas Fase 2: usar mÃ©tricas centralizadas para bandas
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = tech.bandEnergies || null;
    
    // ğŸ” DEBUG: Verificar estado das bandas e mapeamento
    console.log('ğŸ” [DEBUG_BANDS] Verificando bandas espectrais:', {
        MODE: renderMode.toUpperCase(),
        MODE_SOURCE: renderMode === 'genre' ? 'GENRE TARGETS' : 'REFERENCE ANALYSIS',
        hasCentralizedBands: !!centralizedBands,
        centralizedBandsKeys: centralizedBands ? Object.keys(centralizedBands) : [],
        hasLegacyBands: !!legacyBandEnergies,
        legacyBandsKeys: legacyBandEnergies ? Object.keys(legacyBandEnergies) : [],
        hasRefBands: !!ref.bands,
        refBandsKeys: ref.bands ? Object.keys(ref.bands) : [],
        refBandsSource: renderMode === 'genre' ? 'FROM __activeRefData (genre)' : 'FROM referenceAnalysis or referenceComparisonMetrics'
    });
    
    // ğŸ¯ MAPEAMENTO CORRIGIDO: Bandas Calculadas â†’ Bandas de ReferÃªncia
    const bandMappingCalcToRef = {
        // Banda calculada: chave na referÃªncia
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid', 
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho',
        // VariaÃ§Ãµes adicionais
        'low_bass': 'low_bass',
        'low_mid': 'low_mid',
        'high_mid': 'high_mid',
        'presenca': 'presenca',
        'brilho': 'brilho'
    };
    
    // ğŸ¯ MAPEAMENTO REVERSO: Bandas de ReferÃªncia â†’ Bandas Calculadas
    const bandMappingRefToCalc = {
        'sub': 'sub',
        'low_bass': 'bass',
        'upper_bass': 'bass', // ğŸ¯ NOVO: upper_bass â†’ bass
        'low_mid': 'lowMid',
        'mid': 'mid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // ğŸ¯ ALIAS DE BANDAS: Nomes alternativos para busca
    const bandAliases = {
        'bass': ['low_bass', 'upper_bass'],
        'lowMid': ['low_mid'],
        'highMid': ['high_mid'],
        'presence': ['presenca'],
        'air': ['brilho']
    };
    
    // ğŸ¯ NOVA LÃ“GICA: Priorizar bandas da nova estrutura em modo reference
    let bandsToUse, referenceBands;
    
    if (isReferenceMode && hasNewStructure && ref.bands) {
        // Usar bandas da referenceTrack.metrics.spectral_balance
        console.log('âœ… [RENDER-BANDS] Usando bandas da NOVA estrutura (referenceTrack)');
        referenceBands = ref.bands;
        bandsToUse = tech.spectral_balance || centralizedBands || legacyBandEnergies;
    } else {
        // Modo legado ou gÃªnero
        bandsToUse = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
        referenceBands = isReferenceMode && analysis.referenceComparison?.comparison?.spectralBands;
    }
    
    // ğŸ¯ RENDERIZAÃ‡ÃƒO DE BANDAS EM MODO REFERENCE
    if (isReferenceMode && hasNewStructure && ref.bands && bandsToUse) {
        console.log('âœ… [RENDER-REF-BANDS] Renderizando bandas com NOVA estrutura');
        
        const bandNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)',
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)'
        };
        
        // Iterar pelas bandas padrÃ£o
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            // Pegar valores do usuÃ¡rio
            const userBand = bandsToUse[band];
            const userValue = userBand?.percentage || userBand?.energy_db;
            
            // Pegar valores da referÃªncia
            const refBand = ref.bands[band];
            const refValue = refBand?.percentage || refBand?.energy_db;
            
            if (Number.isFinite(userValue) && Number.isFinite(refValue)) {
                pushRow(
                    bandNames[band] || band,
                    userValue,
                    refValue,
                    3.0, // TolerÃ¢ncia de 3% para bandas
                    '%'
                );
                
                console.log(`ğŸ“Š [BAND-${band}] User: ${userValue.toFixed(1)}% | Ref: ${refValue.toFixed(1)}%`);
            }
        });
    }
    // ğŸ¯ RENDERIZAÃ‡ÃƒO DE BANDAS COM ESTRUTURA ANTIGA (referenceComparison.comparison.spectralBands)
    else if (referenceBands && typeof referenceBands === 'object') {
        console.log('âš ï¸ [RENDER-REF-BANDS] Usando bandas de referenceComparison (estrutura antiga)');
        
        const bandNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)',
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)'
        };
        
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            if (referenceBands[band]) {
                const data = referenceBands[band];
                pushRow(
                    bandNames[band] || band,
                    data.user,
                    data.reference,
                    3.0,
                    data.unit
                );
            }
        });
    } 
    // ğŸµ RENDERIZAÃ‡ÃƒO DE BANDAS EM MODO GÃŠNERO
    else if (bandsToUse && ref.bands) {
        const normMap = (analysis?.technicalData?.refBandTargetsNormalized?.mapping) || null;
        const showNorm = (typeof window !== 'undefined' && window.SHOW_NORMALIZED_REF_TARGETS === true && normMap);
        
        // Mapeamento de nomes amigÃ¡veis para as bandas com ranges de frequÃªncia
        const bandDisplayNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)', 
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)',
            brilho: 'Air (10â€“20kHz)'
        };
        
        // ğŸ¯ PROCESSAMENTO CORRIGIDO: Iterar por bandas de referÃªncia e mapear para dados calculados
        console.log('ğŸ”„ Processando bandas com mapeamento corrigido...');
        
        // ğŸ›¡ï¸ FALLBACK: Verificar se ref.bands existe antes de iterar
        if (!ref.bands || typeof ref.bands !== 'object') {
            console.warn('âš ï¸ [REF-COMP] Fallback triggered (missing bands) - ref.bands nÃ£o existe');
            ref.bands = {}; // Criar objeto vazio para evitar erro
        }
        
        for (const [refBandKey, refBand] of Object.entries(ref.bands)) {
            // Encontrar a banda calculada correspondente
            const calcBandKey = bandMappingRefToCalc[refBandKey] || refBandKey;
            let bLocal = null;
            
            console.log(`ğŸ” [BANDS] Processando: ${refBandKey} â†’ ${calcBandKey}`);
            
            // ğŸ¯ NOVO: Busca melhorada com sistema de alias
            const searchBandData = (bandKey) => {
                // Buscar diretamente
                if (centralizedBands && centralizedBands[bandKey]) {
                    return { rms_db: centralizedBands[bandKey].energy_db, source: 'centralized' };
                }
                if (legacyBandEnergies && legacyBandEnergies[bandKey]) {
                    return { ...legacyBandEnergies[bandKey], source: 'legacy' };
                }
                
                // Buscar por alias
                if (bandAliases[bandKey]) {
                    for (const alias of bandAliases[bandKey]) {
                        if (centralizedBands && centralizedBands[alias]) {
                            console.log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias} (centralized)`);
                            return { rms_db: centralizedBands[alias].energy_db, source: 'centralized-alias' };
                        }
                        if (legacyBandEnergies && legacyBandEnergies[alias]) {
                            console.log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias} (legacy)`);
                            return { ...legacyBandEnergies[alias], source: 'legacy-alias' };
                        }
                    }
                }
                
                return null;
            };
            
            // Buscar dados da banda
            bLocal = searchBandData(calcBandKey);
            
            // Se nÃ£o encontrou, tentar busca direta pela chave de referÃªncia
            if (!bLocal) {
                bLocal = searchBandData(refBandKey);
                if (bLocal) {
                    console.log(`âš ï¸ [BANDS] Fallback para chave de referÃªncia: ${refBandKey}`);
                }
            }
            
            // ğŸ¯ TRATAMENTO SILENCIOSO: Ignorar bandas nÃ£o encontradas sem erro
            if (!bLocal || !Number.isFinite(bLocal.rms_db)) {
                console.log(`ğŸ”‡ [BANDS] Ignorando banda inexistente: ${refBandKey} / ${calcBandKey}`);
                continue; // Pular silenciosamente
            }
            
            // Banda encontrada - processar normalmente
            console.log(`âœ… [BANDS] Encontrado ${refBandKey}: ${bLocal.rms_db}dB (${bLocal.source})`);
            
            // Log de validaÃ§Ã£o entre sistemas
            if (typeof window !== 'undefined' && window.METRICS_BANDS_VALIDATION !== false && 
                bLocal.source === 'centralized' && legacyBandEnergies?.[calcBandKey]) {
                const legacyValue = legacyBandEnergies[calcBandKey].rms_db;
                if (Number.isFinite(legacyValue) && Math.abs(bLocal.rms_db - legacyValue) > 0.01) {
                    console.warn(`ğŸ¯ BAND_DIFF: ${calcBandKey} centralized=${bLocal.rms_db} vs legacy=${legacyValue}`);
                }
            }
            
            // ğŸ¯ NOVO: Determinar target e tolerÃ¢ncia com helpers
            let tgt = null;
            let tolerance = null;
            
            // Prioridade 1: target_range (usar helpers para formataÃ§Ã£o e tolerÃ¢ncia)
            if (refBand.target_range && typeof refBand.target_range === 'object' &&
                Number.isFinite(refBand.target_range.min) && Number.isFinite(refBand.target_range.max)) {
                tgt = refBand.target_range;
                // âœ… CORRIGIDO: Usar deriveTolerance() ao invÃ©s de 0
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`ğŸ¯ [BANDS-FORMAT] Usando target_range para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            // Prioridade 2: target_db fixo
            else if (!refBand._target_na && Number.isFinite(refBand.target_db)) {
                tgt = refBand.target_db;
                // âœ… CORRIGIDO: Usar deriveTolerance() com fallback
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`ğŸ¯ [BANDS-FORMAT] Usando target_db fixo para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            
            // Prioridade 3: Targets normalizados (se habilitado)
            if (showNorm && normMap && Number.isFinite(normMap[refBandKey])) {
                tgt = normMap[refBandKey];
                console.log(`ğŸ¯ [BANDS] Sobrescrevendo com target normalizado para ${refBandKey}: ${tgt}`);
            }
            
            // Nome para exibiÃ§Ã£o
            const displayName = bandDisplayNames[calcBandKey] || bandDisplayNames[refBandKey] || refBandKey;
            
            // âœ… CORRIGIDO: Usar centerOfRange para cÃ¡lculo de delta
            const targetCenter = centerOfRange(tgt) ?? tgt ?? null;
            console.log(`ğŸ“Š [BANDS] Adicionando: ${displayName}, valor: ${bLocal.rms_db}dB, target: ${formatTarget(tgt)}, tol: ${tolerance}`);
            
            // ğŸ¯ Passar targetCenter (nÃºmero) para cÃ¡lculo correto de delta em pushRow
            pushRow(displayName, bLocal.rms_db, tgt, tolerance, ' dB');
        }
        
        // ğŸ¯ PROCESSAMENTO DE BANDAS EXTRAS: Bandas calculadas que nÃ£o estÃ£o na referÃªncia
        console.log('ğŸ”„ Verificando bandas extras nÃ£o mapeadas...');
        
        if (bandsToUse) {
            Object.keys(bandsToUse).forEach(calcBandKey => {
                // Filtrar chaves invÃ¡lidas (totais, metadados etc.)
                if (calcBandKey === '_status' || 
                    calcBandKey === 'totalPercentage' || 
                    calcBandKey === 'totalpercentage' ||
                    calcBandKey === 'metadata' ||
                    calcBandKey === 'total' ||
                    calcBandKey.toLowerCase().includes('total')) {
                    return; // Pular esta banda
                }
                
                // Verificar se esta banda jÃ¡ foi processada
                const refBandKey = bandMappingCalcToRef[calcBandKey];
                const alreadyProcessed = refBandKey && ref.bands[refBandKey];
                
                if (!alreadyProcessed) {
                    console.log(`ğŸ” Processando banda extra: ${calcBandKey}`);
                    
                    const bandData = bandsToUse[calcBandKey];
                    let energyDb = null;
                    
                    if (typeof bandData === 'object' && Number.isFinite(bandData.energy_db)) {
                        energyDb = bandData.energy_db;
                    } else if (typeof bandData === 'object' && Number.isFinite(bandData.rms_db)) {
                        energyDb = bandData.rms_db;
                    } else if (Number.isFinite(bandData)) {
                        energyDb = bandData;
                    }
                    
                    if (Number.isFinite(energyDb)) {
                        const displayName = bandDisplayNames[calcBandKey] || 
                                          `${calcBandKey.charAt(0).toUpperCase() + calcBandKey.slice(1)} (Nova Banda)`;
                        
                        // Tentar buscar referÃªncia direta por chave
                        const directRefData = ref.bands?.[calcBandKey];
                        let target = null;
                        let tolerance = null;
                        
                        // [BANDS-TOL-0] Suporte hÃ­brido: target_range ou target_db (SEM TOLERÃ‚NCIA)
                        if (directRefData?.target_range && typeof directRefData.target_range === 'object' &&
                            Number.isFinite(directRefData.target_range.min) && Number.isFinite(directRefData.target_range.max)) {
                            target = directRefData.target_range;
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        } else if (Number.isFinite(directRefData?.target_db)) {
                            target = { min: directRefData.target_db, max: directRefData.target_db };
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        }
                        
                        console.log(`ğŸ“Š Adicionando banda extra: ${displayName}, valor: ${energyDb}dB, target: ${target || 'N/A'}`);
                        pushRow(displayName, energyDb, target, tolerance, ' dB');
                        
                        if (!target) {
                            console.warn(`âš ï¸ Banda sem referÃªncia: ${calcBandKey} (valor: ${energyDb}dB)`);
                        }
                    }
                }
            });
        }
    } else {
        // Fallback melhorado: buscar todas as bandas espectrais disponÃ­veis
        const spectralBands = tech.spectral_balance || 
                            tech.spectralBands || 
                            analysis.metrics?.bands || {};
        
        // ğŸ¯ MAPEAMENTO COMPLETO com correÃ§Ã£o de nomes
        const bandMap = {
            sub: { refKey: 'sub', name: 'Sub (20â€“60Hz)', range: '20â€“60Hz' },
            bass: { refKey: 'low_bass', name: 'Bass (60â€“150Hz)', range: '60â€“150Hz' },
            lowMid: { refKey: 'low_mid', name: 'Low-Mid (150â€“500Hz)', range: '150â€“500Hz' },
            mid: { refKey: 'mid', name: 'Mid (500â€“2kHz)', range: '500â€“2000Hz' },
            highMid: { refKey: 'high_mid', name: 'High-Mid (2â€“5kHz)', range: '2000â€“5000Hz' },
            presence: { refKey: 'presenca', name: 'Presence (5â€“10kHz)', range: '5000â€“10000Hz' },
            air: { refKey: 'brilho', name: 'Air (10â€“20kHz)', range: '10000â€“20000Hz' }
        };
        
        // ğŸ¯ NOVO PROCESSAMENTO MODE-AWARE com resolver
        console.log('ğŸ”„ Processando bandas espectrais (mode-aware resolver)...', {
            renderMode,
            hasRefBands: !!ref?.bands,
            refBandsKeys: ref?.bands ? Object.keys(ref.bands) : [],
            spectralBandsKeys: Object.keys(spectralBands),
            stateRefAnalysis: !!state?.reference?.analysis?.bands
        });
        
        if (spectralBands && Object.keys(spectralBands).length > 0) {
            // ğŸ¯ PATCH B: ExtraÃ§Ã£o de bandas mode-aware com bloqueio de fallback
            // isReferenceMode jÃ¡ definido no escopo superior
            
            let refBands = null;
            let userBands = null;
            
            if (isReferenceMode) {
                // 2Âª faixa: referÃªncia/alvo
                const refTech = opts?.referenceAnalysis?.technicalData
                             || state?.referenceAnalysis?.technicalData
                             || state?.reference?.referenceAnalysis?.technicalData
                             || referenceComparisonMetrics?.target
                             || referenceComparisonMetrics?.userFull?.technicalData /* legado confuso */ 
                             || null;
                
                // 1Âª faixa: base/origem
                const userTech = opts?.userAnalysis?.technicalData
                              || state?.userAnalysis?.technicalData
                              || state?.reference?.userAnalysis?.technicalData
                              || referenceComparisonMetrics?.analyzed
                              || referenceComparisonMetrics?.referenceFull?.technicalData /* legado confuso */
                              || null;
                
                // ğŸ” EXTRAÃ‡ÃƒO DE refBands com fallback seguro (NUNCA usar ranges de gÃªnero)
                refBands = refTech?.spectral_balance ||
                          opts?.referenceAnalysis?.bands ||
                          opts?.referenceAnalysis?.frequencyBands ||
                          state?.referenceAnalysis?.bands ||
                          state?.referenceAnalysis?.frequencyBands ||
                          null;
                
                userBands = userTech?.spectral_balance || null;
                
                console.log('[REF-FLOW] bands sources', {
                    userBands: !!userBands, 
                    refBands: !!refBands,
                    userBandsKeys: userBands ? Object.keys(userBands).slice(0, 5) : [],
                    refBandsKeys: refBands ? Object.keys(refBands).slice(0, 5) : []
                });
                
                if (!refBands) {
                    console.error("ğŸš¨ [REF-ERROR] Nenhum dado de bandas encontrado na referÃªncia.");
                    console.error('[CRITICAL] Reference mode sem bandas da 2Âª faixa! Abortando render.');
                    console.error('[CRITICAL] Proibido fallback de gÃªnero no reference mode');
                    if (container) {
                        container.innerHTML = '<div style="color:red;">âŒ Erro: bandas de referÃªncia nÃ£o disponÃ­veis</div>';
                    }
                    return;
                }
                
                console.log("âœ… [AUDIT_REF_FIX] referenceAnalysis spectral_balance pronto:", refBands);
            } else {
                // GENRE: aqui SIM usa ranges de __activeRefData
                refBands  = (__activeRefData && __activeRefData.bands) || null;
                userBands = (analysis?.technicalData?.spectral_balance) || spectralBands || null;
            }
            
            // Conjunto para rastrear bandas jÃ¡ processadas
            const processedBandKeys = new Set();
            
            // ğŸ¯ Iterar por todas as bandas do usuÃ¡rio
            const bandsToIterate = userBands || spectralBands;
            for (const rawKey of Object.keys(bandsToIterate)) {
                if (IGNORE_BANDS.has(rawKey) || processedBandKeys.has(rawKey)) continue;
                
                const bandKey = normalizeBandKey(rawKey);
                const userVal = pickNumeric(bandsToIterate[rawKey]);
                
                if (userVal === null) continue; // Sem valor do usuÃ¡rio
                
                let targetDisplay = 'â€”';
                let valueDisplay = 'â€”';
                let deltaDisplay = 'â€”';
                let targetValue = null;
                let tolDisplay = null;
                
                if (isReferenceMode) {
                    const refVal = getReferenceBandValue(refBands, bandKey); // retorna nÃºmero (dB) ou null
                    const userValCalc = getReferenceBandValue(userBands, bandKey);
                    
                    if (refVal == null) {
                        console.warn('[REF-FLOW] Banda sem valor na 2Âª faixa:', bandKey);
                        targetDisplay = 'â€”';
                        targetValue = null;
                    } else {
                        targetDisplay = formatDb(refVal);
                        targetValue = refVal;
                    }
                    
                    valueDisplay = (userValCalc == null) ? 'â€”' : formatDb(userValCalc);
                    deltaDisplay = (userValCalc == null || refVal == null) ? 'â€”' : formatDb(userValCalc - refVal);
                    tolDisplay = 0; // Sem tolerÃ¢ncia em comparaÃ§Ã£o direta
                    
                } else {
                    // GENRE: range do JSON de gÃªnero
                    const r = getGenreTargetRange(refBands, bandKey);
                    if (r) {
                        targetDisplay = `${formatDb(r.min)} a ${formatDb(r.max)}`;
                        targetValue = { min: r.min, max: r.max };
                        tolDisplay = r.tol;
                    } else {
                        targetDisplay = 'â€”';
                        targetValue = null;
                    }
                    valueDisplay = formatDb(userVal);
                    deltaDisplay = 'â€”'; // (delta numÃ©rico nÃ£o se aplica a range)
                }
                
                // ğŸ¯ Adicionar linha na tabela
                const label = bandMap[bandKey]?.name || `${bandKey.toUpperCase()}`;
                pushRow(label, userVal, targetValue, tolDisplay, ' dB');
                processedBandKeys.add(rawKey);
                processedBandKeys.add(bandKey);
            }
            
            console.log(`âœ… [BANDS-PROCESSED] ${processedBandKeys.size} bandas processadas no modo ${renderMode}`);
        } else {
            // Fallback para tonalBalance simplificado (mantido para compatibilidade)
            const tb = tech.tonalBalance || {};
            const legacyBandMap = { sub:'sub', low:'low_bass', mid:'mid', high:'brilho' };
            Object.entries(legacyBandMap).forEach(([tbKey, refBand]) => {
                const bData = tb[tbKey];
                const refBandData = ref.bands?.[refBand];
                if (bData && refBandData && Number.isFinite(bData.rms_db)) {
                    console.log(`ğŸ“Š Banda legacy: ${tbKey.toUpperCase()}, valor: ${bData.rms_db}dB, target: ${refBandData.target_db}dB`);
                    pushRow(`${tbKey.toUpperCase()}`, bData.rms_db, refBandData.target_db, refBandData.tol_db, ' dB');
                }
            });
        }
    }
    
    // ğŸ¯ LOG DE RESUMO: Bandas processadas com sucesso
    const bandasDisponiveis = ref.bands ? Object.keys(ref.bands).length : 0;
    const bandasProcessadas = rows.length - 5; // Subtrair mÃ©tricas bÃ¡sicas (LUFS, Peak, DR, LRA, Stereo)
    
    console.log('ğŸ“Š [BANDS] Resumo do processamento de bandas:', {
        bandas_na_referencia: bandasDisponiveis,
        bandas_processadas: Math.max(0, bandasProcessadas),
        metricas_totais: rows.length,
        centralized_bands_ok: !!centralizedBands,
        legacy_bands_ok: !!legacyBandEnergies,
        modo_referencia: isReferenceMode
    });
    
    // ğŸ¯ [A/B-TABLE-FIX] CORREÃ‡ÃƒO CRÃTICA: Renderizar tabela A/B com 2 colunas independentes
    // Modo REFERENCE: Extrair mÃ©tricas de userAnalysis (1Âª faixa) e referenceAnalysis (2Âª faixa)
    
    let abTableHTML = '';
    
    if (isReferenceMode && opts.userAnalysis && opts.referenceAnalysis) {
        console.log('ğŸ¯ [A/B-TABLE-FIX] Renderizando tabela A/B com 2 colunas independentes');
        
        const userTech = opts.userAnalysis.technicalData || {};
        const refTech = opts.referenceAnalysis.technicalData || {};
        
        // ğŸ¯ ASSERT CRÃTICO: Garantir que mÃ©tricas sÃ£o DIFERENTES
        if (userTech.lufsIntegrated === refTech.lufsIntegrated &&
            userTech.dynamicRange === refTech.dynamicRange &&
            userTech.truePeakDbtp === refTech.truePeakDbtp) {
            console.error('âŒ [A/B-TABLE-FIX] ERRO CRÃTICO: user/ref metrics IDÃŠNTICAS - DOM duplicado ou fonte errada!');
            console.table({
                'User LUFS': userTech.lufsIntegrated,
                'Ref LUFS': refTech.lufsIntegrated,
                'User DR': userTech.dynamicRange,
                'Ref DR': refTech.dynamicRange,
                'User Peak': userTech.truePeakDbtp,
                'Ref Peak': refTech.truePeakDbtp
            });
            container.innerHTML = '<div class="card" style="margin-top:12px;"><div style="color:red;padding:20px;">âŒ ERRO: MÃ©tricas idÃªnticas detectadas. Recarregue a pÃ¡gina.</div></div>';
            return;
        }
        
        // Helper format
        const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
        
        // ğŸ¯ Helper para calcular status e cor baseado na diferenÃ§a
        const getStatusAndColor = (diff, tolerance = 0.5) => {
            if (!Number.isFinite(diff)) {
                return { class: '', text: 'N/A', color: 'rgba(255,255,255,0.3)' };
            }
            
            const absDiff = Math.abs(diff);
            
            // LÃ³gica adaptativa baseada no tipo de mÃ©trica
            if (absDiff <= tolerance) {
                // âœ… IDEAL
                return { 
                    class: 'ok', 
                    text: 'Ideal',
                    icon: 'âœ…'
                };
            } else if (absDiff <= tolerance * 6) {
                // âš ï¸ AJUSTE LEVE
                return { 
                    class: 'yellow', 
                    text: 'Ajuste leve',
                    icon: 'âš ï¸'
                };
            } else {
                // âŒ CORRIGIR
                return { 
                    class: 'warn', 
                    text: 'Corrigir',
                    icon: 'âŒ'
                };
            }
        };
        
        // Construir linhas A/B com Delta e Status
        const abRows = [];
        
        const addABRow = (label, userVal, refVal, unit = '', dataMetric = '', tolerance = 0.5) => {
            const dataAttr = dataMetric ? ` data-metric="${dataMetric}"` : '';
            
            // Calcular diferenÃ§a (Faixa 1 - Faixa 2)
            let delta = null;
            let deltaText = 'â€”';
            
            if (Number.isFinite(userVal) && Number.isFinite(refVal)) {
                delta = userVal - refVal;
                const sign = delta > 0 ? '+' : '';
                deltaText = `${sign}${nf(delta)}${unit}`;
            }
            
            // Obter status e classe CSS
            const status = getStatusAndColor(delta, tolerance);
            
            abRows.push(`<tr${dataAttr}>
                <td class="metric-name">${label}</td>
                <td class="ab-user"${dataAttr}>${Number.isFinite(userVal) ? nf(userVal) + unit : 'â€”'}</td>
                <td class="ab-ref"${dataAttr}>${Number.isFinite(refVal) ? nf(refVal) + unit : 'â€”'}</td>
                <td class="delta-col">${deltaText}</td>
                <td class="status-col ${status.class}">
                    <div class="diff-cell-content">
                        <span class="diff-value">${status.icon}</span>
                        <span class="diff-status">${status.text}</span>
                    </div>
                </td>
            </tr>`);
        };
        
        // ===== MÃ‰TRICAS PRINCIPAIS =====
        addABRow('Loudness (LUFS)', userTech.lufsIntegrated, refTech.lufsIntegrated, ' LUFS', 'lufs', 0.5);
        addABRow('True Peak (dBTP)', userTech.truePeakDbtp, refTech.truePeakDbtp, ' dBTP', 'truepeak', 0.3);
        addABRow('Dynamic Range (LU)', userTech.dynamicRange, refTech.dynamicRange, ' LU', 'dr', 1.0);
        addABRow('LRA (LU)', userTech.lra, refTech.lra, ' LU', 'lra', 1.0);
        addABRow('Stereo Corr.', userTech.stereoCorrelation, refTech.stereoCorrelation, '', 'stereo', 0.08);
        
        // ===== BANDAS ESPECTRAIS =====
        const userBands = userTech.spectral_balance || {};
        const refBands = refTech.spectral_balance || {};
        
        const bandNames = {
            sub: 'Sub (20-60Hz)',
            bass: 'Bass (60-150Hz)',
            lowMid: 'Low-Mid (150-500Hz)',
            mid: 'Mid (500-2kHz)',
            highMid: 'High-Mid (2-5kHz)',
            presence: 'Presence (5-10kHz)',
            air: 'Air (10-20kHz)'
        };
        
        Object.entries(bandNames).forEach(([key, name]) => {
            const userVal = userBands[key]?.energy_db ?? userBands[key]?.percentage ?? userBands[key];
            const refVal = refBands[key]?.energy_db ?? refBands[key]?.percentage ?? refBands[key];
            if (Number.isFinite(userVal) || Number.isFinite(refVal)) {
                addABRow(name, userVal, refVal, ' dB', `band-${key}`, 1.0);
            }
        });
        
        // Nomes das faixas
        const userName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || '1Âª Faixa';
        const refName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || '2Âª Faixa';
        
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title" style="
                background: linear-gradient(90deg, #7F00FF, #00FFFF);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                font-size: clamp(15px, 1.3vw, 18px);
                font-weight: 700;
                margin-bottom: 12px;
            ">ğŸµ COMPARAÃ‡ÃƒO A/B ENTRE FAIXAS</div>
            
            <!-- Header com nomes das faixas - Compacto e elegante -->
            <div class="ab-header" style="
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 10px; 
                padding: 10px; 
                background: linear-gradient(90deg, rgba(127, 0, 255, 0.08), rgba(0, 255, 255, 0.08));
                border-radius: 8px; 
                margin-bottom: 10px;
                border: 1px solid rgba(127, 0, 255, 0.12);
            ">
                <div class="track-name user-track" style="
                    padding: 8px 10px;
                    background: rgba(82, 247, 173, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #52f7ad;
                    box-shadow: 0 2px 6px rgba(82, 247, 173, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">ğŸ§</span>
                        <span>Faixa 1</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${userName}</div>
                </div>
                <div class="track-name ref-track" style="
                    padding: 8px 10px;
                    background: rgba(255, 206, 77, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #ffce4d;
                    box-shadow: 0 2px 6px rgba(255, 206, 77, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">ğŸšï¸</span>
                        <span>Faixa 2</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${refName}</div>
                </div>
            </div>
            
            <!-- Tabela de comparaÃ§Ã£o - Refinada e compacta -->
            <table class="ref-compare-table ab-compare-table" style="width: 100%;">
                <thead>
                    <tr>
                        <th style="text-align: left; padding-left: 12px;">MÃ©trica</th>
                        <th class="ab-user-header">Faixa 1</th>
                        <th class="ab-ref-header">Faixa 2</th>
                        <th>Î”</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="ab-comparison-body">${abRows.join('')}</tbody>
            </table>
        </div>`;
        
        // ğŸ¯ LOG DE VALIDAÃ‡ÃƒO PÃ“S-RENDER
        console.group('ğŸ¯ [A/B-TABLE-VALIDATION] ValidaÃ§Ã£o pÃ³s-renderizaÃ§Ã£o');
        console.log('USER LUFS:', userTech.lufsIntegrated);
        console.log('REF LUFS:', refTech.lufsIntegrated);
        console.log('USER DR:', userTech.dynamicRange);
        console.log('REF DR:', refTech.dynamicRange);
        console.log('USER TruePeak:', userTech.truePeakDbtp);
        console.log('REF TruePeak:', refTech.truePeakDbtp);
        console.groupEnd();
        
    } else {
        // Modo GENRE ou fallback: usar tabela antiga
        console.warn('âš ï¸ [A/B-TABLE-FIX] Modo GENRE ou dados incompletos - usando tabela de referÃªncia padrÃ£o');
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title">COMPARAÃ‡ÃƒO DE REFERÃŠNCIA (${titleText})</div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>MÃ©trica</th><th>Valor</th><th>Alvo</th><th>Î”</th>
                </tr></thead>
                <tbody>${rows.join('') || '<tr><td colspan="4" style="opacity:.6">Sem mÃ©tricas disponÃ­veis</td></tr>'}</tbody>
            </table>
        </div>`;
    }
    
    container.innerHTML = abTableHTML;
    
    // ğŸ¯ FORÃ‡AR VISIBILIDADE DA TABELA EM AMBOS OS MODOS
    console.log('[UI_RENDER] ForÃ§ando renderizaÃ§Ã£o da tabela comparativa');
    const tableEl = document.getElementById('referenceComparisons');
    if (tableEl) {
        tableEl.classList.remove('hidden');
        tableEl.style.display = ''; // Limpa inline display:none
        tableEl.style.visibility = 'visible';
        tableEl.style.opacity = '1';
        console.log('âœ… [RENDER-REF] Tabela forÃ§ada para visÃ­vel (mode:', renderMode, ')');
        
        // ğŸ¯ [DOM-VALIDATION] ASSERT CRÃTICO: Verificar que elementos A/B sÃ£o DISTINTOS
        if (isReferenceMode) {
            setTimeout(() => {
                const userLufsEl = document.querySelector('.ab-user[data-metric="lufs"]');
                const refLufsEl = document.querySelector('.ab-ref[data-metric="lufs"]');
                
                console.group('ğŸ¯ [DOM-VALIDATION] VerificaÃ§Ã£o de elementos A/B');
                console.log('User LUFS Element:', userLufsEl);
                console.log('Ref LUFS Element:', refLufsEl);
                console.log('SÃ£o o mesmo elemento?', userLufsEl === refLufsEl);
                console.log('User LUFS innerHTML:', userLufsEl?.innerHTML);
                console.log('Ref LUFS innerHTML:', refLufsEl?.innerHTML);
                
                if (userLufsEl === refLufsEl) {
                    console.error('âŒ [DOM-VALIDATION] ERRO CRÃTICO: Elementos .ab-user e .ab-ref sÃ£o o MESMO objeto!');
                } else if (!userLufsEl || !refLufsEl) {
                    console.error('âŒ [DOM-VALIDATION] ERRO: Elementos nÃ£o encontrados no DOM!');
                } else {
                    console.log('âœ… [DOM-VALIDATION] Elementos A/B sÃ£o DISTINTOS e independentes');
                }
                console.groupEnd();
            }, 100);
        }
    } else {
        console.error('âŒ [RENDER-REF] Elemento #referenceComparisons NÃƒO encontrado no DOM!');
    }
    
    // ğŸ¯ Verificar se wrapper/parent tambÃ©m estÃ¡ visÃ­vel
    const wrapper = tableEl?.parentElement;
    if (wrapper) {
        wrapper.classList.remove('hidden');
        wrapper.classList.add('visible');
        wrapper.style.display = '';
    }
    
    // ğŸ›¡ï¸ PASSO 3: VERIFICAÃ‡ÃƒO FINAL
    console.log('ğŸ¯ [AUDITORIA_REF] ComparaÃ§Ã£o de referÃªncia renderizada com sucesso');
    console.log('ğŸ¯ [AUDITORIA_REF] Targets usados:', {
        lufs: lufsTarget,
        truePeak: tpTarget,
        dr: drTarget,
        lra: lraTarget,
        stereo: stereoTarget,
        totalRows: rows.length
    });
    
    // ğŸ¯ LOG FINAL DE SUCESSO COMPLETO
    console.log('âœ… [REF-COMP] renderReferenceComparisons SUCCESS', {
        mode: renderMode,
        usedReferenceAnalysis: !!analysis.referenceAnalysis,
        bandsResolved: ref.bands ? Object.keys(ref.bands).length : 0,
        rowsGenerated: rows.length,
        titleDisplayed: titleText,
        tableVisible: renderMode === 'reference'
    });
    
    // ğŸ¯ LOG FINAL DE VERIFICAÃ‡ÃƒO (conforme solicitado)
    console.log('[FINAL-CHECK] renderReferenceComparisons concluÃ­do com', {
        mode: renderMode,
        bands: Object.keys(ref?.bands || {}),
        bandsCount: Object.keys(ref?.bands || {}).length,
        tableVisible: !!document.querySelector('#referenceComparisons'),
        tableHasContent: rows.length > 0,
        userMetricsLoaded: !!userMetrics,
        refMetricsLoaded: !!ref,
        titleText: titleText
    });
    
    // âœ… DESBLOQUEIO DO MODAL - Finalizar loading e exibir resultados
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (loading) {
        loading.style.display = 'none';
        console.log('[MODAL-FIX] âœ… Loading ocultado');
    }
    
    if (results) {
        results.style.display = 'block';
        console.log('[MODAL-FIX] âœ… Resultados exibidos');
    }
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        console.log('[MODAL-FIX] âœ… Upload area ocultada');
    }
    
    console.log('[MODAL-FIX] âœ… Loading encerrado com sucesso - modal desbloqueado');
    
    // Estilos injetados uma vez com indicadores visuais melhorados
    if (!document.getElementById('refCompareStyles')) {
        const style = document.createElement('style');
        style.id = 'refCompareStyles';
        style.textContent = `
        .ref-compare-table{width:100%;border-collapse:collapse;font-size:11px;}
        .ref-compare-table th{font-weight:500;padding:4px 6px;border-bottom:1px solid rgba(255,255,255,.12);font-size:11px;color:#fff;letter-spacing:.3px;}
        .ref-compare-table th:first-child{text-align:left;}
        .ref-compare-table th:not(:first-child){text-align:center;}
        .ref-compare-table td{padding:5px 6px;border-bottom:1px solid rgba(255,255,255,.06);color:#f5f7fa;} 
        .ref-compare-table td:first-child{text-align:left;}
        .ref-compare-table td:not(:first-child){text-align:center;}
        .ref-compare-table tr:last-child td{border-bottom:0;} 
        .ref-compare-table td.ok{color:#52f7ad;font-weight:600;} 
        .ref-compare-table td.ok::before{content:'âœ… ';margin-right:2px;}
        .ref-compare-table td.yellow{color:#ffce4d;font-weight:600;} 
        .ref-compare-table td.yellow::before{content:'âš ï¸ ';margin-right:2px;}
        .ref-compare-table td.warn{color:#ff7b7b;font-weight:600;} 
        .ref-compare-table td.warn::before{content:'âŒ ';margin-right:2px;}
        .ref-compare-table .tol{opacity:.7;margin-left:4px;font-size:10px;color:#b8c2d6;} 
        .ref-compare-table tbody tr:hover td{background:rgba(255,255,255,.04);} 
        `;
        document.head.appendChild(style);
    }
    
    // ğŸ¯ ESTILOS DA TABELA CLÃSSICA DE GÃŠNERO
    if (!document.getElementById('classicGenreStyles')) {
        const genreStyle = document.createElement('style');
        genreStyle.id = 'classicGenreStyles';
        genreStyle.textContent = `
        .classic-genre-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .classic-genre-table th {
            font-weight: 600;
            padding: 6px 8px;
            border-bottom: 2px solid rgba(255,255,255,.15);
            font-size: 11px;
            color: #fff;
            text-align: left;
            letter-spacing: .5px;
            background: rgba(0,0,0,.2);
        }
        .classic-genre-table tbody tr {
            transition: background .2s ease;
        }
        .classic-genre-table tbody tr:hover {
            background: rgba(255,255,255,.05);
        }
        .classic-genre-table td {
            padding: 7px 8px;
            border-bottom: 1px solid rgba(255,255,255,.08);
            font-size: 11px;
        }
        .classic-genre-table tr:last-child td {
            border-bottom: 0;
        }
        
        /* ğŸ¯ CORES DE SEVERIDADE */
        .classic-genre-table .genre-row.ok {
            background: rgba(82, 247, 173, .05);
        }
        .classic-genre-table .genre-row.ok:hover {
            background: rgba(82, 247, 173, .12);
        }
        .classic-genre-table .genre-row.caution {
            background: rgba(255, 206, 77, .08);
        }
        .classic-genre-table .genre-row.caution:hover {
            background: rgba(255, 206, 77, .15);
        }
        .classic-genre-table .genre-row.warning {
            background: rgba(255, 165, 0, .1);
        }
        .classic-genre-table .genre-row.warning:hover {
            background: rgba(255, 165, 0, .18);
        }
        .classic-genre-table .genre-row.critical {
            background: rgba(255, 82, 82, .12);
        }
        .classic-genre-table .genre-row.critical:hover {
            background: rgba(255, 82, 82, .2);
        }
        
        /* ğŸ¯ COLUNAS ESPECÃFICAS */
        .classic-genre-table .metric-name {
            font-weight: 500;
            color: #e1e8f0;
        }
        .classic-genre-table .metric-value {
            font-weight: 600;
            color: #52f7ad;
            text-align: center;
        }
        .classic-genre-table .metric-target {
            color: #9ca9ba;
            text-align: center;
            font-size: 10px;
        }
        .classic-genre-table .metric-diff {
            text-align: center;
            font-weight: 600;
        }
        .classic-genre-table .metric-diff.positive {
            color: #ff8a80;
        }
        .classic-genre-table .metric-diff.negative {
            color: #80d8ff;
        }
        .classic-genre-table .metric-severity {
            text-align: center;
            font-weight: 700;
            font-size: 10px;
            letter-spacing: .8px;
        }
        .classic-genre-table .metric-severity.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-severity.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-severity.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-severity.critical {
            color: #ff5252;
        }
        .classic-genre-table .metric-action {
            text-align: center;
            font-size: 10px;
            font-weight: 500;
        }
        .classic-genre-table .metric-action.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-action.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-action.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-action.critical {
            color: #ff5252;
        }
        `;
        document.head.appendChild(genreStyle);
    }
    
    // Garantir que o CSS do priority-banner esteja disponÃ­vel no modal
    if (!document.getElementById('priorityBannerStyles')) {
        const priorityStyle = document.createElement('style');
        priorityStyle.id = 'priorityBannerStyles';
        priorityStyle.textContent = `
        .priority-banner {
            display: flex !important;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            font-weight: 700;
            background: linear-gradient(90deg, #ff006a, #ff9800) !important;
            color: #fff !important;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 106, 0.3);
            animation: pulsePriority 1.5s infinite alternate;
            position: relative;
            z-index: 10;
        }
        
        .priority-icon {
            font-size: 20px;
            line-height: 1;
        }
        
        @keyframes pulsePriority {
            from { opacity: 0.8; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1.02); }
        }
        `;
        document.head.appendChild(priorityStyle);
    }
    
    // ğŸ”“ CORREÃ‡ÃƒO CRÃTICA: Liberar comparisonLock ao final da renderizaÃ§Ã£o
    window.comparisonLock = false;
    console.log('[FIX-AUDIT] âœ… comparisonLock liberado apÃ³s renderizaÃ§Ã£o completa');
    console.log('[FIX-AUDIT] âœ… RenderReferenceComparisons auditado e restaurado com sucesso');
    console.log('[FIX-AUDIT] âœ… userBands e refBands preservadas');
    console.log('[FIX-AUDIT] âœ… Render completo no modo reference');
    console.log('[FIX-AUDIT] âœ… Cards e sugestÃµes renderizados apÃ³s comparaÃ§Ã£o');
    console.groupEnd(); // Fecha [SAFE_RENDER_REF]
    
    // ==== PATCH 2 FINAL: ValidaÃ§Ã£o e limpeza ====
    if (opts.usedReferenceAnalysis !== true) {
        console.error("[REF-PATCH] usedReferenceAnalysis caiu pra false â€” bug de wiring");
        throw new Error("Reference not used");
    }
    window.__refRenderInProgress = false;
}

// ğŸ”’ CÃ“PIA IMUTÃVEL DA FUNÃ‡ÃƒO ORIGINAL displayModalResults
// Esta cÃ³pia garante que interceptadores sempre tenham acesso Ã  funÃ§Ã£o original
if (!window.__displayModalResultsOriginal) {
    console.log('[FIX] ğŸ”’ Criando cÃ³pia imutÃ¡vel de displayModalResults');
    window.__displayModalResultsOriginal = displayModalResults;
    Object.freeze(window.__displayModalResultsOriginal);
    console.log('[FIX] âœ… CÃ³pia imutÃ¡vel criada: window.__displayModalResultsOriginal');
}

/**
 * ğŸ¯ RENDERIZAÃ‡ÃƒO DE COMPARAÃ‡ÃƒO ENTRE DUAS FAIXAS
 * Exibe tabela comparativa lado a lado: Faixa 1 (referÃªncia) vs Faixa 2 (usuÃ¡rio)
 * @param {Object} referenceAnalysis - Dados da primeira faixa (referÃªncia)
 * @param {Object} currentAnalysis - Dados da segunda faixa (usuÃ¡rio)
 */
function renderTrackComparisonTable(baseAnalysis, referenceAnalysis) {
    // ğŸ¯ PARÃ‚METROS CORRIGIDOS:
    // baseAnalysis = primeira faixa (alvo/base da comparaÃ§Ã£o)
    // referenceAnalysis = segunda faixa (atual/sendo comparada)
    
    console.log('ğŸ¯ [TRACK-COMPARE] Renderizando tabela comparativa entre faixas');
    console.log('ğŸ“Š [TRACK-COMPARE] Base (1Âª faixa - ALVO):', baseAnalysis);
    console.log('ğŸ“Š [TRACK-COMPARE] Atual (2Âª faixa - COMPARADA):', referenceAnalysis);
    
    // ğŸ¯ Definir modo reference no estado
    const state = window.__soundyState || {};
    state.render = state.render || {};
    state.render.mode = 'reference';
    console.log('âœ… [TRACK-COMPARE] Modo definido como reference no estado');
    
    // ğŸ¯ LOG AUDIT-MODE-FLOW (conforme solicitado)
    console.log('[AUDIT-MODE-FLOW]', {
        mode: state.render.mode,
        isSecondTrack: state.reference?.isSecondTrack,
        refJobId: state.reference?.jobId,
        hasRefAnalysis: !!state.reference?.analysis
    });
    
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('âŒ Container referenceComparisons nÃ£o encontrado');
        return;
    }
    
    // Normalizar dados de ambas as faixas
    // ref = primeira faixa (BASE/ALVO)
    // curr = segunda faixa (ATUAL/COMPARADA)
    const ref = normalizeBackendAnalysisData(baseAnalysis);
    const curr = normalizeBackendAnalysisData(referenceAnalysis);
    
    const refTech = ref.technicalData || {};
    const currTech = curr.technicalData || {};
    
    // Helper para comparar valores e calcular status
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
    const calcDiffPercent = (curr, ref) => {
        if (!Number.isFinite(curr) || !Number.isFinite(ref) || ref === 0) return null;
        return ((curr - ref) / Math.abs(ref)) * 100;
    };
    
    const getStatus = (diffPercent, tolerance = 10) => {
        if (diffPercent === null) return { class: '', text: 'N/A' };
        const absDiff = Math.abs(diffPercent);
        if (absDiff <= tolerance) return { class: 'ok', text: 'âœ… Ideal' };
        if (absDiff <= tolerance * 2) return { class: 'yellow', text: 'âš ï¸ Ajuste leve' };
        return { class: 'warn', text: 'âŒ Corrigir' };
    };
    
    // Construir linhas da tabela
    const rows = [];
    
    // FunÃ§Ã£o auxiliar para adicionar linha
    const addRow = (label, currVal, refVal, unit = '', tolerance = 10) => {
        const diffPercent = calcDiffPercent(currVal, refVal);
        const status = getStatus(diffPercent, tolerance);
        const diffText = diffPercent !== null ? `${diffPercent > 0 ? '+' : ''}${nf(diffPercent, 1)}%` : 'â€”';
        
        rows.push(`<tr>
            <td>${label}</td>
            <td>${Number.isFinite(currVal) ? nf(currVal) + unit : 'â€”'}</td>
            <td>${Number.isFinite(refVal) ? nf(refVal) + unit : 'â€”'}</td>
            <td>${diffText}</td>
            <td class="${status.class}">${status.text}</td>
        </tr>`);
    };
    
    // ===== MÃ‰TRICAS PRINCIPAIS =====
    addRow('Loudness (LUFS)', currTech.lufsIntegrated || currTech.lufs_integrated, 
           refTech.lufsIntegrated || refTech.lufs_integrated, ' LUFS', 5);
    
    addRow('True Peak (dBTP)', currTech.truePeakDbtp || currTech.true_peak_dbtp,
           refTech.truePeakDbtp || refTech.true_peak_dbtp, ' dBTP', 10);
    
    addRow('Dynamic Range (LU)', currTech.dynamicRange || currTech.dynamic_range,
           refTech.dynamicRange || refTech.dynamic_range, ' LU', 15);
    
    addRow('LRA (LU)', currTech.lra, refTech.lra, ' LU', 15);
    
    addRow('Stereo Correlation', currTech.stereoCorrelation || currTech.stereo_correlation,
           refTech.stereoCorrelation || refTech.stereo_correlation, '', 8);
    
    addRow('Spectral Centroid (Hz)', currTech.spectralCentroidHz || currTech.spectral_centroid,
           refTech.spectralCentroidHz || refTech.spectral_centroid, ' Hz', 10);
    
    // ===== BANDAS ESPECTRAIS =====
    const currBands = currTech.spectral_balance || {};
    const refBands = refTech.spectral_balance || {};
    
    const bandNames = {
        sub: 'Sub (20-60Hz)',
        bass: 'Bass (60-150Hz)',
        lowMid: 'Low-Mid (150-500Hz)',
        mid: 'Mid (500-2kHz)',
        highMid: 'High-Mid (2-5kHz)',
        presence: 'Presence (5-10kHz)',
        air: 'Air (10-20kHz)'
    };
    
    Object.entries(bandNames).forEach(([key, name]) => {
        const currVal = currBands[key]?.percentage;
        const refVal = refBands[key]?.percentage;
        if (Number.isFinite(currVal) && Number.isFinite(refVal)) {
            addRow(name, currVal, refVal, '%', 10);
        }
    });
    
    // Calcular scores comparativos
    const refScore = ref.score || 0;
    const currScore = curr.score || 0;
    const scoreDiff = currScore - refScore;
    
    // Montar HTML da tabela
    // ğŸ¯ LABELS DINÃ‚MICOS: Primeira faixa = BASE/ALVO, Segunda faixa = ATUAL
    container.innerHTML = `
        <div class="card" style="margin-top:12px;">
            <div class="card-title">ğŸµ COMPARAÃ‡ÃƒO ENTRE FAIXAS (Modo Reference)</div>
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 12px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA BASE (1Âª - ALVO)</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${ref.metadata?.fileName || ref.fileName || 'Primeira Faixa'}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: #52f7ad;">${nf(refScore, 0)}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA DE REFERÃŠNCIA (2Âª - ATUAL)</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${curr.metadata?.fileName || curr.fileName || 'Segunda Faixa'}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: ${scoreDiff >= 0 ? '#52f7ad' : '#ff7b7b'};">${nf(currScore, 0)}</span>
                            <span style="opacity: 0.7; margin-left: 4px;">(${scoreDiff > 0 ? '+' : ''}${nf(scoreDiff, 0)})</span>
                        </div>
                    </div>
                </div>
            </div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>MÃ©trica</th>
                    <th>Faixa 2 (Ref/Atual)</th>
                    <th>Faixa 1 (Base/Alvo)</th>
                    <th>DiferenÃ§a (%)</th>
                    <th>Status</th>
                </tr></thead>
                <tbody>${rows.join('')}</tbody>
            </table>
        </div>
    `;
    
    // ğŸ¯ AUDIT_REF_FIX: Log final de confirmaÃ§Ã£o do fluxo A/B
    // ğŸ”’ GUARD: SÃ³ executar logs de referÃªncia se viewMode === "reference"
    if (getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('âœ… [TRACK-COMPARE] Tabela comparativa renderizada com sucesso');
        console.log('[REFERENCE-A/B FIXED âœ…] ComparaÃ§Ã£o A/B entre faixas concluÃ­da');
        console.log('[AUDIT_REF_FIX] Tabela exibindo valores brutos da segunda faixa (referÃªncia real)');
        console.log('[MODE LOCKED] reference - renderizaÃ§Ã£o completa sem alteraÃ§Ã£o de modo');
        
        // ğŸ‰ LOG FINAL DE AUDITORIA
        console.log("âœ… [REFERENCE-A/B FIXED] ComparaÃ§Ã£o renderizada sem erros.");
        console.log("âœ… [AUDITORIA_FINAL_RENDER_REF] Render concluÃ­do com sucesso.");
    } else {
        console.log('[REFERENCE-GUARD] ğŸš« Logs de referÃªncia bloqueados (viewMode:', getViewMode(), ')');
    }
    
    // ğŸ¯ VALIDAÃ‡ÃƒO FINAL PÃ“S-FIX
    const validationData = {
        userTrack: ref.metadata?.fileName || ref.fileName || 'Primeira Faixa',
        refTrack: curr.metadata?.fileName || curr.fileName || 'Segunda Faixa',
        userLUFS: ref.technicalData?.lufsIntegrated || ref.technicalData?.lufs_integrated || 'N/A',
        refLUFS: curr.technicalData?.lufsIntegrated || curr.technicalData?.lufs_integrated || 'N/A',
        userDR: ref.technicalData?.dynamicRange || ref.technicalData?.dynamic_range || 'N/A',
        refDR: curr.technicalData?.dynamicRange || curr.technicalData?.dynamic_range || 'N/A',
        userPeak: ref.technicalData?.truePeakDbtp || ref.technicalData?.true_peak_dbtp || 'N/A',
        refPeak: curr.technicalData?.truePeakDbtp || curr.technicalData?.true_peak_dbtp || 'N/A',
        render: 'concluÃ­do sem erros'
    };
    
    console.log('âœ… [VALIDAÃ‡ÃƒO-FINAL] Modal Reference OK:', validationData);
    
    // âœ… Libera lock apÃ³s renderizaÃ§Ã£o
    window.comparisonLock = false;
    console.log("[LOCK] comparisonLock liberado");
    
    console.groupEnd();
}

// ğŸ¯ ===== SISTEMA DE SCORING AVANÃ‡ADO =====
// Sistema completo de pontuaÃ§Ã£o por categorias com adaptaÃ§Ã£o por gÃªnero

// 1. PESOS POR GÃŠNERO (ATUALIZADOS CONFORME ESPECIFICAÃ‡ÃƒO)
const GENRE_SCORING_WEIGHTS = {
    // Funk Mandela - Foco em Loudness e DinÃ¢mica
    'funk_mandela': {
        loudness: 0.32,    // Loudness crÃ­tico no funk
        dinamica: 0.23,    // DinÃ¢mica importante
        frequencia: 0.20,  // FrequÃªncia equilibrada
        estereo: 0.15,     // EstÃ©reo moderado
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Funk Automotivo (similar ao Mandela)
    'funk_automotivo': {
        loudness: 0.32,
        dinamica: 0.23,
        frequencia: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Trap/Trance - Foco em Loudness e FrequÃªncia
    'trap': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.20,     // EstÃ©reo importante
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    'trance': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.20,     // EstÃ©reo importante
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // EletrÃ´nico - Foco em FrequÃªncia e EstÃ©reo
    'eletronico': {
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.25,     // EstÃ©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Funk Bruxaria - Similar ao EletrÃ´nico
    'funk_bruxaria': {
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.25,     // EstÃ©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Hip Hop - Balanceado entre FrequÃªncia e DinÃ¢mica
    'hip_hop': {
        frequencia: 0.30,
        dinamica: 0.25,
        loudness: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Pesos padrÃ£o (fallback) - DistribuiÃ§Ã£o equilibrada
    'default': {
        loudness: 0.25,
        frequencia: 0.25,
        dinamica: 0.20,
        estereo: 0.15,
        tecnico: 0.15
    }
};

// 2. FUNÃ‡ÃƒO PARA CALCULAR SCORE DE UMA MÃ‰TRICA (VERSÃƒO MENOS PUNITIVA)
function calculateMetricScore(actualValue, targetValue, tolerance) {
    // Verificar se temos valores vÃ¡lidos
    if (!Number.isFinite(actualValue) || !Number.isFinite(targetValue) || !Number.isFinite(tolerance) || tolerance <= 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff: 'N/A (validaÃ§Ã£o falhou)',
                tolerance,
                result: null,
                condition: 'validaÃ§Ã£o falhou',
                reason: !Number.isFinite(actualValue) ? 'actualValue invÃ¡lido' : 
                        !Number.isFinite(targetValue) ? 'targetValue invÃ¡lido' : 
                        !Number.isFinite(tolerance) ? 'tolerance invÃ¡lido' : 
                        'tolerance <= 0'
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (validaÃ§Ã£o)', err);
        }
        return null; // MÃ©trica invÃ¡lida
    }
    
    const diff = Math.abs(actualValue - targetValue);
    
    // ğŸ¯ DENTRO DA TOLERÃ‚NCIA = 100 pontos
    if (diff <= tolerance) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff,
                tolerance,
                result: 100,
                condition: 'diff <= tolerance',
                ratio: diff / tolerance
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (dentro tolerÃ¢ncia)', err);
        }
        return 100;
    }
    
    // ğŸ¯ CURVA DE PENALIZAÃ‡ÃƒO MAIS JUSTA - GRADUAL E MENOS PUNITIVA
    // Î” atÃ© 1.5x tolerÃ¢ncia â†’ ~80
    // Î” atÃ© 2x tolerÃ¢ncia â†’ ~60  
    // Î” atÃ© 3x tolerÃ¢ncia â†’ ~40
    // Î” acima de 3x tolerÃ¢ncia â†’ ~20 (nunca zerar)
    
    const ratio = diff / tolerance;
    let result;
    
    if (ratio <= 1.5) {
        // Entre 1x e 1.5x tolerÃ¢ncia: decaimento suave de 100 para 80
        result = Math.round(100 - ((ratio - 1) * 40)); // 100 - (0.5 * 40) = 80 no mÃ¡ximo
    } else if (ratio <= 2.0) {
        // Entre 1.5x e 2x tolerÃ¢ncia: de 80 para 60
        result = Math.round(80 - ((ratio - 1.5) * 40)); // 80 - (0.5 * 40) = 60 no mÃ¡ximo
    } else if (ratio <= 3.0) {
        // Entre 2x e 3x tolerÃ¢ncia: de 60 para 40
        result = Math.round(60 - ((ratio - 2) * 20)); // 60 - (1 * 20) = 40 no mÃ¡ximo
    } else {
        // Acima de 3x tolerÃ¢ncia: 20 (nunca zerar totalmente)
        result = 20;
    }
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateMetricScore',
            value: actualValue,
            target: targetValue,
            diff,
            tolerance,
            result,
            condition: 'diff > tolerance',
            ratio,
            penaltyLevel: ratio <= 1.5 ? '1-1.5x' : ratio <= 2.0 ? '1.5-2x' : ratio <= 3.0 ? '2-3x' : '>3x'
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateMetricScore (penalizaÃ§Ã£o)', err);
    }
    
    return result;
}

// 3. CALCULAR SCORE DE LOUDNESS (LUFS, True Peak, Crest Factor)
function calculateLoudnessScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // LUFS Integrado (mÃ©trica principal de loudness)
    const lufsValue = metrics.lufs_integrated || tech.lufsIntegrated;
    if (Number.isFinite(lufsValue) && Number.isFinite(refData.lufs_target) && Number.isFinite(refData.tol_lufs)) {
        const score = calculateMetricScore(lufsValue, refData.lufs_target, refData.tol_lufs);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š LUFS: ${lufsValue} vs ${refData.lufs_target} (Â±${refData.tol_lufs}) = ${score}%`);
        }
    }
    
    // True Peak (importante para evitar clipping digital)
    const truePeakValue = metrics.true_peak_dbtp || tech.truePeakDbtp;
    if (Number.isFinite(truePeakValue) && Number.isFinite(refData.true_peak_target) && Number.isFinite(refData.tol_true_peak)) {
        const score = calculateMetricScore(truePeakValue, refData.true_peak_target, refData.tol_true_peak);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š True Peak: ${truePeakValue} vs ${refData.true_peak_target} (Â±${refData.tol_true_peak}) = ${score}%`);
        }
    }
    
    // Crest Factor (dinÃ¢mica de picos)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š Crest Factor: ${crestValue} vs ${refData.crest_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateLoudnessScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`ğŸ”Š Score Loudness Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateLoudnessScore',
            value: { lufs: metrics.lufs_integrated || tech.lufsIntegrated, truePeak: metrics.true_peak_dbtp || tech.truePeakDbtp, crest: tech.crestFactor || metrics.crest_factor },
            target: { lufs: refData.lufs_target, truePeak: refData.true_peak_target, crest: refData.crest_target },
            diff: 'ver logs individuais',
            tolerance: { lufs: refData.tol_lufs, truePeak: refData.tol_true_peak, crest: refData.tol_crest },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (final)', err);
    }
    
    return result;
}

// 4. CALCULAR SCORE DE DINÃ‚MICA (LRA, DR, Crest Consistency, Fator de Crista)
function calculateDynamicsScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // Dynamic Range (DR) - mÃ©trica principal de dinÃ¢mica
    const drValue = metrics.dynamic_range || tech.dynamicRange;
    if (Number.isFinite(drValue) && Number.isFinite(refData.dr_target) && Number.isFinite(refData.tol_dr)) {
        const score = calculateMetricScore(drValue, refData.dr_target, refData.tol_dr);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š Dynamic Range: ${drValue} vs ${refData.dr_target} (Â±${refData.tol_dr}) = ${score}%`);
        }
    }
    
    // LRA (Loudness Range) - variaÃ§Ã£o de loudness
    const lraValue = metrics.lra || tech.lra;
    if (Number.isFinite(lraValue) && Number.isFinite(refData.lra_target) && Number.isFinite(refData.tol_lra)) {
        const score = calculateMetricScore(lraValue, refData.lra_target, refData.tol_lra);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š LRA: ${lraValue} vs ${refData.lra_target} (Â±${refData.tol_lra}) = ${score}%`);
        }
    }
    
    // Crest Factor (jÃ¡ incluÃ­do em Loudness, mas importante para dinÃ¢mica tambÃ©m)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š Crest Factor (DinÃ¢mica): ${crestValue} vs ${refData.crest_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // CompressÃ£o detectada (se disponÃ­vel)
    const compressionRatio = tech.compressionRatio;
    if (Number.isFinite(compressionRatio) && refData.compression_target && Number.isFinite(refData.compression_target)) {
        const tolerance = refData.tol_compression || 1.0;
        const score = calculateMetricScore(compressionRatio, refData.compression_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š CompressÃ£o: ${compressionRatio} vs ${refData.compression_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateDynamicsScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`ğŸ“Š Score DinÃ¢mica Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateDynamicsScore',
            value: { dr: metrics.dynamic_range || tech.dynamicRange, lra: metrics.lra || tech.lra, crest: tech.crestFactor || metrics.crest_factor, compression: tech.compressionRatio },
            target: { dr: refData.dr_target, lra: refData.lra_target, crest: refData.crest_target, compression: refData.compression_target },
            diff: 'ver logs individuais',
            tolerance: { dr: refData.tol_dr, lra: refData.tol_lra, crest: refData.tol_crest, compression: refData.tol_compression },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (final)', err);
    }
    
    return result;
}

// 5. CALCULAR SCORE DE ESTÃ‰REO (Largura, CorrelaÃ§Ã£o, BalanÃ§o L/R)
function calculateStereoScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // CorrelaÃ§Ã£o EstÃ©reo (principal mÃ©trica de estÃ©reo)
    const stereoValue = metrics.stereo_correlation || tech.stereoCorrelation;
    if (Number.isFinite(stereoValue) && Number.isFinite(refData.stereo_target) && Number.isFinite(refData.tol_stereo)) {
        const score = calculateMetricScore(stereoValue, refData.stereo_target, refData.tol_stereo);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š CorrelaÃ§Ã£o EstÃ©reo: ${stereoValue} vs ${refData.stereo_target} (Â±${refData.tol_stereo}) = ${score}%`);
        }
    }
    
    // Largura EstÃ©reo (Width)
    const widthValue = tech.stereoWidth || metrics.stereo_width;
    if (Number.isFinite(widthValue) && refData.width_target && Number.isFinite(refData.width_target)) {
        const tolerance = refData.tol_width || 0.2;
        const score = calculateMetricScore(widthValue, refData.width_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š Largura EstÃ©reo: ${widthValue} vs ${refData.width_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // BalanÃ§o L/R (se disponÃ­vel)
    const balanceValue = tech.stereoBalance || metrics.stereo_balance;
    if (Number.isFinite(balanceValue)) {
        // BalanÃ§o ideal Ã© 0 (perfeitamente centrado)
        const balanceTarget = refData.balance_target || 0.0;
        const balanceTolerance = refData.tol_balance || 0.1; // 10% de tolerÃ¢ncia
        const score = calculateMetricScore(balanceValue, balanceTarget, balanceTolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š BalanÃ§o L/R: ${balanceValue} vs ${balanceTarget} (Â±${balanceTolerance}) = ${score}%`);
        }
    }
    
    // SeparaÃ§Ã£o de canais (se disponÃ­vel)
    const separationValue = tech.channelSeparation || metrics.channel_separation;
    if (Number.isFinite(separationValue) && refData.separation_target && Number.isFinite(refData.separation_target)) {
        const tolerance = refData.tol_separation || 5.0;
        const score = calculateMetricScore(separationValue, refData.separation_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`ğŸ“Š SeparaÃ§Ã£o de Canais: ${separationValue} vs ${refData.separation_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateStereoScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateStereoScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`ğŸ§ Score EstÃ©reo Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateStereoScore',
            value: { correlation: metrics.stereo_correlation || tech.stereoCorrelation, width: tech.stereoWidth || metrics.stereo_width, balance: tech.stereoBalance || metrics.stereo_balance, separation: tech.channelSeparation || metrics.channel_separation },
            target: { correlation: refData.stereo_target, width: refData.width_target, balance: refData.balance_target, separation: refData.separation_target },
            diff: 'ver logs individuais',
            tolerance: { correlation: refData.tol_stereo, width: refData.tol_width, balance: refData.tol_balance, separation: refData.tol_separation },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateStereoScore (final)', err);
    }
    
    return result;
}

// 6. CALCULAR SCORE DE FREQUÃŠNCIA (BANDAS ESPECTRAIS)
function calculateFrequencyScore(analysis, refData) {
    if (!analysis || !refData || !refData.bands) return null;
    
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;
    const bandsToUse = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
    
    if (!bandsToUse) return null;
    
    const scores = [];
    const isReferenceMode = refData._isReferenceMode === true;
    
    console.log('ğŸµ Calculando Score de FrequÃªncia...', {
        mode: isReferenceMode ? 'REFERENCE (valores diretos)' : 'GENRE (target_range)',
        bandsAvailable: Object.keys(refData.bands)
    });
    
    // Mapeamento das bandas calculadas para referÃªncia (exatamente as 7 bandas da tabela UI)
    const bandMapping = {
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid',
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho'
    };
    
    // Processar cada banda individualmente
    Object.entries(bandMapping).forEach(([calcBand, refBand]) => {
        // ğŸ¯ BUSCA EM CASCATA com ALIAS (branch imersao)
        const bandData = getBandDataWithCascade(calcBand, analysis);
        
        // ğŸ”‡ TRATAMENTO SILENCIOSO: ignorar bandas ausentes (branch imersao)
        if (!bandData || !Number.isFinite(bandData.energy_db)) {
            console.log(`ğŸ”‡ [SCORE-FREQ] Ignorando banda inexistente: ${calcBand}`);
            return; // âœ… continue silencioso
        }
        
        const refBandData = refData.bands[refBand];
        
        if (refBandData) {
            const energyDb = bandData.energy_db;
            
            console.log(`[SCORE-FREQ] âœ… ${calcBand}: ${energyDb.toFixed(2)} dB (${bandData.source})`);
            
            // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Detectar modo e usar valores apropriados
            let targetDb = null;
            let tolDb = null;
            
            if (isReferenceMode) {
                // ğŸ‘‰ MODO REFERENCE: Usar valor DIRETO da faixa de referÃªncia (nÃ£o target_range)
                if (typeof refBandData === 'object' && Number.isFinite(refBandData.energy_db)) {
                    targetDb = refBandData.energy_db;
                } else if (typeof refBandData === 'object' && Number.isFinite(refBandData.rms_db)) {
                    targetDb = refBandData.rms_db;
                } else if (Number.isFinite(refBandData)) {
                    targetDb = refBandData;
                }
                // Â±3 dB Ã© uma tolerÃ¢ncia auditiva/operacional razoÃ¡vel para bandas agregadas.
                tolDb = 3.0;
                
                if (targetDb !== null) {
                    console.log(`ğŸ¯ [SCORE-FREQ-REF] ${calcBand}: comparando com faixa de referÃªncia â†’ target=${targetDb.toFixed(1)}dB (valor real), tol=0dB`);
                } else {
                    console.warn(`âš ï¸ [SCORE-FREQ-REF] ${calcBand}: sem valor na faixa de referÃªncia`);
                }
            } else {
                // ğŸ‘‰ MODO GENRE: Usar target_range dos targets de gÃªnero
                if (refBandData.target_range && typeof refBandData.target_range === 'object' &&
                    Number.isFinite(refBandData.target_range.min) && Number.isFinite(refBandData.target_range.max)) {
                    // Novo sistema: calcular alvo e tolerÃ¢ncia a partir do range
                    targetDb = (refBandData.target_range.min + refBandData.target_range.max) / 2;
                    tolDb = (refBandData.target_range.max - refBandData.target_range.min) / 2;
                    console.log(`ğŸ¯ [SCORE-FREQ-GENRE] ${calcBand}: usando target_range [${refBandData.target_range.min}, ${refBandData.target_range.max}] â†’ target=${targetDb.toFixed(1)}dB, tol=${tolDb.toFixed(1)}dB`);
                } else if (Number.isFinite(refBandData.target_db) && Number.isFinite(refBandData.tol_db)) {
                    // Sistema legado
                    targetDb = refBandData.target_db;
                    tolDb = refBandData.tol_db;
                    console.log(`ğŸ¯ [SCORE-FREQ-GENRE] ${calcBand}: usando target_db=${targetDb}dB, tol_db=${tolDb}dB`);
                }
            }
            
            // Calcular score individual da banda
            if (Number.isFinite(targetDb) && Number.isFinite(tolDb)) {
                const score = calculateMetricScore(energyDb, targetDb, tolDb);
                if (score !== null) {
                    scores.push(score);
                    const delta = Math.abs(energyDb - targetDb);
                    const status = delta <= tolDb ? 'âœ…' : 'âŒ';
                    console.log(`ğŸµ ${calcBand.toUpperCase()}: ${energyDb.toFixed(1)}dB vs ${targetDb.toFixed(1)}dB (Â±${tolDb.toFixed(1)}dB) = ${score}% ${status}`);
                }
            }
        }
    });
    
    // Se nÃ£o encontrou scores vÃ¡lidos, retornar null
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateFrequencyScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0,
                isReferenceMode,
                bandsAvailable: refData.bands ? Object.keys(refData.bands) : []
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateFrequencyScore (no scores)', err);
        }
        return null;
    }
    
    // MÃ©dia aritmÃ©tica simples das bandas vÃ¡lidas
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    
    console.log(`ğŸµ Score FrequÃªncia Final: ${result}% (mÃ©dia de ${scores.length} bandas)`);
    console.log(`ğŸµ Scores individuais: [${scores.join(', ')}]`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateFrequencyScore',
            value: 'bandas espectrais (ver logs individuais)',
            target: 'bandas de referÃªncia',
            diff: 'ver logs individuais por banda',
            tolerance: isReferenceMode ? '0 (modo reference)' : 'target_range',
            result,
            condition: 'average of ' + scores.length + ' bands',
            individualScores: scores,
            average,
            isReferenceMode,
            bandsProcessed: scores.length
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateFrequencyScore (final)', err);
    }
    
    return result;
}

// 7. CALCULAR SCORE TÃ‰CNICO
// 7. CALCULAR SCORE TÃ‰CNICO (Clipping, DC Offset, THD)
function calculateTechnicalScore(analysis, refData) {
    if (!analysis) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    console.log('ğŸ”§ Calculando Score TÃ©cnico...');
    
    // 1. CLIPPING - Deve ser prÃ³ximo de 0% (PENALIZAÃ‡ÃƒO FORTE PARA PROBLEMAS CRÃTICOS)
    const clippingValue = tech.clipping || metrics.clipping || 0;
    if (Number.isFinite(clippingValue)) {
        let clippingScore = 100;
        
        if (clippingValue <= 0.001) { // â‰¤ 0.1% = perfeito
            clippingScore = 100;
        } else if (clippingValue <= 0.005) { // â‰¤ 0.5% = bom
            clippingScore = 80;
        } else if (clippingValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            clippingScore = 60;
        } else if (clippingValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            clippingScore = 40;
        } else { // > 2% = crÃ­tico
            clippingScore = 20;
        }
        
        scores.push(clippingScore);
        console.log(`ğŸ”§ Clipping: ${(clippingValue * 100).toFixed(3)}% = ${clippingScore}%`);
    }
    
    // 2. DC OFFSET - Deve ser prÃ³ximo de 0
    const dcOffsetValue = Math.abs(tech.dcOffset || metrics.dc_offset || 0);
    if (Number.isFinite(dcOffsetValue)) {
        let dcScore = 100;
        
        if (dcOffsetValue <= 0.001) { // â‰¤ 0.1% = perfeito
            dcScore = 100;
        } else if (dcOffsetValue <= 0.005) { // â‰¤ 0.5% = bom
            dcScore = 80;
        } else if (dcOffsetValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            dcScore = 60;
        } else if (dcOffsetValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            dcScore = 40;
        } else { // > 2% = crÃ­tico
            dcScore = 20;
        }
        
        scores.push(dcScore);
        console.log(`ğŸ”§ DC Offset: ${dcOffsetValue.toFixed(4)} = ${dcScore}%`);
    }
    
    // 3. THD (Total Harmonic Distortion) - Deve ser baixo
    const thdValue = tech.thd || metrics.thd || 0;
    if (Number.isFinite(thdValue)) {
        let thdScore = 100;
        
        if (thdValue <= 0.001) { // â‰¤ 0.1% = perfeito
            thdScore = 100;
        } else if (thdValue <= 0.005) { // â‰¤ 0.5% = bom
            thdScore = 80;
        } else if (thdValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            thdScore = 60;
        } else if (thdValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            thdScore = 40;
        } else { // > 2% = crÃ­tico
            thdScore = 20;
        }
        
        scores.push(thdScore);
        console.log(`ğŸ”§ THD: ${(thdValue * 100).toFixed(3)}% = ${thdScore}%`);
    }
    
    // 4. PROBLEMAS DETECTADOS (Issues) - PENALIZAÃ‡ÃƒO GRADUAL
    const issues = analysis.issues || [];
    let issuesScore = 100;
    
    issues.forEach(issue => {
        switch (issue.severity) {
            case 'critical':
                issuesScore = Math.max(20, issuesScore - 30); // NÃ£o zerar, mÃ­nimo 20
                console.log(`ğŸ”§ Issue CRÃTICO: ${issue.description} (-30%)`);
                break;
            case 'high':
                issuesScore = Math.max(40, issuesScore - 20); // MÃ­nimo 40
                console.log(`ğŸ”§ Issue ALTO: ${issue.description} (-20%)`);
                break;
            case 'medium':
                issuesScore = Math.max(60, issuesScore - 10); // MÃ­nimo 60
                console.log(`ğŸ”§ Issue MÃ‰DIO: ${issue.description} (-10%)`);
                break;
            case 'low':
                issuesScore = Math.max(80, issuesScore - 5); // MÃ­nimo 80
                console.log(`ğŸ”§ Issue BAIXO: ${issue.description} (-5%)`);
                break;
        }
    });
    
    if (issues.length > 0) {
        scores.push(issuesScore);
        console.log(`ğŸ”§ Issues Gerais: ${issuesScore}% (${issues.length} problemas)`);
    }
    
    // ğŸ¯ NOVA VALIDAÃ‡ÃƒO TRUE PEAK (CORREÃ‡ÃƒO CRÃTICA)
    const truePeak = tech.truePeakDbtp || metrics.truePeakDbtp;
    let truePeakScore = 100; // Score padrÃ£o se nÃ£o houver dados
    let hasTruePeakData = false;
    
    if (Number.isFinite(truePeak)) {
        hasTruePeakData = true;
        console.log(`ğŸ”§ True Peak: ${truePeak.toFixed(2)} dBTP`);
        
        if (truePeak <= -1.5) { // Excelente
            truePeakScore = 100;
            console.log(`ğŸ”§ True Peak EXCELENTE: ${truePeakScore}%`);
        } else if (truePeak <= -1.0) { // Ideal
            truePeakScore = 90;
            console.log(`ğŸ”§ True Peak IDEAL: ${truePeakScore}%`);
        } else if (truePeak <= -0.5) { // Bom
            truePeakScore = 80;
            console.log(`ğŸ”§ True Peak BOM: ${truePeakScore}%`);
        } else if (truePeak <= 0.0) { // AceitÃ¡vel
            truePeakScore = 70;
            console.log(`ğŸ”§ True Peak ACEITÃVEL: ${truePeakScore}%`);
        } else if (truePeak <= 0.5) { // ProblemÃ¡tico
            truePeakScore = 40;
            console.log(`ğŸ”§ True Peak PROBLEMÃTICO: ${truePeakScore}%`);
        } else { // CrÃ­tico
            truePeakScore = 20;
            console.log(`ğŸ”§ True Peak CRÃTICO: ${truePeakScore}%`);
        }
        
        scores.push(truePeakScore);
    }
    
    // Se nÃ£o temos mÃ©tricas tÃ©cnicas especÃ­ficas, usar apenas issues
    if (scores.length === 0) {
        const result = Math.max(20, Math.round(issuesScore)); // Nunca zerar
        console.log(`ğŸ”§ Score TÃ©cnico Final (apenas issues): ${result}%`);
        return result;
    }
    
    // MÃ©dia normalizada de todas as mÃ©tricas tÃ©cnicas (0-100)
    let average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    let result = Math.max(20, Math.round(average)); // Nunca zerar completamente
    
    // ğŸš¨ HARD CAP: True Peak ESTOURADO (> 0.0 dBTP) limita score a 60%
    if (hasTruePeakData && truePeak > 0.0) {
        const maxScoreWithClipping = 60;
        const originalResult = result;
        result = Math.min(result, maxScoreWithClipping);
        
        console.log(`ğŸš¨ HARD CAP APLICADO: True Peak estourado (${truePeak.toFixed(2)} dBTP)`);
        console.log(`ğŸš¨ Score limitado de ${originalResult}% para ${result}% (mÃ¡x: ${maxScoreWithClipping}%)`);
    }
    
    console.log(`ğŸ”§ Score TÃ©cnico Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas${hasTruePeakData ? ', True Peak incluÃ­do' : ''})`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateTechnicalScore',
            value: { clipping: tech.clipping || metrics.clipping, dcOffset: tech.dcOffset || metrics.dc_offset, thd: tech.thd || metrics.thd, truePeak: truePeak, issues: issues.length },
            target: 'valores ideais (0 para clipping/dc/thd, <0 para truePeak)',
            diff: 'N/A (avaliaÃ§Ã£o por faixas)',
            tolerance: 'N/A',
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average,
            hasTruePeakData,
            hardCapApplied: hasTruePeakData && truePeak > 0.0
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateTechnicalScore (final)', err);
    }
    
    return result;
}

// 8. FUNÃ‡ÃƒO PRINCIPAL: CALCULAR TODOS OS SCORES
function calculateAnalysisScores(analysis, refData, genre = null) {
    console.log('ğŸ¯ Calculando scores da anÃ¡lise...', { genre });
    
    // ğŸ¯ [FLOW-FIX] MÃ©tricas recebidas dentro de calculateAnalysisScores
    console.log("[FLOW-FIX] MÃ©tricas recebidas dentro de calculateAnalysisScores:", {
        loudness: analysis.loudness,
        metrics: analysis.metrics,
        technicalData: analysis.technicalData
    });
    
    // ğŸ¯ [GENRE-FIX] Targets finais entregues ao score
    console.log("[GENRE-FIX] Targets finais entregues ao score:", {
        lufs_target: refData?.lufs_target,
        true_peak_target: refData?.true_peak_target,
        dr_target: refData?.dr_target,
        stereo_target: refData?.stereo_target,
        lra_target: refData?.lra_target,
        bands: refData?.bands ? Object.keys(refData.bands) : null,
        bandsCount: refData?.bands ? Object.keys(refData.bands).length : 0
    });
    
    // ğŸ¯ MODO GÃŠNERO: Detectar se Ã© modo gÃªnero e se hÃ¡ targets carregados
    const isGenreMode = analysis?.mode === "genre" || 
                       window.__soundyState?.render?.mode === "genre" ||
                       (typeof getViewMode === 'function' && getViewMode() === "genre");
    
    // ğŸ¯ MODO GÃŠNERO: Extrair targets de gÃªnero de referenceComparison
    let genreTargetBands = null;
    let genreTargetMetrics = null;
    
    if (isGenreMode && analysis?.referenceComparison) {
        const refComp = analysis.referenceComparison;
        
        // Buscar em mÃºltiplos locais possÃ­veis (estrutura varia entre JSONs)
        const genreKey = genre || analysis.genre || analysis.genreId;
        const genreData = genreKey ? refComp[genreKey] : null;
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair bandas do ROOT primeiro
        if (genreData?.bands) {
            genreTargetBands = genreData.bands;
            console.log('âœ… [GENRE-TARGETS] Usando bands do ROOT (correto):', Object.keys(genreTargetBands));
        } else if (genreData?.legacy_compatibility?.bands) {
            genreTargetBands = genreData.legacy_compatibility.bands;
            console.log('âš ï¸ [GENRE-TARGETS] Usando legacy_compatibility.bands (fallback):', Object.keys(genreTargetBands));
        } else if (genreData?.hybrid_processing?.spectral_bands) {
            genreTargetBands = genreData.hybrid_processing.spectral_bands;
            console.log('âš ï¸ [GENRE-TARGETS] Usando hybrid_processing.spectral_bands (fallback):', Object.keys(genreTargetBands));
        } else if (refComp.bands) {
            genreTargetBands = refComp.bands;
            console.log('âš ï¸ [GENRE-TARGETS] Usando bands direto do refComp (fallback):', Object.keys(genreTargetBands));
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair mÃ©tricas escalares do ROOT primeiro
        if (genreData && genreData.lufs_target !== undefined) {
            // ROOT tem targets vÃ¡lidos (estrutura correta V2)
            genreTargetMetrics = {
                lufs_target: genreData.lufs_target,
                true_peak_target: genreData.true_peak_target,
                dr_target: genreData.dr_target,
                lra_target: genreData.lra_target,
                stereo_target: genreData.stereo_target,
                tol_lufs: genreData.tol_lufs || 1.0,
                tol_true_peak: genreData.tol_true_peak || 0.25,
                tol_dr: genreData.tol_dr || 1.25,
                tol_lra: genreData.tol_lra || 2.5,
                tol_stereo: genreData.tol_stereo || 0.065
            };
            console.log('âœ… [GENRE-TARGETS] MÃ©tricas extraÃ­das do ROOT (correto):', {
                lufs: genreTargetMetrics.lufs_target,
                peak: genreTargetMetrics.true_peak_target,
                dr: genreTargetMetrics.dr_target,
                stereo: genreTargetMetrics.stereo_target
            });
        } else if (genreData?.legacy_compatibility) {
            // Fallback: legacy_compatibility (estrutura antiga)
            const lc = genreData.legacy_compatibility;
            genreTargetMetrics = {
                lufs_target: lc.lufs_target,
                true_peak_target: lc.true_peak_target,
                dr_target: lc.dr_target,
                lra_target: lc.lra_target,
                stereo_target: lc.stereo_target,
                tol_lufs: lc.tol_lufs || 1.0,
                tol_true_peak: lc.tol_true_peak || 0.25,
                tol_dr: lc.tol_dr || 1.25,
                tol_lra: lc.tol_lra || 2.5,
                tol_stereo: lc.tol_stereo || 0.065
            };
            console.log('âš ï¸ [GENRE-TARGETS] MÃ©tricas extraÃ­das de legacy_compatibility (fallback)');
        } else if (genreData?.hybrid_processing?.original_metrics) {
            // Fallback 2: hybrid_processing (estrutura hÃ­brida)
            const om = genreData.hybrid_processing.original_metrics;
            genreTargetMetrics = {
                lufs_target: om.lufs_integrated,
                true_peak_target: om.true_peak_dbtp,
                dr_target: om.dynamic_range,
                lra_target: om.lra,
                stereo_target: om.stereo_correlation,
                tol_lufs: 1.0,
                tol_true_peak: 0.25,
                tol_dr: 1.25,
                tol_lra: 2.5,
                tol_stereo: 0.065
            };
            console.log('âš ï¸ [GENRE-TARGETS] MÃ©tricas extraÃ­das de hybrid_processing.original_metrics (fallback)');
        }
        
        // ğŸ¯ INJETAR targets de gÃªnero em refData se disponÃ­veis
        if (genreTargetBands && Object.keys(genreTargetBands).length > 0) {
            console.log('âœ… [GENRE-TARGETS] Injetando bandas de gÃªnero em refData');
            refData = {
                ...refData,
                bands: genreTargetBands,
                _isReferenceMode: false, // NÃƒO Ã© modo A/B
                _isGenreMode: true,
                _genreTargetsLoaded: true
            };
            
            // Mesclar mÃ©tricas se disponÃ­veis
            if (genreTargetMetrics) {
                refData = { ...refData, ...genreTargetMetrics };
            }
        } else {
            console.warn('âš ï¸ [GENRE-TARGETS] Targets de gÃªnero nÃ£o encontrados em referenceComparison');
        }
    }
    
    // ğŸ” [AUDIT-BANDS-IN-CALC] Log NO INÃCIO do cÃ¡lculo de scores
    try {
        const refBandsInCalc = refData?.bands || refData?._referenceBands;
        const userBandsInCalc = analysis?.bands || analysis?.technicalData?.spectral_balance || analysis?.metrics?.bands;
        console.log('[AUDIT-BANDS-IN-CALC]', {
            calcHasRefBands: !!refBandsInCalc,
            calcHasUserBands: !!userBandsInCalc,
            refBandsType: typeof refBandsInCalc,
            userBandsType: typeof userBandsInCalc,
            refBandsKeys: refBandsInCalc ? Object.keys(refBandsInCalc) : [],
            userBandsKeys: userBandsInCalc ? Object.keys(userBandsInCalc) : [],
            refBandsSample: refBandsInCalc ? Object.keys(refBandsInCalc).slice(0, 3) : 'undefined',
            userBandsSample: userBandsInCalc ? Object.keys(userBandsInCalc).slice(0, 3) : 'undefined',
            refDataKeys: refData ? Object.keys(refData) : [],
            isReferenceMode: refData?._isReferenceMode,
            isGenreMode: isGenreMode,
            genreTargetsLoaded: refData?._genreTargetsLoaded
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-CALC', err);
    }
    
    if (!analysis || !refData) {
        console.warn('âš ï¸ Dados insuficientes para calcular scores');
        return null;
    }
    
    // Calcular sub-scores
    const loudnessScore = calculateLoudnessScore(analysis, refData);
    const dynamicsScore = calculateDynamicsScore(analysis, refData);
    const stereoScore = calculateStereoScore(analysis, refData);
    const frequencyScore = calculateFrequencyScore(analysis, refData);
    const technicalScore = calculateTechnicalScore(analysis, refData);
    
    console.log('ğŸ“Š Sub-scores calculados:', {
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        estereo: stereoScore,
        frequencia: frequencyScore,
        tecnico: technicalScore
    });
    
    // Determinar pesos por gÃªnero
    // ğŸ¯ CORREÃ‡ÃƒO: NÃ£o usar 'default' como fallback, usar null
    const genreKey = genre ? genre.toLowerCase().replace(/\s+/g, '_') : null;
    
    if (!genreKey) {
        console.warn('[GET-BAND-LABEL] GÃªnero nÃ£o fornecido, usando label genÃ©rico');
    }
    const weights = GENRE_SCORING_WEIGHTS[genreKey] || GENRE_SCORING_WEIGHTS['default'];
    
    console.log('âš–ï¸ Pesos aplicados:', weights);
    
    // CORREÃ‡ÃƒO: Calcular score final com valores contÃ­nuos
    let weightedSum = 0;
    let totalWeight = 0;
    
    // Somar apenas os scores que existem, ajustando os pesos dinamicamente
    if (loudnessScore !== null) {
        weightedSum += loudnessScore * weights.loudness;
        totalWeight += weights.loudness;
    }
    
    if (dynamicsScore !== null) {
        weightedSum += dynamicsScore * weights.dinamica;
        totalWeight += weights.dinamica;
    }
    
    if (stereoScore !== null) {
        weightedSum += stereoScore * weights.estereo;
        totalWeight += weights.estereo;
    }
    
    if (frequencyScore !== null) {
        weightedSum += frequencyScore * weights.frequencia;
        totalWeight += weights.frequencia;
    }
    
    if (technicalScore !== null) {
        weightedSum += technicalScore * weights.tecnico;
        totalWeight += weights.tecnico;
    }
    
    // Calcular score final normalizado (permite valores contÃ­nuos como 67.3, depois arredonda)
    let finalScore = null;
    if (totalWeight > 0) {
        const rawFinalScore = weightedSum / totalWeight;
        finalScore = Math.round(rawFinalScore); // SÃ³ arredondar no final
    }
    
    const result = {
        final: finalScore,
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        frequencia: frequencyScore,
        estereo: stereoScore,
        tecnico: technicalScore,
        weights: weights,
        genre: genreKey
    };
    
    // ğŸ¯ LOG DE AUDITORIA: Verificar subscores apÃ³s correÃ§Ã£o
    console.log('[AUDIT-SCORES-FIX] Subscores depois da correÃ§Ã£o:', {
        loudness: result.loudness,
        dinamica: result.dinamica,
        estereo: result.estereo,
        frequencia: result.frequencia,
        tecnico: result.tecnico,
        final: result.final
    });
    
    console.log('ğŸ¯ Score final calculado:', result);
    
    // ğŸ¯ AUDIT_REF_FIX: Log final de confirmaÃ§Ã£o do fluxo A/B
    // ğŸ”’ GUARD: SÃ³ executar logs de referÃªncia se viewMode === "reference"
    if (refData._isReferenceMode === true && getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('[REFERENCE-A/B FIXED âœ…] ComparaÃ§Ã£o A/B concluÃ­da com sucesso');
        console.log('[AUDIT_REF_FIX] Bands carregadas da segunda mÃºsica (referÃªncia real)');
        console.log('[AUDIT_REF_FIX] ReferenceComparison gerado com dados A/B corretos');
    }
    
    // ğŸ¯ AUDIT LOG FINAL
    try {
        console.log('[AUDIT-FINAL-SCORES]', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            frequencia: result.frequencia,
            estereo: result.estereo,
            tecnico: result.tecnico,
            finalScore: result.final,
            weights: result.weights,
            genre: result.genre,
            weightedCalculation: {
                loudness: result.loudness !== null ? (result.loudness * result.weights.loudness) : 'N/A',
                dinamica: result.dinamica !== null ? (result.dinamica * result.weights.dinamica) : 'N/A',
                frequencia: result.frequencia !== null ? (result.frequencia * result.weights.frequencia) : 'N/A',
                estereo: result.estereo !== null ? (result.estereo * result.weights.estereo) : 'N/A',
                tecnico: result.tecnico !== null ? (result.tecnico * result.weights.tecnico) : 'N/A'
            },
            isReferenceMode: refData._isReferenceMode === true
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateAnalysisScores (final)', err);
    }
    
    return result;
}

// Recalcular apenas as sugestÃµes baseadas em referÃªncia (sem reprocessar o Ã¡udio)
function updateReferenceSuggestions(analysis) {
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Usar getActiveReferenceComparisonMetrics() para detectar targets corretamente
    const activeComparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasActiveComparisonMetrics = !!activeComparisonMetrics;
    
    console.log('ğŸ” [DEBUG-REF] updateReferenceSuggestions chamado:', {
        hasAnalysis: !!analysis,
        hasTechnicalData: !!analysis?.technicalData,
        hasActiveRefData: !!__activeRefData,
        hasReferenceComparisonMetrics: hasActiveComparisonMetrics, // âœ… CORRIGIDO: usa funÃ§Ã£o nova
        hasReferenceComparisonMetricsOLD: !!referenceComparisonMetrics, // âŒ ANTIGO (para comparaÃ§Ã£o)
        activeRefGenre: __activeRefGenre,
        activeRefDataKeys: __activeRefData ? Object.keys(__activeRefData) : null,
        currentGenre: window.PROD_AI_REF_GENRE,
        mode: analysis?.mode,
        activeComparisonMetricsSource: activeComparisonMetrics ? 'detected' : 'none'
    });
    
    if (!analysis || !analysis.technicalData) {
        console.warn('ğŸš¨ [DEBUG-REF] analysis ou technicalData ausentes');
        return;
    }
    
    // ğŸ¯ PRIORIDADE: Se temos comparaÃ§Ã£o entre faixas, usar referenceComparisonMetrics
    let targetMetrics = null;
    
    if (referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('âœ… [SUGGESTIONS] Usando referenceComparisonMetrics para sugestÃµes (comparaÃ§Ã£o entre faixas)');
        
        // Construir targetMetrics no formato esperado
        const refMetrics = referenceComparisonMetrics.reference;
        targetMetrics = {
            lufs_target: refMetrics.lufsIntegrated || refMetrics.lufs_integrated,
            true_peak_target: refMetrics.truePeakDbtp || refMetrics.true_peak_dbtp,
            dr_target: refMetrics.dynamicRange || refMetrics.dynamic_range,
            lra_target: refMetrics.lra,
            stereo_target: refMetrics.stereoCorrelation || refMetrics.stereo_correlation,
            spectral_centroid_target: refMetrics.spectralCentroidHz || refMetrics.spectral_centroid,
            bands: refMetrics.spectral_balance || null,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300
        };
        
        console.log('ğŸ“Š [SUGGESTIONS] Target metrics (2Âª faixa):', {
            lufs: targetMetrics.lufs_target,
            peak: targetMetrics.true_peak_target,
            dr: targetMetrics.dr_target
        });
        
        // Usar targetMetrics como __activeRefData temporariamente para compatibilidade
        __activeRefData = targetMetrics;
    }
    
    if (!__activeRefData) {
        console.warn('ğŸš¨ [DEBUG-REF] __activeRefData estÃ¡ null - tentando carregar gÃªnero atual');
        
        // Tentar carregar dados de referÃªncia do gÃªnero atual
        if (window.PROD_AI_REF_GENRE) {
            console.log('ğŸ”„ [DEBUG-REF] Tentando carregar dados para gÃªnero:', window.PROD_AI_REF_GENRE);
            loadReferenceData(window.PROD_AI_REF_GENRE).then(() => {
                console.log('âœ… [DEBUG-REF] Dados carregados, reprocessando sugestÃµes');
                updateReferenceSuggestions(analysis);
            }).catch(err => {
                console.error('âŒ [DEBUG-REF] Erro ao carregar dados:', err);
            });
        } else {
            // Tentar com dados de referÃªncia padrÃ£o embutidos
            console.log('ğŸ”„ [DEBUG-REF] Usando dados de referÃªncia embutidos');
            
            // Verificar se existem dados embutidos para o gÃªnero detectado nos scores
            if (analysis.scores && analysis.scores.genre) {
                const detectedGenre = analysis.scores.genre;
                console.log('ğŸ¯ [DEBUG-REF] GÃªnero detectado nos scores:', detectedGenre);
                
                // Usar dados embutidos se disponÃ­veis
                const embeddedRefs = {
                    eletrofunk: {
                        lufs_target: -8.3,
                        true_peak_target: -1,
                        dr_target: 10.1,
                        lra_target: 8.4,
                        stereo_target: 0.12,
                        bands: {
                            low_bass: { target_db: 13.3, tol_db: 2.36 },
                            low_mid: { target_db: 8.8, tol_db: 2.07 },
                            mid: { target_db: 2.5, tol_db: 1.81 },
                            high_mid: { target_db: -6.7, tol_db: 1.52 },
                            presenca: { target_db: -22.7, tol_db: 3.47 },
                            brilho: { target_db: -13.1, tol_db: 2.38 }
                        }
                    }
                };
                
                if (embeddedRefs[detectedGenre]) {
                    console.log('âœ… [DEBUG-REF] Usando dados embutidos para', detectedGenre);
                    __activeRefData = embeddedRefs[detectedGenre];
                    __activeRefGenre = detectedGenre;
                    // Continuar com o processamento
                } else {
                    console.warn('âŒ [DEBUG-REF] GÃªnero nÃ£o suportado nos dados embutidos:', detectedGenre);
                    return;
                }
            } else {
                console.warn('âŒ [DEBUG-REF] Nenhuma estratÃ©gia de recuperaÃ§Ã£o disponÃ­vel');
                return;
            }
        }
        
        // Se chegou atÃ© aqui sem return, __activeRefData foi definido pelos dados embutidos
        if (!__activeRefData) {
            return;
        }
    }
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Evitar duplicaÃ§Ã£o - resetar flag se chamado via applyGenreSelection
    if (analysis._suggestionsGenerated) {
        console.log('ğŸ¯ [SUGGESTIONS] Recalculando sugestÃµes para novo gÃªnero (resetando flag)');
        analysis._suggestionsGenerated = false;
    }
    
    // ğŸ¯ SISTEMA MELHORADO: Usar Enhanced Suggestion Engine quando disponÃ­vel
    if (typeof window !== 'undefined' && window.enhancedSuggestionEngine && window.USE_ENHANCED_SUGGESTIONS !== false) {
        try {
            console.log('ğŸ¯ Usando Enhanced Suggestion Engine...');
            
            // ğŸ¯ INTERCEPT CRÃTICO: Usar reference targets se modo for reference
            const state = window.__soundyState || {};
            let targetDataForEngine = __activeRefData;
            
            if (state.render?.mode === 'reference') {
                // Buscar dados da primeira faixa (referÃªncia) para usar como target
                const referenceBands = state.reference?.analysis?.technicalData?.spectral_balance
                    || state.reference?.analysis?.bands
                    || referenceComparisonMetrics?.referenceFull?.technicalData?.spectral_balance
                    || null;
                
                if (referenceBands) {
                    console.log('ï¿½ [ENGINE-INTERCEPT] Modo reference detectado - usando bandas da primeira faixa como target');
                    targetDataForEngine = {
                        ...(__activeRefData || {}),
                        bands: referenceBands,
                        _isReferenceMode: true,
                        _referenceSource: 'first_track'
                    };
                } else {
                    console.warn('âš ï¸ [ENGINE-INTERCEPT] Modo reference mas sem bandas - usando genreTargets (fallback)');
                }
            }
            
            console.log('ï¿½ğŸ” [DEBUG-ENGINE] Dados sendo passados para Enhanced Engine:', {
                mode: state.render?.mode,
                isReferenceMode: state.render?.mode === 'reference',
                analysis: {
                    hasTechnicalData: !!analysis.technicalData,
                    technicalDataKeys: analysis.technicalData ? Object.keys(analysis.technicalData) : null,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsCount: analysis.suggestions?.length || 0
                },
                targetDataForEngine: {
                    isNull: targetDataForEngine === null,
                    isUndefined: targetDataForEngine === undefined,
                    type: typeof targetDataForEngine,
                    keys: targetDataForEngine ? Object.keys(targetDataForEngine) : null,
                    structure: targetDataForEngine ? 'present' : 'missing',
                    hasBands: !!targetDataForEngine?.bands,
                    isReferenceMode: targetDataForEngine?._isReferenceMode
                }
            });
            
            const enhancedAnalysis = window.enhancedSuggestionEngine.processAnalysis(analysis, targetDataForEngine);
            
            // Preservar sugestÃµes nÃ£o-referÃªncia existentes se necessÃ¡rio
            const existingSuggestions = Array.isArray(analysis.suggestions) ? analysis.suggestions : [];
            const nonRefSuggestions = existingSuggestions.filter(s => {
                const type = s?.type || '';
                return !type.startsWith('reference_') && !type.startsWith('band_adjust') && !type.startsWith('heuristic_');
            });
            
            // Combinar sugestÃµes melhoradas com existentes preservadas
            analysis.suggestions = [...enhancedAnalysis.suggestions, ...nonRefSuggestions];
            
            // Adicionar mÃ©tricas melhoradas Ã  anÃ¡lise
            if (enhancedAnalysis.enhancedMetrics) {
                analysis.enhancedMetrics = enhancedAnalysis.enhancedMetrics;
            }
            
            // Adicionar log de auditoria
            if (enhancedAnalysis.auditLog) {
                analysis.auditLog = enhancedAnalysis.auditLog;
            }
            
            console.log(`ğŸ¯ [SUGGESTIONS] Enhanced Engine: ${enhancedAnalysis.suggestions.length} sugestÃµes geradas`);
            console.log(`ğŸ¯ [SUGGESTIONS] SugestÃµes preservadas: ${nonRefSuggestions.length}`);
            console.log(`ğŸ¯ [SUGGESTIONS] Total final: ${analysis.suggestions.length} sugestÃµes`);
            
            // ğŸ¤– NOVA CAMADA DE IA: PÃ³s-processamento inteligente de sugestÃµes (Enhanced Engine)
            if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
                try {
                    console.log('ğŸ¤– [AI-LAYER] Enriquecendo sugestÃµes do Enhanced Engine...');
                    
                    // Preparar contexto para IA
                    const aiContext = {
                        technicalData: analysis.technicalData,
                        genre: __activeRefGenre || analysis.genre,
                        referenceData: __activeRefData,
                        problems: analysis.problems,
                        enhancedMetrics: enhancedAnalysis.enhancedMetrics
                    };
                    
                    // Chamar IA de forma assÃ­ncrona
                    window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                        .then(enhancedSuggestions => {
                            if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                                // âœ… aplicar ordem garantida apÃ³s IA
                                enhancedSuggestions = window.enhancedSuggestionEngine
                                    .enforceOrderedSuggestions(enhancedSuggestions);

                                analysis.suggestions = enhancedSuggestions;
                                analysis._aiEnhanced = true;
                                analysis._aiTimestamp = new Date().toISOString();
                                analysis._aiSource = 'enhanced_engine';
                                
                                console.log(`ğŸ¤– [AI-LAYER] âœ… Enhanced Engine + IA: ${enhancedSuggestions.length} sugestÃµes`);
                                
                                // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Sempre mostrar interface IA
                                if (window.aiUIController) {
                                    console.log(`ğŸš€ [FORCE-AI-UI] ForÃ§ando exibiÃ§Ã£o da interface IA com ${enhancedSuggestions.length} sugestÃµes`);
                                    window.aiUIController.checkForAISuggestions(analysis);
                                }
                                
                                // Re-renderizar se modal visÃ­vel
                                if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                                    displayModalResults(analysis);
                                }
                            }
                        })
                        .catch(error => {
                            console.warn('ğŸ¤– [AI-LAYER] âŒ Erro na IA do Enhanced Engine:', error);
                            
                            // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Mostrar interface IA mesmo em caso de erro
                            setTimeout(() => {
                                if (window.aiUIController && analysis.suggestions) {
                                    console.log(`ğŸš€ [AI-UI-FORCE-ERROR] ForÃ§ando interface IA aparecer apÃ³s erro com ${analysis.suggestions.length} sugestÃµes`);
                                    window.aiUIController.checkForAISuggestions(analysis, true); // force = true
                                } else {
                                    console.warn('âš ï¸ [AI-UI-FORCE-ERROR] aiUIController nÃ£o encontrado ou sem sugestÃµes');
                                }
                            }, 100);
                        });
                } catch (error) {
                    console.warn('ğŸ¤– [AI-LAYER] âŒ Erro na integraÃ§Ã£o IA Enhanced Engine:', error);
                }
            }
            
            return;
            
        } catch (error) {
            console.warn('ğŸš¨ Erro no Enhanced Suggestion Engine, usando fallback:', error);
            // Continuar com sistema legado em caso de erro
        }
    }
    
    // ğŸ”„ SISTEMA LEGADO (fallback) - APENAS PARA SCORES, NÃƒO DEVE ALTERAR SUGESTÃ•ES
    console.log('ğŸ”„ [FALLBACK] Sistema legado ativado - usando apenas para calcular scores');
    
    // IMPORTANTE: NÃƒO modificar analysis.suggestions aqui para nÃ£o interferir com Enhanced Engine
    // Apenas calcular scores se necessÃ¡rio
    if (!analysis.scores && __activeRefData && analysis.technicalData) {
        try {
            analysis.scores = this.calculateFallbackScores(analysis.technicalData, __activeRefData);
            console.log('âœ… [FALLBACK] Scores calculados pelo sistema legado');
        } catch (error) {
            console.warn('âš ï¸ [FALLBACK] Erro ao calcular scores legados:', error);
        }
    }
    
    console.log('ğŸ¯ [FALLBACK] Sistema legado concluÃ­do sem alterar sugestÃµes');
    
    return; // âŒ SISTEMA LEGADO DESATIVADO - Enhanced Engine deve ser usado para sugestÃµes
    
    // ğŸ¤– NOVA CAMADA DE IA: PÃ³s-processamento inteligente de sugestÃµes
    // PONTO DE INTEGRAÃ‡ÃƒO SEGURO: ApÃ³s geraÃ§Ã£o de todas as sugestÃµes
    if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
        try {
            console.log('ğŸ¤– [AI-LAYER] Iniciando enriquecimento inteligente das sugestÃµes...');
            
            // Preparar contexto para IA
            const aiContext = {
                technicalData: analysis.technicalData,
                genre: __activeRefGenre || analysis.genre,
                referenceData: __activeRefData,
                problems: analysis.problems
            };
            
            // Chamar IA de forma assÃ­ncrona com fallback
            window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                .then(enhancedSuggestions => {
                    if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                        // âœ… aplicar ordem garantida apÃ³s IA
                        enhancedSuggestions = window.enhancedSuggestionEngine
                            .enforceOrderedSuggestions(enhancedSuggestions);

                        analysis.suggestions = enhancedSuggestions;
                        console.log(`ğŸ¤– [AI-LAYER] âœ… ${enhancedSuggestions.length} sugestÃµes enriquecidas com IA`);
                        
                        // Marcar que IA foi aplicada
                        analysis._aiEnhanced = true;
                        analysis._aiTimestamp = new Date().toISOString();
                        
                        // Re-renderizar modal se estiver visÃ­vel
                        if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                            console.log('ğŸ¨ [AI-LAYER] Re-renderizando modal com sugestÃµes IA');
                            displayModalResults(analysis);
                        }
                    } else {
                        console.warn('ğŸ¤– [AI-LAYER] âš ï¸ IA retornou resultado vazio, mantendo sugestÃµes originais');
                    }
                })
                .catch(error => {
                    console.warn('ğŸ¤– [AI-LAYER] âŒ Erro na camada de IA, mantendo sugestÃµes originais:', error);
                    // Sistema continua funcionando normalmente com sugestÃµes originais
                });
                
        } catch (error) {
            console.warn('ğŸ¤– [AI-LAYER] âŒ Erro na inicializaÃ§Ã£o da IA, sistema continua normal:', error);
        }
    } else {
        console.log('ğŸ¤– [AI-LAYER] Sistema de IA desabilitado ou nÃ£o disponÃ­vel');
    }
    
    // ğŸ›¡ï¸ Marcar que sugestÃµes foram geradas (proteÃ§Ã£o contra duplicaÃ§Ã£o)
    analysis._suggestionsGenerated = true;
}

/**
 * ğŸ”¢ Calcular scores bÃ¡sicos quando Enhanced Engine nÃ£o estÃ¡ disponÃ­vel
 * @param {Object} technicalData - Dados tÃ©cnicos da anÃ¡lise
 * @param {Object} referenceData - Dados de referÃªncia
 * @returns {Object} Scores calculados
 */
function calculateFallbackScores(technicalData, referenceData) {
    const scores = {};
    
    try {
        // Score LUFS
        if (Number.isFinite(technicalData.lufsIntegrated) && Number.isFinite(referenceData.lufs_target)) {
            const delta = Math.abs(technicalData.lufsIntegrated - referenceData.lufs_target);
            const tolerance = referenceData.tol_lufs || 2.0;
            scores.lufs = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score True Peak
        if (Number.isFinite(technicalData.truePeakDbtp)) {
            if (technicalData.truePeakDbtp > 0) {
                scores.truePeak = 0; // CrÃ­tico
            } else if (technicalData.truePeakDbtp > -1.0) {
                scores.truePeak = 5; // AceitÃ¡vel mas nÃ£o ideal
            } else {
                scores.truePeak = 10; // Ideal
            }
        }
        
        // Score DR
        if (Number.isFinite(technicalData.dynamicRange) && Number.isFinite(referenceData.dr_target)) {
            const delta = Math.abs(technicalData.dynamicRange - referenceData.dr_target);
            const tolerance = referenceData.tol_dr || 2.0;
            scores.dr = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score geral (mÃ©dia dos scores disponÃ­veis)
        const availableScores = Object.values(scores).filter(s => Number.isFinite(s));
        if (availableScores.length > 0) {
            scores.overall = availableScores.reduce((sum, score) => sum + score, 0) / availableScores.length;
        }
        
        console.log('ğŸ“Š [FALLBACK] Scores calculados:', scores);
        return scores;
        
    } catch (error) {
        console.error('âŒ [FALLBACK] Erro ao calcular scores:', error);
        return {};
    }
}

// ğŸ¨ Estilos do seletor de gÃªnero (injeÃ§Ã£o Ãºnica, nÃ£o quebra CSS existente)
function injectRefGenreStyles() {
    if (document.getElementById('refGenreEnhancedStyles')) return; // jÃ¡ injetado
    const style = document.createElement('style');
    style.id = 'refGenreEnhancedStyles';
    style.textContent = `
    #audioRefGenreContainer{position:relative;gap:10px;padding:6px 10px 4px 10px;border:1px solid rgba(255,255,255,.06);background:linear-gradient(145deg,#0c111b,#0d1321);border-radius:10px;box-shadow:0 2px 6px -2px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,0.02);}
    #audioRefGenreContainer label{font-weight:500;letter-spacing:.3px;color:#9fb3d9;margin-right:4px;}
    #audioRefGenreSelect{appearance:none;-webkit-appearance:none;-moz-appearance:none;position:relative;padding:6px 32px 6px 12px;font-size:12px;line-height:1.2;background:rgba(20,32,54,.7);color:#f4f7fb;border:1px solid #1e2b40;border-radius:8px;cursor:pointer;font-family:inherit;transition:border .25s, background .25s, box-shadow .25s;min-width:140px;}
    #audioRefGenreSelect:hover{background:rgba(28,44,76,.85);}
    #audioRefGenreSelect:focus{outline:none;border-color:#249dff;box-shadow:0 0 0 2px rgba(36,157,255,.3);}
    #audioRefGenreSelect:active{transform:translateY(1px);} 
    #audioRefGenreContainer::after{content:"";position:absolute;top:13px;left: calc(10px + 140px);pointer-events:none;}
    #audioRefGenreContainer .select-wrap{position:relative;}
    /* Seta custom */
    #audioRefGenreContainer .select-wrap:after{content:"";position:absolute;right:12px;top:50%;width:7px;height:7px;border-right:2px solid #9fb3d9;border-bottom:2px solid #9fb3d9;transform:translateY(-60%) rotate(45deg);pointer-events:none;transition:transform .25s,border-color .25s;}
    #audioRefGenreSelect:focus + .arrow, #audioRefGenreContainer .select-wrap:focus-within:after{border-color:#53c2ff;}
    #audioRefStatus{font-size:11px;font-weight:500;letter-spacing:.4px;padding:4px 10px;border-radius:7px;background:#0d6efd;color:#fff;display:inline-flex;align-items:center;gap:6px;box-shadow:0 0 0 1px rgba(255,255,255,.06),0 2px 4px -1px rgba(0,0,0,.7);}
    #audioRefStatus::before{content:"";width:7px;height:7px;border-radius:50%;background:#3df29b;box-shadow:0 0 0 3px rgba(61,242,155,.25);} 
    #audioRefGenreContainer.dark #audioRefStatus{background:#14324f;}
    @media (max-width:600px){#audioRefGenreContainer{padding:6px 8px 4px 8px;gap:6px;}#audioRefGenreSelect{min-width:120px;padding:6px 28px 6px 10px;}}
    `;
    // Wrap opcional para setinha sem mexer HTML: inserir span ao redor do select
    const select = document.getElementById('audioRefGenreSelect');
    if (select && !select.parentElement.classList.contains('select-wrap')) {
        const wrap = document.createElement('div');
        wrap.className = 'select-wrap';
        wrap.style.position = 'relative';
        select.parentNode.insertBefore(wrap, select);
        wrap.appendChild(select);
    }
    document.head.appendChild(style);
}

// ğŸ¨ Estilos do Modal de GÃªnero Musical - Glassmorphism + Glitch
function injectGenreModalStyles() {
    if (document.getElementById('genreModalStyles')) return; // jÃ¡ injetado
    const style = document.createElement('style');
    style.id = 'genreModalStyles';
    style.textContent = `
    /* ğŸµ Novo Modal de GÃªnero Musical - Glassmorphism */
    .genre-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        z-index: 10000;
        opacity: 1;
        transition: opacity 0.3s ease;
    }

    .genre-modal.hidden {
        display: none;
        opacity: 0;
    }

    .genre-modal-container {
        max-width: 720px;
        width: 90%;
        max-height: 90vh;
        background: radial-gradient(
    circle at 20% 20%, 
    rgba(93, 21, 134, 0.85) 0%,       /* Roxo vibrante no canto */
    rgba(0, 0, 0, 0.95) 60%,          /* Preto no centro */
    rgba(0, 102, 255, 0.4) 100%       /* Azul elÃ©trico nas bordas */
);
backdrop-filter: blur(8px);
box-shadow: 0 0 30px rgba(93, 21, 134, 0.4),
            0 0 60px rgba(0, 102, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        padding: 40px 32px 32px 32px;
        text-align: center;
        position: relative;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        box-shadow: 
            0 20px 40px rgba(91, 11, 156, 0.49),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: scale(1);
        transition: transform 0.2s ease;
        overflow: hidden;
    }

    /* LINHAS NEURAIS VANTA - FUNDO TECH */
    .genre-modal-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 40px,
                rgba(106, 154, 255, 0.03) 40px,
                rgba(106, 154, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 40px,
                rgba(106, 0, 255, 0.03) 40px,
                rgba(106, 0, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 60px,
                rgba(0, 212, 255, 0.02) 60px,
                rgba(0, 212, 255, 0.02) 61px
            );
        opacity: 0.6;
        animation: neural-grid-genre 15s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    /* PartÃ­culas flutuantes */
    .genre-modal-container::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background-image: 
            radial-gradient(circle, rgba(106, 0, 255, 0.15) 1px, transparent 1px),
            radial-gradient(circle, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
        background-size: 50px 50px, 80px 80px;
        background-position: 0 0, 25px 25px;
        animation: particles-float-genre 20s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    @keyframes neural-grid-genre {
        0% {
            transform: translate(0, 0);
            opacity: 0.6;
        }
        50% {
            opacity: 0.4;
        }
        100% {
            transform: translate(40px, 40px);
            opacity: 0.6;
        }
    }

    @keyframes particles-float-genre {
        0% {
            transform: translate(0, 0) rotate(0deg);
        }
        100% {
            transform: translate(50px, 50px) rotate(360deg);
        }
    }

    /* Garante que conteÃºdo fica acima do fundo neural */
    .genre-modal-container > * {
        position: relative;
        z-index: 5;
    }

    /* TÃ­tulo com efeito glitch - Paleta roxo escuro + azul ciano */
    .genre-modal-title {
        font-family: 'Orbitron', 'Rajdhani', 'Montserrat Alternates', sans-serif;
        font-size: 2.2rem;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        margin-bottom: 12px;
        position: relative;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 
            0 0 12px rgba(0, 212, 255, 0.4),
            0 0 24px rgba(108, 0, 162, 0.2),
            0 0 40px rgba(0, 212, 255, 0.15);
    }

    .genre-modal-title.glitch::before,
    .genre-modal-title.glitch::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.85;
        pointer-events: none;
    }

    /* PARTE SUPERIOR â€” Roxo escuro */
    .genre-modal-title.glitch::before {
        color: #6c00a2;
        animation: glitch-1 2s infinite alternate-reverse;
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }

    /* PARTE INFERIOR â€” Azul ciano */
    .genre-modal-title.glitch::after {
        color: #00d4ff;
        animation: glitch-2 3s infinite alternate-reverse;
        clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }

    @keyframes glitch-1 {
        0% { transform: translateX(-2px); }
        100% { transform: translateX(2px); }
    }

    @keyframes glitch-2 {
        0% { transform: translateX(2px); }
        100% { transform: translateX(-2px); }
    }

    .genre-modal-subtitle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 1rem;
        margin-bottom: 32px;
        font-weight: 400;
    }

    /* Grid de gÃªneros */
    .genre-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 32px;
    }

    /* ğŸ”§ CORREÃ‡ÃƒO FLASH BRANCO: Estado inicial explÃ­cito */
    .genre-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px 16px;
        
        /* Estado base: exatamente o visual glass atual */
        background: rgba(255, 255, 255, 0.05);
        background-color: transparent; /* Evita herdar branco do user-agent */
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        color: #ffffff;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        
        /* âŒ NÃƒO animar background - sÃ³ transform, box-shadow, border-color, opacity */
        transition: 
            transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            opacity 0.25s ease;
        
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        
        /* Zera estilos nativos se for <button> */
        -webkit-appearance: none;
        appearance: none;
    }

    /* Prepaint: cards invisÃ­veis enquanto CSS assenta */
    .genre-modal.prepaint .genre-card {
        opacity: 0;
    }

    .genre-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.1), 
            transparent);
        transition: left 0.6s ease;
    }

    .genre-card:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(36, 157, 255, 0.4);
        transform: scale(1.05) translateY(-2px);
        box-shadow: 
            0 10px 25px rgba(0, 0, 0, 0.4),
            0 0 0 1px rgba(36, 157, 255, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .genre-card:hover::before {
        left: 100%;
    }

    .genre-card:active {
        transform: scale(0.98) translateY(1px);
    }

    .genre-icon {
        font-size: 2rem;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
    }

    .genre-name {
        font-weight: 700;
        letter-spacing: 0.5px;
    }

    /* BotÃ£o fechar */
    .genre-modal-close {
        background: rgba(255, 255, 255, 0.08);
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 0.9rem;
        cursor: pointer;
        /* âŒ NÃƒO animar background */
        transition: 
            border-color 0.2s ease,
            color 0.2s ease,
            opacity 0.2s ease;
        font-weight: 500;
        -webkit-appearance: none;
        appearance: none;
    }

    .genre-modal-close:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.4);
    }

    /* Responsividade */
    @media (max-width: 768px) {
        .genre-modal-container {
            width: 95%;
            padding: 32px 20px 24px 20px;
        }

        .genre-modal-title {
            font-size: 1.8rem;
        }

        .genre-grid {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .genre-card {
            padding: 16px 12px;
            gap: 8px;
        }

        .genre-icon {
            font-size: 1.5rem;
        }

        .genre-name {
            font-size: 0.85rem;
        }
    }

    @media (max-width: 480px) {
        .genre-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .genre-card {
            padding: 14px 10px;
        }
    }
    `;
    document.head.appendChild(style);
}

// ğŸ¤– Enviar anÃ¡lise para chat
window.sendModalAnalysisToChat = async function sendModalAnalysisToChat() {
    __dbg('ğŸ¯ BOTÃƒO CLICADO: Pedir Ajuda Ã  IA');
    
    if (!currentModalAnalysis) {
        alert('Nenhuma anÃ¡lise disponÃ­vel');
        __dbg('âŒ Erro: currentModalAnalysis nÃ£o existe');
        return;
    }
    
    __dbg('ğŸ¤– Enviando anÃ¡lise para chat...', currentModalAnalysis);
    
    try {
        // Gerar prompt personalizado baseado nos problemas encontrados
        const prompt = window.audioAnalyzer.generateAIPrompt(currentModalAnalysis);
        const message = `ğŸµ Analisei meu Ã¡udio e preciso de ajuda para melhorar. Aqui estÃ£o os dados tÃ©cnicos:\n\n${prompt}`;
        
        __dbg('ğŸ“ Prompt gerado:', message.substring(0, 200) + '...');
        
        // Tentar diferentes formas de integrar com o chat
        let messageSent = false;
        
        // MÃ©todo 1: Usar diretamente o ProdAI Chatbot quando disponÃ­vel
        if (window.prodAIChatbot) {
            __dbg('ğŸ¯ Tentando enviar via ProdAI Chatbot...');
            try {
                // Se o chat ainda nÃ£o estÃ¡ ativo, ativar com a mensagem
                if (!window.prodAIChatbot.isActive && typeof window.prodAIChatbot.activateChat === 'function') {
                    __dbg('ğŸš€ Chat inativo. Ativando com a primeira mensagem...');
                    await window.prodAIChatbot.activateChat(message);
                    showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                    closeAudioModal();
                    messageSent = true;
                } else if (typeof window.prodAIChatbot.sendMessage === 'function') {
                    // Chat jÃ¡ ativo: preencher input ativo e enviar
                    const activeInput = document.getElementById('chatbotActiveInput');
                    if (activeInput) {
                        activeInput.value = message;
                        activeInput.focus();
                        activeInput.dispatchEvent(new Event('input', { bubbles: true }));
                        await window.prodAIChatbot.sendMessage();
                        showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                        closeAudioModal();
                        messageSent = true;
                    }
                }
            } catch (err) {
                __dwrn('âš ï¸ Falha ao usar ProdAIChatbot direto, tentando fallback...', err);
            }
        }
        // MÃ©todo 2: Inserir diretamente no input e simular envio
        else {
            __dbg('ğŸ¯ Tentando mÃ©todo alternativo...');
            
            const input = document.getElementById('chatbotActiveInput') || document.getElementById('chatbotMainInput');
            const sendBtn = document.getElementById('chatbotActiveSendBtn') || document.getElementById('chatbotSendButton');
            
            __dbg('ğŸ” Elementos encontrados:', { input: !!input, sendBtn: !!sendBtn });
            
            if (input && sendBtn) {
                input.value = message;
                input.focus();
                
                // Disparar eventos para simular interaÃ§Ã£o do usuÃ¡rio
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                
                // Aguardar um pouco e clicar no botÃ£o
                setTimeout(() => {
                    sendBtn.click();
                    __dbg('âœ… BotÃ£o clicado');
                    showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                    closeAudioModal();
                }, 500);
                
                messageSent = true;
            }
        }
        
        if (!messageSent) {
            __dbg('âŒ NÃ£o foi possÃ­vel enviar automaticamente, copiando para clipboard...');
            
            // Fallback: copiar para clipboard
            await navigator.clipboard.writeText(message);
            showTemporaryFeedback('ğŸ“‹ AnÃ¡lise copiada! Cole no chat manualmente.');
            __dbg('ğŸ“‹ Mensagem copiada para clipboard como fallback');
        }
        
    } catch (error) {
        console.error('âŒ Erro ao enviar anÃ¡lise para chat:', error);
        showTemporaryFeedback('âŒ Erro ao enviar anÃ¡lise. Tente novamente.');
    }
}

// ï¿½ Mostrar feedback temporÃ¡rio
// (definiÃ§Ã£o duplicada de showTemporaryFeedback removida â€” mantida a versÃ£o consolidada abaixo)

// ğŸ“„ Baixar relatÃ³rio do modal (IMPLEMENTAÃ‡ÃƒO ROBUSTA COM VALIDAÃ‡ÃƒO)
async function downloadModalAnalysis() {
    // 1ï¸âƒ£ VALIDAÃ‡ÃƒO: Verificar se anÃ¡lise estÃ¡ disponÃ­vel no alias global
    const analysis = window.__soundyAI?.analysis || currentModalAnalysis;
    
    if (!analysis) {
        alert('âŒ Nenhuma anÃ¡lise disponÃ­vel.\n\nFaÃ§a uma anÃ¡lise antes de gerar o relatÃ³rio.');
        console.error('[PDF-ERROR] AnÃ¡lise nÃ£o encontrada em window.__soundyAI.analysis ou currentModalAnalysis');
        return;
    }
    
    // ğŸ” AUDITORIA: Mapear estrutura completa do objeto analysis
    console.log('ğŸ” [AUDIT-PDF] ============ INÃCIO DA AUDITORIA ============');
    console.log('ğŸ” [AUDIT-PDF] Analysis root keys:', Object.keys(analysis));
    console.log('ğŸ” [AUDIT-PDF] Fontes detectadas:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        userBands: analysis.user?.bands,
        diagnostics: analysis.diagnostics,
        problems: analysis.problems,
        _diagnostic: analysis._diagnostic,
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        score: analysis.score,
        userScore: analysis.user?.score
    });
    
    // ğŸ” AUDITORIA: Comparar com valores da UI (modal Paperline)
    console.log('ğŸ” [AUDIT-UI] Valores exibidos na UI:', {
        score: document.querySelector('.score-final-value')?.dataset?.value || document.querySelector('.score-final-value')?.textContent,
        bandSub: document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent,
        bandBass: document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent,
        bandMid: document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent,
        bandHigh: document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent
    });
    
    console.log('ğŸ“„ [PDF-START] Iniciando geraÃ§Ã£o de relatÃ³rio PDF...');
    console.log('ğŸ“„ [PDF-SOURCE] Fonte de dados:', {
        usingGlobalAlias: !!window.__soundyAI?.analysis,
        usingCurrentModal: !!currentModalAnalysis,
        fileName: analysis.fileName || analysis.metadata?.fileName,
        hasLoudness: !!(analysis.loudness || analysis.lufsIntegrated),
        hasTruePeak: !!(analysis.truePeak || analysis.truePeakDbtp)
    });
    
    // 2ï¸âƒ£ VALIDAÃ‡ÃƒO: Verificar dependÃªncias
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('âš™ï¸ Carregando bibliotecas...');
        console.warn('âš ï¸ [PDF-WAIT] Aguardando carregamento de jsPDF/html2canvas...');
        
        // Retry apÃ³s 1s
        setTimeout(() => downloadModalAnalysis(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('âš™ï¸ Gerando relatÃ³rio PDF...');
        
        // 3ï¸âƒ£ VALIDAÃ‡ÃƒO CONTRA UI: Comparar dados do relatÃ³rio com a UI
        validateAnalysisDataAgainstUI(analysis);
        
        // 4ï¸âƒ£ NORMALIZAR: Extrair e formatar dados
        const normalizedData = normalizeAnalysisDataForPDF(analysis);
        
        // 5ï¸âƒ£ GERAR HTML: Template profissional
        const reportHTML = generateReportHTML(normalizedData);
        
        // 6ï¸âƒ£ PREPARAR CONTAINER: Inserir e tornar visÃ­vel
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template nÃ£o encontrado no DOM');
        }
        
        container.innerHTML = reportHTML;
        const elemento = container.firstElementChild;
        if (!elemento) {
            throw new Error('Template HTML nÃ£o foi renderizado corretamente');
        }
        
        // Salvar estilos originais
        const originalStyles = {
            display: container.style.display,
            visibility: container.style.visibility,
            position: container.style.position,
            left: container.style.left,
            top: container.style.top,
            zIndex: container.style.zIndex
        };
        
        // âœ… PROPORÃ‡ÃƒO FIXA A4: 794x1123 px (resoluÃ§Ã£o base vertical)
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const A4_RATIO = A4_HEIGHT / A4_WIDTH; // 1.414 (proporÃ§Ã£o A4)
        
        // ForÃ§ar visibilidade temporÃ¡ria com proporÃ§Ã£o A4 fixa
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.position = 'fixed';
        container.style.left = '50%';
        container.style.top = '0';
        container.style.transform = 'translateX(-50%)'; // Centralizar horizontalmente
        container.style.zIndex = '9999';
        container.style.width = `${A4_WIDTH}px`; // Largura fixa A4
        container.style.height = 'auto';
        container.style.margin = '0 auto';
        
        console.log('ğŸ“Š [PDF-RENDER] Container preparado com proporÃ§Ã£o A4:', {
            baseWidth: A4_WIDTH,
            baseHeight: A4_HEIGHT,
            ratio: A4_RATIO,
            containerWidth: elemento.offsetWidth,
            containerHeight: elemento.offsetHeight,
            isVisible: elemento.offsetWidth > 0 && elemento.offsetHeight > 0
        });
        
        // 7ï¸âƒ£ AGUARDAR RENDERIZAÃ‡ÃƒO: 250ms base + scroll + 150ms
        await new Promise(r => setTimeout(r, 250));
        elemento.scrollIntoView({ behavior: 'instant', block: 'start' });
        await new Promise(r => setTimeout(r, 150));
        
        // âœ… 8ï¸âƒ£ CAPTURAR PÃGINAS SEPARADAMENTE com proporÃ§Ã£o fixa A4
        console.log('ğŸ“¸ [PDF-CAPTURE] Iniciando captura em 2 pÃ¡ginas lÃ³gicas com proporÃ§Ã£o A4 fixa...');
        
        // âœ… PROPORÃ‡ÃƒO FIXA: Sempre usar 794px (A4) com scale 2 (alta qualidade)
        // NÃƒO depende de viewport - garante consistÃªncia desktop/mobile
        const CAPTURE_WIDTH = A4_WIDTH; // 794px
        const CAPTURE_SCALE = 2; // Alta qualidade (1588px efetivos)
        const CAPTURE_BG = '#0a0a0f'; // Fundo escuro profissional
        
        console.log('ï¿½ [PDF-A4-FIXED]', {
            captureWidth: CAPTURE_WIDTH,
            captureScale: CAPTURE_SCALE,
            backgroundColor: CAPTURE_BG,
            effectiveWidth: CAPTURE_WIDTH * CAPTURE_SCALE,
            note: 'ProporÃ§Ã£o A4 fixa (nÃ£o depende de viewport)'
        });
        
        const section1 = elemento.querySelector('.pdf-section-metrics');
        const section2 = elemento.querySelector('.pdf-section-diagnostics');
        
        if (!section1 || !section2) {
            throw new Error('âŒ SeÃ§Ãµes PDF nÃ£o encontradas. Verifique as classes .pdf-section-metrics e .pdf-section-diagnostics');
        }
        
        console.log('ï¿½ [PDF-CAPTURE] Capturando PÃ¡gina 1 (MÃ©tricas)...');
        // âœ… FunÃ§Ã£o genÃ©rica e segura de captura A4 com wrapper virtual
        async function renderSectionToPDF(element, sectionName) {
            const wrapper = document.createElement('div');
            const isMobile = window.innerWidth < 768;
            wrapper.style.width = '794px';
            wrapper.style.height = '1123px';
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'flex-start';
            wrapper.style.justifyContent = 'center';
            wrapper.style.background = '#0a0a0f';
            wrapper.style.padding = '0';  // âœ… Zero padding no wrapper
            wrapper.style.position = 'fixed';
            wrapper.style.left = '-9999px';
            wrapper.style.top = '0';
            wrapper.style.zIndex = '-1';
            wrapper.style.overflow = 'hidden';
            
            // Clona o conteÃºdo e aplica padding no clone (nÃ£o no wrapper)
            const clone = element.cloneNode(true);
            clone.style.padding = isMobile ? '10px' : '20px';  // âœ… Padding no conteÃºdo
            clone.style.boxSizing = 'border-box';
            clone.style.width = '100%';
            clone.style.height = '100%';
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);
            
            // Aguarda renderizaÃ§Ã£o
            await new Promise(r => setTimeout(r, 150));
            
            console.log(`ğŸ“ [PDF-WRAPPER] ${sectionName}:`, {
                declared: { width: '794px', height: '1123px' },
                computed: {
                    offsetWidth: wrapper.offsetWidth,
                    offsetHeight: wrapper.offsetHeight,
                    clientWidth: wrapper.clientWidth,
                    clientHeight: wrapper.clientHeight
                },
                usableArea: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    lostHeight: 1123 - wrapper.clientHeight
                },
                padding: isMobile ? '10px (clone)' : '20px (clone)',
                note: 'Padding aplicado no clone, nÃ£o no wrapper'
            });
            
            // Captura com parÃ¢metros fixos A4
            const canvas = await html2canvas(wrapper, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: '#0a0a0f',
                useCORS: true,
                allowTaint: true,
                logging: false,
                scale: 2
            });
            
            document.body.removeChild(wrapper);
            
            const ratio = (canvas.height / canvas.width).toFixed(3);
            const expectedRatio = (1123 / 794).toFixed(3);
            console.log(`ğŸ–¼ï¸ [PDF-CANVAS] ${sectionName}:`, {
                canvasSize: { width: canvas.width, height: canvas.height },
                ratio,
                expectedRatio,
                match: ratio === expectedRatio ? 'âœ…' : 'âš ï¸'
            });
            
            return canvas;
        }
        
        const canvas1 = await renderSectionToPDF(section1, 'MÃ©tricas');
        
        const canvas2 = await renderSectionToPDF(section2, 'DiagnÃ³stico');
        
        console.log('âœ… [PDF-CANVAS] PÃ¡ginas capturadas:', {
            page1: { width: canvas1.width, height: canvas1.height },
            page2: { width: canvas2.width, height: canvas2.height }
        });
        
        if (canvas1.width === 0 || canvas1.height === 0 || canvas2.width === 0 || canvas2.height === 0) {
            throw new Error('Canvas vazio - verifique se as seÃ§Ãµes estÃ£o visÃ­veis');
        }
        
        // âœ… ValidaÃ§Ã£o final de proporÃ§Ã£o A4
        const ratio1 = (canvas1.height / canvas1.width).toFixed(3);
        const ratio2 = (canvas2.height / canvas2.width).toFixed(3);
        const expectedRatio = (1123 / 794).toFixed(3);
        
        console.log('[PDF] ProporÃ§Ã£o A4 preservada com sucesso (' + expectedRatio + ')');
        console.log('[PDF] Canvas1: ' + canvas1.width + 'x' + canvas1.height + ' | Canvas2: ' + canvas2.width + 'x' + canvas2.height);
        console.log('[PDF] ExportaÃ§Ã£o concluÃ­da sem achatamento âœ”ï¸');
        
        // âœ… 9ï¸âƒ£ GERAR PDF COM PROPORÃ‡ÃƒO A4 E MARGENS (centralizaÃ§Ã£o perfeita mobile)
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth(); // 210mm
        const pageHeight = pdf.internal.pageSize.getHeight(); // 297mm
        
        // âœ… Zero margens para ambos dispositivos (100% fill A4)
        const SIDE_MARGIN_MM = 0;
        const TOP_MARGIN_MM = 0;
        const BOTTOM_MARGIN_MM = 0;
        
        console.log('ï¿½ [PDF-A4-FORMAT]', {
            pageWidth,
            pageHeight,
            margins: 'ZERO (100% fill)',
            format: 'A4 Portrait (210x297mm)'
        });
        
        // âœ… FunÃ§Ã£o unificada: preencher 100% A4 (desktop e mobile)
        function addCanvasAsA4PageCentered(cnv, sectionName) {
            // ComeÃ§ar pela altura (preencher verticalmente)
            let imgHeight = pageHeight; // 297mm
            let imgWidth = (cnv.width * imgHeight) / cnv.height;
            
            // Se largura ultrapassar, reajustar por largura
            if (imgWidth > pageWidth) {
                imgWidth = pageWidth; // 210mm
                imgHeight = (cnv.height * imgWidth) / cnv.width;
            }
            
            // PosiÃ§Ã£o absoluta no canto (sem margens)
            const x = 0;
            const y = 0;
            
            const fillPercentage = ((imgHeight / pageHeight) * 100).toFixed(1);
            
            console.log(`ğŸ“„ [PDF-BUILD] ${sectionName}:`, {
                canvasSize: { width: cnv.width, height: cnv.height },
                pageSize: { width: pageWidth, height: pageHeight },
                imgWidth: imgWidth.toFixed(2),
                imgHeight: imgHeight.toFixed(2),
                position: { x, y },
                fillPercentage: `${fillPercentage}%`,
                margins: 'ZERO (100% fill)'
            });
            
            const imgData = cnv.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
        }
        
        // PÃ¡gina 1 (MÃ©tricas)
        addCanvasAsA4PageCentered(canvas1, 'PÃ¡gina 1 (MÃ©tricas)');
        
        // PÃ¡gina 2 (DiagnÃ³stico/RecomendaÃ§Ãµes)
        pdf.addPage();
        addCanvasAsA4PageCentered(canvas2, 'PÃ¡gina 2 (DiagnÃ³stico)');
        
        // ğŸ”Ÿ DOWNLOAD: Nome descritivo com data
        const cleanFileName = (normalizedData.fileName || 'audio')
            .replace(/\.[^/.]+$/, '')
            .replace(/[^a-z0-9_-]/gi, '_');
        const dateStr = new Date().toISOString().split('T')[0];
        const fileName = `Relatorio_SoundyAI_${cleanFileName}_${dateStr}.pdf`;
        
        pdf.save(fileName);
        
        console.log('âœ… [PDF-SUCCESS] RelatÃ³rio gerado:', fileName);
        showTemporaryFeedback('âœ… RelatÃ³rio PDF baixado com sucesso!');
        
        // RESTAURAR: Estilos originais
        Object.assign(container.style, originalStyles);
        setTimeout(() => container.innerHTML = '', 100);
        
    } catch (error) {
        console.error('âŒ [PDF-ERROR] Erro ao gerar relatÃ³rio:', error);
        console.error('âŒ [PDF-ERROR] Stack:', error.stack);
        showTemporaryFeedback('âŒ Erro ao gerar PDF');
        alert(`Erro ao gerar relatÃ³rio PDF:\n\n${error.message}\n\nVerifique o console para mais detalhes.`);
    }
}


// ğŸ” VALIDAÃ‡ÃƒO: Comparar dados do relatÃ³rio com a UI
function validateAnalysisDataAgainstUI(analysis) {
    console.log('ğŸ” [PDF-VALIDATE] Iniciando validaÃ§Ã£o contra UI...');
    console.log('ğŸ§  [PDF-AUDIT] AnÃ¡lise Global:', analysis);
    
    const assertEqual = (label, pdfValue, uiSelector, tolerance = 0.01) => {
        const uiElement = document.querySelector(uiSelector);
        if (!uiElement) {
            console.warn(`âš ï¸ [PDF-VALIDATE] Elemento UI nÃ£o encontrado: ${uiSelector}`);
            return;
        }
        
        let uiValue = uiElement.dataset?.value || 
                     uiElement.getAttribute('data-value') ||
                     parseFloat(uiElement.textContent.replace(/[^0-9.-]/g, ''));
        
        if (isNaN(uiValue)) {
            console.warn(`âš ï¸ [PDF-VALIDATE] Valor UI nÃ£o numÃ©rico em ${uiSelector}`);
            return;
        }
        
        if (pdfValue == null || isNaN(pdfValue)) {
            console.warn(`âš ï¸ [PDF-VALIDATE] Valor PDF ausente para ${label}`);
            return;
        }
        
        const diff = Math.abs(Number(pdfValue) - Number(uiValue));
        const ok = diff < tolerance;
        
        if (!ok) {
            console.warn(`ğŸš¨ [PDF-VALIDATE] DIVERGÃŠNCIA em ${label}:`, {
                pdf: pdfValue,
                ui: uiValue,
                diferenca: diff.toFixed(3)
            });
        } else {
            console.log(`âœ… [PDF-VALIDATE] ${label}: OK (diff=${diff.toFixed(4)})`);
        }
    };
    
    try {
        const lufsValue = analysis.lufsIntegrated || analysis.loudness?.integrated || analysis.technicalData?.lufsIntegrated;
        if (lufsValue) assertEqual('LUFS Integrado', lufsValue, '[data-metric="lufs-integrated"]', 0.1);
        
        const truePeakValue = analysis.truePeakDbtp || analysis.truePeak?.maxDbtp || analysis.technicalData?.truePeakDbtp;
        if (truePeakValue) assertEqual('True Peak', truePeakValue, '[data-metric="true-peak"]', 0.1);
        
        const drValue = analysis.dynamicRange || analysis.dynamics?.range || analysis.technicalData?.dynamicRange;
        if (drValue) assertEqual('Dynamic Range', drValue, '[data-metric="dynamic-range"]', 0.5);
        
        if (analysis.score) assertEqual('Score', analysis.score, '.score-final-value', 1);
        
        console.log('âœ… [PDF-VALIDATE] ValidaÃ§Ã£o concluÃ­da');
    } catch (error) {
        console.error('âŒ [PDF-VALIDATE] Erro na validaÃ§Ã£o:', error);
    }
}

// ğŸ¯ Normalizar dados da anÃ¡lise para formato compatÃ­vel com PDF (NOVA VERSÃƒO ROBUSTA)
function normalizeAnalysisDataForPDF(analysis) {
    console.log('ğŸ“Š [PDF-NORMALIZE] ============ INÃCIO DA NORMALIZAÃ‡ÃƒO ============');
    console.log('ğŸ“Š [PDF-NORMALIZE] Estrutura recebida:', {
        keys: Object.keys(analysis),
        fileName: analysis.fileName || analysis.metadata?.fileName,
        score: analysis.score,
        hasLufsRoot: !!analysis.lufsIntegrated,
        hasTruePeakRoot: !!analysis.truePeakDbtp,
        hasDRRoot: !!analysis.dynamicRange,
        hasBands: !!(analysis.bands || analysis.spectralBands)
    });
    
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'â€”';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    const extract = (...paths) => {
        for (const path of paths) {
            if (typeof path === 'function') {
                const val = path();
                if (Number.isFinite(val)) return val;
            } else if (Number.isFinite(path)) {
                return path;
            }
        }
        return null;
    };
    
    const lufsIntegrated = extract(analysis.lufsIntegrated, analysis.loudness?.integrated, analysis.technicalData?.lufsIntegrated);
    const lufsShortTerm = extract(analysis.avgLoudness, analysis.loudness?.shortTerm, analysis.technicalData?.avgLoudness);
    const lufsMomentary = extract(lufsShortTerm, analysis.loudness?.momentary);
    const lra = extract(analysis.lra, analysis.loudness?.lra, analysis.technicalData?.lra);
    
    console.log('ğŸ§ [PDF-NORMALIZE] Loudness extraÃ­do:', { integrated: lufsIntegrated, shortTerm: lufsShortTerm, momentary: lufsMomentary, lra });
    
    const truePeakDbtp = extract(analysis.truePeakDbtp, analysis.truePeak?.maxDbtp, analysis.technicalData?.truePeakDbtp);
    const clippingSamples = extract(analysis.truePeak?.clipping?.samples, analysis.clipping?.samples, 0);
    const clippingPercentage = extract(analysis.truePeak?.clipping?.percentage, analysis.clipping?.percentage, 0);
    
    console.log('âš™ï¸ [PDF-NORMALIZE] True Peak extraÃ­do:', { maxDbtp: truePeakDbtp, clipping: { samples: clippingSamples, percentage: clippingPercentage }});
    
    const dynamicRange = extract(analysis.dynamicRange, analysis.dynamics?.range, analysis.technicalData?.dynamicRange);
    const crestFactor = extract(analysis.crestFactor, analysis.dynamics?.crest, analysis.technicalData?.crestFactor);
    
    console.log('ğŸšï¸ [PDF-NORMALIZE] DinÃ¢mica extraÃ­da:', { range: dynamicRange, crest: crestFactor });
    
    const stereoWidth = extract(analysis.stereo?.width, analysis.stereoWidth, analysis.technicalData?.stereoWidth);
    const stereoCorrelation = extract(analysis.stereoCorrelation, analysis.stereo?.correlation, analysis.technicalData?.stereoCorrelation);
    const monoCompatibility = extract(analysis.stereo?.monoCompatibility, analysis.monoCompatibility);
    
    console.log('ğŸ›ï¸ [PDF-NORMALIZE] Stereo extraÃ­do:', { width: stereoWidth, correlation: stereoCorrelation, monoCompatibility });
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de bandas espectrais
    console.log('ğŸ“ˆ [AUDIT-FREQ] Bandas disponÃ­veis em analysis:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        spectralBands_nested: analysis.spectral?.bands,
        userBands: analysis.user?.bands,
        userSpectralBands: analysis.user?.spectralBands,
        userSpectral: analysis.user?.spectral
    });
    
    // âœ… FREQUÃŠNCIAS â€” corrigindo campos energy_db, percentage e range
    const bandsSrc = analysis.bands || analysis.spectralBands || analysis.spectral?.bands || {};
    const extractBand = (band) => {
      if (!band) return { db: 'â€”', pct: 'â€”', range: '' };
      if (typeof band === 'number') return { db: band.toFixed(1), pct: 'â€”', range: '' };
      const db = band.energy_db ?? band.rms_db ?? band.value ?? null;
      const pct = band.percentage ?? band.percent ?? null;
      const range = band.range ?? '';
      return {
        db: db !== null ? db.toFixed(1) : 'â€”',
        pct: pct !== null ? pct.toFixed(1) + '%' : 'â€”',
        range
      };
    };

    // Formata todas as bandas principais
    const spectral = {
      sub:  extractBand(bandsSrc.sub),
      bass: extractBand(bandsSrc.bass),
      lowMid: extractBand(bandsSrc.lowMid),
      mid:  extractBand(bandsSrc.mid),
      highMid: extractBand(bandsSrc.highMid),
      presence: extractBand(bandsSrc.presence),
      air: extractBand(bandsSrc.air)
    };

    console.log('ï¿½ [PDF-FIX] Bandas espectrais resolvidas:', spectral);
    
    // âœ… SCORE SINCRONIZADO COM A UI
    let score = analysis.scoring?.final 
             ?? analysis.user?.score 
             ?? analysis.scores?.final 
             ?? analysis.score 
             ?? 0;

    const uiScoreEl = document.querySelector('.score-final-value');
    if (uiScoreEl) {
      const scoreUI = parseFloat(uiScoreEl.dataset?.value || uiScoreEl.textContent || '0');
      if (!isNaN(scoreUI) && scoreUI > 0 && Math.abs(score - scoreUI) > 1) {
        console.warn('âš™ï¸ [PDF-FIX] Score ajustado com base na UI:', { old: score, new: scoreUI });
        score = scoreUI;
      }
    } else {
      console.warn('âš ï¸ [PDF-FIX] Elemento de score na UI nÃ£o encontrado, mantendo score:', score);
    }
    
    score = Math.round(score);
    const classification = analysis.classification || analysis.scoring?.classification || getClassificationFromScore(score);
    const fileName = analysis.fileName || analysis.metadata?.fileName || analysis.fileKey?.split('/').pop() || 'audio_sem_nome.wav';
    const duration = extract(analysis.duration, analysis.metadata?.duration, 0);
    const sampleRate = extract(analysis.sampleRate, analysis.metadata?.sampleRate, 44100);
    const channels = extract(analysis.channels, analysis.metadata?.channels, 2);
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de diagnÃ³sticos
    console.log('ğŸ©º [AUDIT-DIAG] DiagnÃ³stico disponÃ­vel em analysis:', {
        problems: analysis.problems,
        diagnostics: analysis.diagnostics,
        _diagnostic: analysis._diagnostic,
        userProblems: analysis.user?.problems,
        userDiagnostics: analysis.user?.diagnostics,
        problemsType: Array.isArray(analysis.problems) ? 'array' : typeof analysis.problems,
        diagnosticsType: Array.isArray(analysis.diagnostics) ? 'array' : typeof analysis.diagnostics
    });
    
    // âœ… DIAGNÃ“STICO AUTOMÃTICO
    let diagnostics = [];

    if (analysis.diagnostics?.problems?.length > 0) {
      diagnostics = analysis.diagnostics.problems.map(p => p.message || p);
    } 
    else if (analysis.diagnostics?.suggestions?.length > 0) {
      diagnostics = analysis.diagnostics.suggestions.map(s => 
        `âš ï¸ ${s.message || s.type || 'SugestÃ£o'} â€” ${s.why || s.action || ''}`
      );
    } 
    else {
      diagnostics = ['âœ… Nenhum problema detectado'];
    }

    console.log('ğŸ©º [PDF-FIX] DiagnÃ³stico enriquecido:', diagnostics);
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de sugestÃµes
    console.log('ğŸ’¡ [AUDIT-SUG] SugestÃµes detectadas em analysis:', {
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        recommendations: analysis.recommendations,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        userSuggestions: analysis.user?.suggestions,
        userSuggestionsAdvanced: analysis.user?.suggestionsAdvanced,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        suggestionsType: Array.isArray(analysis.suggestions) ? `array[${analysis.suggestions?.length}]` : typeof analysis.suggestions,
        advancedType: Array.isArray(analysis.suggestionsAdvanced) ? `array[${analysis.suggestionsAdvanced?.length}]` : typeof analysis.suggestionsAdvanced
    });
    
    // âœ… SUGESTÃ•ES ENRIQUECIDAS
    let suggestions = [];

    if (analysis.diagnostics?.suggestions?.length > 0) {
      suggestions = analysis.diagnostics.suggestions.map(s => {
        const title = s.message || s.type || 'Ajuste recomendado';
        const action = s.action ? ` â†’ ${s.action}` : '';
        const why = s.why ? ` (${s.why})` : '';
        return `${title}${action}${why}`;
      });
    } else if (Array.isArray(analysis.suggestions)) {
      suggestions = analysis.suggestions.map(s => 
        typeof s === 'string' ? s : s.message || s.type || 'SugestÃ£o'
      );
    }

    console.log('ğŸ’¡ [PDF-FIX] SugestÃµes enriquecidas:', suggestions);
    
    // Normalizar para 'recommendations' (compatibilidade com retorno)
    const recommendations = suggestions.length > 0 ? suggestions : ['âœ… AnÃ¡lise completa'];
    
    const normalizedResult = {
        score,
        classification,
        fileName,
        duration,
        sampleRate,
        channels,
        bitDepth: analysis.bitDepth || analysis.metadata?.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(lufsIntegrated, 1),
            shortTerm: formatValue(lufsShortTerm, 1),
            momentary: formatValue(lufsMomentary, 1),
            lra: formatValue(lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeakDbtp, 2),
            clipping: { samples: clippingSamples || 0, percentage: formatValue(clippingPercentage, 2) }
        },
        dynamics: {
            range: formatValue(dynamicRange, 1),
            crest: formatValue(crestFactor, 1)
        },
        spectral: spectral,
        stereo: {
            width: formatValue(stereoWidth * 100, 1),
            correlation: formatValue(stereoCorrelation, 2),
            monoCompatibility: formatValue(monoCompatibility * 100, 1)
        },
        diagnostics: diagnostics.length > 0 ? diagnostics : ['âœ… Nenhum problema detectado'],
        recommendations: recommendations.length > 0 ? recommendations : ['âœ… AnÃ¡lise completa']
    };
    
    // ğŸ” AUDITORIA: Resumo final comparativo
    console.log('ğŸ“Š [AUDIT-PDF-SUMMARY] Resumo da Auditoria:', {
        hasFrequencies: !!(spectral.sub !== 'â€”' || spectral.bass !== 'â€”' || spectral.mid !== 'â€”' || spectral.high !== 'â€”'),
        frequenciesValues: spectral,
        hasDiagnostics: diagnostics.length > 0 && diagnostics[0] !== 'âœ… Nenhum problema detectado',
        diagnosticsCount: diagnostics.length,
        hasSuggestions: recommendations.length > 0 && recommendations[0] !== 'âœ… AnÃ¡lise completa',
        suggestionsCount: recommendations.length,
        suggestionsEnriched: analysis._suggestionsGenerated === true,
        score: score,
        scoreSource: analysis.score ? 'analysis.score' : (analysis.user?.score ? 'analysis.user.score' : 'scoreUI')
    });
    
    // ğŸ” AUDITORIA: Comparar dados normalizados com valores da UI
    const uiSub = document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiBass = document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiMid = document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiHigh = document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent?.replace(/[^0-9.-]/g, '');
    
    console.log('ğŸš [AUDIT-FREQ-COMPARE] ComparaÃ§Ã£o UI vs PDF:', {
        sub: { ui: uiSub, pdf: spectral.sub, match: parseFloat(uiSub) === parseFloat(spectral.sub) },
        bass: { ui: uiBass, pdf: spectral.bass, match: parseFloat(uiBass) === parseFloat(spectral.bass) },
        mid: { ui: uiMid, pdf: spectral.mid, match: parseFloat(uiMid) === parseFloat(spectral.mid) },
        high: { ui: uiHigh, pdf: spectral.high, match: parseFloat(uiHigh) === parseFloat(spectral.high) }
    });
    
    console.log('âœ… [PDF-NORMALIZE] Resultado normalizado:', normalizedResult);
    console.log('ğŸ“Š [PDF-NORMALIZE] ============ FIM DA NORMALIZAÃ‡ÃƒO ============');
    
    return normalizedResult;
}

// ï¿½ Normalizar dados da anÃ¡lise para formato compatÃ­vel com PDF
function normalizeAnalysisData(analysis) {
    // ğŸ” DIAGNÃ“STICO: Log completo da estrutura recebida
    console.log('ğŸ“Š [PDF-NORMALIZE] ============ INÃCIO DA NORMALIZAÃ‡ÃƒO ============');
    console.log('ğŸ“Š [PDF-NORMALIZE] AnÃ¡lise completa recebida:', analysis);
    console.log('ğŸ“Š [PDF-NORMALIZE] Chaves disponÃ­veis:', Object.keys(analysis));
    
    // ğŸ”§ CORREÃ‡ÃƒO: Dados podem estar na raiz, em metrics, ou em tech
    const metrics = analysis.metrics || {};
    const tech = analysis.tech || analysis.technicalData || {};
    
    console.log('ğŸ” [PDF-NORMALIZE] Origem dos dados:', {
        hasMetrics: !!analysis.metrics,
        hasTech: !!analysis.tech,
        hasTechnicalData: !!analysis.technicalData,
        hasRootData: !!(analysis.loudness || analysis.truePeak || analysis.lufsIntegrated),
        metricsKeys: Object.keys(metrics),
        techKeys: Object.keys(tech)
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Loudness pode estar em mÃºltiplos lugares
    const loudness = metrics.loudness || tech.loudness || analysis.loudness || {
        // Fallback para propriedades na raiz
        integrated: analysis.lufsIntegrated,
        shortTerm: analysis.avgLoudness,
        momentary: analysis.avgLoudness,
        lra: analysis.lra
    };
    console.log('ğŸ§ [PDF-NORMALIZE] Loudness extraÃ­do:', {
        source: metrics.loudness ? 'metrics' : (tech.loudness ? 'tech' : (analysis.loudness ? 'analysis.loudness' : 'raiz')),
        data: loudness,
        integrated: loudness.integrated,
        shortTerm: loudness.shortTerm,
        momentary: loudness.momentary,
        lra: loudness.lra
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: True Peak pode estar em mÃºltiplos lugares
    const truePeak = metrics.truePeak || tech.truePeak || analysis.truePeak || {
        // Fallback para propriedades na raiz
        maxDbtp: analysis.truePeakDbtp,
        clipping: { samples: 0, percentage: 0 }
    };
    console.log('âš™ï¸ [PDF-NORMALIZE] True Peak extraÃ­do:', {
        source: metrics.truePeak ? 'metrics' : (tech.truePeak ? 'tech' : (analysis.truePeak ? 'analysis.truePeak' : 'raiz')),
        data: truePeak,
        maxDbtp: truePeak.maxDbtp,
        clipping: truePeak.clipping
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: DinÃ¢mica pode estar em mÃºltiplos lugares
    const dynamics = metrics.dynamics || tech.dynamics || analysis.dynamics || {
        // Fallback para propriedades na raiz
        range: analysis.dynamicRange,
        crest: analysis.crestFactor
    };
    console.log('ğŸšï¸ [PDF-NORMALIZE] Dynamics extraÃ­do:', {
        source: metrics.dynamics ? 'metrics' : (tech.dynamics ? 'tech' : (analysis.dynamics ? 'analysis.dynamics' : 'raiz')),
        data: dynamics,
        range: dynamics.range,
        crest: dynamics.crest
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Espectro pode estar em mÃºltiplos lugares
    const spectral = metrics.spectral || tech.spectral || analysis.spectral || {};
    const bands = spectral.bands || analysis.spectralBands || analysis.bands || {};
    console.log('ğŸ“ˆ [PDF-NORMALIZE] Spectral extraÃ­do:', {
        source: metrics.spectral ? 'metrics' : (tech.spectral ? 'tech' : (analysis.spectral ? 'analysis.spectral' : (analysis.bands ? 'analysis.bands' : 'vazio'))),
        spectral: spectral,
        bands: bands,
        bandsKeys: Object.keys(bands)
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Stereo pode estar em mÃºltiplos lugares
    const stereo = metrics.stereo || tech.stereo || analysis.stereo || {};
    console.log('ğŸ›ï¸ [PDF-NORMALIZE] Stereo extraÃ­do:', {
        source: metrics.stereo ? 'metrics' : (tech.stereo ? 'tech' : (analysis.stereo ? 'analysis.stereo' : 'vazio')),
        data: stereo,
        width: stereo.width,
        correlation: stereo.correlation,
        monoCompatibility: stereo.monoCompatibility
    });
    
    // Score e classificaÃ§Ã£o
    const score = analysis.qualityOverall || analysis.score || 0;
    const classification = analysis.classification || getClassificationFromScore(score);
    
    // DiagnÃ³sticos e recomendaÃ§Ãµes
    const problems = analysis.problems || [];
    const suggestions = analysis.suggestions || [];
    const diagnostics = problems.length > 0 
        ? problems.map(p => p.message || p) 
        : ['âœ… Nenhum problema crÃ­tico detectado'];
    const recommendations = suggestions.length > 0 
        ? suggestions.map(s => s.message || s.action || s) 
        : ['âœ… AnÃ¡lise completa realizada com sucesso'];
    
    // FormataÃ§Ã£o segura de valores
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'N/A';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    // Log do resultado final normalizado
    const normalizedResult = {
        score: Math.round(score),
        classification,
        fileName: analysis.fileName || 'audio_sem_nome.wav',
        duration: analysis.duration || 0,
        sampleRate: analysis.sampleRate || 44100,
        channels: analysis.channels || 2,
        bitDepth: analysis.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(loudness.integrated, 1),
            shortTerm: formatValue(loudness.shortTerm, 1),
            momentary: formatValue(loudness.momentary, 1),
            lra: formatValue(loudness.lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeak.maxDbtp, 2),
            clipping: {
                samples: truePeak.clipping?.samples || 0,
                percentage: formatValue(truePeak.clipping?.percentage, 2)
            }
        },
        dynamics: {
            range: formatValue(dynamics.range, 1),
            crest: formatValue(dynamics.crest, 1)
        },
        spectral: {
            sub: formatValue(bands.sub || bands.subBass, 1),
            bass: formatValue(bands.bass, 1),
            mid: formatValue(bands.mid || bands.midrange, 1),
            high: formatValue(bands.presence || bands.high || bands.treble, 1)
        },
        stereo: {
            width: formatValue(stereo.width, 1),
            correlation: formatValue(stereo.correlation, 2),
            monoCompatibility: formatValue(stereo.monoCompatibility, 1)
        },
        diagnostics,
        recommendations
    };
    
    console.log('âœ… [PDF-NORMALIZE] Resultado final normalizado:', normalizedResult);
    console.log('ğŸ“Š [PDF-NORMALIZE] ============ FIM DA NORMALIZAÃ‡ÃƒO ============');
    
    return normalizedResult;
}

// ğŸ† ClassificaÃ§Ã£o baseada em score
function getClassificationFromScore(score) {
    if (score >= 90) return 'ğŸ† Profissional';
    if (score >= 75) return 'â­ AvanÃ§ado';
    if (score >= 60) return 'ğŸ‘ IntermediÃ¡rio';
    if (score >= 40) return 'ğŸ“š BÃ¡sico';
    return 'ğŸ”§ Necessita Melhorias';
}

// ğŸ¨ Gerar HTML profissional do relatÃ³rio para PDF
function generateReportHTML(data) {
    // ğŸ” AUDITORIA: Verificar dados recebidos para geraÃ§Ã£o do HTML
    console.log('ğŸ“ [AUDIT-HTML] ============ INÃCIO DA GERAÃ‡ÃƒO DO HTML ============');
    console.log('ğŸ“ [AUDIT-HTML] Dados recebidos:', {
        score: data.score,
        classification: data.classification,
        spectral: data.spectral,
        diagnostics: data.diagnostics,
        recommendations: data.recommendations,
        hasSpectralData: !!(data.spectral && (data.spectral.sub !== 'â€”' || data.spectral.bass !== 'â€”')),
        hasDiagnostics: data.diagnostics?.length > 0,
        hasRecommendations: data.recommendations?.length > 0
    });
    
    const date = new Date().toLocaleDateString('pt-BR');
    const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    
    // Formatar duraÃ§Ã£o
    const minutes = Math.floor(data.duration / 60);
    const seconds = Math.floor(data.duration % 60);
    const durationStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
    
    return `
<div id="report-pdf-container" style="background: #0B0C14;">
    
    <!-- Estilos para otimizaÃ§Ã£o desktop do PDF -->
    <style>
        /* Ajustes apenas para desktop (viewport >= 768px) */
        @media (min-width: 768px) {
            .frequency-spectrum-container {
                margin-top: -10px !important;
                margin-bottom: 20px !important;
            }
            
            .frequency-spectrum-cards {
                transform: scale(0.95);
                transform-origin: top center;
                margin-bottom: -10px;
            }
            
            .freq-card {
                height: 75px !important;
                padding: 10px !important;
            }
            
            /* Ajustes de rodapÃ© e recomendaÃ§Ãµes (pÃ¡gina 2) */
            .pdf-section-diagnostics .pdf-footer {
                margin-top: 25px !important;
                padding-bottom: 10px;
                position: relative;
                bottom: 0;
            }
            
            .pdf-section-recommendations {
                transform: scale(0.97);
                transform-origin: top center;
            }
        }
        
        /* Mobile mantÃ©m estilos originais (< 768px) */
        @media (max-width: 767px) {
            .frequency-spectrum-container {
                margin-top: 0 !important;
            }
            
            .frequency-spectrum-cards {
                transform: none;
            }
            
            .freq-card {
                height: auto !important;
            }
        }
    </style>
    
    <!-- âœ… PÃGINA 1: MÃ‰TRICAS PRINCIPAIS -->
    <div class="pdf-section-metrics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 32px; font-weight: 700; letter-spacing: -0.5px;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: #AAA;">InteligÃªncia Artificial para Produtores Musicais</p>
            </div>
            <div style="text-align: right;">
                <h2 style="color: #8B5CF6; margin: 0; font-size: 24px; font-weight: 600;">RelatÃ³rio de AnÃ¡lise</h2>
                <p style="font-size: 12px; color: #AAA; margin: 5px 0 0 0;">${date} Ã s ${time}</p>
            </div>
        </div>

        <!-- Score Card -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); padding: 20px 30px; border-radius: 12px; color: white; margin-bottom: 30px; box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="margin: 0; font-size: 48px; font-weight: 700;">${data.score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h1>
                <p style="margin: 8px 0 0 0; font-size: 18px; opacity: 0.95; font-weight: 500;">${data.classification}</p>
            </div>
            <div style="font-size: 64px; opacity: 0.9;">ğŸµ</div>
        </div>
    </div>

    <!-- InformaÃ§Ãµes do Arquivo -->
    <div style="background: rgba(255,255,255,0.05); padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #8B5CF6;">
        <p style="margin: 0; font-size: 12px; color: #AAA; text-transform: uppercase; letter-spacing: 0.5px;">ARQUIVO ANALISADO</p>
        <p style="margin: 8px 0 0 0; font-size: 16px; font-weight: 600; color: #FFF;">${data.fileName}</p>
        <p style="margin: 5px 0 0 0; font-size: 13px; color: #999;">
            â±ï¸ ${durationStr} min &nbsp;|&nbsp; ğŸšï¸ ${data.sampleRate}Hz &nbsp;|&nbsp; ğŸ”Š ${data.channels === 2 ? 'Stereo' : data.channels + ' canais'}
        </p>
    </div>

    <!-- Grid de MÃ©tricas -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
        
        <!-- Loudness Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ§</span> Loudness
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Integrado:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.integrated} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Curto Prazo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.shortTerm} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">MomentÃ¢neo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.momentary} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">LRA:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.lra} LU</span>
                </div>
            </div>
        </div>

        <!-- True Peak Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">âš™ï¸</span> True Peak
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Pico Real:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.truePeak.maxDbtp} dBTP</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Clipping (samples):</span>
                    <span style="font-weight: 600; color: ${data.truePeak.clipping.samples > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.samples}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Clipping (%):</span>
                    <span style="font-weight: 600; color: ${parseFloat(data.truePeak.clipping.percentage) > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.percentage}%</span>
                </div>
            </div>
        </div>

        <!-- DinÃ¢mica Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸšï¸</span> DinÃ¢mica
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Dynamic Range:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.range} dB</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Crest Factor:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.crest}</span>
                </div>
            </div>
        </div>

        <!-- Stereo Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ›ï¸</span> Stereo
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Largura Stereo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.width}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">CorrelaÃ§Ã£o:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.correlation}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Compat. Mono:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.monoCompatibility}%</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Espectro de FrequÃªncias -->
    <div class="frequency-spectrum-container" style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid rgba(139, 92, 246, 0.2);">
        <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
            <span style="margin-right: 10px; font-size: 22px;">ğŸ“ˆ</span> Espectro de FrequÃªncias
        </h3>
        <div class="frequency-spectrum-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; font-size: 13px;">
            ${(() => {
                const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 768;
                const cardPadding = isDesktop ? '10px' : '12px';
                const fontSizeLarge = isDesktop ? '14px' : '18px';
                const marginTop = isDesktop ? '5px' : '8px';
                
                const renderBand = (label, band, range) => {
                    if (!band || !band.db) return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #AAA; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">â€”</p>
                        </div>
                    `;
                    return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #8B5CF6; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">${band.db} dB</p>
                        </div>
                    `;
                };
                
                return [
                    renderBand('SUB', data.spectral.sub, '20-60Hz'),
                    renderBand('GRAVE', data.spectral.bass, '60-150Hz'),
                    renderBand('LOW MID', data.spectral.lowMid, '150-500Hz'),
                    renderBand('MÃ‰DIO', data.spectral.mid, '500-2kHz'),
                    renderBand('HIGH MID', data.spectral.highMid, '2-5kHz'),
                    renderBand('PRESENCE', data.spectral.presence, '5-10kHz'),
                    renderBand('AR', data.spectral.air, '10-20kHz')
                ].join('');
            })()}
        </div>
    </div>

    <!-- RodapÃ© da PÃ¡gina 1 -->
    <div style="text-align: center; padding-top: 40px; margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">SoundyAI Â© 2025</p>
        <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">PÃ¡gina 1/2 | MÃ©tricas Principais</p>
    </div>

    </div>
    <!-- FIM DA PÃGINA 1 -->

    <!-- âœ… PÃGINA 2: DIAGNÃ“STICO E RECOMENDAÃ‡Ã•ES -->
    <div class="pdf-section-diagnostics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header Simplificado (PÃ¡gina 2) -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 28px; font-weight: 700;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 13px; color: #AAA;">DiagnÃ³stico e RecomendaÃ§Ãµes da IA</p>
            </div>
            <div style="text-align: right;">
                <p style="font-size: 14px; color: #AAA; margin: 0;">${data.fileName}</p>
                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">PÃ¡gina 2/2</p>
            </div>
        </div>

        <!-- DiagnÃ³stico -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ§ </span> DiagnÃ³stico AutomÃ¡tico
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.diagnostics.map(d => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">â€¢</span> ${d}
                </li>`).join('')}
            </ul>
        </div>

        <!-- RecomendaÃ§Ãµes -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 50px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ’¡</span> RecomendaÃ§Ãµes da IA
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.recommendations.map(r => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">â€¢</span> ${r}
                </li>`).join('')}
            </ul>
        </div>

        <!-- RodapÃ© Final -->
        <div style="position: absolute; bottom: 30px; left: 40px; right: 40px; text-align: center; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">
                SoundyAI Â© 2025
            </p>
            <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">
                InteligÃªncia Artificial para Produtores Musicais | RelatÃ³rio gerado automaticamente
            </p>
        </div>

    </div>
    <!-- FIM DA PÃGINA 2 -->

</div>
    `;
}

// ï¿½ğŸ“‹ Gerar relatÃ³rio detalhado (LEGACY - mantido para compatibilidade)
function generateDetailedReport(analysis) {
    const now = new Date();
    let report = `ğŸµ PROD.AI - RELATÃ“RIO DE ANÃLISE DE ÃUDIO\n`;
    report += `${'='.repeat(50)}\n\n`;
    report += `ğŸ“… Data: ${now.toLocaleString('pt-BR')}\n`;
    report += `ğŸ”¬ AnÃ¡lise realizada com tecnologia Web Audio API\n\n`;
    
    report += `ğŸ“Š DADOS TÃ‰CNICOS PRINCIPAIS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `Peak Level: ${analysis.technicalData.peak.toFixed(2)} dB\n`;
    report += `RMS Level: ${analysis.technicalData.rms.toFixed(2)} dB\n`;
    report += `Dynamic Range: ${analysis.technicalData.dynamicRange.toFixed(2)} dB\n`;
    report += `Duration: ${analysis.duration.toFixed(2)} seconds\n`;
    report += `Sample Rate: ${analysis.sampleRate || 'N/A'} Hz\n`;
    report += `Channels: ${analysis.channels || 'N/A'}\n\n`;
    
    if (analysis.technicalData?.dominantFrequencies?.length > 0) {
        report += `ğŸ¯ FREQUÃŠNCIAS DOMINANTES:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.technicalData.dominantFrequencies.slice(0, 10).forEach((freq, i) => {
            report += `${i + 1}. ${Math.round(freq.frequency)} Hz (${freq.occurrences} ocorrÃªncias)\n`;
        });
        report += `\n`;
    }
    
    if (analysis.problems.length > 0) {
        report += `ğŸš¨ PROBLEMAS DETECTADOS:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.problems.forEach((problem, i) => {
            report += `${i + 1}. PROBLEMA: ${problem.message}\n`;
            report += `   SOLUÃ‡ÃƒO: ${problem.solution}\n`;
            report += `   SEVERIDADE: ${problem.severity}\n\n`;
        });
    }
    
    if (analysis.suggestions.length > 0) {
        report += `ğŸ’¡ SUGESTÃ•ES DE MELHORIA:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.suggestions.forEach((suggestion, i) => {
            report += `${i + 1}. ${suggestion.message}\n`;
            report += `   AÃ‡ÃƒO: ${suggestion.action}\n`;
            report += `   TIPO: ${suggestion.type}\n\n`;
        });
    }
    
    report += `ğŸ“ OBSERVAÃ‡Ã•ES TÃ‰CNICAS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `â€¢ Esta anÃ¡lise foi realizada usando Web Audio API\n`;
    report += `â€¢ Para anÃ¡lises mais avanÃ§adas, considere usar ferramentas profissionais\n`;
    report += `â€¢ Valores de referÃªncia: RMS ideal para streaming: -14 LUFS\n`;
    report += `â€¢ Peak ideal: mÃ¡ximo -1 dB para evitar clipping\n`;
    report += `â€¢ Dynamic range ideal: entre 8-15 dB para mÃºsica popular\n\n`;
    
    report += `ğŸµ Gerado por PROD.AI - Seu mentor de produÃ§Ã£o musical\n`;
    report += `ğŸ“± Para mais anÃ¡lises: prod-ai-teste.vercel.app\n`;
    
    return report;
}

// ğŸ’¬ Mostrar feedback temporÃ¡rio
function showTemporaryFeedback(message) {
    // Criar elemento de feedback
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #00d4ff, #0096cc);
        color: #000;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10001;
        animation: slideInRight 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    `;
    feedback.textContent = message;
    
    // Adicionar animaÃ§Ã£o CSS
    if (!document.getElementById('feedbackStyles')) {
        const style = document.createElement('style');
        style.id = 'feedbackStyles';
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(feedback);
    
    // Remover apÃ³s 3 segundos
    setTimeout(() => {
        feedback.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.parentNode.removeChild(feedback);
            }
        }, 300);
    }, 3000);
}

__dbg('ğŸµ Audio Analyzer Integration Script carregado!');

// Inicializar quando a pÃ¡gina carregar
document.addEventListener('DOMContentLoaded', function() {
    __dbg('ğŸµ DOM carregado, inicializando Audio Analyzer...');
    initializeAudioAnalyzerIntegration();
});

// Fallback: se o DOM jÃ¡ estiver carregado
if (document.readyState !== 'loading') {
    // se DOM jÃ¡ pronto, inicializar uma vez
    initializeAudioAnalyzerIntegration();
}

// UtilitÃ¡rio opcional: testar consistÃªncia das mÃ©tricas com reanÃ¡lises repetidas do mesmo arquivo
// Uso (dev): window.__testConsistency(file, 3).then(console.log)
if (typeof window !== 'undefined' && !window.__testConsistency) {
    window.__testConsistency = async function(file, runs = 3) {
        const out = { runs: [], deltas: {} };
        for (let i = 0; i < runs; i++) {
            const t0 = performance.now();
            // ğŸ†” CORREÃ‡ÃƒO: Adicionar runId para funÃ§Ãµes de teste de consistÃªncia
            const testOptions = prepareAnalysisOptions({}, `consistency_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, testOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufs: res?.technicalData?.lufsIntegrated ?? res?.metrics?.lufs ?? null,
                truePeakDbtp: res?.technicalData?.truePeakDbtp ?? res?.metrics?.truePeakDbtp ?? null,
                dr: res?.technicalData?.dynamicRange ?? res?.metrics?.dynamicRange ?? null,
                lra: res?.technicalData?.lra ?? null,
                processingMs: res?.processingMs ?? (t1 - t0)
            });
        }
        // calcular deltas
        const vals = (key) => out.runs.map(r => r[key]).filter(v => Number.isFinite(v));
        const stats = (arr) => arr.length ? { min: Math.min(...arr), max: Math.max(...arr), spread: Math.max(...arr)-Math.min(...arr) } : null;
        out.deltas.lufs = stats(vals('lufs'));
        out.deltas.truePeakDbtp = stats(vals('truePeakDbtp'));
        out.deltas.dr = stats(vals('dr'));
        out.deltas.lra = stats(vals('lra'));
        return out;
    };
}

// ğŸ¯ FINAL: Display Reference Results
window.displayReferenceResults = function(referenceResults) {
    window.logReferenceEvent('displaying_reference_results', {
        baseline_source: referenceResults.baseline_source,
        has_suggestions: referenceResults.referenceSuggestions?.length > 0
    });
    
    try {
        const { comparisonData, referenceSuggestions, baseline_source } = referenceResults;
        
        if (baseline_source !== 'reference') {
            throw new Error(`Invalid baseline source: ${baseline_source}. Expected 'reference'`);
        }
        
        if (!comparisonData) {
            throw new Error('Missing comparison data in reference results');
        }

        const results = document.getElementById('results');
        if (!results) {
            throw new Error('Results container not found');
        }

        // Exibir seÃ§Ã£o de comparaÃ§Ã£o
        displayComparisonSection(comparisonData, referenceSuggestions || []);
        
        // Se hÃ¡ sugestÃµes, exibir
        if (referenceSuggestions && referenceSuggestions.length > 0) {
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = referenceSuggestions.map(suggestion => 
                    `<div class="suggestion-item">
                        <h4>${suggestion.category}</h4>
                        <p>${suggestion.text}</p>
                        <div class="suggestion-details">
                            <small>DiferenÃ§a: ${suggestion.difference} | Threshold: ${suggestion.threshold}</small>
                        </div>
                    </div>`
                ).join('');
            }
        } else {
            // Audio idÃªntico - mostrar mensagem de sucesso
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = `
                    <div class="no-suggestions">
                        <h3>âœ… AnÃ¡lise de ReferÃªncia ConcluÃ­da</h3>
                        <p>Os Ã¡udios sÃ£o altamente similares. DiferenÃ§as dentro da tolerÃ¢ncia aceitÃ¡vel.</p>
                    </div>
                `;
            }
        }
        
        window.logReferenceEvent('reference_results_displayed_successfully');
        
    } catch (error) {
        console.error('Error displaying reference results:', error);
        window.logReferenceEvent('reference_display_error', { 
            error: error.message,
            baseline_source: referenceResults.baseline_source 
        });
        
        // Fallback display
        const results = document.getElementById('results');
        if (results) {
            results.innerHTML = `
                <div class="error-display">
                    <h3>âŒ Erro na ExibiÃ§Ã£o dos Resultados</h3>
                    <p>Erro: ${error.message}</p>
                    <p>Baseline Source: ${referenceResults.baseline_source}</p>
                </div>
            `;
        }
    }
};

// =============== FUNÃ‡Ã•ES DE NORMALIZAÃ‡ÃƒO DE DADOS ===============

/**
 * ğŸ¯ GERADOR DE SUGESTÃ•ES BÃSICAS
 * Gera sugestÃµes baseadas nas mÃ©tricas tÃ©cnicas (fallback se backend nÃ£o enviar)
 * 
 * @param {Object} data - Dados normalizados da anÃ¡lise
 * @returns {Array} - Array de sugestÃµes estruturadas
 */
function generateBasicSuggestions(data) {
    const suggestions = [];
    const technicalData = data.technicalData || {};
    
    console.log('[SUG-AUDIT] ğŸ” generateBasicSuggestions INÃCIO:', {
        hasTechnicalData: !!technicalData,
        hasLufs: technicalData.lufsIntegrated != null,
        hasTruePeak: technicalData.truePeakDbtp != null,
        hasDR: technicalData.dynamicRange != null,
        hasLRA: technicalData.lra != null,
        hasBands: !!(technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands)
    });
    
    // Regra 1: LUFS Integrado
    if (technicalData.lufsIntegrated != null) {
        const lufs = technicalData.lufsIntegrated;
        const ideal = -10.5; // PadrÃ£o para streaming
        const delta = Math.abs(lufs - ideal);
        
        if (delta > 1.0) {
            suggestions.push({
                type: 'loudness',
                category: 'loudness',
                message: `LUFS Integrado estÃ¡ em ${lufs.toFixed(1)} dB quando deveria estar prÃ³ximo de ${ideal.toFixed(1)} dB`,
                action: delta > 3 ? `Ajustar loudness em ${(ideal - lufs).toFixed(1)} dB via limitador` : `Refinar loudness final`,
                priority: delta > 3 ? 'crÃ­tica' : 'alta',
                band: 'full_spectrum',
                delta: (ideal - lufs).toFixed(1)
            });
        }
    }
    
    // Regra 2: True Peak
    if (technicalData.truePeakDbtp != null) {
        const tp = technicalData.truePeakDbtp;
        if (tp > -1.0) {
            suggestions.push({
                type: 'clipping',
                category: 'mastering',
                message: `True Peak em ${tp.toFixed(2)} dBTP estÃ¡ acima do limite seguro de -1.0 dBTP (risco de clipping em conversÃ£o)`,
                action: `Aplicar limitador com ceiling em -1.0 dBTP ou reduzir gain em ${(tp + 1.0).toFixed(2)} dB`,
                priority: 'crÃ­tica',
                band: 'full_spectrum',
                delta: (tp + 1.0).toFixed(2)
            });
        }
    }
    
    // Regra 3: Dynamic Range
    if (technicalData.dynamicRange != null) {
        const dr = technicalData.dynamicRange;
        const minDR = 6.0;
        
        if (dr < minDR) {
            suggestions.push({
                type: 'dynamics',
                category: 'mastering',
                message: `Dynamic Range estÃ¡ em ${dr.toFixed(1)} dB quando deveria estar acima de ${minDR.toFixed(1)} dB (mix muito comprimido)`,
                action: `Reduzir compressÃ£o/limitaÃ§Ã£o para recuperar ${(minDR - dr).toFixed(1)} dB de dinÃ¢mica`,
                priority: 'alta',
                band: 'full_spectrum',
                delta: (minDR - dr).toFixed(1)
            });
        }
    }
    
    // Regra 4: LRA (Loudness Range)
    if (technicalData.lra != null) {
        const lra = technicalData.lra;
        const minLRA = 3.0; // MÃ­nimo recomendado para evitar fadiga auditiva
        const maxLRA = 15.0; // MÃ¡ximo para manter consistÃªncia
        
        if (lra < minLRA) {
            suggestions.push({
                type: 'lra_low',
                category: 'dynamics',
                message: `LRA (Loudness Range) estÃ¡ em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (mix sem variaÃ§Ã£o dinÃ¢mica)`,
                action: `Aumentar variaÃ§Ã£o dinÃ¢mica em ${(minLRA - lra).toFixed(1)} LU via automaÃ§Ã£o ou compressÃ£o seletiva`,
                priority: 'mÃ©dia',
                band: 'full_spectrum',
                delta: (minLRA - lra).toFixed(1)
            });
        } else if (lra > maxLRA) {
            suggestions.push({
                type: 'lra_high',
                category: 'dynamics',
                message: `LRA (Loudness Range) estÃ¡ em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (variaÃ§Ã£o dinÃ¢mica excessiva)`,
                action: `Reduzir variaÃ§Ã£o dinÃ¢mica em ${(lra - maxLRA).toFixed(1)} LU via compressÃ£o multibanda`,
                priority: 'mÃ©dia',
                band: 'full_spectrum',
                delta: (lra - maxLRA).toFixed(1)
            });
        }
    }
    
    // Regras 5-11: Bandas Espectrais (7 bandas)
    const bands = technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands || {};
    
    if (Object.keys(bands).length > 0) {
        const idealRanges = {
            sub: { min: -38, max: -28, name: 'Sub (20-60Hz)' },
            bass: { min: -31, max: -25, name: 'Bass (60-150Hz)' },
            lowMid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' },
            low_mid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' }, // Alias
            mid: { min: -23, max: -17, name: 'Mid (500Hz-2kHz)' },
            highMid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' },
            high_mid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' }, // Alias
            presence: { min: -23, max: -17, name: 'Presence (5-10kHz)' },
            air: { min: -30, max: -24, name: 'Air (10-20kHz)' }
        };
        
        for (const [band, ideal] of Object.entries(idealRanges)) {
            const bandData = bands[band];
            if (bandData && typeof bandData.energy_db === 'number') {
                const value = bandData.energy_db;
                
                if (value < ideal.min) {
                    const delta = ideal.min - value;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} estÃ¡ em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB abaixo do mÃ­nimo)`,
                        action: `Aumentar ${ideal.name} em +${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'mÃ©dia',
                        band: band,
                        delta: `+${delta.toFixed(1)}`
                    });
                } else if (value > ideal.max) {
                    const delta = value - ideal.max;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} estÃ¡ em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB acima do mÃ¡ximo)`,
                        action: `Reduzir ${ideal.name} em -${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'mÃ©dia',
                        band: band,
                        delta: `-${delta.toFixed(1)}`
                    });
                }
            }
        }
    }
    
    console.log(`[SUG-AUDIT] âœ… generateBasicSuggestions FIM: ${suggestions.length} sugestÃµes geradas`);
    suggestions.forEach((sug, i) => {
        console.log(`[SUG-AUDIT] SugestÃ£o ${i + 1}/${suggestions.length}:`, {
            type: sug.type,
            category: sug.category,
            message: sug.message.substring(0, 60) + '...',
            priority: sug.priority
        });
    });
    
    return suggestions;
}

/**
 * ğŸ”§ FUNÃ‡ÃƒO CORRIGIDA: Normalizar dados do backend (compatÃ­vel com JSON antigo e novo)
 * Mapeia a resposta do backend para o formato que o front-end espera
 * âœ… CompatÃ­vel com JSON antigo e novo (prÃ©/pÃ³s Redis)
 */
function normalizeBackendAnalysisData(result) {
    // âœ… STEP 5/6: Blindagem total â€” clonar entrada para evitar mutaÃ§Ã£o de objetos compartilhados
    if (result && typeof result === 'object') {
        console.log('[NORMALIZE] ğŸ›¡ï¸ Clonando entrada para evitar contaminaÃ§Ã£o');
        result = JSON.parse(JSON.stringify(result));
    }
    // ï¿½ï¸ PROTEÃ‡ÃƒO: Detectar normalizaÃ§Ã£o duplicada
    if (result?.__normalized === true) {
        console.warn('[NORMALIZE] âš ï¸ Objeto jÃ¡ foi normalizado anteriormente - retornando clone');
        console.warn('[NORMALIZE] jobId:', result?.jobId, 'fileName:', result?.metadata?.fileName);
        // Retornar clone profundo para evitar mutaÃ§Ã£o
        return deepCloneSafe(result);
    }
    
    // ï¿½ğŸ” AUDITORIA: Capturar estado ANTES de normalizaÃ§Ã£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âš™ï¸ normalizeBackendAnalysisData - ENTRADA');
    console.log('ğŸ“Š result (antes de normalizar):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result,
        hasMetadata: !!result?.metadata,
        hasTechnicalData: !!result?.technicalData,
        alreadyNormalized: result?.__normalized === true
    });
    console.groupEnd();
    
    console.log("[BACKEND RESULT] Received analysis with data:", result);
    
    // ğŸ¯ PROTEÃ‡ÃƒO CRÃTICA: Preservar modo reference se segunda faixa estÃ¡ ativa
    const state = window.__soundyState || {};
    if (state.reference?.isSecondTrack && state.render?.mode !== 'reference') {
        console.warn('[FIX] Corrigindo mode: reference forÃ§ado (segunda faixa ativa)');
        state.render = state.render || {};
        state.render.mode = 'reference';
        window.__soundyState = state;
    }
    
    // âœ… CompatÃ­vel com JSON antigo e novo (prÃ©/pÃ³s Redis)
    const data = result?.data ?? result;
    const src = data.metrics || data.technicalData || data.loudness || data.spectral || data;

    if (!src) {
        console.error("[NORMALIZE] âŒ Nenhuma fonte de dados encontrada:", result);
        throw new Error("source is not defined");
    }

    console.log("[NORMALIZE] Source data extracted:", src);
    console.log("[NORMALIZE] Full data structure:", data);
    
    // ğŸ¯ CRÃTICO: Preservar data.genre e data.genreTargets (FONTE OFICIAL DO BACKEND)
    console.log("[NORMALIZE] ğŸµ Preservando genre do backend:", {
        'data.genre': data.genre,
        'result.data.genre': result?.data?.genre,
        'hasGenreTargets': !!(data.genreTargets || result?.data?.genreTargets)
    });

    const loudness = src.loudness || data.loudness || data.technicalData?.loudness || {};
    const dynamics = src.dynamics || data.dynamics || data.technicalData?.dynamics || {};
    const truePeak = src.truePeak || data.truePeak || data.technicalData?.truePeak || {};
    const energy = src.energy || data.energy || data.technicalData?.energy || {};
    const bands = src.bands || src.spectralBands || data.technicalData?.bands || data.technicalData?.spectralBands || data.spectralBands || {};

    const normalized = {
        // Preservar estrutura original
        ...data,
        
        // ğŸ¯ CRÃTICO: Garantir que data.genre e data.genreTargets sejam preservados
        data: {
            genre: data.genre || result?.data?.genre || null,
            genreTargets: data.genreTargets || result?.data?.genreTargets || null,
            // Preservar outros dados se existirem
            ...(data.data || {})
        },
        
        // ğŸ¯ MÃ©tricas normalizadas (RMS e LUFS separados)
        avgLoudness: energy.rms ?? 
                    src.avgLoudness ?? 
                    src.rms ??
                    data.technicalData?.avgLoudness ?? 
                    data.technicalData?.rms ??
                    data.energy?.rms ??
                    null,
        
        lufsIntegrated: loudness.integratedLUFS ?? 
                       loudness.integrated ?? 
                       src.lufsIntegrated ?? 
                       data.technicalData?.lufsIntegrated ?? 
                       data.loudness?.integrated ?? 
                       null,
                       
        lra: loudness.lra ?? 
             src.lra ?? 
             data.technicalData?.lra ?? 
             data.loudness?.lra ?? 
             null,
             
        truePeakDbtp: truePeak.maxDbtp ?? 
                     src.truePeakDbtp ?? 
                     data.technicalData?.truePeakDbtp ?? 
                     null,
                     
        dynamicRange: dynamics.range ?? 
                     src.dynamicRange ?? 
                     data.technicalData?.dynamicRange ?? 
                     null,
                     
        crestFactor: dynamics.crest ?? 
                    src.crestFactor ?? 
                    src.crest_factor ??
                    data.technicalData?.crestFactor ?? 
                    null,
                     
        bands: bands,
        
        // ğŸ¯ Preservar estruturas aninhadas originais para fallback
        loudness: data.loudness || loudness,
        dynamics: data.dynamics || dynamics,
        truePeak: data.truePeak || truePeak,
        energy: data.energy || energy,
        
        // Estruturas tÃ©cnicas
        technicalData: {
            // Copiar dados existentes
            ...(data.technicalData || src),
            
            // ğŸ¯ Garantir mÃ©tricas essenciais (MÃ‰TRICAS PRINCIPAIS)
            avgLoudness: energy.rms ?? 
                        src.avgLoudness ?? 
                        src.rms ??
                        data.technicalData?.avgLoudness ?? 
                        data.technicalData?.rms ??
                        data.energy?.rms ??
                        null,
            
            lufsIntegrated: loudness.integratedLUFS ?? 
                           loudness.integrated ?? 
                           src.lufsIntegrated ?? 
                           data.technicalData?.lufsIntegrated ?? 
                           data.loudness?.integrated ?? 
                           null,
                           
            lra: loudness.lra ?? 
                 src.lra ?? 
                 data.technicalData?.lra ?? 
                 data.loudness?.lra ?? 
                 null,
                 
            truePeakDbtp: truePeak.maxDbtp ?? 
                         src.truePeakDbtp ?? 
                         data.technicalData?.truePeakDbtp ?? 
                         null,
                         
            dynamicRange: dynamics.range ?? 
                         src.dynamicRange ?? 
                         data.technicalData?.dynamicRange ?? 
                         null,
                         
            crestFactor: dynamics.crest ?? 
                        src.crestFactor ?? 
                        src.crest_factor ??
                        data.technicalData?.crestFactor ?? 
                        null,
                         
            bandEnergies: bands,
            spectral_balance: bands,
            
            // ğŸ¯ CRITICAL FIX: Adicionar stereoCorrelation e stereoWidth
            stereoCorrelation: src.stereoCorrelation ?? 
                              data.technicalData?.stereoCorrelation ??
                              data.stereoCorrelation ??
                              null,
            
            stereoWidth: src.stereoWidth ??
                        data.technicalData?.stereoWidth ??
                        data.stereoWidth ??
                        null
        },
        
        // ğŸ¯ CRITICAL FIX: Adicionar objeto metrics com nomenclatura snake_case
        // Isso garante compatibilidade com calculateLoudnessScore/Dynamics/Stereo
        metrics: {
            lufs_integrated: loudness.integratedLUFS ?? 
                            loudness.integrated ?? 
                            src.lufsIntegrated ?? 
                            data.technicalData?.lufsIntegrated ?? 
                            data.loudness?.integrated ?? 
                            null,
            
            true_peak_dbtp: truePeak.maxDbtp ?? 
                           src.truePeakDbtp ?? 
                           data.technicalData?.truePeakDbtp ?? 
                           null,
            
            dynamic_range: dynamics.range ?? 
                          src.dynamicRange ?? 
                          data.technicalData?.dynamicRange ?? 
                          null,
            
            lra: loudness.lra ?? 
                src.lra ?? 
                data.technicalData?.lra ?? 
                data.loudness?.lra ?? 
                null,
            
            stereo_correlation: src.stereoCorrelation ?? 
                               data.technicalData?.stereoCorrelation ??
                               data.stereoCorrelation ??
                               null,
            
            stereo_width: src.stereoWidth ??
                         data.technicalData?.stereoWidth ??
                         data.stereoWidth ??
                         null,
            
            crest_factor: dynamics.crest ?? 
                         src.crestFactor ?? 
                         src.crest_factor ??
                         data.technicalData?.crestFactor ?? 
                         null
        },
        
        metadata: data.metadata ?? {},
        
        // Preservar outros campos importantes
        problems: data.problems || [],
        // âœ… PATCH CRÃTICO: Preservar suggestions do backend SEMPRE
        // NÃ£o usar || [] pois isso sobrescreve array vazio vindo do backend
        suggestions: Array.isArray(data.suggestions) ? data.suggestions : [],
        duration: data.duration || null,
        sampleRate: data.sampleRate || null,
        channels: data.channels || null,
        score: data.score || null,
        classification: data.classification || null
    };

    // âœ… AUDITORIA CRÃTICA PRÃ‰-GERAÃ‡ÃƒO: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] PRÃ‰-NORMALIZAÃ‡ÃƒO data.suggestions:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        willPreserve: Array.isArray(data.suggestions) && data.suggestions.length > 0
    });

    // âœ… GARANTIR SUGESTÃ•ES BÃSICAS SE BACKEND NÃƒO ENVIOU
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Entrada:`, {
        hasSuggestions: Array.isArray(normalized.suggestions),
        suggestionsLength: normalized.suggestions?.length || 0,
        source: 'backend'
    });
    
    if (!normalized.suggestions || normalized.suggestions.length === 0) {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Gerando sugestÃµes bÃ¡sicas no frontend...`);
        normalized.suggestions = generateBasicSuggestions(normalized);
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > âœ… ${normalized.suggestions.length} sugestÃµes bÃ¡sicas geradas no frontend`);
    } else {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > âœ… ${normalized.suggestions.length} sugestÃµes vindas do backend (preservadas)`);
    }
    
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > SaÃ­da:`, {
        suggestionsLength: normalized.suggestions.length,
        sampleFirst: normalized.suggestions[0]?.message?.substring(0, 50) + '...'
    });

    console.log("âœ… [NORMALIZE] Parsed data:", normalized);
    console.log("âœ… [NORMALIZE] Normalized metrics:", {
        avgLoudness: normalized.technicalData.avgLoudness,
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        crestFactor: normalized.technicalData.crestFactor,
        bands: normalized.technicalData.bandEnergies || normalized.technicalData.spectral_balance
    });
    
    // âœ… PATCH: garantir estrutura spectral_balance
    if (!normalized.technicalData.spectral_balance) {
        const sourceBands = result?.analysis?.bands || 
                           data?.bands || 
                           data?.frequencyBands || 
                           result?.bands ||
                           src?.spectral_balance ||
                           null;
        
        if (sourceBands) {
            normalized.technicalData.spectral_balance = sourceBands;
            console.log("âœ… [NORMALIZER] spectral_balance restaurado automaticamente");
        } else {
            console.warn("âš ï¸ [NORMALIZER] Nenhum dado de bandas detectado â€” criando estrutura vazia");
            normalized.technicalData.spectral_balance = {
                sub: 0,
                bass: 0,
                low_mid: 0,
                mid: 0,
                high_mid: 0,
                presence: 0,
                air: 0
            };
        }
    }
    
    // ï¿½ï¿½ LOGS ESPECÃFICOS DAS MÃ‰TRICAS PRINCIPAIS (AUDITORIA COMPLETA RMS + LUFS)
    console.log('[AUDITORIA-RMS-LUFS] RMS:', normalized.technicalData.avgLoudness, 'LUFS:', normalized.technicalData.lufsIntegrated);
    
    // âœ… AUDITORIA CRÃTICA: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] data.suggestions FROM BACKEND:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        type: typeof data.suggestions,
        sample: data.suggestions?.[0]
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > RMS=', normalized.technicalData.avgLoudness, {
        'energy.rms': energy.rms,
        'src.avgLoudness': src.avgLoudness,
        'src.rms': src.rms,
        'technicalData.avgLoudness': data.technicalData?.avgLoudness,
        'technicalData.rms': data.technicalData?.rms
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > LUFS=', normalized.technicalData.lufsIntegrated, {
        'loudness.integrated': loudness.integrated,
        'loudness.integratedLUFS': loudness.integratedLUFS,
        'src.lufsIntegrated': src.lufsIntegrated,
        'technicalData.lufsIntegrated': data.technicalData?.lufsIntegrated
    });
    
    console.log('[METRICS-FIX] normalizeBackendAnalysisData > CREST=', normalized.technicalData.crestFactor, {
        'dynamics.crest': dynamics.crest,
        'src.crestFactor': src.crestFactor,
        'src.crest_factor': src.crest_factor,
        'technicalData.crestFactor': data.technicalData?.crestFactor
    });

    // ï¿½ï¸ MARCAR: Flag para prevenir normalizaÃ§Ã£o duplicada
    normalized.__normalized = true;
    normalized.__normalizedAt = Date.now();
    console.log('[NORMALIZE] âœ… Objeto marcado como normalizado:', normalized.jobId);

    // ï¿½ğŸ” AUDITORIA: Estado APÃ“S normalizaÃ§Ã£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… normalizeBackendAnalysisData - SAÃDA');
    console.log('ğŸ“Š normalized (resultado):', {
        jobId: normalized?.jobId,
        fileName: normalized?.metadata?.fileName || normalized?.fileName,
        lufs: normalized?.technicalData?.lufsIntegrated,
        objectId: normalized,
        sameAsInput: normalized === result
    });
    console.log('ğŸ“Š result (input original - VERIFICAR SE MUDOU):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result
    });
    console.log('âš ï¸ VERIFICAÃ‡ÃƒO DE MUTAÃ‡ÃƒO:');
    console.log('  normalized === result?', normalized === result);
    console.log('  normalized.technicalData === result.technicalData?', normalized.technicalData === result.technicalData);
    console.log('  normalized.metadata === result.metadata?', normalized.metadata === result.metadata);
    if (normalized.technicalData === result.technicalData) {
        console.warn('ğŸš¨ MUTAÃ‡ÃƒO DETECTADA: technicalData compartilha referÃªncia!');
    }
    if (normalized.metadata === result.metadata) {
        console.warn('ğŸš¨ MUTAÃ‡ÃƒO DETECTADA: metadata compartilha referÃªncia!');
    }
    console.groupEnd();

    // ========================================
    // ğŸ”’ BLINDAGEM CRÃTICA: Quebrar compartilhamento de ponteiros
    // ========================================
    if (normalized && normalized.metadata) {
      // quebra compartilhamento de ponteiro
      normalized.metadata = { ...normalized.metadata };
    }
    if (normalized && normalized.technicalData) {
      normalized.technicalData = { ...normalized.technicalData };
    }
    if (normalized && normalized.bands) {
      normalized.bands = cloneDeepSafe(normalized.bands);
    }

    // ========================================
    // ğŸ”’ RETORNO FINAL: Clone profundo para garantir isolamento total
    // ========================================
    const normalizedOut = cloneDeepSafe(normalized);
    Object.defineProperty(normalizedOut, 'sameAsInput', { value: false, enumerable: false });
    return normalizedOut;
}

// =============== FUNÃ‡Ã•ES AUXILIARES ===============

// ğŸ§ª TESTE AUTOMÃTICO: Validar normalizaÃ§Ã£o com JSON real
function testNormalizationCompatibility() {
    console.log("ğŸ§ª [TEST] Iniciando teste automÃ¡tico de compatibilidade...");
    
    // Teste 1: Formato antigo (prÃ©-Redis)
    const oldFormat = {
        data: {
            metrics: {
                lufsIntegrated: -11.15,
                lra: 0.8,
                dynamicRange: 10.28
            },
            technicalData: {
                truePeakDbtp: -0.2,
                bands: {
                    bass: -12.5,
                    mid: -10.8,
                    treble: -15.2
                }
            }
        }
    };
    
    // Teste 2: Formato novo (pÃ³s-Redis)
    const newFormat = {
        score: 100,
        classification: "ReferÃªncia Mundial",
        loudness: { integrated: -11.15, lra: 0.8 },
        truePeak: { maxDbtp: -0.2 },
        dynamics: { range: 10.28 },
        spectralBands: {
            bass: -12.5,
            mid: -10.8,
            treble: -15.2
        },
        metadata: { duration: 180 }
    };
    
    // Teste 3: Formato hÃ­brido
    const hybridFormat = {
        metrics: { lufsIntegrated: -11.15 },
        loudness: { integrated: -12.0 },
        technicalData: { lra: 0.8, truePeakDbtp: -0.2 }
    };
    
    try {
        // âœ… Teste formato antigo
        const normalized1 = normalizeBackendAnalysisData(oldFormat);
        console.log("âœ… [TEST] Formato antigo normalizado:", {
            lufs: normalized1.technicalData.lufsIntegrated,
            lra: normalized1.technicalData.lra,
            truePeak: normalized1.technicalData.truePeakDbtp,
            dr: normalized1.technicalData.dynamicRange
        });
        
        // âœ… Teste formato novo
        const normalized2 = normalizeBackendAnalysisData(newFormat);
        console.log("âœ… [TEST] Formato novo normalizado:", {
            lufs: normalized2.technicalData.lufsIntegrated,
            lra: normalized2.technicalData.lra,
            truePeak: normalized2.technicalData.truePeakDbtp,
            dr: normalized2.technicalData.dynamicRange
        });
        
        // âœ… Teste formato hÃ­brido
        const normalized3 = normalizeBackendAnalysisData(hybridFormat);
        console.log("âœ… [TEST] Formato hÃ­brido normalizado:", {
            lufs: normalized3.technicalData.lufsIntegrated,
            lra: normalized3.technicalData.lra,
            truePeak: normalized3.technicalData.truePeakDbtp,
            dr: normalized3.technicalData.dynamicRange
        });
        
        // âœ… ValidaÃ§Ã£o de estrutura
        const isValidStructure = (norm) => {
            return norm.technicalData && 
                   typeof norm.technicalData.lufsIntegrated !== 'undefined' &&
                   typeof norm.technicalData.lra !== 'undefined' &&
                   typeof norm.technicalData.truePeakDbtp !== 'undefined';
        };
        
        if (isValidStructure(normalized1) && isValidStructure(normalized2) && isValidStructure(normalized3)) {
            console.log("âœ… [TEST] Todos os formatos passaram na validaÃ§Ã£o!");
            console.log("âœ… [TEST] Sistema de normalizaÃ§Ã£o estÃ¡ funcionando corretamente");
            return true;
        } else {
            console.error("âŒ [TEST] Falha na validaÃ§Ã£o de estrutura");
            return false;
        }
        
    } catch (error) {
        console.error("âŒ [TEST] Erro no teste de normalizaÃ§Ã£o:", error);
        return false;
    }
}

// ğŸš€ Executar teste automÃ¡tico quando o arquivo carregar
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        setTimeout(() => {
            testNormalizationCompatibility();
        }, 1000);
    });
}

// ğŸ¯ FUNÃ‡ÃƒO: Aplicar correÃ§Ã£o de fallback ao score
    
    tech.lufsShortTerm = getRealValue('lufsShortTerm', 'lufs_short_term') ||
                        (backendData.loudness?.shortTerm && Number.isFinite(backendData.loudness.shortTerm) ? backendData.loudness.shortTerm : null);
    
    tech.lufsMomentary = getRealValue('lufsMomentary', 'lufs_momentary') ||
                        (backendData.loudness?.momentary && Number.isFinite(backendData.loudness.momentary) ? backendData.loudness.momentary : null);
    
    // LRA - CORRIGIR MAPEAMENTO PARA ESTRUTURA REAL: loudness.lra + technicalData.lra
    tech.lra = getRealValue('lra', 'loudnessRange', 'lra_tolerance', 'loudness_range') ||
              (backendData.loudness?.lra && Number.isFinite(backendData.loudness.lra) ? backendData.loudness.lra : null) ||
              (backendData.technicalData?.lra && Number.isFinite(backendData.technicalData.lra) ? backendData.technicalData.lra : null);
    
    console.log('ğŸ“Š [NORMALIZE] MÃ©tricas mapeadas (apenas reais):', {
        peak: tech.peak,
        rms: tech.rms,
        dynamicRange: tech.dynamicRange,
        crestFactor: tech.crestFactor,
        truePeakDbtp: tech.truePeakDbtp,
        lufsIntegrated: tech.lufsIntegrated,
        lufsShortTerm: tech.lufsShortTerm,
        lufsMomentary: tech.lufsMomentary,
        lra: tech.lra
    });
    
    // ğŸ¯ LOG ESPECÃFICO PARA AUDITORIA: LRA com estrutura real
    if (tech.lra !== null) {
        console.log('âœ… [LRA] SUCESSO: LRA mapeado corretamente =', tech.lra);
    } else {
        console.warn('âŒ [LRA] PROBLEMA: LRA nÃ£o foi encontrado no backend data');
        console.log('ğŸ” [LRA] Debug - possÃ­veis caminhos verificados:', {
            'backendData.loudness.lra': backendData.loudness?.lra,
            'backendData.technicalData.lra': backendData.technicalData?.lra,
            'source (technicalData)': source.lra || source.loudnessRange,
            'loudnessObject': backendData.loudness,
            'technicalDataObject': backendData.technicalData
        });
    }
    
    // Headroom - APENAS VALORES REAIS
    tech.headroomDb = getRealValue('headroomDb', 'headroom_db');
    tech.headroomTruePeakDb = getRealValue('headroomTruePeakDb');
    
    // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
    tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                            (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
    
    tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                      (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);
    
    tech.balanceLR = getRealValue('balanceLR', 'balance_lr') ||
                    (backendData.stereo?.balance && Number.isFinite(backendData.stereo.balance) ? backendData.stereo.balance : null);
    
    // Spectral - APENAS VALORES REAIS
    tech.spectralCentroid = getRealValue('spectralCentroid', 'spectral_centroid');
    tech.spectralRolloff = getRealValue('spectralRolloff', 'spectral_rolloff');
    tech.zeroCrossingRate = getRealValue('zeroCrossingRate', 'zero_crossing_rate');
    tech.spectralFlux = getRealValue('spectralFlux', 'spectral_flux');
    tech.spectralFlatness = getRealValue('spectralFlatness', 'spectral_flatness');
    
    // Problemas tÃ©cnicos - APENAS VALORES REAIS
    tech.clippingSamples = getRealValue('clippingSamples', 'clipping_samples');
    tech.clippingPct = getRealValue('clippingPct', 'clipping_pct');
    tech.dcOffset = getRealValue('dcOffset', 'dc_offset');
    tech.thdPercent = getRealValue('thdPercent', 'thd_percent');
    
    // Sample peaks por canal - APENAS VALORES REAIS
    tech.samplePeakLeftDb = getRealValue('samplePeakLeftDb', 'sample_peak_left_db');
    tech.samplePeakRightDb = getRealValue('samplePeakRightDb', 'sample_peak_right_db');
    
    // ===== NOVAS MÃ‰TRICAS IMPLEMENTADAS =====
    
    // Spectral Bandwidth e outras mÃ©tricas espectrais
    tech.spectralBandwidth = getRealValue('spectralBandwidth', 'spectral_bandwidth');
    tech.spectralBandwidthHz = tech.spectralBandwidth; // Alias
    tech.spectralSpread = getRealValue('spectralSpread', 'spectral_spread');
    tech.spectralCrest = getRealValue('spectralCrest', 'spectral_crest');
    tech.spectralSkewness = getRealValue('spectralSkewness', 'spectral_skewness');
    tech.spectralKurtosis = getRealValue('spectralKurtosis', 'spectral_kurtosis');
    
    // ğŸµ SPECTRAL BALANCE - Mapear dados espectrais REAIS do backend
    if (source.spectral_balance || source.spectralBalance || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        
        const spectralSource = source.spectral_balance || source.spectralBalance || source.bands || 
                              backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        
        console.log('ğŸ” [SPECTRAL] Fonte espectral detectada:', spectralSource);
        
        // FunÃ§Ã£o especÃ­fica para dados espectrais
        const getSpectralValue = (...paths) => {
            for (const path of paths) {
                const value = path.split('.').reduce((obj, key) => obj?.[key], spectralSource);
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            return null;
        };
        
        // Se spectral_balance Ã© string (ex: "balanced"), mapear para objeto
        if (typeof spectralSource === 'string') {
            tech.spectral_balance = {
                description: spectralSource,
                status: spectralSource
            };
            console.log('ğŸ“Š [NORMALIZE] Spectral balance (string):', tech.spectral_balance);
        } else {
            tech.spectral_balance = {
                sub: getSpectralValue('sub', 'subBass', 'sub_bass'),
                bass: getSpectralValue('bass', 'low_bass', 'lowBass'),  // Normalizar para 'bass'
                lowMid: getSpectralValue('lowMid', 'low_mid', 'lowmid'),
                mid: getSpectralValue('mid', 'mids', 'middle'),
                highMid: getSpectralValue('highMid', 'high_mid', 'highmid'),
                presence: getSpectralValue('presence', 'presenca'),
                air: getSpectralValue('air', 'brilho', 'treble', 'high')
            };
            console.log('ğŸ“Š [NORMALIZE] Spectral balance mapeado:', tech.spectral_balance);
        }
        
        // ğŸ¯ LOG ESPECÃFICO PARA AUDITORIA: BANDAS ESPECTRAIS
        const bandasDetectadas = typeof tech.spectral_balance === 'object' && tech.spectral_balance.description ? 
            [`description: ${tech.spectral_balance.description}`] :
            Object.entries(tech.spectral_balance)
                .filter(([key, value]) => value !== null && key !== 'description' && key !== 'status')
                .map(([key, value]) => `${key}: ${value}`);
        
        if (bandasDetectadas.length > 0) {
            console.log(`âœ… [BANDAS] SUCESSO: ${bandasDetectadas.length} bandas mapeadas:`, bandasDetectadas.join(', '));
        } else {
            console.warn('âŒ [BANDAS] PROBLEMA: Nenhuma banda espectral foi mapeada');
            console.log('ğŸ” [BANDAS] Debug - caminhos verificados:', {
                'source.spectral_balance': source.spectral_balance,
                'source.spectralBalance': source.spectralBalance, 
                'source.bands': source.bands,
                'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
                'backendData.technicalData.bands': backendData.technicalData?.bands,
                'spectralSource': spectralSource
            });
        }
    } else {
        // NÃ£o definir se nÃ£o hÃ¡ dados reais
        tech.spectral_balance = null;
        console.log('âš ï¸ [NORMALIZE] Nenhum dado espectral real encontrado');
        console.log('ğŸ” [NORMALIZE] Debug espectral - caminhos verificados:', {
            'source.spectral_balance': source.spectral_balance,
            'source.spectralBalance': source.spectralBalance,
            'source.bands': source.bands,
            'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
            'backendData.technicalData.bands': backendData.technicalData?.bands
        });
    }
    
    // ğŸ¶ BAND ENERGIES - Mapear energias das bandas de frequÃªncia REAIS do backend
    if (source.bandEnergies || source.band_energies || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        const bandsSource = source.bandEnergies || source.band_energies || source.bands || 
                          backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        tech.bandEnergies = {};
        
        // Mapear bandas conhecidas - APENAS VALORES REAIS
        const bandMapping = {
            'sub': 'sub',
            'subBass': 'sub', 
            'sub_bass': 'sub',
            'low_bass': 'bass',  // Normalizar para 'bass'
            'lowBass': 'bass',
            'bass': 'bass',
            'upper_bass': 'bass',
            'upperBass': 'bass',
            'low_mid': 'lowMid',  // Normalizar para 'lowMid'
            'lowMid': 'lowMid',
            'lowmid': 'lowMid',
            'mid': 'mid',
            'mids': 'mid',
            'middle': 'mid',
            'high_mid': 'highMid',  // Normalizar para 'highMid'
            'highMid': 'highMid',
            'highmid': 'highMid',
            'upper_mid': 'highMid',
            'upperMid': 'highMid',
            'brilho': 'air',  // Normalizar para 'air'
            'brilliance': 'air',
            'air': 'air',
            'treble': 'air',
            'high': 'air',
            'presenca': 'presence',  // Normalizar para 'presence'
            'presence': 'presence'
        };
        
        Object.entries(bandMapping).forEach(([sourceKey, targetKey]) => {
            const bandData = bandsSource[sourceKey];
            if (bandData && typeof bandData === 'object') {
                // Pegar apenas valores reais, sem fallbacks
                const rms_db = Number.isFinite(bandData.rms_db) ? bandData.rms_db : 
                              Number.isFinite(bandData.energy_db) ? bandData.energy_db :
                              Number.isFinite(bandData.level) ? bandData.level : null;
                              
                const peak_db = Number.isFinite(bandData.peak_db) ? bandData.peak_db : null;
                const frequency_range = bandData.frequency_range || bandData.range || null;
                
                // SÃ³ adicionar se tiver pelo menos um valor real
                if (rms_db !== null || peak_db !== null) {
                    tech.bandEnergies[targetKey] = {
                        rms_db: rms_db,
                        peak_db: peak_db,
                        frequency_range: frequency_range
                    };
                }
            }
        });
        
        console.log('ğŸ“Š [NORMALIZE] Band energies mapeadas (apenas reais):', tech.bandEnergies);
        
        // Se nÃ£o conseguiu mapear nenhuma banda real, deixar null
        if (Object.keys(tech.bandEnergies).length === 0) {
            tech.bandEnergies = null;
            console.log('âš ï¸ [NORMALIZE] Nenhuma banda real encontrada - bandEnergies = null');
        }
    } else {
        tech.bandEnergies = null;
        console.log('âš ï¸ [NORMALIZE] Dados de bandas nÃ£o encontrados - bandEnergies = null');
    }
    
    // ğŸ¼ TONAL BALANCE - Estrutura simplificada para compatibilidade APENAS COM VALORES REAIS
    if (tech.bandEnergies && Object.keys(tech.bandEnergies).length > 0) {
        tech.tonalBalance = {
            sub: tech.bandEnergies.sub || null,
            low: tech.bandEnergies.low_bass || null,
            mid: tech.bandEnergies.mid || null,
            high: tech.bandEnergies.brilho || null
        };
        console.log('ğŸ“Š [NORMALIZE] Tonal balance baseado em bandEnergies reais:', tech.tonalBalance);
    } else {
        tech.tonalBalance = null;
        console.log('âš ï¸ [NORMALIZE] Nenhuma banda real para tonal balance - tonalBalance = null');
    }
    
    // ğŸ¯ FREQUÃŠNCIAS DOMINANTES - Estrutura completa com detailed
    if (source.dominantFrequencies || source.dominant_frequencies) {
        const rawData = source.dominantFrequencies || source.dominant_frequencies;
        
        // Se for string/nÃºmero simples, converter para structured format
        if (typeof rawData === 'string' || typeof rawData === 'number') {
            tech.dominantFrequencies = {
                value: rawData,
                unit: 'Hz'
            };
        } else if (rawData && typeof rawData === 'object') {
            // Se for object com detailed
            tech.dominantFrequencies = {
                value: rawData.value || rawData.primary || null,
                unit: rawData.unit || 'Hz',
                detailed: rawData.detailed || {
                    primary: rawData.primary || rawData.value || null,
                    secondary: rawData.secondary || null,
                    peaks: rawData.peaks || []
                }
            };
        } else {
            tech.dominantFrequencies = null;
        }
        console.log('ğŸ“Š [NORMALIZE] FrequÃªncias dominantes estruturadas:', tech.dominantFrequencies);
    } else {
        tech.dominantFrequencies = null;
        console.log('âš ï¸ [NORMALIZE] FrequÃªncias dominantes nÃ£o encontradas - dominantFrequencies = null');
    }
    
    // ğŸ”„ DC OFFSET - Estrutura completa com canais L/R
    if (source.dcOffset || source.dc_offset) {
        const rawDcData = source.dcOffset || source.dc_offset;
        
        // Se for nÃºmero simples, converter para structured format
        if (typeof rawDcData === 'number') {
            tech.dcOffset = {
                value: rawDcData,
                unit: 'dB',
                detailed: {
                    L: rawDcData,
                    R: rawDcData,
                    severity: Math.abs(rawDcData) > 0.1 ? 'High' : Math.abs(rawDcData) > 0.01 ? 'Medium' : 'Low'
                }
            };
        } else if (rawDcData && typeof rawDcData === 'object') {
            // Se for object com detailed
            tech.dcOffset = {
                value: rawDcData.value || (rawDcData.detailed ? Math.max(Math.abs(rawDcData.detailed.L || 0), Math.abs(rawDcData.detailed.R || 0)) : null),
                unit: rawDcData.unit || 'dB',
                detailed: rawDcData.detailed || {
                    L: rawDcData.L || rawDcData.left || rawDcData.value || 0,
                    R: rawDcData.R || rawDcData.right || rawDcData.value || 0,
                    severity: rawDcData.severity || 'Low'
                }
            };
        } else {
            tech.dcOffset = null;
        }
        console.log('ğŸ“Š [NORMALIZE] DC Offset estruturado:', tech.dcOffset);
    } else {
        tech.dcOffset = null;
        console.log('âš ï¸ [NORMALIZE] DC Offset nÃ£o encontrado - dcOffset = null');
    }
    
    // ğŸ“Š SPECTRAL UNIFORMITY - Estrutura detalhada
    if (source.spectralUniformity || source.spectral_uniformity) {
        const rawSpectralData = source.spectralUniformity || source.spectral_uniformity;
        
        // Se for nÃºmero simples, converter para structured format
        if (typeof rawSpectralData === 'number') {
            tech.spectralUniformity = {
                value: rawSpectralData,
                unit: 'ratio',
                detailed: {
                    variance: rawSpectralData,
                    distribution: rawSpectralData > 0.8 ? 'Uniform' : rawSpectralData > 0.5 ? 'Moderate' : 'Irregular',
                    analysis: rawSpectralData > 0.7 ? 'Well-balanced frequency distribution' : 'Uneven spectral content'
                }
            };
        } else if (rawSpectralData && typeof rawSpectralData === 'object') {
            // Se for object com detailed
            tech.spectralUniformity = {
                value: rawSpectralData.value || rawSpectralData.variance || null,
                unit: rawSpectralData.unit || 'ratio',
                detailed: rawSpectralData.detailed || {
                    variance: rawSpectralData.variance || rawSpectralData.value || null,
                    distribution: rawSpectralData.distribution || 'Unknown',
                    analysis: rawSpectralData.analysis || 'Spectral analysis pending'
                }
            };
        } else {
            tech.spectralUniformity = null;
        }
        console.log('ğŸ“Š [NORMALIZE] Spectral Uniformity estruturado:', tech.spectralUniformity);
    } else {
        tech.spectralUniformity = null;
        console.log('âš ï¸ [NORMALIZE] Spectral Uniformity nÃ£o encontrado - spectralUniformity = null');
    }
    
    // ğŸ”¢ SCORES E QUALIDADE - MAPEAMENTO CORRETO PARA NOVA ESTRUTURA
    normalized.qualityOverall = backendData.score && Number.isFinite(backendData.score) ? backendData.score : null;
    
    if (backendData.qualityBreakdown && typeof backendData.qualityBreakdown === 'object') {
        normalized.qualityBreakdown = backendData.qualityBreakdown;
        console.log('ğŸ“Š [NORMALIZE] Quality breakdown real encontrado:', normalized.qualityBreakdown);
    } else {
        normalized.qualityBreakdown = null;
        console.log('âš ï¸ [NORMALIZE] Quality breakdown nÃ£o encontrado - qualityBreakdown = null');
    }
    
    // ğŸ“Š DADOS AUXILIARES DO NOVO FORMATO
    if (backendData.metadata) {
        normalized.processingMs = backendData.metadata.processingTime || backendData.performance?.workerTotalTimeMs || null;
        normalized.fileName = backendData.metadata.fileName || null;
        normalized.fileSize = backendData.metadata.fileSize || null;
        normalized.buildVersion = backendData.metadata.buildVersion || null;
        normalized.pipelineVersion = backendData.metadata.pipelineVersion || null;
    }
    
    if (backendData.classification) {
        normalized.classification = backendData.classification;
    }
    
    // ğŸ¯ DADOS DE SCORING DETALHADOS
    if (backendData.scoring) {
        normalized.scoring = backendData.scoring;
        console.log('ğŸ“Š [NORMALIZE] Dados de scoring encontrados:', backendData.scoring);
    }
    
    // ğŸš¨ PROBLEMAS/SUGESTÃ•ES DO NOVO ANALYZER - Integrar com structure completa
    if (source.problemsAnalysis || source.problems_analysis) {
        const problemsData = source.problemsAnalysis || source.problems_analysis;
        
        // Adicionar problemas do analyzer
        if (problemsData.problems && Array.isArray(problemsData.problems)) {
            problemsData.problems.forEach(problem => {
                normalized.problems.push({
                    type: problem.type || 'analysis',
                    message: problem.message || problem.description || 'Problema detectado',
                    solution: problem.solution || problem.recommendation || 'Verificar configuraÃ§Ãµes',
                    severity: problem.severity || 'medium',
                    source: 'problems_analyzer'
                });
            });
        }
        
        // Adicionar sugestÃµes do analyzer
        if (problemsData.suggestions && Array.isArray(problemsData.suggestions)) {
            problemsData.suggestions.forEach(suggestion => {
                normalized.suggestions.push({
                    type: suggestion.type || 'optimization',
                    message: suggestion.message || suggestion.description || 'SugestÃ£o de melhoria',
                    action: suggestion.action || suggestion.recommendation || 'Aplicar otimizaÃ§Ã£o',
                    details: suggestion.details || suggestion.context || 'Detalhes nÃ£o disponÃ­veis',
                    source: 'problems_analyzer'
                });
            });
        }
        
        console.log('ğŸ“Š [NORMALIZE] Problems/Suggestions do analyzer integrados:', {
            problemsAdded: problemsData.problems?.length || 0,
            suggestionsAdded: problemsData.suggestions?.length || 0
        });
    }
    
    // ğŸš¨ PROBLEMAS - Garantir que existam alguns problemas/sugestÃµes para exibir
    if (normalized.problems.length === 0) {
        // Detectar problemas bÃ¡sicos baseados nas mÃ©tricas - APENAS SE VALORES EXISTEM
        if (Number.isFinite(tech.clippingSamples) && tech.clippingSamples > 0) {
            normalized.problems.push({
                type: 'clipping',
                message: `Clipping detectado (${tech.clippingSamples} samples)`,
                solution: 'Reduzir o ganho geral ou usar limitador',
                severity: 'high'
            });
        }
        
        if (tech.dcOffset && tech.dcOffset.detailed) {
            const maxDcOffset = Math.max(Math.abs(tech.dcOffset.detailed.L || 0), Math.abs(tech.dcOffset.detailed.R || 0));
            if (maxDcOffset > 0.01) {
                normalized.problems.push({
                    type: 'dc_offset', 
                    message: `DC Offset detectado (L: ${tech.dcOffset.detailed.L?.toFixed(4) || 'N/A'}, R: ${tech.dcOffset.detailed.R?.toFixed(4) || 'N/A'})`,
                    solution: 'Aplicar filtro DC remove',
                    severity: tech.dcOffset.detailed.severity === 'High' ? 'high' : 'medium'
                });
            }
        } else if (Number.isFinite(tech.dcOffset) && Math.abs(tech.dcOffset) > 0.01) {
            normalized.problems.push({
                type: 'dc_offset', 
                message: `DC Offset detectado (${tech.dcOffset.toFixed(4)})`,
                solution: 'Aplicar filtro DC remove',
                severity: 'medium'
            });
        }
        
        if (Number.isFinite(tech.thdPercent) && tech.thdPercent > 1) {
            normalized.problems.push({
                type: 'thd',
                message: `THD elevado (${tech.thdPercent.toFixed(2)}%)`,
                solution: 'Verificar saturaÃ§Ã£o e distorÃ§Ã£o',
                severity: 'medium'
            });
        }
    }
    
    // ğŸ’¡ SUGESTÃ•ES - Garantir algumas sugestÃµes bÃ¡sicas - APENAS SE VALORES EXISTEM
    console.log('[SUGGESTIONS-GEN] ğŸ” Verificando geraÃ§Ã£o de sugestÃµes bÃ¡sicas...');
    console.log('[SUGGESTIONS-GEN] normalized.suggestions.length =', normalized.suggestions.length);
    console.log('[SUGGESTIONS-GEN] MÃ©tricas disponÃ­veis:', {
        dynamicRange: tech.dynamicRange,
        stereoCorrelation: tech.stereoCorrelation,
        lufsIntegrated: tech.lufsIntegrated,
        truePeakDbtp: tech.truePeakDbtp
    });
    
    if (normalized.suggestions.length === 0) {
        console.log('[SUGGESTIONS-GEN] âš ï¸ Nenhuma sugestÃ£o do backend - gerando sugestÃµes bÃ¡sicas...');
        
        if (Number.isFinite(tech.dynamicRange) && tech.dynamicRange < 8) {
            normalized.suggestions.push({
                type: 'dynamics',
                message: 'Faixa dinÃ¢mica baixa detectada',
                action: 'Considerar reduzir compressÃ£o/limitaÃ§Ã£o',
                details: `DR atual: ${tech.dynamicRange.toFixed(1)}dB`
            });
            console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de DR adicionada');
        }
        
        if (Number.isFinite(tech.stereoCorrelation) && tech.stereoCorrelation > 0.9) {
            normalized.suggestions.push({
                type: 'stereo',
                message: 'Imagem estÃ©reo muito estreita',
                action: 'Aumentar espacializaÃ§Ã£o estÃ©reo',
                details: `CorrelaÃ§Ã£o: ${tech.stereoCorrelation.toFixed(3)}`
            });
            console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de correlaÃ§Ã£o estÃ©reo adicionada');
        }
        
        if (Number.isFinite(tech.lufsIntegrated) && tech.lufsIntegrated < -30) {
            normalized.suggestions.push({
                type: 'loudness',
                message: 'Loudness muito baixo',
                action: 'Aumentar volume geral',
                details: `LUFS atual: ${tech.lufsIntegrated.toFixed(1)}`
            });
            console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de loudness baixo adicionada');
        }
        
        // ğŸ†• NOVAS SUGESTÃ•ES BASEADAS EM MÃ‰TRICAS COMUNS
        if (Number.isFinite(tech.truePeakDbtp) && tech.truePeakDbtp > -1.0) {
            normalized.suggestions.push({
                type: 'true_peak',
                message: 'True Peak muito prÃ³ximo de 0 dBFS',
                action: 'Reduzir True Peak para -1.0 dBTP para evitar clipping em conversÃµes',
                details: `True Peak atual: ${tech.truePeakDbtp.toFixed(2)} dBTP`
            });
            console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de True Peak adicionada');
        }
        
        if (Number.isFinite(tech.lra) && tech.lra < 3) {
            normalized.suggestions.push({
                type: 'lra',
                message: 'Loudness Range (LRA) muito baixo',
                action: 'Mix muito comprimido - considerar reduzir compressÃ£o para mais dinÃ¢mica',
                details: `LRA atual: ${tech.lra.toFixed(1)} LU`
            });
            console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de LRA adicionada');
        }
        
        // SugestÃµes baseadas em bandas de frequÃªncia (se disponÃ­veis)
        if (tech.spectral_balance || tech.bandEnergies) {
            const bands = tech.spectral_balance || tech.bandEnergies;
            if (bands.bass != null && bands.bass < -6) {
                normalized.suggestions.push({
                    type: 'frequency_bass',
                    message: 'Pouca energia em graves (bass)',
                    action: 'Considerar aumentar frequÃªncias baixas (60-250 Hz)',
                    details: `Bass: ${bands.bass.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de bass baixo adicionada');
            }
            
            if (bands.presence != null && bands.presence < -8) {
                normalized.suggestions.push({
                    type: 'frequency_presence',
                    message: 'Pouca energia em presenÃ§a (presence)',
                    action: 'Aumentar clareza vocal e definiÃ§Ã£o (2-6 kHz)',
                    details: `Presence: ${bands.presence.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de presence baixo adicionada');
            }
        }
        
        // SugestÃµes baseadas nas novas mÃ©tricas
        if (tech.spectralUniformity && tech.spectralUniformity.detailed) {
            const uniformity = tech.spectralUniformity.value || tech.spectralUniformity.detailed.variance;
            if (Number.isFinite(uniformity) && uniformity < 0.5) {
                normalized.suggestions.push({
                    type: 'spectral_balance',
                    message: 'DistribuiÃ§Ã£o espectral irregular detectada',
                    action: 'Considerar equalizaÃ§Ã£o para melhor balanceamento',
                    details: `Uniformidade: ${uniformity.toFixed(3)}, ${tech.spectralUniformity.detailed.distribution || 'AnÃ¡lise pendente'}`
                });
                console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de uniformidade espectral adicionada');
            }
        }
        
        if (tech.dominantFrequencies && tech.dominantFrequencies.detailed) {
            const primary = tech.dominantFrequencies.detailed.primary;
            if (Number.isFinite(primary)) {
                if (primary < 80) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'FrequÃªncia dominante muito baixa',
                        action: 'Verificar filtro high-pass ou conteÃºdo sub-bass excessivo',
                        details: `Freq. primÃ¡ria: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de frequÃªncia baixa adicionada');
                } else if (primary > 8000) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'FrequÃªncia dominante muito alta',
                        action: 'Verificar conteÃºdo excessivo de agudos',
                        details: `Freq. primÃ¡ria: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de frequÃªncia alta adicionada');
                }
            }
        }
        
        // ğŸš¨ FALLBACK CRÃTICO: Sempre ter pelo menos uma sugestÃ£o
        if (normalized.suggestions.length === 0) {
            console.warn('[SUGGESTIONS-GEN] âš ï¸ Nenhuma sugestÃ£o gerada - criando fallback genÃ©rico');
            normalized.suggestions.push({
                type: 'general',
                message: 'AnÃ¡lise completa realizada',
                action: 'Suas mÃ©tricas de Ã¡udio foram analisadas com sucesso',
                details: 'Revise os cards de mÃ©tricas acima para mais detalhes'
            });
        }
        
        console.log('[SUGGESTIONS-GEN] âœ… Total de sugestÃµes geradas:', normalized.suggestions.length);
    } else {
        console.log('[SUGGESTIONS-GEN] âœ… Backend enviou', normalized.suggestions.length, 'sugestÃµes');
    }
    
    console.log('âœ… [NORMALIZE] NormalizaÃ§Ã£o concluÃ­da:', {
        hasTechnicalData: !!normalized.technicalData,
        hasSpectralBalance: !!normalized.technicalData.spectral_balance,
        hasBandEnergies: !!normalized.technicalData.bandEnergies,
        // Novas mÃ©tricas detalhadas
        hasDominantFreqs: !!normalized.technicalData.dominantFrequencies,
        hasDcOffset: !!normalized.technicalData.dcOffset,
        hasSpectralUniformity: !!normalized.technicalData.spectralUniformity,
        dominantFreqsStructure: normalized.technicalData.dominantFrequencies ? 'structured' : 'missing',
        dcOffsetStructure: normalized.technicalData.dcOffset ? 'structured' : 'missing',
        spectralUniformityStructure: normalized.technicalData.spectralUniformity ? 'structured' : 'missing',
        problemsCount: normalized.problems.length,
        suggestionsCount: normalized.suggestions.length,
        qualityScore: normalized.qualityOverall
    });
    
    // ğŸ¯ LOG DE RESUMO: MÃ©tricas normalizadas com sucesso
    const normalizedMetrics = Object.keys(normalized.technicalData).filter(key => 
        Number.isFinite(normalized.technicalData[key])
    );
    
    console.log('ğŸ“Š [NORMALIZE] Resumo da normalizaÃ§Ã£o:', {
        metricas_normalizadas: normalizedMetrics.length,
        metricas_disponiveis: normalizedMetrics,
        spectral_balance_ok: !!normalized.technicalData.spectral_balance,
        bandas_disponiveis: normalized.technicalData.bandEnergies ? 
            Object.keys(normalized.technicalData.bandEnergies).length : 0,
        problemas_detectados: normalized.problems.length,
        sugestoes_iniciais: normalized.suggestions.length
    });
    
    // ğŸ¯ LOG FINAL PARA DEBUG UI
    console.log("âœ… [UI_FIX] Normalized metrics:", {
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        spectral_balance: normalized.technicalData.spectral_balance,
        bandEnergies: normalized.technicalData.bandEnergies ? Object.keys(normalized.technicalData.bandEnergies) : null
    });
    
// =============== FUNÃ‡Ã•ES UTILITÃRIAS DO MODAL ===============

// ğŸ“ Ocultar Ã¡rea de upload do modal
function hideUploadArea() {
    __dbg('ğŸ“ Ocultando Ã¡rea de upload...');
    const uploadArea = document.getElementById('audioUploadArea');
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    } else {
        __dbg('âŒ Elemento audioUploadArea nÃ£o encontrado!');
    }
}

// ğŸ”„ Mostrar loading de anÃ¡lise
function showAnalysisLoading() {
    __dbg('ğŸ”„ Exibindo loading de anÃ¡lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (results) {
        results.style.display = 'none';
        __dbg('âœ… Results area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'block';
        __dbg('âœ… Loading area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
}

// â¹ï¸ Ocultar loading de anÃ¡lise
function hideAnalysisLoading() {
    __dbg('â¹ï¸ Ocultando loading de anÃ¡lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) {
        loading.style.display = 'none';
        __dbg('âœ… Loading area ocultada');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
}

// ğŸ“Š Mostrar resultados da anÃ¡lise
function showAnalysisResults() {
    __dbg('ğŸ“Š Exibindo resultados da anÃ¡lise...');
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'none';
        __dbg('âœ… Loading area ocultada');
    }
    
    if (results) {
        results.style.display = 'block';
        __dbg('âœ… Results area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisResults nÃ£o encontrado!');
    }
}

// ğŸ¨ INJETAR ESTILOS CSS PARA STATUS DE TRUE PEAK
function injectTruePeakStatusStyles() {
    if (document.getElementById('truePeakStatusStyles')) return; // jÃ¡ injetado
    
    const style = document.createElement('style');
    style.id = 'truePeakStatusStyles';
    style.textContent = `
        /* Status do True Peak */
        .status-excellent {
            color: #00ff88 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(0, 255, 136, 0.3);
        }
        
        .status-ideal {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .status-good {
            color: #17a2b8 !important;
            font-weight: 600;
        }
        
        .status-warning {
            color: #ffc107 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(255, 193, 7, 0.3);
        }
        
        .status-critical {
            color: #dc3545 !important;
            font-weight: 700;
            text-shadow: 0 0 3px rgba(220, 53, 69, 0.4);
            animation: criticalPulse 2s infinite;
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Responsive para mobile */
        @media (max-width: 600px) {
            .status-excellent,
            .status-ideal,
            .status-good,
            .status-warning,
            .status-critical {
                font-size: 11px;
                font-weight: 600;
            }
        }
    `;
    
    document.head.appendChild(style);
    console.log('ğŸ¨ Estilos CSS do True Peak injetados');
}

// Injetar estilos automaticamente quando o DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', injectTruePeakStatusStyles);
} else {
    injectTruePeakStatusStyles();
}

// ğŸ¯ SISTEMA DE TOOLTIPS PARA MÃ‰TRICAS
let currentTooltip = null;

window.showMetricTooltip = function(iconElement, event) {
    // Remover tooltip anterior se existir
    hideMetricTooltip();
    
    const tooltipText = iconElement.getAttribute('data-tooltip');
    if (!tooltipText) return;
    
    // Criar tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'metric-tooltip active';
    tooltip.textContent = tooltipText;
    document.body.appendChild(tooltip);
    
    currentTooltip = tooltip;
    
    // Posicionar tooltip
    const rect = iconElement.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Posicionar abaixo do Ã­cone, centralizado
    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
    let top = rect.bottom + 10;
    
    // Ajustar se sair da tela
    const padding = 10;
    if (left < padding) left = padding;
    if (left + tooltipRect.width > window.innerWidth - padding) {
        left = window.innerWidth - tooltipRect.width - padding;
    }
    if (top + tooltipRect.height > window.innerHeight - padding) {
        // Mostrar acima do Ã­cone se nÃ£o couber embaixo
        top = rect.top - tooltipRect.height - 10;
    }
    
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    
    // Ativar animaÃ§Ã£o
    setTimeout(() => tooltip.classList.add('active'), 10);
};

window.hideMetricTooltip = function() {
    if (currentTooltip) {
        currentTooltip.classList.remove('active');
        setTimeout(() => {
            if (currentTooltip && currentTooltip.parentNode) {
                currentTooltip.parentNode.removeChild(currentTooltip);
            }
            currentTooltip = null;
        }, 300);
    }
};

// Fechar tooltip ao rolar a pÃ¡gina
window.addEventListener('scroll', hideMetricTooltip);
window.addEventListener('resize', hideMetricTooltip);

// ğŸ§© CORREÃ‡ÃƒO #7: Logs de debug automÃ¡ticos para validaÃ§Ã£o
console.log("%c[SYSTEM CHECK] ğŸ” Debug ativo para validaÃ§Ã£o de fluxos genre/reference", "color:#7f00ff;font-weight:bold;");

// ========================================
// ğŸš¨ SISTEMA DE MONITORAMENTO CONTÃNUO DE JOBID
// ========================================
/**
 * Monitora se os jobIds permanecem diferentes em modo reference
 * Detecta e corrige contaminaÃ§Ã£o automaticamente
 */
(function startJobIdMonitor() {
    let monitorInterval = null;
    
    function checkJobIdIntegrity() {
        const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
        
        if (mode === 'reference') {
            const current = window.__CURRENT_JOB_ID__;
            const reference = window.__REFERENCE_JOB_ID__;
            
            // ValidaÃ§Ã£o crÃ­tica
            if (current && reference && current === reference) {
                console.error('ğŸš¨ [MONITOR] CONTAMINAÃ‡ÃƒO DETECTADA!');
                console.error('   currentJobId:', current);
                console.error('   referenceJobId:', reference);
                console.error('   Ambos sÃ£o IGUAIS - isso NÃƒO deveria acontecer!');
                console.trace();
                
                // Tenta recuperar do sessionStorage
                const recoveredJobId = sessionStorage.getItem('currentJobId');
                if (recoveredJobId && recoveredJobId !== reference) {
                    window.__CURRENT_JOB_ID__ = recoveredJobId;
                    console.log('âœ… [MONITOR] JobId recuperado do sessionStorage:', recoveredJobId);
                    console.log('âœ… [MONITOR] ContaminaÃ§Ã£o corrigida automaticamente');
                } else {
                    console.error('âŒ [MONITOR] NÃ£o foi possÃ­vel recuperar currentJobId do sessionStorage');
                    console.error('âŒ [MONITOR] Sistema pode estar em estado inconsistente');
                }
            }
        }
    }
    
    // Inicia monitoramento quando entrar em modo reference
    window.addEventListener('analysisMode', (e) => {
        if (e.detail?.mode === 'reference' && !monitorInterval) {
            console.log('ğŸ” [MONITOR] Iniciando monitoramento de jobIds (intervalo: 1s)');
            monitorInterval = setInterval(checkJobIdIntegrity, 1000);
        } else if (e.detail?.mode !== 'reference' && monitorInterval) {
            console.log('ğŸ” [MONITOR] Parando monitoramento de jobIds');
            clearInterval(monitorInterval);
            monitorInterval = null;
        }
    });
    
    // Inicia imediatamente se jÃ¡ estiver em modo reference
    if (window.currentAnalysisMode === 'reference') {
        console.log('ğŸ” [MONITOR] Modo reference detectado - iniciando monitoramento');
        monitorInterval = setInterval(checkJobIdIntegrity, 1000);
    }
    
    console.log('âœ… [MONITOR] Sistema de monitoramento de jobIds ativado');
})();

window.addEventListener("beforeunload", () => {
    console.log("ğŸ§¹ [CLEANUP] Encerrando sessÃ£o de anÃ¡lise e limpando estado.");
});

// ğŸ¯ PATCH DEFINITIVO: Carregar correÃ§Ã£o da tabela de referÃªncia
(function loadReferenceTablePatch() {
    console.log('ğŸ“¦ [INTEGRATION] Carregando patch definitivo da tabela de referÃªncia...');
    
    // Tentar carregar o patch definitivo
    const script = document.createElement('script');
    script.src = 'patch-tabela-referencia-final.js';
    script.onload = function() {
        console.log('âœ… [INTEGRATION] Patch definitivo carregado com sucesso');
    };
    script.onerror = function() {
        console.warn('âš ï¸ [INTEGRATION] NÃ£o foi possÃ­vel carregar patch-tabela-referencia-final.js');
        console.log('ğŸ’¡ [INTEGRATION] A correÃ§Ã£o jÃ¡ foi aplicada diretamente no cÃ³digo');
    };
    
    document.head.appendChild(script);
})();
