// üéµ AUDIO ANALYZER INTEGRATION - VERS√ÉO REFATORADA
// Sistema de an√°lise 100% baseado em processamento no back-end (Railway + Bucket)
// ‚ö†Ô∏è REMO√á√ÉO COMPLETA: Web Audio API, AudioContext, processamento local
// ‚úÖ NOVO FLUXO: Presigned URL ‚Üí Upload ‚Üí Job Creation ‚Üí Status Polling

// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
// üéØ MODE ENGINE: Fonte √∫nica de verdade para modo de an√°lise
// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
window.SOUNDY_MODE_ENGINE = {
    mode: "genre",          // "genre" | "reference_base" | "reference_compare"
    referenceBase: null,    // an√°lise completa da primeira m√∫sica
    referenceJobId: null,   // jobId da primeira m√∫sica

    setGenre() {
        this.mode = "genre";
        this.referenceBase = null;
        this.referenceJobId = null;
        setViewMode("genre");
    },

    startReferenceBase(firstAnalysis) {
        this.mode = "reference_base";
        this.referenceBase = firstAnalysis;
        this.referenceJobId = firstAnalysis.jobId;
        setViewMode("genre"); // ainda se comporta visualmente como g√™nero
    },

    startReferenceCompare() {
        this.mode = "reference_compare";
        setViewMode("reference");
    },

    isGenre() {
        return this.mode === "genre";
    },

    isReferenceBase() {
        return this.mode === "reference_base";
    },

    isReferenceCompare() {
        return this.mode === "reference_compare";
    },

    clear() {
        this.setGenre();
    }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üéØ GENRE TARGETS UTILS - FONTE √öNICA DE VERDADE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
/**
 * üéØ EXTRAI GENRE TARGETS DE UMA AN√ÅLISE (ALIAS COMPAT√çVEL)
 * 
 * Esta √© uma fun√ß√£o alias que chama extractGenreTargets() principal.
 * Mantida para compatibilidade com c√≥digo legado.
 * 
 * @param {Object} analysis - Objeto de an√°lise normalizado
 * @returns {Object|null} Targets do g√™nero ou null
 */
function extractGenreTargetsFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-ALIAS] Redirecionando para extractGenreTargets()');
    return extractGenreTargets(analysis);
}

/**
 * Extrai g√™nero de uma an√°lise
 * √öNICA FONTE OFICIAL: analysis.data.genre
 * @param {Object} analysis - Objeto de an√°lise normalizado
 * @returns {string|null} Nome do g√™nero ou null
 */
function extractGenreFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-UTILS] üéµ Extraindo g√™nero da an√°lise');
    
    // üéØ PRIORIDADE 1: analysis.data.genre (BACKEND OFICIAL)
    if (analysis?.data?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ‚úÖ G√™nero encontrado em analysis.data.genre:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // üéØ PRIORIDADE 2: analysis.genre (fallback direto)
    if (analysis?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ‚ö†Ô∏è G√™nero encontrado em analysis.genre (fallback):', analysis.genre);
        return analysis.genre;
    }
    
    // üéØ PRIORIDADE 3: analysis.metadata.genre
    if (analysis?.metadata?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ‚ö†Ô∏è G√™nero encontrado em analysis.metadata.genre (fallback):', analysis.metadata.genre);
        return analysis.metadata.genre;
    }
    
    console.warn('[GENRE-TARGETS-UTILS] ‚ùå Nenhum g√™nero encontrado na an√°lise');
    return null;
}

console.log('‚úÖ Genre Targets Utils carregado');

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üéØ GENRE-ONLY EXTRACTION UTILS - NUNCA AFETAM REFERENCE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * üéØ FUN√á√ÉO UTILIT√ÅRIA GLOBAL - OBTER TARGETS CORRETOS
 * 
 * CAMPO REAL DO POSTGRES: analysis.data.genreTargets
 * 
 * ‚ùå N√ÉO USAR:
 *    - analysis.targets
 *    - analysis.results.data.genreTargets
 *    - analysis.results.genreTargets
 * 
 * @param {Object} analysis - Objeto de an√°lise do backend
 * @returns {Object|null} Targets ou null
 */
function getCorrectTargets(analysis) {
    console.log('[TARGETS] üîç Buscando targets corretos...');
    
    if (analysis?.data?.genreTargets && typeof analysis.data.genreTargets === 'object') {
        console.log('[TARGETS] ‚úÖ Usando analysis.data.genreTargets (CAMPO REAL DO POSTGRES)');
        console.log('[TARGETS] Keys:', Object.keys(analysis.data.genreTargets));
        console.log('[TARGETS] Valores:', {
            lufs: analysis.data.genreTargets.lufs,
            truePeak: analysis.data.genreTargets.truePeak,
            dr: analysis.data.genreTargets.dr,
            stereo: analysis.data.genreTargets.stereo,
            hasBands: !!(analysis.data.genreTargets.bands)
        });
        return analysis.data.genreTargets;
    }
    
    console.warn('[TARGETS] ‚ö†Ô∏è Campo "data.genreTargets" n√£o encontrado no JSON recebido.');
    console.warn('[TARGETS] Estrutura recebida:', {
        hasAnalysis: !!analysis,
        analysisKeys: analysis ? Object.keys(analysis) : null,
        hasData: !!analysis?.data,
        hasDataGenreTargets: !!analysis?.data?.genreTargets
    });
    return null;
}

/**
 * üéØ EXTRAI TARGETS DO G√äNERO - FUN√á√ÉO DEFINITIVA E ROBUSTA
 * 
 * Esta fun√ß√£o NUNCA retorna undefined ou null.
 * Sempre retorna targets v√°lidos usando fallbacks se necess√°rio.
 * 
 * ESTRUTURA ACEITA:
 * - results.data.genreTargets (backend/worker/postgres)
 * - analysis.data.genreTargets (frontend)
 * 
 * FALLBACKS AUTOM√ÅTICOS:
 * - window.__activeRefData
 * - window.PROD_AI_REF_DATA[genre]
 * 
 * @param {Object} source - Objeto results (backend) ou analysis (frontend)
 * @returns {Object} Targets do g√™nero (nunca null)
 */
function extractGenreTargets(source) {
    console.log('[EXTRACT-TARGETS] üîç Iniciando extra√ß√£o de targets');
    console.log('[EXTRACT-TARGETS] Tipo de objeto:', source?.constructor?.name || typeof source);
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 1: IDENTIFICAR SE √â MODO GENRE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const mode = source?.mode || source?.data?.mode || 'unknown';
    console.log('[EXTRACT-TARGETS] Modo detectado:', mode);
    
    if (mode !== "genre") {
        console.log('[EXTRACT-TARGETS] ‚ö†Ô∏è N√£o √© modo genre, retornando null');
        return null;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 2: EXTRAIR G√äNERO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const genre = source?.data?.genre || 
                  source?.genre || 
                  source?.metadata?.genre || 
                  'unknown';
    
    console.log('[EXTRACT-TARGETS] G√™nero identificado:', genre);
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 3: BUSCAR TARGETS NA ORDEM DE PRIORIDADE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('[EXTRACT-TARGETS] üì¶ Testando fontes de targets:');
    console.log('[EXTRACT-TARGETS]   source.data.genreTargets:', !!source?.data?.genreTargets);
    console.log('[EXTRACT-TARGETS]   source.genreTargets:', !!source?.genreTargets);
    console.log('[EXTRACT-TARGETS]   source.targets:', !!source?.targets);
    console.log('[EXTRACT-TARGETS]   source.data.targets:', !!source?.data?.targets);
    
    let targets = null;
    let targetSource = null;
    
    // üéØ PRIORIDADE 1: source.data.genreTargets (BACKEND/FRONTEND OFICIAL)
    if (source?.data?.genreTargets && typeof source.data.genreTargets === 'object') {
        targets = source.data.genreTargets;
        targetSource = 'source.data.genreTargets (OFICIAL)';
    }
    // üéØ PRIORIDADE 2: source.genreTargets (fallback direto)
    else if (source?.genreTargets && typeof source.genreTargets === 'object') {
        targets = source.genreTargets;
        targetSource = 'source.genreTargets';
    }
    // üéØ PRIORIDADE 3: source.targets (nomenclatura alternativa)
    else if (source?.targets && typeof source.targets === 'object') {
        targets = source.targets;
        targetSource = 'source.targets';
    }
    // üéØ PRIORIDADE 4: source.data.targets
    else if (source?.data?.targets && typeof source.data.targets === 'object') {
        targets = source.data.targets;
        targetSource = 'source.data.targets';
    }
    // üéØ PRIORIDADE 5: source.result.genreTargets
    else if (source?.result?.genreTargets && typeof source.result.genreTargets === 'object') {
        targets = source.result.genreTargets;
        targetSource = 'source.result.genreTargets';
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 4: VALIDAR E RETORNAR SE ENCONTRADO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if (targets && isValidTargetsStructure(targets)) {
        console.log('[EXTRACT-TARGETS] ‚úÖ Targets encontrados em:', targetSource);
        console.log('[EXTRACT-TARGETS] üìä Estrutura:', {
            hasLufs: !!targets.lufs,
            hasTruePeak: !!targets.truePeak,
            hasDr: !!targets.dr,
            hasBands: !!targets.bands,
            keys: Object.keys(targets)
        });
        return targets;
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 5: FALLBACK 1 - window.__activeRefData
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.warn('[EXTRACT-TARGETS] ‚ö†Ô∏è Targets n√£o encontrados no objeto principal');
    console.log('[EXTRACT-TARGETS] üîÑ Tentando fallback: window.__activeRefData');
    
    if (typeof window !== 'undefined' && window.__activeRefData) {
        const activeData = window.__activeRefData;
        
        // Validar se g√™nero bate
        const activeGenre = activeData.genre || activeData.data?.genre;
        if (activeGenre === genre || !activeGenre) {
            console.log('[EXTRACT-TARGETS] ‚úÖ Usando window.__activeRefData');
            const fallbackTargets = activeData.targets || activeData.data?.genreTargets || activeData;
            
            if (isValidTargetsStructure(fallbackTargets)) {
                return fallbackTargets;
            }
        } else {
            console.warn('[EXTRACT-TARGETS] ‚ö†Ô∏è window.__activeRefData ignorado - g√™nero diferente:', activeGenre, '‚â†', genre);
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 6: FALLBACK 2 - window.PROD_AI_REF_DATA[genre]
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('[EXTRACT-TARGETS] üîÑ Tentando fallback: window.PROD_AI_REF_DATA[' + genre + ']');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        window.PROD_AI_REF_DATA[genre]) {
        
        console.log('[EXTRACT-TARGETS] ‚úÖ Usando window.PROD_AI_REF_DATA[' + genre + ']');
        const fallbackTargets = window.PROD_AI_REF_DATA[genre];
        
        if (isValidTargetsStructure(fallbackTargets)) {
            return fallbackTargets;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 7: FALLBACK 3 - window.PROD_AI_REF_DATA (objeto √∫nico)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('[EXTRACT-TARGETS] üîÑ Tentando fallback: window.PROD_AI_REF_DATA (objeto √∫nico)');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA === 'object') {
        
        // Verificar se √© um objeto √∫nico (n√£o um dicion√°rio de g√™neros)
        if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
            console.log('[EXTRACT-TARGETS] ‚úÖ Usando window.PROD_AI_REF_DATA (objeto √∫nico)');
            return window.PROD_AI_REF_DATA;
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ETAPA 8: ERRO CR√çTICO - NENHUM TARGET ENCONTRADO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.error('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
    console.error('‚ïë  ‚ùå ERRO CR√çTICO: NENHUM TARGET ENCONTRADO               ‚ïë');
    console.error('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
    console.error('[EXTRACT-TARGETS] Modo:', mode);
    console.error('[EXTRACT-TARGETS] G√™nero:', genre);
    console.error('[EXTRACT-TARGETS] source.data:', source?.data);
    console.error('[EXTRACT-TARGETS] source.genreTargets:', source?.genreTargets);
    console.error('[EXTRACT-TARGETS] window.__activeRefData:', typeof window !== 'undefined' ? !!window.__activeRefData : 'N/A');
    console.error('[EXTRACT-TARGETS] window.PROD_AI_REF_DATA:', typeof window !== 'undefined' ? !!window.PROD_AI_REF_DATA : 'N/A');
    
    // Retornar estrutura vazia v√°lida ao inv√©s de null
    console.warn('[EXTRACT-TARGETS] ‚ö†Ô∏è Retornando estrutura vazia v√°lida');
    return {
        lufs: { target: -14, tolerance: 1 },
        truePeak: { target: -1, tolerance: 0.5 },
        dr: { target: 8, tolerance: 2 },
        stereo: { target: 100, tolerance: 10 },
        bands: {}
    };
}

/**
 * Valida se a estrutura de targets √© v√°lida
 * @param {Object} targets - Objeto de targets
 * @returns {boolean} True se v√°lido
 */
function isValidTargetsStructure(targets) {
    if (!targets || typeof targets !== 'object') {
        return false;
    }
    
    // Verificar se tem pelo menos uma das propriedades essenciais
    const hasEssentials = targets.lufs || 
                         targets.truePeak || 
                         targets.dr || 
                         targets.bands ||
                         targets.legacy_compatibility;
    
    return hasEssentials;
}

/**
 * Extrai nome do g√™nero SOMENTE no modo genre
 * ‚ö†Ô∏è IMPORTANTE: Retorna genre normal se n√£o for modo genre
 * @param {Object} analysis - Objeto de an√°lise
 * @returns {string} Nome do g√™nero
 */
function extractGenreName(analysis) {
    // üõ°Ô∏è BARREIRA: Se n√£o for modo genre, retorna genre normal
    if (analysis?.mode !== "genre") {
        return analysis?.genre || null;
    }
    
    console.log('[GENRE-ONLY-UTILS] üéµ Extraindo nome do g√™nero no modo GENRE');
    
    // üéØ FONTE OFICIAL: analysis.data.genre
    if (analysis?.data?.genre) {
        console.log('[GENRE-ONLY-UTILS] ‚úÖ G√™nero encontrado:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // Fallback para analysis.genre
    if (analysis?.genre) {
        console.log('[GENRE-ONLY-UTILS] ‚ö†Ô∏è Usando fallback analysis.genre:', analysis.genre);
        return analysis.genre;
    }
    
    console.warn('[GENRE-ONLY-UTILS] ‚ùå G√™nero n√£o encontrado, usando "default"');
    return "default";
}

/**
 * Carrega targets padr√£o para um g√™nero
 * @param {string} genreName - Nome do g√™nero
 * @returns {Object} Targets padr√£o
 */
function loadDefaultGenreTargets(genreName = "default") {
    console.log('[GENRE-ONLY-UTILS] üì¶ Carregando targets padr√£o para:', genreName);
    
    // Tentar carregar de window.GENRE_TARGETS_DB
    if (window.GENRE_TARGETS_DB && window.GENRE_TARGETS_DB[genreName]) {
        console.log('[GENRE-ONLY-UTILS] ‚úÖ Targets carregados de GENRE_TARGETS_DB');
        return window.GENRE_TARGETS_DB[genreName];
    }
    
    // Fallback: targets gen√©ricos
    console.warn('[GENRE-ONLY-UTILS] ‚ö†Ô∏è Usando targets gen√©ricos');
    return {
        lufs_target: -14,
        true_peak_target: -1,
        dr_target: 8,
        lra_target: 6,
        stereo_target: 0.85,
        bands: {}
    };
}

console.log('‚úÖ Genre-Only Extraction Utils carregado');

// üîç AUDITORIA DE STORAGE - Sistema de detec√ß√£o de inconsist√™ncias
(function initStorageAudit() {
    console.group('%c[AUDITORIA-STORAGE] üß† Inicializando sistema de auditoria de storage', 'color:#A974FF;font-weight:bold;font-size:14px;');
    
    // 1Ô∏è‚É£ Verificar localStorage atual
    const localRefJobId = localStorage.getItem('referenceJobId');
    const localRefAnalysis = localStorage.getItem('referenceAnalysis');
    
    console.log('%c[AUDITORIA-STORAGE] üì¶ localStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', localRefJobId || '‚ùå vazio');
    console.log('   referenceAnalysis:', localRefAnalysis ? `‚úÖ ${localRefAnalysis.length} bytes` : '‚ùå vazio');
    
    // 2Ô∏è‚É£ Verificar sessionStorage atual
    const sessionRefJobId = sessionStorage.getItem('referenceJobId');
    const sessionRefAnalysis = sessionStorage.getItem('referenceAnalysis');
    const sessionCurrentJobId = sessionStorage.getItem('currentJobId');
    
    console.log('%c[AUDITORIA-STORAGE] üì¶ sessionStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', sessionRefJobId || '‚ùå vazio');
    console.log('   referenceAnalysis:', sessionRefAnalysis ? `‚úÖ ${sessionRefAnalysis.length} bytes` : '‚ùå vazio');
    console.log('   currentJobId:', sessionCurrentJobId || '‚ùå vazio');
    
    // 3Ô∏è‚É£ Verificar vari√°veis globais
    console.log('%c[AUDITORIA-STORAGE] üåê Vari√°veis globais:', 'color:#FFD700;font-weight:bold;');
    console.log('   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || '‚ùå undefined');
    console.log('   window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__ || '‚ùå undefined');
    
    // 4Ô∏è‚É£ Detectar inconsist√™ncias
    console.log('%c[AUDITORIA-STORAGE] üîç An√°lise de consist√™ncia:', 'color:#A974FF;font-weight:bold;');
    
    if (localRefJobId && !sessionRefJobId) {
        console.log('%c   ‚ö†Ô∏è PROBLEMA: referenceJobId apenas em localStorage', 'color:#FF5555;font-weight:bold;');
        console.log('   ‚ö†Ô∏è Risco: Compartilhamento entre abas (localStorage √© global)');
        console.log('   ‚úÖ Solu√ß√£o: Migrar para sessionStorage (isolamento por aba)');
    }
    
    if (localRefJobId && sessionRefJobId && localRefJobId !== sessionRefJobId) {
        console.log('%c   ‚ùå INCONSIST√äNCIA CR√çTICA: JobIds diferentes!', 'color:#FF5555;font-weight:bold;');
        console.log('   localStorage.referenceJobId:', localRefJobId);
        console.log('   sessionStorage.referenceJobId:', sessionRefJobId);
    }
    
    if (!localRefJobId && !sessionRefJobId && !window.__REFERENCE_JOB_ID__) {
        console.log('%c   ‚úÖ Estado limpo - sem refer√™ncia ativa', 'color:#00FF88;');
    }
    
    if (localRefJobId || sessionRefJobId || window.__REFERENCE_JOB_ID__) {
        console.log('%c   üìä Refer√™ncia ativa detectada:', 'color:#00C9FF;');
        console.log('   Prioridade: sessionStorage > window > localStorage');
    }
    
    console.groupEnd();
    
    // 5Ô∏è‚É£ Criar utilit√°rio global de storage com fallback
    window.StorageManager = {
        // Salvar referenceJobId
        setReferenceJobId(jobId) {
            console.log('%c[STORAGE-MANAGER] üíæ Salvando referenceJobId:', 'color:#00FF88;font-weight:bold;', jobId);
            try {
                sessionStorage.setItem('referenceJobId', jobId);
                console.log('   ‚úÖ Salvo em sessionStorage (isolado por aba)');
            } catch (e) {
                console.warn('   ‚ö†Ô∏è Falha no sessionStorage, usando localStorage como fallback:', e.message);
                localStorage.setItem('referenceJobId', jobId);
            }
        },
        
        // Ler referenceJobId (prioridade: sessionStorage > window > localStorage)
        getReferenceJobId() {
            const sessionId = sessionStorage.getItem('referenceJobId');
            const windowId = window.__REFERENCE_JOB_ID__;
            const localId = localStorage.getItem('referenceJobId');
            
            const result = sessionId || windowId || localId;
            
            console.log('%c[STORAGE-MANAGER] üìñ Lendo referenceJobId:', 'color:#FFD700;', result || '‚ùå n√£o encontrado');
            console.log('   sessionStorage:', sessionId || '‚ùå');
            console.log('   window.__REFERENCE_JOB_ID__:', windowId || '‚ùå');
            console.log('   localStorage:', localId || '‚ùå');
            
            return result;
        },
        
        // Salvar referenceAnalysis
        setReferenceAnalysis(analysis) {
            const json = JSON.stringify(analysis);
            console.log('%c[STORAGE-MANAGER] üíæ Salvando referenceAnalysis:', 'color:#00FF88;font-weight:bold;', `${json.length} bytes`);
            try {
                sessionStorage.setItem('referenceAnalysis', json);
                console.log('   ‚úÖ Salvo em sessionStorage');
            } catch (e) {
                console.warn('   ‚ö†Ô∏è Falha no sessionStorage (quota?), usando localStorage:', e.message);
                try {
                    localStorage.setItem('referenceAnalysis', json);
                } catch (e2) {
                    console.error('   ‚ùå Falha em ambos storages:', e2.message);
                }
            }
        },
        
        // Ler referenceAnalysis
        getReferenceAnalysis() {
            const sessionData = sessionStorage.getItem('referenceAnalysis');
            const localData = localStorage.getItem('referenceAnalysis');
            
            const result = sessionData || localData;
            
            if (result) {
                try {
                    const parsed = JSON.parse(result);
                    console.log('%c[STORAGE-MANAGER] üìñ referenceAnalysis recuperado:', 'color:#FFD700;', 
                        `${result.length} bytes`, 
                        sessionData ? '(sessionStorage)' : '(localStorage fallback)');
                    return parsed;
                } catch (e) {
                    console.error('%c[STORAGE-MANAGER] ‚ùå Erro ao parsear referenceAnalysis:', 'color:#FF5555;', e.message);
                    return null;
                }
            }
            
            console.log('%c[STORAGE-MANAGER] üìñ referenceAnalysis:', 'color:#FFD700;', '‚ùå n√£o encontrado');
            return null;
        },
        
        // Limpar refer√™ncia
        clearReference() {
            // üö® BLINDAGEM ABSOLUTA: NUNCA limpar em modo genre
            if (window.__CURRENT_MODE__ === 'genre') {
                console.warn('[GENRE-PROTECT] ‚ö†Ô∏è StorageManager.clearReference() BLOQUEADO em modo genre');
                console.warn('[GENRE-PROTECT]   - Preservando:', {
                    selectedGenre: window.__CURRENT_SELECTED_GENRE,
                    mode: window.__CURRENT_MODE__
                });
                return; // N√ÉO executar limpeza
            }

            console.log('%c[STORAGE-MANAGER] üóëÔ∏è Limpando refer√™ncia...', 'color:#FF9500;font-weight:bold;');
            try {
                sessionStorage.removeItem('referenceJobId');
                sessionStorage.removeItem('referenceAnalysis');
                console.log('   ‚úÖ sessionStorage limpo');
            } catch (e) {
                console.warn('   ‚ö†Ô∏è Erro ao limpar sessionStorage:', e.message);
            }
            
            try {
                localStorage.removeItem('referenceJobId');
                localStorage.removeItem('referenceAnalysis');
                console.log('   ‚úÖ localStorage limpo');
            } catch (e) {
                console.warn('   ‚ö†Ô∏è Erro ao limpar localStorage:', e.message);
            }
            
            delete window.__REFERENCE_JOB_ID__;
            console.log('   ‚úÖ window.__REFERENCE_JOB_ID__ removido');
        }
    };
    
    console.log('%c[AUDITORIA-STORAGE] ‚úÖ Sistema de storage auditado e StorageManager criado', 'color:#00FF88;font-weight:bold;');
})();

// ========================================
// üÜî VIRTUAL IDS E √çNDICE DE PAP√âIS (ANTI-SELF-COMPARE)
// ========================================
// Solu√ß√£o definitiva: Virtual ID composto por jobId + role (USER ou REF)
// Mesmo que backend reutilize jobId, o VID mant√©m separa√ß√£o por papel
window.CacheIndex ??= { USER: null, REF: null };

// ========================================
// üß† SISTEMA DE ARMAZENAMENTO ISOLADO FINAL
// ========================================
/**
 * Sistema simplificado e definitivo para armazenamento de an√°lises.
 * Duas vari√°veis isoladas: primeira e segunda m√∫sica.
 * NUNCA mais usar window.__FIRST_ANALYSIS_FROZEN__ ou stateV3.reference.
 */
window.SoundyAI_Store = {
    first: null,   // primeira m√∫sica
    second: null,  // segunda m√∫sica
};

/**
 * Salva primeira an√°lise (refer√™ncia)
 * @param {object} data - Dados da an√°lise
 */
function saveFirstAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.first = JSON.parse(JSON.stringify(data));
    
    console.log('‚úÖ [STORE] Primeira an√°lise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.first?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.first?.technicalData?.lufsIntegrated);
}

/**
 * Salva segunda an√°lise (compara√ß√£o)
 * @param {object} data - Dados da an√°lise
 */
function saveSecondAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.second = JSON.parse(JSON.stringify(data));
    
    console.log('‚úÖ [STORE] Segunda an√°lise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.second?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.second?.technicalData?.lufsIntegrated);
}

// ========================================
// üî¨ GERADOR DE SUGEST√ïES COMPARATIVAS A vs B
// ========================================

/**
 * Gera sugest√µes de IA baseadas no delta entre duas an√°lises (A vs B)
 * @param {object} userAnalysis - An√°lise da faixa atual (B)
 * @param {object} refAnalysis - An√°lise da refer√™ncia (A)
 * @returns {array} - Array de sugest√µes comparativas enriquecidas
 */
function buildComparativeAISuggestions(userAnalysis, refAnalysis) {
    console.log('[A/B-SUGGESTIONS] üî¨ Gerando sugest√µes comparativas...');
    
    if (!userAnalysis || !refAnalysis) {
        console.warn('[A/B-SUGGESTIONS] ‚ö†Ô∏è An√°lises incompletas - abortando gera√ß√£o');
        return [];
    }

    // üîç Leitura segura de m√©tricas (m√∫ltiplos caminhos poss√≠veis)
    const extractMetric = (analysis, metric) => {
        const paths = {
            lufs: [
                analysis?.lufsIntegrated,
                analysis?.avgLoudness,
                analysis?.loudness?.integrated,
                analysis?.technicalData?.lufsIntegrated,
                analysis?.metrics?.loudness?.integrated
            ],
            lra: [
                analysis?.lra,
                analysis?.loudness?.lra,
                analysis?.technicalData?.lra,
                analysis?.metrics?.loudness?.lra
            ],
            tp: [
                analysis?.truePeakDbtp,
                analysis?.truePeak,
                analysis?.loudness?.truePeak,
                analysis?.truePeak?.maxDbtp,
                analysis?.technicalData?.truePeakDbtp,
                analysis?.metrics?.truePeak?.maxDbtp
            ],
            dr: [
                analysis?.dynamicRange,
                analysis?.dynamics?.dynamicRange,
                analysis?.dynamics?.range,
                analysis?.technicalData?.dynamicRange,
                analysis?.metrics?.dynamics?.range
            ],
            cf: [
                analysis?.crestFactor,
                analysis?.dynamics?.crestFactor,
                analysis?.dynamics?.crest,
                analysis?.technicalData?.crestFactor,
                analysis?.metrics?.dynamics?.crest
            ]
        };

        const values = paths[metric] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) {
                return val;
            }
        }
        return null;
    };

    // üìä Extrair m√©tricas de ambas an√°lises
    const U = {
        lufs: extractMetric(userAnalysis, 'lufs'),
        lra: extractMetric(userAnalysis, 'lra'),
        tp: extractMetric(userAnalysis, 'tp'),
        dr: extractMetric(userAnalysis, 'dr'),
        cf: extractMetric(userAnalysis, 'cf')
    };

    const R = {
        lufs: extractMetric(refAnalysis, 'lufs'),
        lra: extractMetric(refAnalysis, 'lra'),
        tp: extractMetric(refAnalysis, 'tp'),
        dr: extractMetric(refAnalysis, 'dr'),
        cf: extractMetric(refAnalysis, 'cf')
    };

    console.log('[A/B-SUGGESTIONS] üìä M√©tricas extra√≠das:', {
        user: U,
        reference: R
    });

    // üî¢ Calcular deltas (B - A)
    const Œî = {
        lufs: (U.lufs !== null && R.lufs !== null) ? (U.lufs - R.lufs) : null,
        lra: (U.lra !== null && R.lra !== null) ? (U.lra - R.lra) : null,
        tp: (U.tp !== null && R.tp !== null) ? (U.tp - R.tp) : null,
        dr: (U.dr !== null && R.dr !== null) ? (U.dr - R.dr) : null,
        cf: (U.cf !== null && R.cf !== null) ? (U.cf - R.cf) : null
    };

    console.log('[A/B-SUGGESTIONS] üî¢ Deltas calculados:', Œî);

    // üéöÔ∏è Thresholds de relev√¢ncia
    const TH = {
        lufs: 1.0,    // 1 LUFS = diferen√ßa perceb√≠vel
        lra: 0.5,     // 0.5 LU = mudan√ßa na din√¢mica
        tp: 0.3,      // 0.3 dBTP = diferen√ßa em headroom
        dr: 0.7,      // 0.7 dB = mudan√ßa no range din√¢mico
        cf: 0.7       // 0.7 = mudan√ßa em transientes
    };

    const suggestions = [];

    // ==========================================
    // 1Ô∏è‚É£ LOUDNESS (LUFS Integrado)
    // ==========================================
    if (Œî.lufs !== null && Math.abs(Œî.lufs) >= TH.lufs) {
        const maisBaixo = Œî.lufs < 0;
        const severidade = Math.abs(Œî.lufs) >= 3 ? "CR√çTICA" : (Math.abs(Œî.lufs) >= 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "Loudness (A vs B)",
            severidade: severidade,
            problema: `Sua faixa est√° ${maisBaixo ? "mais baixa" : "mais alta"} que a refer√™ncia em ${Math.abs(Œî.lufs).toFixed(2)} LUFS. Faixa atual: ${U.lufs?.toFixed(2)} LUFS vs Refer√™ncia: ${R.lufs?.toFixed(2)} LUFS.`,
            causaProvavel: maisBaixo
                ? "Gain staging conservador na masteriza√ß√£o ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo ou ganho de entrada muito alto.",
            solucao: maisBaixo
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Œî.lufs).toFixed(1)} dB. Use um limiter com ceiling adequado (-0.3 dBTP) e ajuste o input gain at√© atingir ${R.lufs?.toFixed(1)} LUFS.`
                : `Reduza o input gain do limiter em ${Math.abs(Œî.lufs).toFixed(1)} dB. Reequilibre os buses para evitar compress√£o excessiva e mantenha o ceiling em -1.0 dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer, Waves L2",
            dicaExtra: "Compare trechos equivalentes (drop/refr√£o) entre as faixas. Use medidores de loudness (Youlean, LUFS Meter) para monitoramento em tempo real.",
            parametros: {
                alvoLUFS: R.lufs,
                diferenca: Œî.lufs,
                ajusteSugerido: maisBaixo ? `+${Math.abs(Œî.lufs).toFixed(1)} dB` : `-${Math.abs(Œî.lufs).toFixed(1)} dB`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 2Ô∏è‚É£ TRUE PEAK
    // ==========================================
    if (Œî.tp !== null && Math.abs(Œî.tp) >= TH.tp) {
        const maisAlto = Œî.tp > 0;
        const severidade = Math.abs(Œî.tp) >= 1.0 ? "CR√çTICA" : (Math.abs(Œî.tp) >= 0.5 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "True Peak (A vs B)",
            severidade: severidade,
            problema: `True Peak ${maisAlto ? "maior" : "menor"} que a refer√™ncia em ${Math.abs(Œî.tp).toFixed(2)} dBTP. Faixa atual: ${U.tp?.toFixed(2)} dBTP vs Refer√™ncia: ${R.tp?.toFixed(2)} dBTP.`,
            causaProvavel: maisAlto 
                ? "Inter-sample peaks causados por limiter sem oversampling adequado ou clipping digital." 
                : "Headroom excessivo n√£o aproveitado - potencial de ganho adicional.",
            solucao: maisAlto
                ? `Ajuste o ceiling do limiter para m√°ximo de -1.0 dBTP. Habilite oversampling 4x ou superior e revise o release time para evitar distor√ß√£o intersample.`
                : `Voc√™ pode aumentar o ceiling em at√© ${Math.abs(Œî.tp).toFixed(1)} dB mantendo margem segura. Ajuste para aproximadamente ${R.tp?.toFixed(1)} dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x-32x), iZotope Ozone Maximizer, Waves L2 Ultramaximizer",
            dicaExtra: "Use medidores de true peak (TT Dynamic Range Meter) e sempre mantenha -0.5 a -1.0 dBTP para distribui√ß√£o em streaming (Spotify, Apple Music).",
            parametros: {
                alvoTP: R.tp,
                diferenca: Œî.tp,
                ceilingRecomendado: maisAlto ? "-1.0 dBTP" : `${R.tp?.toFixed(1)} dBTP`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 3Ô∏è‚É£ LRA (Loudness Range - Macro Din√¢mica)
    // ==========================================
    if (Œî.lra !== null && Math.abs(Œî.lra) >= TH.lra) {
        const maisEstatica = Œî.lra < 0;
        const severidade = Math.abs(Œî.lra) >= 2.0 ? "ALTA" : (Math.abs(Œî.lra) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "LRA / Din√¢mica Macro (A vs B)",
            severidade: severidade,
            problema: `Sua LRA est√° ${maisEstatica ? "mais baixa" : "mais alta"} que a refer√™ncia em ${Math.abs(Œî.lra).toFixed(2)} LU. Faixa atual: ${U.lra?.toFixed(2)} LU vs Refer√™ncia: ${R.lra?.toFixed(2)} LU.`,
            causaProvavel: maisEstatica 
                ? "Compress√£o e limiting excessivos reduzindo contraste din√¢mico entre se√ß√µes." 
                : "Diferen√ßas de arranjo, automa√ß√£o de volume ou menos processamento din√¢mico.",
            solucao: maisEstatica
                ? `Reduza ratio/threshold dos compressores de bus em 2-3 dB. Use automa√ß√£o de volume para criar contrastes entre intro/verso/refr√£o/drop. Alivie o limiter para preservar din√¢mica.`
                : `Ajuste levemente o bus compressor (ratio 2:1-3:1, attack 30ms, release auto) para apertar a macro din√¢mica. Considere sidechain compression em elementos r√≠tmicos.`,
            pluginRecomendado: "SSL Bus Compressor, Glue Compressor (Ableton), API 2500, VCA compressor",
            dicaExtra: "LRA ideal para m√∫sica eletr√¥nica: 3-6 LU. Para rock/pop: 6-10 LU. Use automa√ß√£o de ganho antes de processar para moldar a din√¢mica desejada.",
            parametros: {
                alvoLRA: R.lra,
                diferenca: Œî.lra,
                tipoProcessamento: maisEstatica ? "Aliviar compress√£o" : "Apertar din√¢mica"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 4Ô∏è‚É£ DYNAMIC RANGE (DR)
    // ==========================================
    if (Œî.dr !== null && Math.abs(Œî.dr) >= TH.dr) {
        const severidade = Math.abs(Œî.dr) >= 2.0 ? "ALTA" : (Math.abs(Œî.dr) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "Dynamic Range (A vs B)",
            severidade: severidade,
            problema: `Dynamic Range difere em ${Math.abs(Œî.dr).toFixed(2)} dB da refer√™ncia. Faixa atual: ${U.dr?.toFixed(2)} dB vs Refer√™ncia: ${R.dr?.toFixed(2)} dB.`,
            causaProvavel: "Rela√ß√£o entre picos e RMS (m√©dia de energia) diferente da refer√™ncia devido a processamento din√¢mico distinto.",
            solucao: `Ajuste compress√£o nos subgrupos (drums, bass, synths) para aproximar DR de ${R.dr?.toFixed(1)} dB. Use clippers transparentes antes do limiter para controlar transientes sem perder corpo.`,
            pluginRecomendado: "Clipper transparente (StandardCLIP, K-Clip), bus compressor multi-banda",
            dicaExtra: "DR t√≠pico por g√™nero: EDM (4-6 dB), Pop (6-8 dB), Rock (8-12 dB). Valores muito baixos (<4 dB) indicam overprocessing.",
            parametros: {
                alvoDR: R.dr,
                diferenca: Œî.dr,
                drIdeal: R.dr?.toFixed(1) + " dB"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 5Ô∏è‚É£ CREST FACTOR (Rela√ß√£o Pico/RMS)
    // ==========================================
    if (Œî.cf !== null && Math.abs(Œî.cf) >= TH.cf) {
        const severidade = Math.abs(Œî.cf) >= 1.5 ? "MODERADA" : "LEVE";
        
        suggestions.push({
            categoria: "Crest Factor (A vs B)",
            severidade: severidade,
            problema: `Crest Factor difere em ${Math.abs(Œî.cf).toFixed(2)} dB da refer√™ncia. Faixa atual: ${U.cf?.toFixed(2)} vs Refer√™ncia: ${R.cf?.toFixed(2)}.`,
            causaProvavel: "Transientes (kicks, snares, attacks) com intensidades diferentes entre as faixas.",
            solucao: `Ajuste attack/release de compressores para aproximar punch da refer√™ncia. Use transient shapers para moldar ataques de percuss√£o. CF alvo: ${R.cf?.toFixed(1)}.`,
            pluginRecomendado: "SPL Transient Designer, Oxford Transmod, Waves Trans-X, satura√ß√£o sutil (decapitator)",
            dicaExtra: "CF alto = mais transientes (>10 dB). CF baixo = som mais constante (<6 dB). Use satura√ß√£o para adicionar harm√¥nicos e corpo sem aumentar picos.",
            parametros: {
                alvoCF: R.cf,
                diferenca: Œî.cf,
                ajusteTransientes: Œî.cf < 0 ? "Aumentar ataques" : "Suavizar transientes"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // üìä RESULTADO FINAL
    // ==========================================
    console.log(`[A/B-SUGGESTIONS] ‚úÖ Geradas ${suggestions.length} sugest√µes comparativas`);
    
    if (suggestions.length > 0) {
        console.log('[A/B-SUGGESTIONS] üìã Resumo das sugest√µes:', 
            suggestions.map(s => `${s.categoria} (${s.severidade})`).join(', ')
        );
    }

    // Limitar a 5 sugest√µes mais relevantes (ordenadas por severidade)
    const severityOrder = { "CR√çTICA": 0, "ALTA": 1, "MODERADA": 2, "IMPORTANTE": 3, "LEVE": 4 };
    return suggestions
        .sort((a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5))
        .slice(0, 5);
}

// ========================================
// üéØ PATCH 2: SUGEST√ïES BASEADAS EM G√äNERO
// ========================================

/**
 * üéØ GERAR SUGEST√ïES BASEADAS EM TARGETS DE G√äNERO
 * @param {Object} analysis - An√°lise do usu√°rio
 * @param {Object} genreTargets - Targets do g√™nero (de analysis.data.genreTargets)
 * @returns {Array} - Array de sugest√µes formatadas
 */
function buildGenreBasedAISuggestions(analysis, genreTargets) {
    console.log('[GENRE-SUGGESTIONS] üéØ Gerando sugest√µes baseadas em g√™nero...');
    
    if (!analysis || !genreTargets) {
        console.warn('[GENRE-SUGGESTIONS] ‚ö†Ô∏è Dados incompletos - abortando gera√ß√£o');
        return [];
    }

    // üîç Extrair m√©tricas do usu√°rio
    const extractMetric = (path) => {
        const paths = {
            lufs: [
                analysis.lufsIntegrated,
                analysis.avgLoudness,
                analysis.loudness?.integrated,
                analysis.technicalData?.lufsIntegrated
            ],
            lra: [
                analysis.lra,
                analysis.loudness?.lra,
                analysis.technicalData?.lra
            ],
            tp: [
                analysis.truePeakDbtp,
                analysis.truePeak?.maxDbtp,
                analysis.technicalData?.truePeakDbtp
            ],
            dr: [
                analysis.dynamicRange,
                analysis.dynamics?.range,
                analysis.technicalData?.dynamicRange
            ],
            stereo: [
                analysis.stereoCorrelation,
                analysis.stereo?.correlation,
                analysis.technicalData?.stereoCorrelation
            ]
        };

        const values = paths[path] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) return val;
        }
        return null;
    };

    // üìä M√©tricas do usu√°rio
    const U = {
        lufs: extractMetric('lufs'),
        lra: extractMetric('lra'),
        tp: extractMetric('tp'),
        dr: extractMetric('dr'),
        stereo: extractMetric('stereo')
    };

    // üéØ Targets do g√™nero (estrutura flat do backend normalizado)
    const T = {
        lufs: genreTargets.lufs_target,
        lra: genreTargets.lra_target,
        tp: genreTargets.true_peak_target,
        dr: genreTargets.dr_target,
        stereo: genreTargets.stereo_target
    };

    // üî¢ Toler√¢ncias
    const TOL = {
        lufs: genreTargets.lufs_tolerance || 1.0,
        lra: genreTargets.lra_tolerance || 0.5,
        tp: genreTargets.true_peak_tolerance || 0.3,
        dr: genreTargets.dr_tolerance || 0.7,
        stereo: genreTargets.stereo_tolerance || 0.05
    };

    console.log('[GENRE-SUGGESTIONS] üìä Dados:', { user: U, targets: T, tolerances: TOL });

    // üî¢ Calcular deltas
    const Œî = {
        lufs: (U.lufs !== null && T.lufs !== null) ? (U.lufs - T.lufs) : null,
        lra: (U.lra !== null && T.lra !== null) ? (U.lra - T.lra) : null,
        tp: (U.tp !== null && T.tp !== null) ? (U.tp - T.tp) : null,
        dr: (U.dr !== null && T.dr !== null) ? (U.dr - T.dr) : null,
        stereo: (U.stereo !== null && T.stereo !== null) ? (U.stereo - T.stereo) : null
    };

    const suggestions = [];
    const genreName = analysis.genre || analysis.data?.genre || 'este g√™nero';

    // 1Ô∏è‚É£ LUFS
    if (Œî.lufs !== null && Math.abs(Œî.lufs) > TOL.lufs) {
        const dentroDoAlvo = Math.abs(Œî.lufs) <= TOL.lufs;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Œî.lufs) > TOL.lufs * 2 ? "CR√çTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `Loudness (Padr√£o ${genreName})`,
            severidade,
            problema: `Sua faixa est√° ${Œî.lufs < 0 ? 'mais baixa' : 'mais alta'} que o padr√£o ${genreName} em ${Math.abs(Œî.lufs).toFixed(2)} LUFS. Atual: ${U.lufs?.toFixed(2)} LUFS | Alvo: ${T.lufs?.toFixed(1)} LUFS.`,
            causaProvavel: Œî.lufs < 0
                ? "Gain staging conservador ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo.",
            solucao: Œî.lufs < 0
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Œî.lufs).toFixed(1)} dB.`
                : `Reduza o input gain do limiter em ${Math.abs(Œî.lufs).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer",
            parametros: {
                alvoLUFS: T.lufs,
                diferenca: Œî.lufs,
                tolerancia: TOL.lufs
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 2Ô∏è‚É£ TRUE PEAK
    if (Œî.tp !== null && Math.abs(Œî.tp) > TOL.tp) {
        const dentroDoAlvo = Math.abs(Œî.tp) <= TOL.tp;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Œî.tp) > TOL.tp * 2 ? "CR√çTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `True Peak (Padr√£o ${genreName})`,
            severidade,
            problema: `True Peak ${Œî.tp > 0 ? 'maior' : 'menor'} que o padr√£o em ${Math.abs(Œî.tp).toFixed(2)} dBTP. Atual: ${U.tp?.toFixed(2)} dBTP | Alvo: ${T.tp?.toFixed(1)} dBTP.`,
            causaProvavel: Œî.tp > 0
                ? "Inter-sample peaks causados por limiter sem oversampling adequado."
                : "Headroom excessivo n√£o aproveitado.",
            solucao: Œî.tp > 0
                ? `Ajuste o ceiling do limiter para m√°ximo de -1.0 dBTP com oversampling 4x.`
                : `Voc√™ pode aumentar o ceiling em at√© ${Math.abs(Œî.tp).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x)",
            parametros: {
                alvoTP: T.tp,
                diferenca: Œî.tp,
                tolerancia: TOL.tp
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 3Ô∏è‚É£ DYNAMIC RANGE
    if (Œî.dr !== null && Math.abs(Œî.dr) > TOL.dr) {
        const dentroDoAlvo = Math.abs(Œî.dr) <= TOL.dr;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Œî.dr) > TOL.dr * 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: `Dynamic Range (Padr√£o ${genreName})`,
            severidade,
            problema: `DR difere do padr√£o ${genreName} em ${Math.abs(Œî.dr).toFixed(2)} dB. Atual: ${U.dr?.toFixed(2)} dB | Alvo: ${T.dr?.toFixed(1)} dB.`,
            solucao: `Ajuste compress√£o nos subgrupos para aproximar DR de ${T.dr?.toFixed(1)} dB.`,
            parametros: {
                alvoDR: T.dr,
                diferenca: Œî.dr,
                tolerancia: TOL.dr
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // üéµ BANDAS ESPECTRAIS
    // üéØ PATCH: Aceitar 'bands' (normalizado) OU 'spectralBands' (legacy)
    const targetBands = genreTargets.bands || genreTargets.spectralBands;
    
    if (targetBands && Object.keys(targetBands).length > 0) {
        const userBands = analysis.metrics?.bands || analysis.technicalData?.spectral_balance;
        
        if (userBands) {
            ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
                const userValue = userBands[band]?.percentage || userBands[band]?.energy_db;
                const targetValue = targetBands[band]?.target || targetBands[band]?.percentage;
                const tolerance = targetBands[band]?.tolerance || 3.0;
                
                if (userValue !== null && targetValue !== null) {
                    const delta = userValue - targetValue;
                    
                    if (Math.abs(delta) > tolerance) {
                        suggestions.push({
                            categoria: `Banda ${band} (Padr√£o ${genreName})`,
                            severidade: Math.abs(delta) > tolerance * 2 ? "ALTA" : "MODERADA",
                            problema: `Banda ${band} ${delta > 0 ? 'acima' : 'abaixo'} do padr√£o em ${Math.abs(delta).toFixed(1)}%. Atual: ${userValue.toFixed(1)}% | Alvo: ${targetValue.toFixed(1)}%.`,
                            solucao: delta > 0
                                ? `Reduza frequ√™ncias ${band} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`
                                : `Aumente frequ√™ncias ${band} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`,
                            parametros: {
                                banda: band,
                                alvo: targetValue,
                                diferenca: delta,
                                tolerancia: tolerance
                            },
                            aiEnhanced: true,
                            genreBased: true
                        });
                    }
                }
            });
        }
    }

    console.log(`[GENRE-SUGGESTIONS] ‚úÖ Geradas ${suggestions.length} sugest√µes baseadas em g√™nero`);
    
    // Limitar a 8 sugest√µes mais relevantes (5 m√©tricas + top 3 bandas)
    const severityOrder = { "CR√çTICA": 0, "ALTA": 1, "MODERADA": 2, "OK": 3 };
    return suggestions
        .sort((a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5))
        .slice(0, 8);
}

// ========================================
// ü§ñ SISTEMA DE ESPERA POR ENRIQUECIMENTO IA
// ========================================

/**
 * Aguarda o enriquecimento IA (aiSuggestions) estar dispon√≠vel
 * @param {string} jobId - ID do job para consultar
 * @param {number} timeout - Tempo m√°ximo de espera em ms (padr√£o: 10000ms = 10s)
 * @param {number} pollInterval - Intervalo entre consultas em ms (padr√£o: 1000ms = 1s)
 * @returns {Promise<object|null>} - Dados enriquecidos ou null se timeout
 */
async function waitForAIEnrichment(jobId, timeout = 10000, pollInterval = 1000) {
    // PATCH JOB-ID: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== 'string' || jobId === 'undefined') {
        console.error('[AI-SYNC] ‚ùå jobId inv√°lido ou undefined:', jobId);
        console.error('[AI-SYNC] ‚ùå Abortando waitForAIEnrichment - n√£o √© poss√≠vel consultar job inv√°lido');
        return null;
    }
    
    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('[AI-SYNC] ‚è≥ Aguardando enriquecimento IA...');
    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('[AI-SYNC] üÜî Job ID:', jobId);
    console.log('[AI-SYNC] ‚è±Ô∏è Timeout:', timeout, 'ms');
    console.log('[AI-SYNC] üîÑ Poll interval:', pollInterval, 'ms');
    
    const startTime = Date.now();
    let attempt = 0;
    
    while (Date.now() - startTime < timeout) {
        attempt++;
        const elapsed = Date.now() - startTime;
        
        console.log(`[AI-SYNC] üîç Tentativa ${attempt} (${elapsed}ms/${timeout}ms)...`);
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`);
            
            if (!response.ok) {
                console.warn(`[AI-SYNC] ‚ö†Ô∏è HTTP ${response.status} - Tentando novamente...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
            }
            
            const data = await response.json();
            
            console.log(`[AI-SYNC] üì¶ Resposta recebida (tentativa ${attempt}):`, {
                hasAiSuggestions: Array.isArray(data.aiSuggestions),
                aiSuggestionsLength: data.aiSuggestions?.length || 0,
                hasSuggestions: Array.isArray(data.suggestions),
                suggestionsLength: data.suggestions?.length || 0,
                status: data.status
            });
            
            // ‚úÖ VERIFICA√á√ÉO: aiSuggestions existe E tem conte√∫do
            if (Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                // Verificar se pelo menos 1 tem aiEnhanced: true
                const aiEnhancedCount = data.aiSuggestions.filter(s => s.aiEnhanced === true).length;
                
                console.log(`[AI-SYNC] üéØ aiSuggestions encontrado:`, {
                    total: data.aiSuggestions.length,
                    aiEnhanced: aiEnhancedCount
                });
                
                if (aiEnhancedCount > 0) {
                    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('[AI-SYNC] ‚úÖ‚úÖ‚úÖ ENRIQUECIMENTO IA CONCLU√çDO! ‚úÖ‚úÖ‚úÖ');
                    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('[AI-SYNC] üìä Total:', data.aiSuggestions.length, 'sugest√µes');
                    console.log('[AI-SYNC] ü§ñ Marcadas como aiEnhanced:', aiEnhancedCount);
                    console.log('[AI-SYNC] ‚è±Ô∏è Tempo decorrido:', Date.now() - startTime, 'ms');
                    console.log('[AI-SYNC] üìã Sample da primeira:', {
                        aiEnhanced: data.aiSuggestions[0]?.aiEnhanced,
                        categoria: data.aiSuggestions[0]?.categoria,
                        nivel: data.aiSuggestions[0]?.nivel,
                        hasProblema: !!data.aiSuggestions[0]?.problema,
                        hasSolucao: !!data.aiSuggestions[0]?.solucao
                    });
                    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    
                    return data;
                } else {
                    console.warn(`[AI-SYNC] ‚ö†Ô∏è aiSuggestions existe mas nenhum tem aiEnhanced: true`);
                    console.warn(`[AI-SYNC] ‚ö†Ô∏è Aguardando processamento IA completar...`);
                }
            } else {
                console.log(`[AI-SYNC] ‚è≥ aiSuggestions ainda n√£o dispon√≠vel, aguardando...`);
            }
            
        } catch (error) {
            console.error(`[AI-SYNC] ‚ùå Erro na tentativa ${attempt}:`, error.message);
        }
        
        // Aguardar antes da pr√≥xima tentativa
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout atingido
    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('[AI-SYNC] ‚è±Ô∏è TIMEOUT ATINGIDO');
    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.warn('[AI-SYNC] ‚ö†Ô∏è Enriquecimento IA n√£o completou dentro do tempo limite');
    console.warn('[AI-SYNC] ‚ö†Ô∏è Total de tentativas:', attempt);
    console.warn('[AI-SYNC] ‚ö†Ô∏è Tempo decorrido:', Date.now() - startTime, 'ms');
    console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    
    return null;
}

/**
 * Mostra spinner visual de carregamento IA
 * @param {string} message - Mensagem a exibir
 */
function showAILoadingSpinner(message = 'Conectando √† IA...') {
    console.log('[AI-UI][SPINNER] üîÑ Mostrando spinner:', message);
    
    // Tentar inserir no elemento de status do modal se existir
    const statusElement = document.querySelector('#ai-enrichment-status') || 
                         document.querySelector('.modal-status') ||
                         document.querySelector('.analysis-status');
    
    if (statusElement) {
        statusElement.innerHTML = `
            <div class="ai-loading-spinner" id="aiEnrichmentSpinner">
                <div class="spinner-icon">üîÑ</div>
                <div class="spinner-message">${message}</div>
                <div class="spinner-dots">
                    <span class="dot">‚óè</span>
                    <span class="dot">‚óè</span>
                    <span class="dot">‚óè</span>
                </div>
            </div>
        `;
        
        // Adicionar anima√ß√£o via CSS inline
        const style = document.createElement('style');
        style.textContent = `
            .ai-loading-spinner {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background: rgba(0, 0, 0, 0.05);
                border-radius: 8px;
                margin: 10px 0;
            }
            .spinner-icon {
                font-size: 32px;
                animation: spin 2s linear infinite;
            }
            .spinner-message {
                font-size: 14px;
                color: #666;
                margin: 10px 0 5px 0;
                font-weight: 500;
            }
            .spinner-dots {
                display: flex;
                gap: 4px;
            }
            .spinner-dots .dot {
                font-size: 8px;
                animation: pulse 1.5s ease-in-out infinite;
            }
            .spinner-dots .dot:nth-child(2) {
                animation-delay: 0.2s;
            }
            .spinner-dots .dot:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
        `;
        
        if (!document.getElementById('aiSpinnerStyles')) {
            style.id = 'aiSpinnerStyles';
            document.head.appendChild(style);
        }
    } else {
        console.warn('[AI-UI][SPINNER] ‚ö†Ô∏è Elemento de status n√£o encontrado');
    }
}

/**
 * Remove spinner visual de carregamento IA
 */
function hideAILoadingSpinner() {
    console.log('[AI-UI][SPINNER] ‚úÖ Removendo spinner');
    
    const spinner = document.getElementById('aiEnrichmentSpinner');
    if (spinner) {
        spinner.remove();
    }
}

/**
 * Obt√©m par de an√°lises para compara√ß√£o
 * @returns {object|null} { ref, curr } ou null se alguma an√°lise estiver faltando
 */
function getComparisonPair() {
    const ref = window.SoundyAI_Store.first;
    const curr = window.SoundyAI_Store.second;
    
    if (!ref || !curr) {
        console.warn('‚ö†Ô∏è [STORE] Ainda falta uma das an√°lises para comparar');
        console.warn('   - first:', !!ref);
        console.warn('   - second:', !!curr);
        return null;
    }
    
    console.log('üì¶ [STORE] Par de an√°lises obtido');
    console.log('   - ref.jobId:', ref?.jobId);
    console.log('   - curr.jobId:', curr?.jobId);
    console.log('   - ref.fileName:', ref?.fileName || ref?.metadata?.fileName);
    console.log('   - curr.fileName:', curr?.fileName || curr?.metadata?.fileName);
    
    // üîí AUDITORIA AUTOM√ÅTICA
    console.table({
        refJob: ref?.jobId,
        currJob: curr?.jobId,
        refName: ref?.fileName || ref?.metadata?.fileName,
        currName: curr?.fileName || curr?.metadata?.fileName,
        sameJob: ref?.jobId === curr?.jobId,
        sameName: (ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)
    });
    
    // üö® VALIDA√á√ÉO CR√çTICA
    if (ref?.jobId === curr?.jobId) {
        console.error('üö® [STORE-ERROR] CONTAMINA√á√ÉO DETECTADA!');
        console.error('   JobIds s√£o IGUAIS:', ref.jobId);
        console.error('   Isso N√ÉO DEVERIA ACONTECER com sistema isolado');
        console.trace();
    }
    
    if ((ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)) {
        console.error('üö® [STORE-ERROR] NOMES DE ARQUIVO IGUAIS!');
        console.error('   FileName:', ref?.fileName || ref?.metadata?.fileName);
        console.error('   Poss√≠vel self-compare ou upload duplicado');
        console.trace();
    }
    
    return { ref, curr };
}

// ========================================
// üîß UTILIDADES DE CLONAGEM PROFUNDA
// ========================================
/**
 * Clone profundo seguro - tenta structuredClone, fallback para JSON
 * @param {*} obj - Objeto a ser clonado
 * @returns {*} Clone independente ou objeto original (√∫ltimo recurso)
 */
function cloneDeepSafe(obj) {
  if (!obj) return obj;
  try { return structuredClone(obj); } catch {}
  try { return JSON.parse(JSON.stringify(obj)); } catch {}
  return obj; // √∫ltimo recurso (n√£o deve acontecer)
}

// ========================================
// üîí PASSO 2: PROTE√á√ÉO DE JOBID (ANTI-CONTAMINA√á√ÉO)
// ========================================
/**
 * Protege window.__CURRENT_JOB_ID__ contra sobrescrita acidental
 * Bloqueia tentativas de contaminar com __REFERENCE_JOB_ID__
 */
function protectCurrentJobId(initialValue) {
    // Armazena valor privado
    let _currentJobId = initialValue;
    
    // Redefine a propriedade com getter/setter protegido
    Object.defineProperty(window, '__CURRENT_JOB_ID__', {
        configurable: true,
        enumerable: true,
        set: function(value) {
            console.group('‚ö†Ô∏è [PROTECTION] Tentativa de alterar currentJobId');
            console.log('   - Valor antigo:', _currentJobId);
            console.log('   - Valor novo:', value);
            console.trace('   - Stack trace:');
            console.groupEnd();
            
            // BLOQUEIO: Se tentar contaminar com referenceJobId
            if (value && value === window.__REFERENCE_JOB_ID__) {
                console.error('‚ùå [PROTECTION] BLOQUEADO! Tentativa de contaminar currentJobId com referenceJobId!');
                console.error('‚ùå [PROTECTION] Mantendo valor original:', _currentJobId);
                return; // BLOQUEIA a altera√ß√£o
            }
            
            // BLOQUEIO: Se j√° tiver valor e tentar alterar sem justificativa
            if (_currentJobId && value && _currentJobId !== value) {
                console.warn('‚ö†Ô∏è [PROTECTION] Sobrescrita de currentJobId detectada!');
                console.warn('   Antigo:', _currentJobId);
                console.warn('   Novo:', value);
            }
            
            _currentJobId = value;
            console.log('‚úÖ [PROTECTION] currentJobId atualizado:', _currentJobId);
        },
        get: function() {
            return _currentJobId;
        }
    });
    
    console.log('üîí [PROTECTION] Prote√ß√£o de currentJobId ativada com valor inicial:', initialValue);
}

// ========================================
// üõ°Ô∏è PASSO 3: FUN√á√ÉO SEGURA PARA OBTER JOBID
// ========================================
/**
 * Retorna o jobId correto baseado no modo, com prote√ß√£o contra contamina√ß√£o
 * @param {string} mode - 'reference' ou 'genre'
 * @returns {string|null} jobId seguro
 */
/**
 * ‚ö†Ô∏è DEPRECATED - USE getCorrectJobId() INSTEAD
 * Esta fun√ß√£o est√° DEPRECADA e ser√° removida em vers√µes futuras.
 * MOTIVO: Acessa localStorage diretamente sem valida√ß√£o, causando bug de compara√ß√£o com mesma m√∫sica.
 * @deprecated Use getCorrectJobId(context) em vez disso
 */
function getJobIdSafely(mode) {
    console.error('‚ö†Ô∏è [DEPRECATED] getJobIdSafely() est√° DEPRECADA! Use getCorrectJobId() em vez disso.');
    console.trace('üîç [DEPRECATED] Stack trace de quem chamou a fun√ß√£o deprecada:');
    
    // Redirecionar para a fun√ß√£o correta
    if (mode === 'reference') {
        return getCorrectJobId('reference');
    } else if (mode === 'storage') {
        return getCorrectJobId('storage');
    } else {
        return getCorrectJobId('current');
    }
}

// ========================================
// üéØ FUN√á√ÉO UTILIT√ÅRIA CR√çTICA: getCorrectJobId
// ========================================
/**
 * Retorna o jobId correto baseado no contexto
 * NUNCA use localStorage.getItem('referenceJobId') diretamente!
 * SEMPRE use esta fun√ß√£o!
 * 
 * @param {string} context - 'user'|'second'|'current' = segunda m√∫sica
 *                          'reference'|'first' = primeira m√∫sica
 *                          'storage' = fallback para localStorage
 * @returns {string|null} jobId correto para o contexto
 */
function getCorrectJobId(context) {
    const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
    
    console.group(`üéØ [GET-CORRECT-JOBID] Contexto: ${context}`);
    console.log('   - Modo atual:', mode);
    console.log('   - window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - sessionStorage.currentJobId:', sessionStorage.getItem('currentJobId'));
    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    
    if (mode === 'reference') {
        // Em modo reference, temos dois jobIds diferentes
        const currentJobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId');
        
        // üîß CORRE√á√ÉO: Usar StorageManager para ler referenceJobId
        const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
        
        // üö® VALIDA√á√ÉO CR√çTICA: NUNCA retornar jobIds iguais
        if (currentJobId && referenceJobId && currentJobId === referenceJobId) {
            console.error('‚ùå [CRITICAL] JobIds s√£o iguais! Isso N√ÉO deveria acontecer!');
            console.error('   currentJobId:', currentJobId);
            console.error('   referenceJobId:', referenceJobId);
            console.error('   context:', context);
            console.trace();
            
            // Tenta recuperar do sessionStorage
            const recoveredJobId = sessionStorage.getItem('currentJobId');
            if (recoveredJobId && recoveredJobId !== referenceJobId) {
                console.warn('‚ö†Ô∏è [RECOVERY] JobId recuperado do sessionStorage:', recoveredJobId);
                window.__CURRENT_JOB_ID__ = recoveredJobId;
                console.groupEnd();
                return recoveredJobId;
            }
            
            throw new Error('FATAL: JobIds iguais em modo reference - contamina√ß√£o detectada!');
        }
        
        // Decide qual jobId usar baseado no contexto
        let selectedJobId;
        if (context === 'user' || context === 'second' || context === 'current') {
            selectedJobId = currentJobId;
            console.log('‚úÖ [JOB-ID] Retornando currentJobId (segunda m√∫sica):', selectedJobId);
        } else if (context === 'reference' || context === 'first') {
            selectedJobId = referenceJobId;
            console.log('‚úÖ [JOB-ID] Retornando referenceJobId (primeira m√∫sica):', selectedJobId);
        } else if (context === 'storage') {
            // Fallback para localStorage (compatibilidade)
            selectedJobId = referenceJobId;
            console.warn('‚ö†Ô∏è [JOB-ID] Contexto "storage" - retornando referenceJobId:', selectedJobId);
        } else {
            console.warn('‚ö†Ô∏è [JOB-ID] Contexto n√£o especificado:', context);
            selectedJobId = currentJobId; // Default: segunda m√∫sica
            console.log('   - Default: retornando currentJobId:', selectedJobId);
        }
        
        console.groupEnd();
        return selectedJobId;
    } else {
        // Modo normal: s√≥ existe um jobId
        const jobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId') || localStorage.getItem('currentJobId');
        console.log('‚úÖ [JOB-ID] Modo normal - retornando:', jobId);
        console.groupEnd();
        return jobId;
    }
}

// ========================================
// üîÑ HIDRATA√á√ÉO DE REFER√äNCIA (Corre√ß√£o 1)
// ========================================
/**
 * Garante que a refer√™ncia esteja hidratada e dispon√≠vel para compara√ß√£o A/B.
 * Fonte de verdade: AnalysisCache ‚ûú FirstAnalysisStore ‚ûú __FIRST_ANALYSIS_FROZEN__
 * @returns {Object} { ok: boolean, reason?: string, refId?: string, hasBands?: boolean, file?: string }
 */
function ensureReferenceHydrated() {
  try {
    const mode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
    // üéØ CORRE√á√ÉO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');

    if (mode !== 'reference' || !refId) {
      return { ok: false, reason: 'no-ref-mode-or-id' };
    }

    // Fonte de verdade: AnalysisCache ‚ûú FirstAnalysisStore ‚ûú __FIRST_ANALYSIS_FROZEN__
    const cache = window.AnalysisCache;
    let ref = cache?.get?.(refId) || window.FirstAnalysisStore?.get?.() || window.__FIRST_ANALYSIS_FROZEN__;

    if (!ref) {
      return { ok: false, reason: 'no-ref-object' };
    }

    // deep clone SEM compartilhar metadata/bands
    const refClone = (typeof structuredClone === 'function') 
      ? structuredClone(ref) 
      : JSON.parse(JSON.stringify(ref));

    // Normalizar shape esperado (bands/technicalData/metadata)
    if (!refClone.bands && refClone.spectralBands) {
      refClone.bands = refClone.spectralBands;
    }

    // Publicar refer√™ncia consistente no escopo global
    window.referenceAnalysisData = refClone;
    window.__FIRST_ANALYSIS_FROZEN__ = (typeof structuredClone === 'function') 
      ? structuredClone(refClone) 
      : JSON.parse(JSON.stringify(refClone));

    // Sinaliza√ß√£o
    console.log('[ensureReferenceHydrated] ‚úÖ Refer√™ncia hidratada:', {
      refId,
      hasBands: !!refClone?.bands,
      file: refClone?.metadata?.fileName || refClone?.fileName
    });

    return { 
      ok: true, 
      refId, 
      hasBands: !!refClone?.bands, 
      file: refClone?.metadata?.fileName || refClone?.fileName 
    };
  } catch (e) {
    console.warn('[ensureReferenceHydrated] ‚ùå erro', e);
    return { ok: false, reason: 'exception', error: String(e) };
  }
}

// ========================================
// üõ°Ô∏è GUARDI√ÉO GLOBAL: aiUIController Stub
// ========================================
/**
 * Garante que aiUIController sempre existe, mesmo antes do carregamento completo.
 * Cria stub tempor√°rio que √© substitu√≠do quando o controller real √© carregado.
 */
(function ensureAIUIController() {
  if (!window.aiUIController) {
    console.warn('[SAFE-BOOT] aiUIController ausente - criando stub temporario.');

    window.aiUIController = {
      renderMetricCards: () => console.warn('[STUB] renderMetricCards chamado antes da carga real.'),
      renderScoreSection: () => console.warn('[STUB] renderScoreSection chamado antes da carga real.'),
      renderSuggestions: () => console.warn('[STUB] renderSuggestions chamado antes da carga real.'),
      renderFinalScoreAtTop: () => console.warn('[STUB] renderFinalScoreAtTop chamado antes da carga real.'),
      checkForAISuggestions: () => console.warn('[STUB] checkForAISuggestions chamado antes da carga real.')
    };
  }

  // Espera ate o real ser carregado (quando o modulo UI inicializa)
  const observer = new MutationObserver(() => {
    if (window.aiUIController?.__ready) {
      console.log('[SAFE-BOOT] ‚úÖ aiUIController real detectado, removendo stub.');
      
      // ========================================
      // ‚úÖ AUDITORIA DE COMPATIBILIDADE
      // ========================================
      const requiredFunctions = [
        'renderMetricCards',
        'renderScoreSection',
        'renderSuggestions',
        'renderFinalScoreAtTop',
        'checkForAISuggestions'
      ];
      
      const missingFunctions = requiredFunctions.filter(
        fn => typeof window.aiUIController[fn] !== 'function'
      );
      
      if (missingFunctions.length === 0) {
        console.log('[COMPAT] ‚úÖ aiUIController detectado com todas as fun√ß√µes esperadas');
        console.log('[COMPAT] Fun√ß√µes dispon√≠veis:', requiredFunctions);
      } else {
        console.error('[COMPAT-FAIL] ‚ùå Fun√ß√µes ausentes:', missingFunctions);
        console.error('[COMPAT-FAIL] Tipo de aiUIController:', typeof window.aiUIController);
        console.error('[COMPAT-FAIL] Prot√≥tipo:', Object.getPrototypeOf(window.aiUIController));
      }
      
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
})();

// ========================================
// ‚úÖ CORRE√á√ÉO 4: Alias Seguro para aiUIController
// ========================================
// Garantir que fun√ß√µes legadas estejam dispon√≠veis como fallback
(function createAIUIControllerAliases() {
  if (!window.aiUIController) window.aiUIController = {};
  
  // Se renderMetricCards n√£o existe mas existe fun√ß√£o global, criar alias
  if (typeof window.aiUIController.renderMetricCards !== 'function' && 
      typeof window.renderMetricCards === 'function') {
    window.aiUIController.renderMetricCards = (...args) => window.renderMetricCards(...args);
    console.log('[ALIAS] ‚úÖ Criado alias: aiUIController.renderMetricCards ‚Üí renderMetricCards');
  }
  
  if (typeof window.aiUIController.renderScoreSection !== 'function' && 
      typeof window.renderScoreSection === 'function') {
    window.aiUIController.renderScoreSection = (...args) => window.renderScoreSection(...args);
    console.log('[ALIAS] ‚úÖ Criado alias: aiUIController.renderScoreSection ‚Üí renderScoreSection');
  }
  
  if (typeof window.aiUIController.renderSuggestions !== 'function' && 
      typeof window.renderSuggestions === 'function') {
    window.aiUIController.renderSuggestions = (...args) => window.renderSuggestions(...args);
    console.log('[ALIAS] ‚úÖ Criado alias: aiUIController.renderSuggestions ‚Üí renderSuggestions');
  }
  
  if (typeof window.aiUIController.renderFinalScoreAtTop !== 'function' && 
      typeof window.renderFinalScoreAtTop === 'function') {
    window.aiUIController.renderFinalScoreAtTop = (...args) => window.renderFinalScoreAtTop(...args);
    console.log('[ALIAS] ‚úÖ Criado alias: aiUIController.renderFinalScoreAtTop ‚Üí renderFinalScoreAtTop');
  }
})();

// üìù Carregar gerador de texto did√°tico
if (typeof window !== 'undefined' && !window.SuggestionTextGenerator) {
    const script = document.createElement('script');
    script.src = 'suggestion-text-generator.js';
    script.async = true;
    script.onload = () => {
        console.log('[AudioIntegration] Gerador de texto did√°tico carregado');
    };
    script.onerror = () => {
        console.warn('[AudioIntegration] Falha ao carregar gerador de texto did√°tico');
    };
    document.head.appendChild(script);
}

// Debug flag (silencia logs em produ√ß√£o; defina window.DEBUG_ANALYZER = true para habilitar)
const __DEBUG_ANALYZER__ = true; // üîß TEMPOR√ÅRIO: Ativado para debug do problema
const __dbg = (...a) => { if (__DEBUG_ANALYZER__) console.log('[AUDIO-DEBUG]', ...a); };
const __dwrn = (...a) => { if (__DEBUG_ANALYZER__) console.warn('[AUDIO-WARN]', ...a); };

// ========================================
// üóÇÔ∏è STORES GLOBAIS: AnalysisCache + FirstAnalysisStore
// ========================================
(function initGlobalStores() {
  if (!window.AnalysisCache) {
    // üîß Implementa√ß√£o segura sem recurs√£o infinita
    const _data = new Map();
    
    window.AnalysisCache = {
      _data: _data,
      
      get(key) {
        if (!key) return null;
        const value = this._data.get(key);
        return value ? cloneDeepSafe(value) : null;
      },
      
      set(key, value) {
        if (!key || !value) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(value)));
      },
      
      has(key) {
        return key ? this._data.has(key) : false;
      },
      
      delete(key) {
        return this._data.delete(key);
      },
      
      clear() {
        this._data.clear();
        console.log('[CACHE] üóëÔ∏è clear');
      },
      
      // üîß API ESTENDIDA: Suporta Virtual IDs (vid) ou jobId simples
      put(keyOrAnalysis, analysis) {
        // Suporta: put(vid, analysis) ou put(analysis)
        let key, data;
        if (typeof keyOrAnalysis === 'string' && analysis) {
          key = keyOrAnalysis; // Virtual ID expl√≠cito
          data = analysis;
        } else {
          data = keyOrAnalysis;
          key = data?.jobId || data?.id; // Backward compatibility
        }
        
        if (!key || !data) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(data)));
        console.log('[CACHE] ‚úÖ put', { 
          vid: key, 
          file: data?.fileName || data?.metadata?.fileName,
          isVirtualId: key.includes('::')
        });
      },
      
      ids() {
        return Array.from(this._data.keys());
      }
    };
    
    console.log('[BOOT] AnalysisCache ‚úÖ (Virtual ID support, no recursion)');
  }

  if (!window.FirstAnalysisStore) {
    const _state = {
      user: null,      // Primeira faixa (USER)
      userVid: null,   // Virtual ID do user
      userJobId: null, // jobId original do user
      ref: null,       // Segunda faixa (REF)
      refVid: null,    // Virtual ID da ref
      refJobId: null   // jobId original da ref
    };

    window.FirstAnalysisStore = {
      // ========================================
      // üéØ API POR PAPEL (USER/REF)
      // ========================================
      setUser(analysis, vid, jobId) {
        if (_state.user) {
          console.warn('[FIRST-STORE] ‚ö†Ô∏è USER j√° existe - n√£o sobrescrever');
          return; // set-once para user
        }
        _state.user = analysis;
        _state.userVid = vid;
        _state.userJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] ‚úÖ setUser', { 
          vid, 
          jobId: _state.userJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      setRef(analysis, vid, jobId) {
        // REF pode ser sobrescrito (usu√°rio pode trocar segunda faixa)
        _state.ref = analysis;
        _state.refVid = vid;
        _state.refJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] ‚úÖ setRef', { 
          vid, 
          jobId: _state.refJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      getUser() {
        if (_state.user) return _state.user;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.USER);
          console.log('[FIRST-STORE] ‚ôªÔ∏è RESTORE USER from cache', { vid: window.CacheIndex.USER });
          return restored;
        }
        return null;
      },
      
      getRef() {
        if (_state.ref) return _state.ref;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.REF && window.AnalysisCache?.has(window.CacheIndex.REF)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.REF);
          console.log('[FIRST-STORE] ‚ôªÔ∏è RESTORE REF from cache', { vid: window.CacheIndex.REF });
          return restored;
        }
        return null;
      },
      
      has() { 
        return !!_state.user || !!(window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER));
      },
      
      // ========================================
      // üîß COMPATIBILIDADE COM API ANTIGA
      // ========================================
      set(analysis) {
        // Backward compatibility: se n√£o tem user, assume que √© o primeiro
        if (!_state.user) {
          const jobId = analysis?.jobId || analysis?.id;
          const vid = `${jobId}::USER`;
          this.setUser(analysis, vid, jobId);
          window.CacheIndex.USER = vid;
          
          // üîß CORRE√á√ÉO: Usar StorageManager ao inv√©s de localStorage direto
          try { 
            window.StorageManager.setReferenceJobId(jobId || '');
          } catch (e) {
            console.warn('[FIRST-STORE] ‚ö†Ô∏è Falha ao salvar referenceJobId:', e);
          }
        } else {
          console.warn('[FIRST-STORE] ‚ö†Ô∏è set() chamado mas USER j√° existe - use setRef()');
        }
      },
      
      get() {
        // Backward compatibility: retorna user (primeira faixa)
        return this.getUser();
      },
      
      id() { return _state.userJobId; },
      jobId() { return _state.userJobId; },
      
      clear() { 
        _state.user = null;
        _state.userVid = null;
        _state.userJobId = null;
        _state.ref = null;
        _state.refVid = null;
        _state.refJobId = null;
        window.CacheIndex.USER = null;
        window.CacheIndex.REF = null;
        
        // üîß CORRE√á√ÉO: Usar StorageManager
        try { 
          window.StorageManager.clearReference();
        } catch (e) {
          console.warn('[FIRST-STORE] ‚ö†Ô∏è Falha ao limpar refer√™ncia:', e);
        }
        
        console.log('[FIRST-STORE] üóëÔ∏è clear (USER + REF)');
      },
      
      // ========================================
      // üìä DEBUG
      // ========================================
      _debug() {
        return {
          hasUser: !!_state.user,
          hasRef: !!_state.ref,
          userVid: _state.userVid,
          refVid: _state.refVid,
          userJobId: _state.userJobId,
          refJobId: _state.refJobId,
          cacheIndexUser: window.CacheIndex.USER,
          cacheIndexRef: window.CacheIndex.REF
        };
      }
    };
    console.log('[BOOT] FirstAnalysisStore ‚úÖ (Role-based: USER/REF)');
  }
})();

// Alias global para compatibilidade com c√≥digo existente
const FirstAnalysisStore = window.FirstAnalysisStore;

// ========================================
// üîß FUN√á√ÉO AUXILIAR: Cache por Papel (Role)
// ========================================
/**
 * Salva resultado de an√°lise com Virtual ID baseado no papel (USER ou REF)
 * @param {Object} result - Resultado da an√°lise do backend
 * @param {Object} options - { isSecondTrack: boolean }
 * @returns {Object} { vid: string, clone: Object }
 */
function cacheResultByRole(result, { isSecondTrack }) {
  // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
  const base = result; // ‚úÖ LEITURA DIRETA
  
  // Clone profundo para evitar muta√ß√µes
  const clone = (typeof structuredClone === 'function') 
    ? structuredClone(base) 
    : JSON.parse(JSON.stringify(base));
  
  // Criar Virtual ID: jobId + papel (USER ou REF)
  const jobId = result.jobId || result.id;
  const role = isSecondTrack ? 'REF' : 'USER';
  const vid = `${jobId}::${role}`;
  
  // Salvar no cache com VID
  window.AnalysisCache.put(vid, clone);
  
  // Atualizar √≠ndice de pap√©is
  if (isSecondTrack) {
    window.CacheIndex.REF = vid;
  } else {
    window.CacheIndex.USER = vid;
  }
  
  console.log('[VID] ‚úÖ Cached by role', { 
    vid, 
    role, 
    jobId, 
    file: clone?.fileName || clone?.metadata?.fileName,
    isSecondTrack
  });
  
  return { vid, clone };
}

// ÔøΩÔ∏è GUARDS: Isolamento de jobIds para evitar self-compare
// Recebe objetos j√° clonados e garante que refFull tenha jobId √∫nico se necess√°rio
function refHardGuards({ userFull, refFull, secondAnalysis }) {
    // ========================================
    // ‚úÖ CORRE√á√ÉO 4: Valida√ß√£o de entrada
    // ========================================
    if (!userFull) {
        console.warn('[refHardGuards] ‚ö†Ô∏è userFull inv√°lido');
        return { ok: false, reason: 'invalid-user' };
    }
    if (!refFull) {
        console.warn('[refHardGuards] ‚ö†Ô∏è refFull inv√°lido');
        return { ok: false, reason: 'invalid-ref' };
    }

    const userId = userFull?.jobId || userFull?.id;
    const refId = refFull?.jobId || refFull?.id;
    const secondId = secondAnalysis?.jobId || secondAnalysis?.id;

    // Se jobIds s√£o iguais, for√ßa isolamento adicionando sufixo __ref
    if (userId && refId && userId === refId) {
        console.warn('[GUARD] ‚ö†Ô∏è jobIds iguais, isolando refer√™ncia com sufixo __ref');
        // Clone para evitar muta√ß√£o do original
        refFull = (typeof structuredClone === 'function')
            ? structuredClone(refFull)
            : JSON.parse(JSON.stringify(refFull));
        refFull.jobId = `${refId}__ref`; // for√ßa ID diferente
    }

    console.log('[GUARD] ‚úÖ userJobId:', userId, '| refJobId:', refFull?.jobId || refFull?.id);
    return { ok: true, userFull, refFull };
}

// ÔøΩüîí CLONE PROFUNDO SEGURO (sem loops circulares)
// Substitui JSON.parse(JSON.stringify()) com prote√ß√£o contra refer√™ncias circulares
function deepCloneSafe(obj, seen = new WeakMap()) {
    // Primitivos e null retornam direto
    if (obj === null || typeof obj !== 'object') return obj;
    
    // Se j√° visitamos este objeto, retornar clone existente (evita loop infinito)
    if (seen.has(obj)) return seen.get(obj);
    
    // Criar estrutura base (array ou objeto)
    const clone = Array.isArray(obj) ? [] : {};
    
    // Registrar no mapa ANTES de clonar propriedades (previne recurs√£o infinita)
    seen.set(obj, clone);
    
    // Clonar cada propriedade recursivamente
    for (const key in obj) {
        // Ignorar propriedades espec√≠ficas que causam loops circulares
        if (key === '_referenceAnalysis') {
            console.log('[DEEP-CLONE] ‚ö†Ô∏è Propriedade circular ignorada:', key);
            continue;
        }
        
        // Verificar se propriedade √© pr√≥pria (n√£o herdada)
        if (Object.hasOwn(obj, key)) {
            clone[key] = deepCloneSafe(obj[key], seen);
        }
    }
    
    return clone;
}

// ÔøΩ STRINGIFY SEGURO (sem loops circulares)
// Substitui JSON.stringify() com prote√ß√£o contra refer√™ncias circulares
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (key, value) => {
        // Detectar e marcar refer√™ncias circulares
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
        }
        
        // Omitir propriedades espec√≠ficas que causam loops
        if (key === "_referenceAnalysis" || key === "referenceAnalysis") {
            return "[OmittedRef]";
        }
        
        // Omitir propriedades privadas (come√ßam com _)
        if (key && key.startsWith("_")) {
            return undefined;
        }
        
        return value;
    }, 2); // Indenta√ß√£o de 2 espa√ßos para legibilidade
}

// ÔøΩüõ°Ô∏è HELPER: Comparador robusto de faixas (evita falso self-compare)
function areSameTrack(a, b) {
    if (!a || !b) return false;

    // Prioridade 1: jobId
    const aj = a.jobId || a.id;
    const bj = b.jobId || b.id;
    if (aj && bj) return aj === bj;

    // Prioridade 2: fileKey
    if (a.fileKey && b.fileKey) return a.fileKey === b.fileKey;

    // Prioridade 3: fileName + sampleRate + dura√ß√£o aproximada
    const nameEqual = a.fileName && b.fileName && a.fileName === b.fileName;
    const srA = a.sampleRate || a.metadata?.sampleRate;
    const srB = b.sampleRate || b.metadata?.sampleRate;
    const durA = a.duration || a.metadata?.duration;
    const durB = b.duration || b.metadata?.duration;
    if (nameEqual && srA && srB && srA === srB) {
        const diff = Math.abs((durA || 0) - (durB || 0));
        return diff < 0.2;
    }

    return false;
}

// =============== CLONE & SANITIZE (SEM CICLOS) ===============
function safeDeepClone(obj, cache = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (cache.has(obj)) return cache.get(obj);

    if (Array.isArray(obj)) {
        const arr = [];
        cache.set(obj, arr);
        obj.forEach(v => arr.push(safeDeepClone(v, cache)));
        return arr;
    }

    const clone = {};
    cache.set(obj, clone);

    for (const key of Object.keys(obj)) {
        // Remove refer√™ncias internas e fun√ß√µes
        if (key.startsWith('_') || typeof obj[key] === 'function' || typeof obj[key] === 'symbol') continue;
        clone[key] = safeDeepClone(obj[key], cache);
    }

    return clone;
}

// Reduz o objeto de an√°lise para apenas o necess√°rio
function pickAnalysisFields(a) {
    if (!a) return a;
    const s = safeDeepClone(a);
    return {
        id: s.id ?? s.jobId,
        jobId: s.jobId ?? s.id,
        fileKey: s.fileKey,
        fileName: s.fileName,
        loudness: s.loudness,
        dynamics: s.dynamics,
        spectral: s.spectral,
        metrics: s.metrics,
        technicalData: s.technicalData,
        bands: s.bands,
        spectralBands: s.spectralBands,
        metadata: s.metadata,
    };
}

// Normaliza√ß√£o segura (copia antes de processar)
function normalizeSafe(raw) {
    // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
    return pickAnalysisFields(raw); // ‚úÖ LEITURA DIRETA
}

// üÜî SISTEMA runId - Fun√ß√£o utilit√°ria centralizada
function generateAnalysisRunId(context = 'ui') {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${context}_${timestamp}_${random}`;
}

// üõ°Ô∏è HELPER: Preparar options com runId de forma segura
function prepareAnalysisOptions(baseOptions = {}, context = 'analysis') {
    // Gerar runId se n√£o fornecido
    if (!baseOptions.runId) {
        baseOptions.runId = generateAnalysisRunId(context);
    }
    
    // Configurar vari√°vel global para UI_GATE
    window.__CURRENT_ANALYSIS_RUN_ID__ = baseOptions.runId;
    
    __dbg(`üÜî [runId] Preparado para an√°lise: ${baseOptions.runId} (contexto: ${context})`);
    
    return { ...baseOptions };
}

// üîç FUN√á√ÉO DE DIAGN√ìSTICO DO FLUXO DE REFER√äNCIA
window.diagnosticReferenceFlow = function() {
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#00FFFF;font-weight:bold;');
    console.log('%cüîç DIAGN√ìSTICO COMPLETO DO FLUXO DE REFER√äNCIA', 'color:#00FFFF;font-weight:bold;');
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#00FFFF;font-weight:bold;');
    
    console.log('%cüìä Estado Atual:', 'color:#FFD700;font-weight:bold;');
    console.log('  Mode:', currentAnalysisMode);
    console.log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'null');
    console.log('  localStorage.referenceJobId:', localStorage.getItem('referenceJobId') || 'null');
    
    console.log('%cüóÇÔ∏è Estado Global:', 'color:#FFD700;font-weight:bold;');
    console.log('  window.__soundyState:', window.__soundyState);
    console.log('  previousAnalysis:', window.__soundyState?.previousAnalysis?.jobId || 'null');
    console.log('  userAnalysis:', window.__soundyState?.userAnalysis?.jobId || 'null');
    console.log('  referenceAnalysis:', window.__soundyState?.referenceAnalysis?.jobId || 'null');
    
    console.log('%cüíæ Dados de Refer√™ncia:', 'color:#FFD700;font-weight:bold;');
    console.log('  FirstAnalysisStore:', FirstAnalysisStore.has() ? 'PRESENTE' : 'null');
    console.log('  window.referenceComparisonMetrics:', window.referenceComparisonMetrics ? 'PRESENTE' : 'null');
    
    console.log('%cüéØ Diagn√≥stico:', 'color:#00FF00;font-weight:bold;');
    // üéØ CORRE√á√ÉO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');
    if (currentAnalysisMode === 'reference') {
        if (!refId) {
            console.log('  ‚úÖ Primeira m√∫sica - pronto para receber segunda');
        } else {
            console.log('  ‚úÖ Aguardando segunda m√∫sica');
            console.log(`  üìå Job ID da primeira: ${refId}`);
        }
    } else {
        console.log('  ‚ÑπÔ∏è Modo atual n√£o √© "reference"');
    }
    
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#00FFFF;font-weight:bold;');
    console.log('%cüí° Para testar:', 'color:#FFFF00;');
    console.log('  1. Fa√ßa upload da primeira m√∫sica');
    console.log('  2. Verifique se [REF-SAVE ‚úÖ] aparece');
    console.log('  3. Fa√ßa upload da segunda m√∫sica');
    console.log('  4. Verifique se [REF-LOAD ‚úÖ] e [REF-FIX-PAYLOAD] aparecem');
    console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color:#00FFFF;font-weight:bold;');
};

let currentModalAnalysis = null;
let __audioIntegrationInitialized = false; // evita listeners duplicados
let __refDataCache = {}; // cache por g√™nero
let __activeRefData = null; // dados do g√™nero atual
let __genreManifest = null; // manifesto de g√™neros (opcional)
let __activeRefGenre = null; // chave do g√™nero atualmente carregado em __activeRefData
let __refDerivedStats = {}; // estat√≠sticas agregadas (ex: m√©dia stereo) por g√™nero

// üéØ MODO REFER√äNCIA - Vari√°veis globais
let currentAnalysisMode = 'genre'; // 'genre' | 'reference'
let referenceStepState = {
    currentStep: 'userAudio', // 'userAudio' | 'referenceAudio' | 'analysis'
    userAudioFile: null,
    referenceAudioFile: null,
    userAnalysis: null,
    referenceAnalysis: null
};

// üõ°Ô∏è PROTE√á√ÉO CR√çTICA: Flag para rastrear se usu√°rio EXPLICITAMENTE selecionou modo reference
// Impede que o sistema ative modo A/B automaticamente quando usu√°rio est√° em modo genre
let userExplicitlySelectedReferenceMode = false;

// ========================================
// üî• STATE MACHINE - VIEW MODE CONTROLLER
// ========================================
// Controla qual UI deve ser renderizada (g√™nero vs refer√™ncia)
// Impede contamina√ß√£o entre modos
window.__soundyViewMode = window.__soundyViewMode || "genre";

function setViewMode(mode) {
    const validModes = ["genre", "reference"];
    if (!validModes.includes(mode)) {
        console.error("[VIEW-MODE] ‚ùå Modo inv√°lido:", mode);
        return;
    }
    
    const oldMode = window.__soundyViewMode;
    window.__soundyViewMode = mode;
    
    console.log(`%c[VIEW-MODE] üîÑ Alterado: ${oldMode} ‚Üí ${mode}`, 'color:#00D9FF;font-weight:bold;font-size:13px;');
    
    // Limpar estado do modo anterior
    if (mode === "genre" && oldMode === "reference") {
        console.log("[VIEW-MODE] üßπ Limpando estado de refer√™ncia ao mudar para g√™nero");
        resetReferenceStateFully();
    }
}

function getViewMode() {
    return window.__soundyViewMode || "genre";
}

// üîí GUARD: Bloqueia execu√ß√£o de UI de refer√™ncia no modo g√™nero
function canRunReferenceUI(analysis) {
    // UI de refer√™ncia s√≥ pode renderizar na segunda track
    if (!SOUNDY_MODE_ENGINE.isReferenceCompare()) {
        return false;
    }

    if (!analysis) {
        return false;
    }

    const hasRefComparison = !!analysis.referenceComparison;
    const hasRefJobId = !!analysis.referenceJobId || !!analysis.metadata?.referenceJobId;

    if (!hasRefComparison && !hasRefJobId) {
        return false;
    }

    return true;
}

// üéØ COMPARA√á√ÉO ENTRE FAIXAS - Armazenamento da primeira an√°lise
window.lastReferenceJobId = null;
// ‚ùå REMOVER: window.referenceAnalysisData agora √© definido como getter read-only dinamicamente
// quando a primeira an√°lise √© salva via FirstAnalysisStore.setOnce()

// üéØ COMPARA√á√ÉO ENTRE FAIXAS - M√©tricas de compara√ß√£o (substitui __activeRefData quando em modo reference)
let referenceComparisonMetrics = null;

// üéØ JOBS - Sistema de acompanhamento de jobs remotos
let currentJobId = null;
let jobPollingInterval = null;

// üéØ Fun√ß√µes de Acessibilidade e Gest√£o de Modais

function openModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no primeiro bot√£o
        const firstButton = modal.querySelector('.mode-card button');
        if (firstButton) {
            firstButton.focus();
        }
        
        // Adicionar listener para ESC
        document.addEventListener('keydown', handleModalEscapeKey);
        
        // Trap focus no modal
        trapFocus(modal);
    }
}

function closeModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        
        // Remover listeners
        document.removeEventListener('keydown', handleModalEscapeKey);
        
        // Retornar foco para o bot√£o que abriu o modal
        const audioAnalysisBtn = document.querySelector('button[onclick="openAudioModal()"]');
        if (audioAnalysisBtn) {
            audioAnalysisBtn.focus();
        }
    }
}

function handleModalEscapeKey(e) {
    if (e.key === 'Escape') {
        closeModeSelectionModal();
    }
}

function trapFocus(modal) {
    const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const handleTabKey = (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
            } else if (!e.shiftKey && document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
            }
        }
    };
    
    modal.addEventListener('keydown', handleTabKey);
}

// üéØ Fun√ß√£o Principal de Sele√ß√£o de Modo
function selectAnalysisMode(mode) {
    console.log('üéØ Modo selecionado:', mode);
    
    // ========================================
    // üî• BARREIRA 4: LIMPEZA AO SELECIONAR MODO G√äNERO
    // ========================================
    if (mode === 'genre') {
        console.log('%c[GENRE-BARRIER] üöß BARREIRA 4 ATIVADA: Modo g√™nero selecionado', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
        
        // üî• EXECUTAR LIMPEZA COMPLETA do estado de refer√™ncia
        resetReferenceStateFully();
        
        // üõ°Ô∏è PROTE√á√ÉO: Resetar flag de sele√ß√£o expl√≠cita
        userExplicitlySelectedReferenceMode = false;
        console.log('%c[PROTECTION] ‚úÖ Flag userExplicitlySelectedReferenceMode resetada para false', 'color:#00FF88;font-weight:bold;');
        
        console.log('%c[GENRE-BARRIER] ‚úÖ BARREIRA 4 CONCLU√çDA: Estado limpo ao selecionar g√™nero', 'color:#00FF88;font-weight:bold;');
    }
    
    // üõ°Ô∏è PROTE√á√ÉO: Definir flag quando usu√°rio seleciona modo reference EXPLICITAMENTE
    if (mode === 'reference') {
        userExplicitlySelectedReferenceMode = true;
        console.log('%c[PROTECTION] ‚úÖ Flag userExplicitlySelectedReferenceMode ATIVADA - usu√°rio clicou em modo A/B', 'color:#FFD700;font-weight:bold;font-size:14px;');
    }
    
    // Armazenar modo selecionado
    window.currentAnalysisMode = mode;
    
    // Fechar modal de sele√ß√£o
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // Modo tradicional - abrir modal de an√°lise normal
        openAnalysisModalForMode('genre');
    } else if (mode === 'reference') {
        // Modo refer√™ncia - abrir interface espec√≠fica
        openAnalysisModalForMode('reference');
    }
}

// üéØ Modal de An√°lise por Refer√™ncia
function openReferenceAnalysisModal() {
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        // Configurar modal para modo refer√™ncia
        const modalContent = modal.querySelector('.modal-content');
        const title = modalContent.querySelector('h2');
        const steps = document.getElementById('referenceProgressSteps');
        
        if (title) {
            title.textContent = 'üéµ An√°lise por M√∫sica de Refer√™ncia';
        }
        
        // Mostrar passos do progresso
        if (steps) {
            steps.style.display = 'block';
            updateProgressStep(1); // Primeiro passo ativo
        }
        
        // Modificar texto do bot√£o de upload
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn) {
            uploadBtn.textContent = 'üì§ Upload da M√∫sica Original';
            uploadBtn.onclick = () => handleReferenceFileSelection('original');
        }
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no bot√£o de upload
        if (uploadBtn) {
            uploadBtn.focus();
        }
    }
}

// üéØ Gest√£o de Progresso para Modo Refer√™ncia
function updateProgressStep(step) {
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((stepEl, index) => {
        const stepNumber = index + 1;
        stepEl.classList.remove('active', 'completed');
        
        if (stepNumber < step) {
            stepEl.classList.add('completed');
        } else if (stepNumber === step) {
            stepEl.classList.add('active');
        }
    });
}

// ÔøΩ SISTEMA DE UPLOAD E AN√ÅLISE REMOTA
// ‚úÖ FLUXO OFICIAL: Presigned URL ‚Üí Upload ‚Üí Job Creation ‚Üí Status Polling

// ÔøΩüéØ Sele√ß√£o de Arquivos para Modo Refer√™ncia (fileKeys apenas)
let uploadedFiles = {
    original: null,
    reference: null
};

/**
 * ‚úÖ OBTER URL PR√â-ASSINADA DO BACKEND
/**
 * Obter URL pr√©-assinada do backend
/**
 * üöÄ OBTER URL PR√â-ASSINADA DO BACKEND
 * @param {File} file - Arquivo para upload
 * @returns {Promise<{uploadUrl: string, fileKey: string}>}
 */
async function getPresignedUrl(file) {
  try {
    // Extrair extens√£o do arquivo
    const ext = file.name.split('.').pop().toLowerCase();

    __dbg('üåê Solicitando URL pr√©-assinada...', {
      filename: file.name,
      ext,
           size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
    });

    // ‚úÖ Agora manda "ext" 
    const response = await fetch(`/api/presign?ext=${encodeURIComponent(ext)}`, {
  method: "GET",
  headers: {
    "Accept": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao obter URL de upload: ${response.status} - ${errorText}`);
    }

    const data = await response.json();

    if (!data.uploadUrl || !data.fileKey) {
      throw new Error('Resposta inv√°lida do servidor: uploadUrl ou fileKey ausente');
    }

    return {
      uploadUrl: data.uploadUrl,
      fileKey: data.fileKey
    };
  } catch (error) {
    console.error('‚ùå Erro ao obter URL pr√©-assinada:', error);
    throw new Error(`Falha ao gerar URL de upload: ${error.message}`);
  }
}



/**
 * ‚úÖ UPLOAD DIRETO PARA BUCKET VIA URL PR√â-ASSINADA
 * @param {string} uploadUrl - URL pr√©-assinada para upload
 * @param {File} file - Arquivo para upload
 * @returns {Promise<void>}
 */
async function uploadToBucket(uploadUrl, file) {
  try {
    __dbg('üì§ Iniciando upload para bucket...', { 
      filename: file.name,
      size: `${(file.size / 1024 / 1024).toFixed(2)}MB`,
      url: uploadUrl.substring(0, 50) + '...'
    });

    showUploadProgress(`Enviando ${file.name} para an√°lise...`);

    // üëá sem headers, s√≥ body = file
   const response = await fetch(uploadUrl, {
  method: "PUT",
  body: file
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
    }

    __dbg('‚úÖ Upload para bucket conclu√≠do com sucesso');
    showUploadProgress(`Upload conclu√≠do! Processando ${file.name}...`);

  } catch (error) {
    console.error('‚ùå Erro no upload para bucket:', error);
    throw new Error(`Falha ao enviar arquivo para an√°lise: ${error.message}`);
  }
}


/**
 * ‚úÖ CRIAR JOB DE AN√ÅLISE NO BACKEND
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} mode - Modo de an√°lise ('genre' ou 'reference')
 * @param {string} fileName - Nome original do arquivo
 * @returns {Promise<{jobId: string, success: boolean}>}
 */
async function createAnalysisJob(fileKey, mode, fileName) {
    try {
        __dbg('üîß Criando job de an√°lise...', { fileKey, mode, fileName });

        // üîß FIX CR√çTICO: Detectar se √© primeira ou segunda m√∫sica no modo refer√™ncia
        // üéØ CORRE√á√ÉO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
        console.group('üîç [AUDIT-LOCALSTORAGE] createAnalysisJob - Leitura de referenceJobId');
        console.log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        console.log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
        
        // üéØ USA FUN√á√ÉO SEGURA ao inv√©s de acesso direto
        let referenceJobId = getCorrectJobId('reference'); // Primeira m√∫sica
        
        console.log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
        console.log('   - Mode:', mode);
        console.trace('   - Stack trace:');
        console.groupEnd();
        
        let actualMode = mode;
        let isReferenceBase = false; // üîß FIX: Flag para diferenciar primeira m√∫sica da refer√™ncia
        
        // üéØ CORRE√á√ÉO DO FLUXO: Primeira m√∫sica como "genre", segunda como "reference"
        if (mode === 'reference') {
            // üîÑ RECUPERA√á√ÉO: Tentar restaurar referenceJobId de m√∫ltiplas fontes
            if (!referenceJobId && window.__soundyState?.previousAnalysis?.jobId) {
                referenceJobId = window.__soundyState.previousAnalysis.jobId;
                console.log('[REF-LOAD ‚úÖ] Reference Job ID restaurado do estado:', referenceJobId);
            }

            if (referenceJobId) {
                // TEM referenceJobId = √â A SEGUNDA M√öSICA
                actualMode = 'reference'; // Mant√©m "reference"
                isReferenceBase = false; // Segunda m√∫sica n√£o √© base
                console.log('[MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('[MODE ‚úÖ] SEGUNDA m√∫sica detectada');
                console.log('[MODE ‚úÖ] Mode enviado: "reference"');
                console.log(`[MODE ‚úÖ] Reference Job ID: ${referenceJobId}`);
                console.log('[MODE ‚úÖ] Compara√ß√£o A/B ser√° realizada no backend');
                console.log('[MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            } else {
                // N√ÉO TEM referenceJobId = √â A PRIMEIRA M√öSICA
                actualMode = 'genre'; // Envia como "genre" para an√°lise normal
                isReferenceBase = true; // üîß FIX: Marcar como primeira m√∫sica da refer√™ncia
                console.log('[MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('[MODE ‚úÖ] PRIMEIRA m√∫sica detectada');
                console.log('[MODE ‚úÖ] Mode enviado: "genre" (base para compara√ß√£o)');
                console.log('[MODE ‚úÖ] isReferenceBase: true (diferencia de an√°lise de g√™nero pura)');
                console.log('[MODE ‚úÖ] Esta an√°lise ser√° salva como refer√™ncia');
                console.log('[MODE ‚úÖ] Pr√≥xima m√∫sica ser√° comparada com esta');
                console.log('[MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            }
        }
        
        // üîí PATCH: PRESERVAR G√äNERO ANTES DE MONTAR PAYLOAD
        preserveGenreState();
        
        // üéØ Usar SEMPRE o __CURRENT_SELECTED_GENRE (n√£o o dropdown)
        let finalGenre = window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE;
        
        // üö® LOG DE AUDITORIA: Genre antes de enviar
        console.log('[GENRE-PAYLOAD-SEND] üì§ Enviando payload:', {
            genre: finalGenre,
            mode: actualMode,
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            currentMode: window.__CURRENT_MODE__
        });
        
        // üéØ CORRE√á√ÉO CR√çTICA: Extrair targets da an√°lise anterior se dispon√≠vel
        let finalTargets = null;
        
        // Prioridade 1: Se h√° an√°lise anterior, extrair targets dela (FONTE OFICIAL)
        const previousAnalysis = window.currentAnalysisData || window.__soundyState?.previousAnalysis;
        if (previousAnalysis) {
            console.log('[CREATE-JOB] üéØ Extraindo targets da an√°lise anterior (FONTE OFICIAL)');
            finalTargets = extractGenreTargetsFromAnalysis(previousAnalysis);
            if (finalTargets) {
                console.log('[CREATE-JOB] ‚úÖ Targets extra√≠dos de analysis.data.genreTargets:', Object.keys(finalTargets));
            }
        }
        
        // Prioridade 2 (FALLBACK): Usar vari√°veis globais
        if (!finalTargets) {
            console.warn('[CREATE-JOB] ‚ö†Ô∏è FALLBACK: Usando targets das vari√°veis globais');
            finalTargets = window.__CURRENT_GENRE_TARGETS || window.currentGenreTargets || window.__activeRefData?.targets;
        }
        
        // üîí Valida√ß√£o robusta ‚Äî nunca deixar vir vazio
        if (!finalGenre || typeof finalGenre !== "string" || finalGenre.trim() === "") {
            // √öltima tentativa: buscar do dropdown
            const genreSelect = document.getElementById('audioRefGenreSelect');
            finalGenre = genreSelect?.value || "default";
        }
        
        // Sanitizar
        finalGenre = finalGenre.trim();
        
        // ‚úÖ GARANTIR que targets sejam inclu√≠dos no payload
        if (finalTargets) {
            console.log('‚úÖ [CREATE-JOB] Targets de g√™nero inclu√≠dos no payload:', {
                genre: finalGenre,
                hasTargets: !!finalTargets,
                targetKeys: Object.keys(finalTargets),
                targetSource: window.__activeRefData?.targetSource
            });
        } else {
            console.warn('‚ö†Ô∏è [CREATE-JOB] Nenhum target encontrado para g√™nero:', finalGenre);
        }
        
        // LOG obrigat√≥rio
        console.log("[GENRE FINAL PAYLOAD]", {
            finalGenre,
            hasTargets: !!finalTargets,
            targetCount: finalTargets ? Object.keys(finalTargets).length : 0,
            refGenre: window.PROD_AI_REF_GENRE,
            currentSelected: window.__CURRENT_SELECTED_GENRE
        });

        // Montar payload com modo correto
        const payload = {
            fileKey: fileKey,
            mode: actualMode,
            fileName: fileName,
            isReferenceBase: isReferenceBase,
            genre: finalGenre, // üîí PATCH: Usar finalGenre sempre
            genreTargets: finalTargets, // üîí PATCH: Incluir targets
            hasTargets: !!finalTargets // üîí PATCH: Flag indicando presen√ßa de targets
        };
        
        // üî• GUARD PREVENTIVO: NUNCA enviar sem g√™nero ou targets
        if (!payload.genre || !payload.genreTargets) {
            const errorMsg = `[GENRE-ERROR] G√™nero ou targets ausentes antes do envio do job. Genre: ${payload.genre}, HasTargets: ${!!payload.genreTargets}`;
            console.error(errorMsg);
            throw new Error(errorMsg);
        }
        
        console.log('[GENRE-GUARD] ‚úÖ Payload validado:', {
            genre: payload.genre,
            hasTargets: payload.hasTargets,
            targetCount: payload.genreTargets ? Object.keys(payload.genreTargets).length : 0
        });
        
        // Adicionar referenceJobId apenas se existir
        if (referenceJobId && actualMode === 'reference') {
            payload.referenceJobId = referenceJobId;
            
            console.log('[REF-PAYLOAD ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('[REF-PAYLOAD ‚úÖ] Payload COM referenceJobId:');
            console.log(`[REF-PAYLOAD ‚úÖ]   mode: "${actualMode}"`);
            console.log(`[REF-PAYLOAD ‚úÖ]   referenceJobId: "${referenceJobId}"`);
            console.log(`[REF-PAYLOAD ‚úÖ]   fileName: "${fileName}"`);
            console.log('[REF-PAYLOAD ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        } else if (mode === 'reference' && !referenceJobId) {
            console.log('[REF-PAYLOAD ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('[REF-PAYLOAD ‚úÖ] Payload SEM referenceJobId (primeira m√∫sica):');
            console.log(`[REF-PAYLOAD ‚úÖ]   mode: "${actualMode}" (an√°lise base)`);
            console.log(`[REF-PAYLOAD ‚úÖ]   isReferenceBase: ${isReferenceBase}`);
            console.log(`[REF-PAYLOAD ‚úÖ]   fileName: "${fileName}"`);
            console.log('[REF-PAYLOAD ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        }

        // üîç LOG FINAL: Mostrar payload completo antes do envio com cores
        console.log('%c[REF-FIX-VERIFY]', 'color:#00FFFF;font-weight:bold;', { mode, referenceJobId });
        console.log('%c[REF-FIX-PAYLOAD]', 'color:#7A3FFF;font-weight:bold;', payload);
        
        console.log('[FIX_REFID_PAYLOAD] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('[FIX_REFID_PAYLOAD] Payload final sendo enviado para /api/audio/analyze:');
        console.log('[FIX_REFID_PAYLOAD]', JSON.stringify(payload, null, 2));
        console.log('[FIX_REFID_PAYLOAD] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // üîí LOG OBRIGAT√ìRIO ANTES DO FETCH
        console.log("[GENRE FINAL PAYLOAD SENT]", payload);

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Erro ao criar job: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        console.log("[ANALYZE-RESPONSE]", data);

        // üîí CAPTURA ROBUSTA: M√∫ltiplas tentativas de obter jobId
        const newJobId =
            data.jobId ||
            data.id ||
            data.job?.id;

        if (!newJobId) {
            console.error("[ANALYZE] ‚ùå Nenhum jobId retornado pelo backend!", data);
            throw new Error('Resposta inv√°lida do servidor: jobId ausente');
        }

        __dbg('‚úÖ Job de an√°lise criado:', { 
            jobId: newJobId,
            mode: data.mode,
            fileKey: data.fileKey
        });

        return {
            jobId: newJobId,
            success: true
        };

    } catch (error) {
        console.error('‚ùå Erro ao criar job de an√°lise:', error);
        throw new Error(`Falha ao criar job de an√°lise: ${error.message}`);
    }
}

/**
 * ‚úÖ ACOMPANHAR STATUS DO JOB DE AN√ÅLISE
 * @param {string} jobId - ID do job
 * @returns {Promise<Object>} - Resultado da an√°lise quando completa
 */
async function pollJobStatus(jobId) {
    // üîí BLINDAGEM: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== "string") {
        console.error("[POLLING] ‚ùå jobId inv√°lido ou undefined:", jobId);
        return Promise.reject(new Error("Job ID inv√°lido - polling abortado"));
    }

    console.log("[POLLING] ‚úÖ Iniciando com jobId v√°lido:", jobId);

    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 60; // 5 minutos m√°ximo (5s * 60 = 300s)
        let initialQueuePosition = null;
        
        const poll = async () => {
            try {
                attempts++;
                __dbg(`üîÑ Verificando status do job (tentativa ${attempts}/${maxAttempts})...`);

                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao verificar status: ${response.status}`);
                }

                const jobData = await response.json();
                
                // üîß COMPATIBILIDADE: Suporte para formato novo (ok/job) e antigo
                const job = jobData.job || jobData;
                const status = job.status || jobData.status;
                
                __dbg(`üìä Status do job:`, { 
                    status: status, 
                    progress: job.progress || jobData.progress || 'N/A' 
                });

                // Calcular progresso baseado na posi√ß√£o da fila
                let calculatedProgress = 0;
                let progressMessage = 'üöÄ Inicializando...';
                
                // Obter status da fila se dispon√≠vel
                const queueStatus = window.getAudioQueueStatus ? window.getAudioQueueStatus() : null;
                
                if (status === 'queued') {
                    // Job na fila - calcular posi√ß√£o
                    if (queueStatus && queueStatus.queue) {
                        const totalInQueue = queueStatus.queue.total || 0;
                        
                        // Armazenar posi√ß√£o inicial na primeira tentativa
                        if (initialQueuePosition === null) {
                            initialQueuePosition = totalInQueue;
                        }
                        
                        // Calcular progresso: quanto mais pr√≥ximo de 0, mais perto de processar
                        if (initialQueuePosition > 0) {
                            calculatedProgress = Math.min(
                                Math.max(
                                    ((initialQueuePosition - totalInQueue) / initialQueuePosition) * 50, // 0-50% enquanto na fila
                                    5 // M√≠nimo 5%
                                ),
                                50
                            );
                        } else {
                            calculatedProgress = 10;
                        }
                        
                        progressMessage = `‚è≥ Na fila... Posi√ß√£o: ${totalInQueue + 1} | Processando: ${queueStatus.running || 0}`;
                    } else {
                        calculatedProgress = 10;
                        progressMessage = '‚è≥ Aguardando processamento...';
                    }
                } else if (status === 'processing') {
                    // Job processando - 50% a 95%
                    if (job.progress || jobData.progress) {
                        // Se o backend enviar progresso espec√≠fico, usar e mapear para 50-95%
                        calculatedProgress = 50 + (jobData.progress * 0.45);
                    } else {
                        // Progresso incremental baseado em tentativas
                        calculatedProgress = 50 + Math.min((attempts - (initialQueuePosition || 0)) * 5, 45);
                    }
                    progressMessage = 'üîÑ Analisando √°udio...';
                } else if (status === 'completed' || status === 'done') {
                    calculatedProgress = 100;
                    progressMessage = '‚úÖ An√°lise conclu√≠da!';
                }

                // Atualizar progresso na UI
                updateModalProgress(calculatedProgress, progressMessage);

                if (status === 'completed' || status === 'done') {
                    __dbg('‚úÖ Job conclu√≠do com sucesso');
                    
                    // üéØ NOVO: Verificar modo e decidir fluxo
                    const jobResult = job.results || jobData.results || job.result || jobData.result || jobData;
                    jobResult.jobId = jobId; // Incluir jobId no resultado
                    jobResult.mode = jobData.mode; // Incluir mode no resultado
                    
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    // üîç AUDITORIA COMPLETA - ESTRUTURA REAL DO JSON RECEBIDO
                    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    console.log('\n\nüîçüîçüîç [AUDIT] JSON RECEBIDO DO BACKEND üîçüîçüîç');
                    console.log('[AUDIT] jobResult COMPLETO:', jobResult);
                    console.log('[AUDIT] Keys do jobResult:', Object.keys(jobResult));
                    console.log('[AUDIT] Tipo de jobResult:', typeof jobResult);
                    console.log('[AUDIT] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('[AUDIT] Verificando campos de targets:');
                    console.log('[AUDIT]   ‚úì jobResult.targets:', !!jobResult.targets);
                    console.log('[AUDIT]   ‚úó jobResult.data?.genreTargets:', !!jobResult.data?.genreTargets);
                    console.log('[AUDIT]   ‚úó jobResult.results?.genreTargets:', !!jobResult.results?.genreTargets);
                    console.log('[AUDIT]   ‚úó jobResult.data?.targets:', !!jobResult.data?.targets);
                    console.log('[AUDIT]   ‚úó jobResult.results?.targets:', !!jobResult.results?.targets);
                    console.log('[AUDIT] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    
                    if (jobResult.targets) {
                        console.log('[AUDIT] ‚úÖ CAMPO CORRETO ENCONTRADO: jobResult.targets');
                        console.log('[AUDIT] Keys de targets:', Object.keys(jobResult.targets));
                        console.log('[AUDIT] Estrutura de targets:', {
                            hasLufsTarget: 'lufs_target' in jobResult.targets,
                            hasTruePeakTarget: 'true_peak_target' in jobResult.targets,
                            hasDrTarget: 'dr_target' in jobResult.targets,
                            hasStereoTarget: 'stereo_target' in jobResult.targets,
                            hasBands: 'bands' in jobResult.targets || 'spectral_bands' in jobResult.targets,
                            lufsValue: jobResult.targets.lufs_target,
                            truePeakValue: jobResult.targets.true_peak_target,
                            drValue: jobResult.targets.dr_target,
                            stereoValue: jobResult.targets.stereo_target
                        });
                    } else {
                        console.error('[AUDIT] ‚ùå CAMPO "targets" N√ÉO ENCONTRADO!');
                        console.error('[AUDIT] Estrutura recebida pode estar incorreta');
                    }
                    console.log('üîçüîçüîç [AUDIT] FIM DA AUDITORIA üîçüîçüîç\n\n');
                    
                    // üéØ PATCH CR√çTICO: Garantir que analysis.targets existe (caminho correto)
                    if (jobResult.targets) {
                        console.log('[POLLING] ‚úÖ targets encontrado no jobResult (Postgres)');
                        console.log('[POLLING] Keys:', Object.keys(jobResult.targets));
                    } else if (jobResult.mode === 'genre') {
                        console.warn('[POLLING] ‚ö†Ô∏è Modo genre mas "targets" ausente no JSON');
                        console.warn('[POLLING] Isso pode causar valida√ß√£o incorreta de sugest√µes');
                    }
                    
                    // üî• AUDITORIA CR√çTICA: Verificar technicalData AP√ìS polling
                    console.log('\n\nüî•üî•üî• [AUDIT-TECHNICAL-DATA] FRONTEND POST-POLLING üî•üî•üî•');
                    console.log('[AUDIT-TECHNICAL-DATA] jobResult.technicalData:', {
                      exists: !!jobResult.technicalData,
                      type: typeof jobResult.technicalData,
                      isEmpty: jobResult.technicalData && Object.keys(jobResult.technicalData).length === 0,
                      keys: jobResult.technicalData ? Object.keys(jobResult.technicalData) : [],
                      hasSampleFields: {
                        lufsIntegrated: jobResult.technicalData?.lufsIntegrated,
                        truePeakDbtp: jobResult.technicalData?.truePeakDbtp,
                        dynamicRange: jobResult.technicalData?.dynamicRange,
                        spectral_balance: !!jobResult.technicalData?.spectral_balance
                      }
                    });
                    console.log('[AUDIT-TECHNICAL-DATA] jobResult outros campos:', {
                      hasScore: jobResult.score !== undefined,
                      scoreValue: jobResult.score,
                      hasClassification: !!jobResult.classification,
                      hasTargets: !!jobResult.targets,
                      jobId: jobResult.jobId,
                      mode: jobResult.mode
                    });
                    console.log('üî•üî•üî• [AUDIT-TECHNICAL-DATA] END üî•üî•üî•\n\n');
                    
                    resolve(jobResult);
                    return;
                }

                // ‚ùå JOB COM ERRO
                if (status === 'failed' || status === 'error') {
                    const errorMsg = job.error || jobData.error || 'Erro desconhecido no processamento';
                    reject(new Error(`Falha na an√°lise: ${errorMsg}`));
                    return;
                }

                // Status 'queued', 'processing', etc. - continuar polling
                if (attempts >= maxAttempts) {
                    reject(new Error('Timeout: An√°lise demorou mais que o esperado'));
                    return;
                }

                // Aguardar 5 segundos antes da pr√≥xima verifica√ß√£o
                setTimeout(poll, 5000);

            } catch (error) {
                console.error('‚ùå Erro no polling:', error);
                reject(error);
            }
        };

        // Iniciar polling
        poll();
    });
}

/**
 * Mostrar progresso de upload na UI
 * @param {string} message - Mensagem de progresso
 */
function showUploadProgress(message) {
    const progressText = document.getElementById('audioProgressText');
    if (progressText) {
        progressText.innerHTML = `üåê ${message}`;
    }
}

/**
 * Atualizar progresso do modal de an√°lise
 * @param {number} percentage - Porcentagem (0-100)
 * @param {string} message - Mensagem de status
 */
function updateModalProgress(percentage, message) {
    const progressText = document.getElementById('audioProgressText');
    const progressBar = document.getElementById('audioProgressFill') || document.querySelector('.progress-fill');
    
    if (progressText) {
        progressText.innerHTML = `${message}`;
    }
    
    if (progressBar) {
        // Garantir que a porcentagem est√° entre 0 e 100
        const clampedPercentage = Math.min(Math.max(percentage, 0), 100);
        progressBar.style.width = `${clampedPercentage}%`;
        
        __dbg(`üìä Progresso atualizado: ${clampedPercentage.toFixed(1)}%`);
    }
}

/**
 * ‚úÖ NOVA IMPLEMENTA√á√ÉO: Sele√ß√£o de arquivo de refer√™ncia com presigned URL
 * @param {string} type - Tipo do arquivo ('original' ou 'reference')
 */
function handleReferenceFileSelection(type) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.wav,.flac,.mp3,.m4a';
    input.style.display = 'none';

    input.onchange = async function (e) {
        const file = e.target.files[0];
        if (file) {
            try {
                // Validar arquivo
                if (file.size > 120 * 1024 * 1024) {
                    alert('‚ùå Arquivo muito grande. Limite: 120MB');
                    return;
                }

                __dbg(`üéØ Processando arquivo ${type} com presigned URL:`, file.name);

                // üåê NOVO FLUXO: Presigned URL ‚Üí Upload ‚Üí Job Creation ‚Üí Polling
                
                // 1. Obter URL pr√©-assinada
                const { uploadUrl, fileKey } = await getPresignedUrl(file);
                
                // 2. Upload direto para bucket
                await uploadToBucket(uploadUrl, file);
                
                // 3. Criar job de an√°lise
                const { jobId } = await createAnalysisJob(fileKey, 'reference', file.name);
                
                // 4. Aguardar resultado da an√°lise
                const analysisResult = await pollJobStatus(jobId);
                
                // üîç LOG DE DEBUG: Verificar se an√°lise est√° completa
                console.log('üîç [DEBUG] An√°lise retornada do polling:', {
                    hasResult: !!analysisResult,
                    hasTechnicalData: !!analysisResult?.technicalData,
                    avgLoudness: analysisResult?.technicalData?.avgLoudness,
                    lufsIntegrated: analysisResult?.technicalData?.lufsIntegrated,
                    truePeakDbtp: analysisResult?.technicalData?.truePeakDbtp,
                    dynamicRange: analysisResult?.technicalData?.dynamicRange
                });
                
                // üß© AUDITORIA 1: Verificar se displayModalResults est√° dispon√≠vel
                console.log("[AUDITORIA] displayModalResults:", typeof window.displayModalResults);
                
                // Mostrar resultados no modal (com valida√ß√£o interna de m√©tricas)
                const tryShowModal = (result, attempts = 0) => {
                    if (typeof window.displayModalResults === "function") {
                        console.log("‚úÖ [AUDITORIA] displayModalResults encontrada, exibindo modal...");
                        console.log("‚úÖ [RETRY_SUCCESS] Tentativa", attempts + 1, "bem-sucedida, chamando displayModalResults");
                        console.log("[DISPLAY] Metrics modal triggered from tryShowModal");
                        displayModalResults(result);
                    } else if (attempts < 10) {
                        console.warn("[AUDITORIA] displayModalResults n√£o dispon√≠vel, tentativa", attempts + 1);
                        setTimeout(() => tryShowModal(result, attempts + 1), 500);
                    } else {
                        console.error("[AUDITORIA] Falha ao exibir modal ap√≥s m√∫ltiplas tentativas");
                        // Fallback: tentar exibir em modal simples
                        alert("An√°lise conclu√≠da, mas modal n√£o p√¥de ser exibido. Verifique o console para dados.");
                        console.log("[AUDITORIA] Dados da an√°lise:", result);
                    }
                };
                
                tryShowModal(analysisResult);

                // 5. Armazenar resultado
                uploadedFiles[type] = {
                    fileKey: fileKey,
                    fileName: file.name,
                    analysisResult: analysisResult
                };

                console.log(`‚úÖ Arquivo ${type} processado com sucesso:`, file.name, "fileKey:", fileKey);

                // Atualizar interface
                updateFileStatus(type, file.name);

                // Avan√ßar fluxo
                if (type === "original") {
                    updateProgressStep(2);
                    promptReferenceFile();
                } else if (type === "reference") {
                    updateProgressStep(3);
                    enableAnalysisButton();
                }

            } catch (error) {
                console.error(`‚ùå Erro no processamento do arquivo ${type}:`, error);
                alert(`‚ùå Erro ao processar arquivo: ${error.message}`);

                // Abrir modal de an√°lise em caso de erro
                abrirModalDeAnalise("Erro ao processar arquivo para an√°lise.");
            }
        }
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}


function updateFileStatus(type, filename) {
    const statusContainer = document.getElementById('fileUploadStatus');
    if (!statusContainer) return;
    
    let statusDiv = statusContainer.querySelector(`#${type}FileStatus`);
    if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = `${type}FileStatus`;
        statusDiv.className = 'file-status';
        statusContainer.appendChild(statusDiv);
    }
    
    const label = type === 'original' ? 'üéµ M√∫sica Original' : 'üéØ Refer√™ncia';
    statusDiv.innerHTML = `
        <div class="file-item">
            <span class="file-label">${label}:</span>
            <span class="file-name">${filename}</span>
            <span class="file-check">‚úÖ</span>
        </div>
    `;
}

function promptReferenceFile() {
    const modal = document.getElementById('audioAnalysisModal');
    const uploadBtn = modal.querySelector('#uploadButton');
    
    if (uploadBtn) {
        uploadBtn.textContent = 'üéØ Upload da M√∫sica de Refer√™ncia';
        uploadBtn.onclick = () => handleReferenceFileSelection('reference');
    }
}

function enableAnalysisButton() {
    const modal = document.getElementById('audioAnalysisModal');
    let analyzeBtn = modal.querySelector('#analyzeReferenceBtn');
    
    if (!analyzeBtn) {
        analyzeBtn = document.createElement('button');
        analyzeBtn.id = 'analyzeReferenceBtn';
        analyzeBtn.className = 'btn btn-primary';
        analyzeBtn.textContent = 'üî¨ Iniciar An√°lise Comparativa';
        analyzeBtn.onclick = startReferenceAnalysis;
        
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn && uploadBtn.parentNode) {
            uploadBtn.parentNode.insertBefore(analyzeBtn, uploadBtn.nextSibling);
        }
    }
    
    analyzeBtn.style.display = 'block';
    analyzeBtn.disabled = false;
}

// üéØ An√°lise Comparativa
async function startReferenceAnalysis() {
    if (!uploadedFiles.original || !uploadedFiles.reference) {
        alert('‚ùå Por favor, fa√ßa upload de ambos os arquivos');
        return;
    }

    updateProgressStep(4);

    try {
        showAnalysisProgress();

        // üéØ Extrair g√™nero selecionado do dropdown
        const genreSelect = document.getElementById('audioRefGenreSelect');
        let selectedGenre = genreSelect?.value;
        
        // üéØ CORRE√á√ÉO: Validar se √© string n√£o-vazia antes de fallback
        if (!selectedGenre || selectedGenre.trim() === '') {
            selectedGenre = window.PROD_AI_REF_GENRE || 'default';
        }
        
        console.log('[TRACE-GENRE][FRONTEND-REF] üéµ G√™nero para an√°lise de refer√™ncia:', {
            'genreSelect.value': genreSelect?.value,
            'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE,
            'selectedGenre (final)': selectedGenre
        });

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                originalKey: uploadedFiles.original,
                referenceKey: uploadedFiles.reference,
                mode: 'reference',
                genre: selectedGenre // üéØ FIX CR√çTICO: G√™nero agora inclu√≠do
            })
        });

        if (!response.ok) {
            throw new Error(`Erro na an√°lise: ${response.status}`);
        }

        const result = await response.json();
        displayReferenceComparison(result);

    } catch (error) {
        console.error('‚ùå Erro na an√°lise:', error);
        alert('‚ùå Erro durante a an√°lise. Tente novamente.');
    }
}


function showAnalysisProgress() {
    const modal = document.getElementById('audioAnalysisModal');
    const content = modal.querySelector('.modal-content');
    
    // Criar overlay de progresso
    const progressOverlay = document.createElement('div');
    progressOverlay.id = 'analysisProgressOverlay';
    progressOverlay.className = 'analysis-progress-overlay';
    progressOverlay.innerHTML = `
        <div class="progress-content">
            <div class="spinner"></div>
            <h3>üî¨ Analisando Arquivos...</h3>
            <p>Processando caracter√≠sticas espectrais e comparando com refer√™ncia...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
        </div>
    `;
    
    content.appendChild(progressOverlay);
}

function displayReferenceComparison(data) {
    const modal = document.getElementById('audioAnalysisModal');
    const progressOverlay = document.getElementById('analysisProgressOverlay');
    
    // Remover overlay de progresso
    if (progressOverlay) {
        progressOverlay.remove();
    }
    
    // Criar se√ß√£o de resultados
    const resultsSection = document.createElement('div');
    resultsSection.id = 'referenceResults';
    resultsSection.className = 'reference-results';
    
    resultsSection.innerHTML = generateComparisonHTML(data);
    
    const content = modal.querySelector('.modal-content');
    content.appendChild(resultsSection);
    
    // Scroll para resultados
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

function generateComparisonHTML(data) {
    const { original, reference, comparison } = data;
    
    return `
        <div class="comparison-header">
            <h3>üìä An√°lise Comparativa Conclu√≠da</h3>
            <div class="overall-similarity">
                <span class="similarity-label">Similaridade Geral:</span>
                <span class="similarity-score ${getSimilarityClass(comparison.overallSimilarity)}">
                    ${comparison.overallSimilarity}%
                </span>
            </div>
        </div>
        
        <div class="comparison-grid">
            <div class="comparison-section">
                <h4>üéµ M√∫sica Original</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(original)}
                </div>
            </div>
            
            <div class="comparison-section">
                <h4>üéØ M√∫sica de Refer√™ncia</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(reference)}
                </div>
            </div>
        </div>
        
        <div class="differences-section">
            <h4>üîç Principais Diferen√ßas</h4>
            <div class="differences-grid">
                ${generateDifferencesGrid(comparison.differences)}
            </div>
        </div>
        
        <div class="suggestions-section">
            <h4>üí° Sugest√µes de Melhoria</h4>
            <div class="suggestions-list">
                ${generateSuggestionsList(comparison.suggestions)}
            </div>
        </div>
    `;
}

function generateAudioAnalysisCard(analysis) {
    return `
        <div class="spectral-info">
            <div class="info-item">
                <span class="label">Frequ√™ncia Fundamental:</span>
                <span class="value">${analysis.fundamentalFreq} Hz</span>
            </div>
            <div class="info-item">
                <span class="label">Faixa Din√¢mica:</span>
                <span class="value">${analysis.dynamicRange} dB</span>
            </div>
            <div class="info-item">
                <span class="label">Stereo Width:</span>
                <span class="value">${analysis.stereoWidth}%</span>
            </div>
        </div>
        
        <!-- REMOVED: Bandas de Frequ√™ncia duplicada - consolidada nas m√©tricas avan√ßadas -->
        <!-- frequency-bands section removed to avoid duplication -->
    `;
}

function generateDifferencesGrid(differences) {
    return differences.map(diff => `
        <div class="difference-item ${diff.severity}">
            <div class="diff-header">
                <span class="diff-parameter">${diff.parameter}</span>
                <span class="diff-value">${diff.difference}</span>
            </div>
            <div class="diff-description">${diff.description}</div>
        </div>
    `).join('');
}

function generateSuggestionsList(suggestions) {
    return suggestions.map(suggestion => `
        <div class="suggestion-item">
            <div class="suggestion-title">${suggestion.title}</div>
            <div class="suggestion-description">${suggestion.description}</div>
            <div class="suggestion-priority priority-${suggestion.priority}">
                Prioridade: ${suggestion.priority.toUpperCase()}
            </div>
        </div>
    `).join('');
}

function getSimilarityClass(similarity) {
    if (similarity >= 80) return 'high-similarity';
    if (similarity >= 60) return 'medium-similarity';
    return 'low-similarity';
}

// üéØ Exposi√ß√£o de Fun√ß√µes Globais
window.openModeSelectionModal = openModeSelectionModal;
window.closeModeSelectionModal = closeModeSelectionModal;
window.selectAnalysisMode = selectAnalysisMode;

//! DEBUG: Fun√ß√£o de debug global para for√ßar recarga
window.forceReloadRefs = async function(genre = 'funk_bruxaria') {
    console.log('üîÑ FOR√áA RECARGA DE REFER√äNCIAS:', genre);
    
    // Limpar tudo
    delete window.__refDataCache;
    window.__refDataCache = {};
    window.REFS_BYPASS_CACHE = true;
    window.__activeRefData = null;
    window.__activeRefGenre = null;
    delete window.PROD_AI_REF_DATA;
    
    console.log('üí• Cache limpo, for√ßando reload...');
    
    try {
        const result = await loadReferenceData(genre);
        console.log('‚úÖ Recarga for√ßada conclu√≠da:', {
            version: result.version,
            lufs_target: result.lufs_target,
            true_peak_target: result.true_peak_target,
            presenca_band: result.bands?.presenca?.target_db
        });
        
        // Resetar flag
        window.REFS_BYPASS_CACHE = false;
        return result;
    } catch (error) {
        console.error('üí• Erro na recarga for√ßada:', error);
        window.REFS_BYPASS_CACHE = false;
        throw error;
    }
};

// üîç Fun√ß√£o de Diagn√≥stico de Refer√™ncias (somente dev)
window.diagnosRefSources = function(genre = null) {
    const targetGenre = genre || __activeRefGenre || 'funk_bruxaria';
    const currentData = __activeRefData;
    const cached = __refDataCache[targetGenre];
    
    console.log('üéØ REFER√äNCIAS DIAGN√ìSTICO COMPLETO:', {
        requestedGenre: targetGenre,
        activeGenre: __activeRefGenre,
        currentSource: currentData ? 'loaded' : 'none',
        cacheExists: !!cached,
        REFS_ALLOW_NETWORK: typeof window !== 'undefined' ? window.REFS_ALLOW_NETWORK : 'undefined',
        currentData: currentData ? {
            version: currentData.version,
            num_tracks: currentData.num_tracks,
            lufs_target: currentData.lufs_target,
            true_peak_target: currentData.true_peak_target,
            stereo_target: currentData.stereo_target,
            sub_band: currentData.bands?.sub?.target_db,
            presenca_band: currentData.bands?.presenca?.target_db
        } : null
    });
    
    // Test fetch do JSON externo
    const testUrl = `/refs/out/${targetGenre}.json?v=diagnostic`;
    fetch(testUrl).then(r => r.json()).then(j => {
        const data = j[targetGenre];
        console.log('üåê EXTERNAL JSON TEST:', {
            url: testUrl,
            success: true,
            version: data?.version,
            num_tracks: data?.num_tracks,
            lufs_target: data?.lufs_target,
            true_peak_target: data?.true_peak_target,
            stereo_target: data?.stereo_target
        });
    }).catch(e => console.log('‚ùå EXTERNAL JSON FAILED:', testUrl, e.message));
    
    return { targetGenre, currentData, cached };
};

// =============== ETAPA 2: Robustez & Completeness Helpers ===============
// Central logging para m√©tricas ausentes / NaN (evita console spam e facilita auditoria)
function __logMetricAnomaly(kind, key, context={}) {
    try {
        if (typeof window === 'undefined') return;
        const store = (window.__METRIC_ANOMALIES__ = window.__METRIC_ANOMALIES__ || []);
        const stamp = Date.now();
        store.push({ t: stamp, kind, key, ctx: context });
        if (window.DEBUG_ANALYZER) console.warn('[METRIC_ANOMALY]', kind, key, context);
        // Limitar tamanho
        if (store.length > 500) store.splice(0, store.length - 500);
    } catch {}
}

// Placeholder seguro para valores n√£o finitos (exibe '‚Äî' e loga uma vez por chave por render)
function safeDisplayNumber(val, key, decimals=2) {
    if (!Number.isFinite(val)) { __logMetricAnomaly('non_finite', key); return '‚Äî'; }
    return val.toFixed(decimals);
}

// üÜï Fun√ß√£o para exibir estruturas complexas das novas m√©tricas
function safeDisplayComplexMetric(metric, type = 'generic') {
    if (!metric || typeof metric !== 'object') return '‚Äî';
    
    switch (type) {
        case 'frequency':
            // Para dominantFrequencies
            if (metric.value !== undefined) {
                const unit = metric.unit || 'Hz';
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(1) : '‚Äî';
                return `${value} ${unit}`;
            }
            return '‚Äî';
            
        case 'dcOffset':
            // Para dcOffset com canais L/R
            if (metric.detailed && (metric.detailed.L !== undefined || metric.detailed.R !== undefined)) {
                const L = Number.isFinite(metric.detailed.L) ? metric.detailed.L.toFixed(4) : '‚Äî';
                const R = Number.isFinite(metric.detailed.R) ? metric.detailed.R.toFixed(4) : '‚Äî';
                return `L: ${L}, R: ${R}`;
            } else if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(4) : '‚Äî';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '‚Äî';
            
        case 'spectral':
            // Para spectralUniformity
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(3) : '‚Äî';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '‚Äî';
            
        default:
            // Generic: tentar exibir value ou primeiro campo num√©rico
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(2) : '‚Äî';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '‚Äî';
    }
}

// Invalida√ß√£o ampla de caches derivados quando g√™nero mudar
function invalidateReferenceDerivedCaches() {
    try {
        if (typeof window === 'undefined') return;
        delete window.PROD_AI_REF_DATA; // for√ßa reuso atualizado
    } catch {}
}

// Enriquecimento de objeto de refer√™ncia: preencher lacunas e padronizar escala
function enrichReferenceObject(refObj, genreKey) {
    try {
        if (!refObj || typeof refObj !== 'object') return refObj;
        
        // üî• CORRE√á√ÉO CR√çTICA: Mapear hybrid_processing para propriedades root
        if (refObj.hybrid_processing && typeof refObj.hybrid_processing === 'object') {
            const hybrid = refObj.hybrid_processing;
            
            // Mapear original_metrics
            if (hybrid.original_metrics && typeof hybrid.original_metrics === 'object') {
                refObj.original_metrics = hybrid.original_metrics;
                
                // Mapear m√©tricas individuais para compatibilidade
                if (hybrid.original_metrics.lufs_integrated !== undefined) {
                    refObj.lufs_target = hybrid.original_metrics.lufs_integrated;
                }
                if (hybrid.original_metrics.true_peak_dbtp !== undefined) {
                    refObj.true_peak_target = hybrid.original_metrics.true_peak_dbtp;
                }
                if (hybrid.original_metrics.dynamic_range !== undefined) {
                    refObj.dr_target = hybrid.original_metrics.dynamic_range;
                }
                if (hybrid.original_metrics.stereo_correlation !== undefined) {
                    refObj.stereo_target = hybrid.original_metrics.stereo_correlation;
                }
                if (hybrid.original_metrics.lra !== undefined) {
                    refObj.lra_target = hybrid.original_metrics.lra;
                }
            }
            
            // Mapear spectral_bands (prioridade sobre legacy)
            if (hybrid.spectral_bands && typeof hybrid.spectral_bands === 'object') {
                refObj.spectral_bands = hybrid.spectral_bands;
                
                // üéØ CORRE√á√ÉO CR√çTICA: Normalizar chaves de snake_case ‚Üí camelCase
                if (!refObj.bands) {
                    const normalizedBands = {};
                    Object.keys(hybrid.spectral_bands).forEach(snakeKey => {
                        const camelKey = normalizeGenreBandName(snakeKey);
                        normalizedBands[camelKey] = hybrid.spectral_bands[snakeKey];
                    });
                    refObj.bands = normalizedBands;
                    console.log('[ENRICH] üéØ Bandas normalizadas:', Object.keys(normalizedBands));
                }
            }
        }
        
        // CORRE√á√ÉO CR√çTICA: Mapear legacy_compatibility para propriedades root (fallback)
        if (refObj.legacy_compatibility && typeof refObj.legacy_compatibility === 'object') {
            const legacy = refObj.legacy_compatibility;
            
            // Mapear propriedades principais (apenas se n√£o foram definidas por hybrid)
            if (legacy.lufs_target !== undefined && refObj.lufs_target === undefined) refObj.lufs_target = legacy.lufs_target;
            if (legacy.tol_lufs !== undefined) refObj.tol_lufs = legacy.tol_lufs;
            if (legacy.true_peak_target !== undefined && refObj.true_peak_target === undefined) refObj.true_peak_target = legacy.true_peak_target;
            if (legacy.tol_true_peak !== undefined) refObj.tol_true_peak = legacy.tol_true_peak;
            if (legacy.dr_target !== undefined && refObj.dr_target === undefined) refObj.dr_target = legacy.dr_target;
            if (legacy.tol_dr !== undefined) refObj.tol_dr = legacy.tol_dr;
            if (legacy.lra_target !== undefined && refObj.lra_target === undefined) refObj.lra_target = legacy.lra_target;
            if (legacy.tol_lra !== undefined) refObj.tol_lra = legacy.tol_lra;
            if (legacy.stereo_target !== undefined && refObj.stereo_target === undefined) refObj.stereo_target = legacy.stereo_target;
            if (legacy.tol_stereo !== undefined) refObj.tol_stereo = legacy.tol_stereo;
            
            // Mapear bandas de frequ√™ncia (apenas se n√£o foram definidas por hybrid)
            if (legacy.bands && typeof legacy.bands === 'object' && !refObj.bands) {
                refObj.bands = legacy.bands;
            }
        }
        
        // Feature flag geral
        const enabled = (typeof window === 'undefined') || window.ENABLE_REF_ENRICHMENT !== false;
        if (!enabled) return refObj;
        // Definir escala default se ausente
        if (!refObj.scale) refObj.scale = 'log_ratio_db';
        // Preencher stereo_target se ausente usando estat√≠sticas agregadas (Etapa 2)
        if (refObj.stereo_target == null) {
            try {
                const g = (genreKey||'').toLowerCase();
                const stat = __refDerivedStats[g];
                if (stat && Number.isFinite(stat.avgStereo) && stat.countStereo >= 2) {
                    refObj.stereo_target = stat.avgStereo;
                    refObj.__stereo_filled = 'dataset_avg';
                } else {
                    // fallback heur√≠stico
                    refObj.stereo_target = g.includes('trance') ? 0.17 : (g.includes('funk') ? 0.12 : 0.15);
                    refObj.__stereo_filled = 'heuristic';
                }
                refObj.tol_stereo = refObj.tol_stereo == null ? 0.08 : refObj.tol_stereo;
            } catch { /* noop */ }
        }
        // Garantir tol_stereo razo√°vel
        if (refObj.tol_stereo == null) refObj.tol_stereo = 0.08;
        // Bandas: marcar N/A para target_db null e permitir compara√ß√£o ignorando
        if (refObj.bands && typeof refObj.bands === 'object') {
            for (const [k,v] of Object.entries(refObj.bands)) {
                if (!v || typeof v !== 'object') continue;
                if (v.target_db == null) {
                    v._target_na = true; // flag para UI
                }
            }
        }
        // Normaliza√ß√£o opcional antecipada (apenas ajuste de metadado; c√°lculo real feito no analyzer)
        if (window && window.PRE_NORMALIZE_REF_BANDS === true && refObj.bands) {
            const vals = Object.values(refObj.bands).map(b=>b&&Number.isFinite(b.target_db)?b.target_db:null).filter(v=>v!=null);
            const negRatio = vals.filter(v=>v<0).length/Math.max(1,vals.length);
            const posRatio = vals.filter(v=>v>0).length/Math.max(1,vals.length);
            // Se maioria positiva mas queremos alinhar a negativos, apenas anotar
            if (posRatio>0.7 && negRatio<0.3) refObj.__scale_mismatch_hint = 'positive_targets_vs_negative_measurements';
        }
    } catch (e) { console.warn('[refEnrich] falha', e); }
    return refObj;
}

// Fallback embutido inline para evitar 404 em produ√ß√£o
// üéõÔ∏è ATUALIZADO: Funk Mandela 2025-08-fixed-flex (18/08/2025) - Estrutura Fixed/Flex Implementada
const __INLINE_EMBEDDED_REFS__ = {
    manifest: { genres: [
        { key: 'trance', label: 'Trance' },
        { key: 'funk_mandela', label: 'Funk Mandela' },
        { key: 'funk_bruxaria', label: 'Funk Bruxaria' },
        { key: 'funk_automotivo', label: 'Funk Automotivo' },
        { key: 'eletronico', label: 'Eletr√¥nico' },
        { key: 'eletrofunk', label: 'Eletrofunk' },
        { key: 'funk_consciente', label: 'Funk Consciente' },
        { key: 'trap', label: 'Trap' }
    ]},
    byGenre: {
        trance: { lufs_target: -14, tol_lufs: 0.5, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 9.4, tol_dr: 0.8, lra_target: 10.7, tol_lra: 2.7, stereo_target: 0.17, tol_stereo: 0.03, bands: { sub:{target_db:-17.3,tol_db:2.5}, low_bass:{target_db:-14.6,tol_db:4.3}, upper_bass:{target_db:-14.8,tol_db:2.5}, low_mid:{target_db:-12.6,tol_db:3.7}, mid:{target_db:-12,tol_db:4.0}, high_mid:{target_db:-20.2,tol_db:3.6}, brilho:{target_db:-24.7,tol_db:2.5}, presenca:{target_db:-32.1,tol_db:3.6} } },
    // Perfil atualizado Funk Mandela 2025-08-mandela-targets.4-tolerances-updated - TOLER√ÇNCIAS BIDIRECIONAIS ATUALIZADAS
    funk_mandela:   { 
        version: "2025-08-mandela-targets.4-tolerances-updated", 
        lufs_target: -8.0, tol_lufs: 2.5, tol_lufs_min: 2.5, tol_lufs_max: 2.5, 
        true_peak_target: -0.8, tol_true_peak: 1.0, true_peak_streaming_max: -1.2, true_peak_baile_max: -0.1, 
        dr_target: 8.0, tol_dr: 3.0, // Atualizado para ¬±3.0 unidades
        lra_target: 9.0, lra_min: 6.5, lra_max: 11.5, tol_lra: 2.5, 
        stereo_target: 0.60, tol_stereo: 0.25, stereo_width_target: 0.20, stereo_width_tol: 0.25, // Correla√ß√£o 0.60 ¬± 0.25
        low_end_mono_cutoff: 100, clipping_sample_pct_max: 0.02, vocal_band_min_delta: -1.5,
        fixed: {
            lufs: { integrated: { target: -8.0, tolerance: 2.5 } },
            rms: { policy: "deriveFromLUFS" },
            truePeak: { streamingMax: -1.2, baileMax: -0.1, target: -8.0 },
            dynamicRange: { crest: { target: 8.0, min: 5.0, max: 11.0 } },
            lowEnd: { mono: { cutoffHz: 100 } },
            vocalPresence: { bandHz: [1000, 4000], vocalBandMinDeltaDb: -1.5 }
        },
        flex: {
            clipping: { samplePctMax: 0.02 },
            lra: { min: 6.5, max: 11.5, target: 9.0 },
            stereo: { correlation: { min: 0.35, max: 0.85 }, width: { min: 0.075, max: 0.325 } }
        },
        pattern_rules: { 
            hard_constraints: ["lufs", "truePeak", "dynamicRange", "lowEnd", "vocalPresence"], 
            soft_constraints: ["clipping", "lra", "stereo", "tonalCurve"] 
        }, 
        bands: { 
            sub:{target_db:-7.2,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            low_bass:{target_db:-8.9,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            upper_bass:{target_db:-12.8,tol_db:2.5,severity:"soft",range_hz:"120-200"}, 
            low_mid:{target_db:-9.2,tol_db:2.0,severity:"soft",range_hz:"200-500"}, 
            mid:{target_db:-6.8,tol_db:1.5,severity:"hard",vocal_presence_range:true,range_hz:"500-2000"}, 
            high_mid:{target_db:-12.3,tol_db:1.5,severity:"soft",range_hz:"2000-4000"}, 
            brilho:{target_db:-16.2,tol_db:2.0,severity:"soft",range_hz:"4000-8000"}, 
            presenca:{target_db:-19.1,tol_db:2.5,severity:"hard",vocal_presence_range:true,range_hz:"8000-12000"} 
        } 
    },
        funk_bruxaria: { 
            version: "1.0.1",
            generated_at: "2025-08-23T18:03:37.143Z",
            num_tracks: 29,
            lufs_target: -14,
            tol_lufs: 0.5,
            true_peak_target: -1.0,
            tol_true_peak: 1.0,
            dr_target: 7.4,
            tol_dr: 1.3,
            lra_target: 8.4,
            tol_lra: 2.8,
            stereo_target: 0.3,
            tol_stereo: 0.1,
            calor_target: -11.95,
            brilho_target: -17.69,
            clareza_target: -1.21,
            bands: {
                sub: { target_db: -12.5, tol_db: 3 },
                low_bass: { target_db: -15.2, tol_db: 3 },
                upper_bass: { target_db: -15.2, tol_db: 2.3 },
                low_mid: { target_db: -12, tol_db: 1.7 },
                mid: { target_db: -8.7, tol_db: 1.7 },
                high_mid: { target_db: -14.5, tol_db: 2.8 },
                brilho: { target_db: -17.7, tol_db: 2.2 },
                presenca: { target_db: -26.7, tol_db: 2.8 }
            }
        },
        funk_automotivo:{ lufs_target: -8,  tol_lufs: 1.2, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 8.1, tol_dr: 2.0, lra_target: 6.6, tol_lra: 4.0, stereo_target: 0.3, tol_stereo: 0.15, bands: { sub:{target_db:-7.6,tol_db:6.0}, low_bass:{target_db:-6.6,tol_db:4.5}, upper_bass:{target_db:-11.4,tol_db:3.5}, low_mid:{target_db:-8.2,tol_db:3.5}, mid:{target_db:-6.7,tol_db:3.0}, high_mid:{target_db:-12.8,tol_db:4.5}, brilho:{target_db:-16.6,tol_db:4.5}, presenca:{target_db:-22.7,tol_db:5.0} } },
        eletronico:     { 
            version: "1.0.1",
            lufs_target: -14, tol_lufs: 0.5, tol_lufs_min: 0.5, tol_lufs_max: 0.5,  
            true_peak_target: -1.0, tol_true_peak: 1.0, true_peak_streaming_max: -1.0, true_peak_baile_max: 0.0,
            dr_target: 10.1, tol_dr: 1.4, 
            lra_target: 5.2, lra_min: 1.2, lra_max: 9.2, tol_lra: 4, 
            stereo_target: 0.19, tol_stereo: 0.07, stereo_width_mids_highs_tolerance: "moderate",
            low_end_mono_cutoff: 80, clipping_sample_pct_max: 0.01, vocal_band_min_delta: -2.0,
            bands: { 
                sub:{target_db:-12.5,tol_db:3}, 
                low_bass:{target_db:-10.6,tol_db:3}, 
                upper_bass:{target_db:-13.7,tol_db:3}, 
                low_mid:{target_db:-12.1,tol_db:2.7}, 
                mid:{target_db:-11.8,tol_db:2.4}, 
                high_mid:{target_db:-19.1,tol_db:2.3}, 
                brilho:{target_db:-19.1,tol_db:2}, 
                presenca:{target_db:-24,tol_db:3} 
            } 
        },
        eletrofunk:     { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.12, tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        funk_consciente:{ lufs_target: -12, tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 10, tol_dr: 2, lra_target: 7, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        trap:           { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-16,tol_db:5.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } }
    }
};

// Construir estat√≠sticas agregadas (m√©dia stereo por g√™nero) a partir de refs carregadas
function buildAggregatedRefStats() {
    try {
        const map = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre;
        if (!map) return;
        for (const [g, data] of Object.entries(map)) {
            if (!data || typeof data !== 'object') continue;
            // stereo_target j√° definido conta; se null ignorar
            if (Number.isFinite(data.stereo_target)) {
                const st = (__refDerivedStats[g] = __refDerivedStats[g] || { sumStereo:0, countStereo:0 });
                st.sumStereo += data.stereo_target; st.countStereo += 1;
            }
        }
        for (const [g, st] of Object.entries(__refDerivedStats)) {
            if (st.countStereo > 0) st.avgStereo = st.sumStereo / st.countStereo;
        }
    } catch (e) { if (window.DEBUG_ANALYZER) console.warn('buildAggregatedRefStats fail', e); }
}

// Carregar dinamicamente o fallback embutido se necess√°rio
async function ensureEmbeddedRefsReady(timeoutMs = 2500) {
    try {
        if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
        // Se n√£o for explicitamente permitido, n√£o tentar carregar pela rede para evitar 404
        if (!(typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true)) return false;
        // Injetar script apenas uma vez
        if (typeof document !== 'undefined' && !document.getElementById('embeddedRefsScript')) {
            const s = document.createElement('script');
            s.id = 'embeddedRefsScript';
            s.src = '/refs/embedded-refs.js?v=' + Date.now();
            s.async = true;
            document.head.appendChild(s);
        }
        // Esperar at√© ficar dispon√≠vel ou timeout
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
            await new Promise(r => setTimeout(r, 100));
        }
        return (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) ? true : false;
    } catch { return false; }
}

// Helper: buscar JSON tentando m√∫ltiplos caminhos (resiliente a diferen√ßas local x produ√ß√£o)
async function fetchRefJsonWithFallback(paths) {
    let lastErr = null;
    for (const p of paths) {
        if (!p) continue;
        try {
            // üéØ CORRE√á√ÉO: Usar window.location.origin para garantir caminho absoluto no deploy
            const baseUrl = (typeof window !== 'undefined' && window.location) 
                ? window.location.origin 
                : '';
            
            // Se o path j√° √© absoluto (come√ßa com http), n√£o adicionar origin
            const fullUrl = p.startsWith('http') ? p : `${baseUrl}${p.startsWith('/') ? '' : '/'}${p}`;
            
            // Cache-busting para evitar CDN retornar 404 ou vers√µes antigas
            const hasQ = fullUrl.includes('?');
            const url = fullUrl + (hasQ ? '&' : '?') + 'v=' + Date.now();
            
            if (__DEBUG_ANALYZER__) console.log('[refs] tentando fetch:', url);
            
            const res = await fetch(url, {
                cache: 'no-store',
                headers: { 
                    'Cache-Control': 'no-cache', 
                    'Pragma': 'no-cache',
                    'Accept': 'application/json'
                }
            });
            
            if (res.ok) {
                // üéØ VALIDA√á√ÉO CR√çTICA: Verificar Content-Type
                const contentType = res.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    console.warn('[refs] ‚ö†Ô∏è Content-Type incorreto:', contentType, 'em', p);
                    console.warn('[refs] Esperado: application/json, recebido HTML provavelmente');
                    throw new Error(`Content-Type inv√°lido: ${contentType} (esperado JSON)`);
                }
                
                if (__DEBUG_ANALYZER__) console.log('[refs] OK:', p);
                
                // Verificar se a resposta tem conte√∫do JSON v√°lido
                const text = await res.text();
                
                // üéØ VALIDA√á√ÉO CR√çTICA: Detectar HTML no lugar de JSON
                if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                    console.error('[refs] ‚ùå ERRO: Servidor retornou HTML ao inv√©s de JSON em', p);
                    console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                    throw new Error(`HTML retornado ao inv√©s de JSON em ${p}`);
                }
                
                if (text.trim()) {
                    try {
                        const json = JSON.parse(text);
                        console.log('[refs] ‚úÖ JSON v√°lido carregado de:', p);
                        return json;
                    } catch (jsonError) {
                        console.error('[refs] ‚ùå JSON inv√°lido em', p);
                        console.error('[refs] Erro:', jsonError.message);
                        console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                        throw new Error(`JSON inv√°lido em ${p}: ${jsonError.message}`);
                    }
                } else {
                    console.warn('[refs] Resposta vazia em', p);
                    throw new Error(`Resposta vazia em ${p}`);
                }
            } else {
                if (__DEBUG_ANALYZER__) console.warn('[refs] Falha', res.status, 'em', p);
                lastErr = new Error(`HTTP ${res.status} @ ${p}`);
            }
        } catch (e) {
            if (__DEBUG_ANALYZER__) console.warn('[refs] Erro fetch', p, e?.message || e);
            lastErr = e;
        }
    }
    throw lastErr || new Error('Falha ao carregar JSON de refer√™ncia (todas as rotas testadas)');
}

// üìö Carregar manifesto de g√™neros (opcional). Se ausente, manter fallback.
async function loadGenreManifest() {
    // 1) Preferir embutido em window, depois inline
    try {
        const winEmb = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.manifest) || null;
        if (winEmb && Array.isArray(winEmb.genres)) { __genreManifest = winEmb.genres; return __genreManifest; }
    } catch {}
    if (!__genreManifest && __INLINE_EMBEDDED_REFS__?.manifest?.genres?.length) {
        __genreManifest = __INLINE_EMBEDDED_REFS__.manifest.genres;
        return __genreManifest;
    }
    // 2) Se permitido, tentar rede
    if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
        try {
            const json = await fetchRefJsonWithFallback([
                `/refs/out/genres.json`,
                `refs/out/genres.json`,
                `./refs/out/genres.json`,
                `../refs/out/genres.json`
            ]);
            if (json && Array.isArray(json.genres)) { __genreManifest = json.genres; return __genreManifest; }
        } catch (e) { __dwrn('Manifesto via rede indispon√≠vel:', e.message || e); }
    }
    return __genreManifest || null;
}

// üè∑Ô∏è Popular o <select> com base no manifesto, mantendo fallback e preservando sele√ß√£o
function populateGenreSelect(manifestGenres) {
    const sel = document.getElementById('audioRefGenreSelect');
    if (!sel) return;
    if (!Array.isArray(manifestGenres) || manifestGenres.length === 0) {
        // Nada a fazer (fallback j√° em HTML)
        // Ainda assim, garantir que o g√™nero ativo esteja presente como op√ß√£o
        ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
        return;
    }
    // Salvar valor atual (se houver)
    const current = sel.value;
    // Limpar op√ß√µes atuais e reconstruir
    while (sel.options.length) sel.remove(0);
    for (const g of manifestGenres) {
        if (!g || !g.key) continue;
        const opt = document.createElement('option');
        opt.value = String(g.key);
        opt.textContent = String(g.label || labelizeKey(g.key));
        sel.appendChild(opt);
    }
    // Garantir que g√™nero ativo via URL/localStorage esteja presente
    ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
    // Restaurar sele√ß√£o (priorizar PROD_AI_REF_GENRE > current > primeira op√ß√£o)
    const target = window.PROD_AI_REF_GENRE || current || (sel.options[0] && sel.options[0].value);
    if (target) sel.value = target;
}

// üî§ Converter chave em r√≥tulo amig√°vel (ex.: "funk_mandela" ‚Üí "Funk Mandela")
function labelizeKey(key) {
    if (!key) return '';
    return String(key)
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\b\w/g, c => c.toUpperCase());
}

// ‚úÖ Garantir que a op√ß√£o do g√™nero ativo exista no select (para casos via URL)
function ensureActiveGenreOption(selectEl, genreKey) {
    if (!selectEl || !genreKey) return;
    const exists = Array.from(selectEl.options).some(o => o.value === genreKey);
    if (!exists) {
        const opt = document.createElement('option');
        opt.value = String(genreKey);
        opt.textContent = labelizeKey(genreKey);
        selectEl.appendChild(opt);
    }
}

/**
 * üéØ NOVA FUN√á√ÉO: Extrair targets de g√™nero do JSON
 * Formato esperado do JSON:
 * {
 *   "nome_genero": {
 *     "version": "...",
 *     "hybrid_processing": {
 *       "original_metrics": {...},
 *       "spectral_bands": {...}  ‚Üê PRIORIDADE 1
 *     },
 *     "legacy_compatibility": {
 *       "bands": {...}  ‚Üê PRIORIDADE 2
 *     },
 *     "bands": {...}  ‚Üê PRIORIDADE 3 (fallback)
 *   }
 * }
 */
function extractGenreTargets(json, genreName) {
    console.log('[EXTRACT-TARGETS] üîç Extraindo targets para:', genreName);
    console.log('[EXTRACT-TARGETS] üì¶ JSON recebido:', json);
    
    // 1. Identificar o root real do g√™nero
    let root = null;
    
    // Tentar: json[genreName]
    if (json && typeof json === 'object' && json[genreName]) {
        root = json[genreName];
        console.log('[EXTRACT-TARGETS] ‚úÖ Root encontrado em json[genreName]');
    }
    // Tentar: json j√° √© o root (quando vem de cache ou embedded)
    else if (json && typeof json === 'object' && json.version) {
        root = json;
        console.log('[EXTRACT-TARGETS] ‚úÖ JSON j√° √© o root (tem version)');
    }
    // Tentar: primeiro objeto no JSON
    else if (json && typeof json === 'object') {
        const firstKey = Object.keys(json)[0];
        if (firstKey && json[firstKey] && typeof json[firstKey] === 'object') {
            root = json[firstKey];
            console.log('[EXTRACT-TARGETS] ‚úÖ Root encontrado na primeira chave:', firstKey);
        }
    }
    
    if (!root) {
        console.error('[EXTRACT-TARGETS] ‚ùå Root n√£o encontrado no JSON');
        return null;
    }
    
    console.log('[EXTRACT-TARGETS] üìä Root identificado:', {
        version: root.version,
        hasHybridProcessing: !!root.hybrid_processing,
        hasLegacyCompatibility: !!root.legacy_compatibility,
        hasBands: !!root.bands
    });
    
    // 2. Buscar targets na ordem de prioridade
    let targets = null;
    let source = null;
    
    // üéØ PRIORIDADE 1: legacy_compatibility.bands (FONTE OFICIAL)
    if (root.legacy_compatibility?.bands) {
        targets = root.legacy_compatibility.bands;
        source = 'legacy_compatibility.bands';
        console.log('[EXTRACT-TARGETS] ‚úÖ Targets encontrados em legacy_compatibility.bands (OFICIAL)');
    }
    // üéØ PRIORIDADE 2: hybrid_processing.spectral_bands (fallback)
    else if (root.hybrid_processing?.spectral_bands) {
        targets = root.hybrid_processing.spectral_bands;
        source = 'hybrid_processing.spectral_bands';
        console.log('[EXTRACT-TARGETS] ‚ö†Ô∏è Targets encontrados em hybrid_processing.spectral_bands (fallback)');
    }
    // üéØ PRIORIDADE 3: bands (fallback gen√©rico)
    else if (root.bands) {
        targets = root.bands;
        source = 'bands';
        console.log('[EXTRACT-TARGETS] ‚ö†Ô∏è Targets encontrados em bands (fallback gen√©rico)');
    }
    // üéØ PRIORIDADE 4: hybrid_processing.original_metrics (√∫ltimo recurso)
    else if (root.hybrid_processing?.original_metrics) {
        targets = root.hybrid_processing.original_metrics;
        source = 'hybrid_processing.original_metrics';
        console.log('[EXTRACT-TARGETS] ‚ö†Ô∏è Usando original_metrics como √∫ltimo recurso');
    }
    
    if (!targets) {
        console.error('[EXTRACT-TARGETS] ‚ùå Nenhum target encontrado no JSON');
        console.error('[EXTRACT-TARGETS] üì¶ Root completo:', root);
        return null;
    }
    
    // 3. Criar objeto de resultado completo
    const result = {
        ...root,
        targets: targets,
        targetSource: source
    };
    
    console.log('[EXTRACT-TARGETS] ‚úÖ Extra√ß√£o completa:', {
        genre: genreName,
        source: source,
        version: root.version,
        targetKeys: Object.keys(targets),
        lufs_target: root.lufs_target,
        true_peak_target: root.true_peak_target,
        dr_target: root.dr_target,
        stereo_target: root.stereo_target
    });
    
    return result;
}

async function loadReferenceData(genre) {
    try {
        // Se feature flag de invalidar cache por troca de escala/g√™nero estiver ativa, ignorar cache salvo
        const bypassCache = (typeof window !== 'undefined' && window.REFS_BYPASS_CACHE === true);
        if (!bypassCache && __refDataCache[genre]) {
            __activeRefData = __refDataCache[genre];
            __activeRefGenre = genre;
            
            // ‚úÖ Log detalhado dos targets carregados do cache
            console.log('[LOAD-REF] üì¶ Carregado do cache:', {
                genre: genre,
                hasTargets: !!__activeRefData?.targets,
                targetKeys: __activeRefData?.targets ? Object.keys(__activeRefData.targets) : [],
                targetSource: __activeRefData?.targetSource
            });
            
            updateRefStatus('‚úî refer√™ncias (cache)', '#0d6efd');
            return __activeRefData;
        }
        if (bypassCache) {
            delete __refDataCache[genre];
        }
        updateRefStatus('‚è≥ carregando...', '#996600');
        
        console.log('üîç DEBUG loadReferenceData in√≠cio:', { genre, bypassCache });
        
        // PRIORIDADE CORRIGIDA: external > embedded > fallback
        // 1) Tentar carregar JSON externo primeiro (sempre, independente de REFS_ALLOW_NETWORK)
        console.log('üåê Tentando carregar JSON externo primeiro...');
        try {
            const version = Date.now(); // Force cache bust
            const json = await fetchRefJsonWithFallback([
                `/refs/out/${genre}.json?v=${version}`,
                `refs/out/${genre}.json?v=${version}`,
                `./refs/out/${genre}.json?v=${version}`,
                `../refs/out/${genre}.json?v=${version}`
            ]);
            
            // ‚úÖ NOVA L√ìGICA: Usar extractGenreTargets para processar JSON
            const extractedData = extractGenreTargets(json, genre);
            
            if (extractedData && typeof extractedData === 'object' && extractedData.version) {
                const enrichedNet = enrichReferenceObject(extractedData, genre);
                __refDataCache[genre] = enrichedNet;
                __activeRefData = enrichedNet;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedNet;
                window.__activeRefData = enrichedNet; // ‚úÖ Garantir disponibilidade global
                
                // ‚úÖ Log detalhado mostrando targets reais
                console.log('üéØ REFS DIAGNOSTIC (EXTERNAL):', {
                    genre,
                    source: 'external',
                    path: `/refs/out/${genre}.json`,
                    version: extractedData.version,
                    num_tracks: extractedData.num_tracks,
                    lufs_target: extractedData.lufs_target,
                    true_peak_target: extractedData.true_peak_target,
                    stereo_target: extractedData.stereo_target,
                    targetSource: extractedData.targetSource,
                    targetKeys: extractedData.targets ? Object.keys(extractedData.targets) : [],
                    firstTarget: extractedData.targets ? Object.values(extractedData.targets)[0] : null
                });
                
                console.log('‚úÖ [GENRE_MODAL] Targets de g√™nero carregados:', {
                    genre: genre,
                    hasTargets: !!extractedData.targets,
                    targetCount: extractedData.targets ? Object.keys(extractedData.targets).length : 0,
                    targetSample: extractedData.targets ? Object.keys(extractedData.targets).slice(0, 3) : []
                });
                
                updateRefStatus('‚úî refer√™ncias aplicadas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedNet;
            }
        } catch (netError) {
            console.log('‚ùå External refs failed:', netError.message);
            console.log('üîÑ Fallback para embedded refs...');
            
            // üî• CORRE√á√ÉO LOOP INFINITO: For√ßar refsReady se refs internas j√° carregaram
            if (!window.refsReady && window.embeddedRefsLoaded) {
                window.refsReady = true;
                console.log("‚ö†Ô∏è [refs] refsReady for√ßado como true ap√≥s fallback com erro de fetch externo");
            }
        }
        
        // 2) Fallback para refer√™ncias embutidas (embedded)
        const embWin = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre && window.__EMBEDDED_REFS__.byGenre[genre]) || null;
        const embInline = __INLINE_EMBEDDED_REFS__?.byGenre?.[genre] || null;
        const useData = embWin || embInline;
        if (useData && typeof useData === 'object') {
            // ‚úÖ NOVA L√ìGICA: Extrair targets corretamente
            const extractedData = extractGenreTargets(useData, genre);
            
            if (extractedData) {
                const enriched = enrichReferenceObject(structuredClone(extractedData), genre);
                __refDataCache[genre] = enriched;
                __activeRefData = enriched;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enriched;
                window.__activeRefData = enriched; // ‚úÖ Garantir disponibilidade global
                
                // ‚úÖ Log detalhado mostrando targets reais
                console.log('üéØ REFS DIAGNOSTIC (EMBEDDED):', {
                    genre,
                    source: 'embedded',
                    path: embWin ? 'window.__EMBEDDED_REFS__' : '__INLINE_EMBEDDED_REFS__',
                    version: extractedData.version || 'embedded',
                    num_tracks: extractedData.num_tracks || 'unknown',
                    lufs_target: extractedData.lufs_target,
                    true_peak_target: extractedData.true_peak_target,
                    stereo_target: extractedData.stereo_target,
                    targetSource: extractedData.targetSource,
                    targetKeys: extractedData.targets ? Object.keys(extractedData.targets) : [],
                    firstTarget: extractedData.targets ? Object.values(extractedData.targets)[0] : null
                });
                
                console.log('‚úÖ [GENRE_MODAL] Targets de g√™nero carregados:', {
                    genre: genre,
                    hasTargets: !!extractedData.targets,
                    targetCount: extractedData.targets ? Object.keys(extractedData.targets).length : 0,
                    targetSample: extractedData.targets ? Object.keys(extractedData.targets).slice(0, 3) : []
                });
                
                updateRefStatus('‚úî refer√™ncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enriched;
            }
        }
        
        // 3) Se ainda nada funcionou e REFS_ALLOW_NETWORK est√° ativo (legacy path)
        if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
            console.log('‚ö†Ô∏è Using legacy REFS_ALLOW_NETWORK path - should not happen with new logic');
        }
        
        // 4) √öltimo recurso: trance inline (fallback)
        const fallback = __INLINE_EMBEDDED_REFS__?.byGenre?.trance;
        if (fallback) {
            const enrichedFb = enrichReferenceObject(structuredClone(fallback), 'trance');
            __refDataCache['trance'] = enrichedFb;
            __activeRefData = enrichedFb;
            __activeRefGenre = 'trance';
            window.PROD_AI_REF_DATA = enrichedFb;
            
            // Log de diagn√≥stico
            console.log('üéØ REFS DIAGNOSTIC:', {
                genre,
                source: 'fallback',
                path: '__INLINE_EMBEDDED_REFS__.trance',
                version: 'fallback',
                num_tracks: fallback.num_tracks || 'unknown',
                lufs_target: fallback.lufs_target,
                true_peak_target: fallback.true_peak_target,
                stereo_target: fallback.stereo_target
            });
            
            updateRefStatus('‚úî refer√™ncias embutidas (fallback)', '#0d6efd');
            try { buildAggregatedRefStats(); } catch {}
            return enrichedFb;
        }
        throw new Error('Sem refer√™ncias dispon√≠veis');
    } catch (e) {
        console.warn('Falha ao carregar refer√™ncias', genre, e);
        // Fallback: tentar EMBEDDED
        try {
            const embMap = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre || {};
            const emb = embMap[genre];
            if (emb && typeof emb === 'object') {
                const enrichedEmb = enrichReferenceObject(structuredClone(emb), genre);
                __refDataCache[genre] = enrichedEmb;
                __activeRefData = enrichedEmb;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedEmb;
                updateRefStatus('‚úî refer√™ncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmb;
            }
            // Se o g√™nero espec√≠fico n√£o existir, usar um padr√£o seguro (trance) se dispon√≠vel
            if (embMap && embMap.trance) {
                const enrichedEmbTr = enrichReferenceObject(structuredClone(embMap.trance), 'trance');
                __refDataCache['trance'] = enrichedEmbTr;
                __activeRefData = enrichedEmbTr;
                __activeRefGenre = 'trance';
                window.PROD_AI_REF_DATA = enrichedEmbTr;
                updateRefStatus('‚úî refer√™ncias embutidas (fallback)', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmbTr;
            }
        } catch(_) {}
        updateRefStatus('‚ö† falha refs', '#992222');
        return null;
    }
}

function updateRefStatus(text, color) {
    const el = document.getElementById('audioRefStatus');
    if (el) { el.textContent = text; el.style.background = color || '#1f2b40'; }
}

/**
 * üîí FUN√á√ÉO DE PRESERVA√á√ÉO DE G√äNERO
 * Garante que o g√™nero selecionado NUNCA seja perdido em resets
 */
function preserveGenreState(sourceAnalysis = null) {
    console.log('[PRESERVE-GENRE] üîí Preservando estado do g√™nero');
    
    // üéØ CORRE√á√ÉO CR√çTICA: Se foi passada uma an√°lise, extrair targets dela primeiro
    if (sourceAnalysis) {
        console.log('[PRESERVE-GENRE] üéØ An√°lise fornecida - extraindo genre e targets (FONTE OFICIAL)');
        
        const extractedGenre = extractGenreFromAnalysis(sourceAnalysis);
        const extractedTargets = extractGenreTargetsFromAnalysis(sourceAnalysis);
        
        if (extractedGenre) {
            window.__CURRENT_SELECTED_GENRE = extractedGenre;
            window.PROD_AI_REF_GENRE = extractedGenre;
            console.log('[PRESERVE-GENRE] ‚úÖ G√™nero extra√≠do de analysis.data.genre:', extractedGenre);
        }
        
        if (extractedTargets) {
            window.__CURRENT_GENRE_TARGETS = extractedTargets;
            window.currentGenreTargets = extractedTargets;
            console.log('[PRESERVE-GENRE] ‚úÖ Targets extra√≠dos de analysis.data.genreTargets:', Object.keys(extractedTargets));
        }
        
        // Se conseguiu extrair ambos, retornar
        if (extractedGenre && extractedTargets) {
            return;
        }
    }
    
    // Se __CURRENT_SELECTED_GENRE j√° existe, n√£o precisa restaurar
    if (window.__CURRENT_SELECTED_GENRE) {
        console.log('[PRESERVE-GENRE] ‚úÖ __CURRENT_SELECTED_GENRE j√° existe:', window.__CURRENT_SELECTED_GENRE);
        return;
    }

    // Se o CURRENT n√£o existir, restaurar do refGenre
    if (window.PROD_AI_REF_GENRE) {
        window.__CURRENT_SELECTED_GENRE = window.PROD_AI_REF_GENRE;
        console.log('[PRESERVE-GENRE] ‚úÖ __CURRENT_SELECTED_GENRE restaurado de PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
    }

    // Reatribuir targets
    if (window.__CURRENT_GENRE_TARGETS) {
        window.currentGenreTargets = window.__CURRENT_GENRE_TARGETS;
        console.log('[PRESERVE-GENRE] ‚úÖ currentGenreTargets restaurado de __CURRENT_GENRE_TARGETS');
    }
}

function applyGenreSelection(genre) {
    if (!genre) return Promise.resolve();
    window.PROD_AI_REF_GENRE = genre;
    localStorage.setItem('prodai_ref_genre', genre);
    // Invalida√ß√£o de cache opcional
    if (typeof window !== 'undefined' && window.INVALIDATE_REF_CACHE_ON_GENRE_CHANGE === true) {
        try { delete __refDataCache[genre]; } catch {}
        invalidateReferenceDerivedCaches();
    }
    
    // üéØ FOR√áAR invalida√ß√£o para garantir nova refer√™ncia
    try { 
        delete __refDataCache[genre]; 
        invalidateReferenceDerivedCaches();
        console.log('‚úÖ Cache invalidado para g√™nero:', genre);
    } catch(e) { console.warn('‚ö†Ô∏è Falha na invalida√ß√£o:', e); }
    
    // Carregar refs e, se j√° houver an√°lise no modal, atualizar sugest√µes de refer√™ncia e re-renderizar
    return loadReferenceData(genre).then(() => {
        // üîí PATCH: Salvar g√™nero e targets em TODAS as vari√°veis globais
        window.__CURRENT_SELECTED_GENRE = genre;
        window.PROD_AI_REF_GENRE = genre;
        
        // Extrair targets do __activeRefData carregado
        if (window.__activeRefData?.targets) {
            window.__CURRENT_GENRE_TARGETS = window.__activeRefData.targets;
            window.currentGenreTargets = window.__activeRefData.targets;
            console.log('[APPLY-GENRE] ‚úÖ G√™nero e targets salvos:', {
                genre: genre,
                hasTargets: true,
                targetKeys: Object.keys(window.__activeRefData.targets)
            });
        } else {
            console.warn('[APPLY-GENRE] ‚ö†Ô∏è Targets n√£o encontrados em __activeRefData');
        }
        
        try {
            if (typeof currentModalAnalysis === 'object' && currentModalAnalysis) {
                // üéØ NOVO: Recalcular score com nova refer√™ncia
                try {
                    if (typeof window !== 'undefined' && window.computeMixScore && __refData) {
                        currentModalAnalysis.qualityOverall = window.computeMixScore(currentModalAnalysis.technicalData, __refData);
                        console.log('‚úÖ Score recalculado para novo g√™nero:', currentModalAnalysis.qualityOverall);
                    }
                } catch(e) { console.warn('‚ùå Falha ao recalcular score:', e); }
                
                // Recalcular sugest√µes reference_* com as novas toler√¢ncias
                try { updateReferenceSuggestions(currentModalAnalysis); } catch(e) { console.warn('updateReferenceSuggestions falhou', e); }
                // Re-renderiza√ß√£o completa para refletir sugest√µes e compara√ß√µes
                try { 
                    // üîí UI GATE: Verificar se an√°lise ainda √© v√°lida
                    const analysisRunId = currentModalAnalysis?.runId || currentModalAnalysis?.metadata?.runId;
                    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
                    
                    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                        console.warn(`üö´ [UI_GATE] Re-render cancelado - an√°lise obsoleta (an√°lise: ${analysisRunId}, atual: ${currentRunId})`);
                        return;
                    }
                    
                    displayModalResults(currentModalAnalysis); 
                } catch(e) { console.warn('re-render modal falhou', e); }
            }
        } catch (e) { console.warn('re-render compara√ß√£o falhou', e); }
    });
}
// Expor global
if (typeof window !== 'undefined') {
    window.applyGenreSelection = applyGenreSelection;
}

// Health check utilit√°rio (Etapa 2) ‚Äì avalia estabilidade das m√©tricas em m√∫ltiplos runs
if (typeof window !== 'undefined' && !window.__audioHealthCheck) {
    window.__audioHealthCheck = async function(file, opts = {}) {
        const runs = opts.runs || 3;
        const delayMs = opts.delayMs || 0;
        const out = { runs: [], spreads: {}, anomalies: [] };
        for (let i=0;i<runs;i++) {
            const t0 = performance.now();
            // üÜî CORRE√á√ÉO: Adicionar runId para fun√ß√µes de health check
            const healthOptions = prepareAnalysisOptions({}, `health_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, healthOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufsIntegrated: res?.technicalData?.lufsIntegrated,
                truePeakDbtp: res?.technicalData?.truePeakDbtp,
                dynamicRange: res?.technicalData?.dynamicRange,
                lra: res?.technicalData?.lra,
                stereoCorrelation: res?.technicalData?.stereoCorrelation,
                processingMs: (res?.processingMs ?? (t1 - t0))
            });
            if (delayMs) await new Promise(r=>setTimeout(r, delayMs));
        }
        const collect = (key) => out.runs.map(r=>r[key]).filter(v=>Number.isFinite(v));
        const stats = (arr) => arr.length?{min:Math.min(...arr),max:Math.max(...arr),spread:Math.max(...arr)-Math.min(...arr)}:null;
        ['lufsIntegrated','truePeakDbtp','dynamicRange','lra','stereoCorrelation','processingMs'].forEach(k=>{
            out.spreads[k] = stats(collect(k));
        });
        // Anomalias agrupadas (do logger central)
        try { out.anomalies = (window.__METRIC_ANOMALIES__||[]).slice(-100); } catch {}
        return out;
    };
}

// ================== ACCEPTANCE TEST HARNESS (Etapa 3) ==================
// ‚ö†Ô∏è REMOVIDO: Testes que dependem de Web Audio API
// TODO: Implementar testes baseados em an√°lise remota se necess√°rio

if (typeof window !== 'undefined' && !window.__runAcceptanceAudioTests) {
    window.__runAcceptanceAudioTests = async function(opts = {}) {
        console.warn('‚ö†Ô∏è Testes de aceita√ß√£o de √°udio foram removidos devido √† migra√ß√£o para an√°lise remota');
        return { 
            skipped: true, 
            reason: 'Web Audio API removida - usar testes de backend' 
        };
    };
}

// Inicializar quando DOM carregar
document.addEventListener('DOMContentLoaded', function() {
    initializeAudioAnalyzerIntegration();
});


function initializeAudioAnalyzerIntegration() {
    if (__audioIntegrationInitialized) {
        __dbg('‚ÑπÔ∏è Integra√ß√£o do Audio Analyzer j√° inicializada. Ignorando chamada duplicada.');
        return;
    }
    __audioIntegrationInitialized = true;
    __dbg('üéµ Inicializando integra√ß√£o do Audio Analyzer...');
    // Habilitar flag de refer√™ncia por g√™nero via par√¢metro de URL (ex.: ?refgenre=trance)
    try {
        if (typeof window !== 'undefined') {
            const params = new URLSearchParams(window.location.search);
            const rg = params.get('refgenre');
            if (rg && !window.PROD_AI_REF_GENRE) {
                window.PROD_AI_REF_GENRE = String(rg).trim().toLowerCase();
                __dbg(`[REF-G√äNERO] Ativado via URL: ${window.PROD_AI_REF_GENRE}`);
            }
            // Flags de controle por URL (n√£o alteram CSS)
            if (params.has('surgical')) {
                const v = params.get('surgical');
                window.USE_SURGICAL_EQ = !(v === '0' || v === 'false');
                __dbg(`[FLAG] USE_SURGICAL_EQ = ${window.USE_SURGICAL_EQ}`);
            }
            if (params.has('useLog')) {
                const v = params.get('useLog');
                window.USE_LOG_BAND_ENERGIES = (v === '1' || v === 'true');
                __dbg(`[FLAG] USE_LOG_BAND_ENERGIES = ${window.USE_LOG_BAND_ENERGIES}`);
            }
            if (params.has('adv')) {
                const v = params.get('adv');
                const on = !(v === '0' || v === 'false');
                window.USE_ADVANCED_METRICS = on;
                window.USE_ADVANCED_LOUDNESS = on;
                window.USE_ADVANCED_TRUEPEAK = on;
                window.USE_ADVANCED_SPECTRUM = on;
                __dbg(`[FLAG] ADVANCED = ${on}`);
            }
            if (params.has('debug')) {
                const v = params.get('debug');
                window.DEBUG_ANALYZER = (v === '1' || v === 'true');
                __dbg(`[FLAG] DEBUG_ANALYZER = ${window.DEBUG_ANALYZER}`);
            }
            // Preferir m√©tricas avan√ßadas (ITU/oversampling) quando dispon√≠veis, sem sobrescrever configs do usu√°rio
            if (typeof window.PREFER_ADVANCED_METRICS === 'undefined') {
                window.PREFER_ADVANCED_METRICS = true;
                __dbg('[FLAG] PREFER_ADVANCED_METRICS = true (auto)');
            }
        }
    } catch (_) { /* noop */ }
    
    // Restaurar g√™nero salvo
    try {
        const saved = localStorage.getItem('prodai_ref_genre');
        if (!window.PROD_AI_REF_GENRE && saved) window.PROD_AI_REF_GENRE = saved;
    } catch {}

    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (genreSelect) {
        // Popular dinamicamente a partir do manifesto, mantendo fallback
        loadGenreManifest().then(() => {
            populateGenreSelect(__genreManifest);
            // Listener de mudan√ßa (garantir apenas um)
            genreSelect.onchange = () => applyGenreSelection(genreSelect.value);
            // Aplicar sele√ß√£o atual
            const selected = genreSelect.value || window.PROD_AI_REF_GENRE;
            applyGenreSelection(selected);
        });
    }

    // Bot√£o de an√°lise de m√∫sica (novo design)
    const musicAnalysisBtn = document.getElementById('musicAnalysisBtn');
    if (musicAnalysisBtn) {
        musicAnalysisBtn.addEventListener('click', openAudioModal);
        __dbg('‚úÖ Bot√£o de An√°lise de M√∫sica configurado');
    }
    
    // Modal de √°udio
    setupAudioModal();
    
    __dbg('üéµ Audio Analyzer Integration carregada com sucesso!');
    
    // üß† Aguarda refs e cache ficarem prontos antes de liberar o ForceActivator
    function waitForRefsAndCacheBeforeReady() {
        const checkReady = () => {
            const ready = !!(window.audioAnalyzer && window.CACHE_CTX_AWARE_V1_API && window.refsReady);
            console.log("‚è≥ [READY-CHECK] Estado atual:", {
                audioAnalyzer: !!window.audioAnalyzer,
                CACHE_CTX_AWARE_V1_API: !!window.CACHE_CTX_AWARE_V1_API,
                refsReady: !!window.refsReady
            });
            if (ready) {
                console.log("‚úÖ [GLOBAL] Todos os sistemas prontos. Disparando analysisReady...");
                const evt = new Event("analysisReady");
                document.dispatchEvent(evt);
                return true;
            }
            return false;
        };

        if (!checkReady()) {
            const interval = setInterval(() => {
                if (checkReady()) clearInterval(interval);
            }, 300);
        }
    }

    // üî• Chamar a fun√ß√£o de espera no ponto onde estava o dispatch antigo:
    waitForRefsAndCacheBeforeReady();

    // Aplicar estilos aprimorados ao seletor de g√™nero
    try { injectRefGenreStyles(); } catch(e) { /* silencioso */ }
    
    // üÜï Inicializar Modal de G√™nero Musical
    try { initGenreModal(); } catch(e) { console.warn('Falha ao inicializar modal de g√™nero:', e); }
}

// ============================================================================
// ÔøΩ MODAL DE BOAS-VINDAS √Ä AN√ÅLISE - NOVO SISTEMA
// ============================================================================

/**
 * üåü Abrir modal de boas-vindas
 * Modal inicial que apresenta o sistema e direciona para o guia t√©cnico
 */
function openWelcomeModal() {
    __dbg('üéâ Abrindo modal de boas-vindas √† an√°lise...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) {
        console.error('‚ùå Modal de boas-vindas n√£o encontrado no DOM');
        return;
    }
    
    // Abrir modal com anima√ß√£o
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    
    // Foco no modal para acessibilidade
    requestAnimationFrame(() => {
        modal.focus();
        
        // Foco no primeiro bot√£o
        const firstBtn = modal.querySelector('.welcome-btn.primary');
        if (firstBtn) {
            firstBtn.focus();
        }
    });
    
    __dbg('‚úÖ Modal de boas-vindas aberto com sucesso');
}

/**
 * ‚ùå Fechar modal de boas-vindas
 */
function closeWelcomeModal() {
    __dbg('‚ùå Fechando modal de boas-vindas...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    __dbg('‚úÖ Modal de boas-vindas fechado');
}

/**
 * üìñ Abrir guia t√©cnico em nova aba
 */
function openTechnicalGuide() {
    __dbg('üìñ Abrindo guia t√©cnico de an√°lise...');
    
    // Abrir guia na mesma pasta (public/)
    window.open('guia-tecnico-analise.html', '_blank', 'noopener,noreferrer');
    
    // N√£o fecha o modal - usu√°rio pode ler o guia e voltar
    __dbg('‚úÖ Guia t√©cnico aberto em nova aba');
}

/**
 * ‚ñ∂Ô∏è Prosseguir para an√°lise (fechar modal de boas-vindas e continuar fluxo)
 */
function proceedToAnalysis() {
    __dbg('‚ñ∂Ô∏è Prosseguindo para an√°lise...');
    
    // Fechar modal de boas-vindas
    closeWelcomeModal();
    
    // Continuar com o fluxo original
    const isReferenceEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
    
    if (isReferenceEnabled) {
        // Abrir modal de sele√ß√£o de modo
        openModeSelectionModal();
    } else {
        // Ir direto para modo g√™nero
        selectAnalysisMode('genre');
    }
    
    __dbg('‚úÖ Fluxo de an√°lise continuado');
}

// Expor fun√ß√µes globalmente para uso nos onclick do HTML
window.openWelcomeModal = openWelcomeModal;
window.closeWelcomeModal = closeWelcomeModal;
window.openTechnicalGuide = openTechnicalGuide;
window.proceedToAnalysis = proceedToAnalysis;

/**
 * ‚å®Ô∏è Configurar acessibilidade do modal de boas-vindas
 */
function setupWelcomeModalAccessibility() {
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) return;
    
    // ESC para fechar
    document.addEventListener('keydown', function handleWelcomeEscape(e) {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeWelcomeModal();
        }
    });
    
    // Tab navigation (trap focus)
    modal.addEventListener('keydown', function handleWelcomeTabNav(e) {
        if (e.key !== 'Tab') return;
        
        const focusableElements = modal.querySelectorAll(
            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
        }
    });
    
    __dbg('‚å®Ô∏è Acessibilidade do modal de boas-vindas configurada');
}

// Inicializar acessibilidade quando DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupWelcomeModalAccessibility);
} else {
    setupWelcomeModalAccessibility();
}

// ============================================================================

// üéµ Abrir modal de an√°lise de √°udio (MODIFICADO para usar novo fluxo)
function openAudioModal() {
    window.logReferenceEvent('open_modal_requested');
    
    // üåü NOVO: Abrir modal de boas-vindas PRIMEIRO
    openWelcomeModal();
}

// üéØ NOVO: Abrir modal secund√°rio para upload da m√∫sica de refer√™ncia
function openReferenceUploadModal(referenceJobId, firstAnalysisResult) {
    __dbg('üéØ Abrindo modal secund√°rio para m√∫sica de refer√™ncia', { referenceJobId });
    
    // üéØ PROTE√á√ÉO: Garantir que primeira an√°lise est√° completa
    if (!firstAnalysisResult) {
        console.error('‚ùå [PROTECTION] Primeira an√°lise n√£o est√° completa - abortando abertura do modal de refer√™ncia');
        alert('‚ö†Ô∏è A primeira an√°lise ainda n√£o foi conclu√≠da. Por favor, aguarde.');
        return;
    }
    
    // üéØ PROTE√á√ÉO: Validar que h√° dados essenciais
    if (!firstAnalysisResult.technicalData) {
        console.error('‚ùå [PROTECTION] Primeira an√°lise n√£o cont√©m technicalData - dados incompletos');
        alert('‚ö†Ô∏è A primeira an√°lise n√£o foi conclu√≠da corretamente. Por favor, tente novamente.');
        return;
    }
    
    console.log('‚úÖ [PROTECTION] Primeira an√°lise validada com sucesso:', {
        hasJobId: !!referenceJobId,
        hasTechnicalData: !!firstAnalysisResult.technicalData,
        hasScore: !!firstAnalysisResult.score
    });
    
    window.logReferenceEvent('reference_upload_modal_opened', { referenceJobId });
    
    // üéØ PERSISTIR DADOS DA PRIMEIRA FAIXA
    window.__REFERENCE_JOB_ID__ = referenceJobId;
    
    // ÔøΩ HARD-GUARD: Salvar primeira an√°lise no FirstAnalysisStore (IMUT√ÅVEL)
    console.log('[FirstAnalysisStore] üîí Salvando primeira an√°lise no store imut√°vel...');
    
    // ‚úÖ USAR NOVA API: FirstAnalysisStore.set() - clonagem interna
    FirstAnalysisStore.set(firstAnalysisResult);
    
    // ‚ùå REMOVER: N√£o usar mais window.referenceAnalysisData / window.__FIRST_ANALYSIS_RESULT__
    // A √öNICA fonte de verdade √© FirstAnalysisStore
    
    window.lastReferenceJobId = referenceJobId;
    
    console.log('‚úÖ [COMPARE-MODE] Primeira faixa salva:', {
        jobId: referenceJobId,
        score: firstAnalysisResult?.score,
        lufs: firstAnalysisResult?.technicalData?.lufsIntegrated,
        storeProtected: FirstAnalysisStore.has()
    });
    
    // üî• FIX-REFERENCE: N√ÉO chamar reset completo - apenas limpar UI visualmente
    // closeAudioModal();   // ‚ùå REMOVIDO - deletava __REFERENCE_JOB_ID__
    // resetModalState();   // ‚ùå REMOVIDO - deletava __REFERENCE_JOB_ID__

    // Resetar apenas UI (sem limpar flags globais)
    const uploadAreaFirst = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');

    if (uploadAreaFirst) uploadAreaFirst.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';

    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';

    console.log('[FIX-REFERENCE] Modal reaberto SEM limpar flags de refer√™ncia');
    
    // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: N√£o permitir ativa√ß√£o de modo reference se usu√°rio n√£o selecionou explicitamente
    if (!userExplicitlySelectedReferenceMode) {
        console.error('%c[PROTECTION] ‚ùå BLOQUEIO ATIVADO: openReferenceUploadModal chamado mas userExplicitlySelectedReferenceMode = false', 'color:#FF0000;font-weight:bold;font-size:14px;');
        console.error('[PROTECTION] ‚ùå Modo reference n√£o pode ser ativado automaticamente - usu√°rio est√° em modo genre');
        console.trace('[PROTECTION] Stack trace do bloqueio:');
        alert('‚ö†Ô∏è ERRO: Sistema tentou ativar modo A/B automaticamente. Por favor, selecione o modo A/B explicitamente.');
        return;
    }
    
    // üéØ CORRE√á√ÉO: Manter modo 'reference' para segunda m√∫sica tamb√©m
    // O backend identifica que √© compara√ß√£o pela presen√ßa do referenceJobId
    currentAnalysisMode = 'reference';
    console.log('%c[PROTECTION] ‚úÖ currentAnalysisMode definido como reference - flag verificada', 'color:#00FF88;font-weight:bold;');
    
    // Abrir modal novamente
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('‚ùå Modal de an√°lise de √°udio n√£o encontrado');
        return;
    }
    
    // Atualizar t√≠tulo e instru√ß√µes do modal
    const modalTitle = document.getElementById('audioModalTitle');
    const modalSubtitle = document.getElementById('audioModalSubtitle');
    
    if (modalTitle) {
        modalTitle.innerHTML = 'üéØ Upload da M√∫sica de Refer√™ncia';
    }
    
    if (modalSubtitle) {
        modalSubtitle.innerHTML = '<span id="audioModeIndicator">Etapa 2/2: Envie a m√∫sica de refer√™ncia para compara√ß√£o</span>';
        modalSubtitle.style.display = 'block';
    }
    
    // Atualizar mensagem na √°rea de upload
    const uploadAreaSecond = document.getElementById('audioUploadArea');
    if (uploadAreaSecond) {
        const uploadContent = uploadAreaSecond.querySelector('.upload-content h4');
        if (uploadContent) {
            uploadContent.textContent = 'Enviar m√∫sica de refer√™ncia';
        }
        
        const uploadDescription = uploadAreaSecond.querySelector('.upload-content p');
        if (uploadDescription) {
            uploadDescription.textContent = 'Arraste a m√∫sica de refer√™ncia aqui ou clique para selecionar';
        }
    }
    
    // Mostrar modal
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    
    __dbg('‚úÖ Modal secund√°rio de refer√™ncia aberto');
}

// üéØ NOVO: Modal de Sele√ß√£o de Modo
function openModeSelectionModal() {
    __dbg('ÔøΩ Abrindo modal de sele√ß√£o de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (!modal) {
        console.error('Modal de sele√ß√£o de modo n√£o encontrado');
        return;
    }
    
    // Verificar se modo refer√™ncia est√° habilitado e mostrar/esconder bot√£o
    const referenceModeBtn = document.getElementById('referenceModeBtn');
    if (referenceModeBtn) {
        const isEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
        referenceModeBtn.style.display = isEnabled ? 'flex' : 'none';
        
        if (!isEnabled) {
            referenceModeBtn.disabled = true;
        }
    }
    
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('mode_selection_modal_opened');
}

function closeModeSelectionModal() {
    __dbg('‚ùå Fechando modal de sele√ß√£o de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    window.logReferenceEvent('mode_selection_modal_closed');
}

// üéØ NOVO: Selecionar modo de an√°lise
function selectAnalysisMode(mode) {
    window.logReferenceEvent('analysis_mode_selected', { mode });
    
    if (mode === 'reference' && !window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED) {
        alert('Modo de an√°lise por refer√™ncia n√£o est√° dispon√≠vel no momento.');
        return;
    }
    
    currentAnalysisMode = mode;
    
    // Fechar modal de sele√ß√£o de modo
    closeModeSelectionModal();
    
    // Abrir modal de an√°lise configurado para o modo selecionado
    openAnalysisModalForMode(mode);
}

// ÔøΩ NOVO MODAL DE G√äNERO MUSICAL - Sistema completo
// Feature flag para controlar ativa√ß√£o
window.FEATURE_NEW_GENRE_MODAL = true; // Definir como false para usar seletor antigo

// üéµ Fun√ß√µes do Modal de G√™nero Musical
function openGenreModal() {
    __dbg('[GENRE_MODAL] Abrindo modal de sele√ß√£o de g√™nero...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal n√£o encontrado no DOM');
        return;
    }
    
    // Injetar estilos se ainda n√£o foi feito
    injectGenreModalStyles();
    
    // üîß CORRE√á√ÉO FLASH BRANCO: Prepaint para evitar primeiro frame errado
    modal.classList.add('prepaint');  // Cards invis√≠veis enquanto CSS aplica
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
    
    // Libera a transi√ß√£o s√≥ de opacity no pr√≥ximo frame
    requestAnimationFrame(() => {
        modal.classList.remove('prepaint');
        
        // Foco no primeiro bot√£o de g√™nero
        const firstGenreCard = modal.querySelector('.genre-card');
        if (firstGenreCard) {
            firstGenreCard.focus();
        }
    });
    
    // Adicionar listeners de teclado
    modal.addEventListener('keydown', handleGenreModalKeydown);
    
    __dbg('[GENRE_MODAL] Modal aberto com sucesso (sem flash branco)');
}

function closeGenreModal() {
    __dbg('[GENRE_MODAL] Fechando modal de sele√ß√£o de g√™nero...');
    
    const modal = document.getElementById('newGenreModal');
    if (modal) {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        
        // Remover listeners
        modal.removeEventListener('keydown', handleGenreModalKeydown);
    }
    
    __dbg('[GENRE_MODAL] Modal fechado');
}

function handleGenreModalKeydown(e) {
    if (e.key === 'Escape') {
        closeGenreModal();
    }
}

// üéØ Inicializa√ß√£o do Modal de G√™nero
function initGenreModal() {
    __dbg('[GENRE_MODAL] Inicializando sistema do modal...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.warn('[GENRE_MODAL] Modal n√£o encontrado, inicializa√ß√£o cancelada');
        return;
    }
    
    const genreCards = modal.querySelectorAll('.genre-card');
    const closeBtn = modal.querySelector('[data-close]');
    
    // üéØ Handler de clique nos g√™neros
    genreCards.forEach(card => {
        card.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const genre = card.dataset.genre;
            if (!genre) {
                console.error('[GENRE_MODAL] G√™nero n√£o definido no card');
                return;
            }
            
            __dbg('[GENRE_MODAL] G√™nero selecionado:', genre);
            
            // üî• REUTILIZAR EXATAMENTE: Chamar applyGenreSelection como especificado
            if (typeof applyGenreSelection === 'function') {
                // ‚úÖ CORRE√á√ÉO CR√çTICA: Aguardar carregamento completo dos targets
                await applyGenreSelection(genre);
                
                // ‚úÖ Log detalhado mostrando targets reais
                console.log('‚úÖ [GENRE_MODAL] Targets de g√™nero carregados:', {
                    genre: genre,
                    hasActiveRefData: !!window.__activeRefData,
                    hasTargets: !!window.__activeRefData?.targets,
                    targetSource: window.__activeRefData?.targetSource,
                    targetKeys: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets) : [],
                    targetSample: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets).slice(0, 3) : [],
                    lufs_target: window.__activeRefData?.lufs_target,
                    true_peak_target: window.__activeRefData?.true_peak_target,
                    version: window.__activeRefData?.version
                });
                
                __dbg('[GENRE_MODAL] ‚úÖ applyGenreSelection conclu√≠do com sucesso');
            } else {
                console.error('[GENRE_MODAL] applyGenreSelection n√£o est√° dispon√≠vel');
                return;
            }
            
            // üî• Fechar modal conforme especifica√ß√£o
            closeGenreModal();
            
            // üî• CONTINUAR FLUXO: Abrir modal de upload automaticamente
            // ‚úÖ CORRE√á√ÉO: Removido setTimeout - targets j√° est√£o carregados
            openAnalysisModalForGenre();
        });
    });
    
    // Handler do bot√£o fechar
    if (closeBtn) {
        closeBtn.addEventListener('click', closeGenreModal);
    }
    
    // Fechar clicando no fundo
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeGenreModal();
        }
    });
    
    __dbg('[GENRE_MODAL] Sistema inicializado com sucesso');
}

// üéØ Abrir modal de an√°lise ap√≥s sele√ß√£o de g√™nero
function openAnalysisModalForGenre() {
    __dbg('[GENRE_MODAL] Abrindo modal de an√°lise para g√™nero selecionado...');
    
    // Usar o fluxo normal do modal de an√°lise
    window.currentAnalysisMode = 'genre';
    
    // üéØ LIMPAR estado de refer√™ncia ao entrar em modo genre (conforme solicitado)
    const state = window.__soundyState || {};
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        console.log('‚úÖ [GENRE-CLEANUP] Estado de refer√™ncia limpo ao iniciar modo genre');
    }
    window.__soundyState = state;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal de an√°lise n√£o encontrado');
        return;
    }
    
    // Configurar modal para modo g√™nero
    configureModalForMode('genre');
    
    modal.style.display = 'flex';
    
    // ‚úÖ CORRE√á√ÉO CR√çTICA: N√ÉO resetar g√™nero/targets aqui!
    // Apenas limpar estado visual de upload (preserva g√™nero selecionado)
    clearAudioOnlyState();
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    __dbg('[GENRE_MODAL] Modal de an√°lise aberto (g√™nero preservado)');
}

// Expor fun√ß√µes globalmente
window.openGenreModal = openGenreModal;
window.closeGenreModal = closeGenreModal;

// ÔøΩüéØ NOVO: Abrir modal de an√°lise configurado para o modo
function openAnalysisModalForMode(mode) {
    __dbg(`üéµ Abrindo modal de an√°lise para modo: ${mode}`);
    
    // üÜï FEATURE FLAG: Verificar se deve usar novo modal de g√™nero
    if (mode === 'genre' && window.FEATURE_NEW_GENRE_MODAL === true) {
        __dbg('üé® Usando novo modal de g√™nero musical');
        openGenreModal();
        return;
    }
    
    // CORRE√á√ÉO CR√çTICA: Definir window.currentAnalysisMode sempre que o modal for aberto
    window.currentAnalysisMode = mode;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('Modal de an√°lise n√£o encontrado');
        return;
    }
    
    // Configurar modal baseado no modo
    configureModalForMode(mode);
    
    // Reset state espec√≠fico do modo
    if (mode === 'reference') {
        resetReferenceState();
    }
    
    modal.style.display = 'flex';
    
    // ‚úÖ CORRE√á√ÉO: Reset seletivo baseado no modo
    if (mode === 'genre') {
        // Modo g√™nero: apenas limpar visual (preserva g√™nero)
        clearAudioOnlyState();
    } else {
        // Modo refer√™ncia: reset completo
        resetModalState();
    }
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('analysis_modal_opened', { mode });
}

// üéØ NOVO: Configurar modal baseado no modo selecionado
function configureModalForMode(mode) {
    const title = document.getElementById('audioModalTitle');
    const subtitle = document.getElementById('audioModalSubtitle');
    const modeIndicator = document.getElementById('audioModeIndicator');
    const genreContainer = document.getElementById('audioRefGenreContainer');
    const progressSteps = document.getElementById('referenceProgressSteps');
    
    if (mode === 'genre') {
        // Modo G√™nero: comportamento original
        if (title) title.textContent = 'üéµ An√°lise de √Åudio';
        if (subtitle) subtitle.style.display = 'none';
        if (genreContainer) genreContainer.style.display = 'flex';
        if (progressSteps) progressSteps.style.display = 'none';
        
        // üîß FIX: Limpar dados de refer√™ncia ao trocar para modo genre
        if (window.__referenceComparisonActive) {
            console.log('[MODE_CHANGE] Trocando de REFERENCE para GENRE - limpando dados');
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            window.__referenceComparisonActive = false;
            
            console.log('[MODE_CHANGE] ‚úÖ Dados de refer√™ncia limpos para modo GENRE');
        }
        
    } else if (mode === 'reference') {
        // Modo Refer√™ncia: interface espec√≠fica
        if (title) title.textContent = 'üéØ An√°lise por Refer√™ncia';
        if (subtitle) {
            subtitle.style.display = 'block';
            if (modeIndicator) {
                modeIndicator.textContent = 'Compara√ß√£o direta entre suas m√∫sicas';
            }
        }
        if (genreContainer) genreContainer.style.display = 'none';
        if (progressSteps) progressSteps.style.display = 'flex';
        
        // Configurar steps iniciais
        updateReferenceStep('userAudio');
    }
}

// üéØ NOVO: Reset estado do modo refer√™ncia (compatibilidade)
function resetReferenceState() {
    // üö® BLINDAGEM ABSOLUTA: NUNCA resetar em modo genre
    if (window.__CURRENT_MODE__ === 'genre') {
        console.warn('[GENRE-PROTECT] ‚ö†Ô∏è resetReferenceState() BLOQUEADO em modo genre');
        console.warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        return; // N√ÉO executar reset
    }

    referenceStepState = {
        currentStep: 'userAudio',
        userAudioFile: null,
        referenceAudioFile: null,
        userAnalysis: null,
        referenceAnalysis: null
    };
    
    window.logReferenceEvent('reference_state_reset');
}

// üéØ FUN√á√ÉO AUXILIAR: Obter g√™nero ativo de m√∫ltiplas fontes
function getActiveGenre(analysis, fallback) {
    // üéØ PRIORIDADE CORRETA: Fontes diretas ANTES de data.genre
    const genre = analysis?.genre ||             // ‚úÖ 1¬™ prioridade: valor direto
                 analysis?.genreId ||            // ‚úÖ 2¬™ prioridade: ID do g√™nero
                 analysis?.metadata?.genre ||    // ‚úÖ 3¬™ prioridade: metadata
                 analysis?.data?.genre ||        // ‚ö†Ô∏è 4¬™ prioridade: pode ser null (contaminado)
                 fallback;                       // ‚úÖ 5¬™ prioridade: fallback
    
    console.log('[GET-ACTIVE-GENRE] G√™nero detectado:', genre, '(fallback:', fallback, ')');
    console.log('[GET-ACTIVE-GENRE] Fontes verificadas:', {
        'analysis.genre': analysis?.genre,
        'analysis.genreId': analysis?.genreId,
        'analysis.metadata.genre': analysis?.metadata?.genre,
        'analysis.data.genre': analysis?.data?.genre,
        'fallback': fallback,
        'final': genre
    });
    return genre;
}

// üî• CORRE√á√ÉO CR√çTICA: Limpeza COMPLETA do estado de refer√™ncia para modo g√™nero
function resetReferenceStateFully(preserveGenre) {
    // ‚úÖ PROTE√á√ÉO: N√£o limpar targets no modo g√™nero
    const currentMode = window.currentAnalysisMode;
    if (currentMode === 'genre') {
        console.log('%c[GENRE-ISOLATION] üõ°Ô∏è Modo GENRE detectado - IGNORANDO reset de refer√™ncia', 'color:#FFD700;font-weight:bold;font-size:14px;');
        console.log('[GENRE-ISOLATION] ‚úÖ Targets de g√™nero preservados (reset bloqueado)');
        
        // üõ°Ô∏è PROTE√á√ÉO: Resetar flag ao limpar estado de refer√™ncia
        userExplicitlySelectedReferenceMode = false;
        console.log('%c[PROTECTION] ‚úÖ Flag userExplicitlySelectedReferenceMode resetada em resetReferenceStateFully', 'color:#00FF88;font-weight:bold;');
        
        return; // N√ÉO executar reset no modo g√™nero
    }
    
    console.group('%c[GENRE-ISOLATION] üßπ Limpeza completa do estado de refer√™ncia', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
    
    // üõ°Ô∏è PROTE√á√ÉO: Resetar flag ao limpar estado de refer√™ncia
    userExplicitlySelectedReferenceMode = false;
    console.log('%c[PROTECTION] ‚úÖ Flag userExplicitlySelectedReferenceMode resetada em resetReferenceStateFully', 'color:#00FF88;font-weight:bold;');
    
    // ===============================================================
    // üîí BLOCO 1 ‚Äî PRESERVAR G√äNERO ANTES DO RESET (M√öLTIPLAS FONTES)
    // ===============================================================
    let __PRESERVED_GENRE__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ = preserveGenre ||
                             window.__CURRENT_SELECTED_GENRE ||
                             window.PROD_AI_REF_GENRE ||
                             (genreSelect ? genreSelect.value : null) ||
                             window.__CURRENT_GENRE ||
                             window.__soundyState?.render?.genre ||
                             window.__activeUserGenre;

        console.log("[SAFE-RESET] ‚ö†Ô∏è Preservando g√™nero selecionado:", __PRESERVED_GENRE__);
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao capturar g√™nero antes do reset:", e);
    }
    
    // üéØ SALVAR G√äNERO ANTES DE LIMPAR (compatibilidade com c√≥digo existente)
    const __savedGenre = __PRESERVED_GENRE__;
    
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] üíæ Salvando g√™nero antes da limpeza:', __savedGenre);
    }
    
    // 1Ô∏è‚É£ Limpar vari√°veis globais window - CR√çTICO
    console.log('[GENRE-ISOLATION] 1Ô∏è‚É£ Limpando vari√°veis globais window...');
    
    // üî• CORRE√á√ÉO CR√çTICA: Salvar targets do g√™nero preservado ANTES de limpar
    let __savedGenreTargets = null;
    if (__savedGenre) {
        // PROD_AI_REF_DATA pode ser dicion√°rio ou objeto √∫nico
        if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object') {
            if (window.PROD_AI_REF_DATA[__savedGenre]) {
                // Estrutura de dicion√°rio
                __savedGenreTargets = window.PROD_AI_REF_DATA[__savedGenre];
                console.log('[GENRE-ISOLATION] üíæ Targets do g√™nero salvos (dicion√°rio):', __savedGenre);
            } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
                // Objeto √∫nico
                __savedGenreTargets = window.PROD_AI_REF_DATA;
                console.log('[GENRE-ISOLATION] üíæ Targets salvos (objeto √∫nico):', __savedGenre);
            }
        }
        // Fallback para __activeRefData
        if (!__savedGenreTargets && window.__activeRefData) {
            __savedGenreTargets = window.__activeRefData;
            console.log('[GENRE-ISOLATION] üíæ Targets salvos de __activeRefData:', __savedGenre);
        }
    }
    
    // üéØ CORRE√á√ÉO CR√çTICA: Resetar PROD_AI_REF_DATA para false (n√£o delete)
    window.PROD_AI_REF_DATA = false;
    console.log('   ‚úÖ window.PROD_AI_REF_DATA: false');
    
    // üî• CORRE√á√ÉO CR√çTICA: Restaurar targets do g√™nero preservado
    if (__savedGenre && __savedGenreTargets) {
        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
            window.PROD_AI_REF_DATA = {};
        }
        window.PROD_AI_REF_DATA[__savedGenre] = __savedGenreTargets;
        window.__activeRefData = __savedGenreTargets;
        console.log(`[GENRE-ISOLATION] üîÑ Targets restaurados para g√™nero: ${__savedGenre}`);
        console.log('   ‚úÖ window.PROD_AI_REF_DATA[' + __savedGenre + ']: restaurado');
        console.log('   ‚úÖ window.__activeRefData: restaurado com targets do g√™nero');
    } else {
        // üéØ CORRE√á√ÉO CR√çTICA: Resetar __activeRefData apenas se n√£o houver g√™nero preservado
        window.__activeRefData = null;
        console.log('   ‚úÖ window.__activeRefData: null');
    }
    
    // üéØ CORRE√á√ÉO CR√çTICA: Resetar __REFERENCE_JOB_ID__
    SOUNDY_MODE_ENGINE.clear();
    delete window.__REFERENCE_JOB_ID__;
    console.log('   ‚úÖ window.__REFERENCE_JOB_ID__: removido');
    
    // üéØ CORRE√á√ÉO CR√çTICA: Resetar __REFERENCE_FILE_KEY__
    window.__REFERENCE_FILE_KEY__ = null;
    console.log('   ‚úÖ window.__REFERENCE_FILE_KEY__: null');
    
    // üéØ CORRE√á√ÉO CR√çTICA: Resetar __CURRENT_JOB_ID__
    window.__CURRENT_JOB_ID__ = null;
    console.log('   ‚úÖ window.__CURRENT_JOB_ID__: null');
    
    // üéØ CORRE√á√ÉO CR√çTICA: Resetar __activeUserData
    window.__activeUserData = null;
    console.log('   ‚úÖ window.__activeUserData: null');
    
    delete window.referenceAnalysisData;
    window.__referenceComparisonActive = false;
    window.__FIRST_ANALYSIS_FROZEN__ = undefined;
    console.log('   ‚úÖ window.referenceAnalysisData: removido');
    console.log('   ‚úÖ window.__referenceComparisonActive: false');
    
    // 2Ô∏è‚É£ Limpar __soundyState
    console.log('[GENRE-ISOLATION] 2Ô∏è‚É£ Limpando window.__soundyState...');
    if (window.__soundyState) {
        delete window.__soundyState.reference;
        delete window.__soundyState.referenceAnalysis;
        delete window.__soundyState.previousAnalysis;
        if (window.__soundyState.render) {
            window.__soundyState.render.mode = 'genre';
        }
        console.log('   ‚úÖ __soundyState.reference: removido');
        console.log('   ‚úÖ __soundyState.referenceAnalysis: removido');
        console.log('   ‚úÖ __soundyState.render.mode: for√ßado para "genre"');
    }
    
    // 3Ô∏è‚É£ Limpar localStorage
    console.log('[GENRE-ISOLATION] 3Ô∏è‚É£ Limpando localStorage...');
    try {
        localStorage.removeItem('referenceJobId');
        localStorage.removeItem('referenceAnalysis');
        console.log('   ‚úÖ localStorage.referenceJobId: removido');
        console.log('   ‚úÖ localStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   ‚ö†Ô∏è Falha ao limpar localStorage:', e.message);
    }
    
    // 4Ô∏è‚É£ Limpar sessionStorage
    console.log('[GENRE-ISOLATION] 4Ô∏è‚É£ Limpando sessionStorage...');
    try {
        sessionStorage.removeItem('referenceJobId');
        sessionStorage.removeItem('referenceAnalysis');
        console.log('   ‚úÖ sessionStorage.referenceJobId: removido');
        console.log('   ‚úÖ sessionStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   ‚ö†Ô∏è Falha ao limpar sessionStorage:', e.message);
    }
    
    // 5Ô∏è‚É£ Limpar Store (se existir)
    console.log('[GENRE-ISOLATION] 5Ô∏è‚É£ Limpando SoundyAI_Store...');
    if (window.SoundyAI_Store) {
        delete window.SoundyAI_Store.first;
        delete window.SoundyAI_Store.second;
        console.log('   ‚úÖ SoundyAI_Store.first: removido');
        console.log('   ‚úÖ SoundyAI_Store.second: removido');
    }
    
    // 6Ô∏è‚É£ Resetar referenceStepState
    console.log('[GENRE-ISOLATION] 6Ô∏è‚É£ Resetando referenceStepState...');
    if (typeof referenceStepState !== 'undefined') {
        referenceStepState = {
            currentStep: 'userAudio',
            userAudioFile: null,
            referenceAudioFile: null,
            userAnalysis: null,
            referenceAnalysis: null
        };
        console.log('   ‚úÖ referenceStepState: resetado');
    }
    
    // üîß CORRE√á√ÉO CR√çTICA: Resetar flag de renderiza√ß√£o de IA
    // Permite que o m√≥dulo de sugest√µes seja re-renderizado ap√≥s limpeza
    console.log('[GENRE-ISOLATION] 7Ô∏è‚É£ Resetando flags de renderiza√ß√£o de IA...');
    window.__AI_RENDER_COMPLETED__ = false;
    console.log('   ‚úÖ window.__AI_RENDER_COMPLETED__: false (permitir re-renderiza√ß√£o)');
    
    // üéØ RESTAURAR G√äNERO AP√ìS LIMPEZA
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] üîÑ Restaurando g√™nero:', __savedGenre);
        window.__CURRENT_GENRE = __savedGenre;
        
        if (!window.__soundyState) {
            window.__soundyState = {};
        }
        if (!window.__soundyState.render) {
            window.__soundyState.render = {};
        }
        
        window.__soundyState.render.genre = __savedGenre;
        window.__activeUserGenre = __savedGenre;
        window.PROD_AI_REF_GENRE = __savedGenre;  // ‚úÖ CORRE√á√ÉO: Sincronizar PROD_AI_REF_GENRE
        
        console.log('   ‚úÖ window.__CURRENT_GENRE:', __savedGenre);
        console.log('   ‚úÖ window.__soundyState.render.genre:', __savedGenre);
        console.log('   ‚úÖ window.__activeUserGenre:', __savedGenre);
        console.log('   ‚úÖ window.PROD_AI_REF_GENRE:', __savedGenre);
    }
    
    // ===============================================================
    // üîí BLOCO 3 ‚Äî RESTAURAR G√äNERO NO DROPDOWN AP√ìS O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;
            window.__CURRENT_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            console.log("[SAFE-RESET] ‚úÖ G√™nero restaurado no dropdown ap√≥s reset:", __PRESERVED_GENRE__);
        } else {
            console.warn("[SAFE-RESET] ‚ö†Ô∏è Nenhum g√™nero v√°lido preservado para dropdown.");
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar g√™nero no dropdown:", e);
    }
    
    console.log('%c[GENRE-ISOLATION] ‚úÖ Estado de refer√™ncia completamente limpo', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

// ========================================
// üî• UI HELPERS - SHOW/HIDE SE√á√ïES
// ========================================

function hideReferenceUI() {
    console.log('[UI-CONTROL] üôà Ocultando elementos de UI de refer√™ncia...');
    
    // Ocultar elementos espec√≠ficos de refer√™ncia
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ‚úÖ Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showGenreUI() {
    console.log('[UI-CONTROL] üëÅÔ∏è Exibindo elementos de UI de g√™nero...');
    
    // Exibir elementos espec√≠ficos de g√™nero
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ‚úÖ Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

function hideGenreUI() {
    console.log('[UI-CONTROL] üôà Ocultando elementos de UI de g√™nero...');
    
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ‚úÖ Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showReferenceUI() {
    console.log('[UI-CONTROL] üëÅÔ∏è Exibindo elementos de UI de refer√™ncia...');
    
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ‚úÖ Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

// ========================================
// üî• RENDERIZA√á√ÉO ISOLADA DE G√äNERO
// ========================================

// üéØ M√ìDULO DE CONVERS√ÉO DE BANDAS (EXCLUSIVO PARA MODO G√äNERO)
// ========================================
/**
 * Converte nomes de bandas do backend para o formato esperado pelos targets de g√™nero.
 * 
 * Backend envia: sub, bass, lowMid, mid, highMid, presence, air
 * Targets esperam: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
 * 
 * ‚ö†Ô∏è USO EXCLUSIVO: Apenas para analysis.mode === "genre"
 * ‚ùå NUNCA usar para: mode === "reference", A/B, referenceComparison
 * 
 * @param {Object} bands - Bandas do backend (analysis.bands)
 * @returns {Object} Bandas convertidas para formato de targets de g√™nero
 */
// üéØ SISTEMA DE ALIAS DE BANDAS (branch imersao)
const BAND_ALIASES = {
    'bass': ['low_bass', 'upper_bass'],
    'lowMid': ['low_mid'],
    'highMid': ['high_mid'],
    'presence': ['presenca'],
    'air': ['brilho']
};

/**
 * Busca banda com suporte a alias (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} bandsObject - Objeto com bandas
 * @returns {Object|null} Dados da banda ou null
 */
function searchBandWithAlias(bandKey, bandsObject) {
    if (!bandsObject || typeof bandsObject !== 'object') return null;
    
    // 1. Busca direta
    if (bandsObject[bandKey]) {
        return bandsObject[bandKey];
    }
    
    // 2. Busca por alias
    const aliases = BAND_ALIASES[bandKey];
    if (aliases) {
        for (const alias of aliases) {
            if (bandsObject[alias]) {
                console.log(`üîÑ [ALIAS] ${bandKey} ‚Üí ${alias}`);
                return bandsObject[alias];
            }
        }
    }
    
    return null;
}

/**
 * Busca banda em m√∫ltiplas fontes com cascata (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} analysis - Objeto de an√°lise completo
 * @returns {Object|null} Dados da banda com source
 */
/**
 * Normaliza nomes de bandas do backend para formato dos targets de g√™nero.
 * Backend: ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air']
 * Targets: ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca']
 */
function normalizeGenreBandName(name) {
    // üéØ PATCH DEFINITIVO: Backend J√Å normalizou (low_bass ‚Üí bass, presenca ‚Üí presence, etc.)
    // N√£o converter novamente! Apenas garantir compatibilidade com snake_case legado
    const map = {
        // Se ainda receber snake_case (compatibilidade), converter para camelCase
        'low_bass': 'bass',
        'upper_bass': 'upperBass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air',
        // CamelCase j√° normalizado - retornar como est√°
        'bass': 'bass',
        'upperBass': 'upperBass',
        'lowMid': 'lowMid',
        'highMid': 'highMid',
        'presence': 'presence',
        'air': 'air',
        'sub': 'sub',
        'mid': 'mid'
    };
    return map[name] || name;
}

function getBandDataWithCascade(bandKey, analysis) {
    // üéØ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    
    // 1. Prioridade: analysis.metrics.bands (centralizado - mantido por compatibilidade)
    if (analysis.metrics?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.metrics.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'centralized' 
            };
        }
    }
    
    // üéØ CORRE√á√ÉO: 2. analysis.technicalData.bands (caminho REAL do backend - prioridade 2)
    if (analysis.technicalData?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'technical' 
            };
        }
    }
    
    // üéØ CORRE√á√ÉO: 3. analysis.technicalData.spectral_balance (fonte real - alias de bands)
    if (analysis.technicalData?.spectral_balance) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectral_balance);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectral_balance' 
            };
        }
    }
    
    // 4. Fallback: tech.bandEnergies (legado)
    if (analysis.technicalData?.bandEnergies) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bandEnergies);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'legacy' 
            };
        }
    }
    
    // 5. Fallback: tech.spectralBands (legado)
    if (analysis.technicalData?.spectralBands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectralBands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectralBands' 
            };
        }
    }
    
    return null;
}

function mapBackendBandsToGenreBands(bands) {
    if (!bands || typeof bands !== 'object') {
        console.warn('[BAND-MAPPER] ‚ö†Ô∏è Bandas inv√°lidas recebidas:', bands);
        return {};
    }
    
    console.group('[BAND-MAPPER] üîÑ Convertendo bandas do backend para formato de g√™nero');
    console.log('[BAND-MAPPER] Bandas originais (backend):', Object.keys(bands));
    
    const mapped = {
        // Mapeamento direto (mesma chave)
        sub: bands.sub || null,
        mid: bands.mid || null,
        
        // Convers√µes necess√°rias
        low_bass: bands.bass || null,           // bass ‚Üí low_bass
        upper_bass: null,                       // ‚ùå n√£o existe no backend atual
        low_mid: bands.lowMid || null,          // lowMid ‚Üí low_mid
        high_mid: bands.highMid || null,        // highMid ‚Üí high_mid
        brilho: bands.air || null,              // air ‚Üí brilho
        presenca: bands.presence || null        // presence ‚Üí presenca
    };
    
    console.log('[BAND-MAPPER] Bandas convertidas (targets):', Object.keys(mapped).filter(k => mapped[k] !== null));
    console.log('[BAND-MAPPER] Bandas ausentes:', Object.keys(mapped).filter(k => mapped[k] === null));
    console.groupEnd();
    
    return mapped;
}

/**
 * Aplica convers√£o de bandas EXCLUSIVAMENTE para modo g√™nero.
 * 
 * @param {Object} analysis - Objeto de an√°lise completo
 * @returns {Object} An√°lise com bandas convertidas (analysis.genreBands)
 */
function applyGenreBandConversion(analysis) {
    // üõ°Ô∏è GUARD: Apenas para modo g√™nero
    if (analysis?.mode !== 'genre') {
        console.log('[BAND-MAPPER] ‚è≠Ô∏è Modo n√£o √© g√™nero, pulando convers√£o');
        return analysis;
    }
    
    console.group('[BAND-MAPPER] üéØ Aplicando convers√£o de bandas para modo G√äNERO');
    console.log('[BAND-MAPPER] Mode:', analysis.mode);
    console.log('[BAND-MAPPER] Bandas originais:', analysis.bands ? Object.keys(analysis.bands) : 'N/A');
    
    // Converter bandas do backend para formato de targets
    if (analysis.bands) {
        analysis.genreBands = mapBackendBandsToGenreBands(analysis.bands);
        console.log('[BAND-MAPPER] ‚úÖ analysis.genreBands criado com', Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null).length, 'bandas');
    } else {
        console.warn('[BAND-MAPPER] ‚ö†Ô∏è analysis.bands n√£o dispon√≠vel');
        analysis.genreBands = {};
    }
    
    console.groupEnd();
    return analysis;
}

function renderGenreView(analysis) {
    console.group('%c[GENRE-VIEW] üé® Renderizando UI exclusiva de g√™nero', 'color:#00C9FF;font-weight:bold;font-size:14px;');
    
    // üî• ISOLAMENTO TOTAL: Limpar TODAS as vari√°veis de refer√™ncia
    console.log('[GENRE-VIEW] üßπ LIMPANDO vari√°veis de refer√™ncia...');
    analysis.referenceComparison = undefined;
    analysis.referenceComparisonMetrics = undefined;
    window.referenceComparisonMetrics = null;
    console.log('[GENRE-VIEW] ‚úÖ Vari√°veis de refer√™ncia limpas');
    
    // 1Ô∏è‚É£ Validar an√°lise
    if (!analysis) {
        console.error('[GENRE-VIEW] ‚ùå ERRO: An√°lise n√£o fornecida');
        console.groupEnd();
        return;
    }
    
    // 2Ô∏è‚É£ Garantir limpeza completa
    console.log('[GENRE-VIEW] 1Ô∏è‚É£ Executando limpeza preventiva...');
    // üéØ PRESERVAR G√äNERO durante o reset - USANDO extractGenreName
    const genreToPreserve = extractGenreName(analysis) || window.PROD_AI_REF_GENRE;
    resetReferenceStateFully(genreToPreserve);
    
    // üéØ GARANTIR que analysis.genre est√° definido
    if (genreToPreserve && !analysis.genre) {
        analysis.genre = genreToPreserve;
    }
    
    // 3Ô∏è‚É£ Configurar ViewMode
    console.log('[GENRE-VIEW] 2Ô∏è‚É£ Configurando ViewMode...');
    setViewMode("genre");
    
    // 4Ô∏è‚É£ Controlar UI visibility
    console.log('[GENRE-VIEW] 3Ô∏è‚É£ Controlando visibilidade de UI...');
    hideReferenceUI();
    showGenreUI();
    
    // 5Ô∏è‚É£ Obter g√™nero - USANDO NOVA FUN√á√ÉO GENRE-ONLY
    const genre = extractGenreName(analysis) || 'default';
    
    console.log('[GENRE-VIEW] 4Ô∏è‚É£ G√™nero identificado:', genre);
    
    // üéØ CONVERS√ÉO DE BANDAS: Backend ‚Üí Targets de g√™nero
    console.log('[GENRE-VIEW] üîÑ Aplicando convers√£o de bandas...');
    applyGenreBandConversion(analysis);
    console.log('[GENRE-VIEW] ‚úÖ Bandas convertidas:', analysis.genreBands ? Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null) : 'N/A');
    
    // 6Ô∏è‚É£ Obter targets de g√™nero - USANDO NOVA FUN√á√ÉO GENRE-ONLY
    // üéØ PRIORIDADE 1: analysis.data.genreTargets (FONTE OFICIAL)
    let genreTargets = extractGenreTargets(analysis);
    
    // üéØ FALLBACK 1: Tentar carregar de PROD_AI_REF_DATA
    if (!genreTargets && window.PROD_AI_REF_DATA) {
        if (typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
            // Estrutura de dicion√°rio: { genre1: {...}, genre2: {...} }
            genreTargets = window.PROD_AI_REF_DATA[genre];
            console.log('[GENRE-VIEW] üì¶ Targets obtidos de PROD_AI_REF_DATA[genre] (fallback)');
        } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
            // Objeto √∫nico diretamente atribu√≠do
            genreTargets = window.PROD_AI_REF_DATA;
            console.log('[GENRE-VIEW] üì¶ Targets obtidos de PROD_AI_REF_DATA (fallback)');
        }
    }
    
    // üéØ FALLBACK 2: __activeRefData
    if (!genreTargets && window.__activeRefData) {
        genreTargets = window.__activeRefData;
        console.log('[GENRE-VIEW] üì¶ Targets obtidos de __activeRefData (fallback final)');
    }
    
    // üéØ FALLBACK 3: Carregar targets padr√£o se nada funcionar
    if (!genreTargets) {
        console.warn('[GENRE-VIEW] ‚ö†Ô∏è Nenhum target encontrado - carregando defaults');
        genreTargets = loadDefaultGenreTargets(genre);
        // Salvar em analysis.data.genreTargets para uso posterior
        if (!analysis.data) analysis.data = {};
        analysis.data.genreTargets = genreTargets;
    }
    
    if (!genreTargets) {
        console.error('[GENRE-VIEW] ‚ùå CR√çTICO: Targets de g√™nero n√£o dispon√≠veis - ABORTANDO');
        console.error('[GENRE-VIEW]    window.PROD_AI_REF_DATA:', window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    window.__activeRefData:', window.__activeRefData);
        console.error('[GENRE-VIEW]    Tipo PROD_AI_REF_DATA:', typeof window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    analysis.referenceComparison:', analysis.referenceComparison);
        console.error('[GENRE-VIEW] üîç DIAGN√ìSTICO: Verificar se targets foram carregados antes de displayModalResults');
        console.groupEnd();
        return; // ‚ùå ABORTAR se n√£o houver targets
    } else {
        console.log('[GENRE-VIEW] 5Ô∏è‚É£ Targets encontrados:', {
            hasBands: !!genreTargets?.bands,
            bandsCount: genreTargets?.bands ? Object.keys(genreTargets.bands).length : 0,
            hasLegacyCompatibility: !!genreTargets?.legacy_compatibility,
            hasLufsTarget: genreTargets?.lufs_target !== undefined,
            bandas: genreTargets?.bands ? Object.keys(genreTargets.bands) : 'N/A'
        });
    }
    
    // 7Ô∏è‚É£ Renderizar tabela de compara√ß√£o de g√™nero
    console.log('[GENRE-VIEW] 6Ô∏è‚É£ Renderizando tabela de compara√ß√£o...');
    console.log('[GENRE-VIEW] üéØ GARANTIA: Chamando renderGenreComparisonTable com targets validados');
    console.log('[GENRE-VIEW] üîç AUDIT: Targets sendo passados:', {
        hasHybridProcessing: !!genreTargets?.hybrid_processing,
        hasSpectralBands: !!genreTargets?.hybrid_processing?.spectral_bands,
        spectralBandsKeys: genreTargets?.hybrid_processing?.spectral_bands ? Object.keys(genreTargets.hybrid_processing.spectral_bands) : 'N/A'
    });
    
    renderGenreComparisonTable({
        analysis,
        genre,
        targets: genreTargets
    });
    
    console.log('[GENRE-VIEW] üéØ GARANTIA: renderGenreComparisonTable executado');
    console.log('[GENRE-VIEW] üîç AUDIT: Verificando se #referenceComparisons foi preenchido...');
    
    const refCompContainer = document.getElementById('referenceComparisons');
    if (refCompContainer) {
        console.log('[GENRE-VIEW] ‚úÖ Container encontrado:', {
            innerHTML: refCompContainer.innerHTML.length > 0 ? `${refCompContainer.innerHTML.length} chars` : 'VAZIO',
            display: window.getComputedStyle(refCompContainer).display,
            visibility: window.getComputedStyle(refCompContainer).visibility,
            opacity: window.getComputedStyle(refCompContainer).opacity
        });
    } else {
        console.error('[GENRE-VIEW] ‚ùå Container #referenceComparisons N√ÉO ENCONTRADO!');
    }
    
    console.log('%c[GENRE-VIEW] ‚úÖ Renderiza√ß√£o de g√™nero conclu√≠da', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

function renderGenreComparisonTable(options) {
    const { analysis, genre, targets } = options;
    
    console.group('[GENRE-TABLE] üìä RENDERIZA√á√ÉO COMPLETA DE G√äNERO');
    console.log('[GENRE-TABLE] üéØ G√™nero:', genre);
    console.log('[GENRE-TABLE] üìÅ Targets recebidos (par√¢metro):', targets);
    
    // üõ°Ô∏è GUARD: Apenas para modo g√™nero
    if (analysis?.mode !== 'genre') {
        console.warn('[GENRE-TABLE] ‚è≠Ô∏è Modo n√£o √© g√™nero, abortando renderiza√ß√£o');
        console.groupEnd();
        return;
    }
    
    // Buscar container
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('[GENRE-TABLE] ‚ùå Container #referenceComparisons n√£o encontrado!');
        console.groupEnd();
        return;
    }
    
    // üéØ CORRE√á√ÉO CR√çTICA: Usar targets recebidos por par√¢metro (j√° validados)
    let genreData = targets;
    console.log('[GENRE-TABLE] üéØ Usando targets recebidos por par√¢metro (fonte oficial)');
    
    console.log('[GENRE-TABLE] üì¶ Genre data recebido (flat object):', Object.keys(genreData));
    
    if (!genreData) {
        console.error('[GENRE-TABLE] ‚ùå CR√çTICO: Nenhum target dispon√≠vel!');
        console.error('[GENRE-TABLE]    - analysis.data.genreTargets:', !!analysis?.data?.genreTargets);
        console.error('[GENRE-TABLE]    - targets parameter:', !!targets);
        console.groupEnd();
        return;
    }
    
    console.log('[GENRE-TABLE] üì¶ Genre data:', {
        lufs_target: genreData.lufs_target,
        true_peak_target: genreData.true_peak_target,
        dr_target: genreData.dr_target,
        lra_target: genreData.lra_target,
        stereo_target: genreData.stereo_target,
        tol_lufs: genreData.tol_lufs,
        tol_true_peak: genreData.tol_true_peak,
        tol_dr: genreData.tol_dr,
        tol_lra: genreData.tol_lra,
        tol_stereo: genreData.tol_stereo,
        hasBands: !!genreData.bands
    });
    
    // üéØ EXTRAIR VALORES DO ANALYSIS (mesmas fontes usadas em calculateScore)
    const lufsIntegrated = analysis.loudness?.integrated ?? analysis.technicalData?.lufsIntegrated ?? null;
    const truePeakDbtp = analysis.truePeakDbtp ?? analysis.truePeak?.maxDbtp ?? analysis.technicalData?.truePeakDbtp ?? null;
    const dynamicRange = analysis.dynamicRange ?? analysis.dynamics?.range ?? analysis.technicalData?.dynamicRange ?? null;
    const lra = analysis.lra ?? analysis.loudness?.lra ?? analysis.technicalData?.lra ?? null;
    const stereoCorrelation = analysis.stereoCorrelation ?? analysis.stereo?.correlation ?? analysis.technicalData?.stereoCorrelation ?? null;
    
    console.log('[GENRE-TABLE] üìä Valores extra√≠dos do analysis:', {
        lufsIntegrated,
        truePeakDbtp,
        dynamicRange,
        lra,
        stereoCorrelation
    });
    
    // üéØ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode n√£o existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const userBands = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    console.log('[GENRE-TABLE] üéµ Fonte de bandas do usu√°rio:', 
        technicalBands ? '‚úÖ technicalData.bands (prioridade 1)' : 
        centralizedBands ? '‚ö†Ô∏è metrics.bands (fallback 2)' : 
        spectralBalance ? '‚ö†Ô∏è spectral_balance (fallback 3)' : 
        '‚ö†Ô∏è bandEnergies (fallback 4 - legado)');
    
    console.log('[GENRE-TABLE] üéµ Bandas dispon√≠veis:', userBands ? Object.keys(userBands) : 'NENHUMA');
    
    console.log('[GENRE-TABLE] üéµ Bandas do usu√°rio:', userBands ? Object.keys(userBands) : 'N/A');
    
    // üéØ PATCH: Aceitar 'bands' (normalizado) OU 'spectral_bands' (com underscore) com normaliza√ß√£o
    const targetBands = (() => {

        // üéØ PRIORIDADE 1: spectral_bands (estrutura correta do JSON com snake_case)
        if (genreData.spectral_bands && typeof genreData.spectral_bands === 'object' && Object.keys(genreData.spectral_bands).length > 0) {
            console.log('[GENRE-TABLE] üéØ Usando genreData.spectral_bands (normalizando)');
            
            // Normalizar chaves de snake_case ‚Üí camelCase
            const normalized = {};
            Object.keys(genreData.spectral_bands).forEach(snakeKey => {
                const camelKey = normalizeGenreBandName(snakeKey);
                normalized[camelKey] = genreData.spectral_bands[snakeKey];
            });
            
            console.log('[GENRE-TABLE] üéØ Bandas normalizadas:', Object.keys(normalized));
            return normalized;
        }

        // üéØ PRIORIDADE 2: bands (j√° normalizado via enrichReferenceObject)
        if (genreData.bands && Object.keys(genreData.bands).length > 0) {
            console.log('[GENRE-TABLE] üéØ Usando genreData.bands (j√° normalizado)');
            return genreData.bands;
        }

        // üéØ FALLBACK: extrair bandas da raiz (compatibilidade legado)
        const bandsFromRoot = {};
        const metricKeys = [
            'lufs_target','true_peak_target','dr_target','lra_target','stereo_target',
            'tol_lufs','tol_true_peak','tol_dr','tol_lra','tol_stereo'
        ];

        Object.keys(genreData).forEach(key => {
            const value = genreData[key];

            // Se √© um objeto, n√£o est√° na lista de m√©tricas e possui target_db = √© banda v√°lida
            if (typeof value === 'object' && value !== null && 
                !metricKeys.includes(key) &&
                (value.target_db !== undefined || value.target !== undefined)
            ) {
                // Normalizar chave de snake_case ‚Üí camelCase
                const normalizedKey = normalizeGenreBandName(key);
                bandsFromRoot[normalizedKey] = value;
            }
        });

        console.log('[GENRE-TABLE] üéØ Bandas extra√≠das da raiz (normalizadas):', Object.keys(bandsFromRoot));
        return bandsFromRoot;
    })();
    
    console.log('[GENRE-TABLE] üéØ Target bands (source):', genreData.bands ? 'bands' : (genreData.spectralBands ? 'spectralBands' : 'ROOT'));
    console.log('[GENRE-TABLE] üéØ Target bands (keys):', Object.keys(targetBands));
    
    // üéØ HELPER: Calcular severidade e a√ß√£o baseado em diferen√ßa e toler√¢ncia
    const calcSeverity = (value, target, tolerance, options = {}) => {
        const { targetRange } = options;
        
        if (!Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        // üéØ NOVA L√ìGICA: Priorizar target_range se existir
        if (targetRange && typeof targetRange === 'object') {
            // Suportar ambos formatos: { min, max } ou { min_db, max_db }
            const min = targetRange.min ?? targetRange.min_db;
            const max = targetRange.max ?? targetRange.max_db;
            
            if (typeof min !== 'number' || typeof max !== 'number') {
                // Range inv√°lido, usar fallback
                if (target === null || target === undefined) {
                    return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
                }
            } else {
                // ‚úÖ Valor dentro do range
                if (value >= min && value <= max) {
                    return { severity: 'OK', severityClass: 'ok', action: '‚úÖ Dentro do padr√£o', diff: 0 };
                }
                
                // ‚ùå Valor fora do range: calcular dist√¢ncia at√© borda mais pr√≥xima
                let diff;
                let absDelta;
                if (value < min) {
                    diff = value - min;  // negativo (precisa subir)
                    absDelta = min - value;
                } else {
                    diff = value - max;  // positivo (precisa descer)
                    absDelta = value - max;
                }
                
                // Thresholds para severidade baseados na dist√¢ncia
                if (absDelta >= 2) {
                    const action = diff > 0 ? `üî¥ Reduzir ${absDelta.toFixed(1)} dB` : `üî¥ Aumentar ${absDelta.toFixed(1)} dB`;
                    return { severity: 'CR√çTICA', severityClass: 'critical', action, diff };
                } else {
                    const action = diff > 0 ? `‚ö†Ô∏è Reduzir ${absDelta.toFixed(1)} dB` : `‚ö†Ô∏è Aumentar ${absDelta.toFixed(1)} dB`;
                    return { severity: 'ATEN√á√ÉO', severityClass: 'caution', action, diff };
                }
            }
        }
        
        // üîÑ FALLBACK: L√≥gica antiga com target fixo (para m√©tricas sem range)
        if (target === null || target === undefined) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        const diff = value - target;
        const absDiff = Math.abs(diff);
        
        if (absDiff <= tolerance) {
            return { severity: 'OK', severityClass: 'ok', action: '‚úÖ Dentro do padr√£o', diff };
        } else if (absDiff <= tolerance * 2) {
            const action = diff > 0 ? `‚ö†Ô∏è Reduzir ${absDiff.toFixed(1)}` : `‚ö†Ô∏è Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ATEN√á√ÉO', severityClass: 'caution', action, diff };
        } else if (absDiff <= tolerance * 3) {
            const action = diff > 0 ? `üü° Reduzir ${absDiff.toFixed(1)}` : `üü° Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ALTA', severityClass: 'warning', action, diff };
        } else {
            const action = diff > 0 ? `üî¥ Reduzir ${absDiff.toFixed(1)}` : `üî¥ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'CR√çTICA', severityClass: 'critical', action, diff };
        }
    };
    
    // Construir linhas da tabela
    const rows = [];
    let metricsCount = 0;
    let bandsCount = 0;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 1Ô∏è‚É£ M√âTRICAS PRINCIPAIS (LUFS, TRUE PEAK, DR, LRA, STEREO)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // üîä LUFS Integrado
    if (genreData.lufs_target !== null && genreData.lufs_target !== undefined) {
        const lufsValue = lufsIntegrated;
        if (Number.isFinite(lufsValue) && Number.isFinite(genreData.lufs_target)) {
            const result = calcSeverity(lufsValue, genreData.lufs_target, genreData.tol_lufs || 1.0);
            if (result && Number.isFinite(result.diff)) {
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">üîä Loudness (LUFS)</td>
                        <td class="metric-value">${lufsValue.toFixed(2)} LUFS</td>
                        <td class="metric-target">${genreData.lufs_target.toFixed(1)} LUFS</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ‚úÖ LUFS: ${lufsValue.toFixed(2)} | Target: ${genreData.lufs_target} | ${result.severity}`);
            }
        }
    }
    
    // üéöÔ∏è True Peak
    if (genreData.true_peak_target !== null && genreData.true_peak_target !== undefined) {
        const tpValue = truePeakDbtp;
        if (Number.isFinite(tpValue) && Number.isFinite(genreData.true_peak_target)) {
            const result = calcSeverity(tpValue, genreData.true_peak_target, genreData.tol_true_peak || 0.5);
            if (result && Number.isFinite(result.diff)) {
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">üéöÔ∏è Pico Real (dBTP)</td>
                        <td class="metric-value">${tpValue.toFixed(2)} dBTP</td>
                        <td class="metric-target">${genreData.true_peak_target.toFixed(1)} dBTP</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ‚úÖ True Peak: ${tpValue.toFixed(2)} | Target: ${genreData.true_peak_target} | ${result.severity}`);
            }
        }
    }
    
    // üìä Dynamic Range (DR)
    if (genreData.dr_target !== null && genreData.dr_target !== undefined) {
        const drValue = dynamicRange;
        if (Number.isFinite(drValue) && Number.isFinite(genreData.dr_target)) {
            const result = calcSeverity(drValue, genreData.dr_target, genreData.tol_dr || 1.0);
            if (result && Number.isFinite(result.diff)) {
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">üìä Din√¢mica (DR)</td>
                        <td class="metric-value">${drValue.toFixed(2)} DR</td>
                        <td class="metric-target">${genreData.dr_target.toFixed(1)} DR</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ‚úÖ DR: ${drValue.toFixed(2)} | Target: ${genreData.dr_target} | ${result.severity}`);
            }
        }
    }
    
    // üìà Loudness Range (LRA)
    if (genreData.lra_target !== null && genreData.lra_target !== undefined) {
        const lraValue = lra;
        if (Number.isFinite(lraValue) && Number.isFinite(genreData.lra_target)) {
            const result = calcSeverity(lraValue, genreData.lra_target, genreData.tol_lra || 2.0);
            if (result && Number.isFinite(result.diff)) {
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">üìà LRA (Faixa de Loudness)</td>
                        <td class="metric-value">${lraValue.toFixed(2)} LU</td>
                        <td class="metric-target">${genreData.lra_target.toFixed(1)} LU</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(2)}</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ‚úÖ LRA: ${lraValue.toFixed(2)} | Target: ${genreData.lra_target} | ${result.severity}`);
            }
        }
    }
    
    // üéß Stereo Correlation
    if (genreData.stereo_target !== null && genreData.stereo_target !== undefined) {
        const stereoValue = stereoCorrelation;
        if (Number.isFinite(stereoValue) && Number.isFinite(genreData.stereo_target)) {
            const result = calcSeverity(stereoValue, genreData.stereo_target, genreData.tol_stereo || 0.1);
            if (result && Number.isFinite(result.diff)) {
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">üéß Imagem Est√©reo</td>
                        <td class="metric-value">${stereoValue.toFixed(3)}</td>
                        <td class="metric-target">${genreData.stereo_target.toFixed(3)}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${result.diff >= 0 ? '+' : ''}${result.diff.toFixed(3)}</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ‚úÖ Stereo: ${stereoValue.toFixed(3)} | Target: ${genreData.stereo_target} | ${result.severity}`);
            }
        }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 2Ô∏è‚É£ BANDAS ESPECTRAIS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // üéØ PATCH: Usar nomenclatura NORMALIZADA (camelCase) igual ao backend
    const nomesBandas = {
        sub: 'üîâ Sub (20-60 Hz)',
        bass: 'üîä Bass (60-120 Hz)',           // ‚Üê low_bass normalizado
        upperBass: 'üîä Upper Bass (120-250 Hz)', // ‚Üê upper_bass normalizado
        lowMid: 'üéµ Low Mid (250-500 Hz)',      // ‚Üê low_mid normalizado
        mid: 'üéµ Mid (500-2k Hz)',
        highMid: 'üé∏ High Mid (2k-4k Hz)',      // ‚Üê high_mid normalizado
        presence: 'üíé Presen√ßa (10k-20k Hz)',   // ‚Üê presenca normalizado
        air: '‚ú® Brilho (4k-10k Hz)',           // ‚Üê brilho normalizado
        // Compatibilidade com nomes legados (snake_case)
        low_bass: 'üîä Bass (60-120 Hz)',
        upper_bass: 'üîä Upper Bass (120-250 Hz)',
        low_mid: 'üéµ Low Mid (250-500 Hz)',
        high_mid: 'üé∏ High Mid (2k-4k Hz)',
        presenca: 'üíé Presen√ßa (10k-20k Hz)',
        brilho: '‚ú® Brilho (4k-10k Hz)'
    };
    
    // üéØ ITERAR APENAS SOBRE BANDAS QUE EXISTEM NOS DOIS LADOS (target-driven)
    // Previne erro: "Cannot read properties of undefined (reading 'toFixed')"
    if (targetBands && Object.keys(targetBands).length > 0) {
        Object.keys(targetBands).forEach(targetKey => {
            try {
                // üõ°Ô∏è PROTE√á√ÉO #1: Verificar se target tem estrutura v√°lida
                const targetBand = targetBands[targetKey];
                if (!targetBand || typeof targetBand !== 'object') {
                    console.log(`[GENRE-TABLE] ‚è≠Ô∏è Pulando banda com target inv√°lido: ${targetKey}`);
                    return;
                }
                
                // üõ°Ô∏è PROTE√á√ÉO #2: Validar se existe valor target (range ou db)
                const hasRange = targetBand.target_range 
                    && (typeof targetBand.target_range.min === 'number' || typeof targetBand.target_range.min_db === 'number')
                    && (typeof targetBand.target_range.max === 'number' || typeof targetBand.target_range.max_db === 'number');
                const hasTargetDb = typeof targetBand.target_db === 'number';
                
                if (!hasRange && !hasTargetDb) {
                    console.log(`[GENRE-TABLE] ‚è≠Ô∏è Pulando banda sem target v√°lido: ${targetKey}`);
                    return;
                }
                
                // üîÑ NORMALIZAR nome da banda para buscar no userBands
                // targetKey j√° est√° normalizado (camelCase), procurar no userBands
                const bandData = userBands?.[targetKey];
                
                // üõ°Ô∏è PROTE√á√ÉO #3: Verificar se usu√°rio tem essa banda
                if (!bandData) {
                    console.log(`[GENRE-TABLE] ‚è≠Ô∏è Pulando banda sem dados do usu√°rio: ${targetKey}`);
                    return;
                }
                
                // üõ°Ô∏è PROTE√á√ÉO #4: Extrair valor num√©rico com fallbacks seguros
                let energyDb = null;
                if (typeof bandData === 'number') {
                    energyDb = bandData;
                } else if (typeof bandData === 'object') {
                    energyDb = bandData.energy_db ?? bandData.rms_db ?? bandData.db ?? null;
                }
                
                // üõ°Ô∏è PROTE√á√ÉO #5: Validar que energyDb √© n√∫mero finito
                if (!Number.isFinite(energyDb)) {
                    console.log(`[GENRE-TABLE] üîá Banda sem valor num√©rico v√°lido: ${targetKey} (valor: ${energyDb})`);
                    return;
                }
                
                // üéØ PRIORIZAR target_range (min/max) - IGNORAR tol_db
                const targetRange = hasRange ? targetBand.target_range : null;
                const targetValue = hasTargetDb ? targetBand.target_db : null;
                
                // ‚ö†Ô∏è N√ÉO USAR tol_db - apenas para compatibilidade com fallback legado
                // Range √© a toler√¢ncia quando existir
                
                // üßÆ Calcular severidade com suporte a range
                const result = calcSeverity(energyDb, targetValue, 2.0, { targetRange });
                
                // üõ°Ô∏è PROTE√á√ÉO #6: Validar resultado antes de usar
                if (!result || typeof result.diff !== 'number') {
                    console.warn(`[GENRE-TABLE] ‚ö†Ô∏è Resultado de severidade inv√°lido para: ${targetKey}`);
                    return;
                }
                
                // üé® Formatar coluna ALVO: mostrar range se existir, sen√£o target fixo
                let targetLabel;
                if (targetRange) {
                    // Suportar ambos formatos: { min, max } ou { min_db, max_db }
                    const minValue = targetRange.min ?? targetRange.min_db;
                    const maxValue = targetRange.max ?? targetRange.max_db;
                    const minSafe = Number.isFinite(minValue) ? minValue.toFixed(1) : '?';
                    const maxSafe = Number.isFinite(maxValue) ? maxValue.toFixed(1) : '?';
                    targetLabel = `${minSafe} dB a ${maxSafe} dB`;
                } else if (targetValue !== null) {
                    targetLabel = `${targetValue.toFixed(1)} dB`;
                } else {
                    targetLabel = '‚Äî';
                }
                
                const nomeAmigavel = nomesBandas[targetKey] || targetKey;
                
                // üõ°Ô∏è PROTE√á√ÉO #7: Usar valores seguros em .toFixed()
                const energyDbSafe = Number.isFinite(energyDb) ? energyDb.toFixed(2) : '‚Äî';
                const diffSafe = Number.isFinite(result.diff) ? result.diff.toFixed(2) : '0.00';
                const diffSign = result.diff >= 0 ? '+' : '';
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">${nomeAmigavel}</td>
                        <td class="metric-value">${energyDbSafe} dB</td>
                        <td class="metric-target">${targetLabel}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${diffSign}${diffSafe} dB</td>
                        <td class="metric-severity ${result.severityClass}">${result.severity}</td>
                        <td class="metric-action ${result.severityClass}">${result.action}</td>
                    </tr>
                `);
                bandsCount++;
                
                // Log mais informativo mostrando range quando dispon√≠vel
                const targetInfo = targetRange 
                    ? `[${(targetRange.min ?? targetRange.min_db).toFixed(1)}, ${(targetRange.max ?? targetRange.max_db).toFixed(1)}]` 
                    : (targetValue !== null ? targetValue.toFixed(1) : 'N/A');
                console.log(`[GENRE-TABLE] ‚úÖ ${nomeAmigavel}: ${energyDb.toFixed(2)} dB | Target: ${targetInfo} | ${result.severity}`);
                
            } catch (err) {
                // üõ°Ô∏è PROTE√á√ÉO #8: Capturar qualquer erro e continuar com pr√≥xima banda
                console.warn(`[GENRE-TABLE][SAFE-FAIL] Erro ao processar banda ${targetKey}:`, err.message);
                return; // Pular essa banda e continuar com as outras
            }
        });
    }
    
    // Renderizar HTML completo
    const tableHTML = `
        <div class="card genre-comparison-classic" style="margin-top:12px;">
            <div class="card-title">COMPARA√á√ÉO COM ${genre.toUpperCase()}</div>
            <table class="classic-genre-table">
                <thead>
                    <tr>
                        <th>M√©trica</th>
                        <th>Valor</th>
                        <th>Alvo</th>
                        <th>Diferen√ßa</th>
                        <th>Severidade</th>
                        <th>A√ß√£o Sugerida</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.join('')}
                </tbody>
            </table>
        </div>
    `;
    
    // üî• AUDITORIA CR√çTICA: Verificar container ANTES de inserir HTML
    console.log('[GENRE-TABLE-AUDIT] üîç ANTES de innerHTML:', {
        containerExists: !!container,
        containerVisible: container ? window.getComputedStyle(container).display : 'N/A',
        containerOpacity: container ? window.getComputedStyle(container).opacity : 'N/A',
        containerParent: container ? container.parentElement?.id : 'N/A',
        tableHTMLLength: tableHTML.length,
        rowsCount: rows.length
    });
    
    container.innerHTML = tableHTML;
    
    // üî• AUDITORIA CR√çTICA: Verificar container DEPOIS de inserir HTML
    console.log('[GENRE-TABLE-AUDIT] üîç DEPOIS de innerHTML:', {
        containerInnerHTMLLength: container.innerHTML.length,
        containerFirstChild: container.firstChild ? container.firstChild.className : 'N/A',
        tableExists: !!container.querySelector('.classic-genre-table'),
        rowsInDOM: container.querySelectorAll('tr').length
    });
    
    // For√ßar visibilidade
    container.classList.remove('hidden');
    container.style.display = 'block';
    container.style.visibility = 'visible';
    container.style.opacity = '1';
    
    // üî• AUDITORIA FINAL: Verificar visibilidade computada
    const computedStyle = window.getComputedStyle(container);
    console.log('[GENRE-TABLE-AUDIT] üîç VISIBILIDADE FINAL:', {
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        opacity: computedStyle.opacity,
        height: computedStyle.height,
        overflow: computedStyle.overflow
    });
    
    // üé® INJETAR ESTILOS CSS PARA TABELA CL√ÅSSICA DE G√äNERO (branch imersao)
    if (!document.getElementById('classicGenreTableStyles')) {
        const style = document.createElement('style');
        style.id = 'classicGenreTableStyles';
        style.textContent = `
            /* üéØ TABELA CL√ÅSSICA DE G√äNERO */
            .genre-comparison-classic {
                background: linear-gradient(135deg, rgba(14, 20, 34, 0.95), rgba(31, 43, 64, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 16px;
                padding: 24px;
                margin-top: 16px;
            }
            
            .classic-genre-table {
                width: 100%;
                border-collapse: collapse;
                font-size: 13px;
            }
            
            .classic-genre-table thead {
                background: rgba(0, 102, 255, 0.15);
                border-bottom: 2px solid rgba(36, 157, 255, 0.4);
            }
            
            .classic-genre-table th {
                font-weight: 600;
                padding: 12px 16px;
                text-align: center;
                font-size: 12px;
                color: #00f0ff;
                letter-spacing: 0.5px;
                text-transform: uppercase;
            }
            
            .classic-genre-table th:first-child {
                text-align: left;
            }
            
            .classic-genre-table td {
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                color: #f5f7fa;
                text-align: center;
            }
            
            .classic-genre-table td:first-child {
                text-align: left;
                font-weight: 500;
            }
            
            .classic-genre-table tr:last-child td {
                border-bottom: 0;
            }
            
            .classic-genre-table tbody tr:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            
            /* üé® CORES DE SEVERIDADE */
            .classic-genre-table .genre-row.ok {
                background: rgba(82, 247, 173, 0.08);
            }
            
            .classic-genre-table .genre-row.caution {
                background: rgba(255, 206, 77, 0.08);
            }
            
            .classic-genre-table .genre-row.warning {
                background: rgba(255, 165, 0, 0.08);
            }
            
            .classic-genre-table .genre-row.critical {
                background: rgba(255, 123, 123, 0.08);
            }
            
            .classic-genre-table .metric-severity.ok {
                color: #52f7ad;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.caution {
                color: #ffce4d;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.warning {
                color: #ffa500;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.critical {
                color: #ff7b7b;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-action {
                font-size: 12px;
            }
            
            .classic-genre-table .metric-diff.positive {
                color: #ffa500;
            }
            
            .classic-genre-table .metric-diff.negative {
                color: #00d4ff;
            }
            
            /* üéØ MOBILE RESPONSIVO - TABELA G√äNERO */
            @media (max-width: 768px) {
                .genre-comparison-classic {
                    padding: 12px !important;
                    border-radius: 12px !important;
                    overflow-x: hidden !important;
                }
                
                .classic-genre-table {
                    table-layout: fixed !important;
                    width: 100% !important;
                    font-size: 10px !important;
                    overflow-x: auto !important;
                    display: block !important;
                }
                
                .classic-genre-table thead,
                .classic-genre-table tbody,
                .classic-genre-table tr {
                    display: table !important;
                    width: 100% !important;
                    table-layout: fixed !important;
                }
                
                .classic-genre-table th {
                    padding: 8px 4px !important;
                    font-size: 9px !important;
                    letter-spacing: 0.3px !important;
                    line-height: 1.2 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table td {
                    padding: 8px 4px !important;
                    font-size: 10px !important;
                    line-height: 1.3 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table th:nth-child(1),
                .classic-genre-table td:nth-child(1) {
                    width: 22% !important;
                    text-align: left !important;
                }
                
                .classic-genre-table th:nth-child(2),
                .classic-genre-table td:nth-child(2),
                .classic-genre-table th:nth-child(3),
                .classic-genre-table td:nth-child(3),
                .classic-genre-table th:nth-child(4),
                .classic-genre-table td:nth-child(4) {
                    width: 14% !important;
                }
                
                .classic-genre-table th:nth-child(5),
                .classic-genre-table td:nth-child(5) {
                    width: 15% !important;
                }
                
                .classic-genre-table th:nth-child(6),
                .classic-genre-table td:nth-child(6) {
                    width: 21% !important;
                }
                
                .classic-genre-table td .icon,
                .classic-genre-table td i,
                .classic-genre-table td svg {
                    width: 12px !important;
                    height: 12px !important;
                    font-size: 12px !important;
                }
                
                .classic-genre-table .metric-severity {
                    font-size: 9px !important;
                    font-weight: 600 !important;
                }
                
                .classic-genre-table .metric-action {
                    font-size: 9px !important;
                }
                
                .classic-genre-table .metric-diff {
                    font-size: 9px !important;
                }
                
                .genre-comparison-classic .card-title {
                    font-size: 13px !important;
                    padding: 8px 0 !important;
                }
            }
        `;
        document.head.appendChild(style);
        console.log('[GENRE-TABLE] üé® Estilos CSS injetados');
    }
    
    console.log('[GENRE-TABLE] ‚úÖ Tabela COMPLETA renderizada:', {
        metricas: metricsCount,
        bandas: bandsCount,
        totalLinhas: rows.length
    });
    console.groupEnd();
}

// üéØ NOVO: Atualizar step ativo no modo refer√™ncia
function updateReferenceStep(step) {
    const steps = ['userAudio', 'referenceAudio', 'analysis'];
    const stepElements = {
        userAudio: document.getElementById('stepUserAudio'),
        referenceAudio: document.getElementById('stepReferenceAudio'),
        analysis: document.getElementById('stepAnalysis')
    };
    
    // Reset todos os steps
    Object.values(stepElements).forEach(el => {
        if (el) {
            el.classList.remove('active', 'completed');
        }
    });
    
    // Marcar steps anteriores como completed
    const currentIndex = steps.indexOf(step);
    for (let i = 0; i < currentIndex; i++) {
        const stepElement = stepElements[steps[i]];
        if (stepElement) {
            stepElement.classList.add('completed');
        }
    }
    
    // Marcar step atual como active
    const currentElement = stepElements[step];
    if (currentElement) {
        currentElement.classList.add('active');
    }
    
    referenceStepState.currentStep = step;
    
    window.logReferenceEvent('reference_step_updated', { step, currentIndex });
}

// ‚ùå Fechar modal de an√°lise de √°udio
function closeAudioModal() {
    __dbg('‚ùå Fechando modal de an√°lise de √°udio...');
    
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        currentModalAnalysis = null;
        resetModalState();
        
        // üîß CORRE√á√ÉO: Garantir que o modal pode ser usado novamente
        // Limpar cache de arquivos para for√ßar novo processamento
        const fileInput = document.getElementById('modalAudioFileInput');
        if (fileInput) {
            fileInput.value = ''; // Limpar input para permitir re-sele√ß√£o do mesmo arquivo
        }
        
        // Resetar flags globais para pr√≥xima an√°lise
        if (typeof window !== 'undefined') {
            delete window.__AUDIO_ADVANCED_READY__;
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        
        // üîß FIX: Verificar se h√° compara√ß√£o ativa antes de limpar
        const hasActiveComparison = window.__referenceComparisonActive === true;
        
        // üö® BLINDAGEM: N√ÉO limpar FirstAnalysisStore em modo genre
        const isGenreMode = window.__CURRENT_MODE__ === 'genre';
        
        if (!hasActiveComparison && !isGenreMode) {
            // üßπ LIMPEZA COMPLETA: Apenas se n√£o houver compara√ß√£o ativa E n√£o for modo genre
            // üîí HARD-GUARD: Limpar FirstAnalysisStore (√∫nica fonte de verdade)
            FirstAnalysisStore.clear();
            
            // ‚ùå REMOVER: window.referenceAnalysisData agora √© read-only (n√£o pode ser setado)
            // Ele sempre aponta para FirstAnalysisStore.get(), que acabamos de limpar
            
            // Limpar Mode Engine
            SOUNDY_MODE_ENGINE.clear();
            
            referenceComparisonMetrics = null;
            window.lastReferenceJobId = null;
            
            // Limpar IDs de refer√™ncia
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            
            console.log('[CLEANUP] closeAudioModal: LIMPEZA TOTAL (sem compara√ß√£o ativa)');
            console.log('[CLEANUP] FirstAnalysisStore limpo - window.referenceAnalysisData agora retorna null');
        } else if (isGenreMode) {
            // Preservar g√™nero em modo genre
            console.log('[CLEANUP] closeAudioModal: PRESERVANDO g√™nero (modo genre)');
            console.log('[GENRE-PROTECT] ‚ö†Ô∏è Limpeza FirstAnalysisStore BLOQUEADA em modo genre');
            console.log('[GENRE-PROTECT]   - Preservando:', {
                selectedGenre: window.__CURRENT_SELECTED_GENRE,
                mode: window.__CURRENT_MODE__
            });
        } else {
            // Preservar dados de refer√™ncia
            console.log('[CLEANUP] closeAudioModal: PRESERVANDO refer√™ncia (compara√ß√£o ativa)');
            console.log('[CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
            console.log('[CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
        }
        
        // Limpeza de state global (sempre limpar estado tempor√°rio de renderiza√ß√£o)
        const state = window.__soundyState || {};
        if (state.reference) {
            state.reference.analysis = null;
            state.reference.isSecondTrack = false;
            // N√ÉO limpar jobId se houver compara√ß√£o ativa
            if (!hasActiveComparison) {
                state.reference.jobId = null;
                state.reference.userAnalysis = null;
                state.reference.referenceAnalysis = null;
            }
        }
        
        // Limpar an√°lises tempor√°rias mas preservar previousAnalysis se necess√°rio
        state.userAnalysis = null;
        state.referenceAnalysis = null;
        if (!hasActiveComparison) {
            state.previousAnalysis = null;
        }
        
        state.render = state.render || {};
        state.render.mode = null;
        
        window.__soundyState = state;
        
        __dbg('‚úÖ Modal resetado e pronto para pr√≥xima an√°lise');
    }
}

// üîÑ Reset estado do modal
/**
 * üÜï NOVA FUN√á√ÉO: Limpa APENAS estado visual de upload
 * N√ÉO toca em g√™nero, targets ou localStorage
 * Usada ao abrir modal de an√°lise (preserva sele√ß√£o de g√™nero)
 */
function clearAudioOnlyState() {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    const fileInput = document.getElementById('modalAudioFileInput');

    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    if (fileInput) fileInput.value = '';

    console.log('[AUDIO-RESET] ‚úÖ Apenas estado de √°udio foi limpo (g√™nero preservado)');
    console.log('[AUDIO-RESET] üìä G√™nero mantido:', {
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE,
        __CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        hasTargets: !!window.__activeRefData
    });
}

function resetModalState() {
    __dbg('üîÑ Resetando estado do modal...');
    
    // üö® BLINDAGEM ABSOLUTA: NUNCA resetar em modo genre
    if (window.__CURRENT_MODE__ === 'genre') {
        console.warn('[GENRE-PROTECT] ‚ö†Ô∏è resetModalState() BLOQUEADO em modo genre');
        console.warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        return; // N√ÉO executar reset
    }
    
    // üîí PATCH: PRESERVAR G√äNERO ANTES DE QUALQUER OPERA√á√ÉO
    preserveGenreState();
    
    // ===============================================================
    // üîí BLOCO 1 ‚Äî PRESERVAR G√äNERO ANTES DO RESET
    // ===============================================================
    let __PRESERVED_GENRE__ = null;
    let __PRESERVED_TARGETS__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ =
            window.__CURRENT_SELECTED_GENRE ||
            window.PROD_AI_REF_GENRE ||
            (genreSelect ? genreSelect.value : null);
        
        __PRESERVED_TARGETS__ =
            window.__CURRENT_GENRE_TARGETS ||
            window.currentGenreTargets ||
            window.__activeRefData?.targets;

        console.log("[SAFE-RESET] ‚ö†Ô∏è Preservando g√™nero selecionado:", __PRESERVED_GENRE__);
        console.log("[SAFE-RESET] ‚ö†Ô∏è Preservando targets:", __PRESERVED_TARGETS__ ? Object.keys(__PRESERVED_TARGETS__) : 'null');
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao capturar g√™nero antes do reset:", e);
    }
    
    // Mostrar √°rea de upload
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    // Reset progress
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    currentModalAnalysis = null;
    
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';
    
    // üß© CORRE√á√ÉO #4: Reset completo de estado (limpeza total)
    const state = window.__soundyState || {};
    
    // Limpar completamente estado de refer√™ncia
    state.reference = null;
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    // Limpar modo de renderiza√ß√£o
    if (!state.render) state.render = {};
    state.render.mode = null;
    
    window.__soundyState = state;
    
    // üî• FIX-REFERENCE: Verificar se estamos aguardando segunda m√∫sica ANTES de limpar
    const isAwaitingSecondTrack = currentAnalysisMode === 'reference' && window.__REFERENCE_JOB_ID__;
    
    console.log('[FIX_REFID_RESET] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`[FIX_REFID_RESET] Mode atual: ${currentAnalysisMode}`);
    console.log(`[FIX_REFID_RESET] Reference Job ID existe: ${window.__REFERENCE_JOB_ID__ ? 'SIM' : 'N√ÉO'}`);
    console.log(`[FIX_REFID_RESET] Aguardando segunda m√∫sica: ${isAwaitingSecondTrack ? 'SIM' : 'N√ÉO'}`);

    if (!isAwaitingSecondTrack) {
        // üßº LIMPEZA COMPLETA: S√≥ limpar se N√ÉO estivermos aguardando segunda m√∫sica
        SOUNDY_MODE_ENGINE.clear();
        window.__REFERENCE_JOB_ID__ = null;
        window.referenceComparisonMetrics = null;
        window.lastReferenceJobId = null;
        delete window.__REFERENCE_JOB_ID__;
        localStorage.removeItem('referenceJobId');
        
        // ‚úÖ LIMPAR FirstAnalysisStore
        FirstAnalysisStore.clear();
        
        console.log('[FIX_REFID_RESET] Estado limpo completamente ‚úÖ');
        console.log('[FIX_REFID_RESET] Limpeza incluiu: window, localStorage e estado global');
        console.log('[FIX_REFID_RESET] Flags de refer√™ncia LIMPAS (modo n√£o-reference)');
    } else {
        // Preservar IDs de refer√™ncia para segunda m√∫sica
        console.log('[FIX_REFID_RESET] ‚ö†Ô∏è PRESERVANDO flags de refer√™ncia!');
        console.log(`[FIX_REFID_RESET] Reference Job ID mantido: ${window.__REFERENCE_JOB_ID__}`);
        console.log(`[FIX_REFID_RESET] localStorage.referenceJobId: ${localStorage.getItem('referenceJobId')}`);
        console.log('[FIX_REFID_RESET] Aguardando upload da segunda m√∫sica...');
    }
    console.log('[FIX_REFID_RESET] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    // Flags internas
    delete window.__AUDIO_ADVANCED_READY__;
    delete window.__MODAL_ANALYSIS_IN_PROGRESS__;    console.log('[CLEANUP] resetModalState: estado global/flags limpos');
    
    // ===============================================================
    // üîí BLOCO 3 ‚Äî RESTAURAR G√äNERO E TARGETS AP√ìS O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            console.log("[SAFE-RESET] ‚úÖ G√™nero restaurado ap√≥s reset:", __PRESERVED_GENRE__);
        } else {
            console.warn("[SAFE-RESET] ‚ö†Ô∏è Nenhum g√™nero v√°lido preservado.");
        }
        
        // üîí PATCH: RESTAURAR TARGETS TAMB√âM
        if (__PRESERVED_TARGETS__) {
            window.__CURRENT_GENRE_TARGETS = __PRESERVED_TARGETS__;
            window.currentGenreTargets = __PRESERVED_TARGETS__;
            console.log("[SAFE-RESET] ‚úÖ Targets restaurados ap√≥s reset:", Object.keys(__PRESERVED_TARGETS__));
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar g√™nero:", e);
    }
    
    __dbg('‚úÖ Estado do modal resetado completamente');
}

// ‚öôÔ∏è Configurar modal de √°udio
function setupAudioModal() {
    const modal = document.getElementById('audioAnalysisModal');
    const fileInput = document.getElementById('modalAudioFileInput');
    const uploadArea = document.getElementById('audioUploadArea');
    
    if (!modal || !fileInput || !uploadArea) {
        __dwrn('‚ö†Ô∏è Elementos do modal n√£o encontrados');
        return;
    }
    
    // Fechar modal clicando fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeAudioModal();
        }
    });
    
    // Fechar modal com ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeAudioModal();
        }
    });
    
    // Detectar se √© dispositivo m√≥vel
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (!isMobile) {
        // Drag and Drop (apenas para desktop)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleModalFileSelection(files[0]);
            }
        });
    }
    
    // File input change event
    fileInput.addEventListener('change', (e) => {
        __dbg('üìÅ File input change triggered');
        if (e.target.files.length > 0) {
            __dbg('üìÅ File selected:', e.target.files[0].name);
            handleModalFileSelection(e.target.files[0]);
        }
    });
    
    // N√£o adicionar nenhum listener JS ao bot√£o/label de upload!
    uploadArea.onclick = null;
    
    __dbg('‚úÖ Modal de √°udio configurado com sucesso');
}

// üìÅ Processar arquivo selecionado no modal
async function handleModalFileSelection(file) {
    __dbg('üìÅ Arquivo selecionado no modal:', file.name);
    
    // ========================================
    // üîí DECLARA√á√ÉO DE ESCOPO GLOBAL: normalizedFirst
    // ========================================
    // Garantir que normalizedFirst sempre exista no escopo da fun√ß√£o
    let normalizedFirst = window.__FIRST_ANALYSIS_FROZEN__ 
        ? structuredClone(window.__FIRST_ANALYSIS_FROZEN__) 
        : null;
    
    // üîß CORRE√á√ÉO: Prevenir m√∫ltiplas an√°lises simult√¢neas
    if (typeof window !== 'undefined' && window.__MODAL_ANALYSIS_IN_PROGRESS__) {
        __dbg('‚ö†Ô∏è An√°lise j√° em progresso, ignorando nova sele√ß√£o');
        return;
    }
    
    try {
        // Marcar an√°lise em progresso
        if (typeof window !== 'undefined') {
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = true;
        }
        
        // Valida√ß√£o comum de arquivo
        if (!validateAudioFile(file)) {
            return; // validateAudioFile j√° mostra erro
        }
        
        // üåê NOVO FLUXO COMPLETO: Presigned URL ‚Üí Upload ‚Üí Job Creation ‚Üí Polling
        __dbg('üåê Iniciando fluxo de an√°lise remota completo...');
        
        // Mostrar loading
        hideUploadArea();
        showAnalysisLoading();
        showUploadProgress(`Preparando upload de ${file.name}...`);
        
        // üåê ETAPA 1: Obter URL pr√©-assinada
        const { uploadUrl, fileKey } = await getPresignedUrl(file);
        
        // üåê ETAPA 2: Upload direto para bucket
        await uploadToBucket(uploadUrl, file);
        
        // üåê ETAPA 3: Criar job de an√°lise no backend
        const { jobId } = await createAnalysisJob(fileKey, currentAnalysisMode, file.name);
        
        // üåê ETAPA 4: Acompanhar progresso e aguardar resultado
        showUploadProgress(`Analisando ${file.name}... Aguarde.`);
        const analysisResult = await pollJobStatus(jobId);
        
        // üåê ETAPA 5: Processar resultado baseado no modo e contexto
        // üéØ FLUXO CORRIGIDO: Identificar se √© primeira ou segunda m√∫sica
        const jobMode = analysisResult.mode || currentAnalysisMode;
        const isSecondTrack = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
        
        // üîç AUDITORIA: Estado ANTES de processar resultado
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] üìå handleModalFileSelection - IN√çCIO');
        console.log('‚öôÔ∏è Fun√ß√£o: handleModalFileSelection');
        console.log('üìÅ Arquivo:', file.name);
        console.log('üéØ Modo atual:', currentAnalysisMode);
        console.log('üîë jobId retornado:', jobId);
        console.log('üìä analysisResult recebido:', {
            jobId: analysisResult?.jobId,
            fileName: analysisResult?.fileName || analysisResult?.metadata?.fileName,
            lufs: analysisResult?.technicalData?.lufsIntegrated,
            mode: analysisResult?.mode
        });
        console.log('üåê Estado global ANTES de processar:');
        console.log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        const firstAnalysis = FirstAnalysisStore.get();
        console.log('  FirstAnalysisStore:', firstAnalysis ? {
            fileName: firstAnalysis?.fileName || firstAnalysis?.metadata?.fileName,
            jobId: firstAnalysis?.jobId
        } : 'null');
        console.log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
            fileName: window.__soundyState.previousAnalysis?.fileName || window.__soundyState.previousAnalysis?.metadata?.fileName,
            jobId: window.__soundyState.previousAnalysis?.jobId
        } : 'null');
        console.groupEnd();
        
        console.log('[AUDIO-DEBUG] üéØ Modo do job:', jobMode);
        console.log('[AUDIO-DEBUG] üéØ √â segunda faixa?', isSecondTrack);
        console.log('[AUDIO-DEBUG] üéØ Reference Job ID armazenado:', window.__REFERENCE_JOB_ID__);
        console.log('[AUDIO-DEBUG] üéØ FirstAnalysisStore:', FirstAnalysisStore.has());
        console.log('[AUDIO-DEBUG] üéØ Current mode:', currentAnalysisMode);
        
        // üîß FIX: Primeira m√∫sica vem como "genre" (modo base), segunda como "reference"
        const isFirstReferenceTrack = currentAnalysisMode === 'reference' && !isSecondTrack;
        
        if (isFirstReferenceTrack) {
            // PRIMEIRA m√∫sica em modo reference: abrir modal para m√∫sica de refer√™ncia
            __dbg('üéØ Primeira m√∫sica analisada - abrindo modal para segunda');
            
            // ========================================
            // üîí SALVAR PRIMEIRA AN√ÅLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel USER
            const { vid: userVid, clone: userClone } = cacheResultByRole(analysisResult, { isSecondTrack: false });
            
            // üíæ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveFirstAnalysis(userClone || analysisResult);
            
            // Atualizar normalizedFirst para uso nos logs e modal
            if (!normalizedFirst && userClone) {
                normalizedFirst = userClone;
                window.__FIRST_ANALYSIS_FROZEN__ = structuredClone(normalizedFirst); // Mantido para compatibilidade
                console.log('[SCOPE] ‚úÖ normalizedFirst inicializado com userClone');
            }
            
            if (!window.FirstAnalysisStore?.has()) {
                // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: N√£o salvar como refer√™ncia se modo n√£o foi selecionado explicitamente
                if (!userExplicitlySelectedReferenceMode) {
                    console.warn('%c[PROTECTION] ‚ö†Ô∏è BLOQUEIO: Tentativa de salvar __REFERENCE_JOB_ID__ mas userExplicitlySelectedReferenceMode = false', 'color:#FFA500;font-weight:bold;');
                    console.warn('[PROTECTION] ‚ö†Ô∏è Sistema em modo genre - ignorando salvamento de refer√™ncia');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // N√ÉO executar salvamento de refer√™ncia
                } else {
                    // Salvar como USER no FirstAnalysisStore
                    FirstAnalysisStore.setUser(userClone, userVid, analysisResult.jobId);
                    window.__REFERENCE_JOB_ID__ = analysisResult.jobId;
                    
                    console.log('[A/B] üßä primeira faixa salva com VID', {
                        vid: userVid,
                        jobId: analysisResult.jobId, 
                        file: userClone?.fileName || userClone?.metadata?.fileName,
                        role: 'USER'
                    });
                    console.log('%c[PROTECTION] ‚úÖ __REFERENCE_JOB_ID__ definido - flag verificada', 'color:#00FF88;font-weight:bold;');
                }
            }
            
            // üîç AUDITORIA: Estado AP√ìS salvar primeira an√°lise
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] üíæ Primeira An√°lise SALVA');
            console.log('‚öôÔ∏è Contexto: Salvamento da primeira faixa');
            console.log('üìä analysisResult (original):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const storedFirst = FirstAnalysisStore.get();
            console.log('üîí FirstAnalysisStore (clone):', {
                jobId: storedFirst?.jobId,
                fileName: storedFirst?.metadata?.fileName || storedFirst?.fileName,
                lufs: storedFirst?.technicalData?.lufsIntegrated,
                sameAsOriginal: false // sempre retorna clone
            });
            console.log('üí° Verifica√ß√£o de isolamento:');
            console.log('  FirstAnalysisStore.get() !== analysisResult?', storedFirst !== analysisResult);
            console.log('  FirstAnalysisStore retorna clones:', true);
            console.groupEnd();
            
            // ========================================
            // üõ°Ô∏è VALIDA√á√ÉO: Garantir que normalizedFirst existe
            // ========================================
            if (!normalizedFirst) {
                console.warn('[WARN] normalizedFirst ausente ‚Äî usando fallback do FirstAnalysisStore.');
                normalizedFirst = structuredClone(FirstAnalysisStore.getUser() || {});
            }
            
            console.log('[REF-SAVE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('[REF-SAVE ‚úÖ] Primeira m√∫sica processada com sucesso!');
            console.log(`[REF-SAVE ‚úÖ] Job ID salvo globalmente: ${normalizedFirst?.jobId || 'unknown'}`);
            console.log('[REF-SAVE ‚úÖ] Locais de salvamento:');
            console.log('[REF-SAVE ‚úÖ]   - window.__REFERENCE_JOB_ID__');
            console.log('[REF-SAVE ‚úÖ]   - localStorage.referenceJobId');
            console.log('[REF-SAVE ‚úÖ]   - window.AnalysisCache (imut√°vel)');
            console.log('[REF-SAVE ‚úÖ]   - window.FirstAnalysisStore (imut√°vel + clonagem autom√°tica)');
            console.log(`[REF-SAVE ‚úÖ] File Name: ${normalizedFirst?.metadata?.fileName || normalizedFirst?.fileName || 'unknown'}`);
            console.log(`[REF-SAVE ‚úÖ] LUFS: ${normalizedFirst?.technicalData?.lufsIntegrated || 'N/A'} LUFS`);
            console.log(`[REF-SAVE ‚úÖ] DR: ${normalizedFirst?.technicalData?.dynamicRange || 'N/A'} dB`);
            console.log('[REF-SAVE ‚úÖ] Este ID ser√° usado na segunda m√∫sica');
            console.log('[REF-SAVE ‚úÖ] Primeira an√°lise salva e congelada.');
            console.log('[REF-SAVE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            if (normalizedFirst && normalizedFirst.jobId) {
                openReferenceUploadModal(normalizedFirst.jobId, normalizedFirst);
            } else {
                console.error('[ERROR] ‚ùå N√£o foi poss√≠vel abrir modal: normalizedFirst inv√°lido');
            }
        } else if (isSecondTrack) {
            // üî• FOR√áAR: Se tem jobId de refer√™ncia, SEMPRE tratar como segunda track
            console.log('üü¢üü¢üü¢ [SEGUNDA-TRACK-DETECTADA-FORCE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üü¢ [FORCE] isSecondTrack TRUE - entrando em bloco A/B');
            console.log('üü¢ [FORCE] jobMode (pode ser null):', jobMode);
            console.log('üü¢ [FORCE] currentAnalysisMode (pode ser genre):', currentAnalysisMode);
            console.log('üü¢ [FORCE] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('üü¢ [FORCE] IGNORANDO jobMode - usando APENAS isSecondTrack como crit√©rio');
            console.log('üü¢üü¢üü¢ [SEGUNDA-TRACK-DETECTADA-FORCE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            // SEGUNDA m√∫sica em modo reference: mostrar resultado comparativo
            console.log('üü¢ [SEGUNDA-TRACK] ‚úÖ Sistema ENTROU no bloco de segunda track!');
            console.log('üü¢ [SEGUNDA-TRACK] jobMode:', jobMode);
            console.log('üü¢ [SEGUNDA-TRACK] currentAnalysisMode:', currentAnalysisMode);
            console.log('üü¢ [SEGUNDA-TRACK] isSecondTrack:', isSecondTrack);
            console.log('üü¢ [SEGUNDA-TRACK] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('üü¢ [SEGUNDA-TRACK] analysisResult.jobId:', analysisResult?.jobId);
            console.log('üü¢ [SEGUNDA-TRACK] Aguardando processamento... (se n√£o aparecer erro abaixo, fluxo est√° correto)');
            console.log('üü¢üü¢üü¢ [SEGUNDA-TRACK-DETECTADA] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üéØ [COMPARE-MODE] Segunda m√∫sica analisada - exibindo compara√ß√£o entre faixas');
            console.log('‚úÖ [COMPARE-MODE] Tabela comparativa ser√° exibida');
            console.log(`‚úÖ [COMPARE-MODE] jobMode: ${jobMode}, currentMode: ${currentAnalysisMode}, isSecond: ${isSecondTrack}`);
            __dbg('üéØ Segunda m√∫sica analisada - exibindo resultado comparativo');
            
            // ========================================
            // üîí SALVAR SEGUNDA AN√ÅLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel REF
            const { vid: refVid, clone: refClone } = cacheResultByRole(analysisResult, { isSecondTrack: true });
            
            // üíæ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveSecondAnalysis(refClone || analysisResult);
            
            // Salvar como REF no FirstAnalysisStore (mantido para compatibilidade)
            FirstAnalysisStore.setRef(refClone, refVid, analysisResult.jobId);
            
            console.log('[A/B] üßä segunda faixa salva com VID', {
                vid: refVid,
                jobId: analysisResult.jobId,
                file: refClone?.fileName || refClone?.metadata?.fileName,
                role: 'REF'
            });
            
            // ÔøΩ AUDITORIA: Estado ANTES de construir estrutura A/B
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] üéØ Segunda An√°lise RECEBIDA');
            console.log('‚öôÔ∏è Contexto: Recep√ß√£o da segunda faixa');
            console.log('üìä analysisResult (2¬™ faixa):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const frozenFirst = FirstAnalysisStore.get();
            console.log('üîí FirstAnalysisStore (1¬™ faixa congelada):', {
                jobId: frozenFirst?.jobId,
                fileName: frozenFirst?.metadata?.fileName,
                lufs: frozenFirst?.technicalData?.lufsIntegrated
            });
            console.log('üíæ window.__soundyState.previousAnalysis (1¬™ faixa):', {
                jobId: window.__soundyState?.previousAnalysis?.jobId,
                fileName: window.__soundyState?.previousAnalysis?.metadata?.fileName,
                lufs: window.__soundyState?.previousAnalysis?.technicalData?.lufsIntegrated,
                objectId: window.__soundyState?.previousAnalysis
            });
            console.log('‚ö†Ô∏è CHECKPOINT CR√çTICO: Verificar se objetos s√£o distintos');
            console.log('  analysisResult !== previousAnalysis?', analysisResult !== window.__soundyState?.previousAnalysis);
            console.log('  analysisResult !== FirstAnalysisStore?', analysisResult !== FirstAnalysisStore.get());
            console.groupEnd();
            
            // ÔøΩüî• CORRE√á√ÉO CR√çTICA: Primeira m√∫sica √© ATUAL (sua faixa), segunda √© REFER√äNCIA (alvo)
            const state = window.__soundyState || {};
            
            // üßä PROTE√á√ÉO ANTIFALSA ATUALIZA√á√ÉO DA REFER√äNCIA
            if (state?.render?.mode === 'reference' && window.__FIRST_ANALYSIS_FROZEN__) {
                console.warn('[STATE-FIX] üîí Bloqueando sobrescrita de refer√™ncia - usando c√≥pia congelada');
                console.warn('[STATE-FIX]   __FIRST_ANALYSIS_FROZEN__:', window.__FIRST_ANALYSIS_FROZEN__?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
                console.warn('[STATE-FIX]   analysisResult (2¬™ faixa):', analysisResult?.fileName || analysisResult?.metadata?.fileName);
                
                // Garantir que previousAnalysis aponte para o frozen
                if (!state.previousAnalysis || state.previousAnalysis.jobId === analysisResult.jobId) {
                    console.warn('[STATE-FIX] ‚ö†Ô∏è Corrigindo previousAnalysis contaminado');
                    state.previousAnalysis = JSON.parse(JSON.stringify(window.__FIRST_ANALYSIS_FROZEN__));
                }
            }
            
            if (state.previousAnalysis) {
                // ‚úÖ SEM√ÇNTICA CORRETA DO FLUXO A/B:
                // - Primeira faixa (previousAnalysis) = userAnalysis (SUA M√öSICA/ATUAL)
                // - Segunda faixa (analysisResult) = referenceAnalysis (ALVO/REFER√äNCIA a alcan√ßar)
                
                // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: N√£o permitir isSecondTrack = true se usu√°rio n√£o selecionou modo reference
                if (!userExplicitlySelectedReferenceMode) {
                    console.error('%c[PROTECTION] ‚ùå BLOQUEIO CR√çTICO: Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    console.error('[PROTECTION] ‚ùå Sistema em modo genre - N√ÉO pode processar segunda track');
                    console.error('[PROTECTION] ‚ùå state.previousAnalysis existe mas modo n√£o √© reference expl√≠cito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // N√ÉO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // üßä PROTE√á√ÉO ANTICONTAMINA√á√ÉO: Deep clone obrigat√≥rio
                console.log('[STATE-FIX] üîí Criando deep clones para evitar contamina√ß√£o de estado');
                state.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));      // 1¬™ = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));         // 2¬™ = faixa de refer√™ncia (alvo)
                
                // üéØ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));    // 1¬™ faixa (sua m√∫sica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));       // 2¬™ faixa (refer√™ncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('%c[PROTECTION] ‚úÖ isSecondTrack = true PERMITIDO - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] Atribui√ß√£o correta A/B:');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   1¬™ Faixa (ATUAL/SUA M√öSICA):', state.previousAnalysis.fileName || state.previousAnalysis.metadata?.fileName || '1¬™ Faixa');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   2¬™ Faixa (REFER√äNCIA/ALVO):', analysisResult.fileName || analysisResult.metadata?.fileName || '2¬™ Faixa');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   Compara√ß√£o: SUA M√öSICA vs REFER√äNCIA');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   Modal mostrar√°: ESQUERDA=sua m√∫sica, DIREITA=refer√™ncia');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   1¬™ tem bandas:', !!state.userAnalysis?.technicalData?.spectral_balance);
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   2¬™ tem bandas:', !!state.referenceAnalysis?.technicalData?.spectral_balance);
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // üîç AUDITORIA: Estado AP√ìS construir estrutura A/B
                console.groupCollapsed('[AUDITORIA_STATE_FLOW] üîß Estrutura A/B CONSTRU√çDA');
                console.log('‚öôÔ∏è Contexto: Estrutura state.reference montada');
                console.log('üìä state.userAnalysis (1¬™ faixa - SUA M√öSICA):', {
                    jobId: state.userAnalysis?.jobId,
                    fileName: state.userAnalysis?.metadata?.fileName || state.userAnalysis?.fileName,
                    lufs: state.userAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.userAnalysis
                });
                console.log('üìä state.referenceAnalysis (2¬™ faixa - REFER√äNCIA):', {
                    jobId: state.referenceAnalysis?.jobId,
                    fileName: state.referenceAnalysis?.metadata?.fileName || state.referenceAnalysis?.fileName,
                    lufs: state.referenceAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.referenceAnalysis
                });
                console.log('‚ö†Ô∏è VERIFICA√á√ÉO DE CONTAMINA√á√ÉO:');
                console.log('  state.userAnalysis === state.referenceAnalysis?', state.userAnalysis === state.referenceAnalysis);
                console.log('  state.userAnalysis === analysisResult?', state.userAnalysis === analysisResult);
                console.log('  state.userAnalysis === state.previousAnalysis?', state.userAnalysis === state.previousAnalysis);
                console.log('  state.referenceAnalysis === analysisResult?', state.referenceAnalysis === analysisResult);
                console.log('üí° Pr√≥ximo passo: Normalizar analysisResult antes de enviar para displayModalResults');
                console.groupEnd();
                
                // üéØ LOG AUDIT-MODE-FLOW (conforme solicitado)
                console.log('[AUDIT-MODE-FLOW]', {
                    mode: 'reference',
                    isSecondTrack: state.reference.isSecondTrack,
                    refJobId: state.reference.jobId,
                    hasUserAnalysis: !!state.userAnalysis,
                    hasReferenceAnalysis: !!state.referenceAnalysis
                });
                
                // üéØ LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            } else if (FirstAnalysisStore.has()) {
                // üî• FALLBACK: Primeira m√∫sica √© ATUAL (sua faixa), segunda √© REFER√äNCIA (alvo)
                const firstAnalysis = FirstAnalysisStore.get(); // sempre clone
                
                // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: N√£o permitir isSecondTrack = true se usu√°rio n√£o selecionou modo reference
                if (!userExplicitlySelectedReferenceMode) {
                    console.error('%c[PROTECTION] ‚ùå BLOQUEIO CR√çTICO (FALLBACK): Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    console.error('[PROTECTION] ‚ùå Sistema em modo genre - N√ÉO pode processar segunda track');
                    console.error('[PROTECTION] ‚ùå FirstAnalysisStore.has() = true mas modo n√£o √© reference expl√≠cito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // N√ÉO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // üßä PROTE√á√ÉO ANTICONTAMINA√á√ÉO: Deep clone obrigat√≥rio
                console.log('[STATE-FIX] üîí FALLBACK - Criando deep clones para evitar contamina√ß√£o');
                state.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));    // 1¬™ = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                 // 2¬™ = refer√™ncia (alvo)
                
                // üéØ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));  // 1¬™ faixa (sua m√∫sica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                // 2¬™ faixa (refer√™ncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('%c[PROTECTION] ‚úÖ isSecondTrack = true PERMITIDO (FALLBACK) - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] Fallback - Atribui√ß√£o correta A/B:');
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   1¬™ Faixa (ATUAL/SUA M√öSICA):', firstAnalysis?.fileName);
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED]   2¬™ Faixa (REFER√äNCIA/ALVO):', analysisResult.fileName);
                console.log('‚úÖ [REFERENCE-A/B-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // üéØ LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userTrack: state.userAnalysis?.fileName || 'Sua m√∫sica (atual)',
                    referenceTrack: state.referenceAnalysis?.fileName || 'Faixa de refer√™ncia (alvo)',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            }
            
            // üö® AUDIT_REF_FIX: N√ÉO chamar handleGenreAnalysisWithResult em modo reference!
            // Esta fun√ß√£o limpa o estado e for√ßa mode='genre', quebrando o fluxo A/B
            
            // PRESERVAR modo reference at√© o final (reutilizar state j√° declarado acima)
            if (!state.render) state.render = {};
            state.render.mode = 'reference';
            window.__soundyState = state;
            
            console.log('[AUDIT_REF_FIX] Preservando modo reference at√© final da renderiza√ß√£o');
            console.log('[MODE LOCKED] reference - handleGenreAnalysisWithResult PULADO');
            
            // üîç AUDITORIA: Estado ANTES de normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚öôÔ∏è ANTES de normalizeBackendAnalysisData');
            console.log('‚öôÔ∏è Contexto: Prestes a normalizar analysisResult (2¬™ faixa)');
            console.log('üìä analysisResult (ANTES de normalizar):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const checkFirst = FirstAnalysisStore.get();
            console.log('üîí FirstAnalysisStore (N√ÉO deve mudar):', {
                jobId: checkFirst?.jobId,
                fileName: checkFirst?.metadata?.fileName,
                lufs: checkFirst?.technicalData?.lufsIntegrated
            });
            console.log('‚ö†Ô∏è PONTO CR√çTICO: normalizeBackendAnalysisData() vai modificar analysisResult?');
            console.groupEnd();
            
            // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
            // ‚ùå REMOVIDO: normalizeBackendAnalysisData() destr√≥i dados
            const normalizedResult = analysisResult; // ‚úÖ LEITURA DIRETA
            
            // üîí POPULAR CACHE COM RESULTADO DIRETO
            AnalysisCache.put(normalizedResult);
            
            // üîçüîç AUDITORIA: Estado AP√ìS normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚úÖ DEPOIS de normalizeBackendAnalysisData');
            console.log('‚öôÔ∏è Contexto: Normaliza√ß√£o conclu√≠da');
            console.log('üìä normalizedResult (resultado da normaliza√ß√£o):', {
                jobId: normalizedResult?.jobId,
                fileName: normalizedResult?.metadata?.fileName || normalizedResult?.fileName,
                lufs: normalizedResult?.technicalData?.lufsIntegrated,
                objectId: normalizedResult,
                sameAsOriginal: normalizedResult === analysisResult
            });
            console.log('üìä analysisResult (AP√ìS normaliza√ß√£o - pode ter mudado?):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            console.log('üîí window.__FIRST_ANALYSIS_FROZEN__ (deve estar INTACTO):', {
                jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
                fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
                lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
                isFrozen: Object.isFrozen(window.__FIRST_ANALYSIS_FROZEN__)
            });
            console.log('üí° Pr√≥ximo: Enviar normalizedResult para displayModalResults()');
            console.groupEnd();
            
            // ÔøΩ PARTE 3.4: Garantir atribui√ß√£o correta ANTES de displayModalResults
            // üîß PARTE 1: Normalize reference comparison structure
            if (state.render.mode === "reference" && analysisResult && state.previousAnalysis) {
                // üßä PROTE√á√ÉO ANTICONTAMINA√á√ÉO: Deep clone para evitar muta√ß√£o
                console.log('[STATE-FIX] üîí Normalizando com deep clones');
                const firstResult = JSON.parse(JSON.stringify(state.previousAnalysis));
                const secondResult = JSON.parse(JSON.stringify(analysisResult));

                const normalizedUser = {
                    fileName: firstResult.fileName || firstResult.metadata?.fileName,
                    bands: firstResult.spectralBands || firstResult.bands || firstResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: firstResult.loudness?.integrated ?? firstResult.lufsIntegrated,
                        dr: firstResult.dynamics?.dr ?? firstResult.dynamicRange,
                        peak: firstResult.truePeak?.dbtp ?? firstResult.truePeakDbtp
                    }
                };

                const normalizedRef = {
                    fileName: secondResult.fileName || secondResult.metadata?.fileName,
                    bands: secondResult.spectralBands || secondResult.bands || secondResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: secondResult.loudness?.integrated ?? secondResult.lufsIntegrated,
                        dr: secondResult.dynamics?.dr ?? secondResult.dynamicRange,
                        peak: secondResult.truePeak?.dbtp ?? secondResult.truePeakDbtp
                    }
                };

                // üßä PROTE√á√ÉO: Usar deep clone para state.reference
                state.reference = {
                    mode: "reference",
                    isSecondTrack: true,
                    userAnalysis: JSON.parse(JSON.stringify(normalizedUser)),
                    referenceAnalysis: JSON.parse(JSON.stringify(normalizedRef)),
                    analysis: {
                        bands: JSON.parse(JSON.stringify(normalizedRef.bands))
                    }
                };

                state.render.mode = 'reference';
                window.__soundyState = state;
                console.log("[REF-FIX] Estrutura final corrigida", state.reference);
            }
            
            // üî• FORCE MODE REFERENCE EXPLICITAMENTE ANTES DE displayModalResults
            // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: S√≥ for√ßar modo reference se usu√°rio selecionou explicitamente
            if (!userExplicitlySelectedReferenceMode) {
                console.error('%c[PROTECTION] ‚ùå BLOQUEIO: Tentativa de for√ßar modo reference mas userExplicitlySelectedReferenceMode = false', 'color:#FF0000;font-weight:bold;font-size:16px;');
                console.error('[PROTECTION] ‚ùå Sistema em modo genre - N√ÉO pode for√ßar modo reference');
                console.trace('[PROTECTION] Stack trace do bloqueio:');
                // N√ÉO for√ßar modo reference
                return;
            }
            
            state.render = state.render || {};
            state.render.mode = 'reference';
            currentAnalysisMode = 'reference';
            window.__soundyState = state;
            
            console.log('%c[PROTECTION] ‚úÖ Modo for√ßado para reference - flag verificada', 'color:#00FF88;font-weight:bold;');
            console.log('üî•üî•üî• [MODE-FORCE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üî• [MODE-FORCE] ‚úÖ Modo FOR√áADO para reference antes de displayModalResults');
            console.log('üî• [MODE-FORCE] state.render.mode:', state.render.mode);
            console.log('üî• [MODE-FORCE] currentAnalysisMode:', currentAnalysisMode);
            console.log('üî• [MODE-FORCE] window.__soundyState.render.mode:', window.__soundyState.render.mode);
            console.log('üî•üî•üî• [MODE-FORCE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // üî• CORRE√á√ÉO: Preparar dados para compara√ß√£o A/B correta
            console.log('[REFERENCE-FLOW] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('[REFERENCE-FLOW] Segunda m√∫sica conclu√≠da - montando compara√ß√£o A/B');
            
            // ÔøΩ PASSO 2: ATIVAR PROTE√á√ÉO DE CURRENTJOBID
            const currentJobId = normalizedResult?.jobId || analysisResult?.jobId;
            // üîß CORRE√á√ÉO: Usar StorageManager
            const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
            
            if (currentJobId) {
                console.log('üîí [PROTECTION] Ativando prote√ß√£o para currentJobId:', currentJobId);
                console.log('üîç [PROTECTION] ReferenceJobId:', referenceJobId);
                
                // üö® VALIDA√á√ÉO CR√çTICA: Garantir que jobIds s√£o DIFERENTES
                if (currentJobId === referenceJobId) {
                    console.error('‚ùå [MODAL-FILE] ERRO CR√çTICO: Backend retornou mesmo jobId!');
                    console.error('   currentJobId:', currentJobId);
                    console.error('   referenceJobId:', referenceJobId);
                    console.trace();
                    alert('ERRO: O backend retornou o mesmo jobId da primeira m√∫sica. Tente novamente.');
                    return;
                }
                
                console.log('‚úÖ [MODAL-FILE] Segunda m√∫sica analisada:');
                console.log('   Novo currentJobId:', currentJobId);
                console.log('   ReferenceJobId:', referenceJobId);
                console.log('   S√£o diferentes?', currentJobId !== referenceJobId ? '‚úÖ SIM' : '‚ùå N√ÉO');
                
                // Salvar em m√∫ltiplas camadas de prote√ß√£o
                window.__CURRENT_JOB_ID__ = currentJobId;
                sessionStorage.setItem('currentJobId', currentJobId);
                
                protectCurrentJobId(currentJobId);
                console.log('‚úÖ [PROTECTION] Prote√ß√£o ativada - currentJobId protegido contra contamina√ß√£o');
                console.log('‚úÖ [PROTECTION] sessionStorage.currentJobId salvo:', sessionStorage.getItem('currentJobId'));
            } else {
                console.warn('‚ö†Ô∏è [PROTECTION] currentJobId n√£o encontrado, prote√ß√£o n√£o ativada');
            }
            
            // ÔøΩüõ°Ô∏è DEEP CLONE OBRIGAT√ìRIO: Evitar contamina√ß√£o de ponteiros que causa falso self-compare
            console.log('[DEEP-CLONE-GUARD] üîí Clonando userAnalysis para evitar compartilhamento de metadata');
            const userAnalysis = structuredClone(state.previousAnalysis || state.userAnalysis);
            
            console.log('[DEEP-CLONE-GUARD] üîí Clonando referenceAnalysisData para evitar compartilhamento de metadata');
            const referenceAnalysisData = structuredClone(normalizedResult || state.referenceAnalysis);
            
            // üîç VALIDA√á√ÉO CR√çTICA: Confirmar que os clones s√£o independentes
            console.groupCollapsed('[INTEGRITY-CHECK] üîí Valida√ß√£o de Clones Independentes');
            console.log('‚úÖ userAnalysis !== referenceAnalysisData?', userAnalysis !== referenceAnalysisData);
            console.log('‚úÖ userAnalysis.metadata !== referenceAnalysisData.metadata?', userAnalysis?.metadata !== referenceAnalysisData?.metadata);
            console.log('üìÅ userFileName:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('üìÅ refFileName:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('üÜî userJobId:', userAnalysis?.jobId || userAnalysis?.id);
            console.log('üÜî refJobId:', referenceAnalysisData?.jobId || referenceAnalysisData?.id);
            console.log('‚ö†Ô∏è Nomes iguais?', (userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName));
            console.log('‚ö†Ô∏è JobIds iguais?', (userAnalysis?.jobId || userAnalysis?.id) === (referenceAnalysisData?.jobId || referenceAnalysisData?.id));
            
            if ((userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName)) {
                console.error('üö® CONTAMINA√á√ÉO DETECTADA: userFileName === refFileName!');
                console.error('üö® Isso indica que os clones N√ÉO s√£o independentes ou que a fonte est√° contaminada!');
            } else {
                console.log('‚úÖ INTEGRIDADE CONFIRMADA: Arquivos s√£o diferentes');
            }
            console.groupEnd();
            
            console.log('[REFERENCE-COMPARE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('[REFERENCE-COMPARE] 1¬™ FAIXA (SUA M√öSICA):');
            console.log('[REFERENCE-COMPARE]   Nome:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!userAnalysis?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', userAnalysis?.technicalData?.spectral_balance ? 'SIM' : 'N√ÉO');
            console.log('[REFERENCE-COMPARE]   bandas:', userAnalysis?.technicalData?.spectral_balance ? Object.keys(userAnalysis.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', userAnalysis?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] 2¬™ FAIXA (REFER√äNCIA):');
            console.log('[REFERENCE-COMPARE]   Nome:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!referenceAnalysisData?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', referenceAnalysisData?.technicalData?.spectral_balance ? 'SIM' : 'N√ÉO');
            console.log('[REFERENCE-COMPARE]   bandas:', referenceAnalysisData?.technicalData?.spectral_balance ? Object.keys(referenceAnalysisData.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', referenceAnalysisData?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // Marcar no normalizedResult que √© modo refer√™ncia com dados corretos
            normalizedResult._isReferenceMode = true;
            // üõ°Ô∏è PROTE√á√ÉO CIRCULAR: usar clone seguro para evitar loops
            normalizedResult._userAnalysis = deepCloneSafe(userAnalysis);
            normalizedResult._referenceAnalysis = deepCloneSafe(referenceAnalysisData);
            
            // ==== CHECKPOINT AUDITORIA REF-CONTAMINA√á√ÉO ====
            console.group("[AUDITORIA REF-CONTAMINA√á√ÉO]");
            console.log("üåê window.referenceAnalysisData:", window.referenceAnalysisData?.metadata?.fileName || window.referenceAnalysisData?.fileName);
            console.log("üßä __FIRST_ANALYSIS_FROZEN__:", window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.fileName);
            console.log("üì¶ analysis.metadata.fileName:", normalizedResult?.metadata?.fileName);
            console.groupEnd();
            
            // ========================================
            // üß† OBTER PAR DE AN√ÅLISES DO STORE ISOLADO
            // ========================================
            console.log('[STORE-FLOW] Obtendo par de an√°lises do store isolado');
            const comparisonPair = getComparisonPair();
            
            if (comparisonPair) {
                console.log('‚úÖ [STORE-FLOW] Par obtido com sucesso');
                console.log('   - ref.jobId:', comparisonPair.ref?.jobId);
                console.log('   - curr.jobId:', comparisonPair.curr?.jobId);
                console.log('   - ref.fileName:', comparisonPair.ref?.fileName || comparisonPair.ref?.metadata?.fileName);
                console.log('   - curr.fileName:', comparisonPair.curr?.fileName || comparisonPair.curr?.metadata?.fileName);
                
                // ‚úÖ USAR DADOS DO STORE COMO FONTE DE VERDADE
                normalizedResult._comparisonPair = comparisonPair;
                normalizedResult._useStoreData = true;
                
                console.log('üéØ [STORE-FLOW] Dados do store anexados ao normalizedResult');
            } else {
                console.warn('‚ö†Ô∏è [STORE-FLOW] Store n√£o pronto, usando dados legados');
            }
            
            console.log("[SAFE-MODAL] ‚úÖ Fluxo reference intacto, iniciando renderiza√ß√£o final.");
            
            // ========================================
            // ü§ñ AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL
            // ========================================
            console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('[AI-SYNC] üîç Verificando status do enriquecimento IA...');
            console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // Verificar se aiSuggestions j√° est√° presente
            const hasAISuggestions = Array.isArray(normalizedResult.aiSuggestions) && 
                                     normalizedResult.aiSuggestions.length > 0 &&
                                     normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
            
            console.log('[AI-SYNC] üìä Estado atual:', {
                hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
                aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
                aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
                jobId: normalizedResult.jobId
            });
            
            if (!hasAISuggestions) {
                console.log('[AI-SYNC] ‚è≥ aiSuggestions n√£o est√° pronto, aguardando enriquecimento...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    console.error('[AI-SYNC] ‚ùå jobId inv√°lido, n√£o √© poss√≠vel aguardar enriquecimento:', normalizedResult.jobId);
                    console.warn('[AI-SYNC] ‚ö†Ô∏è Pulando enriquecimento IA - usando dados j√° dispon√≠veis');
                } else {
                    // Mostrar spinner visual
                    showAILoadingSpinner('ü§ñ Conectando √† IA para an√°lise avan√ßada...');
                    
                    try {
                        // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                    
                        if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                            // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                            normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        
                        console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                        console.log('[AI-SYNC] ‚úÖ Enriquecimento IA mesclado com sucesso!');
                        console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                        console.log('[AI-SYNC] üìä Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                        console.log('[AI-SYNC] ü§ñ Marcadas como aiEnhanced:', 
                            normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                        
                        // Atualizar cache com dados enriquecidos
                        AnalysisCache.put(normalizedResult);
                        
                    } else {
                        console.warn('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                        console.warn('[AI-SYNC] ‚ö†Ô∏è Enriquecimento IA n√£o completou a tempo');
                        console.warn('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                        console.warn('[AI-SYNC] ‚ÑπÔ∏è Modal ser√° exibido com sugest√µes base');
                        console.warn('[AI-SYNC] ‚ÑπÔ∏è IA pode estar desabilitada ou sobrecarregada');
                        }
                        
                    } catch (syncError) {
                        console.error('[AI-SYNC] ‚ùå Erro ao aguardar enriquecimento IA:', syncError);
                        console.warn('[AI-SYNC] ‚ÑπÔ∏è Continuando com sugest√µes base...');
                    } finally {
                        // Remover spinner
                        hideAILoadingSpinner();
                    }
                } // PATCH JOB-ID: Fim do bloco de valida√ß√£o
                
            } else {
                console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('[AI-SYNC] ‚úÖ aiSuggestions j√° presente no resultado!');
                console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('[AI-SYNC] ‚ÑπÔ∏è N√£o √© necess√°rio aguardar, exibindo imediatamente');
            }
            
            console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('[AI-SYNC] üé¨ Iniciando renderiza√ß√£o do modal...');
            console.log('[AI-SYNC] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // ========================================
            // ‚úÖ CORRE√á√ÉO: Aguardar enriquecimento IA antes de abrir modal
            // ========================================
            if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
                console.log('[AI-SYNC] ‚è≥ Enriquecimento IA ausente ‚Äî aguardando resposta...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    console.error('[AI-SYNC] ‚ùå jobId inv√°lido, n√£o √© poss√≠vel aguardar enriquecimento:', normalizedResult.jobId);
                    console.warn('[AI-SYNC] ‚ö†Ô∏è Pulando enriquecimento IA - abrindo modal com dados dispon√≠veis');
                } else {
                    showAILoadingSpinner('ü§ñ Conectando √† IA para an√°lise avan√ßada...');

                    try {
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                    if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                        normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        console.log(`[AI-SYNC] ‚úÖ Sugest√µes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                    } else {
                        console.warn('[AI-SYNC] ‚ö†Ô∏è Timeout ou IA n√£o retornou sugest√µes v√°lidas. Fallback para sugest√µes base.');
                    }
                } catch (error) {
                    console.error('[AI-SYNC] ‚ùå Erro ao aguardar sugest√µes enriquecidas:', error);
                } finally {
                    hideAILoadingSpinner();
                }
                } // PATCH JOB-ID: Fim do bloco de valida√ß√£o
            }

            // ‚úÖ Agora sim, exibe o modal com ou sem IA (fallback incluso)
            await displayModalResults(normalizedResult);
            console.log('[FIX-REFERENCE] Modal aberto ap√≥s segunda an√°lise');
            
            // üîç VALIDA√á√ÉO FINAL: Confirmar que __FIRST_ANALYSIS_FROZEN__ permanece intacto
            console.groupCollapsed('[POST-RENDER-VALIDATION] üîí Verifica√ß√£o Final de Integridade');
            console.log('üßä __FIRST_ANALYSIS_FROZEN__ AP√ìS segunda an√°lise:');
            console.log('   fileName:', window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
            console.log('   jobId:', window.__FIRST_ANALYSIS_FROZEN__?.jobId);
            console.log('   √â o mesmo que normalizedResult?', window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId);
            
            if (window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId) {
                console.error('üö® FALHA CR√çTICA: __FIRST_ANALYSIS_FROZEN__ foi sobrescrito pela segunda an√°lise!');
            } else {
                console.log('‚úÖ INTEGRIDADE MANTIDA: __FIRST_ANALYSIS_FROZEN__ permanece intacto');
            }
            console.groupEnd();
            
            // ========================================
            // ‚úÖ CORRE√á√ÉO 1: EARLY RETURN - Impedir limpeza no modo reference
            // ========================================
            if (currentAnalysisMode === 'reference' || jobMode === 'reference') {
                console.log('‚úÖ [CLEANUP] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('‚úÖ [CLEANUP] MODO REFERENCE ATIVO - Limpeza bloqueada por early return');
                console.log('‚úÖ [CLEANUP] Refer√™ncia PRESERVADA intacta:');
                console.log('‚úÖ [CLEANUP]   - currentAnalysisMode:', currentAnalysisMode);
                console.log('‚úÖ [CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
                console.log('‚úÖ [CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('‚úÖ [CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
                console.log('‚úÖ [CLEANUP] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // Marcar que h√° uma compara√ß√£o ativa
                window.__referenceComparisonActive = true;
                
                // EARLY RETURN: N√£o executa nenhuma limpeza
                // Continua para o pr√≥ximo bloco de c√≥digo sem deletar nada
            } else {
                // Modo normal (genre): limpar normalmente
                delete window.__REFERENCE_JOB_ID__;
                delete window.__FIRST_ANALYSIS_RESULT__;
                localStorage.removeItem('referenceJobId');
                
                console.log('‚úÖ [CLEANUP] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('‚úÖ [CLEANUP] Refer√™ncia removida (modo genre)');
                console.log('‚úÖ [CLEANUP] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            }
            
            // üîí MANT√âM: window.referenceAnalysisData e referenceComparisonMetrics para renderiza√ß√£o
        } else {
            // Modo genre: an√°lise por g√™nero tradicional
            __dbg('üéØ Exibindo resultado por g√™nero');
            await handleGenreAnalysisWithResult(analysisResult, file.name);
        }

    } catch (error) {
        console.error('üî¥üî¥üî¥ [ERRO-CR√çTICO-CAPTURADO] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.error('üî¥ [ERRO-CR√çTICO] Erro capturado no handleModalFileSelection!');
        console.error('üî¥ [ERRO-CR√çTICO] Este erro est√° RESETANDO currentAnalysisMode para "genre"!');
        console.error('üî¥ [ERRO-CR√çTICO] Error message:', error.message);
        console.error('üî¥ [ERRO-CR√çTICO] Error stack:', error.stack);
        console.error('üî¥ [ERRO-CR√çTICO] currentAnalysisMode ANTES:', currentAnalysisMode);
        console.error('üî¥ [ERRO-CR√çTICO] window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        console.error('üî¥ [ERRO-CR√çTICO] isSecondTrack:', window.__REFERENCE_JOB_ID__ !== null);
        console.error('üî¥ [ERRO-CR√çTICO] FEATURE_FLAGS?.FALLBACK_TO_GENRE:', window.FEATURE_FLAGS?.FALLBACK_TO_GENRE);
        console.error('üî¥üî¥üî¥ [ERRO-CR√çTICO-CAPTURADO] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.error('‚ùå Erro na an√°lise do modal:', error);
        
        // ‚úÖ STEP 4/6: Bloquear fallback para genre em caso de self-compare ou circular structure
        const msg = String(error?.message || '');
        if (msg.includes('Self-compare') || msg.includes('circular structure')) {
            console.warn('[REF-FLOW] Erro de self-compare/circular structure ‚Äî ignorando fallback pra genre.');
            showModalError('Erro de compara√ß√£o detectado. Aguardando nova an√°lise...');
            return; // Aborta sem resetar modo
        }
        
        // ========================================
        // üõ°Ô∏è PROTE√á√ÉO: Nunca resetar modo se h√° primeira an√°lise v√°lida
        // ========================================
        if (window.FEATURE_FLAGS?.FALLBACK_TO_GENRE && currentAnalysisMode === 'reference') {
            // N√ÉO altere currentAnalysisMode se houver refer√™ncia v√°lida salva
            if (!window.FirstAnalysisStore?.has()) {
                console.warn('[REF-FLOW] Erro real + sem primeira an√°lise ‚Äî fallback ativado.');
                
                window.logReferenceEvent('error_fallback_to_genre', { 
                    error: error.message,
                    originalMode: currentAnalysisMode 
                });
                
                showModalError('Erro na an√°lise por refer√™ncia. Redirecionando para an√°lise por g√™nero...');
                
                setTimeout(() => {
                    currentAnalysisMode = 'genre';
                    configureModalForMode('genre');
                }, 2000);
            } else {
                console.warn('[REF-FLOW] Erro capturado, mas primeira an√°lise existe ‚Äî mantendo modo reference');
                console.warn('[FALLBACK] Degradando visual apenas, n√£o alterando modo global');
                showModalError('Erro tempor√°rio na an√°lise. Tente fazer upload da segunda faixa novamente.');
            }
        } else {
            // Determinar tipo de erro para mensagem mais espec√≠fica
            let errorMessage = error.message;
            if (error.message.includes('Falha ao gerar URL de upload')) {
                errorMessage = 'Falha ao gerar URL de upload. Verifique sua conex√£o e tente novamente.';
            } else if (error.message.includes('Falha ao enviar arquivo para an√°lise')) {
                errorMessage = 'Falha ao enviar arquivo para an√°lise. Verifique sua conex√£o e tente novamente.';
            }
            
            showModalError(`Erro ao processar arquivo: ${errorMessage}`);
        }
    } finally {
        // üéµ WAV CLEANUP: Limpar otimiza√ß√µes WAV em caso de erro
        try {
            if (window.wavMobileOptimizer) {
                window.wavMobileOptimizer.cleanupWAVOptimizations();
            }
        } catch (cleanupError) {
            console.warn('WAV cleanup error in finally (non-critical):', cleanupError);
        }
        
        // üîß CORRE√á√ÉO: Sempre limpar flag de an√°lise em progresso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('‚úÖ Flag de an√°lise em progresso removida');
    }
}

// ÔøΩ NOVAS FUN√á√ïES: An√°lise baseada em fileKey (p√≥s-upload remoto)

/**
 * Processar an√°lise por refer√™ncia usando fileKey
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
// üåê NOVAS FUN√á√ïES: An√°lise baseada em resultado remoto

/**
 * Processar an√°lise por refer√™ncia usando resultado remoto
 * @param {Object} analysisResult - Resultado da an√°lise remota
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
async function handleReferenceAnalysisWithResult(analysisResult, fileKey, fileName) {
    __dbg('üéØ Processando an√°lise por refer√™ncia com resultado remoto:', { fileKey, fileName });
    
    window.logReferenceEvent('reference_analysis_with_result_started', { 
        fileKey,
        fileName 
    });
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de an√°lise inv√°lido recebido do servidor');
        }
        
        updateModalProgress(90, 'üéØ Aplicando resultado da an√°lise...');
        
        // Determinar se √© arquivo original ou de refer√™ncia
        const isReference = currentAnalysisMode === 'reference' && uploadedFiles.original;
        const fileType = isReference ? 'reference' : 'original';
        
        // Armazenar resultado
        uploadedFiles[fileType] = {
            fileKey: fileKey,
            fileName: fileName,
            analysisResult: analysisResult
        };
        
        __dbg(`‚úÖ Arquivo ${fileType} armazenado:`, uploadedFiles[fileType]);
        
        // Atualizar display na interface
        updateReferenceFileDisplay(fileType, fileName);
        
        // Log do evento
        window.logReferenceEvent('reference_file_processed', {
            fileType,
            fileName,
            hasResult: !!analysisResult
        });
        
        // Verificar se ambos os arquivos est√£o prontos para compara√ß√£o
        if (uploadedFiles.original && uploadedFiles.reference) {
            enableReferenceComparison();
            updateModalProgress(100, '‚úÖ Ambos os arquivos analisados! Compara√ß√£o dispon√≠vel.');
            
        
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao processar an√°lise por refer√™ncia:', error);
        window.logReferenceEvent('reference_analysis_error', { 
            error: error.message,
            fileKey,
            fileName 
        });
        throw error;
    }
}

/**
 * Processar an√°lise por g√™nero usando resultado remoto
 * @param {Object} analysisResult - Resultado da an√°lise remota
 * @param {string} fileName - Nome original do arquivo
 */
async function handleGenreAnalysisWithResult(analysisResult, fileName) {
    __dbg('üéµ Processando an√°lise por g√™nero com resultado remoto:', { fileName });
    
    // üß© AUDIT_REF_FIX: Verificar se N√ÉO estamos em modo reference antes de limpar
    const state = window.__soundyState || {};
    const currentMode = state?.render?.mode || currentAnalysisMode;
    const isSecondTrack = state?.reference?.isSecondTrack || false;
    
    // üö® PROTE√á√ÉO: N√ÉO limpar estado se estivermos em modo reference
    if (currentMode === 'reference' && isSecondTrack) {
        console.warn('‚ö†Ô∏è [AUDIT_REF_FIX] handleGenreAnalysisWithResult chamado em modo reference!');
        console.warn('‚ö†Ô∏è [AUDIT_REF_FIX] ABORTANDO limpeza para preservar dados A/B');
        console.log('[MODE LOCKED] reference - limpeza de estado BLOQUEADA');
        
        // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
        const normalizedResult = analysisResult; // ‚úÖ LEITURA DIRETA
        
        // üîí POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        return normalizedResult;
    }
    
    // üö® BLINDAGEM: N√ÉO limpar estado em modo genre (preservar g√™nero)
    if (window.__CURRENT_MODE__ === 'genre') {
        console.warn('[GENRE-PROTECT] ‚ö†Ô∏è handleGenreAnalysisWithResult - limpeza BLOQUEADA em modo genre');
        console.log('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        
        // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
        const normalizedResult = analysisResult; // ‚úÖ LEITURA DIRETA
        AnalysisCache.put(normalizedResult);
        
        console.log('[GENRE-BEFORE-DISPLAY] üéµ Genre preservado:', {
            preservedGenre: window.__CURRENT_SELECTED_GENRE,
            normalizedGenre: normalizedResult.genre
        });
        
        // ‚úÖ Continuar processamento SEM limpar estado
        updateModalProgress(90, 'üéµ Aplicando resultado da an√°lise...');
        
        try {
            if (!analysisResult || typeof analysisResult !== 'object') {
                throw new Error('Resultado de an√°lise inv√°lido recebido do servidor');
            }
            
            return normalizedResult;
        } catch (error) {
            console.error('‚ùå Erro ao processar an√°lise de g√™nero:', error);
            throw error;
        }
    }
    
    // üß© CORRE√á√ÉO #1: Limpeza completa APENAS em modo Reference (quando n√£o h√° segundo track)
    
    // Limpar completamente estado de refer√™ncia
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        state.reference.userAnalysis = null;
        state.reference.referenceAnalysis = null;
    }
    
    // For√ßar modo g√™nero explicitamente
    if (!state.render) state.render = {};
    state.render.mode = 'genre';
    
    window.__soundyState = state;
    
    // üîí HARD-GUARD: Limpar FirstAnalysisStore (√∫nica fonte de verdade)
    FirstAnalysisStore.clear();
    console.log('[CLEANUP] handleGenreAnalysisWithResult: FirstAnalysisStore limpo');
    
    // ‚ùå REMOVER: window.referenceAnalysisData agora √© read-only (n√£o pode ser setado)
    window.referenceComparisonMetrics = null;
    window.lastReferenceJobId = null;
    
    console.log('üéöÔ∏è [FIX-GENRE] Estado completamente limpo, modo for√ßado para "genre"');
    
    // üîí PATCH: PRESERVAR G√äNERO AP√ìS LIMPEZA
    preserveGenreState();
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de an√°lise inv√°lido recebido do servidor');
        }
        
        updateModalProgress(90, 'üéµ Aplicando resultado da an√°lise...');
        
        // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
        // ‚ùå REMOVIDO: normalizeBackendAnalysisData() destr√≥i dados
        const normalizedResult = analysisResult; // ‚úÖ LEITURA DIRETA
        
        // üîí POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        // ========================================
        // üî• BARREIRA 3: LIMPEZA NO RECEBIMENTO DE AN√ÅLISE
        // ========================================
        // Se o backend retornar mode: "genre", garantir limpeza ANTES de processar
        const isGenreModeFromBackend = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreModeFromBackend) {
            console.log('%c[GENRE-BARRIER] üöß BARREIRA 3 ATIVADA: An√°lise de g√™nero recebida do backend', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
            console.log('[GENRE-BARRIER] normalizedResult.mode:', normalizedResult.mode);
            console.log('[GENRE-BARRIER] normalizedResult.isReferenceBase:', normalizedResult.isReferenceBase);
            
            // üî• EXECUTAR LIMPEZA COMPLETA
            // üéØ PRESERVAR G√äNERO durante o reset
            const genreToPreserve = getActiveGenre(normalizedResult, window.PROD_AI_REF_GENRE);
            console.log('[GENRE-BARRIER] G√™nero a preservar:', genreToPreserve);
            resetReferenceStateFully(genreToPreserve);
            
            // üéØ GARANTIR que normalizedResult.genre est√° definido
            if (genreToPreserve && !normalizedResult.genre) {
                normalizedResult.genre = genreToPreserve;
                console.log('[GENRE-BARRIER] normalizedResult.genre restaurado:', genreToPreserve);
            }
            
            // üîí CONFIGURAR VIEW MODE
            setViewMode("genre");
            
            // üîí FOR√áAR MODO G√äNERO
            window.currentAnalysisMode = 'genre';
            
            console.log('%c[GENRE-BARRIER] ‚úÖ BARREIRA 3 CONCLU√çDA: Estado limpo antes de processar an√°lise', 'color:#00FF88;font-weight:bold;');
        }
        
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        // üéØ MODE ENGINE: Configura√ß√£o baseada em mode + isReferenceBase
        // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
        
        // PRIMEIRA TRACK DO FLUXO A/B (mode: "genre" + isReferenceBase: true)
        if (normalizedResult.isReferenceBase === true && normalizedResult.mode === 'genre') {
            SOUNDY_MODE_ENGINE.startReferenceBase(normalizedResult);
            console.log('[MODE-ENGINE] Primeira track salva como refer√™ncia base');
        }
        // SEGUNDA TRACK (mode: "reference" do backend)
        else if (normalizedResult.mode === 'reference') {
            SOUNDY_MODE_ENGINE.startReferenceCompare();
            console.log('[MODE-ENGINE] Segunda track detectada, modo A/B ativado');
        }
        
        // ‚úÖ CORRE√á√ÉO CR√çTICA: Carregar targets de g√™nero baseado em MODE, n√£o em referenceComparison
        const isGenreMode = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreMode) {
            console.log('[GENRE-TARGETS] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('[GENRE-TARGETS] üéµ MODO G√äNERO PURO DETECTADO');
            console.log('[GENRE-TARGETS] mode:', normalizedResult.mode);
            console.log('[GENRE-TARGETS] isReferenceBase:', normalizedResult.isReferenceBase);
            console.log('[GENRE-TARGETS] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            // üîí LIMPAR referenceComparison residual de sess√µes anteriores
            if (normalizedResult.referenceComparison) {
                console.log('[GENRE-TARGETS] ‚ö†Ô∏è referenceComparison residual detectado - removendo');
                delete normalizedResult.referenceComparison;
            }
            
            // Carregar targets de g√™nero de /refs/out/
            // üéØ CORRE√á√ÉO: Usar getActiveGenre ao inv√©s de fallback direto para "default"
            const genreId = getActiveGenre(normalizedResult, null);
            
            if (!genreId) {
                console.warn('[GENRE-TARGETS] ‚ö†Ô∏è Nenhum g√™nero detectado - pulando carregamento de targets');
                console.warn('[GENRE-TARGETS] Fontes verificadas:', {
                    'normalizedResult.genre': normalizedResult.genre,
                    'normalizedResult.genreId': normalizedResult.genreId,
                    'normalizedResult.metadata?.genre': normalizedResult.metadata?.genre,
                    'window.__CURRENT_GENRE': window.__CURRENT_GENRE,
                    'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE
                });
            } else {
                console.log(`[GENRE-TARGETS] Carregando targets para g√™nero: ${genreId}`);
            }
            
            // üéØ VALIDA√á√ÉO: S√≥ carregar se genreId for v√°lido (n√£o vazio, n√£o 'default')
            if (genreId && genreId !== 'default') {
                try {
                    const response = await fetch(`/refs/out/${genreId}.json`);
                    if (response.ok) {
                        const rawJson = await response.json();
                        
                        // üî• CORRE√á√ÉO CR√çTICA: Extrair o objeto interno do JSON
                        // O JSON tem estrutura: { "genreId": { ...dados... } }
                        const rootKey = Object.keys(rawJson)[0];
                        let targets = rawJson[rootKey] || rawJson;
                        
                        console.log('[GENRE-TARGETS] üì¶ JSON bruto carregado:', { 
                            rootKey, 
                            hasRootKey: !!rootKey,
                            targetKeys: Object.keys(targets)
                        });
                        
                        // üî• CORRE√á√ÉO CR√çTICA: Enriquecer targets usando enrichReferenceObject
                        targets = enrichReferenceObject(targets, genreId);
                        console.log('[GENRE-TARGETS] üîß Targets enriquecidos via enrichReferenceObject');
                        
                        // üîç DIAGN√ìSTICO: Logs detalhados da estrutura ap√≥s enriquecimento
                        console.log('[GENRE-TARGETS] üìä Estrutura targets (AP√ìS enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasSpectralBands: !!targets?.spectral_bands,
                            spectralBandsCount: targets?.spectral_bands ? Object.keys(targets.spectral_bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasOriginalMetrics: !!targets?.original_metrics,
                            hasLufsTarget: targets?.lufs_target !== undefined,
                            hasTruePeakTarget: targets?.true_peak_target !== undefined,
                            hasDrTarget: targets?.dr_target !== undefined,
                            hasStereoTarget: targets?.stereo_target !== undefined
                        });
                        
                        // üîç DIAGN√ìSTICO: Amostra das bandas
                        if (targets?.bands) {
                            const sampleBand = Object.keys(targets.bands)[0];
                            console.log('[GENRE-TARGETS] üìã Amostra de banda:', sampleBand, targets.bands[sampleBand]);
                        }
                        
                        // üî• CORRE√á√ÉO CR√çTICA: Criar referenceComparisonMetrics para UI
                        normalizedResult.referenceComparisonMetrics = {
                            bands: targets.bands || targets.spectral_bands,
                            spectralBands: targets.spectral_bands || targets.bands,
                            legacyBands: targets.legacy_compatibility?.bands,
                            originalMetrics: targets.original_metrics || targets.hybrid_processing?.original_metrics,
                            lufs_target: targets.lufs_target,
                            true_peak_target: targets.true_peak_target,
                            dr_target: targets.dr_target,
                            stereo_target: targets.stereo_target,
                            lra_target: targets.lra_target
                        };
                        console.log('[GENRE-TARGETS] üì¶ referenceComparisonMetrics criado:', {
                            hasBands: !!normalizedResult.referenceComparisonMetrics.bands,
                            hasOriginalMetrics: !!normalizedResult.referenceComparisonMetrics.originalMetrics
                        });
                        
                        // üî• CORRE√á√ÉO CR√çTICA: Atribuir targets a TODAS as vari√°veis globais
                        normalizedResult.referenceComparison = targets;
                        
                        // ‚úÖ CORRE√á√ÉO: Inicializar window.PROD_AI_REF_DATA como objeto se for false
                        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
                            window.PROD_AI_REF_DATA = {};
                            console.log('[GENRE-TARGETS] üîß Inicializando window.PROD_AI_REF_DATA como objeto');
                        }
                        
                        // ‚úÖ CORRE√á√ÉO: Atribuir targets ao g√™nero espec√≠fico
                        window.PROD_AI_REF_DATA[genreId] = targets;
                        console.log(`[GENRE-TARGETS] üì¶ window.PROD_AI_REF_DATA['${genreId}'] atribu√≠do`);
                        
                        // ‚úÖ CORRE√á√ÉO: Atualizar __activeRefData
                        window.__activeRefData = targets;
                        console.log('[GENRE-TARGETS] üì¶ window.__activeRefData atualizado');
                        
                        // ‚úÖ CORRE√á√ÉO: Sincronizar g√™nero ativo
                        window.__CURRENT_GENRE = genreId;
                        console.log(`[GENRE-TARGETS] üéØ window.__CURRENT_GENRE = '${genreId}'`);
                        
                        console.log(`[GENRE-TARGETS] ‚úÖ Targets carregados e enriquecidos para ${genreId}`);
                        console.log('[GENRE-TARGETS] üìä Estrutura targets (AP√ìS enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasLufsTarget: !!targets?.lufs_target,
                            hasTruePeakTarget: !!targets?.true_peak_target,
                            hasDrTarget: !!targets?.dr_target,
                            hasStereoTarget: !!targets?.stereo_target
                        });
                        console.log('[GENRE-TARGETS] üìã Targets.bands:', targets?.bands);
                    } else {
                        console.warn(`[GENRE-TARGETS] ‚ö†Ô∏è Arquivo n√£o encontrado: /refs/out/${genreId}.json (${response.status})`);
                        console.warn(`[GENRE-TARGETS] Continuando sem targets espec√≠ficos do g√™nero`);
                    }
                } catch (err) {
                    console.error("[GENRE-TARGETS] ‚ùå Erro ao carregar targets de g√™nero:", err);
                    console.error("[GENRE-TARGETS] Continuando com targets padr√£o ou sem targets");
                }
            } else {
                console.warn('[GENRE-TARGETS] ‚ö†Ô∏è GenreId inv√°lido ou "default" - pulando fetch:', genreId);
            }
        } else {
            console.log("[GENRE-TARGETS] ‚ö†Ô∏è N√£o √© modo g√™nero puro - pulando carregamento de targets");
            console.log("[GENRE-TARGETS] mode:", normalizedResult.mode);
            console.log("[GENRE-TARGETS] isReferenceBase:", normalizedResult.isReferenceBase);
        }
        
        // üéØ CORRE√á√ÉO CR√çTICA: Gerar sugest√µes no primeiro load
        if (__activeRefData && !normalizedResult._suggestionsGenerated) {
            console.log('üéØ [SUGGESTIONS] Engine chamado no primeiro load');
            try {
                updateReferenceSuggestions(normalizedResult, __activeRefData);
                normalizedResult._suggestionsGenerated = true;
                console.log(`üéØ [SUGGESTIONS] ${normalizedResult.suggestions?.length || 0} sugest√µes geradas no primeiro load`);
            } catch (error) {
                console.error('‚ùå [SUGGESTIONS] Erro ao gerar sugest√µes no primeiro load:', error);
            }
        } else if (!__activeRefData) {
            console.log('üéØ [SUGGESTIONS] Dados de refer√™ncia n√£o dispon√≠veis para gerar sugest√µes');
        } else {
            console.log('üéØ [SUGGESTIONS] Sugest√µes j√° foram geradas anteriormente');
        }

        // üöÄ FOR√áA EXIBI√á√ÉO: Sempre mostrar interface IA ap√≥s sugest√µes serem processadas
        if (normalizedResult.suggestions && normalizedResult.suggestions.length > 0) {
            setTimeout(() => {
                console.log(`üöÄ [AI-UI-FORCE] Tentando for√ßar interface IA aparecer com ${normalizedResult.suggestions.length} sugest√µes`);
                
                // Verificar m√∫ltiplas formas de chamar a interface IA
                if (window.aiUIController) {
                    console.log(`üöÄ [AI-UI-FORCE] Usando aiUIController existente`);
                    window.aiUIController.checkForAISuggestions(normalizedResult, true);
                } else if (window.forceShowAISuggestions) {
                    console.log(`üöÄ [AI-UI-FORCE] Usando forceShowAISuggestions como fallback`);
                    window.forceShowAISuggestions(normalizedResult);
                } else {
                    console.warn('‚ö†Ô∏è [AI-UI-FORCE] Nenhum m√©todo de interface IA encontrado, criando interface b√°sica...');
                    
                    // Criar interface b√°sica na hora
                    const aiSection = document.createElement('div');
                    aiSection.id = 'ai-suggestions-section';
                    aiSection.style.cssText = `
                        margin: 20px 0; padding: 20px; border: 2px solid #4CAF50;
                        border-radius: 10px; background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
                        color: white; font-family: Arial, sans-serif;
                    `;
                    aiSection.innerHTML = `
                        <h3 style="color: #4CAF50; margin: 0 0 15px 0;">ü§ñ Sugest√µes Inteligentes</h3>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <p style="margin: 0 0 10px 0; color: #A5D6A7;">
                                üí° Interface IA carregada com ${normalizedResult.suggestions.length} sugest√µes
                            </p>
                            <p style="margin: 0; font-size: 14px; color: #81C784;">
                                Configure uma API Key da OpenAI para sugest√µes inteligentes personalizadas.
                            </p>
                            <button onclick="if(window.promptForAPIKey) window.promptForAPIKey(); else alert('Configure API Key da OpenAI para ativar IA')" 
                                    style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                ‚öôÔ∏è Configurar IA
                            </button>
                        </div>
                    `;
                    
                    // Inserir na interface
                    const modal = document.getElementById('audioAnalysisModal');
                    const content = modal?.querySelector('.modal-content');
                    if (content) {
                        // Remover se√ß√£o anterior se existir
                        const existing = content.querySelector('#ai-suggestions-section');
                        if (existing) existing.remove();
                        
                        // Adicionar nova se√ß√£o
                        content.appendChild(aiSection);
                        console.log('‚úÖ [AI-UI-FORCE] Interface IA b√°sica criada e inserida');
                    } else {
                        console.error('‚ùå [AI-UI-FORCE] Modal n√£o encontrado para inserir interface');
                    }
                }
            }, 500); // Delay para garantir que o DOM esteja renderizado
        }
        
        // Definir como an√°lise atual do modal
        currentModalAnalysis = normalizedResult;
        
        // üéØ ALIAS GLOBAL PARA RELAT√ìRIOS (Fonte de Verdade √önica)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = normalizedResult;
            
            // Criar namespace global unificado
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = normalizedResult;
            
            console.log('‚úÖ [PDF-READY] An√°lise armazenada globalmente:', {
                hasGlobalAlias: !!window.__soundyAI.analysis,
                fileName: normalizedResult.metadata?.fileName || normalizedResult.fileName,
                score: normalizedResult.score,
                hasMetrics: !!(normalizedResult.loudness || normalizedResult.technicalData)
            });
        }
        
        updateModalProgress(100, `‚úÖ An√°lise de ${fileName} conclu√≠da!`);
        
        // ========================================
        // ü§ñ AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL (MODO GENRE)
        // ========================================
        console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('[AI-SYNC][GENRE] üîç Verificando status do enriquecimento IA...');
        console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        
        // Verificar se aiSuggestions j√° est√° presente
        const hasAISuggestionsGenre = Array.isArray(normalizedResult.aiSuggestions) && 
                                      normalizedResult.aiSuggestions.length > 0 &&
                                      normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
        
        console.log('[AI-SYNC][GENRE] üìä Estado atual:', {
            hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
            aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
            aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
            jobId: normalizedResult.jobId
        });
        
        if (!hasAISuggestionsGenre) {
            console.log('[AI-SYNC][GENRE] ‚è≥ aiSuggestions n√£o est√° pronto, aguardando enriquecimento...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                console.error('[AI-SYNC][GENRE] ‚ùå jobId inv√°lido, n√£o √© poss√≠vel aguardar enriquecimento:', normalizedResult.jobId);
                console.warn('[AI-SYNC][GENRE] ‚ö†Ô∏è Pulando enriquecimento IA - usando dados j√° dispon√≠veis');
            } else {
                // Mostrar spinner visual
                showAILoadingSpinner('ü§ñ Conectando √† IA para an√°lise avan√ßada...');
            
            try {
                // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                const enrichedDataGenre = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                
                if (enrichedDataGenre && enrichedDataGenre.aiSuggestions && enrichedDataGenre.aiSuggestions.length > 0) {
                    // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                    normalizedResult.aiSuggestions = enrichedDataGenre.aiSuggestions;
                    
                    console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('[AI-SYNC][GENRE] ‚úÖ Enriquecimento IA mesclado com sucesso!');
                    console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.log('[AI-SYNC][GENRE] üìä Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                    console.log('[AI-SYNC][GENRE] ü§ñ Marcadas como aiEnhanced:', 
                        normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                    
                    // Atualizar cache com dados enriquecidos
                    AnalysisCache.put(normalizedResult);
                    
                } else {
                    console.warn('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.warn('[AI-SYNC][GENRE] ‚ö†Ô∏è Enriquecimento IA n√£o completou a tempo');
                    console.warn('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                    console.warn('[AI-SYNC][GENRE] ‚ÑπÔ∏è Modal ser√° exibido com sugest√µes base');
                    console.warn('[AI-SYNC][GENRE] ‚ÑπÔ∏è IA pode estar desabilitada ou sobrecarregada');
                }
                
            } catch (syncErrorGenre) {
                console.error('[AI-SYNC][GENRE] ‚ùå Erro ao aguardar enriquecimento IA:', syncErrorGenre);
                console.warn('[AI-SYNC][GENRE] ‚ÑπÔ∏è Continuando com sugest√µes base...');
            } finally {
                // Remover spinner
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de valida√ß√£o
            
        } else {
            console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('[AI-SYNC][GENRE] ‚úÖ aiSuggestions j√° presente no resultado!');
            console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('[AI-SYNC][GENRE] ‚ÑπÔ∏è N√£o √© necess√°rio aguardar, exibindo imediatamente');
        }
        
        console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        console.log('[AI-SYNC][GENRE] üé¨ Iniciando renderiza√ß√£o do modal...');
        console.log('[AI-SYNC][GENRE] ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        
        // ========================================
        // ‚úÖ CORRE√á√ÉO: Aguardar enriquecimento IA antes de abrir modal (MODO GENRE)
        // ========================================
        if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
            console.log('[AI-SYNC][GENRE] ‚è≥ Enriquecimento IA ausente ‚Äî aguardando resposta...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                console.error('[AI-SYNC][GENRE] ‚ùå jobId inv√°lido, n√£o √© poss√≠vel aguardar enriquecimento:', normalizedResult.jobId);
                console.warn('[AI-SYNC][GENRE] ‚ö†Ô∏è Pulando enriquecimento IA - abrindo modal com dados dispon√≠veis');
            } else {
                showAILoadingSpinner('ü§ñ Conectando √† IA para an√°lise avan√ßada...');

                try {
                    const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                    normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                    console.log(`[AI-SYNC][GENRE] ‚úÖ Sugest√µes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                } else {
                    console.warn('[AI-SYNC][GENRE] ‚ö†Ô∏è Timeout ou IA n√£o retornou sugest√µes v√°lidas. Fallback para sugest√µes base.');
                }
            } catch (error) {
                console.error('[AI-SYNC][GENRE] ‚ùå Erro ao aguardar sugest√µes enriquecidas:', error);
            } finally {
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de valida√ß√£o
        }
        
        // ‚úÖ Agora sim, exibe o modal com ou sem IA (fallback incluso)
        // üõ°Ô∏è VERIFICA√á√ÉO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            await displayModalResults(normalizedResult);
            console.log("[DISPLAY] Modal aberto com sucesso (modo genre)");
        } else {
            console.error('‚ùå [MODAL_MONITOR] Fun√ß√£o displayModalResults n√£o encontrada');
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao processar an√°lise por g√™nero:', error);
        throw error;
    }
}

/**
 * Atualizar display de arquivo de refer√™ncia na interface
 * @param {string} fileType - Tipo do arquivo ('original' ou 'reference')
 * @param {string} fileName - Nome do arquivo
 */
function updateReferenceFileDisplay(fileType, fileName) {
    const displayElement = document.getElementById(`${fileType}FileDisplay`);
    if (displayElement) {
        displayElement.textContent = fileName;
        displayElement.style.display = 'block';
    }
    
    // Atualizar tamb√©m elementos relacionados
    const labelElement = document.querySelector(`label[for="${fileType}FileInput"]`);
    if (labelElement) {
        labelElement.style.opacity = '0.7';
    }
}

/**
 * Habilitar bot√£o de compara√ß√£o de refer√™ncia
 */
function enableReferenceComparison() {
    const compareButton = document.getElementById('compareButton');
    if (compareButton) {
        compareButton.disabled = false;
        compareButton.style.opacity = '1';
        compareButton.style.cursor = 'pointer';
    }
    
    // Atualizar indicador visual
    const indicator = document.querySelector('.reference-ready-indicator');
    if (indicator) {
        indicator.style.display = 'block';
    }
}


/**
 * Mostrar mensagem do pr√≥ximo passo
 * @param {string} message - Mensagem a ser exibida
 */
function showNextStepMessage(message) {
    console.log(`‚û°Ô∏è ${message}`);
    
    // Implementar notifica√ß√£o visual se necess√°rio
    const notification = document.createElement('div');
    notification.className = 'next-step-notification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    // Remover ap√≥s 5 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 5000);
}

// ÔøΩüéØ NOVO: Valida√ß√£o comum de arquivo
function validateAudioFile(file) {
    const MAX_UPLOAD_MB = 60;
    const MAX_UPLOAD_SIZE = MAX_UPLOAD_MB * 1024 * 1024;
    
    // Formatos aceitos: WAV, FLAC, MP3 (simplificado)
    const allowedTypes = ['audio/wav', 'audio/flac', 'audio/mpeg', 'audio/mp3'];
    const allowedExtensions = ['.wav', '.flac', '.mp3'];
    
    // Validar tipo de arquivo
    const isValidType = allowedTypes.includes(file.type.toLowerCase()) || 
                       allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
    
    if (!isValidType) {
        showModalError(`Formato n√£o suportado. Apenas WAV, FLAC e MP3 s√£o aceitos.
                      üí° Prefira WAV ou FLAC para maior precis√£o na an√°lise.`);
        return false;
    }
    
    // Validar tamanho (novo limite: 60MB)
    if (file.size > MAX_UPLOAD_SIZE) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        showModalError(`Arquivo muito grande: ${sizeInMB}MB. 
                      Limite m√°ximo: ${MAX_UPLOAD_MB}MB.`);
        return false;
    }
    
    // üéµ WAV MOBILE WARNING: Avisar sobre demora em arquivos WAV grandes no mobile
    const isWAV = file.name.toLowerCase().endsWith('.wav') || file.type.includes('wav');
    const isMobile = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
    const isLargeWAV = isWAV && file.size > 20 * 1024 * 1024; // >20MB
    
    if (isLargeWAV && isMobile) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        const estimatedTime = Math.ceil(file.size / (2 * 1024 * 1024)); // ~2MB/s no mobile
        
        console.warn(`‚è±Ô∏è WAV grande no mobile: ${sizeInMB}MB - tempo estimado: ${estimatedTime}s`);
        
        // Mostrar aviso n√£o-bloqueante
        setTimeout(() => {
            if (document.getElementById('audioProgressText')) {
                document.getElementById('audioProgressText').innerHTML = 
                    `‚è±Ô∏è Arquivo WAV grande (${sizeInMB}MB)<br>Tempo estimado: ${estimatedTime}-${estimatedTime*2}s<br>Aguarde...`;
            }
        }, 1000);
    }
    
    // Mostrar recomenda√ß√£o para MP3
    if (file.type === 'audio/mpeg' || file.type === 'audio/mp3' || file.name.toLowerCase().endsWith('.mp3')) {
        console.log('üí° MP3 detectado - Recomenda√ß√£o: Use WAV ou FLAC para maior precis√£o');
    }
    
    return true;
}

// üéØ NOVO: Processar arquivo no modo refer√™ncia
async function handleReferenceFileSelection(file) {
    window.logReferenceEvent('reference_file_selected', { 
        step: referenceStepState.currentStep,
        fileName: file.name,
        fileSize: file.size 
    });
    
    if (referenceStepState.currentStep === 'userAudio') {
        // Primeiro arquivo: m√∫sica do usu√°rio
        referenceStepState.userAudioFile = file;
        
        // üêõ DIAGN√ìSTICO: Verificar se est√° carregando dados de g√™nero no modo refer√™ncia
        console.log('üîç [DIAGN√ìSTICO] Analisando USER audio em modo refer√™ncia');
        console.log('üîç [DIAGN√ìSTICO] Current mode:', window.currentAnalysisMode);
        console.log('üîç [DIAGN√ìSTICO] Genre ativo antes da an√°lise:', window.PROD_AI_REF_GENRE);
        console.log('üîç [DIAGN√ìSTICO] Active ref data:', !!__activeRefData);
        
        // Analisar arquivo do usu√°rio
        showModalLoading();
        updateModalProgress(10, 'üéµ Analisando sua m√∫sica...');
        
        // üéØ CORRE√á√ÉO TOTAL: Analisar arquivo do usu√°rio SEM aplicar targets
        const userAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem compara√ß√µes
          debugModeReference: true,
          // Garantir mesmas configura√ß√µes para ambos os arquivos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // üÜî CORRE√á√ÉO: Preparar options com runId
        const userOptionsWithRunId = prepareAnalysisOptions(userAnalysisOptions, 'user_ref');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, userOptionsWithRunId);
        
        // üêõ VALIDA√á√ÉO: Verificar que n√£o h√° compara√ß√£o com g√™nero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('‚ö†Ô∏è [AVISO] An√°lise do usu√°rio contaminada com compara√ß√£o/score');
        }
        
        console.log('üîç [DIAGN√ìSTICO] User analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        referenceStepState.userAnalysis = analysis;
        
        // Avan√ßar para pr√≥ximo step
        updateReferenceStep('referenceAudio');
        updateUploadAreaForReferenceStep();
        
        window.logReferenceEvent('user_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
        
    } else if (referenceStepState.currentStep === 'referenceAudio') {
        // Segundo arquivo: m√∫sica de refer√™ncia
        referenceStepState.referenceAudioFile = file;
        
        // üêõ DIAGN√ìSTICO: Verificar an√°lise do arquivo de refer√™ncia
        console.log('üîç [DIAGN√ìSTICO] Analisando REFERENCE audio em modo refer√™ncia');
        console.log('üîç [DIAGN√ìSTICO] Current mode:', window.currentAnalysisMode);
        console.log('üîç [DIAGN√ìSTICO] Genre ativo antes da an√°lise:', window.PROD_AI_REF_GENRE);
        
        // Analisar arquivo de refer√™ncia (extra√ß√£o de m√©tricas com MESMAS configura√ß√µes)
        showModalLoading();
        updateModalProgress(50, 'üéØ Analisando m√∫sica de refer√™ncia...');
        
        // üéØ CORRE√á√ÉO TOTAL: Usar EXATAMENTE as mesmas configura√ß√µes do usu√°rio
        const refAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem compara√ß√µes
          debugModeReference: true,
          // üéØ GARANTIR par√¢metros id√™nticos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // üÜî CORRE√á√ÉO: Preparar options com runId
        const refOptionsWithRunId = prepareAnalysisOptions(refAnalysisOptions, 'ref_audio');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, refOptionsWithRunId);
        
        // üêõ VALIDA√á√ÉO: Verificar que n√£o h√° compara√ß√£o com g√™nero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('‚ö†Ô∏è [AVISO] An√°lise da refer√™ncia contaminada com compara√ß√£o/score');
        }
        
        console.log('üîç [DIAGN√ìSTICO] Reference analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        // üéØ VALIDA√á√ÉO: Verificar se conseguimos extrair m√©tricas v√°lidas
        const referenceMetrics = {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp
        };
        
        // üö® ERRO CLARO: Falhar se n√£o conseguir extrair m√©tricas
        if (!Number.isFinite(referenceMetrics.lufs)) {
          throw new Error('REFERENCE_METRICS_FAILED: N√£o foi poss√≠vel extrair m√©tricas LUFS da m√∫sica de refer√™ncia. Verifique se o arquivo √© v√°lido.');
        }
        
        if (!Number.isFinite(referenceMetrics.stereoCorrelation)) {
          throw new Error('REFERENCE_METRICS_FAILED: N√£o foi poss√≠vel extrair correla√ß√£o est√©reo da m√∫sica de refer√™ncia.');
        }
        
        console.log('‚úÖ [SUCESSO] M√©tricas da refer√™ncia extra√≠das:', referenceMetrics);
        
        referenceStepState.referenceAnalysis = analysis;
        referenceStepState.referenceMetrics = referenceMetrics;
        
        // Executar compara√ß√£o
        updateReferenceStep('analysis');
        await performReferenceComparison();
        
        // üéØ EXIBIR resultados da an√°lise por refer√™ncia
        const finalAnalysis = referenceStepState.finalAnalysis;
        
        updateModalProgress(100, '‚úÖ An√°lise por refer√™ncia conclu√≠da!');
        
        // üéØ LOGS finais de valida√ß√£o
        console.log('üéâ [AN√ÅLISE POR REFER√äNCIA] Conclu√≠da com sucesso:');
        console.log('  - Baseline source:', finalAnalysis.comparison?.baseline_source);
        console.log('  - LUFS difference:', finalAnalysis.comparison?.loudness?.difference?.toFixed(2));
        console.log('  - Sugest√µes:', finalAnalysis.suggestions?.length || 0);
        console.log('  - Sem g√™nero:', !finalAnalysis.genre);
        
        // Exibir modal de resultados
        displayReferenceResults(finalAnalysis);
        
        window.logReferenceEvent('reference_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
    }
}

// üéØ NOVO: Processar arquivo no modo g√™nero (comportamento original)
async function handleGenreFileSelection(file) {
    // üêõ DIAGN√ìSTICO: Confirmar que este √© o modo g√™nero
    console.log('üîç [DIAGN√ìSTICO] handleGenreFileSelection - modo:', window.currentAnalysisMode);
    console.log('üîç [DIAGN√ìSTICO] Este deveria ser APENAS modo g√™nero!');
    
    __dbg('üîÑ Iniciando nova an√°lise - for√ßando exibi√ß√£o do loading');
    showModalLoading();
    updateModalProgress(10, '‚ö° Carregando Algoritmos Avan√ßados...');
    
    // Aguardar audio analyzer carregar se necess√°rio
    if (!window.audioAnalyzer) {
        __dbg('‚è≥ Aguardando Audio Analyzer carregar...');
        updateModalProgress(30, 'üîß Inicializando V2 Engine...');
        await waitForAudioAnalyzer();
    }

    // üêõ CORRE√á√ÉO CR√çTICA: S√≥ carregar refer√™ncias de g√™nero se estivermos NO MODO G√äNERO
    if (window.currentAnalysisMode === 'genre') {
        // üéØ FALLBACK SEGURO: Restaurar g√™nero do localStorage se n√£o estiver setado
        if (!window.PROD_AI_REF_GENRE) {
            const savedGenre = localStorage.getItem('prodai_ref_genre');
            if (savedGenre) {
                console.log('üîß [GENRE-FALLBACK] Restaurando g√™nero do localStorage:', savedGenre);
                window.PROD_AI_REF_GENRE = savedGenre;
            } else {
                console.error('‚ùå [GENRE-CRITICAL] G√™nero n√£o encontrado - modo g√™nero sem targets');
            }
        }
        
        // üéØ CORRE√á√ÉO CR√çTICA: RESETAR ESTADO DE REFER√äNCIA ANTES DE CARREGAR TARGETS DE G√äNERO
        // üéØ PRESERVAR G√äNERO durante o reset
        const currentGenre = window.PROD_AI_REF_GENRE || window.__CURRENT_GENRE;
        console.log('üßπ [GENRE-MODE] Resetando estado de refer√™ncia antes de carregar targets...');
        console.log('üßπ [GENRE-MODE] G√™nero preservado:', currentGenre);
        resetReferenceStateFully(currentGenre);
        
        // Garantir que refer√™ncias do g√™nero selecionado estejam carregadas antes da an√°lise
        try {
            const genre = window.PROD_AI_REF_GENRE;
            console.log('üîç [DIAGN√ìSTICO] Carregando refer√™ncias de g√™nero:', genre);
            
            // ‚úÖ CORRE√á√ÉO: Sempre carregar targets se g√™nero existir
            if (genre) {
                updateModalProgress(25, `üìö Carregando refer√™ncias: ${genre}...`);
                await loadReferenceData(genre);
                updateModalProgress(30, 'üìö Refer√™ncias ok');
                
                // ‚úÖ VALIDA√á√ÉO: Confirmar que targets foram carregados
                if (!window.__activeRefData) {
                    console.error('‚ùå [GENRE-CRITICAL] Falha ao carregar targets de g√™nero');
                } else {
                    console.log('‚úÖ [GENRE-SUCCESS] Targets carregados:', {
                        genre,
                        hasBands: !!window.__activeRefData.bands,
                        lufsTarget: window.__activeRefData.lufs_target
                    });
                }
            }
        } catch (e) { 
            console.error('‚ùå [GENRE-ERROR] Erro ao carregar refer√™ncias de g√™nero:', e);
        }
    } else {
        console.log('üîç [DIAGN√ìSTICO] PULAR carregamento de refer√™ncias - modo n√£o √© g√™nero');
    }
    
    // Analisar arquivo
    __dbg('üî¨ Iniciando an√°lise...');
    updateModalProgress(40, 'üéµ Processando Waveform Digital...');
    
    // ÔøΩ WAV MOBILE OPTIMIZATION: Aplicar otimiza√ß√µes espec√≠ficas para WAV
    try {
        // Carregar otimizador WAV se n√£o estiver dispon√≠vel
        if (typeof window.wavMobileOptimizer === 'undefined') {
            const optimizerScript = document.createElement('script');
            optimizerScript.src = '/lib/audio/wav-mobile-optimizer.js';
            optimizerScript.type = 'module';
            document.head.appendChild(optimizerScript);
            
            // Aguardar carregamento com timeout
            await new Promise((resolve) => {
                optimizerScript.onload = () => {
                    console.log('üéµ WAV optimizer carregado');
                    resolve();
                };
                optimizerScript.onerror = () => {
                    console.warn('‚ö†Ô∏è WAV optimizer falhou ao carregar');
                    resolve();
                };
                setTimeout(resolve, 1500); // fallback timeout
            });
        }
        
        // Aplicar otimiza√ß√µes se dispon√≠vel
        if (window.wavMobileOptimizer) {
            const wavAnalysis = window.wavMobileOptimizer.applyWAVOptimizations(file);
            if (wavAnalysis.requiresOptimization) {
                updateModalProgress(45, `üéµ WAV ${wavAnalysis.sizeInMB}MB - otimiza√ß√£o mobile ativa...`);
                console.log('üéµ WAV mobile optimizations applied:', wavAnalysis);
            }
        }
    } catch (optimizerError) {
        console.warn('‚ö†Ô∏è WAV optimizer failed, continuing with standard processing:', optimizerError);
    }
    
    // ÔøΩüéØ CORRE√á√ÉO: Passar modo correto para an√°lise
    const analysisOptions = { 
      mode: window.currentAnalysisMode || 'genre' 
    };
    // üÜî CORRE√á√ÉO: Preparar options com runId para an√°lise principal
    const optionsWithRunId = prepareAnalysisOptions(analysisOptions, 'main');
    const analysis = await window.audioAnalyzer.analyzeAudioFile(file, optionsWithRunId);
    currentModalAnalysis = analysis;
    
    // üéµ WAV CLEANUP: Limpar otimiza√ß√µes WAV ap√≥s conclus√£o
    try {
        if (window.wavMobileOptimizer) {
            window.wavMobileOptimizer.cleanupWAVOptimizations();
        }
    } catch (cleanupError) {
        console.warn('WAV cleanup error (non-critical):', cleanupError);
    }
    
    __dbg('‚úÖ An√°lise conclu√≠da:', analysis);
    
    updateModalProgress(90, 'üß† Computando M√©tricas Avan√ßadas...');
    
    // Aguardar um pouco para melhor UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    updateModalProgress(100, '‚ú® An√°lise Completa - Pronto!');
    
    // Mostrar resultados
    setTimeout(() => {
        // üîí FASE 2 UI GATE: Verificar se an√°lise ainda √© v√°lida
        const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
        const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
        
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`üö´ [UI_GATE] An√°lise cancelada - n√£o renderizar UI (an√°lise: ${analysisRunId}, atual: ${currentRunId})`);
            return;
        }
        
        // Telemetria: verificar elementos alvo antes de preencher o modal
        const exists = {
            audioUploadArea: !!document.getElementById('audioUploadArea'),
            audioAnalysisLoading: !!document.getElementById('audioAnalysisLoading'),
            audioAnalysisResults: !!document.getElementById('audioAnalysisResults'),
            modalTechnicalData: !!document.getElementById('modalTechnicalData')
        };
        __dbg('üõ∞Ô∏è [Telemetry] Front antes de preencher modal (exist√™ncia de elementos):', exists);
        
        // üîí UI GATE: Verificar novamente antes de renderizar
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`üö´ [UI_GATE] Verifica√ß√£o dupla - an√°lise cancelada durante delay`);
            return;
        }
        
        // üõ°Ô∏è VERIFICA√á√ÉO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            displayModalResults(analysis);
        } else {
            console.warn('‚ö†Ô∏è [MODAL_MONITOR] Fun√ß√£o displayModalResults n√£o encontrada, aguardando carregamento...');
            // Tentar novamente em 1 segundo
            setTimeout(() => {
                if (typeof displayModalResults === 'function') {
                    displayModalResults(analysis);
                } else {
                    console.error('‚ùå [MODAL_MONITOR] Timeout - fun√ß√£o displayModalResults n√£o encontrada ap√≥s espera');
                }
            }, 1000);
        }
        
        // üîß CORRE√á√ÉO: Limpar flag de an√°lise em progresso ap√≥s sucesso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('‚úÖ An√°lise conclu√≠da com sucesso - flag removida');
    }, 800);
}

// üéØ NOVO: Atualizar upload area para step de refer√™ncia
function updateUploadAreaForReferenceStep() {
    const uploadArea = document.getElementById('audioUploadArea');
    if (!uploadArea) return;
    
    const uploadContent = uploadArea.querySelector('.upload-content');
    if (!uploadContent) return;
    
    // Limpar input de arquivo
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) {
        fileInput.value = '';
    }
    
    // Atualizar conte√∫do baseado no step
    if (referenceStepState.currentStep === 'referenceAudio') {
        const icon = uploadContent.querySelector('.upload-icon');
        const title = uploadContent.querySelector('h4');
        const description = uploadContent.querySelector('p:not(.supported-formats):not(.format-recommendation)');
        
        if (icon) icon.textContent = 'üéØ';
        if (title) title.textContent = 'M√∫sica de Refer√™ncia';
        if (description) description.textContent = 'Agora selecione a m√∫sica que servir√° como refer√™ncia para compara√ß√£o';
    }
    
    // Mostrar upload area novamente
    uploadArea.style.display = 'block';
    
    // Esconder loading
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) loading.style.display = 'none';
    
    window.logReferenceEvent('upload_area_updated', { 
        step: referenceStepState.currentStep 
    });
}

// üéØ REESCRITA COMPLETA: Compara√ß√£o baseada exclusivamente na refer√™ncia
async function performReferenceComparison() {
    window.logReferenceEvent('reference_comparison_started');
    
    try {
        updateModalProgress(70, 'üîÑ Comparando as duas m√∫sicas...');
        
        const userAnalysis = referenceStepState.userAnalysis;
        const refAnalysis = referenceStepState.referenceAnalysis;
        const referenceMetrics = referenceStepState.referenceMetrics;
        
        if (!userAnalysis || !refAnalysis || !referenceMetrics) {
            throw new Error('COMPARISON_DATA_MISSING: An√°lises ou m√©tricas de refer√™ncia n√£o encontradas');
        }
        
        // üéØ EXTRAIR m√©tricas do usu√°rio (an√°lise pura, sem compara√ß√µes)
        const userMetrics = {
            lufs: userAnalysis.technicalData?.lufsIntegrated,
            stereoCorrelation: userAnalysis.technicalData?.stereoCorrelation,
            dynamicRange: userAnalysis.technicalData?.dynamicRange,
            truePeak: userAnalysis.technicalData?.truePeakDbtp
        };
        
        // üö® VALIDA√á√ÉO: Verificar m√©tricas do usu√°rio
        if (!Number.isFinite(userMetrics.lufs)) {
            throw new Error('USER_METRICS_FAILED: N√£o foi poss√≠vel extrair m√©tricas LUFS da sua m√∫sica');
        }
        
        console.log('üîç [COMPARA√á√ÉO] M√©tricas extra√≠das:');
        console.log('  - Usu√°rio:', userMetrics);
        console.log('  - Refer√™ncia:', referenceMetrics);
        
        // üéØ CALCULAR diferen√ßas PURAS (refer√™ncia como baseline)
        const differences = {
            lufs: userMetrics.lufs - referenceMetrics.lufs,
            stereoCorrelation: userMetrics.stereoCorrelation - referenceMetrics.stereoCorrelation,
            dynamicRange: userMetrics.dynamicRange - referenceMetrics.dynamicRange,
            truePeak: userMetrics.truePeak - referenceMetrics.truePeak
        };
        
        console.log('üîç [COMPARA√á√ÉO] Diferen√ßas calculadas:', differences);
        
        // üéØ GERAR sugest√µes baseadas APENAS na refer√™ncia
        const referenceSuggestions = [];
        const THRESHOLD = 0.2; // Ignorar diferen√ßas menores que 0.2dB
        
        // Loudness (LUFS) - üö® COM VERIFICA√á√ÉO DE HEADROOM SEGURO
        if (Math.abs(differences.lufs) > THRESHOLD) {
            const action = differences.lufs > 0 ? 'Diminuir' : 'Aumentar';
            const direction = differences.lufs > 0 ? 'decrease' : 'increase';
            const adjustmentDb = Math.abs(differences.lufs);
            
            // üîí Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                const userTruePeak = userMetrics.truePeak;
                const clippingSamples = userAnalysis.technical?.clippingSamples || 0;
                const isClipped = clippingSamples > 0;
                const headroomSafetyMargin = -0.6; // Target true peak seguro
                
                // üö® REGRA 1: Se CLIPPED, n√£o sugerir aumento
                if (isClipped) {
                    console.log(`[REF-HEADROOM] üö® Clipping detectado - n√£o sugerindo aumento de ${adjustmentDb.toFixed(1)}dB`);
                    referenceSuggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: `Imposs√≠vel igualar refer√™ncia - √°udio tem clipping`,
                        action: `Primeiro resolver clipping, depois ajustar para refer√™ncia`,
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        baseline_source: 'reference_audio',
                        warning: `Clipping detectado (${clippingSamples} samples)`
                    });
                } 
                // üö® REGRA 2: Verificar headroom dispon√≠vel
                else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        referenceSuggestions.push({
                            type: 'reference_loudness',
                            message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar √† m√∫sica de refer√™ncia`,
                            action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            baseline_source: 'reference_audio',
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB dispon√≠vel`
                        });
                    } else {
                        console.log(`[REF-HEADROOM] ‚ö†Ô∏è Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB - bloqueando`);
                        referenceSuggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: `Imposs√≠vel igualar refer√™ncia - sem headroom suficiente`,
                            action: `True Peak ${userTruePeak.toFixed(1)}dBTP permite apenas +${availableHeadroom.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            baseline_source: 'reference_audio',
                            warning: `Necess√°rio ${adjustmentDb.toFixed(1)}dB mas s√≥ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    referenceSuggestions.push({
                        type: 'reference_loudness_conservative',
                        message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar refer√™ncia (verificar clipping)`,
                        action: `${action} volume CUIDADOSAMENTE em ${adjustmentDb.toFixed(1)}dB`,
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        baseline_source: 'reference_audio',
                        warning: 'Sem dados True Peak - verifique clipping ap√≥s ajuste'
                    });
                }
            } else {
                // Diminuir √© sempre seguro
                referenceSuggestions.push({
                    type: 'reference_loudness',
                    message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar √† m√∫sica de refer√™ncia`,
                    action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction,
                    baseline_source: 'reference_audio'
                });
            }
        }
        
        // Dynamic Range
        if (Math.abs(differences.dynamicRange) > THRESHOLD) {
            const action = differences.dynamicRange > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_dynamics',
                message: `${action} range din√¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB para igualar √† refer√™ncia`,
                action: `${action} range din√¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.dynamicRange),
                baseline_source: 'reference_audio'
            });
        }
        
        // Stereo Correlation
        if (Math.abs(differences.stereoCorrelation) > 0.05) { // 5% threshold para correla√ß√£o
            const action = differences.stereoCorrelation > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_stereo',
                message: `${action} correla√ß√£o est√©reo para igualar √† refer√™ncia (diferen√ßa: ${(differences.stereoCorrelation * 100).toFixed(1)}%)`,
                action: `Ajustar correla√ß√£o est√©reo`,
                frequency_range: 'N/A',
                baseline_source: 'reference_audio'
            });
        }
        
        // Pico Real
        if (Math.abs(differences.truePeak) > THRESHOLD) {
            const action = differences.truePeak > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_peak',
                message: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB para igualar √† refer√™ncia`,
                action: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.truePeak),
                baseline_source: 'reference_audio'
            });
        }
        
        console.log(`üîç [COMPARA√á√ÉO] Sugest√µes geradas: ${referenceSuggestions.length}`);
        
        // üéØ CRIAR an√°lise final com compara√ß√£o pura
        const finalAnalysis = {
            ...userAnalysis,
            comparison: {
                mode: 'reference',
                baseline_source: 'reference_audio',
                loudness: {
                    user: userMetrics.lufs,
                    reference: referenceMetrics.lufs,
                    difference: differences.lufs,
                    baseline: referenceMetrics.lufs
                },
                dynamics: {
                    user: userMetrics.dynamicRange,
                    reference: referenceMetrics.dynamicRange,
                    difference: differences.dynamicRange,
                    baseline: referenceMetrics.dynamicRange
                },
                stereo: {
                    user: userMetrics.stereoCorrelation,
                    reference: referenceMetrics.stereoCorrelation,
                    difference: differences.stereoCorrelation,
                    baseline: referenceMetrics.stereoCorrelation
                },
                peak: {
                    user: userMetrics.truePeak,
                    reference: referenceMetrics.truePeak,
                    difference: differences.truePeak,
                    baseline: referenceMetrics.truePeak
                }
            },
            suggestions: referenceSuggestions,
            // üö´ NUNCA usar g√™nero em modo refer√™ncia
            genre: null,
            mixScore: null, // N√£o gerar score baseado em g√™nero
            mixClassification: null
        };
        
        // üéØ LOGS de valida√ß√£o final
        console.log('üéâ [SUCESSO] Compara√ß√£o por refer√™ncia conclu√≠da:');
        console.log('  - Modo:', finalAnalysis.comparison.mode);
        console.log('  - Baseline source:', finalAnalysis.comparison.baseline_source);
        console.log('  - Sugest√µes:', referenceSuggestions.length);
        console.log('  - Sem contamina√ß√£o de g√™nero:', !finalAnalysis.genre);
        
        referenceStepState.finalAnalysis = finalAnalysis;
        console.log('üîç [DIAGN√ìSTICO] Reference analysis tem compara√ß√£o com g√™nero:', !!refAnalysis.comparison);
        
        // üéØ NOVO: Verificar se an√°lises est√£o "limpas" (sem contaminar com g√™nero)
        const userClean = !userAnalysis.comparison && !userAnalysis.reference;
        const refClean = !refAnalysis.comparison && !refAnalysis.reference;
        console.log('üîç [DIAGN√ìSTICO] User analysis clean (sem g√™nero):', userClean);
        console.log('üîç [DIAGN√ìSTICO] Reference analysis clean (sem g√™nero):', refClean);
        
        // Gerar compara√ß√£o
        const comparison = generateComparison(userAnalysis, refAnalysis);
        
        // üêõ DIAGN√ìSTICO: Verificar se comparison est√° usando os dados corretos
        console.log('üîç [DIAGN√ìSTICO] Comparison gerada:', comparison);
        console.log('üîç [DIAGN√ìSTICO] baseline_source: reference_audio (confirmed)');
        
        // Gerar sugest√µes baseadas na compara√ß√£o
        const suggestions = generateReferenceSuggestions(comparison);
        
        // üêõ DIAGN√ìSTICO: Verificar se sugest√µes s√£o baseadas apenas na comparison
        console.log('üîç [DIAGN√ìSTICO] Sugest√µes geradas (count):', suggestions.length);
        console.log('üîç [DIAGN√ìSTICO] Primeiro tipo de sugest√£o:', suggestions[0]?.type);
        
        // Criar an√°lise combinada para exibi√ß√£o
        const combinedAnalysis = {
            ...userAnalysis,
            comparison,
            suggestions: [...(userAnalysis.suggestions || []), ...suggestions],
            analysisMode: 'reference',
            referenceFile: referenceStepState.referenceAudioFile.name,
            userFile: referenceStepState.userAudioFile.name,
            // üéØ NOVO: Incluir m√©tricas da refer√™ncia para renderReferenceComparisons
            referenceMetrics: {
                lufs: refAnalysis.technicalData?.lufsIntegrated,
                truePeakDbtp: refAnalysis.technicalData?.truePeakDbtp,
                dynamicRange: refAnalysis.technicalData?.dynamicRange,
                lra: refAnalysis.technicalData?.lra,
                stereoCorrelation: refAnalysis.technicalData?.stereoCorrelation,
                // üîß CORRE√á√ÉO: Criar estrutura de bands compat√≠vel
                bands: refAnalysis.technicalData?.bandEnergies ? (() => {
                    const refBands = {};
                    const refBandEnergies = refAnalysis.technicalData.bandEnergies;
                    
                    // Criar estrutura de bands usando as m√©tricas da refer√™ncia como targets
                    Object.entries(refBandEnergies).forEach(([bandName, bandData]) => {
                        if (bandData && Number.isFinite(bandData.rms_db)) {
                            refBands[bandName] = {
                                target_db: bandData.rms_db,  // Usar valor da refer√™ncia como target
                                tol_db: 3.0,  // Toler√¢ncia padr√£o
                                _target_na: false
                            };
                        }
                    });
                    
                    return refBands;
                })() : null
            },
            // üêõ DIAGN√ìSTICO: Adicionar metadados para diagn√≥stico
            _diagnostic: {
                baseline_source: 'reference_audio',
                mode: 'reference',
                userLufs: userAnalysis.technicalData?.lufsIntegrated,
                referenceLufs: refAnalysis.technicalData?.lufsIntegrated,
                difference: comparison.loudness?.difference,
                genreActive: window.PROD_AI_REF_GENRE,
                useGenreTargets: false,
                // üéØ NOVO: Informa√ß√µes de normaliza√ß√£o e janela
                usedWindowSeconds: 30, // TODO: pegar do analyzer quando implementado
                normalizedLUFS: {
                    user: userAnalysis.technicalData?.lufsIntegrated,
                    ref: refAnalysis.technicalData?.lufsIntegrated
                },
                analysisTimestamp: new Date().toISOString()
            }
        };
        
        console.log('üîç [DIAGN√ìSTICO] Combined analysis diagnostic:', combinedAnalysis._diagnostic);
        
        currentModalAnalysis = combinedAnalysis;
        
        // üéØ ALIAS GLOBAL PARA RELAT√ìRIOS (Modo Refer√™ncia)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = combinedAnalysis;
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = combinedAnalysis;
            
            console.log('‚úÖ [PDF-READY] Compara√ß√£o armazenada globalmente:', {
                mode: 'reference',
                hasComparison: !!combinedAnalysis.comparison,
                userFile: combinedAnalysis.userFile,
                referenceFile: combinedAnalysis.referenceFile
            });
        }
        
        updateModalProgress(100, '‚ú® Compara√ß√£o Completa!');
        
        // Mostrar resultados
        setTimeout(() => {
            // üîí UI GATE: Verificar se an√°lise ainda √© v√°lida
            const analysisRunId = combinedAnalysis?.runId || combinedAnalysis?.metadata?.runId;
            const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
            
            if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                console.warn(`üö´ [UI_GATE] Compara√ß√£o cancelada - n√£o renderizar UI (an√°lise: ${analysisRunId}, atual: ${currentRunId})`);
                return;
            }
            
            displayModalResults(combinedAnalysis);
            window.logReferenceEvent('reference_comparison_completed');
        }, 800);
        
    } catch (error) {
        console.error('‚ùå Erro na compara√ß√£o:', error);
        window.logReferenceEvent('reference_comparison_error', { error: error.message });
        showModalError(`Erro na compara√ß√£o: ${error.message}`);
    }
}

// üéØ NOVO: Gerar compara√ß√£o entre duas an√°lises
function generateComparison(userAnalysis, refAnalysis) {
    const userTech = userAnalysis.technicalData || {};
    const refTech = refAnalysis.technicalData || {};
    
    return {
        loudness: {
            user: userTech.lufsIntegrated || null,
            reference: refTech.lufsIntegrated || null,
            difference: (userTech.lufsIntegrated && refTech.lufsIntegrated) 
                ? userTech.lufsIntegrated - refTech.lufsIntegrated 
                : null
        },
        dynamics: {
            user: userTech.lra || userTech.crestFactor || null,
            reference: refTech.lra || refTech.crestFactor || null,
            difference: (userTech.lra && refTech.lra) 
                ? userTech.lra - refTech.lra 
                : null
        },
        stereo: {
            user: userTech.stereoCorrelation || null,
            reference: refTech.stereoCorrelation || null,
            difference: (userTech.stereoCorrelation && refTech.stereoCorrelation) 
                ? userTech.stereoCorrelation - refTech.stereoCorrelation 
                : null
        },
        spectral: compareSpectralData(userTech, refTech)
    };
}

// üéØ NOVO: Comparar dados espectrais
function compareSpectralData(userTech, refTech) {
    const bandNames = ['subBass', 'bass', 'lowMid', 'mid', 'upperMid', 'presence', 'brilliance', 'air'];
    const comparisons = {};
    
    bandNames.forEach(band => {
        const userValue = userTech[`${band}Energy`] || userTech[`energy_${band}`] || null;
        const refValue = refTech[`${band}Energy`] || refTech[`energy_${band}`] || null;
        
        if (userValue !== null && refValue !== null) {
            comparisons[band] = {
                user: userValue,
                reference: refValue,
                difference: userValue - refValue
            };
        }
    });
    
    return comparisons;
}

// üéØ NOVO: Gerar sugest√µes baseadas na compara√ß√£o
function generateReferenceSuggestions(comparison) {
    // üêõ DIAGN√ìSTICO: Logs para verificar fonte dos dados
    console.log('üîç [DIAGN√ìSTICO] generateReferenceSuggestions called with:', comparison);
    console.log('üîç [DIAGN√ìSTICO] Usando APENAS dados da comparison, n√£o genre targets');
    console.log('üîç [DIAGN√ìSTICO] Genre ativo (N√ÉO usado):', window.PROD_AI_REF_GENRE);
    
    const suggestions = [];
    
    // Sugest√µes de loudness - üö® COM VERIFICA√á√ÉO DE HEADROOM SEGURO
    if (comparison.loudness.difference !== null) {
        const diff = comparison.loudness.difference;
        console.log('üîç [DIAGN√ìSTICO] Loudness difference:', diff);
        
        if (Math.abs(diff) > 1) {
            const adjustmentDb = Math.abs(diff);
            const direction = diff > 0 ? 'decrease' : 'increase';
            
            // üîí Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                // Tentar acessar dados do usu√°rio para verifica√ß√£o de headroom
                const userTruePeak = comparison.userTruePeak || null;
                const userClipping = comparison.userClipping || 0;
                const isClipped = userClipping > 0;
                const headroomSafetyMargin = -0.6;
                
                if (isClipped) {
                    console.log(`[REF-HEADROOM] üö® Clipping detectado - bloqueando aumento de ${adjustmentDb.toFixed(1)}dB`);
                    suggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: 'Imposs√≠vel igualar refer√™ncia - √°udio tem clipping',
                        action: 'Primeiro resolver clipping, depois ajustar para refer√™ncia',
                        explanation: 'Clipping detectado impede aumento seguro',
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        warning: `Clipping detectado (${userClipping} samples)`
                    });
                } else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        const suggestion = {
                            type: 'reference_loudness',
                            message: 'Sua m√∫sica est√° mais baixa que a refer√™ncia',
                            action: `Aumentar volume em ${adjustmentDb.toFixed(1)}dB`,
                            explanation: 'Para match de loudness com a refer√™ncia',
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB dispon√≠vel`
                        };
                        suggestions.push(suggestion);
                    } else {
                        console.log(`[REF-HEADROOM] ‚ö†Ô∏è Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB`);
                        suggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: 'Imposs√≠vel igualar refer√™ncia - sem headroom suficiente',
                            action: `True Peak permite apenas +${availableHeadroom.toFixed(1)}dB (necess√°rio ${adjustmentDb.toFixed(1)}dB)`,
                            explanation: 'Aumentar mais causaria clipping (True Peak > -0.6 dBTP)',
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            warning: `Necess√°rio ${adjustmentDb.toFixed(1)}dB mas s√≥ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    suggestions.push({
                        type: 'reference_loudness_conservative',
                        message: 'Sua m√∫sica est√° mais baixa que a refer√™ncia (verificar clipping)',
                        action: `Aumentar CUIDADOSAMENTE volume em ${adjustmentDb.toFixed(1)}dB`,
                        explanation: 'Sem dados True Peak - risco de clipping',
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        warning: 'Verifique clipping ap√≥s ajuste'
                    });
                }
            } else {
                // Diminuir √© sempre seguro
                const suggestion = {
                    type: 'reference_loudness',
                    message: 'Sua m√∫sica est√° mais alta que a refer√™ncia',
                    action: `Diminuir volume em ${adjustmentDb.toFixed(1)}dB`,
                    explanation: 'Para match de loudness com a refer√™ncia',
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction
                };
                suggestions.push(suggestion);
            }
            
            console.log('üîç [DIAGN√ìSTICO] Sugest√£o de loudness processada com headroom check');
        }
    }
    
    // Sugest√µes espectrais
    Object.entries(comparison.spectral).forEach(([band, data]) => {
        console.log(`üîç [DIAGN√ìSTICO] Spectral band ${band}:`, data);
        
        if (Math.abs(data.difference) > 2) {
            const freqRanges = {
                subBass: '20-60 Hz',
                bass: '60-250 Hz',
                lowMid: '250-500 Hz',
                mid: '500-2k Hz',
                upperMid: '2k-4k Hz',
                presence: '4k-6k Hz',
                brilliance: '6k-12k Hz',
                air: '12k-20k Hz'
            };
            
            const suggestion = {
                type: 'reference_spectral',
                message: data.difference > 0 ? `Muito ${band} comparado √† refer√™ncia` : `Pouco ${band} comparado √† refer√™ncia`,
                action: data.difference > 0 ? `Cortar ${band}` : `Real√ßar ${band}`,
                explanation: `Para match espectral com a refer√™ncia`,
                frequency_range: freqRanges[band] || 'N/A',
                adjustment_db: Math.abs(data.difference),
                direction: data.difference > 0 ? 'cut' : 'boost',
                q_factor: 1.0
            };
            
            console.log(`üîç [DIAGN√ìSTICO] Adicionando sugest√£o espectral para ${band}:`, suggestion);
            suggestions.push(suggestion);
        }
    });
    
    console.log('üîç [DIAGN√ìSTICO] Total sugest√µes geradas:', suggestions.length);
    console.log('üîç [DIAGN√ìSTICO] baseline_source: reference_audio (confirmed)');
    
    return suggestions;
}

// üéØ NOVO: Adicionar se√ß√£o de compara√ß√£o com refer√™ncia
function addReferenceComparisonSection(analysis) {
    const results = document.getElementById('audioAnalysisResults');
    if (!results) return;
    
    const comparison = analysis.comparison;
    const userFile = analysis.userFile || 'Sua m√∫sica';
    const referenceFile = analysis.referenceFile || 'M√∫sica de refer√™ncia';
    
    // Criar se√ß√£o de compara√ß√£o
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'reference-comparison-section';
    comparisonSection.innerHTML = `
        <div class="comparison-header">
            <h4>üéØ Compara√ß√£o com Refer√™ncia</h4>
            <div class="comparison-files">
                <span class="file-indicator user">üìÑ ${userFile}</span>
                <span class="vs-indicator">vs</span>
                <span class="file-indicator reference">üéØ ${referenceFile}</span>
            </div>
        </div>
        
        <div class="comparison-content">
            <div class="comparison-grid">
                ${generateComparisonRow('Loudness', comparison.loudness, 'LUFS')}
                ${generateComparisonRow('Faixa Din√¢mica', comparison.dynamics, 'dB')}
                ${generateComparisonRow('Correla√ß√£o Est√©reo', comparison.stereo, '')}
            </div>
            
            ${comparison.spectral && Object.keys(comparison.spectral).length > 0 ? `
                <div class="spectral-comparison">
                    <h5>üìä An√°lise Espectral</h5>
                    <div class="spectral-grid">
                        ${Object.entries(comparison.spectral).map(([band, data]) => 
                            generateSpectralComparisonCard(band, data)
                        ).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
    
    // Inserir no in√≠cio da se√ß√£o de resultados
    const resultsHeader = results.querySelector('.results-header');
    if (resultsHeader) {
        resultsHeader.insertAdjacentElement('afterend', comparisonSection);
    } else {
        results.insertBefore(comparisonSection, results.firstChild);
    }
    
    window.logReferenceEvent('comparison_section_displayed');
}

// üéØ NOVO: Gerar linha de compara√ß√£o
function generateComparisonRow(label, comparisonData, unit) {
    if (!comparisonData || comparisonData.difference === null) {
        return `
            <div class="comparison-row unavailable">
                <div class="comparison-label">${label}</div>
                <div class="comparison-values">
                    <span class="comparison-unavailable">Dados insuficientes</span>
                </div>
            </div>
        `;
    }
    
    const userValue = comparisonData.user?.toFixed?.(1) || comparisonData.user || '‚Äî';
    const refValue = comparisonData.reference?.toFixed?.(1) || comparisonData.reference || '‚Äî';
    const diff = comparisonData.difference?.toFixed?.(1) || '‚Äî';
    const diffClass = comparisonData.difference > 0 ? 'positive' : comparisonData.difference < 0 ? 'negative' : 'neutral';
    
    return `
        <div class="comparison-row">
            <div class="comparison-label">${label}</div>
            <div class="comparison-values">
                <div class="value-pair">
                    <span class="user-value">${userValue}${unit}</span>
                    <span class="ref-value">${refValue}${unit}</span>
                </div>
                <div class="difference-indicator ${diffClass}">
                    ${diff > 0 ? '+' : ''}${diff}${unit}
                </div>
            </div>
        </div>
    `;
}

// üéØ NOVO: Gerar card de compara√ß√£o espectral
function generateSpectralComparisonCard(band, data) {
    const bandNames = {
        subBass: 'Sub Bass',
        bass: 'Bass',
        lowMid: 'Low Mid',
        mid: 'Mid',
        upperMid: 'Upper Mid',
        presence: 'Presence',
        brilliance: 'Brilliance',
        air: 'Air'
    };
    
    const friendlyName = bandNames[band] || band;
    const diff = data.difference?.toFixed?.(1) || '‚Äî';
    const diffClass = data.difference > 2 ? 'high-positive' : 
                      data.difference > 0.5 ? 'positive' : 
                      data.difference < -2 ? 'high-negative' : 
                      data.difference < -0.5 ? 'negative' : 'neutral';
    
    return `
        <div class="spectral-card ${diffClass}">
            <div class="spectral-band-name">${friendlyName}</div>
            <div class="spectral-difference">${diff > 0 ? '+' : ''}${diff}dB</div>
        </div>
    `;
}

// ‚è≥ Aguardar Audio Analyzer carregar
function waitForAudioAnalyzer() {
    return new Promise((resolve) => {
        if (window.audioAnalyzer) {
            resolve();
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (window.audioAnalyzer) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
        
        // Timeout ap√≥s 10 segundos
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
        }, 10000);
    });
}

// ÔøΩ Atualizar progresso no modal
function updateModalProgress(percentage, message) {
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
    
    if (progressText) {
        progressText.textContent = message || `${percentage}%`;
    }
    
    __dbg(`üìà Progresso: ${percentage}% - ${message}`);
}

// ‚ùå Mostrar erro no modal
function showModalError(message) {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    if (results) {
        results.style.display = 'block';
        results.innerHTML = `
            <div style="color: #ff4444; text-align: center; padding: 30px;">
                <div style="font-size: 3em; margin-bottom: 15px;">‚ö†Ô∏è</div>
                <h3 style="margin: 0 0 15px 0; color: #ff4444;">Erro na An√°lise</h3>
                <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">${message}</p>
                <button onclick="resetModalState()" style="
                    background: #ff4444; 
                    color: white; 
                    border: none; 
                    padding: 12px 25px; 
                    border-radius: 6px; 
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: background 0.3s;
                " onmouseover="this.style.background='#ff3333'" 
                   onmouseout="this.style.background='#ff4444'">
                    Tentar Novamente
                </button>
            </div>
        `;
    }
}

// ÔøΩüîÑ Mostrar loading no modal
function showModalLoading() {
    __dbg('üîÑ Exibindo tela de loading no modal...');
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    // üîß CORRE√á√ÉO: Garantir que o loading seja exibido corretamente
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('‚úÖ Upload area ocultada');
    }
    if (results) {
        results.style.display = 'none';
        __dbg('‚úÖ Results area ocultada');
    }
    if (loading) {
        loading.style.display = 'block';
        __dbg('‚úÖ Loading area exibida');
    } else {
        __dbg('‚ùå Elemento audioAnalysisLoading n√£o encontrado!');
    }
    
    // Reset progress
    updateModalProgress(0, 'üîÑ Inicializando Engine de An√°lise...');
    __dbg('‚úÖ Progresso resetado e loading configurado');
}

// üìà Simular progresso
// (fun√ß√£o de simula√ß√£o de progresso removida ‚Äî n√£o utilizada)

// üìä Mostrar resultados no modal
// üìä Mostrar resultados no modal
async function displayModalResults(analysis) {
    console.log('[DEBUG-DISPLAY] üß† In√≠cio displayModalResults()');
    
    // üî• FASE 2 - VALIDA√á√ÉO IMEDIATA: Verificar se genreTargets chegou at√© aqui
    console.group('[FASE2-VALIDATION] üéØ displayModalResults - ENTRADA');
    console.log('analysis.data.genreTargets:', analysis.data?.genreTargets ? '‚úÖ PRESENTE' : '‚ùå AUSENTE');
    if (analysis.data?.genreTargets) {
        console.log('  ‚Üí Keys:', Object.keys(analysis.data.genreTargets));
        console.log('  ‚Üí Has bands:', !!analysis.data.genreTargets.bands);
        if (analysis.data.genreTargets.bands) {
            console.log('  ‚Üí Band keys:', Object.keys(analysis.data.genreTargets.bands));
        }
    }
    console.groupEnd();
    
    // üî• VALIDA√á√ÉO FINAL OBRIGAT√ìRIA: Verificar dados essenciais ANTES de exibir modal
    console.log("\n\nüî•üî•üî• [AUDIT-FINAL-FRONT] VALIDA√á√ÉO COMPLETA üî•üî•üî•");
    console.log("[AUDIT-FINAL-FRONT]", {
        hasTechnicalData: !!analysis.technicalData,
        techKeys: Object.keys(analysis.technicalData || {}),
        techKeyCount: Object.keys(analysis.technicalData || {}).length,
        hasGenreTargets: !!analysis.data?.genreTargets,
        gtKeys: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets) : null,
        gtKeyCount: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets).length : 0,
        hasScore: analysis.score !== undefined && analysis.score !== null,
        scoreValue: analysis.score,
        hasMetadata: !!analysis.metadata,
        metadataKeys: analysis.metadata ? Object.keys(analysis.metadata).length : 0,
        // Campos essenciais de technicalData
        essentialFields: {
            lufsIntegrated: analysis.technicalData?.lufsIntegrated,
            truePeakDbtp: analysis.technicalData?.truePeakDbtp,
            dynamicRange: analysis.technicalData?.dynamicRange,
            spectral_balance: analysis.technicalData?.spectral_balance ? Object.keys(analysis.technicalData.spectral_balance).length : 0,
            stereoCorrelation: analysis.technicalData?.stereoCorrelation,
            lra: analysis.technicalData?.lra
        },
        // Campos essenciais de genreTargets
        genreTargetsFields: analysis.data?.genreTargets ? {
            lufs: analysis.data.genreTargets.lufs,
            true_peak: analysis.data.genreTargets.true_peak,
            dr: analysis.data.genreTargets.dr,
            spectral_bands: analysis.data.genreTargets.spectral_bands ? Object.keys(analysis.data.genreTargets.spectral_bands).length : 0
        } : null
    });
    
    // ‚ö†Ô∏è ALERTA se technicalData tiver menos de 10 campos
    if (analysis.technicalData && Object.keys(analysis.technicalData).length < 10) {
        console.error("[AUDIT-FINAL-FRONT] ‚ùå technicalData TEM POUCOS CAMPOS!");
        console.error("[AUDIT-FINAL-FRONT] Campos presentes:", Object.keys(analysis.technicalData));
        console.error("[AUDIT-FINAL-FRONT] MODAL PODE N√ÉO ABRIR CORRETAMENTE!");
    } else if (analysis.technicalData && Object.keys(analysis.technicalData).length >= 30) {
        console.log("[AUDIT-FINAL-FRONT] ‚úÖ technicalData COMPLETO com", Object.keys(analysis.technicalData).length, "campos");
    }
    
    if (!analysis.data?.genreTargets) {
        console.error("[AUDIT-FINAL-FRONT] ‚ùå genreTargets AUSENTE!");
        console.error("[AUDIT-FINAL-FRONT] Tabelas de compara√ß√£o N√ÉO v√£o funcionar!");
        
        // ü©π PATCH CR√çTICO: Tentar reconstruir genreTargets do estado global
        const mode = analysis.mode || 'single';
        if (mode === 'genre') {
            const genre = analysis.data?.genre || analysis.genre || window.__CURRENT_SELECTED_GENRE || window.__CURRENT_GENRE;
            const activeRef = window.__activeRefData || 
                             (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) || 
                             null;
            
            if (activeRef) {
                const reconstructedTargets = activeRef.bands || 
                                           activeRef.spectralBands || 
                                           activeRef.spectral_bands ||
                                           (activeRef.targets && (activeRef.targets.bands || activeRef.targets.spectral_bands)) || 
                                           null;
                
                if (reconstructedTargets) {
                    console.log('[GENRE-FLOW-PATCH] ‚úÖ genreTargets reconstru√≠do do estado global:', {
                        genre,
                        keys: Object.keys(reconstructedTargets),
                        source: 'window.__activeRefData'
                    });
                    
                    // Garantir que analysis.data exista e persistir genreTargets
                    analysis.data = analysis.data || {};
                    analysis.data.genreTargets = reconstructedTargets;
                    
                    console.log("[GENRE-FLOW-PATCH] ‚úÖ analysis.data.genreTargets restaurado com sucesso");
                }
            }
        }
    } else {
        console.log("[AUDIT-FINAL-FRONT] ‚úÖ genreTargets presente com", Object.keys(analysis.data.genreTargets).length, "campos");
    }
    
    console.log("üî•üî•üî• [AUDIT-FINAL-FRONT] FIM DA VALIDA√á√ÉO üî•üî•üî•\n\n");
    
    // üî• AUDITORIA CR√çTICA: Verificar technicalData DENTRO de displayModalResults
    console.log('\n\nüî•üî•üî• [AUDIT-TECHNICAL-DATA] DISPLAY ENTRY üî•üî•üî•');
    console.log('[AUDIT-TECHNICAL-DATA] analysis.technicalData:', {
      exists: !!analysis?.technicalData,
      type: typeof analysis?.technicalData,
      isEmpty: analysis?.technicalData && Object.keys(analysis.technicalData).length === 0,
      keys: analysis?.technicalData ? Object.keys(analysis.technicalData) : [],
      hasSampleFields: {
        lufsIntegrated: analysis?.technicalData?.lufsIntegrated,
        truePeakDbtp: analysis?.technicalData?.truePeakDbtp,
        dynamicRange: analysis?.technicalData?.dynamicRange,
        spectral_balance: !!analysis?.technicalData?.spectral_balance
      }
    });
    console.log('[AUDIT-TECHNICAL-DATA] analysis outros campos:', {
      hasScore: analysis?.score !== undefined,
      scoreValue: analysis?.score,
      hasClassification: !!analysis?.classification,
      hasData: !!analysis?.data,
      hasDataGenreTargets: !!analysis?.data?.genreTargets,
      jobId: analysis?.jobId,
      mode: analysis?.mode
    });
    console.log('üî•üî•üî• [AUDIT-TECHNICAL-DATA] END üî•üî•üî•\n\n');
    
    // üö® LOG DIAGN√ìSTICO: G√™nero ANTES de exibir modal
    console.log('[GENRE-BEFORE-DISPLAY] üéµ Estado do g√™nero:', {
        preservedGenre: window.__CURRENT_SELECTED_GENRE,
        analysisGenre: analysis?.genre,
        mode: window.__CURRENT_MODE__ || currentAnalysisMode,
        timestamp: new Date().toISOString()
    });

    // ========================================
    // ‚úÖ CORRE√á√ÉO 2: RESTAURA√á√ÉO DE DADOS DE REFER√äNCIA
    // ========================================
    // Verifica se dados de refer√™ncia foram perdidos e restaura do cache
    
    // üéØ CORRE√á√ÉO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
    console.group('üîç [AUDIT-LOCALSTORAGE] displayModalResults - Leitura de referenceJobId');
    console.log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - Antes: window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    console.log('   - Mode:', currentAnalysisMode);
    
    // üéØ USA FUN√á√ÉO SEGURA ao inv√©s de acesso direto
    const referenceJobId = getCorrectJobId('reference'); // Primeira m√∫sica
    
    console.log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
    console.trace('   - Stack trace:');
    console.groupEnd();
    
    if (referenceJobId && currentAnalysisMode === 'reference') {
        // Verificar se dados de refer√™ncia est√£o ausentes
        const hasReferenceData = window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__;
        const hasFirstAnalysisStore = FirstAnalysisStore.has();
        
        if (!hasReferenceData && !hasFirstAnalysisStore) {
            console.warn('[RESTORE] ‚ö†Ô∏è Dados de refer√™ncia ausentes - tentando restaurar do cache');
            console.log('[RESTORE] referenceJobId:', referenceJobId);
            
            // Tentar restaurar do AnalysisCache
            if (window.AnalysisCache && window.AnalysisCache.has(referenceJobId)) {
                const cachedReference = window.AnalysisCache.get(referenceJobId);
                
                if (cachedReference) {
                    console.log('[RESTORE] ‚úÖ Refer√™ncia encontrada no AnalysisCache');
                    
                    // Clone profundo para evitar contamina√ß√£o
                    const restoredReference = (typeof structuredClone === 'function')
                        ? structuredClone(cachedReference)
                        : JSON.parse(JSON.stringify(cachedReference));
                    
                    // Restaurar para FirstAnalysisStore
                    if (FirstAnalysisStore && typeof FirstAnalysisStore.set === 'function') {
                        FirstAnalysisStore.set(restoredReference);
                        console.log('[RESTORE] ‚úÖ Refer√™ncia restaurada no FirstAnalysisStore');
                    }
                    
                    // Restaurar window.referenceAnalysisData
                    window.referenceAnalysisData = restoredReference;
                    window.__FIRST_ANALYSIS_FROZEN__ = Object.freeze(restoredReference);
                    
                    console.log('[RESTORE] ‚úÖ Dados de refer√™ncia completamente restaurados:', {
                        jobId: restoredReference.jobId,
                        fileName: restoredReference.metadata?.fileName || restoredReference.fileName
                    });
                } else {
                    console.error('[RESTORE] ‚ùå Refer√™ncia no cache est√° vazia');
                }
            } else {
                console.error('[RESTORE] ‚ùå Refer√™ncia n√£o encontrada no AnalysisCache');
                console.error('[RESTORE] Cache IDs dispon√≠veis:', window.AnalysisCache?.ids?.() || 'N/A');
            }
        } else {
            console.log('[RESTORE] ‚úÖ Dados de refer√™ncia j√° existem - restaura√ß√£o n√£o necess√°ria');
        }
    }

    // ========================================
    // ‚úÖ PROTE√á√ÉO DEFINITIVA CONTRA ERRO DE INTERFACE
    // ========================================
    // Espera o m√≥dulo aiUIController inicializar antes de renderizar
    let tries = 0;
    const MAX_TRIES = 30;
    const WAIT_MS = 150;

    while (
        (!window.aiUIController ||
         typeof window.aiUIController.renderMetricCards !== 'function' ||
         typeof window.aiUIController.renderScoreSection !== 'function') &&
        tries < MAX_TRIES
    ) {
        await new Promise(r => setTimeout(r, WAIT_MS));
        tries++;
        if (tries % 5 === 0) {
            console.warn(`[WAIT] aguardando aiUIController carregar... tentativa ${tries}`);
        }
    }

    // Falha definitiva ‚Äî controller nunca carregou
    if (
        !window.aiUIController ||
        typeof window.aiUIController.renderMetricCards !== 'function'
    ) {
        console.error('[FATAL] aiUIController n√£o carregado ap√≥s todas as tentativas');
        alert('Erro ao carregar interface de resultados. Recarregue a p√°gina.');
        return;
    }

    console.log('[SAFE] ‚úÖ aiUIController detectado, renderiza√ß√£o liberada.');

    // ========================================
    // ‚úÖ CORRE√á√ÉO 2: AB SAFETY - Hidrata√ß√£o e For√ßar Modo Reference
    // ========================================
    const abState = ensureReferenceHydrated();
    const _modeNow = window.currentAnalysisMode || window.__soundyState?.render?.mode;

    // Se √© segunda faixa e temos refId v√°lido, o modo √© obrigatoriamente 'reference'
    const isSecondTrack = !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has?.());
    
    // üõ°Ô∏è PROTE√á√ÉO CR√çTICA: S√≥ for√ßar modo reference se usu√°rio selecionou explicitamente
    if (isSecondTrack && _modeNow !== 'reference') {
        if (!userExplicitlySelectedReferenceMode) {
            console.error('%c[PROTECTION] ‚ùå BLOQUEIO em displayModalResults: isSecondTrack detectado mas userExplicitlySelectedReferenceMode = false', 'color:#FF0000;font-weight:bold;font-size:16px;');
            console.error('[PROTECTION] ‚ùå Sistema em modo genre - N√ÉO pode for√ßar modo reference');
            console.error('[PROTECTION] ‚ùå Abortando renderiza√ß√£o A/B');
            console.trace('[PROTECTION] Stack trace do bloqueio:');
            // N√ÉO for√ßar modo reference - abortar
            return;
        }
        
        window.currentAnalysisMode = 'reference';
        if (window.__soundyState?.render) window.__soundyState.render.mode = 'reference';
        console.warn('[AB-FORCE] For√ßando mode=reference porque h√° segunda faixa + referenceId.');
        console.log('%c[PROTECTION] ‚úÖ Modo for√ßado para reference em displayModalResults - flag verificada', 'color:#00FF88;font-weight:bold;');
    }

    // Validar refer√™ncia
    if (isSecondTrack && (!abState.ok || !window.referenceAnalysisData?.bands)) {
        console.error('[AB-BLOCK] Refer√™ncia n√£o hidratada para compara√ß√£o', abState);
        console.error('[AB-BLOCK] Segunda faixa detectada mas sem refer√™ncia v√°lida - abortando compara√ß√£o A/B');
        // N√£o degrade para genre; aborte a compara√ß√£o para evitar self-compare
        // Continue renderizando cards da segunda faixa normalmente (modo single)
    } else if (isSecondTrack) {
        console.log('[AB-SAFETY] ‚úÖ Refer√™ncia validada:', {
            ok: abState.ok,
            refId: abState.refId,
            hasBands: abState.hasBands,
            file: abState.file
        });
    }

    // =========================================================================
    // üÜî INFO: Sistema agora usa Virtual IDs (VID) para separa√ß√£o por papel
    // =========================================================================
    // Mesmo que jobIds sejam iguais, Virtual IDs (jobId::USER e jobId::REF) mant√™m separa√ß√£o
    // O bloqueio de self-compare agora √© feito por conte√∫do em renderReferenceComparisons
    console.log('[VID-INFO] ‚úÖ Sistema usa Virtual IDs - jobId reutilizado n√£o causa self-compare', {
        currentJobId: analysis?.jobId,
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        storeHasUser: !!FirstAnalysisStore.getUser(),
        storeHasRef: !!FirstAnalysisStore.getRef()
    });
    
    // ‚úÖ HARD-GUARD: Validar FirstAnalysisStore - se vazio, √© modo genre (n√£o reference)
    if (!FirstAnalysisStore.has()) {
        console.log('[INFO] FirstAnalysisStore vazio - modo genre (n√£o reference). Continuando render normalmente.');
        // ‚úÖ N√ÉO RETORNA AQUI! Modo genre n√£o precisa de primeira an√°lise
    } else {
        console.log('[HARD-GUARD] ‚úÖ FirstAnalysisStore validado - primeira an√°lise protegida:', {
            jobId: FirstAnalysisStore.get()?.jobId,
            fileName: FirstAnalysisStore.get()?.metadata?.fileName
        });
    }
    
    // =========================================================================
    // ÔøΩüö® DEBUG CR√çTICO: Timing e Estado dos Dados (detecta chamada prematura)
    // =========================================================================
    console.groupCollapsed("[DEBUG-DISPLAY] üß† In√≠cio displayModalResults()");
    console.log("üì¶ analysis.metadata.fileName:", analysis?.metadata?.fileName);
    console.log("üßä FirstAnalysisStore:", FirstAnalysisStore.has() ? FirstAnalysisStore.get()?.metadata?.fileName : 'null');
    console.log("üìä analysis.metrics:", !!analysis?.metrics, "technicalData:", !!analysis?.technicalData);
    const storedFirstForDebug = FirstAnalysisStore.get();
    console.log("üìä first.metrics:", !!storedFirstForDebug?.metrics, "technicalData:", !!storedFirstForDebug?.technicalData);
    console.groupEnd();
    
    // =========================================================================
    // üö® AUDITORIA COMPLETA EM TEMPO DE EXECU√á√ÉO - DESCOBRIR POR QUE N√ÉO RENDERIZA
    // =========================================================================
    try {
        console.groupCollapsed('[AUDITORIA_REFERENCE_MODE] üîç INVESTIGA√á√ÉO COMPLETA');
        console.log('[STEP 1] üîç Modo recebido:', analysis?.mode);
        console.log('[STEP 2] üîç Cont√©m metrics?', !!analysis?.metrics);
        console.log('[STEP 3] üîç Cont√©m technicalData?', !!analysis?.technicalData);
        console.log('[STEP 4] üîç Cont√©m suggestions?', !!analysis?.suggestions);
        console.log('[STEP 5] üîç Fun√ß√µes dispon√≠veis:', {
            renderMetricCards: typeof window.renderMetricCards,
            renderScoreSection: typeof window.renderScoreSection,
            renderSuggestions: typeof window.renderSuggestions,
            renderFinalScoreAtTop: typeof window.renderFinalScoreAtTop,
            renderAdvancedMetrics: typeof window.renderAdvancedMetrics,
        });
        console.log('[STEP 6] üîç analysis (safe):', safeStringify(analysis || {}));
        console.groupEnd();
    } catch (e) {
        console.warn('[AUDITORIA_REFERENCE_MODE] ‚ö†Ô∏è Falha ao logar analysis:', e.message);
    }
    
    // üîç AUDITORIA: Estado AO ENTRAR em displayModalResults
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] üöÄ displayModalResults - ENTRADA');
    console.log('‚öôÔ∏è Fun√ß√£o: displayModalResults');
    console.log('üìä analysis (par√¢metro recebido):', {
        jobId: analysis?.jobId,
        fileName: analysis?.metadata?.fileName || analysis?.fileName,
        lufs: analysis?.technicalData?.lufsIntegrated,
        mode: analysis?.mode,
        objectId: analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis
    });
    console.log('üéß analysis.userAnalysis:', analysis?.userAnalysis ? {
        fileName: analysis.userAnalysis?.metadata?.fileName || analysis.userAnalysis?.fileName,
        jobId: analysis.userAnalysis?.jobId,
        lufs: analysis.userAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.userAnalysis
    } : 'null');
    console.log('üéß analysis.referenceAnalysis:', analysis?.referenceAnalysis ? {
        fileName: analysis.referenceAnalysis?.metadata?.fileName || analysis.referenceAnalysis?.fileName,
        jobId: analysis.referenceAnalysis?.jobId,
        lufs: analysis.referenceAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.referenceAnalysis
    } : 'null');
    console.log('üåê Estado global atual:');
    const storedFirstForAudit = FirstAnalysisStore.get();
    console.log('  FirstAnalysisStore:', storedFirstForAudit ? {
        fileName: storedFirstForAudit.metadata?.fileName,
        jobId: storedFirstForAudit.jobId,
        lufs: storedFirstForAudit.technicalData?.lufsIntegrated
    } : 'null');
    console.log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
        fileName: window.__soundyState.previousAnalysis?.metadata?.fileName || window.__soundyState.previousAnalysis?.fileName,
        jobId: window.__soundyState.previousAnalysis?.jobId
    } : 'null');
    console.log('‚ö†Ô∏è VERIFICA√á√ÉO DE CONTAMINA√á√ÉO:');
    console.log('  analysis.userAnalysis === analysis.referenceAnalysis?', analysis?.userAnalysis === analysis?.referenceAnalysis);
    console.groupEnd();
    
    // üéØ LOG INICIAL PARA CONFIRMAR CHAMADA DA FUN√á√ÉO AP√ìS CORRE√á√ïES
    console.log("‚úÖ [DISPLAY_MODAL] Fun√ß√£o displayModalResults chamada com dados:", analysis);
    console.log("‚úÖ [DISPLAY_MODAL] Estrutura dos dados recebidos:", Object.keys(analysis || {}));
    
    // üîí PROTE√á√ÉO MODO REFERENCE: Evitar sobrescrita por interceptores
    if (analysis && analysis.mode === "reference") {
        const previous = window.__soundyState?.previousAnalysis;
        const user = analysis.userAnalysis || previous;
        const ref = analysis.referenceAnalysis || 
                    window.__soundyState?.referenceAnalysis || 
                    window.__soundyState?.reference?.referenceAnalysis || 
                    null;

        console.log("[REFERENCE-FLOW ‚úÖ] Compara√ß√£o direta A/B antes da renderiza√ß√£o:", {
            userTrack: user?.fileName || user?.metadata?.fileName,
            referenceTrack: ref?.fileName || ref?.metadata?.fileName,
            hasUserBands: !!(user?.technicalData?.spectral_balance || user?.bands),
            hasRefBands: !!(ref?.technicalData?.spectral_balance || ref?.bands),
        });

        // üîí Prote√ß√£o contra sobrescrita por interceptores
        if (user) Object.freeze(user);
        if (ref) Object.freeze(ref);

        const payload = {
            mode: "reference",
            userAnalysis: user,
            referenceAnalysis: ref,
        };

        // ==== PATCH 3: DEFINITIVO - FirstAnalysisStore + refHardGuards ====
        const first = FirstAnalysisStore.get();
        
        if (!first) {
            console.error('[A/B] ‚ùå Primeira an√°lise n√£o encontrada no FirstAnalysisStore');
            console.warn('[A/B] ‚ö†Ô∏è Renderizando apenas segunda an√°lise como single');
            
            // Renderiza apenas a segunda como single (fallback seguro)
            if (typeof window.aiUIController !== 'undefined') {
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            return; // n√£o prossegue sem primeira an√°lise
        }

        // ‚úÖ MONTAGEM A/B COM ISOLAMENTO COMPLETO
        let userFull = first; // 1¬™ faixa (j√° √© clone do FirstAnalysisStore.get())
        let refFull = (typeof structuredClone === 'function')
            ? structuredClone(analysis)
            : JSON.parse(JSON.stringify(analysis)); // 2¬™ faixa (clone expl√≠cito)

        // ÔøΩÔ∏è APLICAR GUARDS: Isola jobIds se forem iguais
        ({ userFull, refFull } = refHardGuards({ userFull, refFull }));

        // üî¨ GERAR SUGEST√ïES COMPARATIVAS A vs B (se ainda n√£o existirem)
        const hasExistingSuggestions = Array.isArray(userFull?.aiSuggestions) && userFull.aiSuggestions.length > 0;
        
        if (!hasExistingSuggestions) {
            console.log('[A/B-FLOW] üî¨ Gerando sugest√µes comparativas A vs B...');
            const comparativeSuggestions = buildComparativeAISuggestions(userFull, refFull);
            
            if (comparativeSuggestions.length > 0) {
                // Injetar sugest√µes comparativas no userFull
                userFull.aiSuggestions = comparativeSuggestions;
                userFull.hasEnriched = true;
                userFull.mode = "compare";
                
                console.log('[A/B-FLOW] ‚úÖ Sugest√µes comparativas injetadas:', {
                    quantidade: comparativeSuggestions.length,
                    categorias: comparativeSuggestions.map(s => s.categoria).join(', ')
                });
            } else {
                console.warn('[A/B-FLOW] ‚ö†Ô∏è Nenhuma sugest√£o comparativa gerada - m√©tricas insuficientes');
            }
        } else {
            console.log('[A/B-FLOW] ‚ÑπÔ∏è Sugest√µes j√° existem - pulando gera√ß√£o comparativa');
        }

        // ‚úÖ RENDER COMPLETO (nunca aborta por contamina√ß√£o - trabalha direto nos objetos)
        if (typeof window.aiUIController !== 'undefined') {
            window.aiUIController.renderMetricCards({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderScoreSection({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderSuggestions({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderFinalScoreAtTop({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.checkForAISuggestions({ mode: 'reference', user: userFull, reference: refFull });
        }

        console.log('[A/B-END] ‚úÖ', {
            userFile: userFull?.fileName || userFull?.metadata?.fileName,
            refFile: refFull?.fileName || refFull?.metadata?.fileName,
            userId: userFull?.jobId || userFull?.id,
            refId: refFull?.jobId || refFull?.id
        });
        
        // ‚úÖ CORRE√á√ÉO CR√çTICA DA AUDITORIA (linha 4502)
        // REMOVIDO return prematuro que bloqueava:
        // - Normaliza√ß√£o de dados (linha 4822)
        // - C√°lculo de scores (linha 4889)
        // - Renderiza√ß√£o de cards (linha 6623)
        // - renderFinalScoreAtTop() (linha 6620)
        // - advancedMetricsCard() (linha 6636)
        // ‚ùå return; ‚Üê REMOVIDO
        
        console.log('[AUDIT-CORRECTION] ‚úÖ Fluxo continuar√° para renderizar cards, scores e sugest√µes');
        console.log('[AUDIT-CORRECTION] ‚úÖ Return prematuro removido - pipeline completo ativado');
    } else if (analysis && analysis.mode === "genre") {
        // üéØ PATCH 1: MODO G√äNERO COM TARGETS
        console.log('[GENRE-FLOW] üéØ Renderizando modo g√™nero com targets');
        
        const genreTargets = analysis.data?.genreTargets;
        
        if (!genreTargets) {
            console.warn('[GENRE-FLOW] ‚ö†Ô∏è genreTargets n√£o encontrado em analysis.data!');
            console.warn('[GENRE-FLOW]    analysis.data:', analysis.data);
            console.warn('[GENRE-FLOW]    analysis.genreTargets:', analysis.genreTargets);
            
            // ü©π PATCH: N√ÉO dar return - continuar com degrad√™
            console.warn('[GENRE-FLOW] ‚ö†Ô∏è Modo DEGRAD√ä: Renderizando sem tabela de compara√ß√£o');
            console.warn('[GENRE-FLOW] ‚úÖ Score, m√©tricas e sugest√µes ser√£o exibidos normalmente');
            
            // Renderizar em modo single (sem targets)
            if (typeof window.aiUIController !== 'undefined') {
                console.log('[GENRE-FLOW] üéØ Renderizando em modo single (degrad√™)');
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            
            // ‚ùå N√ÉO dar return - deixar modal abrir normalmente
            // return; ‚Üê REMOVIDO
        } else {
            console.log('[GENRE-FLOW] ‚úÖ genreTargets encontrado:', {
                lufs_target: genreTargets.lufs_target,
                true_peak_target: genreTargets.true_peak_target,
                dr_target: genreTargets.dr_target,
                spectralBands: genreTargets.spectralBands ? Object.keys(genreTargets.spectralBands) : null
            });
        
        // ‚úÖ Renderizar tabela de compara√ß√£o com targets
        renderGenreComparisonTable({
            analysis,
            genre: analysis.genre || analysis.data.genre,
            targets: genreTargets
        });
        
        // ‚úÖ Renderizar sugest√µes com contexto de g√™nero
        if (typeof window.aiUIController !== 'undefined') {
            console.log('[GENRE-FLOW] üéØ Renderizando sugest√µes em modo g√™nero');
            
            window.aiUIController.renderSuggestions({ 
                mode: 'genre', 
                user: analysis,
                targets: genreTargets
            });
            
            window.aiUIController.renderMetricCards({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderScoreSection({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderFinalScoreAtTop({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.checkForAISuggestions({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
        }
        
        console.log('[GENRE-FLOW] ‚úÖ Renderiza√ß√£o de modo g√™nero conclu√≠da');
        } // ‚Üê Fechar else do genreTargets
    }
    
    // [AUDIT-FLOW-CHECK] Verificar se chegou aqui (deveria chegar sempre, inclusive no modo reference)
    console.log('[AUDIT-FLOW-CHECK] ‚úÖ Fluxo continua ap√≥s blocos reference/genre - modo:', analysis?.mode);
    
    // üîí VALIDA√á√ÉO CR√çTICA: Garantir que m√©tricas essenciais est√£o presentes
    // CORRIGIDO: Verificar novos caminhos do backend Redis
    const hasEssentialMetrics = (
        analysis?.technicalData && 
        (
            Number.isFinite(analysis.technicalData.lufsIntegrated) ||
            Number.isFinite(analysis.technicalData.lufs_integrated) ||
            Number.isFinite(analysis.technicalData.avgLoudness) ||
            Number.isFinite(analysis.technicalData.dynamicRange) ||
            // NOVOS CAMINHOS: Estrutura do backend Redis
            Number.isFinite(analysis.loudness?.integrated) ||
            Number.isFinite(analysis.technicalData?.dr) ||
            // Fallback: Se tem score, provavelmente tem dados v√°lidos
            Number.isFinite(analysis.score)
        )
    );
    
    if (!hasEssentialMetrics) {
        console.warn('‚ö†Ô∏è [UI_GATE] Aguardando m√©tricas essenciais... an√°lise incompleta:', analysis);
        console.log('üîç [UI_GATE] Debug - estrutura recebida:', {
            technicalData: analysis?.technicalData,
            loudness: analysis?.loudness,
            score: analysis?.score,
            hasScore: Number.isFinite(analysis?.score)
        });
        
        // CORRE√á√ÉO: Verificar se √© estrutura nova mas v√°lida
        if (analysis?.loudness || analysis?.technicalData || Number.isFinite(analysis?.score)) {
            console.warn("‚ö†Ô∏è [UI_GATE] Estrutura nova detectada, prosseguindo com dados dispon√≠veis");
        } else {
            console.warn('[AUDITORIA_CONDICAO] ‚ö†Ô∏è Retorno antecipado em: hasEssentialMetrics falhou - mode:', analysis?.mode);
            console.warn('[AUDITORIA_TIMING] normalizeBackendAnalysisData terminado?', !!window.currentAnalysisData);
            console.warn('[AUDITORIA_TIMING] displayModalResults chamado?', performance.now());
            // Tentar novamente em 2 segundos apenas se realmente n√£o h√° dados
            setTimeout(() => displayModalResults(analysis), 2000);
            return;
        }
    }
    
    console.log('‚úÖ [UI_GATE] M√©tricas essenciais presentes, exibindo resultados');
    
    // üî• CORRE√á√ÉO COMPARA√á√ÉO A/B: Usar _userAnalysis (1¬™ faixa = sua m√∫sica) para cards/m√©tricas
    if (analysis._isReferenceMode && analysis._userAnalysis && analysis._referenceAnalysis) {
        console.log('[REFERENCE-DISPLAY] üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('[REFERENCE-DISPLAY] üéØ Modo A/B detectado - Configura√ß√£o correta:');
        console.log('[REFERENCE-DISPLAY] ‚úÖ 1¬™ faixa (SUA M√öSICA/ATUAL):', analysis._userAnalysis?.fileName || analysis._userAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] ‚úÖ 2¬™ faixa (REFER√äNCIA/ALVO):', analysis._referenceAnalysis?.fileName || analysis._referenceAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] üìä Cards principais: mostrar√£o m√©tricas da SUA M√öSICA (1¬™ faixa)');
        console.log('[REFERENCE-DISPLAY] üìä Tabela comparativa: SUA M√öSICA (esquerda) vs REFER√äNCIA (direita)');
        console.log('[REFERENCE-DISPLAY] üéØ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        // Salvar an√°lise de refer√™ncia antes de substituir
        const originalReferenceAnalysis = analysis._referenceAnalysis;
        
        // SUBSTITUIR analysis pelos dados da PRIMEIRA faixa (sua m√∫sica/atual) para renderiza√ß√£o dos cards
        const firstTrackAnalysis = analysis._userAnalysis;
        
        // Copiar propriedades importantes
        analysis = {
            ...firstTrackAnalysis,
            _isReferenceMode: true,
            _userAnalysis: firstTrackAnalysis,
            _referenceAnalysis: originalReferenceAnalysis,
            mode: 'reference' // Manter modo para l√≥gica posterior
        };
        
        console.log('[REFERENCE-DISPLAY ‚úÖ] Analysis substitu√≠do por dados da sua m√∫sica (1¬™ faixa)');
        console.log('[REFERENCE-DISPLAY] M√©tricas da SUA M√öSICA a serem exibidas nos cards:', {
            lufs: analysis.technicalData?.lufsIntegrated || analysis.loudness?.integrated,
            dr: analysis.technicalData?.dynamicRange || analysis.technicalData?.dr,
            tp: analysis.technicalData?.truePeakDbtp || analysis.truePeak?.maxDbtp
        });
    }
    
    // üéØ DETEC√á√ÉO DE MODO COMPARA√á√ÉO ENTRE FAIXAS
    const isSecondTrackCheck = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
    const mode = analysis?.mode || currentAnalysisMode;
    
    // üî¥üî¥üî¥ DIAGN√ìSTICO CR√çTICO: Por que n√£o est√° entrando no bloco A/B?
    console.log('üî¥üî¥üî¥ [DIAGN√ìSTICO-AB] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üî¥ [DIAGN√ìSTICO-AB] Valores das vari√°veis da condicional:');
    console.log('üî¥ [DIAGN√ìSTICO-AB]   analysis?.mode:', analysis?.mode);
    console.log('üî¥ [DIAGN√ìSTICO-AB]   currentAnalysisMode:', currentAnalysisMode);
    console.log('üî¥ [DIAGN√ìSTICO-AB]   mode (final):', mode);
    console.log('üî¥ [DIAGN√ìSTICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('üî¥ [DIAGN√ìSTICO-AB]   isSecondTrackCheck:', isSecondTrackCheck);
    console.log('üî¥ [DIAGN√ìSTICO-AB] Condicional ser√°:', mode === 'reference' && isSecondTrackCheck);
    console.log('üî¥ [DIAGN√ìSTICO-AB]   mode === "reference"?', mode === 'reference');
    console.log('üî¥ [DIAGN√ìSTICO-AB]   isSecondTrackCheck?', isSecondTrackCheck);
    console.log('üî¥üî¥üî¥ [DIAGN√ìSTICO-AB] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    // üéØ DEFINIR MODO NO ESTADO ANTES DE QUALQUER C√ÅLCULO
    const state = window.__soundyState || {};
    state.render = state.render || {};
    
    // üî¥ FIX CR√çTICO: Remover verifica√ß√£o de window.__FIRST_ANALYSIS_FROZEN__ da condicional
    // para permitir entrada no bloco e fazer recupera√ß√£o autom√°tica
    if (mode === 'reference' && isSecondTrackCheck) {
        console.log('üéØ [COMPARE-MODE] Modo reference detectado - Segunda faixa chegou');
        console.log('üìä [COMPARE-MODE] window.__FIRST_ANALYSIS_FROZEN__ existe?', !!window.__FIRST_ANALYSIS_FROZEN__);
        console.log('üìä [COMPARE-MODE] Segunda faixa:', analysis);
        
        // üéØ DEFINIR MODO REFERENCE NO ESTADO
        state.render.mode = 'reference';
        window.__soundyState = state;
        console.log('‚úÖ [COMPARE-MODE] Modo definido como REFERENCE no estado');
        
        // üéØ CRIAR ESTRUTURA DE COMPARA√á√ÉO ENTRE FAIXAS COM C√ìPIA DEFENSIVA
        
        // üîç AUDITORIA: Estado ANTES de deepCloneSafe + normalizeBackendAnalysisData
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] üîí ANTES deepCloneSafe + normalize');
        console.log('‚öôÔ∏è Contexto: Prestes a criar refNormalized e currNormalized');
        console.log('üìä window.__FIRST_ANALYSIS_FROZEN__ (1¬™ faixa):', {
            fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
            jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
            lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
            objectId: window.__FIRST_ANALYSIS_FROZEN__
        });
        console.log('üìä analysis (2¬™ faixa):', {
            fileName: analysis?.metadata?.fileName || analysis?.fileName,
            jobId: analysis?.jobId,
            lufs: analysis?.technicalData?.lufsIntegrated,
            objectId: analysis
        });
        console.log('üí° Opera√ß√£o: deepCloneSafe() + normalizeBackendAnalysisData()');
        console.groupEnd();
        
        // ========================================
        // üß† PRIORIZAR DADOS DO STORE ISOLADO (FONTE DE VERDADE)
        // ========================================
        let refNormalized, currNormalized;
        
        // üîí PRIORIDADE ABSOLUTA: Verificar SoundyAI_Store PRIMEIRO
        const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
        
        if (storeHasBoth) {
            console.log('üéØ [STORE-ABSOLUTE-PRIORITY] ‚úÖ Store tem ambas an√°lises - USANDO COMO FONTE √öNICA');
            console.log('   - Store.first.jobId:', window.SoundyAI_Store.first?.jobId);
            console.log('   - Store.second.jobId:', window.SoundyAI_Store.second?.jobId);
            console.log('   - Store.first.fileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
            console.log('   - Store.second.fileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
            
            // Normalizar dados do store (n√£o do comparisonPair que pode estar desatualizado)
            refNormalized = normalizeSafe(window.SoundyAI_Store.first);   // Primeira m√∫sica
            currNormalized = normalizeSafe(window.SoundyAI_Store.second); // Segunda m√∫sica
            
            console.log('‚úÖ [STORE-ABSOLUTE-PRIORITY] Dados do store normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
            
            // üö® VALIDA√á√ÉO CR√çTICA: Detectar contamina√ß√£o no store
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('üö® [STORE-ERROR] ‚ùå CONTAMINA√á√ÉO NO STORE DETECTADA!');
                console.error('   - JobIds s√£o IGUAIS:', window.SoundyAI_Store.first.jobId);
                console.error('   - Isso indica bug no salvamento dos dados');
                console.trace();
            }
            
        } else if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('üéØ [STORE-PRIORITY] Usando dados do comparisonPair (anexado ao analysis)');
            const pair = analysis._comparisonPair;
            
            // Normalizar dados do comparisonPair
            refNormalized = normalizeSafe(pair.ref);   // Primeira m√∫sica (refer√™ncia)
            currNormalized = normalizeSafe(pair.curr); // Segunda m√∫sica (atual)
            
            console.log('‚úÖ [STORE-PRIORITY] Dados do comparisonPair normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
        } else {
            console.log('‚ö†Ô∏è [LEGACY-MODE] Store n√£o dispon√≠vel, usando modo legado');
            console.warn('‚ö†Ô∏è [LEGACY-WARN] ATEN√á√ÉO: Modo legado pode ter contamina√ß√£o!');
            
            // üîí HARD-GUARD: Usar FirstAnalysisStore.get() (√∫nica fonte de verdade - modo legado)
            const firstAnalysis = FirstAnalysisStore.get();
            
            console.log('üî¥ [AUDIT-CRITICAL] ANTES de criar refNormalized/currNormalized:');
            console.log('  FirstAnalysisStore.has():', FirstAnalysisStore.has());
            console.log('  firstAnalysis.metadata?.fileName:', firstAnalysis?.metadata?.fileName);
            console.log('  firstAnalysis.jobId:', firstAnalysis?.jobId);
            console.log('  analysis.metadata?.fileName:', analysis?.metadata?.fileName);
            console.log('  analysis.jobId:', analysis?.jobId);
            console.log('  üö® S√ÉO O MESMO ARQUIVO?', firstAnalysis?.metadata?.fileName === analysis?.metadata?.fileName);
            console.log('  üö® S√ÉO O MESMO JOBID?', firstAnalysis?.jobId === analysis?.jobId);
            
            // ‚úÖ STEP 2/6 REFATORADO: Normaliza√ß√£o segura sem ciclos (modo legado)
            console.log('[NORMALIZE-DEFENSIVE] üîí Criando c√≥pia isolada da 1¬™ faixa (normalizeSafe)');
            refNormalized = normalizeSafe(firstAnalysis);
            
            console.log('[NORMALIZE-DEFENSIVE] üîí Criando c√≥pia isolada da 2¬™ faixa (normalizeSafe)');
            currNormalized = normalizeSafe(analysis);
        }
        
        // ========================================
        // üö® VALIDA√á√ÉO CR√çTICA ABSOLUTA: ABORTAR SE JOBIDS IGUAIS
        // ========================================
        const refFileName = refNormalized?.metadata?.fileName || refNormalized?.fileName;
        const currFileName = currNormalized?.metadata?.fileName || currNormalized?.fileName;
        const refJobId = refNormalized?.jobId || refNormalized?.id;
        const currJobId = currNormalized?.jobId || currNormalized?.id;
        
        console.groupCollapsed('[PRE-VALIDATION] üîç Verifica√ß√£o de Integridade dos Objetos');
        console.log('üìÅ Arquivo 1 (ref):', refFileName);
        console.log('üìÅ Arquivo 2 (curr):', currFileName);
        console.log('üÜî JobId 1 (ref):', refJobId);
        console.log('üÜî JobId 2 (curr):', currJobId);
        console.log('‚ö†Ô∏è Nomes iguais?', refFileName === currFileName);
        console.log('‚ö†Ô∏è JobIds iguais?', refJobId === currJobId);
        console.log('‚ö†Ô∏è Objetos s√£o mesma refer√™ncia?', refNormalized === currNormalized);
        console.log('‚ö†Ô∏è Metadata s√£o mesma refer√™ncia?', refNormalized?.metadata === currNormalized?.metadata);
        console.groupEnd();
        
        // üö® VALIDA√á√ÉO CR√çTICA: Se jobIds forem iguais, ABORTAR IMEDIATAMENTE
        if (refJobId && currJobId && refJobId === currJobId) {
            console.error('üö®üö®üö® [CRITICAL-ERROR] JOBIDS IGUAIS DETECTADOS! üö®üö®üö®');
            console.error('   - refJobId:', refJobId);
            console.error('   - currJobId:', currJobId);
            console.error('   - refFileName:', refFileName);
            console.error('   - currFileName:', currFileName);
            console.error('   - Sistema est√° tentando comparar a m√∫sica consigo mesma!');
            console.error('   - ABORTANDO renderiza√ß√£o para evitar dados incorretos');
            console.trace();
            
            // Mostrar alerta ao usu√°rio
            alert('‚ùå ERRO CR√çTICO: Sistema detectou que est√° tentando comparar a mesma m√∫sica.\n\n' +
                  'JobId 1: ' + refJobId + '\n' +
                  'JobId 2: ' + currJobId + '\n\n' +
                  'Por favor, recarregue a p√°gina e tente novamente com duas m√∫sicas DIFERENTES.');
            
            // ABORTAR renderiza√ß√£o
            return;
        }
        
        console.log('‚úÖ [VALIDATION-PASS] JobIds s√£o diferentes - prosseguindo com renderiza√ß√£o');
        
        // üõ°Ô∏è Prote√ß√£o contra auto-compara√ß√£o e renderiza√ß√£o segura
        let isSelfCompare = false;
        
        // ========================================
        // üîß VALIDA√á√ÉO INTELIGENTE: Usar jobId e VID em vez de apenas fileName
        // ========================================
        const sameFileName = refFileName === currFileName;
        const sameJobId = !!(refJobId && currJobId && refJobId === currJobId);
        
        // Verificar Virtual IDs (mais confi√°vel que fileName)
        const refVid = refNormalized?.vid || window.CacheIndex?.REF;
        const currVid = currNormalized?.vid || window.CacheIndex?.USER;
        const sameVid = !!(refVid && currVid && refVid === currVid);
        
        // Fallback: areSameTrack() para valida√ß√£o t√©cnica
        const sameTrack = areSameTrack(refNormalized, currNormalized);
        
        console.groupCollapsed('[SMART-VALIDATION] üß† An√°lise de Self-Compare (VID-aware)');
        console.log('üìã An√°lise completa:', {
            sameFileName,
            sameJobId,
            refVid,
            currVid,
            sameVid,
            sameTrack,
            decisao: (sameJobId || sameVid) 
                ? 'SELF-COMPARE REAL (jobId ou VID id√™ntico)' 
                : (sameFileName && !sameJobId && !sameVid) 
                    ? 'MESMO ARQUIVO, IDs DIFERENTES ‚Üí OK (n√£o √© self-compare)' 
                    : 'ARQUIVOS DIFERENTES'
        });
        console.groupEnd();
        
        // Self-compare detectado se: jobId OU VID id√™nticos
        if (sameJobId || sameVid) {
            console.warn('[REF-GUARD] ‚ö†Ô∏è Self-compare REAL detectado ‚Äî marcando flag mas CONTINUANDO renderiza√ß√£o A/B.');
            isSelfCompare = true;
            
            // üî• Marcar no estado que √© self-compare (sem interromper fluxo)
            if (!state.render) state.render = {};
            state.render.isSelfCompare = true;
            
            console.log('[REF-GUARD] üîÑ Self-compare confirmado:', {
                sameJobId: sameJobId ? refJobId : false,
                sameVid: sameVid ? refVid : false,
                note: 'Score ser√° 100% mas renderiza√ß√£o continua'
            });
        } else if (sameFileName && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] ‚úÖ Mesmo arquivo mas IDs diferentes ‚Üí N√£o √© self-compare, continuando normalmente');
        } else if (sameTrack && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] ‚ö†Ô∏è areSameTrack() detectou semelhan√ßa mas IDs s√£o diferentes ‚Üí Continuando normalmente');
        } else {
            console.log('[REF-GUARD] ‚úÖ Valida√ß√£o passou - faixas s√£o diferentes');
        }
        
        // ‚úÖ REVALIDA√á√ÉO: Garantir que n√£o √© falso-positivo
        // Se chegou aqui com isSelfCompare mas VIDs s√£o diferentes, corrigir
        if (isSelfCompare && refVid !== currVid) {
            console.warn('[REF-GUARD] ‚ùé Corrigido selfCompare falso-positivo (VIDs diferentes):', {
                refVid,
                currVid,
                refFile: refFileName,
                currFile: currFileName
            });
            isSelfCompare = false;
            if (state.render) state.render.isSelfCompare = false;
        }
        
        // üêõ DEBUG A/B
        console.log('[DEBUG-A/B]', {
            ref: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            curr: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            same: areSameTrack(refNormalized, currNormalized),
        });
        
        // üîç AUDITORIA: Estado AP√ìS criar refNormalized e currNormalized
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚úÖ DEPOIS refNormalized + currNormalized');
        console.log('‚öôÔ∏è Contexto: Clones normalizados criados');
        console.log('üìä refNormalized (1¬™ faixa normalizada):', {
            fileName: refNormalized?.metadata?.fileName,
            jobId: refNormalized?.jobId,
            lufs: refNormalized?.technicalData?.lufsIntegrated,
            objectId: refNormalized
        });
        console.log('üìä currNormalized (2¬™ faixa normalizada):', {
            fileName: currNormalized?.metadata?.fileName,
            jobId: currNormalized?.jobId,
            lufs: currNormalized?.technicalData?.lufsIntegrated,
            objectId: currNormalized
        });
        console.log('‚ö†Ô∏è VERIFICA√á√ÉO DE ISOLAMENTO:');
        console.log('  refNormalized !== currNormalized?', refNormalized !== currNormalized);
        console.log('  refNormalized !== window.__FIRST_ANALYSIS_FROZEN__?', refNormalized !== window.__FIRST_ANALYSIS_FROZEN__);
        console.log('  currNormalized !== analysis?', currNormalized !== analysis);
        console.log('  refNormalized.metadata?.fileName:', refNormalized?.metadata?.fileName);
        console.log('  currNormalized.metadata?.fileName:', currNormalized?.metadata?.fileName);
        console.log('  üö® SAME FILE?', refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName);
        
        // üî¥ VALIDA√á√ÉO CR√çTICA: Se os arquivos s√£o iguais, ABORTAR imediatamente
        if (refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName) {
            console.error('üî¥ [AUDITORIA_STATE_FLOW] ‚ùå‚ùå‚ùå CONTAMINA√á√ÉO CONFIRMADA ‚ùå‚ùå‚ùå');
            console.error('üî¥ refNormalized e currNormalized t√™m O MESMO ARQUIVO!');
            console.error('üî¥ Isso significa que window.__FIRST_ANALYSIS_FROZEN__ foi contaminado!');
            console.error('üî¥ Sistema est√° comparando a m√∫sica consigo mesma!');
            console.table({
                'refNormalized.fileName': refNormalized?.metadata?.fileName,
                'refNormalized.jobId': refNormalized?.jobId,
                'currNormalized.fileName': currNormalized?.metadata?.fileName,
                'currNormalized.jobId': currNormalized?.jobId,
                'sameFile': refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName,
                'sameJobId': refNormalized?.jobId === currNormalized?.jobId
            });
        }
        console.groupEnd();
        
        // [REF-FLOW] Construindo m√©tricas A/B
        // ‚úÖ SEM√ÇNTICA CORRETA:
        // - refNormalized = 1¬™ faixa = SUA M√öSICA (atual) = userAnalysis
        // - currNormalized = 2¬™ faixa = REFER√äNCIA (alvo a alcan√ßar) = referenceAnalysis
        
        // üßä PROTE√á√ÉO ANTICONTAMINA√á√ÉO: S√≥ criar se ainda n√£o existir
        if (!referenceComparisonMetrics) {
            console.log('[STATE-FIX] ‚úÖ Criando referenceComparisonMetrics pela primeira vez');
            referenceComparisonMetrics = {
                // ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                userTrack: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),        // 1¬™ faixa (sua m√∫sica/atual)
                referenceTrack: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2¬™ faixa (refer√™ncia/alvo)
                
                userTrackFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceTrackFull: JSON.parse(JSON.stringify(currNormalized || null)),
                
                // LEGADO: manter por compatibilidade (mapeamento correto)
                user: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),       // 1¬™ = sua m√∫sica (atual)
                reference: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2¬™ = refer√™ncia (alvo)
                userFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceFull: JSON.parse(JSON.stringify(currNormalized || null))
            };
        } else {
            console.warn('[STATE-FIX] ‚ö†Ô∏è referenceComparisonMetrics j√° inicializado, n√£o sobrescrevendo');
            console.warn('[STATE-FIX]   Mantendo dados originais:', {
                userFile: referenceComparisonMetrics.userFull?.fileName || referenceComparisonMetrics.userFull?.metadata?.fileName,
                refFile: referenceComparisonMetrics.referenceFull?.fileName || referenceComparisonMetrics.referenceFull?.metadata?.fileName
            });
        }
        
        console.log('[REF-FLOW] ‚úÖ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('[REF-FLOW] ‚úÖ M√©tricas A/B constru√≠das corretamente:');
        console.log('[REF-FLOW] ‚úÖ   SUA M√öSICA (1¬™):', refNormalized.metadata?.fileName);
        console.log('[REF-FLOW] ‚úÖ   LUFS:', referenceComparisonMetrics.userTrack?.lufsIntegrated);
        console.log('[REF-FLOW] ‚úÖ   REFER√äNCIA (2¬™):', currNormalized.metadata?.fileName);
        console.log('[REF-FLOW] ‚úÖ   LUFS:', referenceComparisonMetrics.referenceTrack?.lufsIntegrated);
        console.log('[REF-FLOW] ‚úÖ   Tabela: ESQUERDA=sua m√∫sica, DIREITA=refer√™ncia');
        console.log('[REF-FLOW] ‚úÖ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        console.log('[ASSERT] reference mode', {
            userIsFirst: !!(state?.userAnalysis || refNormalized),
            refIsSecond: !!(state?.referenceAnalysis || currNormalized)
        });
        
        // üß© PROTE√á√ÉO CONTRA DADOS INCOMPLETOS
        if (!currNormalized?.technicalData?.spectral_balance) {
            console.warn("‚ö†Ô∏è [REF-FIX] spectral_balance ausente em currNormalized, reconstruindo...");
            if (currNormalized?.bands) {
                currNormalized.technicalData.spectral_balance = currNormalized.bands;
            } else if (currNormalized?.technicalData?.bandEnergies) {
                currNormalized.technicalData.spectral_balance = currNormalized.technicalData.bandEnergies;
            } else {
                console.warn("‚ö†Ô∏è [REF-FIX] Criando estrutura vazia para currNormalized");
                if (!currNormalized.technicalData) currNormalized.technicalData = {};
                currNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }

        if (!refNormalized?.technicalData?.spectral_balance) {
            console.warn("‚ö†Ô∏è [REF-FIX] spectral_balance ausente em refNormalized, reconstruindo...");
            if (refNormalized?.bands) {
                refNormalized.technicalData.spectral_balance = refNormalized.bands;
            } else if (refNormalized?.technicalData?.bandEnergies) {
                refNormalized.technicalData.spectral_balance = refNormalized.technicalData.bandEnergies;
            } else {
                console.warn("‚ö†Ô∏è [REF-FIX] Criando estrutura vazia para refNormalized");
                if (!refNormalized.technicalData) refNormalized.technicalData = {};
                refNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }
        
        // üß© LOG DE AUDITORIA DETALHADO
        console.log("[ASSERT_REF_FLOW ‚úÖ]", {
            userTrack: refNormalized?.metadata?.fileName || "primeira faixa",
            referenceTrack: currNormalized?.metadata?.fileName || "segunda faixa",
            userBands: Object.keys(refNormalized?.technicalData?.spectral_balance || {}),
            referenceBands: Object.keys(currNormalized?.technicalData?.spectral_balance || {})
        });
        
        // üß© PROTE√á√ÉO NO displayModalResults: Valida√ß√£o de referenceTrack
        if (!currNormalized?.metadata?.fileName && !currNormalized?.fileName) {
            console.warn("‚ö†Ô∏è [DISPLAY_MODAL_FIX] Reference track com dados incompletos ‚Äî continuando com fallback...");
            // ‚ùå REMOVIDO: return que bloqueava renderiza√ß√£o
            // Agora continua o fluxo com dados dispon√≠veis, mesmo que incompletos
        }
        
        // üß© CORRE√á√ÉO #6: Chamada √öNICA de renderiza√ß√£o (remover duplica√ß√£o)
        // SEM√ÇNTICA CORRETA:
        // - userAnalysis = 1¬™ faixa (SUA M√öSICA - atual)
        // - referenceAnalysis = 2¬™ faixa (REFER√äNCIA - alvo)
        
        // üîç [A/B-DEBUG] Dados ANTES de renderReferenceComparisons
        console.log("[A/B-DEBUG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        console.log("[A/B-DEBUG] Dados antes do SAFE_RENDER_REF:");
        console.log("[A/B-DEBUG] refNormalized (1¬™ faixa - SUA M√öSICA):", {
            fileName: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            hasBands: !!refNormalized?.bands,
            hasSpectralBalance: !!refNormalized?.technicalData?.spectral_balance,
            bandsKeys: refNormalized?.bands ? Object.keys(refNormalized.bands) : [],
            spectralBalanceKeys: refNormalized?.technicalData?.spectral_balance ? Object.keys(refNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] currNormalized (2¬™ faixa - REFER√äNCIA):", {
            fileName: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            hasBands: !!currNormalized?.bands,
            hasSpectralBalance: !!currNormalized?.technicalData?.spectral_balance,
            bandsKeys: currNormalized?.bands ? Object.keys(currNormalized.bands) : [],
            spectralBalanceKeys: currNormalized?.technicalData?.spectral_balance ? Object.keys(currNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        
        // ‚úÖ GARANTIR que bands esteja no n√≠vel correto (userAnalysis.bands e referenceAnalysis.bands)
        if (!refNormalized.bands && refNormalized?.technicalData?.spectral_balance) {
            refNormalized.bands = refNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] ‚úÖ Bandas copiadas de technicalData.spectral_balance para bands (userAnalysis)");
        }
        
        if (!currNormalized.bands && currNormalized?.technicalData?.spectral_balance) {
            currNormalized.bands = currNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] ‚úÖ Bandas copiadas de technicalData.spectral_balance para bands (referenceAnalysis)");
        }
        
        console.log("[A/B-DEBUG] ‚úÖ Bandas finais:", {
            userBandsLength: refNormalized?.bands ? Object.keys(refNormalized.bands).length : 0,
            referenceBandsLength: currNormalized?.bands ? Object.keys(currNormalized.bands).length : 0
        });
        
        // üßä PROTE√á√ÉO ANTICONTAMINA√á√ÉO: Deep clone antes de renderizar
        console.log('[STATE-FIX] üîí Criando frozen clones para renderReferenceComparisons');
        const frozenRef = JSON.parse(JSON.stringify(refNormalized));
        const frozenCurr = JSON.parse(JSON.stringify(currNormalized));
        
        // üîç AUDITORIA DE INTEGRIDADE
        console.log('[STATE-INTEGRITY]', {
            refJobId: frozenRef.jobId,
            currJobId: frozenCurr.jobId,
            refFile: frozenRef.fileName || frozenRef.metadata?.fileName,
            currFile: frozenCurr.fileName || frozenCurr.metadata?.fileName,
            sameJob: frozenRef.jobId === frozenCurr.jobId,
            sameFile: (frozenRef.fileName || frozenRef.metadata?.fileName) === (frozenCurr.fileName || frozenCurr.metadata?.fileName),
            areIndependent: frozenRef !== frozenCurr,
            metadataIndependent: frozenRef.metadata !== frozenCurr.metadata
        });
        
        // üéØ VALIDA√á√ÉO CR√çTICA: Garantir que jobIds s√£o DIFERENTES antes de renderizar
        console.group('üîç [DISPLAY-MODAL] Valida√ß√£o de JobIds antes de renderizar');
        console.log('   - frozenRef.jobId:', frozenRef.jobId);
        console.log('   - frozenCurr.jobId:', frozenCurr.jobId);
        console.log('   - S√£o diferentes?', frozenRef.jobId !== frozenCurr.jobId);
        
        // Validar com getCorrectJobId() tamb√©m
        const expectedCurrentJobId = getCorrectJobId('current');
        const expectedReferenceJobId = getCorrectJobId('reference');
        console.log('   - getCorrectJobId("current"):', expectedCurrentJobId);
        console.log('   - getCorrectJobId("reference"):', expectedReferenceJobId);
        console.log('   - Esses tamb√©m s√£o diferentes?', expectedCurrentJobId !== expectedReferenceJobId);
        
        if (frozenRef.jobId === frozenCurr.jobId) {
            console.error('‚ùå [DISPLAY-MODAL] ERRO: frozenRef e frozenCurr t√™m o MESMO jobId!');
            console.error('   Isso significa que os dados est√£o contaminados!');
            console.trace();
            console.groupEnd();
            
            // Tentar recuperar usando getCorrectJobId
            console.warn('üîÑ [DISPLAY-MODAL] Tentando recuperar dados corretos...');
            // Por enquanto, ABORTAR para evitar renderiza√ß√£o incorreta
            alert('ERRO: N√£o foi poss√≠vel carregar a compara√ß√£o. Os dados est√£o contaminados. Recarregue a p√°gina.');
            return;
        }
        
        console.log('‚úÖ [DISPLAY-MODAL] JobIds s√£o diferentes - prosseguindo com renderiza√ß√£o');
        console.groupEnd();
        
        // ========================================
        // üß† USAR DADOS DO STORE SE DISPON√çVEL
        // ========================================
        let renderUserAnalysis, renderRefAnalysis;
        
        if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('üéØ [RENDER-STORE] Usando dados do store isolado para renderiza√ß√£o');
            renderUserAnalysis = frozenRef;   // J√° √© clone de comparisonPair.ref
            renderRefAnalysis = frozenCurr;   // J√° √© clone de comparisonPair.curr
        } else {
            console.log('‚ö†Ô∏è [RENDER-LEGACY] Usando dados legados para renderiza√ß√£o');
            renderUserAnalysis = frozenRef;
            renderRefAnalysis = frozenCurr;
        }
        
        // üéØ [METRICS-DEBUG] LOG CR√çTICO DAS M√âTRICAS ANTES DE RENDERIZAR
        console.group('üéØ [METRICS-DEBUG] M√©tricas ANTES de renderReferenceComparisons');
        console.table({
            'User LUFS': renderUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': renderRefAnalysis?.technicalData?.lufsIntegrated,
            'User DR': renderUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': renderRefAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': renderUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': renderRefAnalysis?.technicalData?.truePeakDbtp,
            'User JobId': renderUserAnalysis?.jobId,
            'Ref JobId': renderRefAnalysis?.jobId,
            'User File': renderUserAnalysis?.fileName || renderUserAnalysis?.metadata?.fileName,
            'Ref File': renderRefAnalysis?.fileName || renderRefAnalysis?.metadata?.fileName
        });
        console.log('‚úÖ [METRICS-DEBUG] Se os valores acima forem IGUAIS, h√° contamina√ß√£o!');
        console.groupEnd();
        
        renderReferenceComparisons({
            mode: 'reference',
            userAnalysis: renderUserAnalysis,        // 1¬™ faixa (sua m√∫sica) - CLONE INDEPENDENTE
            referenceAnalysis: renderRefAnalysis,    // 2¬™ faixa (refer√™ncia) - CLONE INDEPENDENTE
            analysis: {
                userAnalysis: renderUserAnalysis,
                referenceAnalysis: renderRefAnalysis
            },
            _useStoreData: analysis?._useStoreData  // Propagar flag
        });
        
        // ‚ùå REMOVIDO: renderTrackComparisonTable() - causava duplica√ß√£o
        // renderReferenceComparisons() j√° renderiza tudo
        console.log('‚úÖ [REFERENCE-RENDER] Renderiza√ß√£o √∫nica completa (sem duplica√ß√£o)');
        
        // Atualizar window.latestAnalysis para compatibilidade com IA e PDF
        window.latestAnalysis = {
            mode: "comparison",
            reference: window.referenceAnalysisData,
            current: analysis,
            scores: analysis.scores || {}
        };
        
        // ‚úÖ CORRE√á√ÉO CR√çTICA: N√ÉO retornar aqui!
        // Continuar para renderizar cards, scores e sugest√µes
        console.log('[AUDIT-FIX] ‚úÖ Continuando renderiza√ß√£o completa (cards, scores, sugest√µes)');
        
        // üéØ GARANTIR que sugest√µes de IA sejam chamadas tamb√©m no modo reference
        console.log('[AUDIT-FIX] ü§ñ Iniciando renderiza√ß√£o de sugest√µes de IA no modo reference');
        
        // ‚úÖ CORRE√á√ÉO: Garantir que analysisForSuggestions inclua suggestions completas
        const analysisForSuggestions = {
            ...(refNormalized || analysis),
            // ‚úÖ Preservar suggestions da an√°lise (pode vir do backend ou frontend)
            suggestions: 
                (refNormalized || analysis)?.suggestions || 
                (refNormalized || analysis)?.userAnalysis?.suggestions || 
                analysis?.suggestions ||
                [],
            mode: 'reference'
        };
        
        console.log('[SUG-AUDIT] reference deltas ready:', !!analysis.referenceComparison);
        console.log('[AUDIT-FIX] üìä analysisForSuggestions preparado:', {
            hasSuggestions: !!analysisForSuggestions.suggestions,
            suggestionsLength: analysisForSuggestions.suggestions?.length || 0,
            mode: analysisForSuggestions.mode,
            hasReferenceComparison: !!analysisForSuggestions.referenceComparison
        });
        
        // üî• Chamada ao displayModalResults no fluxo normal (n√£o self-compare)
        if (typeof AISuggestionsIntegration?.displayModalResults === 'function') {
            AISuggestionsIntegration.displayModalResults(currNormalized);
        }
        
        // Chamar sugest√µes de IA ap√≥s pequeno delay para garantir que DOM est√° pronto
        setTimeout(() => {
            if (window.aiUIController) {
                // üîç PASSO 1: LOG CR√çTICO ANTES de checkForAISuggestions
                console.group('üîç [PRE-AI-SUGGESTIONS] Estado ANTES de checkForAISuggestions');
                console.log('   - currentJobId (segunda m√∫sica):', window.__CURRENT_JOB_ID__);
                console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('   - analysisForSuggestions:', {
                    jobId: analysisForSuggestions?.jobId,
                    fileName: analysisForSuggestions?.fileName || analysisForSuggestions?.metadata?.fileName,
                    hasSuggestions: !!analysisForSuggestions?.suggestions,
                    suggestionsLength: analysisForSuggestions?.suggestions?.length || 0
                });
                
                // üîç [AUDITORIA_DOM] Verificar estado do DOM de sugest√µes
                const aiSection = document.getElementById('aiSuggestionsExpanded');
                const aiContent = document.getElementById('aiExpandedGrid');
                const existingSuggestions = aiContent?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                
                console.log('   [AUDITORIA_DOM] Estado ANTES:', {
                    aiSection: !!aiSection,
                    aiSectionVisible: aiSection?.style?.display !== 'none',
                    aiContent: !!aiContent,
                    suggestionsExistentes: existingSuggestions
                });
                console.groupEnd();
                
                console.log('[AUDIT-FIX] ‚úÖ Chamando aiUIController.checkForAISuggestions');
                console.log('[AUDIT-FIX] Passando analysisForSuggestions com', analysisForSuggestions?.suggestions?.length || 0, 'sugest√µes');
                window.aiUIController.checkForAISuggestions(analysisForSuggestions, true);
                
                // üîç PASSO 2: LOG CR√çTICO DEPOIS de checkForAISuggestions
                setTimeout(() => {
                    console.group('üîç [POST-AI-SUGGESTIONS] Estado DEPOIS de checkForAISuggestions');
                    console.log('   - currentJobId:', window.__CURRENT_JOB_ID__);
                    console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                    console.log('   - MUDOU?', window.__CURRENT_JOB_ID__ === window.__REFERENCE_JOB_ID__ ? '‚ùå CONTAMINADO!' : '‚úÖ Intacto');
                    
                    // üîç [AUDITORIA_DOM] Verificar estado do DOM de sugest√µes DEPOIS
                    const aiSectionAfter = document.getElementById('aiSuggestionsExpanded');
                    const aiContentAfter = document.getElementById('aiExpandedGrid');
                    const cardsAfter = aiContentAfter?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                    
                    console.log('   [AUDITORIA_DOM] Estado DEPOIS:', {
                        aiSection: !!aiSectionAfter,
                        aiSectionVisible: aiSectionAfter?.style?.display !== 'none',
                        aiContent: !!aiContentAfter,
                        cards: cardsAfter
                    });
                    
                    if (cardsAfter === 0) {
                        console.error('   [AUDITORIA_DOM] ‚ùå NENHUM CARD FOI RENDERIZADO!');
                        console.error('   [AUDITORIA_DOM] Poss√≠veis causas:');
                        console.error('   [AUDITORIA_DOM]   1. analysisForSuggestions n√£o tem suggestions[]');
                        console.error('   [AUDITORIA_DOM]   2. Fun√ß√£o checkForAISuggestions retornou cedo');
                        console.error('   [AUDITORIA_DOM]   3. Erro no renderCompactPreview()');
                    } else {
                        console.log('   [AUDITORIA_DOM] ‚úÖ', cardsAfter, 'cards renderizados com sucesso!');
                    }
                    console.groupEnd();
                }, 100); // Delay pequeno para dar tempo de renderizar
            } else if (window.forceShowAISuggestions) {
                console.log('[AUDIT-FIX] ‚úÖ Chamando forceShowAISuggestions');
                window.forceShowAISuggestions(analysisForSuggestions);
            } else {
                console.warn('[AUDIT-FIX] ‚ö†Ô∏è Nenhuma fun√ß√£o de IA dispon√≠vel');
            }
        }, 800);
        
        // ‚ö†Ô∏è IMPORTANTE: N√£o usar return aqui - continuar fluxo normal
        // return; // ‚Üê REMOVIDO
    }
    else {
        // üî¥ DIAGN√ìSTICO: Por que N√ÉO entrou no bloco A/B?
        console.error('üî¥üî¥üî¥ [DIAGN√ìSTICO-AB] N√ÉO ENTROU NO BLOCO A/B!');
        console.error('üî¥ [DIAGN√ìSTICO-AB] Motivo:');
        if (mode !== 'reference') {
            console.error('üî¥ [DIAGN√ìSTICO-AB]   ‚ùå mode !== "reference" (mode =', mode, ')');
        }
        if (!isSecondTrack) {
            console.error('üî¥ [DIAGN√ìSTICO-AB]   ‚ùå isSecondTrack = false');
            console.error('üî¥ [DIAGN√ìSTICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        }
        console.error('üî¥ [DIAGN√ìSTICO-AB] Sistema VAI RENDERIZAR EM MODO SINGLE-TRACK!');
        console.error('üî¥üî¥üî¥ [DIAGN√ìSTICO-AB] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    }
    
    // üéØ CORRE√á√ÉO: Definir modo baseado no contexto real da an√°lise
    // N√ÉO for√ßar genre se for primeira faixa de refer√™ncia
    if (mode === 'reference' && !isSecondTrack) {
        // Primeira faixa em modo reference - manter modo reference mas n√£o renderizar ainda
        state.render.mode = 'reference';
        console.log('‚úÖ [REFERENCE-FIRST] Primeira faixa de refer√™ncia - aguardando segunda');
    } else if (mode !== 'reference' || (mode === 'reference' && !window.referenceAnalysisData)) {
        // üîê PARTE 3.3: Trava do modo Reference ‚Äî N√ÉO for√ßar genre se estamos em fluxo de refer√™ncia
        const isReferenceFlowLocked =
            (state?.reference?.isSecondTrack === true) ||
            (!!window.__REFERENCE_JOB_ID__ && state?.render?.mode === "reference");

        if (!isReferenceFlowLocked) {
            // Modo genre genu√≠no
            state.render.mode = 'genre';
            console.log('‚úÖ [GENRE-MODE] Modo definido como GENRE no estado');
            
            // Limpar dados de refer√™ncia para evitar contamina√ß√£o APENAS em modo genre
            if (state.reference) {
                state.reference.isSecondTrack = false;
                state.reference.analysis = null;
            }
        } else {
            console.log('üîí [REF-LOCK] Modo reference travado ‚Äî genre for√ßado bloqueado');
        }
    }
    window.__soundyState = state;
    
    // üîí UI GATE: Verifica√ß√£o final antes de renderizar
    const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
    
    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
        console.warn('[AUDITORIA_CONDICAO] ‚ö†Ô∏è Retorno antecipado: analysisRunId !== currentRunId', { analysisRunId, currentRunId, mode: analysis?.mode });
        console.warn(`üö´ [UI_GATE] displayModalResults cancelado - an√°lise obsoleta (an√°lise: ${analysisRunId}, atual: ${currentRunId})`);
        return;
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const technicalData = document.getElementById('modalTechnicalData');
    
    if (!results || !technicalData) {
        console.warn('[AUDITORIA_CONDICAO] ‚ö†Ô∏è Retorno antecipado: !results || !technicalData', { hasResults: !!results, hasTechnicalData: !!technicalData, mode: analysis?.mode });
        console.error('‚ùå Elementos de resultado n√£o encontrados');
        return;
    }
    
    console.log('[AUDIT-FLOW-CHECK] ‚úÖ Todos os gates passaram - continuando para renderiza√ß√£o');
    
    // üî• CORRE√á√ÉO CR√çTICA: Abrir modal ANTES de renderizar modo g√™nero
    // O container #referenceComparisons s√≥ existe DEPOIS do modal ser aberto
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    results.style.display = 'block';
    console.log('[MODAL-OPEN] ‚úÖ Modal aberto - results.style.display = "block"');
    
    // üîß CORRE√á√ÉO CR√çTICA: Normalizar dados do backend para compatibilidade com front-end
    // ‚úÖ PATCH: Normaliza√ß√£o redundante REMOVIDA - dados j√° normalizados em handleModalFileSelection
    if (analysis && typeof analysis === 'object') {
        console.log('[AUDITORIA-RMS-LUFS] Verificando estado dos dados (j√° normalizados):', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.rms': analysis?.technicalData?.rms,
            'energy.rms': analysis?.energy?.rms,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'loudness.integrated': analysis?.loudness?.integrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
        });
        
        // üö´ PATCH: Normaliza√ß√£o redundante REMOVIDA para evitar contamina√ß√£o
        // ‚ùå analysis = normalizeBackendAnalysisData(analysis);
        console.log('[NORMALIZE-SKIP] ‚úÖ Evitando re-normaliza√ß√£o destrutiva - dados j√° normalizados em handleModalFileSelection');
        console.log('[NORMALIZE-SKIP] ‚úÖ Preservando integridade de referenceComparisonMetrics');
        
        console.log('[AUDITORIA-RMS-LUFS] Dados preservados:', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'loudness.integrated': analysis?.loudness?.integrated,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp,
            'energy.rms': analysis?.energy?.rms
        });
        console.log('üìä [DEBUG] Dados preservados para exibi√ß√£o:', analysis);
        
        // üéØ RECALCULAR hasReferenceComparisonMetrics AP√ìS NORMALIZA√á√ÉO
        const state = window.__soundyState || {};
        state.hasReferenceComparisonMetrics = computeHasReferenceComparisonMetrics(analysis);
        window.__soundyState = state;
        console.log('[ASSERT] hasReferenceComparisonMetrics recalculado ap√≥s normaliza√ß√£o:', state.hasReferenceComparisonMetrics);
        
        // üõ°Ô∏è PASSO 2: GARANTIR analysis.referenceComparison EXISTE
        if (!analysis.referenceComparison) {
            analysis.referenceComparison = {};
            console.log('üõ°Ô∏è [PASSO 2] Criado analysis.referenceComparison vazio');
        }
        
        // üéØ CORRE√á√ÉO CR√çTICA: Preencher targets de G√äNERO completos
        const mode = analysis?.mode || currentAnalysisMode || 'genre';
        const isGenreMode = mode === 'genre';
        
        if (isGenreMode) {
            // Obter targets de g√™nero de m√∫ltiplas fontes
            const genreTargets = window.__activeRefData || 
                                window.PROD_AI_REF_DATA?.[analysis.genre] || 
                                window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE] || 
                                {};
            
            console.log('üéØ [GENRE-TARGETS-MERGE] Mesclando targets de g√™nero:', {
                hasGenreTargets: !!genreTargets,
                hasBands: !!(genreTargets.bands),
                source: window.__activeRefData ? '__activeRefData' : 'PROD_AI_REF_DATA'
            });
            
            if (genreTargets && Object.keys(genreTargets).length > 0) {
                // Fonte prim√°ria: referenceComparison ou referenceComparisonMetrics
                const src = genreTargets.referenceComparison || 
                           genreTargets.referenceComparisonMetrics || 
                           genreTargets;
                
                // ‚úÖ CR√çTICO: Mesclar TODOS os targets incluindo bandas
                if (src.lufs_target != null)   analysis.referenceComparison.lufs_target   = src.lufs_target;
                if (src.tp_target != null)     analysis.referenceComparison.tp_target     = src.tp_target;
                if (src.dr_target != null)     analysis.referenceComparison.dr_target     = src.dr_target;
                if (src.lra_target != null)    analysis.referenceComparison.lra_target    = src.lra_target;
                if (src.stereo_target != null) analysis.referenceComparison.stereo_target = src.stereo_target;
                
                // ‚úÖ CR√çTICO: Incluir BANDAS de g√™nero
                if (src.bands && Object.keys(src.bands).length > 0) {
                    analysis.referenceComparison.bands = src.bands;
                    console.log('‚úÖ [GENRE-BANDS-MERGED] Bandas de g√™nero inclu√≠das:', Object.keys(src.bands));
                }
                
                // Marcar como targets de g√™nero
                analysis.referenceComparison._isGenreMode = true;
                analysis.referenceComparison._genreTargetsLoaded = true;
            } else {
                console.warn('‚ö†Ô∏è [GENRE-TARGETS-MERGE] Targets de g√™nero n√£o encontrados, usando fallback');
                // Fallback com valores padr√£o
                if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = -14;
                if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = -1;
                if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = 8;
                if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = 6;
                if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = 0.1;
            }
        } else {
            // Modo refer√™ncia: usar fallback simples
            const genreTargets = __activeRefData || {};
            if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = genreTargets.lufs_target ?? -14;
            if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = genreTargets.true_peak_target ?? -1;
            if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = genreTargets.dr_target ?? 8;
            if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = genreTargets.lra_target ?? 6;
            if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = genreTargets.stereo_target ?? 0.1;
        }
        
        console.log('‚úÖ [PASSO 2] analysis.referenceComparison garantido:', {
            hasBands: !!analysis.referenceComparison.bands,
            bandsCount: analysis.referenceComparison.bands ? Object.keys(analysis.referenceComparison.bands).length : 0,
            isGenreMode: analysis.referenceComparison._isGenreMode,
            targets: {
                lufs: analysis.referenceComparison.lufs_target,
                tp: analysis.referenceComparison.tp_target,
                dr: analysis.referenceComparison.dr_target
            }
        });
    }
    
    /* =========[ BLOCO: SCORES A/B ‚Äì substitui 4888‚Äì5050 ]========= */

    /** Utilit√°rios robustos (n√£o colidem com nomes existentes) */
    const __EPS = 1e-3;
    const __DB_EPS = 0.5; // ~0.5 dB para "iguais"
    const __MIN_BANDS = 7;

    function __num(v){ return typeof v === 'number' && isFinite(v); }
    function __ae(a,b,eps=__EPS){ return __num(a) && __num(b) && Math.abs(a-b) <= eps; }
    function __keys(o){ return o ? Object.keys(o) : []; }

    function __getBandsSafe(from) {
      // aceita objetos tipo analysis, referenceFull, technicalData.spectral_balance etc.
      if (!from) return null;

      // 1) caminhos mais prov√°veis
      const td = from.technicalData || from.technical_data || null;
      if (td && td.spectral_balance) return td.spectral_balance;
      if (from.metrics && from.metrics.bands) return from.metrics.bands;
      if (from.bands) return from.bands;

      // 2) objetos j√° no formato bandas
      const maybeBands = (from.sub || from.lowMid || from.low_mid) ? from : null;
      if (maybeBands) return maybeBands;

      return null;
    }

    function __normalizeBandKeys(b) {
      if (!b) return null;
      // normaliza low_mid->lowMid, high_mid->highMid etc.
      const map = {
        sub: 'sub', bass: 'bass',
        low_mid: 'lowMid', lowmid: 'lowMid', lowMid: 'lowMid',
        mid: 'mid',
        high_mid: 'highMid', highmid: 'highMid', highMid: 'highMid',
        presence: 'presence', air: 'air',
        total: 'totalPercentage', total_percentage: 'totalPercentage', totalPercentage: 'totalPercentage',
        _status: '_status'
      };
      const out = {};
      for (const k of Object.keys(b)) {
        const nk = map[k] || k;
        out[nk] = b[k];
      }
      return out;
    }

    function __bandsAreMeaningful(bands) {
      if (!bands) return false;
      const k = __keys(bands).filter(k => ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (k.length < __MIN_BANDS) return false;
      // precisa ter varia√ß√£o real (evita vetor todo zero)
      const vals = k.map(k => bands[k]).filter(__num);
      if (vals.length < __MIN_BANDS) return false;
      const max = Math.max(...vals), min = Math.min(...vals);
      return isFinite(max) && isFinite(min) && (Math.abs(max - min) > 0.2); // >0.2 dB de amplitude m√≠nima
    }

    function __bandsSimilar(a, b, epsDb = __DB_EPS) {
      if (!a || !b) return false;
      const ak = __keys(a), bk = __keys(b);
      const common = ak.filter(k => bk.includes(k) && ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (common.length < __MIN_BANDS) return false;
      let equal = 0;
      for (const k of common) {
        if (__num(a[k]) && __num(b[k]) && Math.abs(a[k] - b[k]) <= epsDb) equal++;
      }
      return equal >= __MIN_BANDS; // praticamente iguais
    }

    function __tracksLookSame(userTd, refTd, userMd, refMd, userBands, refBands) {
      // ========================================
      // üîß CORRE√á√ÉO: Detec√ß√£o segura de self-compare usando jobId e VID
      // ========================================
      // Recuperar objetos completos para acessar jobId e vid
      const userFull = referenceComparisonMetrics?.userFull || {};
      const refFull = referenceComparisonMetrics?.referenceFull || {};
      
      // Crit√©rio 1: jobId id√™ntico (mais confi√°vel)
      const sameJobId = !!(userFull?.jobId && refFull?.jobId && userFull.jobId === refFull.jobId);
      
      // Crit√©rio 2: Virtual ID id√™ntico (detecta mesmo jobId::ROLE)
      const sameVid = !!(userFull?.vid && refFull?.vid && userFull.vid === refFull.vid);
      
      // Crit√©rio 3: Fallback - fileName id√™ntico APENAS se n√£o h√° jobId em nenhum dos dois
      const sameName = (
        !userFull?.jobId && 
        !refFull?.jobId && 
        !!userMd?.fileName && 
        !!refMd?.fileName && 
        userMd.fileName === refMd.fileName
      );
      
      // Crit√©rios t√©cnicos (mantidos para valida√ß√£o adicional)
      const sameLufs = __ae(userTd?.lufsIntegrated, refTd?.lufsIntegrated, 0.05);
      const sameTp   = __ae(userTd?.truePeakDbtp,  refTd?.truePeakDbtp,  0.05);
      const sameDr   = __ae(userTd?.dynamicRange,  refTd?.dynamicRange,  0.1);
      const sameCent = __ae(userTd?.spectralCentroidHz, refTd?.spectralCentroidHz, 5);
      const sameBands = __bandsSimilar(userBands, refBands);
      
      // Self-compare detectado se:
      // 1. jobId id√™ntico OU
      // 2. VID id√™ntico OU
      // 3. Sem jobId em ambos E fileName id√™ntico OU
      // 4. Todas as m√©tricas t√©cnicas id√™nticas E bands similares
      const isSelfCompare = sameJobId || sameVid || sameName || (sameLufs && sameTp && sameDr && sameCent && sameBands);
      
      // Log de auditoria
      console.log("[COMPARE-FLAG] selfCompare:", isSelfCompare, {
        userJobId: userFull?.jobId || 'N/A',
        refJobId: refFull?.jobId || 'N/A',
        sameJobId,
        userVid: userFull?.vid || window.CacheIndex?.USER || 'N/A',
        refVid: refFull?.vid || window.CacheIndex?.REF || 'N/A',
        sameVid,
        userFile: userMd?.fileName || 'N/A',
        refFile: refMd?.fileName || 'N/A',
        sameName,
        technicalMatch: sameLufs && sameTp && sameDr && sameCent && sameBands,
        criteria: {
          sameJobId,
          sameVid,
          sameName,
          sameLufs,
          sameTp,
          sameDr,
          sameCent,
          sameBands
        }
      });
      
      return isSelfCompare;
    }

    /** 1) Extrai estruturas normalizadas que j√° existem nesse ponto do fluxo */
    // üîß FIX CR√çTICO: Mudado de const para let para permitir recupera√ß√£o em caso de contamina√ß√£o
    let userFull  = referenceComparisonMetrics?.userFull;       // 1¬™ faixa (sua m√∫sica)
    let refFull   = referenceComparisonMetrics?.referenceFull;  // 2¬™ faixa (refer√™ncia)
    
    // ÔøΩ HARD-GUARD: Se userFull est√° undefined, recuperar de FirstAnalysisStore.get()
    if (!userFull && FirstAnalysisStore.has()) {
        console.warn('[SAFEGUARD] userFull est√° undefined ‚Äî recuperando de FirstAnalysisStore');
        userFull = structuredClone(FirstAnalysisStore.get());
        console.log('[SAFEGUARD] ‚úÖ userFull recuperado:', {
            fileName: userFull?.metadata?.fileName,
            jobId: userFull?.jobId
        });
    }

    let userTd    = referenceComparisonMetrics?.userTrack   || {};
    let refTd     = referenceComparisonMetrics?.referenceTrack || {};
    let userMd    = userFull?.metadata || {};
    let refMd     = refFull?.metadata  || {};

    // bandas A/B normalizadas + keys padronizadas
    let userBands = __normalizeBandKeys(__getBandsSafe(userFull));
    let refBands  = __normalizeBandKeys(__getBandsSafe(refFull));

    /** 2) Hard-gates antes de montar o objeto de score */
    const isReferenceMode = !!(referenceComparisonMetrics && referenceComparisonMetrics.reference);
    
    // üîç LOG DE VERIFICA√á√ÉO M√çNIMO (tempor√°rio - conforme item 7 do plano)
    console.log('[AB-CHECK]', {
        userJobId: userFull?.jobId,
        refJobId: refFull?.jobId,
        userName: userFull?.metadata?.fileName,
        refName: refFull?.metadata?.fileName
    });
    
    // ‚úÖ PATCH: Valida√ß√£o de integridade ANTES de calcular selfCompare
    console.log('[INTEGRITY-CHECK] Validando dados antes de calcular score:', {
        userFileName: userMd.fileName,
        refFileName: refMd.fileName,
        userLUFS: userTd.lufsIntegrated,
        refLUFS: refTd.lufsIntegrated,
        sameFile: userMd.fileName === refMd.fileName,
        sameLUFS: userTd.lufsIntegrated && refTd.lufsIntegrated ? 
            Math.abs(userTd.lufsIntegrated - refTd.lufsIntegrated) < 0.05 : false
    });
    
    // üö® PATCH: Alerta cr√≠tico se arquivos s√£o iguais (contamina√ß√£o detectada)
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.error('[INTEGRITY-CHECK] ‚ùå FALHA CR√çTICA: userFile === refFile');
        console.error('[INTEGRITY-CHECK] ‚ùå Prov√°vel contamina√ß√£o de dados!');
        console.error('[INTEGRITY-CHECK] ‚ùå Tentando recuperar de state.previousAnalysis...');
        
        // Tentar recuperar userFull de previousAnalysis
        if (state.previousAnalysis.metadata?.fileName !== refMd.fileName) {
            console.warn('[INTEGRITY-CHECK] ‚ö†Ô∏è Recuperando userFull de state.previousAnalysis');
            
            // üõ°Ô∏è PROTE√á√ÉO: SEMPRE usar clone para evitar contamina√ß√£o de ponteiros
            console.log('[SAFEGUARD] Clonando state.previousAnalysis para evitar refer√™ncia compartilhada');
            const recoveredUserFull = structuredClone(state.previousAnalysis);
            const recoveredUserMd = recoveredUserFull.metadata || {};
            const recoveredUserTd = recoveredUserFull.technicalData || {};
            const recoveredUserBands = __normalizeBandKeys(__getBandsSafe(recoveredUserFull));
            
            // Reatribuir vari√°veis recuperadas
            userFull = recoveredUserFull;
            userMd = recoveredUserMd;
            userTd = recoveredUserTd;
            userBands = recoveredUserBands;
            
            console.log('[INTEGRITY-CHECK] ‚úÖ Dados recuperados de state.previousAnalysis:', {
                fileName: recoveredUserMd.fileName,
                lufs: recoveredUserTd.lufsIntegrated
            });
        }
    }
    
    // üîç AUDITORIA: Estado ANTES de calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] üéØ ANTES de __tracksLookSame (selfCompare)');
    console.log('‚öôÔ∏è Contexto: Prestes a calcular selfCompare');
    console.log('üìä userMd (1¬™ faixa metadata):', {
        fileName: userMd?.fileName,
        objectId: userMd
    });
    console.log('üìä refMd (2¬™ faixa metadata):', {
        fileName: refMd?.fileName,
        objectId: refMd
    });
    console.log('üìä userTd (1¬™ faixa technicalData):', {
        lufs: userTd?.lufsIntegrated,
        dr: userTd?.dynamicRange,
        objectId: userTd
    });
    console.log('üìä refTd (2¬™ faixa technicalData):', {
        lufs: refTd?.lufsIntegrated,
        dr: refTd?.dynamicRange,
        objectId: refTd
    });
    console.log('üìä userFull (origem):', {
        fileName: userFull?.metadata?.fileName,
        jobId: userFull?.jobId,
        objectId: userFull
    });
    console.log('üìä refFull (origem):', {
        fileName: refFull?.metadata?.fileName,
        jobId: refFull?.jobId,
        objectId: refFull
    });
    console.log('‚ö†Ô∏è PR√â-VERIFICA√á√ÉO DE CONTAMINA√á√ÉO:');
    console.log('  userMd.fileName === refMd.fileName?', userMd?.fileName === refMd?.fileName);
    console.log('  userFull === refFull?', userFull === refFull);
    console.log('  userTd === refTd?', userTd === refTd);
    console.groupEnd();
    
    // üõ°Ô∏è PROTE√á√ÉO: Detectar e corrigir contamina√ß√£o ANTES de __tracksLookSame
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.warn('[FIX] üö® Detec√ß√£o de self-compare FALSO ‚Äì isolando referenceAnalysis');
        console.warn('[FIX] userFull foi contaminado com dados de refFull');
        console.warn('[FIX] Tentando recuperar de FirstAnalysisStore...');
        
        // ÔøΩ HARD-GUARD: SEMPRE usar FirstAnalysisStore.get() como fonte confi√°vel
        if (!FirstAnalysisStore.has()) {
            console.error('[FIX] ‚ùå FirstAnalysisStore vazio! Abortando recupera√ß√£o...');
            return;
        }
        
        // Recuperar primeira an√°lise de fonte confi√°vel (APENAS FirstAnalysisStore)
        const safeUserFull = structuredClone(FirstAnalysisStore.get());
        userFull = safeUserFull;
        userMd = safeUserFull.metadata || {};
        userTd = safeUserFull.technicalData || {};
        userBands = __normalizeBandKeys(__getBandsSafe(safeUserFull));
        
        console.log('[FIX] ‚úÖ userFull recuperado:', {
            fileName: userMd.fileName,
            lufs: userTd.lufsIntegrated,
            source: 'FirstAnalysisStore'
        });
    }
    
    // üõ°Ô∏è VALIDA√á√ÉO FINAL: Garantir que userFull e refFull s√£o DIFERENTES ap√≥s todas as recupera√ß√µes
    console.group('üîç [FINAL VALIDATION] Verifica√ß√£o final de contamina√ß√£o');
    console.log('userMd.fileName:', userMd?.fileName);
    console.log('refMd.fileName:', refMd?.fileName);
    console.log('userFull.jobId:', userFull?.jobId);
    console.log('refFull.jobId:', refFull?.jobId);
    console.log('userFull === refFull?', userFull === refFull);
    console.log('userMd === refMd?', userMd === refMd);
    console.log('userTd === refTd?', userTd === refTd);
    console.log('userBands === refBands?', userBands === refBands);
    console.groupEnd();
    
    // ‚úÖ VALIDA√á√ÉO FINAL: Log apenas, n√£o bloqueia renderiza√ß√£o
    if (userMd?.fileName === refMd?.fileName || userFull?.jobId === refFull?.jobId) {
        console.warn('[INFO] ‚ö†Ô∏è Mesmo jobId/fileName detectado (self-compare falso). Continuando render normalmente.');
        console.warn('[INFO] userMd.fileName:', userMd?.fileName);
        console.warn('[INFO] refMd.fileName:', refMd?.fileName);
        console.warn('[INFO] userFull.jobId:', userFull?.jobId);
        console.warn('[INFO] refFull.jobId:', refFull?.jobId);
        // ‚úÖ N√ÉO RETORNA AQUI! Continua o fluxo para permitir renderiza√ß√£o
    } else {
        console.log('[FINAL VALIDATION] ‚úÖ Dados validados - userFull e refFull s√£o DIFERENTES');
    }
    
    // ‚úÖ STEP 6/6 (FINAL): Integrity check - apenas log, n√£o bloqueia
    if (areSameTrack(userFull, refFull)) {
        console.warn('[INFO] ‚ö†Ô∏è areSameTrack() retornou true (self-compare falso). Continuando render normalmente.');
        // ‚úÖ N√ÉO RETORNA AQUI! Continua o fluxo para permitir renderiza√ß√£o
    } else {
        console.log('[INTEGRITY CHECK] ‚úÖ userFull e refFull s√£o diferentes ‚Äî prosseguindo com c√°lculo');
    }
    
    // üéØ ROOT CAUSE FIX: Detectar modo g√™nero ANTES de calcular refBandsOK
    // Em modo g√™nero, refBands vem de genreTargets, N√ÉO de referenceAnalysis!
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    let finalRefBands = refBands;
    
    if (isGenreMode) {
        console.log('üéØ [GENRE-BANDS-FIX] Modo G√äNERO detectado - buscando bandas de genreTargets');
        
        // Buscar bandas dos targets de g√™nero carregados
        const genreTargets = window.__activeRefData || 
                           analysis?.referenceComparison || 
                           (analysis?.genre ? window.PROD_AI_REF_DATA?.[analysis.genre] : null);
        
        if (genreTargets) {
            // Tentar extrair bandas de diferentes estruturas poss√≠veis
            finalRefBands = genreTargets.bands || 
                          genreTargets.legacy_compatibility?.bands ||
                          genreTargets.hybrid_processing?.spectral_bands ||
                          null;
            
            console.log('üéØ [GENRE-BANDS-FIX] Bandas de g√™nero encontradas:', {
                source: genreTargets.bands ? 'bands' : 
                       genreTargets.legacy_compatibility?.bands ? 'legacy_compatibility.bands' :
                       genreTargets.hybrid_processing?.spectral_bands ? 'hybrid_processing.spectral_bands' : 'null',
                bands: finalRefBands ? Object.keys(finalRefBands) : 'null',
                genre: analysis?.genre
            });
        } else {
            console.warn('‚ö†Ô∏è [GENRE-BANDS-FIX] Targets de g√™nero N√ÉO encontrados! refBands ser√° null');
        }
    } else {
        console.log('üîÑ [AB-MODE] Modo A/B detectado - usando refBands de referenceAnalysis');
    }
    
    const selfCompare = __tracksLookSame(userTd, refTd, userMd, refMd, userBands, finalRefBands);
    const refBandsOK  = __bandsAreMeaningful(finalRefBands);
    const userBandsOK = __bandsAreMeaningful(userBands);

    // üß™ MODO VERIFICA√á√ÉO: Log estruturado com console.table
    console.table({
        'userFile': userMd?.fileName || 'N/A',
        'refFile': refMd?.fileName || 'N/A',
        'sameFile': userMd?.fileName === refMd?.fileName,
        'userJobId': userFull?.jobId || 'N/A',
        'refJobId': refFull?.jobId || 'N/A',
        'sameJobId': userFull?.jobId === refFull?.jobId,
        'userLUFS': userTd?.lufsIntegrated || 'N/A',
        'refLUFS': refTd?.lufsIntegrated || 'N/A',
        'userBandsOK': userBandsOK,
        'refBandsOK': refBandsOK,
        'isGenreMode': isGenreMode,
        'finalRefBands': finalRefBands ? 'OK' : 'null'
    });
    
    console.log('[VERIFY_AB_ORDER]', {
      mode: state.render.mode,
      isGenreMode: isGenreMode,
      userFile: userMd.fileName, refFile: refMd.fileName,
      userLUFS: userTd.lufsIntegrated, refLUFS: refTd.lufsIntegrated,
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      refBands: refBandsOK  ? __keys(finalRefBands)  : 'ausente',
      selfCompare
    });
    
    // üîç AUDITORIA: Estado AP√ìS calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚úÖ DEPOIS de __tracksLookSame');
    console.log('‚öôÔ∏è Contexto: selfCompare calculado');
    console.log('üéØ selfCompare:', selfCompare);
    console.log('üéØ refBandsOK:', refBandsOK);
    console.log('üéØ userBandsOK:', userBandsOK);
    console.log('üéØ disableFrequency ser√°:', !refBandsOK || !userBandsOK || selfCompare);
    if (selfCompare) {
        console.warn('‚ö†Ô∏è selfCompare TRUE detectado - score ser√° 100%');
        console.warn('‚ö†Ô∏è Verificar se √© leg√≠timo (mesma faixa 2x) ou contamina√ß√£o');
    }
    console.groupEnd();

    /** 2.5) FUN√á√ÉO CR√çTICA: Injetar targets de g√™nero em refData */
    function injectGenreTargetsIntoRefData(refData, genreTargets) {
        if (!refData || !genreTargets) return refData;
        
        const fields = [
            "lufs_target",
            "true_peak_target",
            "dr_target",
            "lra_target",
            "stereo_target",
            "bands",
            "tol_lufs",
            "tol_true_peak",
            "tol_dr",
            "tol_lra",
            "tol_stereo"
        ];
        
        fields.forEach(key => {
            if (genreTargets[key] !== undefined) {
                refData[key] = genreTargets[key];
            }
        });
        
        console.log("[GENRE-FIX] Targets injetados em refData:", {
            lufs_target: refData.lufs_target,
            true_peak_target: refData.true_peak_target,
            dr_target: refData.dr_target,
            stereo_target: refData.stereo_target,
            hasBands: !!refData.bands,
            bandsCount: refData.bands ? Object.keys(refData.bands).length : 0
        });
        
        return refData;
    }

    /** 3) Se refer√™ncia n√£o √© v√°lida ou A==B, rebaixa o score de frequ√™ncia via "disable" e re-normaliza pesos */
    let disableFrequency = false;
    let referenceDataForScores = null;

    if (!refBandsOK || !userBandsOK || selfCompare) {
      disableFrequency = true;
      console.warn('‚ö†Ô∏è [SCORES-GUARD] Desativando score de Frequ√™ncia:',
        { refBandsOK, userBandsOK, selfCompare, isGenreMode });

      // monta alvo somente com m√©tricas escalares (sem bandas)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: null, // for√ßa desativado
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _disabledBands: true
      };
    } else {
      // fluxo normal (A/B saud√°vel OU modo g√™nero com targets)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: finalRefBands, // <- bandas reais (de refer√™ncia A/B ou g√™nero)
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true
      };
    }

    console.log('[SCORE-FIX] Bandas preparadas p/ c√°lculo:', {
      disableFrequency, 
      refBands: referenceDataForScores.bands ? __keys(referenceDataForScores.bands) : 'desativado',
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      isGenreMode: isGenreMode
    });

    /** 4) C√°lculo seguro com prote√ß√£o de toler√¢ncia e re-balanceamento de pesos */
    function __safeCalculateAnalysisScores(analysisObj, refData, genre) {
      // Protege toler√¢ncias (evita tolDb=0)
      if (!refData || typeof refData !== 'object') refData = {};
      if (!__num(refData.tol_spectral) || refData.tol_spectral <= 0) refData.tol_spectral = 300;

      // üéØ CORRE√á√ÉO: Detectar modo g√™nero e targets de m√∫ltiplas fontes
      const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
      
      // üéØ CORRE√á√ÉO: Buscar targets de g√™nero de todas as fontes poss√≠veis
      const genreTargets = window.__activeRefData || 
                          window.PROD_AI_REF_DATA?.[analysisObj?.genre] || 
                          window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE];
      
      const genreBands = genreTargets?.bands || 
                        genreTargets?.referenceComparison?.bands ||
                        analysisObj?.referenceComparison?.bands;
      
      // ‚úÖ CR√çTICO: hasGenreTargets deve ser true se houver targets ou bandas
      const hasGenreTargets = isGenreMode && (
        !!genreTargets || 
        !!(analysisObj?.referenceComparison?._genreTargetsLoaded) ||
        !!(analysisObj?.referenceComparison?.bands)
      );
      
      const hasRefBands = !!(genreBands && Object.keys(genreBands).length > 0);
      const refBandsOK = hasRefBands;
      
      console.log('üîç [SCORES-GUARD-ENHANCED]', {
        isGenreMode,
        hasGenreTargets,
        hasRefBands,
        refBandsOK,
        analysisMode: analysisObj?.mode,
        viewMode: window.__soundyState?.render?.mode,
        refDataHasBands: !!(refData?.bands),
        genreTargetsFound: !!genreTargets,
        genreBandsCount: genreBands ? Object.keys(genreBands).length : 0,
        isReferenceMode: refData?._isReferenceMode,
        disabledBands: refData?._disabledBands
      });

      // Chama o c√°lculo original
      const out = calculateAnalysisScores(analysisObj, refData, genre) || {};

      // üéØ DECIS√ÉO DE DESATIVAR FREQU√äNCIA:
      // - Modo REFERENCE: desativar se !refData.bands ou _disabledBands
      // - Modo GENRE: N√ÉO desativar se houver targets de g√™nero carregados
      const shouldDisableFrequency = isGenreMode 
        ? (!hasGenreTargets && (!refData.bands || refData._disabledBands)) // Modo g√™nero: s√≥ desativar se N√ÉO houver targets
        : (!refData.bands || refData._disabledBands); // Modo reference: desativar se sem bandas A/B
      
      if (shouldDisableFrequency) {
        const subs = out.subscores || out; // compat: alguns retornam direto
        const weights = {
          loudness: 0.32, dinamica: 0.23, frequencia: 0.0, estereo: 0.15, tecnico: 0.30 // soma = 1.0
        };
        // recomputa final de forma defensiva
        const lv = __num(subs.loudness)   ? subs.loudness   : 0;
        const dv = __num(subs.dinamica)   ? subs.dinamica   : 0;
        const ev = __num(subs.estereo)    ? subs.estereo    : 0;
        const tv = __num(subs.tecnico)    ? subs.tecnico    : 0;
        const final = Math.round(
          lv*weights.loudness + dv*weights.dinamica + ev*weights.estereo + tv*weights.tecnico
        );
        out.final = final;
        out._weightsApplied = weights;
        out._freqDisabled = true;
        console.warn('‚ö†Ô∏è [SCORES-GUARD] Frequ√™ncia desativada ‚áí pesos re-normalizados', weights);
      } else if (isGenreMode && hasGenreTargets) {
        console.log('‚úÖ [SCORES-GUARD] Modo G√äNERO: Frequ√™ncia ATIVADA (targets de g√™nero dispon√≠veis)');
      }

      // Hard-cap de True Peak continua valendo (o seu j√° est√° aplicado antes)
      return out;
    }

    /** 5) EXECUTA o c√°lculo com o objeto blindado */
    const detectedGenre = analysis.metadata?.genre || analysis.genre || __activeRefGenre;
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üîç PARTE 4: TESTE DE INSPE√á√ÉO OBRIGAT√ìRIO (PR√â-C√ÅLCULO)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.group("üîç [AUDIT-BACKEND-FLOW] M√âTRICAS RECEBIDAS DO BACKEND");
    console.log("üìä analysis.technicalData:", analysis.technicalData);
    console.log("üìä analysis.metrics:", analysis.metrics);
    console.log("üîë Keys technicalData:", Object.keys(analysis.technicalData || {}));
    console.log("üîë Keys metrics:", Object.keys(analysis.metrics || {}));
    console.log("üìç M√©tricas espec√≠ficas:");
    console.log("  - technicalData.lufsIntegrated:", analysis.technicalData?.lufsIntegrated);
    console.log("  - metrics.lufs_integrated:", analysis.metrics?.lufs_integrated);
    console.log("  - technicalData.truePeakDbtp:", analysis.technicalData?.truePeakDbtp);
    console.log("  - metrics.true_peak_dbtp:", analysis.metrics?.true_peak_dbtp);
    console.log("  - technicalData.dynamicRange:", analysis.technicalData?.dynamicRange);
    console.log("  - metrics.dynamic_range:", analysis.metrics?.dynamic_range);
    console.log("  - technicalData.lra:", analysis.technicalData?.lra);
    console.log("  - metrics.lra:", analysis.metrics?.lra);
    console.log("  - technicalData.stereoCorrelation:", analysis.technicalData?.stereoCorrelation);
    console.log("  - metrics.stereo_correlation:", analysis.metrics?.stereo_correlation);
    console.log("  - technicalData.stereoWidth:", analysis.technicalData?.stereoWidth);
    console.log("  - metrics.stereo_width:", analysis.metrics?.stereo_width);
    console.log("üìå Targets para c√°lculo (refData):");
    console.log("  - lufs_target:", referenceDataForScores?.lufs_target);
    console.log("  - true_peak_target:", referenceDataForScores?.true_peak_target);
    console.log("  - dr_target:", referenceDataForScores?.dr_target);
    console.log("  - lra_target:", referenceDataForScores?.lra_target);
    console.log("  - stereo_target:", referenceDataForScores?.stereo_target);
    console.log("  - bands:", referenceDataForScores?.bands ? Object.keys(referenceDataForScores.bands) : 'null');
    console.groupEnd();
    
    // üéØ [GENRE-FIX] CR√çTICO: Aplicar targets de g√™nero SOMENTE no modo genre
    // ‚ö†Ô∏è NUNCA AFETA MODO REFERENCE
    if (isGenreMode) {
        console.log("[GENRE-FIX] ‚úÖ Modo genre detectado - aplicando targets oficiais");
        
        // üéØ USAR NOVA FUN√á√ÉO: extractGenreTargets (FONTE OFICIAL)
        const officialGenreTargets = extractGenreTargets(analysis);
        
        if (officialGenreTargets) {
            console.log("[GENRE-FIX] ‚úÖ Targets encontrados em analysis.data.genreTargets (FONTE OFICIAL)");
            console.log("[GENRE-FIX] Targets:", {
                lufs_target: officialGenreTargets.lufs_target,
                true_peak_target: officialGenreTargets.true_peak_target,
                dr_target: officialGenreTargets.dr_target,
                stereo_target: officialGenreTargets.stereo_target,
                hasBands: !!officialGenreTargets.bands,
                bandsCount: officialGenreTargets.bands ? Object.keys(officialGenreTargets.bands).length : 0
            });
            
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, officialGenreTargets);
        } else if (window.__activeRefData) {
            // üéØ FALLBACK: Usar window.__activeRefData apenas se n√£o houver targets oficiais
            console.warn("[GENRE-FIX] ‚ö†Ô∏è FALLBACK: Usando window.__activeRefData");
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, window.__activeRefData);
        } else {
            // üéØ FALLBACK FINAL: Carregar defaults
            console.warn("[GENRE-FIX] ‚ö†Ô∏è Nenhum target encontrado - carregando defaults");
            const defaultTargets = loadDefaultGenreTargets(extractGenreName(analysis));
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, defaultTargets);
        }
    }
    // üõ°Ô∏è MODO REFERENCE: N√£o fazer NADA - referenceDataForScores permanece intacto
    
    // üéØ [FLOW-FIX] Calculando scores AP√ìS normaliza√ß√£o de m√©tricas
    console.log("[FLOW-FIX] Calculando scores AP√ìS normaliza√ß√£o de m√©tricas.");
    
    const analysisScores = __safeCalculateAnalysisScores(analysis, referenceDataForScores, detectedGenre);

    if (analysisScores) {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üîç TAREFA 1: AUDITORIA COMPLETA DA ESTRUTURA DE SCORES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        console.group('üîç [AUDIT-SCORES] ESTRUTURA COMPLETA DE analysisScores');
        console.log('[AUDIT-SCORES] analysisScores bruto:', analysisScores);
        console.log('[AUDIT-SCORES] keys:', Object.keys(analysisScores || {}));
        console.log('[AUDIT-SCORES] Subscores individuais:');
        console.log('  - analysisScores.loudness:', analysisScores.loudness);
        console.log('  - analysisScores.dinamica:', analysisScores.dinamica);
        console.log('  - analysisScores.dynamics:', analysisScores.dynamics);
        console.log('  - analysisScores.estereo:', analysisScores.estereo);
        console.log('  - analysisScores.stereo:', analysisScores.stereo);
        console.log('  - analysisScores.frequency:', analysisScores.frequency);
        console.log('  - analysisScores.frequencia:', analysisScores.frequencia);
        console.log('  - analysisScores.technical:', analysisScores.technical);
        console.log('  - analysisScores.tecnico:', analysisScores.tecnico);
        console.log('  - analysisScores.subscores (objeto):', analysisScores.subscores);
        if (analysisScores.subscores) {
            console.log('    ‚Üí subscores.loudness:', analysisScores.subscores.loudness);
            console.log('    ‚Üí subscores.dynamics:', analysisScores.subscores.dynamics);
            console.log('    ‚Üí subscores.stereo:', analysisScores.subscores.stereo);
            console.log('    ‚Üí subscores.frequency:', analysisScores.subscores.frequency);
            console.log('    ‚Üí subscores.technical:', analysisScores.subscores.technical);
        }
        console.log('  - analysisScores.breakdown:', analysisScores.breakdown);
        console.log('  - analysisScores.final:', analysisScores.final);
        console.log('  - analysisScores.composite:', analysisScores.composite);
        
        // üîç PARTE 5: DIAGN√ìSTICO FINAL - Identificar subscores NULL
        const nullScores = [];
        if (analysisScores.loudness === null || analysisScores.loudness === undefined) nullScores.push('loudness');
        if (analysisScores.dinamica === null || analysisScores.dinamica === undefined) nullScores.push('dinamica');
        if (analysisScores.estereo === null || analysisScores.estereo === undefined) nullScores.push('estereo');
        if (analysisScores.frequencia === null || analysisScores.frequencia === undefined) nullScores.push('frequencia');
        if (analysisScores.tecnico === null || analysisScores.tecnico === undefined) nullScores.push('tecnico');
        
        if (nullScores.length > 0) {
            console.error('‚ùå [AUDIT-SCORES] SUBSCORES NULL DETECTADOS:', nullScores);
            console.error('‚ö†Ô∏è [AUDIT-SCORES] Causa prov√°vel: m√©tricas ausentes em analysis.metrics ou analysis.technicalData');
        } else {
            console.log('‚úÖ [AUDIT-SCORES] TODOS OS SUBSCORES S√ÉO V√ÅLIDOS');
        }
        console.groupEnd();
        
        // Adicionar scores √† an√°lise
        analysis.scores = analysisScores;
        console.log('‚úÖ Scores calculados e adicionados √† an√°lise');
        
        // Tamb√©m armazenar globalmente
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_SCORES__ = analysisScores;
        }
    } else {
        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel calcular scores (dados insuficientes)');
    }

    /* =========[ /BLOCO: SCORES A/B ]========= */
    
    // üî• REMOVIDO: Modal j√° foi aberto no in√≠cio da fun√ß√£o (linha 8350)
    // Remover duplica√ß√£o de abertura do modal que estava causando problemas no modo g√™nero
    
    // üéØ NOVO: Verificar se √© modo refer√™ncia e adicionar se√ß√£o de compara√ß√£o
    if (analysis.analysisMode === 'reference' && analysis.comparison) {
        addReferenceComparisonSection(analysis);
    }
    
    // Marcar se pacote avan√ßado chegou (LUFS integrado + Pico Real + LRA)
    // üîç AUDITORIA: Verificar m√∫ltiplos caminhos para lufsIntegrated e truePeakDbtp
    const lufsValue = analysis?.technicalData?.lufs_integrated ?? 
                     analysis?.technicalData?.lufsIntegrated ??
                     analysis?.metrics?.loudness?.integrated ??
                     analysis?.loudness?.integrated;
    
    const truePeakValue = analysis?.technicalData?.truePeakDbtp ??
                         analysis?.truePeak?.maxDbtp;
    
    const advancedReady = (
        Number.isFinite(lufsValue) && Number.isFinite(truePeakValue)
    );
    
    // üéØ LOGS DE DIAGN√ìSTICO - M√âTRICAS PRINCIPAIS
    console.log('[METRICS-FIX] advancedReady:', advancedReady);
    console.log('[METRICS-FIX] LUFS=', lufsValue, {
        'technicalData.lufs_integrated': analysis?.technicalData?.lufs_integrated,
        'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
        'metrics.loudness.integrated': analysis?.metrics?.loudness?.integrated,
        'loudness.integrated': analysis?.loudness?.integrated
    });
    console.log('[METRICS-FIX] TRUEPEAK=', truePeakValue, {
        'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
        'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
    });
    
    if (typeof window !== 'undefined') window.__AUDIO_ADVANCED_READY__ = advancedReady;

    // Helpers seguros com bloqueio de fallback se advanced n√£o pronto
    const safeFixed = (v, d=1) => (Number.isFinite(v) ? v.toFixed(d) : '‚Äî');
    const safeHz = (v) => (Number.isFinite(v) ? `${Math.round(v)} Hz` : '‚Äî');
    const pct = (v, d=0) => (Number.isFinite(v) ? `${(v*100).toFixed(d)}%` : '‚Äî');
    const tonalSummary = (tb) => {
        if (!tb || typeof tb !== 'object') return '‚Äî';
        const parts = [];
        if (tb.sub && Number.isFinite(tb.sub.rms_db)) parts.push(`Sub ${tb.sub.rms_db.toFixed(1)}dB`);
        if (tb.low && Number.isFinite(tb.low.rms_db)) parts.push(`Low ${tb.low.rms_db.toFixed(1)}dB`);
        if (tb.mid && Number.isFinite(tb.mid.rms_db)) parts.push(`Mid ${tb.mid.rms_db.toFixed(1)}dB`);
        if (tb.high && Number.isFinite(tb.high.rms_db)) parts.push(`High ${tb.high.rms_db.toFixed(1)}dB`);
        return parts.length ? parts.join(' ‚Ä¢ ') : '‚Äî';
    };

        // Layout com cards e KPIs, mantendo o container #modalTechnicalData
        const kpi = (value, label, cls='') => `
            <div class="kpi ${cls}">
                <div class="kpi-value">${value}</div>
                <div class="kpi-label">${label}</div>
            </div>`;

        const scoreKpi = Number.isFinite(analysis.qualityOverall) ? kpi(Number(analysis.qualityOverall.toFixed(1)), 'SCORE GERAL', 'kpi-score') : '';
        const timeKpi = Number.isFinite(analysis.processingMs) ? kpi(analysis.processingMs, 'TEMPO (MS)', 'kpi-time') : '';

        const src = (k) => (analysis.technicalData?._sources && analysis.technicalData._sources[k]) ? ` data-src="${analysis.technicalData._sources[k]}" title="origem: ${analysis.technicalData._sources[k]}"` : '';
        
        // üéØ MAPEAMENTO DE M√âTRICAS COM TOOLTIPS
        const metricsTooltips = {
            // M√©tricas Principais
            'Volume m√©dio (rms)': 'Mostra o volume real percebido ao longo da faixa. Ajuda a saber se a m√∫sica est√° "forte" sem clipar.',
            'Loudness (lufs)': 'M√©dia geral de volume no padr√£o das plataformas de streaming. Ideal: ‚Äì14 LUFS.',
            'Pico m√°ximo (dbfs)': 'O ponto mais alto da onda sonora, √∫til pra evitar distor√ß√£o.',
            'Pico real (dbtp)': 'Pico real detectado ap√≥s convers√£o digital. Deve ficar abaixo de ‚Äì1 dBTP pra evitar clipagem.',
            'Din√¢mica (dr)': 'Diferen√ßa entre os sons mais baixos e mais altos. Mais DR = mais respiro e punch.',
            'Consist√™ncia de volume (lu)': 'Mede o quanto o volume se mant√©m constante. 0 LU √© estabilidade perfeita.',
            'Imagem est√©reo': 'Representa a largura e equil√≠brio do est√©reo. 1 = mono, 0.9 = est√©reo amplo.',
            'Abertura est√©reo (%)': 'O quanto a faixa "abre" nos lados. Sons amplos soam mais envolventes.',
            
            // An√°lise de Frequ√™ncias
            'Subgrave (20‚Äì60 hz)': 'Regi√£o das batidas mais profundas, sentida mais do que ouvida.',
            'Graves (60‚Äì150 hz)': 'Corpo do kick e do baixo. Cuidado pra n√£o embolar.',
            'M√©dios-graves (150‚Äì500 hz)': 'Base harm√¥nica. Excesso aqui soa abafado.',
            'M√©dios (500 hz‚Äì2 khz)': 'Clareza e presen√ßa de vocais e instrumentos.',
            'M√©dios-agudos (2‚Äì5 khz)': 'Ataque e defini√ß√£o. Muito = som agressivo.',
            'Presen√ßa (5‚Äì10 khz)': 'Brilho, clareza e detalhe.',
            'Ar (10‚Äì20 khz)': 'Sensa√ß√£o de espa√ßo e abertura.',
            'Frequ√™ncia central (hz)': 'Mostra onde est√° o "centro tonal" da faixa.',
            
            // M√©tricas Avan√ßadas
            'Fator de crista (crest factor)': 'Diferen√ßa entre pico e volume m√©dio. Mostra o punch e headroom.',
            'Centro espectral (hz)': 'Frequ√™ncia onde est√° concentrada a energia da m√∫sica.',
            'Extens√£o de agudos (hz)': 'Indica at√© onde chegam as altas frequ√™ncias.',
            'Uniformidade espectral (%)': 'Mede se o som est√° equilibrado entre graves, m√©dios e agudos.',
            'Bandas espectrais (n)': 'Quantidade de faixas de frequ√™ncia analisadas.',
            'Kurtosis espectral': 'Mede picos anormais no espectro (distor√ß√£o, harshness).',
            'Assimetria espectral': 'Mostra se o espectro est√° mais "pendendo" pros graves ou pros agudos.'
        };
        
        const row = (label, valHtml, keyForSource=null) => {
            // Usar sistema de enhancement se dispon√≠vel
            const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
                ? window.enhanceRowLabel(label, keyForSource) 
                : label;
            
            // Limpar label (trim) e capitalizar primeira letra
            const cleanLabel = enhancedLabel.trim();
            const capitalizedLabel = cleanLabel.charAt(0).toUpperCase() + cleanLabel.slice(1);
            
            // Verificar se existe tooltip para essa m√©trica (case-insensitive)
            const labelLowerCase = capitalizedLabel.toLowerCase();
            let tooltip = null;
            
            // Buscar tooltip comparando case-insensitive
            for (const [key, value] of Object.entries(metricsTooltips)) {
                if (key.toLowerCase() === labelLowerCase) {
                    tooltip = value;
                    break;
                }
            }
            
            // Gerar HTML do label com √≠cone de info e tooltip
            const labelHtml = tooltip 
                ? `<div class="metric-label-container">
                     <span style="flex: 1;">${capitalizedLabel}</span>
                     <span class="metric-info-icon" 
                           data-tooltip="${tooltip.replace(/"/g, '&quot;')}"
                           onmouseenter="showMetricTooltip(this, event)"
                           onmouseleave="hideMetricTooltip()">‚ÑπÔ∏è</span>
                   </div>`
                : capitalizedLabel;
            
            return `
                <div class="data-row"${keyForSource?src(keyForSource):''}>
                    <span class="label">${labelHtml}</span>
                    <span class="value">${valHtml}</span>
                </div>`;
        };

        // üéØ CENTRALIZA√á√ÉO DAS M√âTRICAS - Fun√ß√µes de acesso unificado com fallbacks robustos
        const getNestedValue = (obj, path) => {
            if (!obj || !path) return null;
            return path.split('.').reduce((current, key) => current?.[key], obj);
        };

        // üîß getMetricWithFallback: Suporta m√∫ltiplos caminhos de fallback em ordem de prioridade
        const getMetricWithFallback = (paths, defaultValue = null) => {
            if (!Array.isArray(paths)) paths = [paths];
            
            for (const pathConfig of paths) {
                let value = null;
                
                if (typeof pathConfig === 'string') {
                    // Caminho simples: tenta metrics > technicalData
                    value = getNestedValue(analysis.metrics, pathConfig) ?? 
                           getNestedValue(analysis.technicalData, pathConfig);
                } else if (Array.isArray(pathConfig)) {
                    // Array de caminhos aninhados: ['loudness', 'integrated']
                    value = getNestedValue(analysis, pathConfig.join('.'));
                }
                
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            
            return defaultValue;
        };

        const getMetric = (metricPath, fallbackPath = null) => {
            // Prioridade: metrics centralizadas > technicalData legado > fallback
            const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
            if (Number.isFinite(centralizedValue)) {
                // Log tempor√°rio para valida√ß√£o
                if (typeof window !== 'undefined' && window.METRICS_UI_VALIDATION !== false) {
                    const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
                    if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                        console.warn(`üéØ METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                    }
                }
                return centralizedValue;
            }
            
            // Fallback para technicalData legado
            const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
            return Number.isFinite(legacyValue) ? legacyValue : null;
        };

        const safePct = (v) => (Number.isFinite(v) ? `${(v*100).toFixed(0)}%` : '‚Äî');
        const monoCompat = (s) => s ? s : '‚Äî';

        // Fun√ß√£o para obter o valor LUFS integrado usando m√©tricas centralizadas
        const getLufsIntegratedValue = () => {
            return getMetric('lufs_integrated', 'lufsIntegrated');
        };

        // üéØ FUN√á√ÉO DE STATUS DO TRUE PEAK (CORRE√á√ÉO CR√çTICA)
        const getTruePeakStatus = (value) => {
            if (!Number.isFinite(value)) return { status: '‚Äî', class: '' };
            
            if (value <= -1.5) return { status: 'EXCELENTE', class: 'status-excellent' };
            if (value <= -1.0) return { status: 'IDEAL', class: 'status-ideal' };
            if (value <= -0.5) return { status: 'BOM', class: 'status-good' };
            if (value <= 0.0) return { status: 'ACEIT√ÅVEL', class: 'status-warning' };
            return { status: 'ESTOURADO', class: 'status-critical' };
        };

        const col1 = [
            // üü£ CARD 1: M√âTRICAS PRINCIPAIS - Reorganizado com fallbacks robustos
            // CONDITIONAL: Pico M√°ximo - s√≥ exibir se n√£o for placeholder 0.000
            (Number.isFinite(getMetric('peak_db', 'peak')) && getMetric('peak_db', 'peak') !== 0 ? row('Pico M√°ximo (dBFS)', `${safeFixed(getMetric('peak_db', 'peak'))} dB`, 'peak') : ''),
            
            // üéØ Pico Real (dBTP) - com fallbacks robustos ['truePeak','maxDbtp'] > technicalData.truePeakDbtp
            (() => {
                const tpValue = getMetricWithFallback([
                    ['truePeak', 'maxDbtp'],
                    'truePeakDbtp',
                    'technicalData.truePeakDbtp'
                ]);
                console.log('[METRICS-FIX] col1 > Pico Real - advancedReady:', advancedReady, 'tpValue:', tpValue);
                if (!advancedReady) {
                    console.warn('[METRICS-FIX] col1 > Pico Real BLOQUEADO por advancedReady=false');
                    return '';
                }
                if (tpValue === null || tpValue === undefined) {
                    console.warn('[METRICS-FIX] col1 > Pico Real N√ÉO ENCONTRADO em nenhum caminho');
                    return '';
                }
                if (!Number.isFinite(tpValue)) {
                    console.warn('[METRICS-FIX] col1 > Pico Real valor inv√°lido:', tpValue);
                    return '';
                }
                const tpStatus = getTruePeakStatus(tpValue);
                console.log('[METRICS-FIX] col1 > Pico Real RENDERIZADO:', tpValue, 'dBTP status:', tpStatus.status);
                return row('Pico Real (dBTP)', `${safeFixed(tpValue, 2)} dBTP <span class="${tpStatus.class}">${tpStatus.status}</span>`, 'truePeakDbtp');
            })(),
            
            // üéØ Volume M√©dio (RMS) - energia real em dBFS
            (() => {
                const rmsValue = getMetricWithFallback([
                    ['energy', 'rms'],
                    'avgLoudness',
                    'rms',
                    'technicalData.avgLoudness',
                    'technicalData.rms'
                ]);
                console.log('[AUDITORIA-RMS-LUFS] col1 > Volume M√©dio (RMS) - advancedReady:', advancedReady, 'rmsValue:', rmsValue);
                
                // üéØ Exibir sempre, mesmo se 0 (valor t√©cnico v√°lido)
                if (rmsValue === null || rmsValue === undefined) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > Volume M√©dio (RMS) N√ÉO ENCONTRADO - exibindo 0');
                    return row('Volume M√©dio (RMS)', `0.0 dBFS`, 'avgLoudness');
                }
                if (!Number.isFinite(rmsValue)) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > Volume M√©dio (RMS) valor inv√°lido:', rmsValue);
                    return row('Volume M√©dio (RMS)', `0.0 dBFS`, 'avgLoudness');
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > Volume M√©dio (RMS) RENDERIZADO:', rmsValue, 'dBFS');
                return row('Volume M√©dio (RMS)', `${safeFixed(rmsValue, 1)} dBFS`, 'avgLoudness');
            })(),
            
            // üéØ Loudness (LUFS) - loudness perceptiva em LUFS
            (() => {
                const lufsValue = getMetricWithFallback([
                    ['loudness', 'integrated'],
                    'lufs_integrated',
                    'lufsIntegrated',
                    'technicalData.lufsIntegrated'
                ]);
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) - advancedReady:', advancedReady, 'lufsValue:', lufsValue);
                
                if (!advancedReady) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS BLOQUEADO por advancedReady=false');
                    return '';
                }
                // üéØ Exibir sempre, mesmo se 0
                if (lufsValue === null || lufsValue === undefined) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS N√ÉO ENCONTRADO - exibindo 0');
                    return row('Loudness (LUFS)', `0.0 LUFS`, 'lufsIntegrated');
                }
                if (!Number.isFinite(lufsValue)) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS valor inv√°lido:', lufsValue);
                    return row('Loudness (LUFS)', `0.0 LUFS`, 'lufsIntegrated');
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) RENDERIZADO:', lufsValue, 'LUFS');
                return row('Loudness (LUFS)', `${safeFixed(lufsValue, 1)} LUFS`, 'lufsIntegrated');
            })(),
            
            row('Din√¢mica (DR)', `${safeFixed(getMetric('dynamic_range', 'dynamicRange'))} dB`, 'dynamicRange'),
            row('Consist√™ncia de Volume (LU)', `${safeFixed(getMetric('lra', 'lra'))} LU`, 'lra'),
            // Imagem Est√©reo (movido de col2)
            row('Imagem Est√©reo', Number.isFinite(getMetric('stereo_correlation', 'stereoCorrelation')) ? safeFixed(getMetric('stereo_correlation', 'stereoCorrelation'), 3) : '‚Äî', 'stereoCorrelation'),
            // Abertura Est√©reo (movido de col2)
            row('Abertura Est√©reo (%)', Number.isFinite(getMetric('stereo_width', 'stereoWidth')) ? `${safeFixed(getMetric('stereo_width', 'stereoWidth') * 100, 0)}%` : '‚Äî', 'stereoWidth')
            ].join('');

        const col2 = (() => {
            // üîµ CARD 2: AN√ÅLISE DE FREQU√äNCIAS - Reorganizado com sub-bandas espectrais
            const rows = [];
            
            // Sub-bandas espectrais (movidas de advancedMetricsCard)
            const spectralBands = analysis.technicalData?.spectral_balance || 
                                analysis.technicalData?.spectralBands || 
                                analysis.metrics?.bands || {};
            
            if (Object.keys(spectralBands).length > 0) {
                const bandMap = {
                    sub: { name: 'Subgrave (20‚Äì60 Hz)', range: '20-60Hz' },
                    bass: { name: 'Graves (60‚Äì150 Hz)', range: '60-150Hz' },
                    lowMid: { name: 'M√©dios-Graves (150‚Äì500 Hz)', range: '150-500Hz' },
                    mid: { name: 'M√©dios (500 Hz‚Äì2 kHz)', range: '500-2000Hz' },
                    highMid: { name: 'M√©dios-Agudos (2‚Äì5 kHz)', range: '2000-5000Hz' },
                    presence: { name: 'Presen√ßa (5‚Äì10 kHz)', range: '5000-10000Hz' },
                    air: { name: 'Ar (10‚Äì20 kHz)', range: '10000-20000Hz' }
                };
                
                Object.keys(bandMap).forEach(bandKey => {
                    const bandData = spectralBands[bandKey];
                    if (bandData && typeof bandData === 'object') {
                        const energyDb = bandData.energy_db;
                        const percentage = bandData.percentage;
                        const status = bandData.status;
                        
                        if (status && status !== 'not_calculated') {
                            let displayValue = '';
                            if (Number.isFinite(energyDb) && Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB (${safeFixed(percentage, 1)}%)`;
                            } else if (Number.isFinite(energyDb)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB`;
                            } else if (Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(percentage, 1)}%`;
                            } else {
                                displayValue = 'n√£o calculado';
                            }
                            rows.push(row(bandMap[bandKey].name, displayValue, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`));
                        }
                    } else if (Number.isFinite(bandData)) {
                        rows.push(row(bandMap[bandKey].name, `${safeFixed(bandData, 1)} dB`, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`));
                    }
                });
            }
            
            // Frequ√™ncia Central (mant√©m aqui)
            rows.push(row('Frequ√™ncia Central (Hz)', Number.isFinite(getMetric('spectral_centroid', 'spectralCentroidHz')) ? safeHz(getMetric('spectral_centroid', 'spectralCentroidHz')) : '‚Äî', 'spectralCentroidHz'));
            
            return rows.join('');
            // REMOVED: Correla√ß√£o Est√©reo - movido para col1
            // REMOVED: Largura Est√©reo - movido para col1
        })();

            // üß© CORRE√á√ÉO #5: Exibir frequ√™ncias dominantes na UI (removido bloqueio)
            // Frequ√™ncias dominantes agora vis√≠veis
            console.log('üéõÔ∏è [DEBUG] Exibindo m√©tricas de frequ√™ncia na UI');
            
            const col3 = [
                // REMOVED: Dominant Frequencies UI (mantendo c√°lculo interno para suggestions)
                
                // REMOVED: clipping (%) - ocultado da interface conforme solicitado
                // REMOVED: dc offset - ocultado da interface conforme solicitado
                (Number.isFinite(getMetric('thd', 'thd')) ? row('thd', `${safeFixed(getMetric('thd', 'thd'), 2)}%`, 'thd') : ''),
                
                // REMOVED: Din√¢mica e Fator de Crista duplicados - j√° exibidos em col1
                // REMOVED: row('Correla√ß√£o Est√©reo (largura)') - duplicado de col2
                // REMOVED: row('fator de crista') - duplicado de col1
                // REMOVED: row('Din√¢mica (diferen√ßa entre alto/baixo)') - duplicado de col1 com DR e LRA
                
                // REMOVED: Placeholders hardcoded - substituir por valores reais quando dispon√≠veis
                // row('crest consist', 'Œî=4.43 check', 'crestConsist'),
                // row('Varia√ß√£o de Volume (consist√™ncia)', 'ok', 'volumeConsistency'),
                
                // REMOVED: Problemas - ocultado da interface conforme solicitado
                // REMOVED: Sugest√µes - movido para o final do card M√âTRICAS AVAN√áADAS
                // row('Sugest√µes', (analysis.suggestions?.length || 0) > 0 ? `<span class="tag tag-success">${analysis.suggestions.length} dispon√≠vel(s)</span>` : '‚Äî')
                // REMOVED: col3Extras (dominant frequencies UI)
            ].join('');

            // Card extra: M√©tricas Avan√ßadas (expandido para Web Audio API compatibility)
            const advancedMetricsCard = () => {
                const rows = [];
                
                // === M√âTRICAS DE PICO E CLIPPING (se√ß√£o principal) ===
                
                // REMOVED: True Peak (dBTP) - agora exclusivo do card M√âTRICAS PRINCIPAIS
                // Se truePeakDbtp estiver mapeado no card de avan√ßadas, remova de l√°. 
                // True Peak deve existir apenas em M√©tricas Principais para evitar duplica√ß√£o
                
                // Picos por canal separados
                if (Number.isFinite(analysis.technicalData?.samplePeakLeftDb)) {
                    rows.push(row('Pico L (dBFS)', `${safeFixed(analysis.technicalData.samplePeakLeftDb, 1)} dBFS`, 'samplePeakLeftDb'));
                }
                if (Number.isFinite(analysis.technicalData?.samplePeakRightDb)) {
                    rows.push(row('Pico R (dBFS)', `${safeFixed(analysis.technicalData.samplePeakRightDb, 1)} dBFS`, 'samplePeakRightDb'));
                }
                
                // REMOVED: Clipping (%) - ocultado da interface conforme solicitado
                
                // REMOVED: Clipping samples - ocultado da interface conforme solicitado
                
                // REMOVED: DC OFFSET - ocultado da interface conforme solicitado
                
                // === THD (Total Harmonic Distortion) ===
                if (Number.isFinite(analysis.technicalData?.thd)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thd, 4)}%`, 'thd'));
                } else if (Number.isFinite(analysis.technicalData?.thdPercent)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thdPercent, 4)}%`, 'thdPercent'));
                }
                
                // === HEADROOM ===
                if (Number.isFinite(analysis.technicalData?.headroomDb)) {
                    rows.push(row('headroom (dB)', `${safeFixed(analysis.technicalData.headroomDb, 1)} dB`, 'headroomDb'));
                }
                
                // === FATOR DE CRISTA (movido de M√âTRICAS PRINCIPAIS) ===
                const crestValue = getMetricWithFallback([
                    ['dynamics', 'crest'],
                    'crest_factor',
                    'crestFactor',
                    'technicalData.crestFactor'
                ]);
                if (Number.isFinite(crestValue)) {
                    console.log('[METRICS-FIX] advancedMetricsCard > Fator de Crista RENDERIZADO:', crestValue, 'dB');
                    rows.push(row('Fator de Crista (Crest Factor)', `${safeFixed(crestValue, 2)} dB`, 'crestFactor'));
                } else {
                    console.warn('[METRICS-FIX] advancedMetricsCard > Fator de Crista N√ÉO ENCONTRADO ou inv√°lido:', crestValue);
                }
                
                // üü¢ CARD 3: M√âTRICAS AVAN√áADAS - Sub-bandas espectrais REMOVIDAS (movidas para col2)
                // === M√âTRICAS ESPECTRAIS AVAN√áADAS ===
                
                // Centro Espectral
                if (Number.isFinite(analysis.technicalData?.spectralCentroid)) {
                    rows.push(row('Centro Espectral (Hz)', `${Math.round(analysis.technicalData.spectralCentroid)} Hz`, 'spectralCentroid'));
                }
                
                // Spectral Rolloff (Extens√£o de agudos)
                if (Number.isFinite(analysis.technicalData?.spectralRolloff)) {
                    rows.push(row('Extens√£o de Agudos (Hz)', `${Math.round(analysis.technicalData.spectralRolloff)} Hz`, 'spectralRolloff'));
                }
                
                // Spectral Flatness (Uniformidade espectral)
                if (Number.isFinite(analysis.technicalData?.spectralFlatness)) {
                    rows.push(row('Uniformidade Espectral (%)', `${safeFixed(analysis.technicalData.spectralFlatness * 100, 1)}%`, 'spectralFlatness'));
                }
                
                // Spectral Bandwidth (Bandas espectrais)
                if (Number.isFinite(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))) {
                    rows.push(row('Bandas Espectrais (n)', `${safeHz(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))}`, 'spectralBandwidthHz'));
                }
                
                // Spectral Kurtosis
                if (Number.isFinite(analysis.technicalData?.spectralKurtosis)) {
                    rows.push(row('Kurtosis Espectral', `${safeFixed(analysis.technicalData.spectralKurtosis, 3)}`, 'spectralKurtosis'));
                }
                
                // Spectral Skewness
                if (Number.isFinite(analysis.technicalData?.spectralSkewness)) {
                    rows.push(row('Assimetria Espectral', `${safeFixed(analysis.technicalData.spectralSkewness, 3)}`, 'spectralSkewness'));
                }
                
                // === REMOVIDO: BANDAS ESPECTRAIS DETALHADAS (Sub, Bass, Low-Mid, etc.) ===
                // As sub-bandas espectrais foram movidas para o card "AN√ÅLISE DE FREQU√äNCIAS" (col2)
                // Comentado para evitar duplica√ß√£o
                
                if (false && Object.keys({}).length > 0) {
                    // REMOVIDO: C√≥digo de bandas espectrais (sub, bass, lowMid, etc.)
                    // As sub-bandas espectrais foram movidas para col2 (AN√ÅLISE DE FREQU√äNCIAS)
                    // Este bloco foi comentado para evitar duplica√ß√£o
                }
                
                // üß© CORRE√á√ÉO #5: Exibir frequ√™ncias dominantes e uniformidade espectral
                // === FREQU√äNCIAS DOMINANTES ===
                if (Array.isArray(analysis.technicalData?.dominantFrequencies) && analysis.technicalData.dominantFrequencies.length > 0) {
                    const freqList = analysis.technicalData.dominantFrequencies
                        .slice(0, 5)
                        .map(f => `${Math.round(f)}Hz`)
                        .join(', ');
                    rows.push(row('frequ√™ncias dominantes', freqList, 'dominantFrequencies'));
                    console.log('üéõÔ∏è [DEBUG] Frequ√™ncias dominantes exibidas:', freqList);
                }
                
                // === UNIFORMIDADE ESPECTRAL ===
                if (Number.isFinite(analysis.technicalData?.spectralUniformity)) {
                    rows.push(row('uniformidade espectral', `${safeFixed(analysis.technicalData.spectralUniformity, 3)}`, 'spectralUniformity'));
                    console.log('üéõÔ∏è [DEBUG] Uniformidade espectral exibida:', analysis.technicalData.spectralUniformity);
                }
                
                // === ZEROS CROSSING RATE ===
                if (Number.isFinite(analysis.technicalData?.zcr)) {
                    rows.push(row('zero crossings', `${Math.round(analysis.technicalData.zcr)}`, 'zeroCrossings'));
                }
                
                // === MFCC (primeiros coeficientes) ===
                if (Array.isArray(analysis.technicalData?.mfcc) && analysis.technicalData.mfcc.length > 0) {
                    analysis.technicalData.mfcc.slice(0, 3).forEach((coeff, idx) => {
                        if (Number.isFinite(coeff)) {
                            rows.push(row(`mfcc ${idx + 1}`, `${safeFixed(coeff, 3)}`, `mfcc${idx + 1}`));
                        }
                    });
                }
                
                // === SUGEST√ïES DISPON√çVEIS (movido de SCORES & DIAGN√ìSTICO) ===
                const suggestionsCount = analysis.suggestions?.length || 0;
                console.log('[AUDITORIA-SUGESTOES] Sugest√µes detectadas:', suggestionsCount);
                
                if (suggestionsCount > 0) {
                    rows.push(row('Sugest√µes', `<span class="tag tag-success">${suggestionsCount} DISPON√çVEL${suggestionsCount > 1 ? 'S' : ''}</span>`, 'suggestions'));
                }
                
                return rows.join('') || row('Status', 'Sem m√©tricas avan√ßadas dispon√≠veis');
            };

            // Card extra: Problemas T√©cnicos detalhados
            const techProblems = () => {
                const rows = [];
                let hasActualProblems = false;
                
                // ===== SEMPRE MOSTRAR TODAS AS M√âTRICAS T√âCNICAS =====
                
                // 1. Clipping - SEMPRE mostrar com valores reais
                const clipVal = Number.isFinite(analysis.technicalData?.clippingSamples) ? analysis.technicalData.clippingSamples : 0;
                const clipPct = Number.isFinite(analysis.technicalData?.clippingPct) ? analysis.technicalData.clippingPct : 0;
                // üéØ CLIPPING PRECEDENCE V2: Usar nova l√≥gica de preced√™ncia
                const peak = Number.isFinite(analysis.technicalData?.peak) ? analysis.technicalData.peak : -Infinity;
                const truePeak = Number.isFinite(analysis.technicalData?.truePeakDbtp) ? analysis.technicalData.truePeakDbtp : null;
                
                // Verificar se temos dados do novo sistema de preced√™ncia
                const precedenceData = analysis.technicalData?._singleStage;
                let hasClippingProblem, clipText, clipClass;
                
                if (precedenceData && precedenceData.source === 'enhanced-clipping-v2') {
                    // üöÄ Usar novo sistema de preced√™ncia
                    const isClipped = precedenceData.finalState === 'CLIPPED';
                    const isTruePeakOnly = precedenceData.finalState === 'TRUE_PEAK_ONLY';
                    hasClippingProblem = isClipped || isTruePeakOnly;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = isClipped ? 'error' : 'warn'; // CLIPPED √© mais severo que TRUE_PEAK_ONLY
                        
                        const details = [];
                        if (isClipped) {
                            details.push(`üî¥ CLIPPED: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                            if (precedenceData.precedenceApplied) {
                                details.push(`TP override: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                            }
                        } else if (isTruePeakOnly) {
                            details.push(`üü° TruePeak: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        }
                        
                        if (precedenceData.clippingSamples > 0) {
                            details.push(`${precedenceData.clippingSamples} samples (${precedenceData.clippingPct.toFixed(3)}%)`);
                        }
                        
                        clipText = details.join(' | ');
                    } else {
                        // Estado limpo com novo sistema
                        const safeDetails = [];
                        safeDetails.push(`‚úÖ Sample: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                        safeDetails.push(`TP: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        safeDetails.push(`${precedenceData.clippingSamples} samples`);
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                } else {
                    // üîÑ Fallback para sistema legado
                    const hasPeakClipping = peak > -0.1;
                    const hasTruePeakClipping = truePeak !== null && truePeak > -0.1;
                    const hasSampleClipping = clipVal > 0;
                    const hasPercentageClipping = clipPct > 0;
                    
                    hasClippingProblem = hasPeakClipping || hasTruePeakClipping || hasSampleClipping || hasPercentageClipping;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = 'warn';
                        
                        const details = [];
                        if (hasPeakClipping) details.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (hasTruePeakClipping) details.push(`TruePeak: ${truePeak.toFixed(2)}dBTP`);
                        if (hasSampleClipping) details.push(`${clipVal} samples (${clipPct.toFixed(3)}%)`);
                        
                        clipText = details.join(' | ');
                    } else {
                        const safeDetails = [];
                        safeDetails.push(`${clipVal} samples`);
                        if (peak > -Infinity) safeDetails.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (truePeak !== null) safeDetails.push(`TP: ${truePeak.toFixed(2)}dBTP`);
                        
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                }
                rows.push(row('Clipping', `<span class="${clipClass}">${clipText}</span>`, 'clippingSamples'));
                
                // 2. DC Offset - SEMPRE mostrar (usando nova estrutura)
                let dcVal, hasDcProblem, dcClass;
                if (analysis.dcOffset && Number.isFinite(analysis.dcOffset.maxAbsDC)) {
                    // Usar nova estrutura detalhada
                    dcVal = analysis.dcOffset.maxAbsDC;
                    hasDcProblem = analysis.dcOffset.needsCorrection || analysis.dcOffset.severity !== 'none';
                    dcClass = hasDcProblem ? (analysis.dcOffset.isCritical ? 'error' : 'warn') : '';
                    if (hasDcProblem) hasActualProblems = true;
                    const dcDetails = `Max: ${safeFixed(dcVal, 4)} | L: ${safeFixed(analysis.dcOffset.leftDC, 4)} | R: ${safeFixed(analysis.dcOffset.rightDC, 4)} | ${analysis.dcOffset.severity}`;
                    rows.push(row('DC Offset (Detalhado)', `<span class="${dcClass}">${dcDetails}</span>`, 'dcOffset'));
                } else {
                    // Fallback para estrutura legada
                    dcVal = Number.isFinite(analysis.technicalData?.dcOffset) ? analysis.technicalData.dcOffset : 0;
                    hasDcProblem = Math.abs(dcVal) > 0.01;
                    if (hasDcProblem) hasActualProblems = true;
                    dcClass = hasDcProblem ? 'warn' : '';
                    rows.push(row('DC Offset', `<span class="${dcClass}">${safeFixed(dcVal, 4)}</span>`, 'dcOffset'));
                }
                
                // 3. THD - SEMPRE mostrar
                const thdVal = Number.isFinite(analysis.technicalData?.thdPercent) ? analysis.technicalData.thdPercent : 0;
                const hasThdProblem = thdVal > 1.0;
                if (hasThdProblem) hasActualProblems = true;
                const thdClass = hasThdProblem ? 'warn' : '';
                rows.push(row('THD', `<span class="${thdClass}">${safeFixed(thdVal, 2)}%</span>`, 'thdPercent'));
                
                // 4. Stereo Correlation - SEMPRE mostrar
                const stereoCorr = Number.isFinite(analysis.technicalData?.stereoCorrelation) ? analysis.technicalData.stereoCorrelation : 0;
                const hasStereoProb = stereoCorr !== null && (stereoCorr < -0.3 || stereoCorr > 0.95);
                if (hasStereoProb) hasActualProblems = true;
                const stereoClass = hasStereoProb ? 'warn' : '';
                let stereoText = safeFixed(stereoCorr, 3);
                if (hasStereoProb) {
                    const status = stereoCorr < -0.3 ? 'Fora de fase' : 'Mono demais';
                    stereoText += ` (${status})`;
                }
                rows.push(row('Stereo Corr.', `<span class="${stereoClass}">${stereoText}</span>`, 'stereoCorrelation'));
                
                // 5. Fator de Crista - SEMPRE mostrar  
                const crestVal = Number.isFinite(analysis.technicalData?.crestFactor) ? analysis.technicalData.crestFactor : 0;
                const hasCrestProblem = crestVal < 6 || crestVal > 20; // Valores normais: 6-20dB
                if (hasCrestProblem) hasActualProblems = true;
                const crestClass = hasCrestProblem ? 'warn' : '';
                rows.push(row('Fator de Crista', `<span class="${crestClass}">${safeFixed(crestVal, 1)} dB</span>`, 'crestFactor'));
                
                // Consist√™ncia (se dispon√≠vel) - mas sempre tentar mostrar
                if (analysis.metricsValidation && Object.keys(analysis.metricsValidation).length) {
                    const mv = analysis.metricsValidation;
                    const badge = (k,v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:${v==='ok'?'#143f2b':(v==='warn'?'#4d3808':'#4a1d1d')};color:${v==='ok'?'#29c182':(v==='warn'?'#ffce4d':'#ff7d7d')};margin-left:6px;">${v}</span>`;
                    
                    if (mv.dynamicRangeConsistency) {
                        rows.push(row('DR Consist√™ncia', `Œî=${mv.dynamicRangeDelta || '0'} ${badge('dr', mv.dynamicRangeConsistency)}`));
                        if (mv.dynamicRangeConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('DR Consist√™ncia', `<span style="opacity:0.6;">Œî=0 ${badge('dr', 'ok')}</span>`));
                    }
                    
                    if (mv.crestFactorConsistency) {
                        rows.push(row('Crest Consist.', `Œî=${mv.crestVsExpectedDelta || '0'} ${badge('cf', mv.crestFactorConsistency)}`));
                        if (mv.crestFactorConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Œî=0 ${badge('cf', 'ok')}</span>`));
                    }
                    
                    if (mv.lraPlausibility) {
                        rows.push(row('LRA Plaus√≠vel', badge('lra', mv.lraPlausibility)));
                        if (mv.lraPlausibility !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('LRA Plaus√≠vel', `<span style="opacity:0.6;">${badge('lra', 'ok')}</span>`));
                    }
                } else {
                    // Mostrar como n√£o dispon√≠vel/OK
                    const badge = (v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:#143f2b;color:#29c182;margin-left:6px;">${v}</span>`;
                    rows.push(row('DR Consist√™ncia', `<span style="opacity:0.6;">Œî=0 ${badge('ok')}</span>`));
                    rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Œî=0 ${badge('ok')}</span>`));
                    rows.push(row('LRA Plaus√≠vel', `<span style="opacity:0.6;">${badge('ok')}</span>`));
                }
                
                return rows.join('');
            };

            // Card extra: Diagn√≥stico & Sugest√µes listados
            const diagCard = () => {
                // =========================================================================
                // üö® AUDITORIA: RENDERIZA√á√ÉO DE SUGEST√ïES
                // =========================================================================
                console.log('[RENDER_SUGGESTIONS] ‚úÖ Iniciada');
                
                const blocks = [];
                
                // üîç DEBUG: Verificar estado das sugest√µes
                console.log('üîç [DEBUG_SUGGESTIONS] analysis.suggestions:', analysis.suggestions);
                console.log('üîç [DEBUG_SUGGESTIONS] an√°lise completa de sugest√µes:', {
                    hasAnalysis: !!analysis,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsType: typeof analysis.suggestions,
                    suggestionsLength: analysis.suggestions?.length || 0,
                    suggestionsArray: analysis.suggestions
                });

                // üöÄ INTEGRA√á√ÉO SISTEMA ULTRA-AVAN√áADO V2: Enriquecimento direto das sugest√µes existentes
                let enrichedSuggestions = analysis.suggestions || [];
                
                if (typeof window.UltraAdvancedSuggestionEnhancer !== 'undefined' && enrichedSuggestions.length > 0) {
                    try {
                        console.log('üöÄ [ULTRA_V2] Iniciando sistema ultra-avan√ßado V2...');
                        console.log('üìä [ULTRA_V2] Sugest√µes para enriquecer:', enrichedSuggestions.length);
                        
                        const ultraEnhancer = new window.UltraAdvancedSuggestionEnhancer();
                        
                        // Preparar contexto de an√°lise
                        const analysisContext = {
                            detectedGenre: analysis.detectedGenre || 'general',
                            fileName: analysis.fileName,
                            duration: analysis.duration,
                            sampleRate: analysis.sampleRate,
                            mode: analysis.mode || 'genre',
                            // ‚úÖ MODO REFERENCE: Adicionar dados de compara√ß√£o A/B
                            referenceComparison: analysis.referenceComparison || null,
                            referenceJobId: analysis.referenceJobId || null,
                            referenceFileName: analysis.referenceFileName || null
                        };
                        
                        // üéØ MODO GENRE: Usar EXCLUSIVAMENTE analysis.data (metrics + genreTargets)
                        // ‚ùå SEM FALLBACKS - se n√£o existir, lista vazia
                        if (analysis.mode === "genre") {
                            // ‚úÖ EXTRAIR METRICS de analysis.data.metrics
                            const metrics = analysis?.data?.metrics;
                            const correctTargets = getCorrectTargets(analysis);
                            
                            if (!metrics) {
                                console.error('[ULTRA_V2] ‚ùå CR√çTICO: analysis.data.metrics n√£o encontrado');
                                throw new Error('NO_METRICS_FROM_BACKEND');
                            }
                            
                            if (!correctTargets) {
                                console.error('[ULTRA_V2] ‚ùå CR√çTICO: analysis.data.genreTargets n√£o encontrado (Postgres)');
                                throw new Error('NO_TARGETS_FROM_POSTGRES');
                            }
                            
                            console.log('[ULTRA_V2] ‚úÖ Injetando metrics e correctTargets em analysisContext');
                            console.log('[ULTRA_V2] Metrics:', {
                                loudness: metrics.loudness,
                                truePeak: metrics.truePeak,
                                dr: metrics.dr,
                                stereo: metrics.stereo,
                                hasBands: !!metrics.bands
                            });
                            console.log('[ULTRA_V2] Targets:', {
                                lufs: correctTargets.lufs,
                                truePeak: correctTargets.truePeak,
                                dr: correctTargets.dr,
                                stereo: correctTargets.stereo,
                                hasBands: !!correctTargets.bands
                            });
                            
                            // ‚úÖ INJETAR NO CONTEXT
                            analysisContext.metrics = metrics;
                            analysisContext.correctTargets = correctTargets;
                        }
                        // üõ°Ô∏è MODO REFERENCE: N√£o injetar nada - usa dados de compara√ß√£o A/B
                        
                        // ‚úÖ Log para modo reference
                        if (analysisContext.mode === 'reference' && analysisContext.referenceComparison) {
                            console.log('[ULTRA_V2] üéØ Modo reference detectado - enriquecendo com dados de compara√ß√£o A/B');
                            console.log('[ULTRA_V2] Refer√™ncia:', analysisContext.referenceFileName);
                            console.log('[ULTRA_V2] Deltas dispon√≠veis:', Object.keys(analysisContext.referenceComparison));
                        }
                        
                        // üöÄ Enriquecer sugest√µes existentes
                        const ultraResults = ultraEnhancer.enhanceExistingSuggestions(enrichedSuggestions, analysisContext);
                        
                        if (ultraResults && ultraResults.enhancedSuggestions && ultraResults.enhancedSuggestions.length > 0) {
                            enrichedSuggestions = ultraResults.enhancedSuggestions;
                            
                            console.log('‚ú® [ULTRA_V2] Sistema ultra-avan√ßado V2 aplicado com sucesso!', {
                                originalCount: analysis.suggestions?.length || 0,
                                enhancedCount: enrichedSuggestions.length,
                                processingTime: ultraResults.metadata?.processingTimeMs,
                                educationalLevel: ultraResults.metadata?.educationalLevel
                            });
                            
                            // Adicionar m√©tricas do sistema ultra-avan√ßado √† an√°lise
                            if (!analysis.enhancedMetrics) analysis.enhancedMetrics = {};
                            analysis.enhancedMetrics.ultraAdvancedSystem = {
                                applied: true,
                                version: ultraResults.metadata?.version,
                                processingTimeMs: ultraResults.metadata?.processingTimeMs,
                                enhancedCount: enrichedSuggestions.length,
                                educationalLevel: ultraResults.metadata?.educationalLevel,
                                originalCount: ultraResults.metadata?.originalCount
                            };
                            
                            // ‚úÖ Log da primeira sugest√£o enriquecida para debug
                            if (enrichedSuggestions.length > 0) {
                                const firstEnhanced = enrichedSuggestions[0];
                                console.log('üéì [ULTRA_V2] Exemplo de sugest√£o enriquecida:', {
                                    original: firstEnhanced.message,
                                    educationalTitle: firstEnhanced.educationalContent?.title,
                                    hasDAWExamples: !!(firstEnhanced.educationalContent?.dawExamples),
                                    severity: firstEnhanced.severity?.label,
                                    priority: firstEnhanced.priority
                                });
                            }
                            
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            // ‚úÖ VALIDA√á√ÉO FINAL: Confirmar sistema configurado corretamente
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            if (analysisContext.mode === 'genre' && analysisContext.correctTargets && analysisContext.metrics) {
                                console.log('');
                                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                                console.log('‚úÖ [VALIDA√á√ÉO FINAL] Sistema de Sugest√µes IA Configurado');
                                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                                console.log('üìä Fonte de Metrics: analysis.data.metrics');
                                console.log('üìä Fonte de Targets: analysis.data.genreTargets (Postgres)');
                                console.log('üìä Modo de An√°lise:', analysisContext.mode);
                                console.log('üìä Metrics Injetados:', {
                                    loudness: analysisContext.metrics.loudness?.value,
                                    truePeak: analysisContext.metrics.truePeak?.value,
                                    dr: analysisContext.metrics.dr?.value,
                                    stereo: analysisContext.metrics.stereo?.value
                                });
                                console.log('üìä Targets Injetados:', {
                                    lufs: analysisContext.correctTargets.lufs?.target,
                                    truePeak: analysisContext.correctTargets.truePeak?.target,
                                    dr: analysisContext.correctTargets.dr?.target,
                                    stereo: analysisContext.correctTargets.stereo?.target
                                });
                                console.log('üìä Diferen√ßas Calculadas:', {
                                    lufs: (analysisContext.metrics.loudness?.value - analysisContext.correctTargets.lufs?.target).toFixed(2),
                                    truePeak: (analysisContext.metrics.truePeak?.value - analysisContext.correctTargets.truePeak?.target).toFixed(2),
                                    dr: (analysisContext.metrics.dr?.value - analysisContext.correctTargets.dr?.target).toFixed(2),
                                    stereo: (analysisContext.metrics.stereo?.value - analysisContext.correctTargets.stereo?.target).toFixed(4)
                                });
                                console.log('üìä Total de Sugest√µes Enriquecidas:', enrichedSuggestions.length);
                                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                                console.log('');
                            }
                            
                        } else {
                            console.warn('‚ö†Ô∏è [ULTRA_V2] Sistema n√£o retornou sugest√µes v√°lidas:', ultraResults);
                        }
                        
                    } catch (error) {
                        console.error('‚ùå [ULTRA_V2] Erro no sistema ultra-avan√ßado V2:', error);
                        // Manter sugest√µes originais em caso de erro
                    }
                } else {
                    if (typeof window.UltraAdvancedSuggestionEnhancer === 'undefined') {
                        console.log('‚ö†Ô∏è [ULTRA_V2] Sistema ultra-avan√ßado V2 n√£o est√° dispon√≠vel');
                    } else {
                        console.log('‚ö†Ô∏è [ULTRA_V2] Nenhuma sugest√£o para processar');
                    }
                }
                
                // Atualizar analysis.suggestions com as sugest√µes enriched
                analysis.suggestions = enrichedSuggestions;
                
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // üî• PARTE 1: VINCULAR SUGEST√ïES ENRIQUECIDAS √Ä UI DE IA
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // Mapear sugest√µes enriquecidas para o formato esperado pela AI UI
                const finalAISuggestions = enrichedSuggestions.map(sug => {
                    // Manter campos essenciais para compatibilidade
                    return {
                        type: sug.metric || sug.type || 'general',
                        message: sug.message || '',
                        action: sug.action || sug.educationalContent?.solution || '',
                        explanation: sug.explanation || sug.educationalContent?.explanation || '',
                        categoria: sug.categoria || sug.category || 't√©cnico',
                        priority: sug.priority || sug.severity?.priority || 3,
                        delta: sug.delta || sug.deltaNum || 0,
                        currentValue: sug.currentValue || '',
                        targetValue: sug.targetValue || '',
                        severity: sug.severity || { level: 'medium', label: 'Moderada' },
                        // Preservar conte√∫do educacional completo
                        educationalContent: sug.educationalContent || {},
                        // Preservar campos originais para compatibilidade total
                        ...sug
                    };
                });
                
                // Garantir que analysis.user existe
                if (!analysis.user) {
                    analysis.user = {};
                }
                
                // Sobrescrever com sugest√µes enriquecidas (fonte oficial)
                analysis.user.aiSuggestions = finalAISuggestions;
                analysis.aiSuggestions = finalAISuggestions; // Caminho alternativo
                
                // üîç LOG DE AUDITORIA: Confirmar vincula√ß√£o
                console.log('');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üîó [AI-FRONT][ULTRA-BIND] Vinculando sugest√µes enriquecidas');
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('[AI-FRONT][ULTRA-BIND] Total de sugest√µes:', finalAISuggestions.length);
                console.log('[AI-FRONT][ULTRA-BIND] Paths atualizados:', {
                    'analysis.suggestions': enrichedSuggestions.length,
                    'analysis.aiSuggestions': finalAISuggestions.length,
                    'analysis.user.aiSuggestions': finalAISuggestions.length
                });
                
                if (finalAISuggestions.length > 0) {
                    const sample = finalAISuggestions[0];
                    console.log('[AI-FRONT][ULTRA-BIND] Sample da primeira sugest√£o:', {
                        type: sample.type,
                        message: sample.message?.substring(0, 80) + '...',
                        hasEducationalContent: !!sample.educationalContent,
                        severity: sample.severity?.label,
                        priority: sample.priority,
                        currentValue: sample.currentValue,
                        targetValue: sample.targetValue
                    });
                }
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('');

                // Helpers para embelezar as sugest√µes sem mudar layout/IDs
                const formatNumbers = (text, decimals = 2) => {
                    if (!text || typeof text !== 'string') return '';
                    return text.replace(/(-?\d+\.\d{3,})/g, (m) => {
                        const n = parseFloat(m);
                        return Number.isFinite(n) ? n.toFixed(decimals) : m;
                    });
                };
                const renderSuggestionItem = (sug) => {
                    // üöÄ PRIORIDADE: Verificar se tem conte√∫do educacional do Sistema Ultra-Avan√ßado V2
                    const hasUltraV2Content = sug.educationalContent && sug.educationalContent.title;
                    
                    if (hasUltraV2Content) {
                        // ÔøΩ SISTEMA ULTRA-AVAN√áADO V2: Renderizar com conte√∫do educacional completo
                        const edu = sug.educationalContent;
                        const severity = sug.severity || { level: 'medium', color: '#FF9800', label: 'Moderada' };
                        
                        // Extrair frequ√™ncia se dispon√≠vel
                        const freqMatch = (edu.action || sug.action || '').match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz|khz|kHz)/i);
                        const frequency = freqMatch ? freqMatch[1] : null;
                        
                        return `
                            <div class="enhanced-card ultra-advanced-v2">
                                <div class="card-header">
                                    <h4 class="card-title">${edu.title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency}${frequency > 1000 ? 'Hz' : 'kHz'}</span>` : ''}
                                        <span class="severity-badge ${severity.level}" style="background-color: ${severity.color};">${severity.label}</span>
                                        <span class="priority-badge">P${sug.priority || 5}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: ${severity.color};">
                                    <strong>üìö Explica√ß√£o:</strong> ${edu.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50;">
                                    <div class="card-action-title">üîß A√ß√£o Recomendada</div>
                                    <div class="card-action-content">${edu.action}</div>
                                </div>
                                
                                ${edu.dawExamples ? `
                                    <div class="card-daw-examples" style="background: rgba(33, 150, 243, 0.1); border-color: #2196F3; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                                        <div class="card-daw-title" style="font-weight: bold; margin-bottom: 8px; color: #2196F3;">üéõÔ∏è Exemplos por DAW</div>
                                        ${Object.entries(edu.dawExamples).map(([daw, instruction]) => 
                                            `<div style="margin-bottom: 6px;"><strong>${daw}:</strong> ${instruction}</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                                
                                ${edu.expectedResult ? `
                                    <div class="card-result" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                                        <div class="card-result-title" style="font-weight: bold; margin-bottom: 8px; color: #4CAF50;">‚ú® Resultado Esperado</div>
                                        <div class="card-result-content">${edu.expectedResult}</div>
                                    </div>
                                ` : ''}
                                
                                ${edu.technicalDetails ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa; font-weight: bold;">üìã Detalhes T√©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;">${edu.technicalDetails}</div>
                                    </details>
                                ` : ''}
                                
                                ${sug.educationalMetadata ? `
                                    <div class="educational-metadata" style="margin-top: 12px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; font-size: 11px; color: #888;">
                                        üìñ Tempo de leitura: ${sug.educationalMetadata.estimatedReadTime} | 
                                        üéØ Dificuldade: ${sug.educationalMetadata.practicalDifficulty} | 
                                        üß† Conceitos: ${sug.educationalMetadata.concepts?.join(', ') || 'N/A'}
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    // üîÑ FALLBACK: Sistema anterior se n√£o tiver conte√∫do Ultra-Avan√ßado V2
                    const hasTextGenerator = typeof window.SuggestionTextGenerator !== 'undefined';
                    let didacticText = null;
                    
                    if (hasTextGenerator) {
                        try {
                            const generator = new window.SuggestionTextGenerator();
                            didacticText = generator.generateDidacticText(sug);
                        } catch (error) {
                            console.warn('[RenderSuggestion] Erro no gerador de texto:', error);
                        }
                    }
                    
                    // Usar texto did√°tico se dispon√≠vel, sen√£o usar texto original
                    const title = didacticText?.title || sug.message || '';
                    const explanation = didacticText?.explanation || sug.explanation || '';
                    const action = didacticText?.action || sug.action || '';
                    const rationale = didacticText?.rationale || '';
                    const technical = didacticText?.technical || sug.details || '';
                    
                    // üéØ SISTEMA MELHORADO: Verificar se tem informa√ß√µes de severidade e prioridade
                    const hasEnhancedInfo = sug.severity && sug.priority;
                    const severityColor = hasEnhancedInfo ? sug.severity.color : '#9fb3d9';
                    const severityLevel = hasEnhancedInfo ? sug.severity.level : 'medium';
                    const severityLabel = hasEnhancedInfo ? sug.severity.label : '';
                    const priority = hasEnhancedInfo ? sug.priority : 0;
                    const confidence = hasEnhancedInfo ? sug.confidence : 1;
                    
                    // Detectar tipo de sugest√£o
                    const isSurgical = sug.type === 'surgical_eq' || (sug.subtype && ['sibilance', 'harshness', 'clipping'].includes(sug.subtype));
                    const isBandAdjust = sug.type === 'band_adjust';
                    const isClipping = sug.type === 'clipping' || title.toLowerCase().includes('clipping');
                    const isBalance = sug.type === 'balance' || title.toLowerCase().includes('balance');
                    
                    // Determinar classe do card
                    let cardClass = 'enhanced-card';
                    if (isSurgical) cardClass += ' surgical';
                    else if (isBandAdjust) cardClass += ' band-adjust';
                    else if (isClipping) cardClass += ' clipping';
                    else if (isBalance) cardClass += ' balance';
                    else cardClass += ' problem';
                    
                    // Extrair frequ√™ncia e valores t√©cnicos
                    const freqMatch = (title + ' ' + action).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                    const frequency = freqMatch ? freqMatch[1] : null;
                    
                    const dbMatch = action.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                    const dbValue = dbMatch ? dbMatch[1] : null;
                    
                    const qMatch = action.match(/Q\s*[=:]?\s*(\d+(?:\.\d+)?)/i);
                    const qValue = qMatch ? qMatch[1] : null;
                    
                    // Extrair faixa de frequ√™ncia se dispon√≠vel
                    const frequencyRange = sug.frequency_range || '';
                    const adjustmentDb = sug.adjustment_db;
                    
                    // üö® VERIFICAR SE √â UM AVISO CR√çTICO
                    if (didacticText?.isCritical) {
                        return `
                            <div class="${cardClass} critical-alert">
                                <div class="card-header">
                                    <h4 class="card-title">üö® Problema Cr√≠tico</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge severa">CR√çTICO</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: #f44336;">
                                    <strong>‚ö†Ô∏è Problema:</strong> ${didacticText.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                    <div class="card-action-title" style="color: #f44336;">
                                        üö® A√ß√£o Urgente
                                    </div>
                                    <div class="card-action-content">${didacticText.action}</div>
                                </div>
                                
                                <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                    <div class="card-impact-title" style="color: #f44336;">‚ö†Ô∏è Por que √© cr√≠tico</div>
                                    <div class="card-impact-content">${didacticText.rationale}</div>
                                </div>
                            </div>`;
                    }
                    
                    if (isSurgical) {
                        // Card cir√∫rgico aprimorado
                        const context = title.replace(/\[\d+Hz\]/, '').replace(/\d+Hz/, '').trim();
                        const severity = severityLevel === 'high' ? 'alta' : (severityLevel === 'medium' ? 'moderada' : 'leve');
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">üîß Corre√ß√£o Cir√∫rgica</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severity}">${severity}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>Problema detectado:</strong> ${context || explanation || 'Resson√¢ncia problem√°tica identificada'}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        üéõÔ∏è A√ß√£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequency || qValue || dbValue) ? `
                                    <div class="card-technical">
                                        ${frequency ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Frequ√™ncia</div>
                                                <div class="tech-value">${frequency} Hz</div>
                                            </div>
                                        ` : ''}
                                        ${dbValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ganho</div>
                                                <div class="tech-value">${dbValue} dB</div>
                                            </div>
                                        ` : ''}
                                        ${qValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Q Factor</div>
                                                <div class="tech-value">${qValue}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">‚ö†Ô∏è Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes T√©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    } 
                    
                    else if (isBandAdjust) {
                        // Card de ajuste de banda aprimorado
                        const shouldBoost = adjustmentDb > 0 || action.toLowerCase().includes('aumentar') || action.toLowerCase().includes('boost');
                        const actionIcon = shouldBoost ? 'üìà' : 'üìâ';
                        const actionType = shouldBoost ? 'Boost' : 'Corte';
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">${actionIcon} Ajuste de Banda</h4>
                                    <div class="card-badges">
                                        ${frequencyRange ? `<span class="frequency-badge">${frequencyRange}</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${actionType}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>An√°lise:</strong> ${explanation || title}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        üéöÔ∏è Como Ajustar
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequencyRange || adjustmentDb) ? `
                                    <div class="card-technical">
                                        ${frequencyRange ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Faixa</div>
                                                <div class="tech-value">${frequencyRange}</div>
                                            </div>
                                        ` : ''}
                                        ${adjustmentDb ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ajuste</div>
                                                <div class="tech-value">${adjustmentDb > 0 ? '+' : ''}${adjustmentDb.toFixed(1)} dB</div>
                                            </div>
                                        ` : ''}
                                        ${sug.details ? `
                                            <div class="tech-item" style="grid-column: span 2;">
                                                <div class="tech-label">Status</div>
                                                <div class="tech-value" style="font-size: 10px;">${sug.details.replace('Atual:', '').replace('Alvo:', '‚Üí')}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">üí° Resultado Esperado</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    else {
                        // üö® VERIFICAR SE √â TRUE PEAK COM MENSAGEM ESPECIAL
                        const isTruePeak = sug.type === 'reference_true_peak' || sug.metricType === 'true_peak' || 
                                         title.toLowerCase().includes('true peak') || title.toLowerCase().includes('tp');
                        const hasSpecialAlert = sug.specialAlert || sug.priorityWarning;
                        
                        if (isTruePeak && hasSpecialAlert) {
                            // Card especial para True Peak com mensagem de prioridade
                            return `
                                <div class="${cardClass} true-peak-priority">
                                    <div class="card-header">
                                        <h4 class="card-title">‚ö° ${title}</h4>
                                        <div class="card-badges">
                                            <span class="priority-badge primeiro">PRIMEIRO</span>
                                            <span class="severity-badge critica">CR√çTICO</span>
                                        </div>
                                    </div>
                                    
                                    ${sug.priorityWarning ? `
                                        <div class="priority-warning" style="background: rgba(255, 193, 7, 0.2); border: 1px solid #FFC107; border-radius: 6px; padding: 12px; margin: 12px 0; color: #856404;">
                                            ${sug.priorityWarning}
                                        </div>
                                    ` : ''}
                                    
                                    ${explanation ? `
                                        <div class="card-description" style="border-left-color: #FF5722;">
                                            <strong>‚ö†Ô∏è Por que √© priorit√°rio:</strong> ${explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(255, 87, 34, 0.1); border-color: #FF5722;">
                                        <div class="card-action-title" style="color: #FF5722;">
                                            üö® Corre√ß√£o Priorit√°ria
                                        </div>
                                        <div class="card-action-content">${action}</div>
                                    </div>
                                    
                                    ${sug.why ? `
                                        <div class="card-impact" style="background: rgba(255, 87, 34, 0.05); border-color: #FF5722;">
                                            <div class="card-impact-title" style="color: #FF5722;">üî¥ Motivo da Prioridade</div>
                                            <div class="card-impact-content">${sug.why}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${technical ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes T√©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                        </details>
                                    ` : ''}
                                </div>`;
                        }
                        
                        // Card gen√©rico melhorado
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">üéµ ${title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${severityLabel || 'info'}</span>
                                    </div>
                                </div>
                                
                                ${explanation ? `
                                    <div class="card-description">
                                        <strong>Explica√ß√£o:</strong> ${explanation}
                                    </div>
                                ` : ''}
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        üîß A√ß√£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">‚ö†Ô∏è Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes T√©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    }
                };
                if ((analysis.problems?.length || 0) > 0) {
                    // üéØ Fun√ß√£o local para deduplicar problemas por tipo
                    const deduplicateByType = (items) => {
                        const seen = new Map();
                        const deduplicated = [];
                        for (const item of items) {
                            if (!item || !item.type) continue;
                            
                            // üéØ CORRE√á√ÉO: Para band_adjust, usar type + subtype como chave √∫nica
                            let uniqueKey = item.type;
                            if (item.type === 'band_adjust' && item.subtype) {
                                uniqueKey = `${item.type}:${item.subtype}`;
                            }
                            
                            const existing = seen.get(uniqueKey);
                            if (!existing) {
                                seen.set(uniqueKey, item);
                                deduplicated.push(item);
                            } else {
                                // Manter o mais detalhado (com mais propriedades)
                                const currentScore = Object.keys(item).length + (item.explanation ? 10 : 0) + (item.impact ? 5 : 0);
                                const existingScore = Object.keys(existing).length + (existing.explanation ? 10 : 0) + (existing.impact ? 5 : 0);
                                if (currentScore > existingScore) {
                                    seen.set(uniqueKey, item);
                                    const index = deduplicated.findIndex(d => {
                                        if (d.type === 'band_adjust' && item.type === 'band_adjust') {
                                            return d.type === item.type && d.subtype === item.subtype;
                                        }
                                        return d.type === item.type;
                                    });
                                    if (index >= 0) deduplicated[index] = item;
                                }
                            }
                        }
                        return deduplicated;
                    };
                    
                    // Aplicar deduplica√ß√£o dos problemas na UI
                    const deduplicatedProblems = deduplicateByType(analysis.problems);
                    const list = deduplicatedProblems.map(p => {
                        const msg = typeof p.message === 'string' ? p.message.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.message;
                        const sol = typeof p.solution === 'string' ? p.solution.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.solution;
                        
                        // üö® USAR FORMATO NATIVO DOS PROBLEMAS - Evitar duplica√ß√£o do SuggestionTextGenerator
                        // Os problemas j√° t√™m explanation, impact, frequency_range, adjustment_db, details
                        let didacticText = null; // Desabilitado para evitar duplica√ß√£o
                        
                        // Se for problema cr√≠tico (clipping, etc), usar card cr√≠tico aprimorado
                        if (p.type === 'clipping' || p.severity === 'critical' || p.severity === 'high') {
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            
                            return `
                                <div class="enhanced-card critical-alert">
                                    <div class="card-header">
                                        <h4 class="card-title">üö® Problema Cr√≠tico</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge severa">CR√çTICO</span>
                                        </div>
                                    </div>
                                    
                                    <div class="card-description" style="border-left-color: #f44336;">
                                        <strong>‚ö†Ô∏è Problema:</strong> ${msg}
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description" style="border-left-color: #f44336; background: rgba(244, 67, 54, 0.05);">
                                            <strong>Explica√ß√£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                        <div class="card-action-title" style="color: #f44336;">
                                            üö® A√ß√£o Urgente
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || p.adjustment_db) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Frequ√™ncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${p.adjustment_db ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${p.adjustment_db} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                            <div class="card-impact-title" style="color: #f44336;">‚ö†Ô∏è Por que √© cr√≠tico</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes T√©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        } else {
                            // Para problemas menos cr√≠ticos, usar card padr√£o melhorado
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            const dbMatch = sol.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                            const dbValue = dbMatch ? dbMatch[1] : null;
                            
                            // Determinar tipo de problema
                            const problemType = p.type || 'general';
                            let cardClass = 'enhanced-card problem';
                            let problemIcon = '‚ö†Ô∏è';
                            
                            if (problemType.includes('balance')) {
                                cardClass = 'enhanced-card balance';
                                problemIcon = '‚öñÔ∏è';
                            } else if (problemType.includes('dc_offset')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'üìä';
                            } else if (problemType.includes('phase')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'üåä';
                            }
                            
                            return `
                                <div class="${cardClass}">
                                    <div class="card-header">
                                        <h4 class="card-title">${problemIcon} ${msg}</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge moderada">problema</span>
                                        </div>
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description">
                                            <strong>Explica√ß√£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action">
                                        <div class="card-action-title">
                                            üîß Como Resolver
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || dbValue) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Frequ√™ncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${dbValue ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${dbValue} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact">
                                            <div class="card-impact-title">‚ö†Ô∏è Impacto</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes T√©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        }
                    }).join('');
                    blocks.push(`<div class="diag-section"><div class="diag-heading">‚ö†Ô∏è Problemas Detectados:</div>${list}</div>`);
                }
                // üõë CARD DE SUGEST√ïES ANTIGAS DESATIVADO - Removido conforme solicitado
                // O card "SUGEST√ïES EDUCACIONAIS ULTRA-AVAN√áADAS" foi desativado para limpar a UI
                // Apenas o novo sistema de sugest√µes (que aparece no final do modal) deve ser usado
                /*
                if ((analysis.suggestions?.length || 0) > 0) {
                    // [C√ìDIGO COMENTADO - Card de sugest√µes antigas removido]
                }
                */
                // Subbloco opcional com diagn√≥sticos do V2 PRO (quando dispon√≠veis)
                const v2Pro = analysis.v2Pro || analysis.v2Diagnostics; // Compatibilidade
                if (v2Pro && (typeof window === 'undefined' || window.SUGESTOES_AVANCADAS !== false)) {
                    const v2p = (v2Pro.problems || []).map(p => `
                        <div class="diag-item danger">
                            <div class="diag-title">${p.message}</div>
                            <div class="diag-tip">${p.solution || ''}</div>
                        </div>`).join('');
                    // V2 Pro removido - n√£o mostrar diagn√≥sticos duplicados
                }
                console.log('[RENDER_SUGGESTIONS] ‚úÖ Finalizada - Total de sugest√µes:', enrichedSuggestions?.length || 0);
                return blocks.join('') || '<div class="diag-empty">Sem diagn√≥sticos</div>';
            };

        // üéØ SUBSCORES: Corrigir mapeamento para backend Node.js
        const breakdown = analysis.scores || analysis.qualityBreakdown || {};
        
        // üéØ APLICAR CAPS EM ESTADO CLIPPED
        const precedenceData = analysis.technicalData?._singleStage;
        const isClippedState = precedenceData?.finalState === 'CLIPPED' && precedenceData?.scoreCapApplied === true;
        
        // Aplicar caps nos sub-scores se em estado CLIPPED
        const applyClippingCaps = (originalBreakdown) => {
            if (!isClippedState) return originalBreakdown;
            
            const capped = { ...originalBreakdown };
            
            // Caps espec√≠ficos para estado CLIPPED
            if (Number.isFinite(capped.loudness)) {
                capped.loudness = Math.min(capped.loudness, 70); // Loudness ‚â§ 70
            }
            if (Number.isFinite(capped.technical)) {
                capped.technical = Math.min(capped.technical, 60); // T√©cnico ‚â§ 60  
            }
            if (Number.isFinite(capped.dynamics)) {
                capped.dynamics = Math.min(capped.dynamics, 50); // Din√¢mica ‚â§ 50
            }
            
            // Frequency e Stereo podem manter valores originais (n√£o afetados diretamente pelo clipping)
            
            return capped;
        };
        
        const finalBreakdown = applyClippingCaps(breakdown);
        
        // Fun√ß√£o para renderizar score com barra de progresso
        const renderScoreWithProgress = (label, value, color = '#00ffff') => {
            const numValue = parseFloat(value) || 0;
            const displayValue = value != null ? value : '‚Äî';
            
            // Indicar se o valor foi capeado (comparar com breakdown original)
            const labelKey = label.toLowerCase().replace('faixa din√¢mica', 'dynamics').replace('t√©cnico', 'technical').replace('loudness', 'loudness').replace('frequ√™ncia', 'frequency').replace('stereo', 'stereo');
            const wasCapped = isClippedState && breakdown[labelKey] && Number.isFinite(breakdown[labelKey]) && 
                             breakdown[labelKey] !== value;
            const cappedIndicator = wasCapped ? ' üî¥' : '';
            
            if (value == null) {
                return `<div class="data-row">
                    <span class="label">${label}:</span>
                    <span class="value">‚Äî</span>
                </div>`;
            }
            
            return `<div class="data-row metric-with-progress">
                <span class="label">${label}${cappedIndicator}:</span>
                <div class="metric-value-progress">
                    <span class="value">${displayValue}/100</span>
                    <div class="progress-bar-mini">
                        <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${color}; color: ${color};"></div>
                    </div>
                </div>
            </div>`;
        };
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üéØ RENDERIZAR SCORE FINAL NO TOPO - VISUAL FUTURISTA
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        /**
         * Renderiza o score final no container dedicado no topo da an√°lise
         * @param {Object} scores - Objeto contendo todos os scores
         */
        function renderFinalScoreAtTop(scores) {
            console.log('[RENDER_FINAL_SCORE] ‚úÖ Iniciada');
            console.log('[RENDER_FINAL_SCORE] scores:', scores);
            
            if (!scores || !Number.isFinite(scores.final)) {
                console.warn('[RENDER_FINAL_SCORE] ‚ö†Ô∏è Retorno antecipado - Score final n√£o dispon√≠vel');
                console.warn('[AUDITORIA_CONDICAO] ‚ö†Ô∏è Retorno antecipado em: renderFinalScoreAtTop - !scores || !Number.isFinite(scores.final)');
                return;
            }
            
            const container = document.getElementById('final-score-display');
            if (!container) {
                console.error('[RENDER_FINAL_SCORE] ‚ö†Ô∏è Retorno antecipado - Container #final-score-display n√£o encontrado');
                console.warn('[AUDITORIA_CONDICAO] ‚ö†Ô∏è Retorno antecipado em: renderFinalScoreAtTop - !container');
                return;
            }
            
            console.log('[RENDER_FINAL_SCORE] ‚úÖ Container encontrado, renderizando...');
            
            const finalScore = Math.round(scores.final);
            const percent = Math.min(Math.max(finalScore, 0), 100);
            
            // Determinar mensagem de status baseada no score
            let statusMessage = '';
            let statusClass = '';
            
            if (finalScore >= 90) {
                statusMessage = '‚ú® Excelente! Pronto para lan√ßamento';
                statusClass = 'status-excellent';
            } else if (finalScore >= 75) {
                statusMessage = '‚úÖ √ìtimo! Qualidade profissional';
                statusClass = 'status-good';
            } else if (finalScore >= 60) {
                statusMessage = '‚ö†Ô∏è Bom, mas pode melhorar';
                statusClass = 'status-warning';
            } else if (finalScore >= 40) {
                statusMessage = 'üîß Precisa de ajustes';
                statusClass = 'status-warning';
            } else {
                statusMessage = 'üö® Necessita corre√ß√µes importantes';
                statusClass = 'status-poor';
            }
            
            // Renderizar HTML do score final
            container.innerHTML = `
                <div class="score-final-label">üèÜ SCORE FINAL</div>
                <div class="score-final-value">0</div>
                <div class="score-final-bar-container">
                    <div class="score-final-bar">
                        <div class="score-final-bar-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-final-status ${statusClass}">${statusMessage}</div>
            `;
            
            // Animar contagem do score (impacto visual) - inicia ap√≥s pequeno delay
            setTimeout(() => {
                animateFinalScore(finalScore);
            }, 100);
            
            console.log('[RENDER_FINAL_SCORE] ‚úÖ Finalizada');
        }
        
        /**
         * Anima a contagem do score final de 0 at√© o valor final
         * @param {number} targetScore - Score final a ser exibido
         */
        function animateFinalScore(targetScore) {
            const el = document.querySelector('.score-final-value');
            const barFill = document.querySelector('.score-final-bar-fill');
            if (!el) return;
            
            let currentScore = 0;
            const duration = 2500; // 2.5 segundos (mais lento e dram√°tico)
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out cubic - mais suave)
                const eased = 1 - Math.pow(1 - progress, 3);
                currentScore = targetScore * eased;
                
                // Atualizar n√∫mero
                el.textContent = Math.floor(currentScore);
                
                // Animar barra junto (se existir)
                if (barFill) {
                    const currentPercent = Math.min(Math.max(currentScore, 0), 100);
                    barFill.style.width = `${currentPercent}%`;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    el.textContent = targetScore; // Garantir valor final exato
                    if (barFill) {
                        const finalPercent = Math.min(Math.max(targetScore, 0), 100);
                        barFill.style.width = `${finalPercent}%`;
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // üéØ RENDERIZAR SCORES DO NOVO SISTEMA
        const renderNewScores = () => {
            // Verificar se temos scores calculados
            const scores = analysis.scores;
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üîç TAREFA 2: AUDITORIA DE LEITURA DE SCORES NA UI
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            console.group('üé® [AUDIT-RENDER] LEITURA DE SCORES NA UI');
            console.log('[AUDIT-RENDER] analysis.scores recebido pela UI:', scores);
            console.log('[AUDIT-RENDER] scores existe?', !!scores);
            console.log('[AUDIT-RENDER] scores.loudness:', scores?.loudness);
            console.log('[AUDIT-RENDER] scores.dinamica:', scores?.dinamica);
            console.log('[AUDIT-RENDER] scores.estereo:', scores?.estereo);
            console.log('[AUDIT-RENDER] scores.frequencia:', scores?.frequencia);
            console.log('[AUDIT-RENDER] scores.tecnico:', scores?.tecnico);
            console.log('[AUDIT-RENDER] scores.subscores:', scores?.subscores);
            console.groupEnd();
            
            if (!scores) {
                console.warn('‚ö†Ô∏è [AUDIT-RENDER] SCORES AUSENTES - renderizando fallback');
                return `<div class="data-row">
                    <span class="label">Sistema de Scoring:</span>
                    <span class="value">N√£o dispon√≠vel</span>
                </div>`;
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // üîß TAREFA 3: NORMALIZA√á√ÉO DE ESTRUTURA DE SCORES
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // Adaptar estrutura retornada por calculateAnalysisScores para UI
            const rawScores = scores || {};
            const subs = rawScores.subscores || rawScores;
            
            const normalizedScores = {
                loudness: subs.loudness ?? rawScores.loudness ?? subs.lufs ?? null,
                dinamica: subs.dinamica ?? subs.dynamics ?? rawScores.dinamica ?? rawScores.dynamics ?? null,
                estereo: subs.estereo ?? subs.stereo ?? rawScores.estereo ?? rawScores.stereo ?? null,
                frequencia: subs.frequencia ?? subs.frequency ?? rawScores.frequencia ?? rawScores.frequency ?? null,
                tecnico: subs.tecnico ?? subs.technical ?? rawScores.tecnico ?? rawScores.technical ?? null,
                final: rawScores.final ?? rawScores.composite ?? rawScores.score ?? null,
                breakdown: rawScores.breakdown ?? null
            };
            
            console.group('‚úÖ [AUDIT-RENDER] SCORES NORMALIZADOS');
            console.log('[AUDIT-RENDER] normalizedScores.loudness:', normalizedScores.loudness);
            console.log('[AUDIT-RENDER] normalizedScores.dinamica:', normalizedScores.dinamica);
            console.log('[AUDIT-RENDER] normalizedScores.estereo:', normalizedScores.estereo);
            console.log('[AUDIT-RENDER] normalizedScores.frequencia:', normalizedScores.frequencia);
            console.log('[AUDIT-RENDER] normalizedScores.tecnico:', normalizedScores.tecnico);
            console.log('[AUDIT-RENDER] normalizedScores.final:', normalizedScores.final);
            
            // üîç TAREFA 4: VALIDA√á√ÉO FINAL - Contagem de valores null
            const nullCount = Object.values(normalizedScores).filter(v => v === null).length;
            const validCount = Object.values(normalizedScores).filter(v => Number.isFinite(v)).length;
            console.log('üìä [AUDIT-RENDER] VALIDA√á√ÉO:', {
                total: Object.keys(normalizedScores).length,
                validos: validCount,
                nulos: nullCount,
                status: nullCount === 0 ? '‚úÖ TODOS PREENCHIDOS' : `‚ö†Ô∏è ${nullCount} NULOS`
            });
            console.groupEnd();
            
            const renderScoreProgressBar = (label, value, color = '#00ffff', emoji = 'üéØ') => {
                // Se null/undefined, renderizar "‚Äî" e barra vazia SEM cores "ok"
                if (!Number.isFinite(value)) {
                    return `<div class="data-row metric-with-progress">
                        <span class="label">${emoji} ${label}:</span>
                        <div class="metric-value-progress">
                            <span class="value" style="color: #666; font-weight: normal;">‚Äî</span>
                            <div class="progress-bar-mini">
                                <div class="progress-fill-mini" style="width: 0%; background: transparent;"></div>
                            </div>
                        </div>
                    </div>`;
                }
                
                const numValue = value;
                const displayValue = Math.round(value);
                
                // Cor baseada no score
                let scoreColor = color;
                if (value >= 80) scoreColor = '#00ff92'; // Verde para scores altos
                else if (value >= 60) scoreColor = '#ffd700'; // Amarelo para scores m√©dios
                else if (value >= 40) scoreColor = '#ff9500'; // Laranja para scores baixos
                else scoreColor = '#ff3366'; // Vermelho para scores muito baixos
                
                return `<div class="data-row metric-with-progress">
                    <span class="label">${emoji} ${label}:</span>
                    <div class="metric-value-progress">
                        <span class="value" style="color: ${scoreColor}; font-weight: bold;">${displayValue}</span>
                        <div class="progress-bar-mini">
                            <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${scoreColor};"></div>
                        </div>
                    </div>
                </div>`;
            };
            
            // üéØ Score final REMOVIDO daqui - ser√° renderizado no topo
            // ‚ùå N√ÉO INCLUIR O SCORE FINAL AQUI - ele tem seu pr√≥prio container no topo
            
            // ‚úÖ Sub-scores permanecem no mesmo lugar (dentro do card Scores & Diagn√≥stico)
            // üîß USANDO normalizedScores ao inv√©s de scores bruto
            const subScoresHtml = `
                ${renderScoreProgressBar('Loudness', normalizedScores.loudness, '#ff3366', 'üîä')}
                ${renderScoreProgressBar('Frequ√™ncia', normalizedScores.frequencia, '#00ffff', 'üéµ')}
                ${renderScoreProgressBar('Est√©reo', normalizedScores.estereo, '#ff6b6b', 'üéß')}
                ${renderScoreProgressBar('Din√¢mica', normalizedScores.dinamica, '#ffd700', 'üìä')}
                ${renderScoreProgressBar('T√©cnico', normalizedScores.tecnico, '#00ff92', 'üîß')}
            `;
            
            return subScoresHtml;
        };
        
        const scoreRows = renderNewScores();

        // üîπ Fun√ß√£o utilit√°ria: Remove n√≥s de texto vazios (whitespace) dentro dos cards
        function normalizeCardWhitespace(root = document) {
            const cards = root.querySelectorAll('.cards-grid .card');
            cards.forEach((card) => {
                // Remove n√≥s de texto que sejam apenas whitespace (espa√ßos/linhas)
                const toRemove = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        toRemove.push(n);
                    }
                });
                toRemove.forEach((n) => n.parentNode.removeChild(n));
            });
        }

        // üîπ Alias para compatibilidade com nomenclatura alternativa
        function stripEmptyTextNodesInCards(root = document) {
            root.querySelectorAll('.cards-grid .card').forEach((card) => {
                const garbage = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        garbage.push(n);
                    }
                });
                garbage.forEach((n) => n.remove());
            });
        }

        // =========================================================================
        // üö® AUDITORIA CR√çTICA: PONTO DE RENDERIZA√á√ÉO DE CARDS
        // =========================================================================
        console.groupCollapsed('[AUDITORIA_RENDERIZACAO] üé® RENDERIZA√á√ÉO DE CARDS');
        console.log('[RENDER_CARDS] ‚úÖ IN√çCIO - Prestes a renderizar cards');
        console.log('[RENDER_CARDS] Modo:', analysis?.mode);
        console.log('[RENDER_CARDS] Cont√©m analysis.scores?', !!analysis?.scores);
        console.log('[RENDER_CARDS] Cont√©m analysis.technicalData?', !!analysis?.technicalData);
        console.log('[RENDER_CARDS] technicalData dispon√≠vel no DOM?', !!document.getElementById('modalTechnicalData'));
        console.log('[RENDER_CARDS] scoreKpi length:', scoreKpi?.length || 0);
        console.log('[RENDER_CARDS] col1 length:', col1?.length || 0);
        console.log('[RENDER_CARDS] col2 length:', col2?.length || 0);
        console.groupEnd();
        
        // [AUDIT-FLOW-CHECK] Confirmar que chegou na renderiza√ß√£o de cards
        console.log('[AUDIT-FLOW-CHECK] ‚úÖ Renderizando cards - modo:', analysis?.mode);
        
        // =========================================================================
        // üö® AUDITORIA: RENDERIZAR SCORE FINAL NO TOPO
        // =========================================================================
        console.log('[RENDER_SCORE_TOP] ‚úÖ Chamando renderFinalScoreAtTop');
        console.log('[RENDER_SCORE_TOP] analysis.scores:', analysis?.scores);
        
        // üéØ RENDERIZAR SCORE FINAL NO TOPO (ISOLADO)
        renderFinalScoreAtTop(analysis.scores);
        
        console.log('[RENDER_SCORE_TOP] ‚úÖ renderFinalScoreAtTop FINALIZADO');

        console.log('[RENDER_CARDS] ‚úÖ Atribuindo HTML ao technicalData.innerHTML');
        technicalData.innerHTML = `
            <div class="kpi-row">${scoreKpi}${timeKpi}</div>
            ${renderSmartSummary(analysis)}
            <div class="cards-grid">
                <div class="card">
                    <div class="card-title">M√âTRICAS PRINCIPAIS</div>
                    ${col1}
                </div>
                <div class="card">
                    <div class="card-title">AN√ÅLISE DE FREQU√äNCIAS</div>
                    ${col2}
                </div>
                <div class="card">
                    <div class="card-title">M√âTRICAS AVAN√áADAS</div>
                    ${advancedMetricsCard()}
                </div>
                <div class="card">
                    <div class="card-title">SCORES & DIAGN√ìSTICO</div>
                    ${scoreRows}
                    ${col3}
                </div>
                <!-- Card "Problemas T√©cnicos" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">‚ö†Ô∏è Problemas T√©cnicos</div>
                    ${techProblems()}
                </div>
                -->
                <!-- Card "Diagn√≥stico & Sugest√µes" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">ü©∫ Diagn√≥stico & Sugest√µes</div>
                    ${diagCard()}
                </div>
                -->
            </div>
        `;
        
        // =========================================================================
        // üö® AUDITORIA: CONFIRMAR RENDERIZA√á√ÉO NO DOM
        // =========================================================================
        console.log('[RENDER_CARDS] ‚úÖ HTML atribu√≠do ao technicalData.innerHTML');
        console.log('[RENDER_CARDS] Tamanho do HTML:', technicalData.innerHTML.length);
        console.log('[RENDER_CARDS] Primeiros 200 chars:', technicalData.innerHTML.substring(0, 200));
    
        // üîπ Sanitizar DOM: Remove n√≥s de texto vazios que criam espa√ßo extra
        normalizeCardWhitespace(technicalData);
        stripEmptyTextNodesInCards(technicalData);
        
        // =========================================================================
        // üö® AUDITORIA: VERIFICAR DOM AP√ìS SANITIZA√á√ÉO
        // =========================================================================
        setTimeout(() => {
            console.groupCollapsed('[AUDITORIA_DOM] üîç VERIFICA√á√ÉO DO DOM');
            console.log('[AUDITORIA_DOM] Cards:', document.querySelectorAll('.cards-grid .card').length);
            console.log('[AUDITORIA_DOM] Sugest√µes:', document.querySelectorAll('.suggestion-card').length);
            console.log('[AUDITORIA_DOM] Score containers:', document.querySelectorAll('.score-card, .final-score-display').length);
            console.log('[AUDITORIA_DOM] technicalData.innerHTML length:', document.getElementById('modalTechnicalData')?.innerHTML?.length || 0);
            console.groupEnd();
        }, 1000);
    
        // üéØ CORRIGIDO: S√≥ renderizar refer√™ncias se N√ÉO estiver em modo compara√ß√£o de faixas
        // O displayModalResults() j√° trata compara√ß√£o via renderTrackComparisonTable()
        
        // üî• FLAG DE CONTROLE: Impedir dupla renderiza√ß√£o em modo g√™nero
        let genreRenderComplete = false;
        
        try { 
            // ========================================
            // üî• MODO G√äNERO: RENDERIZA√á√ÉO ISOLADA
            // ========================================
            // ‚úÖ RESTAURADO: Fluxo original que sempre funcionou
            if (analysis?.mode === "genre") {
                console.log('%c[GENRE-MODE] üéØ MODO G√äNERO DETECTADO - RENDERIZA√á√ÉO DIRETA', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
                console.log('[GENRE-MODE] analysis.mode:', analysis.mode);
                console.log('[GENRE-MODE] analysis.genre:', analysis.genre || analysis.metadata?.genre);
                console.log('[GENRE-MODE] window.__activeRefData:', !!window.__activeRefData);
                console.log('[GENRE-MODE] window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
                console.log('[GENRE-MODE] analysis.bands:', analysis.bands ? Object.keys(analysis.bands).length + ' bandas' : 'N/A');
                console.log('[GENRE-MODE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // ‚úÖ CHAMAR FUN√á√ÉO DE RENDERIZA√á√ÉO DE G√äNERO
                renderGenreView(analysis);
                
                // üî• MARCAR FLAG: G√™nero foi renderizado, N√ÉO renderizar A/B depois
                genreRenderComplete = true;
                
                console.log('%c[GENRE-MODE] ‚úÖ RENDERIZA√á√ÉO CONCLU√çDA', 'color:#00FF88;font-weight:bold;');
                return;
            }
            
            // ========================================
            // üéØ MODO REFER√äNCIA: PREPARAR DADOS PARA COMPARA√á√ÉO A/B
            // ========================================
            // ‚úÖ RESTAURADO: Fluxo original de refer√™ncia mantido intacto
            const isSecondTrack = (
                analysis.mode === 'reference' &&
                window.__REFERENCE_JOB_ID__ !== null &&
                window.__REFERENCE_JOB_ID__ !== undefined
            );
            
            const mode = analysis?.mode || currentAnalysisMode;
            const state = window.__soundyState || {};
            
            console.log('üîç [RENDER-FLOW] Verificando modo e decis√£o de renderiza√ß√£o:', {
                'analysis.mode': analysis.mode,
                'analysis.isReferenceBase': analysis.isReferenceBase,
                'currentAnalysisMode': window.currentAnalysisMode,
                isSecondTrack,
                hasReferenceAnalysisData: !!window.referenceAnalysisData,
                '__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
                stateRenderMode: state.render?.mode
            });
            
            console.log('[VERIFY_RENDER_MODE]', {
                mode: state.render?.mode || 'undefined',
                usingReferenceBands: !!(state.reference?.analysis?.bands || analysis?.referenceAnalysis?.bands),
                usingGenreTargets: !!window.__activeRefData?.bands,
                genreTargetsKeys: window.__activeRefData?.bands ? Object.keys(window.__activeRefData.bands) : [],
                referenceBandsKeys: state.reference?.analysis?.bands ? Object.keys(state.reference.analysis.bands) : []
            });
            
            console.log('üéµ [REFERENCE-MODE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üéµ [REFERENCE-MODE] MODO REFER√äNCIA DETECTADO');
            console.log('üéµ [REFERENCE-MODE] analysis.mode:', analysis.mode);
            console.log('üéµ [REFERENCE-MODE] analysis.isReferenceBase:', analysis.isReferenceBase);
            console.log('üéµ [REFERENCE-MODE] isSecondTrack:', isSecondTrack);
            console.log('üéµ [REFERENCE-MODE] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            console.log(`üìä [RENDER-FLOW] Preparando renderReferenceComparisons() - modo: ${compareMode}`);
            console.log('[RENDER-FLOW] mustBeReference:', mustBeReference);
            console.log('[RENDER-FLOW] __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[RENDER-FLOW] referenceAnalysisData.bands:', !!window.referenceAnalysisData?.bands);
            
            // Preparar objeto ctx com clones profundos para evitar contamina√ß√£o
            const userClone = (typeof structuredClone === 'function') 
                ? structuredClone(analysis) 
                : JSON.parse(JSON.stringify(analysis));
            
            const refClone = window.referenceAnalysisData 
                ? ((typeof structuredClone === 'function') 
                    ? structuredClone(window.referenceAnalysisData) 
                    : JSON.parse(JSON.stringify(window.referenceAnalysisData)))
                : null;
            
            const renderOpts = {
                mode: compareMode,
                user: userClone,
                ref: refClone,
                // Compatibilidade com c√≥digo legado
                analysis: analysis,
                userAnalysis: state.userAnalysis || state.reference?.userAnalysis || userClone,
                referenceAnalysis: state.referenceAnalysis || state.reference?.referenceAnalysis || refClone
            };
            
            console.log('[RENDER-OPTS] ‚úÖ Dados preparados:', {
                mode: renderOpts.mode,
                hasUser: !!renderOpts.user,
                hasRef: !!renderOpts.ref,
                userBands: !!renderOpts.user?.bands,
                refBands: !!renderOpts.ref?.bands
            });
            
            // üîç [AUDIT-BANDS-BEFORE] Log ANTES da chamada de renderReferenceComparisons
            try {
                const refBands = renderOpts.referenceAnalysis?.bands || renderOpts.referenceAnalysis?.technicalData?.spectral_balance;
                const userBands = renderOpts.userAnalysis?.bands || renderOpts.userAnalysis?.technicalData?.spectral_balance;
                console.log('[AUDIT-BANDS-BEFORE]', {
                    hasRefBands: !!refBands,
                    hasUserBands: !!userBands,
                    refBandsType: typeof refBands,
                    userBandsType: typeof userBands,
                    refBandsKeys: refBands ? Object.keys(refBands) : [],
                    userBandsKeys: userBands ? Object.keys(userBands) : [],
                    refBandsPreview: refBands ? Object.keys(refBands).slice(0, 3) : 'N/A',
                    userBandsPreview: userBands ? Object.keys(userBands).slice(0, 3) : 'N/A',
                    renderOptsKeys: Object.keys(renderOpts)
                });
            } catch (err) {
                console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-BEFORE', err);
            }
            
            // ‚úÖ [BANDS-FIX] Nunca espera bandas no DOM - trabalha direto nos objetos
            // Se os objetos existem, seguimos ‚Äî processamento √© nos dados, n√£o no DOM
            const ensureBandsReady = (userFull, refFull) => {
                return !!(userFull && refFull);
            };

            // üî• PROTE√á√ÉO: N√ÉO renderizar A/B se g√™nero j√° foi renderizado
            if (genreRenderComplete) {
                console.log('[GENRE-PROTECTION] ‚úÖ Modo g√™nero j√° renderizado - BLOQUEANDO renderiza√ß√£o A/B');
            } else if (ensureBandsReady(renderOpts?.userAnalysis, renderOpts?.referenceAnalysis)) {
                renderReferenceComparisons(renderOpts);
            } else {
                console.warn('[BANDS-FIX] ‚ö†Ô∏è Objetos ausentes para compara√ß√£o A/B, pulando render de refer√™ncia');
            }
        } catch(e){ 
            console.error('‚ùå [RENDER-FLOW] ERRO em renderReferenceComparisons:', e);
            console.error('‚ùå Stack trace:', e.stack);
        }    
        try { if (window.CAIAR_ENABLED) injectValidationControls(); } catch(e){ console.warn('validation controls fail', e); }
        
        // üîç Verifica√ß√£o de debug: Detecta whitespace restante
        if (window.DEBUG_ANALYZER) {
            document.querySelectorAll('.cards-grid .card').forEach((card, i) => {
                const ghosts = [...card.childNodes].filter(n => n.nodeType === 3 && !/\S/.test(n.nodeValue || ''));
                if (ghosts.length) console.warn(`Card #${i+1}: whitespace nodes restantes`, ghosts);
            });
        }
        
        __dbg('üìä Resultados exibidos no modal');
        
        // ‚úÖ LOG FINAL DE CONFIRMA√á√ÉO
        console.log('[DISPLAY_MODAL_RESULTS] ‚úÖ‚úÖ‚úÖ FUN√á√ÉO FINALIZADA COM SUCESSO ‚úÖ‚úÖ‚úÖ');
        console.log('[DISPLAY_MODAL_RESULTS] Modo:', analysis?.mode);
        console.log('[DISPLAY_MODAL_RESULTS] Self-compare?', state?.render?.isSelfCompare || false);
        console.log('[DISPLAY_MODAL_RESULTS] Renderiza√ß√£o completa: cards, scores, tabela A/B, sugest√µes');
    }

    // === Controles de Valida√ß√£o (Suite Objetiva + Subjetiva) ===
    function injectValidationControls(){
        if (document.getElementById('validationControlsBar')) return;
        const host = document.getElementById('modalTechnicalData');
        if (!host) return;
        const bar = document.createElement('div');
        bar.id='validationControlsBar';
        bar.style.cssText='margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:#0f1826;padding:10px 12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;font-size:12px;';
        bar.innerHTML = `
            <strong style="letter-spacing:.5px;color:#9fc9ff;font-weight:600;">Valida√ß√£o Auditiva</strong>
            <button id="runValidationSuiteBtn" style="background:#10365a;color:#fff;border:1px solid #1e4d7a;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;">Rodar Suite (10)</button>
            <button id="openSubjectiveFormBtn" style="background:#1c2c44;color:#d6e7ff;border:1px solid #284362;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Subjetivo 1‚Äì5</button>
            <button id="downloadValidationReportBtn" style="background:#224d37;color:#c5ffe9;border:1px solid #2f6e4e;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Baixar Relat√≥rio</button>
            <span id="validationStatusMsg" style="margin-left:auto;font-size:11px;opacity:.75;">Pronto</span>
        `;
        host.prepend(bar);
        // Handlers
        const btnRun = bar.querySelector('#runValidationSuiteBtn');
        const btnForm = bar.querySelector('#openSubjectiveFormBtn');
        const btnDownload = bar.querySelector('#downloadValidationReportBtn');
        const statusEl = bar.querySelector('#validationStatusMsg');
        btnRun.onclick = async ()=>{
            btnRun.disabled = true; btnRun.textContent = 'Rodando...'; statusEl.textContent = 'Executando suite...';
            try {
                const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`);
                const summary = await mod.runValidationSuite({});
                statusEl.textContent = summary? `Cobertura m√©dia Œî ${(summary.avgDelta*100).toFixed(1)}%` : 'Sem dados';
                btnRun.textContent = 'Suite OK';
                btnForm.disabled = false; btnDownload.disabled = false;
                // √Årea din√¢mica para formul√°rio
                ensureValidationPanel();
            } catch(err){ console.error('Erro suite valida√ß√£o', err); statusEl.textContent='Erro'; btnRun.textContent='Erro'; btnRun.disabled=false; }
        };
        btnForm.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); ensureValidationPanel(); mod.renderSubjectiveForm('validationPanelInner'); statusEl.textContent='Formul√°rio subjetivo aberto'; } catch(e){ console.warn(e); }
        };
        btnDownload.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); const rep = mod.generateValidationReport(); if(rep){ downloadObjectAsJson(rep, 'prodai_validation_report.json'); statusEl.textContent = rep?.subjective?.pctImproved!=null? `Subj ${(rep.subjective.pctImproved*100).toFixed(0)}%`:'Relat√≥rio gerado'; } } catch(e){ console.warn(e); }
        };
    }

    function ensureValidationPanel(){
        if (document.getElementById('validationPanel')) return;
        const container = document.createElement('div');
        container.id='validationPanel';
        container.style.cssText='margin-top:12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:#0d141f;padding:10px 12px;';
        container.innerHTML = `<div style="font-size:12px;font-weight:600;letter-spacing:.5px;color:#9fc9ff;margin-bottom:6px;">Resultados da Valida√ß√£o</div><div id='validationPanelInner' style='font-size:11px;'></div>`;
        const host = document.getElementById('modalTechnicalData');
        if (host) host.appendChild(container);
        // estilos m√≠nimos tabela subjetiva
        if (!document.getElementById('validationStyles')){
            const st=document.createElement('style'); st.id='validationStyles'; st.textContent=`
                .subjective-table{border-collapse:collapse;width:100%;margin-top:6px;font-size:11px;}
                .subjective-table th,.subjective-table td{border:1px solid rgba(255,255,255,.08);padding:4px 6px;text-align:center;}
                .subjective-table th{background:#132132;color:#c9e4ff;font-weight:500;letter-spacing:.4px;}
                .subjective-table select{min-width:42px;}
            `; document.head.appendChild(st);
        }
    }

    function downloadObjectAsJson(obj, filename){
        try { const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250); } catch(e){ console.warn('download json fail', e); }
    }

// ===== Painel Resumo Inteligente (top 3 problemas + top 3 a√ß√µes) =====
function renderSmartSummary(analysis){
    try {
        if (!(typeof window !== 'undefined' && window.CAIAR_ENABLED) || !analysis) return '';
        // Garantir plano explain (caso ainda n√£o anexado)
        if (!analysis.caiarExplainPlan && window.audioAnalyzer && typeof analysis === 'object') {
            try {
                // se m√≥dulo ainda n√£o carregado, importar dinamicamente
                if (!window.__CAIAR_EXPLAIN_LOADING__) {
                    window.__CAIAR_EXPLAIN_LOADING__ = import('/lib/audio/features/caiar-explain.js').then(mod=>{
                        if (mod && typeof mod.generateExplainPlan === 'function') mod.generateExplainPlan(analysis);
                    }).catch(()=>null);
                }
            } catch {}
        }
        const problems = Array.isArray(analysis.problems) ? analysis.problems.slice(0,3) : [];
        // Selecionar a√ß√µes: usar passos do plano explain se existir, sen√£o derivar das sugest√µes
        let steps = (analysis.caiarExplainPlan && Array.isArray(analysis.caiarExplainPlan.passos)) ? analysis.caiarExplainPlan.passos.slice(0,6) : [];
        if (steps.length === 0) {
            const sugg = Array.isArray(analysis.suggestions) ? analysis.suggestions.slice() : [];
            // Ordenar por prioridade DECRESCENTE (maior prioridade = menor valor num√©rico = vem primeiro)
            sugg.sort((a,b)=> (b.priority||999)-(a.priority||999));
            steps = sugg.slice(0,6).map((s,i)=>({
                ordem:i+1,
                titulo:s.message||'A√ß√£o',
                acao:s.action||'',
                porque:s.details||s.rationale? JSON.stringify(s.rationale):'Otimiza√ß√£o recomendada',
                condicao:s.condition||s.condicao||'Aplicar quando percept√≠vel',
                origem:s.source||s.type,
                stem:s.targetStem||null,
                parametroPrincipal: s.freqHz? (Math.round(s.freqHz)+' Hz'): (s.band||null)
            }));
        }
        const topActions = steps.slice(0,3);
        const actionItems = topActions.map(a=>{
            const stem = a.stem ? `<span class="ss-stem">${a.stem}</span>` : '';
            const param = a.parametroPrincipal ? `<span class="ss-param">${a.parametroPrincipal}</span>` : '';
            const cond = a.condicao ? `<span class="ss-cond">${a.condicao}</span>` : '';
            const whyId = 'why_'+Math.random().toString(36).slice(2);
            return `<div class="ss-action-item">
                <div class="ss-line-main">
                    <span class="ss-title">${a.titulo}</span>
                    ${stem}
                    ${param}
                </div>
                <div class="ss-line-meta">
                    ${cond}
                    <button type="button" class="ss-why-btn" data-why-target="${whyId}">Por que?</button>
                </div>
                <div class="ss-why" id="${whyId}">${a.porque || 'Melhora coer√™ncia sonora.'}</div>
            </div>`;
        }).join('');
        const problemItems = problems.map(p=>`<div class="ss-prob-item"><span class="ss-prob-msg">${p.message||''}</span></div>`).join('');
        // Expand/Collapse container
        const html = `<div class="smart-summary-card" id="smartSummaryCard">
            <div class="ss-header">
                <div class="ss-title-block">‚ö° Resumo Inteligente</div>
                <button type="button" class="ss-toggle" data-expanded="true">Colapsar</button>
            </div>
            <div class="ss-content" data-collapsible="body">
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 Problemas</div>
                    ${problemItems || '<div class="ss-empty">Nenhum problema cr√≠tico</div>'}
                </div>
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 A√ß√µes</div>
                    ${actionItems || '<div class="ss-empty">Nenhuma a√ß√£o priorit√°ria</div>'}
                </div>
                <div class="ss-hint">Execute as a√ß√µes na ordem. Tempo de entendimento < 30s.</div>
            </div>
        </div>`;
        // Injetar estilos apenas uma vez
        if (!document.getElementById('smartSummaryStyles')) {
            const st = document.createElement('style');
            st.id = 'smartSummaryStyles';
            st.textContent = `
            .smart-summary-card{margin:12px 0 4px 0;padding:14px 16px;border:1px solid rgba(255,255,255,.08);border-radius:14px;background:linear-gradient(145deg,#0f1623,#101b2e);box-shadow:0 4px 14px -4px rgba(0,0,0,.55),0 0 0 1px rgba(255,255,255,0.03);font-size:13px;}
            .smart-summary-card .ss-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;}
            .smart-summary-card .ss-title-block{font-weight:600;letter-spacing:.5px;color:#e5f1ff;font-size:13px;}
            .smart-summary-card .ss-toggle{background:#18263a;color:#d2e6ff;border:1px solid #24364e;border-radius:8px;padding:4px 10px;font-size:11px;cursor:pointer;letter-spacing:.4px;transition:background .25s,border-color .25s;}
            .smart-summary-card .ss-toggle:hover{background:#203148;}
            .smart-summary-card .ss-section{margin-top:10px;}
            .smart-summary-card .ss-section-title{font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.7px;color:#86b4ff;margin-bottom:6px;}
            .smart-summary-card .ss-prob-item{background:rgba(255,90,90,.08);border:1px solid rgba(255,90,90,.25);padding:6px 8px;border-radius:8px;margin-bottom:6px;line-height:1.3;}
            .smart-summary-card .ss-prob-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-action-item{background:#152132;border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;margin-bottom:8px;}
            .smart-summary-card .ss-action-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-line-main{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:4px;}
            .smart-summary-card .ss-title{font-weight:600;color:#fff;font-size:13px;}
            .smart-summary-card .ss-stem{background:#24364e;color:#9ac9ff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-param{background:#1c2c44;color:#d6ecff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-cond{font-size:10px;background:#223347;color:#cfe8ff;padding:2px 6px;border-radius:6px;letter-spacing:.3px;}
            .smart-summary-card .ss-line-meta{display:flex;align-items:center;gap:10px;}
            .smart-summary-card .ss-why-btn{background:none;border:0;color:#53b4ff;font-size:11px;cursor:pointer;padding:0 2px;}
            .smart-summary-card .ss-why{display:none;margin-top:6px;font-size:11px;line-height:1.4;background:#101c2b;padding:6px 8px;border:1px solid rgba(255,255,255,.05);border-radius:8px;color:#c7d8eb;}
            .smart-summary-card .ss-why.open{display:block;}
            .smart-summary-card .ss-hint{margin-top:10px;font-size:10px;opacity:.55;letter-spacing:.4px;}
            .smart-summary-card .ss-empty{opacity:.6;font-size:12px;padding:4px 2px;}
            .smart-summary-card[data-collapsed='true'] .ss-content{display:none;}
            @media (max-width:560px){.smart-summary-card{padding:12px 12px;} .smart-summary-card .ss-title{font-size:12px;} }
            `;
            document.head.appendChild(st);
            // Delegated listeners
            document.addEventListener('click', (e)=>{
                const btn = e.target.closest('.ss-toggle');
                if (btn){
                    const card = btn.closest('.smart-summary-card');
                    const expanded = btn.getAttribute('data-expanded') === 'true';
                    btn.setAttribute('data-expanded', expanded? 'false':'true');
                    btn.textContent = expanded? 'Expandir':'Colapsar';
                    if (expanded) card.setAttribute('data-collapsed','true'); else card.removeAttribute('data-collapsed');
                }
                const why = e.target.closest('.ss-why-btn');
                if (why){
                    const id = why.getAttribute('data-why-target');
                    const block = document.getElementById(id);
                    if (block){ block.classList.toggle('open'); }
                }
            }, { passive:true });
        }
        return html;
    } catch (e) { console.warn('smart summary fail', e); return ''; }
}

// üéØ HELPER: Detectar se modo reference est√° ativo (corre√ß√£o definitiva)
function isReferenceCompareActive(analysis, state) {
    const hasRefJob = !!(state?.referenceJobId || analysis?.referenceComparison?.baseJobId);
    const hasRefBands = !!(
        analysis?.referenceComparison ||
        analysis?.spectralBands?.reference ||
        analysis?.bands // j√° normalizado com centraliza√ß√£o
    );
    const isSecondTrack = analysis?.mode === 'reference' && state?.isSecondTrack === true;

    return (isSecondTrack && hasRefJob) || (analysis?.mode === 'reference' && hasRefBands);
}

// üéØ HELPER: Calcular centro de um range {min, max}
function centerOfRange(range) {
    if (!range || typeof range.min !== 'number' || typeof range.max !== 'number') return null;
    return (range.min + range.max) / 2;
}

// üéØ HELPER: Formatar target (range ou valor) para exibi√ß√£o
function formatTarget(rangeOrValue) {
    if (typeof rangeOrValue === 'number') return `${rangeOrValue.toFixed(1)} dB`;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        return `${rangeOrValue.min.toFixed(1)} a ${rangeOrValue.max.toFixed(1)} dB`;
    }
    return '‚Äî';
}

// üéØ HELPER: Derivar toler√¢ncia de um range ou valor
function deriveTolerance(rangeOrValue, fallback = 2.0) {
    if (typeof rangeOrValue === 'number') return fallback;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        // 1/4 da largura do range, limitado entre 0.8 e 4.5
        const span = Math.abs(rangeOrValue.max - rangeOrValue.min);
        return Math.max(0.8, Math.min(4.5, span * 0.25));
    }
    return fallback;
}

// üéØ HELPER: Computar se tem dados necess√°rios para referenceComparisonMetrics
/**
 * üéØ FUN√á√ÉO CR√çTICA: Obter m√©tricas de compara√ß√£o ativas (modo refer√™ncia OU g√™nero)
 * 
 * Esta fun√ß√£o resolve o bug onde modo g√™nero n√£o detectava targets carregados.
 * 
 * REGRAS:
 * 1. Modo refer√™ncia: usa analysis.referenceComparisonMetrics (vem do backend)
 * 2. Modo g√™nero: usa window.__activeRefData / window.PROD_AI_REF_DATA[genre] (carregado no front)
 * 3. Nunca quebra comportamento de modo refer√™ncia existente
 * 
 * @param {Object} normalizedResult - An√°lise normalizada
 * @returns {Object|null} - M√©tricas de compara√ß√£o ou null
 */
function getActiveReferenceComparisonMetrics(normalizedResult) {
    // üî• BYPASS TOTAL: Modo g√™nero NUNCA retorna referenceComparisonMetrics
    if (SOUNDY_MODE_ENGINE.isGenre()) {
        console.log('[GENRE-BYPASS] getActiveReferenceComparisonMetrics: modo g√™nero detectado, retornando null');
        return null;
    }
    
    const mode = normalizedResult?.mode || window.__soundyState?.render?.mode || 'genre';
    const genre = normalizedResult?.genre || 
                  normalizedResult?.metadata?.genre ||
                  window.__CURRENT_GENRE || 
                  window.__soundyState?.render?.genre ||
                  window.PROD_AI_REF_GENRE;

    console.group('üîç [GENRE-FIX] getActiveReferenceComparisonMetrics');
    console.log('Mode:', mode);
    console.log('Genre:', genre);

    // 1Ô∏è‚É£ MODO REFER√äNCIA: usa o que veio do backend
    if (mode === 'reference' && normalizedResult?.referenceComparisonMetrics) {
        console.log('‚úÖ [GENRE-FIX] Usando referenceComparisonMetrics do backend (modo reference)');
        console.log('   - Fonte: backend');
        console.log('   - Tem bands:', !!normalizedResult.referenceComparisonMetrics.bands);
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    // 2Ô∏è‚É£ MODO G√äNERO: üéØ CORRE√á√ÉO CR√çTICA - Usar analysis.data.genreTargets
    if (mode === 'genre') {
        console.log('üéØ [GENRE-TARGETS] Extraindo targets da an√°lise (FONTE OFICIAL)');
        
        // üéØ PRIORIDADE 1: analysis.data.genreTargets (BACKEND OFICIAL)
        const genreTargets = extractGenreTargetsFromAnalysis(normalizedResult);
        if (genreTargets) {
            console.log('‚úÖ [GENRE-FIX] Usando analysis.data.genreTargets (modo genre - FONTE OFICIAL)');
            console.log('   - Fonte: analysis.data.genreTargets');
            console.log('   - Tem bands:', !!genreTargets.bands);
            console.log('   - Keys:', Object.keys(genreTargets));
            console.groupEnd();
            return genreTargets.referenceComparisonMetrics || genreTargets;
        }
        
        // üéØ PRIORIDADE 2 (FALLBACK): window.__activeRefData (global universal)
        if (window.__activeRefData) {
            console.warn('‚ö†Ô∏è [GENRE-FIX] FALLBACK: Usando window.__activeRefData (analysis.data.genreTargets n√£o dispon√≠vel)');
            console.log('   - Fonte: window.__activeRefData (FALLBACK)');
            console.log('   - Tem bands:', !!window.__activeRefData.bands);
            console.log('   - Tem referenceComparisonMetrics:', !!window.__activeRefData.referenceComparisonMetrics);
            console.groupEnd();
            return window.__activeRefData.referenceComparisonMetrics || window.__activeRefData;
        }
        
        // üéØ PRIORIDADE 3 (FALLBACK): window.PROD_AI_REF_DATA[genre] (dicion√°rio por g√™nero)
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            console.warn('‚ö†Ô∏è [GENRE-FIX] FALLBACK: Usando PROD_AI_REF_DATA[genre] (analysis.data.genreTargets n√£o dispon√≠vel)');
            console.log('   - Fonte: window.PROD_AI_REF_DATA[' + genre + '] (FALLBACK)');
            console.log('   - Tem bands:', !!window.PROD_AI_REF_DATA[genre].bands);
            console.groupEnd();
            const genreData = window.PROD_AI_REF_DATA[genre];
            return genreData.referenceComparisonMetrics || genreData;
        }
        
        // üéØ PRIORIDADE 4 (FALLBACK): Fallback para analysis.referenceComparisonMetrics (se existir)
        if (normalizedResult?.referenceComparisonMetrics) {
            console.warn('‚ö†Ô∏è [GENRE-FIX] FALLBACK: Usando analysis.referenceComparisonMetrics (√∫ltimo recurso)');
            console.log('   - Fonte: analysis.referenceComparisonMetrics (FALLBACK)');
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        console.error('‚ùå [GENRE-FIX] CR√çTICO: Nenhum target de g√™nero encontrado!');
        console.error('   - analysis.data.genreTargets:', !!normalizedResult?.data?.genreTargets);
        console.error('   - window.__activeRefData:', !!window.__activeRefData);
        console.error('   - window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
        console.error('   - Genre:', genre);
        console.groupEnd();
        return null;
    }

    // 3Ô∏è‚É£ FALLBACK: tentar analysis.referenceComparisonMetrics
    if (normalizedResult?.referenceComparisonMetrics) {
        console.log('‚úÖ [GENRE-FIX] Usando analysis.referenceComparisonMetrics (fallback gen√©rico)');
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    console.warn('‚ùå [GENRE-FIX] Nenhuma m√©trica de compara√ß√£o dispon√≠vel');
    console.groupEnd();
    return null;
}

function computeHasReferenceComparisonMetrics(analysis) {
    // üî• BYPASS TOTAL: Modo g√™nero NUNCA tem referenceComparisonMetrics
    if (SOUNDY_MODE_ENGINE.isGenre()) {
        console.log('[GENRE-BYPASS] computeHasReferenceComparisonMetrics: modo g√™nero detectado, retornando false');
        return false;
    }
    
    // üéØ CORRE√á√ÉO CR√çTICA: Usar getActiveReferenceComparisonMetrics() ao inv√©s de s√≥ verificar analysis
    const comparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasMetrics = !!comparisonMetrics;
    
    console.log('[GENRE-FIX] computeHasReferenceComparisonMetrics:', {
        hasMetrics,
        mode: analysis?.mode,
        hasActiveRefData: !!window.__activeRefData,
        hasProdAiRefData: !!window.PROD_AI_REF_DATA
    });
    
    return hasMetrics;
}

// --- BEGIN: band target resolver (mode-aware) ---
const BAND_NORMALIZATION_MAP = {
    // normaliza chaves heterog√™neas para um vocabul√°rio comum
    low_bass: 'bass',
    upper_bass: 'bass',
    low_mid: 'lowMid',
    high_mid: 'highMid',
    brilho: 'air',
    presenca: 'presence',
    // deixe iguais as que j√° batem:
    sub: 'sub',
    bass: 'bass',
    lowMid: 'lowMid',
    mid: 'mid',
    highMid: 'highMid',
    presence: 'presence',
    air: 'air'
};

const IGNORE_BANDS = new Set(['totalPercentage', '_status', 'total', 'metadata']);

// tenta extrair n√∫mero: aceita { value }, { db }, { rms_db }, { energy_db }, n√∫mero puro etc.
function pickNumeric(val) {
    if (val == null) return null;
    if (typeof val === 'number' && Number.isFinite(val)) return val;
    if (typeof val === 'object') {
        if (typeof val.value === 'number' && Number.isFinite(val.value)) return val.value;
        if (typeof val.db === 'number' && Number.isFinite(val.db)) return val.db;
        if (typeof val.rms_db === 'number' && Number.isFinite(val.rms_db)) return val.rms_db;
        if (typeof val.energy_db === 'number' && Number.isFinite(val.energy_db)) return val.energy_db;
    }
    return null;
}

function normalizeBandKey(k) {
    return BAND_NORMALIZATION_MAP[k] || k;
}

function getReferenceBandValue(refBands, bandKey) {
    const k = normalizeBandKey(bandKey);
    const v = refBands?.[k];
    return pickNumeric(v);
}

function getGenreTargetRange(genreTargets, bandKey) {
    const k = normalizeBandKey(bandKey);
    // Suporta {min,max} ou [min,max], e fallback para target/¬±tol
    const range = genreTargets?.[k];
    if (!range) return null;

    if (Array.isArray(range) && range.length === 2) {
        return { min: range[0], max: range[1], tol: Math.abs(range[1] - range[0]) / 4 || null };
    }
    if (typeof range === 'object') {
        if (typeof range.min === 'number' && typeof range.max === 'number') {
            return { min: range.min, max: range.max, tol: (range.tol ?? (Math.abs(range.max - range.min) / 4)) || null };
        }
        if (typeof range.target_db === 'number' && typeof range.tol_db === 'number') {
            return { min: range.target_db - range.tol_db, max: range.target_db + range.tol_db, tol: range.tol_db };
        }
        if (typeof range.target === 'number' && typeof range.tol === 'number') {
            return { min: range.target - range.tol, max: range.target + range.tol, tol: range.tol };
        }
    }
    return null;
}

function formatDb(n) {
    return (typeof n === 'number' && Number.isFinite(n)) ? `${n.toFixed(1)}dB` : '‚Äî';
}
// --- END: band target resolver (mode-aware) ---

// üß† NOVA PROTE√á√ÉO UNIVERSAL ‚Äî Refer√™ncia real > g√™nero
function resolveTargetMetric(analysis, key, fallback) {
    // 1Ô∏è‚É£ Busca no objeto da an√°lise de refer√™ncia (segunda faixa)
    if (analysis?.referenceAnalysis?.technicalData?.[key] !== undefined) {
        console.log(`üéØ [RESOLVE] ${key} encontrado em referenceAnalysis:`, analysis.referenceAnalysis.technicalData[key]);
        return analysis.referenceAnalysis.technicalData[key];
    }
    
    // 2Ô∏è‚É£ Busca no objeto da pr√≥pria an√°lise (se comparando com si mesma)
    if (analysis?.technicalData?.[key] !== undefined) {
        console.log(`üéØ [RESOLVE] ${key} encontrado em technicalData:`, analysis.technicalData[key]);
        return analysis.technicalData[key];
    }
    
    // 3Ô∏è‚É£ Busca no g√™nero (estrutura antiga)
    const targetKey = `${key}_target`;
    if (analysis?.referenceComparison?.[targetKey] !== undefined) {
        console.log(`üéØ [RESOLVE] ${key} encontrado em referenceComparison.${targetKey}:`, analysis.referenceComparison[targetKey]);
        return analysis.referenceComparison[targetKey];
    }
    
    // 4Ô∏è‚É£ Fallback seguro
    console.log(`üõ°Ô∏è [RESOLVE] ${key} usando fallback:`, fallback);
    return fallback ?? 0;
}

// üßÆ PARTE 3.1: Fun√ß√£o de normaliza√ß√£o para estrutura de refer√™ncia
function normalizeReferenceShape(a) {
  if (!a) return {};
  return {
    fileName: a.fileName || a.metadata?.fileName || "Faixa desconhecida",
    bands: a.bands || a.spectralBands,
    lufsIntegrated: a.loudness?.integrated ?? a.lufsIntegrated,
    truePeakDbtp: a.truePeak?.dbtp ?? a.truePeakDbtp,
    dynamicRange: a.dynamics?.dr ?? a.dynamicRange,
    lra: a.loudness?.range ?? a.lra,
    crestFactor: a.dynamics?.crest ?? a.crestFactor
  };
}

// üîí Global render lock para evitar ReferenceError
if (typeof window.comparisonLock === "undefined") {
    window.comparisonLock = false;
    console.log("[LOCK-INIT] comparisonLock inicializado como false");
}

// --- BEGIN: deterministic mode gate ---
function renderReferenceComparisons(ctx) {
    // ========================================
    // üéØ PASSO 0: GUARD - APENAS PARA MODO REFER√äNCIA
    // ========================================
    if (!SOUNDY_MODE_ENGINE.isReferenceCompare()) {
        console.log('[RENDER-REF] ‚è≠Ô∏è Modo n√£o √© refer√™ncia - abortando');
        return;
    }
    
    // üõ°Ô∏è PATCH 3: GUARD ADICIONAL - Se for modo g√™nero, n√£o renderizar A/B
    const analysisCheck = ctx?.userAnalysis || ctx?.user;
    if (analysisCheck?.mode === 'genre') {
        console.log('[RENDER-REF] üéØ Modo g√™nero detectado - deve usar renderGenreComparisonTable');
        console.warn('[RENDER-REF] ‚ö†Ô∏è Esta fun√ß√£o n√£o deve ser chamada para modo g√™nero!');
        return; // Modo g√™nero deve usar renderGenreComparisonTable
    }
    
    // ========================================
    // üéØ PASSO 1: VALIDAR DADOS DO STORE SE DISPON√çVEL (MODO REFERENCE)
    // ========================================
    console.group('üéØ [RENDER-REF] VALIDA√á√ÉO DE FONTE DE DADOS');
    
    if (ctx?._useStoreData) {
        console.log('‚úÖ [STORE-MODE] Renderiza√ß√£o usando dados do store isolado');
        console.log('   - userAnalysis.jobId:', ctx.userAnalysis?.jobId);
        console.log('   - referenceAnalysis.jobId:', ctx.referenceAnalysis?.jobId);
        
        // Valida√ß√£o de integridade do store
        if (window.SoundyAI_Store?.first && window.SoundyAI_Store?.second) {
            console.table({
                refJobId: window.SoundyAI_Store.first?.jobId,
                currJobId: window.SoundyAI_Store.second?.jobId,
                refName: window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName,
                currName: window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName,
                sameJob: window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId,
                sameName: (window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName) === 
                          (window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName)
            });
            
            // üö® VALIDA√á√ÉO CR√çTICA: Store N√ÉO pode ter jobIds iguais
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('üö® [STORE-ERROR] STORE CONTAMINADO!');
                console.error('   - Store tem jobIds id√™nticos');
                console.trace();
                console.groupEnd();
                alert('ERRO: Store contaminado detectado. Por favor, recarregue a p√°gina.');
                return;
            }
            
            console.log('‚úÖ [STORE-VALIDATED] Store validado - dados isolados confirmados');
        } else {
            console.warn('‚ö†Ô∏è [STORE-WARN] Store n√£o est√° completo');
            console.log('   - Caindo para modo legado');
        }
    } else {
        console.log('‚ö†Ô∏è [LEGACY-MODE] Renderiza√ß√£o usando sistema legado');
        console.log('   - Dados n√£o v√™m do store isolado');
    }
    
    console.groupEnd();
    
    // ========================================
    // üö® VALIDA√á√ÉO CR√çTICA NO IN√çCIO: Tentar recuperar jobIds corretos se necess√°rio
    // ========================================
    let userJobId = ctx?.userAnalysis?.jobId || ctx?.user?.jobId;
    let refJobId = ctx?.referenceAnalysis?.jobId || ctx?.ref?.jobId;
    
    console.group('üéØ [RENDER-REF] Iniciando renderiza√ß√£o com valida√ß√£o');
    console.log('   userJobId recebido:', userJobId);
    console.log('   refJobId recebido:', refJobId);
    console.log('   S√£o iguais?', userJobId === refJobId);
    
    // Se recebeu jobIds iguais, TENTA RECUPERAR os corretos
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('‚ùå [RENDER-REF] ERRO: Recebeu jobIds iguais!');
        console.error('   Tentando recuperar jobIds corretos com getCorrectJobId()...');
        
        // RECUPERA os jobIds corretos
        const recoveredCurrentJobId = getCorrectJobId('current');
        const recoveredReferenceJobId = getCorrectJobId('reference');
        
        console.log('üîÑ [RENDER-REF] JobIds recuperados:');
        console.log('   Novo userJobId (current):', recoveredCurrentJobId);
        console.log('   Novo refJobId (reference):', recoveredReferenceJobId);
        console.log('   Recuperados s√£o diferentes?', recoveredCurrentJobId !== recoveredReferenceJobId);
        
        // Se AINDA forem iguais, ABORTA
        if (recoveredCurrentJobId === recoveredReferenceJobId) {
            console.error('‚ùå [RENDER-REF] FALHA NA RECUPERA√á√ÉO!');
            console.error('   Mesmo ap√≥s getCorrectJobId(), os jobIds s√£o iguais');
            console.trace();
            console.groupEnd();
            alert('ERRO: N√£o foi poss√≠vel carregar a compara√ß√£o. Os jobIds s√£o iguais. Recarregue a p√°gina.');
            return;
        }
        
        console.log('‚úÖ [RENDER-REF] JobIds recuperados com sucesso!');
        console.log('   Atualizando userJobId e refJobId no contexto...');
        
        // Atualizar jobIds no contexto
        userJobId = recoveredCurrentJobId;
        refJobId = recoveredReferenceJobId;
        
        // Atualizar tamb√©m no ctx se poss√≠vel
        if (ctx?.userAnalysis) ctx.userAnalysis.jobId = userJobId;
        if (ctx?.referenceAnalysis) ctx.referenceAnalysis.jobId = refJobId;
        if (ctx?.user) ctx.user.jobId = userJobId;
        if (ctx?.ref) ctx.ref.jobId = refJobId;
    } else {
        console.log('‚úÖ [RENDER-REF] JobIds j√° s√£o diferentes - continuando normalmente');
    }
    
    console.groupEnd();
    
    // ========================================
    // üö® VALIDA√á√ÉO CR√çTICA: NUNCA COMPARAR MESMA M√öSICA (valida√ß√£o original mantida)
    // ========================================
    console.group('üö® [RENDER-VALIDATION] Valida√ß√£o cr√≠tica de jobIds');
    console.log('   - userJobId (ap√≥s poss√≠vel recupera√ß√£o):', userJobId);
    console.log('   - refJobId (ap√≥s poss√≠vel recupera√ß√£o):', refJobId);
    console.log('   - S√£o iguais?', userJobId === refJobId);
    
    // VALIDA√á√ÉO CR√çTICA: Se jobIds s√£o iguais, ABORTAR renderiza√ß√£o
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('‚ùå [RENDER] ERRO CR√çTICO: Tentando comparar mesma m√∫sica!');
        console.error('   userJobId:', userJobId);
        console.error('   refJobId:', refJobId);
        console.trace();
        
        // Tenta recuperar o jobId correto da segunda m√∫sica
        const recoveredJobId = getCorrectJobId('current'); // Segunda m√∫sica
        const firstJobId = getCorrectJobId('reference'); // Primeira m√∫sica
        
        console.log('üîÑ [RENDER] Tentando recuperar jobIds corretos:');
        console.log('   - Recovered currentJobId:', recoveredJobId);
        console.log('   - Recovered referenceJobId:', firstJobId);
        
        if (recoveredJobId && firstJobId && recoveredJobId !== firstJobId) {
            console.warn('‚ö†Ô∏è [RENDER] JobIds recuperados - reconstruindo ctx');
            // Reconstruir ctx com jobIds corretos
            // Por ora, ABORTAR para evitar renderiza√ß√£o incorreta
            alert('ERRO: N√£o foi poss√≠vel carregar a compara√ß√£o corretamente. Por favor, recarregue a p√°gina e tente novamente.');
            console.groupEnd();
            return;
        } else {
            console.error('‚ùå [RENDER] N√£o foi poss√≠vel recuperar jobIds corretos');
            alert('ERRO CR√çTICO: Compara√ß√£o inv√°lida detectada. Recarregue a p√°gina.');
            console.groupEnd();
            return;
        }
    }
    
    console.log('‚úÖ [RENDER-VALIDATION] JobIds s√£o diferentes - continuando renderiza√ß√£o');
    console.groupEnd();
    
    // ========================================
    // ‚úÖ CORRE√á√ÉO 3: Padroniza√ß√£o de chamada e valida√ß√£o de ctx
    // ========================================
    // Normalizar ctx para aceitar objeto { mode, user, ref }
    const mode = ctx?.mode || window.currentAnalysisMode || 'genre';
    const user = ctx?.user || ctx?.userAnalysis || window._lastUserAnalysis || {};
    const refData = ctx?.ref || ctx?.referenceAnalysis || window.referenceAnalysisData || {};

    // HARD-GUARD: sem bands? n√£o renderiza A/B para evitar self-compare
    if (mode === 'reference') {
        if (!refData?.bands || !user?.bands) {
            console.warn('[A/B-SKIP] bands ausentes (user/ref). Evitando self-compare.');
            console.warn('[SUG-AUDIT][REFERENCE] ‚ö†Ô∏è Modo reference mas sem bandas - pode afetar suggestions');
            return;
        }
        
        // ‚úÖ AUDITORIA: Verificar se suggestions est√£o presentes
        console.log('[SUG-AUDIT][REFERENCE] Dados recebidos:', {
            userHasSuggestions: Array.isArray(user?.suggestions),
            userSuggestionsLength: user?.suggestions?.length || 0,
            refHasSuggestions: Array.isArray(refData?.suggestions),
            refSuggestionsLength: refData?.suggestions?.length || 0
        });
    }

    // Atualizar opts para compatibilidade com c√≥digo existente
    const opts = {
        mode: mode,
        userAnalysis: user,
        referenceAnalysis: refData,
        ...ctx // Mesclar propriedades adicionais de ctx
    };

    // ========================================
    // üõ°Ô∏è BLOQUEIO DEFINITIVO DE SELF-COMPARE POR CONTE√öDO
    // ========================================
    // Recuperar faixas do FirstAnalysisStore usando pap√©is (USER/REF)
    const userFromStore = FirstAnalysisStore.getUser();
    const refFromStore = FirstAnalysisStore.getRef();
    
    if (!userFromStore?.bands || !refFromStore?.bands) {
        console.warn('[AB-BLOCK] ‚ö†Ô∏è Bands ausentes - abortando A/B');
        return;
    }
    
    // Detectar self-compare por m√∫ltiplos crit√©rios de conte√∫do
    const samePointer = userFromStore === refFromStore;
    const sameJobId = userFromStore?.jobId && refFromStore?.jobId && userFromStore.jobId === refFromStore.jobId;
    const sameFile = userFromStore?.metadata?.fileKey && refFromStore?.metadata?.fileKey && 
                     userFromStore.metadata.fileKey === refFromStore.metadata.fileKey;
    const sameHash = userFromStore?.objectId?.hash && refFromStore?.objectId?.hash && 
                     userFromStore.objectId.hash === refFromStore.objectId.hash;
    
    if (samePointer || sameJobId || sameFile || sameHash) {
        console.error('[AB-BLOCK] ‚ùå Self-compare detectado - abortando tabela A/B:', {
            samePointer,
            sameJobId: sameJobId ? `${userFromStore.jobId}` : false,
            sameFile: sameFile ? `${userFromStore.metadata.fileKey}` : false,
            sameHash: sameHash ? `${userFromStore.objectId.hash}` : false,
            userVid: window.CacheIndex.USER,
            refVid: window.CacheIndex.REF,
            userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
            refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName
        });
        return; // Aborta renderiza√ß√£o A/B
    }
    
    // ‚úÖ Valida√ß√£o passou - s√£o faixas diferentes
    console.log('[AB-SAFETY] ‚úÖ Faixas validadas como diferentes:', {
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
        refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName,
        userJobId: userFromStore?.jobId,
        refJobId: refFromStore?.jobId
    });
    
    // üéØ [STORE-PRIORITY-FIX] PRIORIDADE ABSOLUTA: SoundyAI_Store > FirstAnalysisStore
    console.log('üéØ [STORE-PRIORITY-FIX] Verificando prioridade de fonte de dados...');
    
    // Verificar se SoundyAI_Store tem ambas an√°lises
    const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
    
    let finalUserAnalysis, finalReferenceAnalysis;
    
    if (storeHasBoth) {
        console.log('‚úÖ [STORE-PRIORITY-FIX] Usando SoundyAI_Store (prioridade m√°xima)');
        finalUserAnalysis = window.SoundyAI_Store.first;
        finalReferenceAnalysis = window.SoundyAI_Store.second;
        
        console.table({
            'Fonte': 'SoundyAI_Store',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId,
            'User LUFS': finalUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': finalReferenceAnalysis?.technicalData?.lufsIntegrated,
            'User DR': finalUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': finalReferenceAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': finalUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': finalReferenceAnalysis?.technicalData?.truePeakDbtp
        });
    } else {
        console.warn('‚ö†Ô∏è [STORE-PRIORITY-FIX] SoundyAI_Store incompleto, usando FirstAnalysisStore (fallback)');
        finalUserAnalysis = userFromStore;
        finalReferenceAnalysis = refFromStore;
        
        console.table({
            'Fonte': 'FirstAnalysisStore (fallback)',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId
        });
    }
    
    // Usar as faixas priorizadas (SoundyAI_Store > FirstAnalysisStore)
    opts.userAnalysis = finalUserAnalysis;
    opts.referenceAnalysis = finalReferenceAnalysis;
    
    // ========================================
    // üîß DETEC√á√ÉO SEGURA DE SELF-COMPARE (AP√ìS AB-SAFETY)
    // ========================================
    // Agora que temos os dados validados, detectar self-compare com crit√©rios rigorosos
    const refAnalysis = opts.referenceAnalysis;
    const currAnalysis = opts.userAnalysis;
    
    const sameJob = !!(refAnalysis?.jobId && currAnalysis?.jobId && refAnalysis.jobId === currAnalysis.jobId);
    const sameVid = !!(refAnalysis?.vid && currAnalysis?.vid && refAnalysis.vid === currAnalysis.vid);
    const sameFileName = !!(refAnalysis?.fileName && currAnalysis?.fileName && refAnalysis.fileName === currAnalysis.fileName);
    const refVid = window.CacheIndex?.REF;
    const userVid = window.CacheIndex?.USER;
    
    // S√≥ marca como selfCompare se TODAS as checagens coincidirem
    let selfCompare = false;
    if (sameJob && sameVid && sameFileName) {
        selfCompare = true;
        console.warn('[REF-GUARD] ‚ö†Ô∏è Self-compare detectado (todos crit√©rios):', { sameJob, sameVid, sameFileName });
    }
    
    // ‚úÖ REVALIDA√á√ÉO: Limpar flag se for falso positivo
    // Se VIDs ou files s√£o diferentes, n√£o pode ser self-compare
    if (selfCompare && (userVid !== refVid || 
        (refAnalysis?.fileName || refAnalysis?.metadata?.fileName) !== (currAnalysis?.fileName || currAnalysis?.metadata?.fileName))) {
        console.warn('[REF-GUARD] ‚ùé Corrigido selfCompare falso-positivo ap√≥s AB-SAFETY:', {
            userVid,
            refVid,
            userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
            refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
        });
        selfCompare = false;
    }
    
    // Marcar no opts para uso posterior
    opts.isSelfCompare = selfCompare;
    
    console.log('[SELF-COMPARE-FINAL] Decis√£o final:', {
        selfCompare,
        sameJob,
        sameVid,
        sameFileName,
        userVid,
        refVid,
        userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
        refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
    });
    
    // ==== STEP 3/6: refHardGuards() simplificado ====
    const guardResult = (function refHardGuards(){
        const s = window.__soundyState || {};
        
        if (!opts.userAnalysis || !opts.referenceAnalysis) {
            console.error("[REF-PATCH] Faltam dados pra A/B");
            return { abort: true, reason: 'missing-data' };
        }

        opts.usedReferenceAnalysis = true;

        if (window.__refRenderInProgress) {
            console.warn("[REF-PATCH] Render A/B em progresso ‚Äî ignorando duplicado");
            return { abort: true, reason: 'render-in-progress' };
        }
        window.__refRenderInProgress = true;
        
        return { abort: false };
    })();
    
    // ‚úÖ STEP 3/6: Tratar retorno de refHardGuards()
    if (guardResult && guardResult.abort) {
        console.warn(`[REF-GUARD] Abortando renderReferenceComparisons: ${guardResult.reason}`);
        return;
    }
    
    // ÔøΩ [AUDIT-BANDS-IN-RENDER] Log NO IN√çCIO da fun√ß√£o renderReferenceComparisons
    try {
        const refBandsInRender = opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance;
        const userBandsInRender = opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance;
        console.log('[AUDIT-BANDS-IN-RENDER]', {
            receivedRefBands: refBandsInRender,
            receivedUserBands: userBandsInRender,
            typeofRefBands: typeof refBandsInRender,
            typeofUserBands: typeof userBandsInRender,
            refBandsKeys: refBandsInRender ? Object.keys(refBandsInRender) : [],
            userBandsKeys: userBandsInRender ? Object.keys(userBandsInRender) : [],
            optsKeys: Object.keys(opts),
            hasUserAnalysis: !!opts.userAnalysis,
            hasReferenceAnalysis: !!opts.referenceAnalysis
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-RENDER', err);
    }
    
    // ÔøΩüîí PROTE√á√ÉO ANTI-DUPLICA√á√ÉO: Detectar se faixas s√£o id√™nticas
    if (opts.userAnalysis?.fileName && opts.referenceAnalysis?.fileName &&
        opts.userAnalysis.fileName === opts.referenceAnalysis.fileName) {
        console.error("‚ùå [REF-DUPE] Detec√ß√£o de duplica√ß√£o ‚Äî refer√™ncia sobrescrita!");
        console.table({
            userTrack: opts.userAnalysis?.fileName,
            refTrack: opts.referenceAnalysis?.fileName,
        });
        return; // aborta renderiza√ß√£o duplicada
    }
    
    // üß© Controle seguro de renderiza√ß√£o
    if (window.comparisonLock) {
        console.warn("[LOCK] Renderiza√ß√£o de compara√ß√£o ignorada (lock ativo)");
        return;
    }
    
    // [AUDIT-FLOW] Log ANTES do lock
    console.log("[AUDIT-FLOW] üîç ANTES do lock:", {
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    window.comparisonLock = true;
    console.log("[LOCK] comparisonLock ativado");
    
    // [AUDIT-FLOW] Log DEPOIS do lock
    console.log("[AUDIT-FLOW] üîç DEPOIS do lock:", {
        comparisonLock: window.comparisonLock,
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    // üîß PARTE 2: Prote√ß√£o em renderReferenceComparisons
    const globalState = window.__soundyState || {};
    const refStateCheck = globalState?.reference || {};
    const userCheck = refStateCheck.userAnalysis || opts.userAnalysis;
    const refCheck = refStateCheck.referenceAnalysis || opts.referenceAnalysis;

    if (!userCheck || !refCheck) {
        console.warn("[REF-COMP] Faltam dados de refer√™ncia ou usu√°rio, usando fallback seguro");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (fallback)");
        return renderGenreComparisonSafe?.();
    }

    const userTrackCheck = userCheck.fileName || userCheck.metadata?.fileName || "Faixa 1 (usu√°rio)";
    const refTrackCheck = refCheck.fileName || refCheck.metadata?.fileName || "Faixa 2 (refer√™ncia)";
    const userBandsCheck = userCheck.bands || userCheck.technicalData?.spectral_balance || {};
    const refBandsCheck = refCheck.bands || refCheck.technicalData?.spectral_balance || {};

    const userBandsCountCheck = userBandsCheck ? Object.keys(userBandsCheck).length : 0;
    const refBandsCountCheck = refBandsCheck ? Object.keys(refBandsCheck).length : 0;
    
    if (refBandsCountCheck === 0) {
        console.warn("[REF-COMP] referenceBands ausentes - fallback para valores brutos");
    }

    console.log("[REF-COMP] Dados validados:", { 
        userTrackCheck, 
        refTrackCheck, 
        userBandsCount: userBandsCountCheck, 
        refBandsCount: refBandsCountCheck,
        userBandsKeys: userBandsCheck ? Object.keys(userBandsCheck) : [],
        refBandsKeys: refBandsCheck ? Object.keys(refBandsCheck) : []
    });
    
    // üß© [FINAL-FIX] Valida√ß√£o real das bandas antes de renderizar
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (container ausente)");
        return;
    }
    
    // üîß CORRE√á√ÉO CR√çTICA: Removido __REF_RENDER_LOCK__ que bloqueava segunda chamada leg√≠tima
    // A valida√ß√£o de dados abaixo √© suficiente para prevenir renders incompletos
    console.log("[LOCK-FIX] ‚úÖ Permitindo render com valida√ß√£o de dados (lock duplicado removido)");
    
    // Aceita opts ou analysis (backward compatibility)
    const finalAnalysis = opts.analysis || opts;
    let comparisonData = opts?.comparisonData || {};
    
    const refBandsReal =
        comparisonData?.refBands ||
        comparisonData?.referenceAnalysis?.bands ||
        comparisonData?.referenceAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.referenceAnalysis?.bands ||
        window.__soundyState?.reference?.referenceAnalysis?.technicalData?.spectral_balance;

    const userBandsReal =
        comparisonData?.userBands ||
        comparisonData?.userAnalysis?.bands ||
        comparisonData?.userAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.userAnalysis?.bands ||
        window.__soundyState?.reference?.userAnalysis?.technicalData?.spectral_balance;

    console.log('[VALIDATION-FIX] Verificando bandas:', {
        refBandsRealKeys: refBandsReal ? Object.keys(refBandsReal) : null,
        userBandsRealKeys: userBandsReal ? Object.keys(userBandsReal) : null,
    });

    if (!refBandsReal || !userBandsReal) {
        console.error('[VALIDATION-FIX] ‚ùå Falha cr√≠tica: bandas n√£o detectadas no momento do render.');
        console.error('comparisonData:', comparisonData);
        console.error('window.__soundyState:', window.__soundyState);
        window.comparisonLock = false;
        if (typeof displayModalResultsError === 'function') {
            return displayModalResultsError('Erro na an√°lise por refer√™ncia (bandas n√£o detectadas).');
        }
        return;
    }

    // ‚úÖ Substitui o fallback antigo
    comparisonData.refBands = refBandsReal;
    comparisonData.userBands = userBandsReal;
    console.log('[VALIDATION-FIX] ‚úÖ Bandas restauradas para renderiza√ß√£o A/B');
    
    // üß† [SAFE_REF_V3] PATCH DEFINITIVO - Construir estrutura segura ANTES de qualquer acesso
    console.groupCollapsed("üß† [SAFE_REF_V3]");
    console.log("üì¶ opts recebido:", opts);
    
    // üîê Obter state global
    const stateV3 = window.__soundyState || {};
    
    // üîê Obter an√°lises primeiro
    const ua = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
    const ra = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
    
    // üîê Construir compara√ß√£o segura com m√∫ltiplas fontes
    let comparisonBase = 
        opts?.comparisonData || 
        window?.comparisonData || 
        window?.lastComparisonData || 
        {};
    
    // üéØ SEM√ÇNTICA CORRETA:
    // - userTrack = 1¬™ faixa (SUA M√öSICA/ATUAL) = userAnalysis
    // - referenceTrack = 2¬™ faixa (REFER√äNCIA/ALVO) = referenceAnalysis
    let comparisonSafe;
    
    if (!comparisonBase.userTrack || !comparisonBase.referenceTrack) {
        console.warn("‚ö†Ô∏è [SAFE_REF_V3] comparisonData incompleto ‚Äî tentando reconstruir via an√°lises");
        
        comparisonSafe = {
            userTrack: ua?.metadata?.fileName || ua?.fileName || "1¬™ Faixa (Sua M√∫sica/Atual)",
            referenceTrack: ra?.metadata?.fileName || ra?.fileName || "2¬™ Faixa (Refer√™ncia/Alvo)",
            userBands: 
                ua?.technicalData?.spectral_balance || 
                ua?.bands || 
                ua?.spectralBands || 
                null,
            refBands: 
                ra?.technicalData?.spectral_balance || 
                ra?.bands || 
                ra?.spectralBands || 
                null,
        };
    } else {
        comparisonSafe = comparisonBase;
    }
    
    // üîç [AUDIT-BANDS-SAFE-V3] Log AP√ìS constru√ß√£o de comparisonSafe
    try {
        console.log('[AUDIT-BANDS-SAFE-V3]', {
            comparisonSafeUserBands: comparisonSafe.userBands,
            comparisonSafeRefBands: comparisonSafe.refBands,
            typeofUserBands: typeof comparisonSafe.userBands,
            typeofRefBands: typeof comparisonSafe.refBands,
            userBandsKeys: comparisonSafe.userBands ? Object.keys(comparisonSafe.userBands) : [],
            refBandsKeys: comparisonSafe.refBands ? Object.keys(comparisonSafe.refBands) : [],
            sourceUA: ua ? 'opts.userAnalysis ou state.reference.userAnalysis' : 'N/A',
            sourceRA: ra ? 'opts.referenceAnalysis ou state.reference.referenceAnalysis' : 'N/A',
            uaBands: ua?.technicalData?.spectral_balance || ua?.bands || ua?.spectralBands,
            raBands: ra?.technicalData?.spectral_balance || ra?.bands || ra?.spectralBands
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-SAFE-V3', err);
    }
    
    // Guardar globalmente (backup)
    window.lastComparisonData = comparisonSafe;
    
    // üß© Substituir opts.comparisonData quebrado
    opts.comparisonData = comparisonSafe;
    
    // üîí Fallback hard caso ainda venha undefined
    if (!comparisonSafe.referenceTrack) {
        comparisonSafe.referenceTrack = 
            opts?.referenceAnalysis?.metadata?.fileName || 
            opts?.referenceAnalysis?.fileName ||
            stateV3?.reference?.referenceAnalysis?.metadata?.fileName || 
            "2¬™ Faixa (Refer√™ncia/Alvo)";
    }
    if (!comparisonSafe.userTrack) {
        comparisonSafe.userTrack = 
            opts?.userAnalysis?.metadata?.fileName || 
            opts?.userAnalysis?.fileName ||
            stateV3?.reference?.userAnalysis?.metadata?.fileName || 
            "1¬™ Faixa (Sua M√∫sica/Atual)";
    }
    
    console.log("‚úÖ [SAFE_REF_V3] Estrutura final reconstru√≠da:", comparisonSafe);
    console.groupEnd();
    

    //  [PATCH V5] SCOPE GUARD DEFINITIVO - Sincroniza√ß√£o final antes de usar dados
    console.groupCollapsed(" [REF_FIX_V5]");
    let userTrack, referenceTrack;
    try {
        //  Verifica e sincroniza escopo de comparisonData
        // üéØ SEM√ÇNTICA CORRETA:
        // - userTrack = 1¬™ faixa (SUA M√öSICA/ATUAL) = userAnalysis
        // - referenceTrack = 2¬™ faixa (REFER√äNCIA/ALVO) = referenceAnalysis
        let comparisonData =
            opts?.comparisonData ||
            window?.comparisonData ||
            window?.lastComparisonData ||
            stateV3?.reference?.comparisonData ||
            comparisonSafe || // Usar comparisonSafe do Patch V3 como fallback
            {
                userTrack:
                    opts?.userAnalysis?.metadata?.fileName ||
                    opts?.userAnalysis?.fileName ||
                    stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                    "Sua M√∫sica (Atual)",
                referenceTrack:
                    opts?.referenceAnalysis?.metadata?.fileName ||
                    opts?.referenceAnalysis?.fileName ||
                    stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                    "Faixa de Refer√™ncia (Alvo)",
                userBands:
                    opts?.userAnalysis?.technicalData?.spectral_balance ||
                    opts?.userAnalysis?.bands ||
                    stateV3?.reference?.userAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.userAnalysis?.bands ||
                    {},
                refBands:
                    opts?.referenceAnalysis?.technicalData?.spectral_balance ||
                    opts?.referenceAnalysis?.bands ||
                    stateV3?.reference?.referenceAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.referenceAnalysis?.bands ||
                    {},
            };

        // üß© FIX: Preservar bandas v√°lidas antes da redeclara√ß√£o
        if (comparisonData) {
            // Se j√° houver bandas v√°lidas em comparisonSafe, preservar
            if (!comparisonData.refBands && comparisonSafe?.refBands) {
                comparisonData.refBands = comparisonSafe.refBands;
            }
            if (!comparisonData.userBands && comparisonSafe?.userBands) {
                comparisonData.userBands = comparisonSafe.userBands;
            }
            
            // Fallback adicional para opts se comparisonData ainda vazio
            if (!comparisonData.refBands && opts?.referenceAnalysis) {
                comparisonData.refBands =
                    opts.referenceAnalysis.bands ||
                    opts.referenceAnalysis.technicalData?.spectral_balance ||
                    window.__lastRefBands ||
                    {};
            }
            if (!comparisonData.userBands && opts?.userAnalysis) {
                comparisonData.userBands =
                    opts.userAnalysis.bands ||
                    opts.userAnalysis.technicalData?.spectral_balance ||
                    window.__lastUserBands ||
                    {};
            }
        }

        //  Atualiza refer√™ncias globais
        window.comparisonData = comparisonData;
        window.lastComparisonData = comparisonData;
        opts.comparisonData = comparisonData;

        //  Cria vari√°veis locais seguras com fallback robusto
        // üéØ SEM√ÇNTICA CORRETA DOS NOMES:
        userTrack = comparisonData?.userTrack || "Sua M√∫sica (Atual)";
        referenceTrack = comparisonData?.referenceTrack || "Faixa de Refer√™ncia (Alvo)";
        
        // ‚ö° Fallback em cascata para garantir bandas v√°lidas (incluindo persist√™ncia global)
        const localRefBands =
            window.__lastRefBands ||
            comparisonData?.refBands ||
            comparisonSafe?.refBands ||
            opts?.referenceAnalysis?.bands ||
            opts?.referenceAnalysis?.technicalData?.spectral_balance ||
            {};
        
        const localUserBands =
            window.__lastUserBands ||
            comparisonData?.userBands ||
            comparisonSafe?.userBands ||
            opts?.userAnalysis?.bands ||
            opts?.userAnalysis?.technicalData?.spectral_balance ||
            {};
        
        // [REF-COMP] ‚úÖ Persistir bandas globalmente para uso posterior
        if (localRefBands && Object.keys(localRefBands).length > 0) window.__lastRefBands = localRefBands;
        if (localUserBands && Object.keys(localUserBands).length > 0) window.__lastUserBands = localUserBands;
        
        console.log('[REF-COMP][BANDS-FINAL-FIX] Estado de bandas ap√≥s fallback:', {
            hasRefBands: !!localRefBands && Object.keys(localRefBands).length > 0,
            hasUserBands: !!localUserBands && Object.keys(localUserBands).length > 0,
            refKeys: localRefBands ? Object.keys(localRefBands) : [],
            userKeys: localUserBands ? Object.keys(localUserBands) : []
        });

        // üîç [AUDIT-REDECLARE] Log AP√ìS redeclara√ß√£o de vari√°veis
        try {
            console.log('[AUDIT-REDECLARE]', {
                refBandsCheck: localRefBands,
                userBandsCheck: localUserBands,
                typeofRefBands: typeof localRefBands,
                typeofUserBands: typeof localUserBands,
                refBandsKeys: localRefBands ? Object.keys(localRefBands) : [],
                userBandsKeys: localUserBands ? Object.keys(localUserBands) : [],
                refBandsIsEmpty: !localRefBands || Object.keys(localRefBands).length === 0,
                userBandsIsEmpty: !localUserBands || Object.keys(localUserBands).length === 0,
                comparisonDataRefBands: comparisonData?.refBands,
                comparisonDataUserBands: comparisonData?.userBands
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'AUDIT-REDECLARE', err);
        }

        console.log(" [REF_FIX_V5] Estrutura estabilizada:", {
            userTrack,
            referenceTrack,
            userBands: !!Object.keys(localUserBands || {}).length,
            refBands: !!Object.keys(localRefBands || {}).length,
        });

        //  Abortagem segura se algo vier undefined
        if (!referenceTrack || !userTrack) {
            console.error(" [REF_FIX_V5] referenceTrack ou userTrack ausentes!");
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (track ausente)");
            console.groupEnd();
            return;
        }

        //  Reatribui localmente para garantir escopo
        opts.referenceTrack = referenceTrack;
        opts.userTrack = userTrack;
        comparisonData.referenceTrack = referenceTrack;
        comparisonData.userTrack = userTrack;
    } catch (err) {
        console.error(" [REF_FIX_V5] Erro cr√≠tico de escopo:", err);
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (erro cr√≠tico)");
        console.groupEnd();
        return;
    }
    console.groupEnd();
    
    // üßÆ PARTE 3.2: Valida√ß√£o e normaliza√ß√£o de an√°lises
    const sRef = stateV3?.reference || {};
    const userAnalysis = opts.userAnalysis ?? sRef.userAnalysis;
    const referenceAnalysis = opts.referenceAnalysis ?? sRef.referenceAnalysis;

    if (!userAnalysis || !referenceAnalysis) {
        console.warn("[REF-COMP] Faltam an√°lises; usando fallback controlado.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (an√°lises ausentes)");
        return renderGenreComparisonSafe?.();
    }

    // üéØ SEM√ÇNTICA CORRETA DOS NOMES:
    // - userAnalysis = 1¬™ faixa = SUA M√öSICA (atual)
    // - referenceAnalysis = 2¬™ faixa = REFER√äNCIA (alvo a alcan√ßar)
    const userTrackNormalized = userAnalysis.fileName || userAnalysis.metadata?.fileName || sRef.userTrack || "Sua M√∫sica (Atual)";
    const refTrackNormalized = referenceAnalysis.fileName || referenceAnalysis.metadata?.fileName || sRef.referenceTrack || "Faixa de Refer√™ncia (Alvo)";
    
    // üîç AUDITORIA ANTI-DUPLICA√á√ÉO: Verificar se as faixas s√£o distintas
    console.log('üîç [AUDIT_REF_MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üîç [AUDIT_REF_MODE ‚úÖ] Valida√ß√£o de faixas distintas:');
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   userTrack (SUA M√öSICA):', userTrackNormalized);
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   referenceTrack (REFER√äNCIA):', refTrackNormalized);
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   S√£o id√™nticas?', userTrackNormalized === refTrackNormalized ? '‚ö†Ô∏è SIM - VERIFICAR FLUXO!' : '‚úÖ N√ÉO');
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   userAnalysis jobId:', userAnalysis?.jobId);
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   referenceAnalysis jobId:', referenceAnalysis?.jobId);
    console.log('üîç [AUDIT_REF_MODE ‚úÖ]   JobIds id√™nticos?', userAnalysis?.jobId === referenceAnalysis?.jobId ? '‚ö†Ô∏è SIM - VERIFICAR!' : '‚úÖ N√ÉO');
    console.log('üîç [AUDIT_REF_MODE ‚úÖ] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    if (userTrackNormalized === refTrackNormalized) {
        console.warn("‚ö†Ô∏è [REF-COMP] As duas faixas t√™m o mesmo nome ‚Äî verifique o fluxo de atribui√ß√£o!");
        console.warn("‚ö†Ô∏è [REF-COMP] Dados recebidos:", {
            userAnalysis: userAnalysis,
            referenceAnalysis: referenceAnalysis
        });
    }
    
    // Evita leitura em escopos errados - ABORT se referenceTrack undefined
    if (!referenceTrack) {
        console.error("üö® [SAFE_REF_V3] referenceTrack ainda undefined! Abortando render seguro.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (referenceTrack undefined)");
        return;
    }
    
    // ‚úÖ LOG PARA CONFIRMA√á√ÉO FINAL
    console.log("[REF-COMPARE ‚úÖ] Dire√ß√£o correta confirmada: PRIMEIRA = sua m√∫sica (atual), SEGUNDA = refer√™ncia (alvo)");
    
    // [AUDIT-FLOW] Log de rastreamento PR√â-EXTRA√á√ÉO
    console.log("[AUDIT-FLOW] üîç PR√â-EXTRA√á√ÉO de bandas:", {
        'analysis.userAnalysis?.bands': analysis.userAnalysis?.bands,
        'opts.userAnalysis?.bands': opts.userAnalysis?.bands,
        'opts.userAnalysis?.technicalData?.spectral_balance': opts.userAnalysis?.technicalData?.spectral_balance,
        'analysis.referenceAnalysis?.bands': analysis.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.bands': opts.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.technicalData?.spectral_balance': opts.referenceAnalysis?.technicalData?.spectral_balance
    });
    
    // ‚úÖ CORRE√á√ÉO V3: Extra√ß√£o unificada de bandas espectrais (aceita arrays e objetos)
    let userBandsLocal =
        analysis.userAnalysis?.bands ||
        opts.userAnalysis?.bands ||
        opts.userAnalysis?.technicalData?.spectral_balance ||
        analysis.bands ||
        analysis.referenceComparison?.userBands ||
        null;

    let refBandsLocal =
        analysis.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.technicalData?.spectral_balance ||
        analysis.referenceComparison?.refBands ||
        null;
    
    // [AUDIT-FLOW] Log P√ìS-EXTRA√á√ÉO
    console.log("[AUDIT-FLOW] üîç P√ìS-EXTRA√á√ÉO de bandas:", {
        userBandsLocal,
        refBandsLocal,
        userBandsLocalType: userBandsLocal ? (Array.isArray(userBandsLocal) ? 'Array' : 'Object') : 'null',
        refBandsLocalType: refBandsLocal ? (Array.isArray(refBandsLocal) ? 'Array' : 'Object') : 'null'
    });
    
    // ÔøΩ LOG DE DEBUG: Mostrar o que foi encontrado
    console.log("[REF-COMP] üîç Extra√ß√£o inicial de bandas:", {
        userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? `Array(${userBandsLocal.length})` : `Object(${Object.keys(userBandsLocal).length})`) : 'null',
        refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? `Array(${refBandsLocal.length})` : `Object(${Object.keys(refBandsLocal).length})`) : 'null',
        sourceUser: userBandsLocal ? 'encontrado' : 'null',
        sourceRef: refBandsLocal ? 'encontrado' : 'null'
    });

    // ‚úÖ Valida√ß√£o: Aceitar tanto arrays quanto objetos
    const hasUserBands = userBandsLocal && (
        (Array.isArray(userBandsLocal) && userBandsLocal.length > 0) ||
        (typeof userBandsLocal === 'object' && Object.keys(userBandsLocal).length > 0)
    );
    
    const hasRefBands = refBandsLocal && (
        (Array.isArray(refBandsLocal) && refBandsLocal.length > 0) ||
        (typeof refBandsLocal === 'object' && Object.keys(refBandsLocal).length > 0)
    );

    // üö® Prote√ß√£o aprimorada com fallback global
    if (!hasUserBands || !hasRefBands) {
        console.warn("[REF-COMP] ‚ö†Ô∏è Bandas ausentes na estrutura principal - tentando fallback global");
        
        const globalUser = window.__soundyState?.previousAnalysis?.bands || 
                          window.__soundyState?.previousAnalysis?.technicalData?.spectral_balance ||
                          window.__soundyState?.userAnalysis?.bands || 
                          null;
        const globalRef = window.__soundyState?.referenceAnalysis?.bands || 
                         window.__soundyState?.referenceAnalysis?.technicalData?.spectral_balance ||
                         window.__soundyState?.reference?.analysis?.bands || 
                         null;
        
        const hasGlobalUser = globalUser && (
            (Array.isArray(globalUser) && globalUser.length > 0) ||
            (typeof globalUser === 'object' && Object.keys(globalUser).length > 0)
        );
        
        const hasGlobalRef = globalRef && (
            (Array.isArray(globalRef) && globalRef.length > 0) ||
            (typeof globalRef === 'object' && Object.keys(globalRef).length > 0)
        );
        
        console.log("[REF-COMP] üîç Fallback global:", {
            globalUser: globalUser ? (Array.isArray(globalUser) ? `Array(${globalUser.length})` : `Object(${Object.keys(globalUser).length})`) : 'null',
            globalRef: globalRef ? (Array.isArray(globalRef) ? `Array(${globalRef.length})` : `Object(${Object.keys(globalRef).length})`) : 'null',
            hasGlobalUser,
            hasGlobalRef,
            hasPreviousAnalysis: !!window.__soundyState?.previousAnalysis,
            hasReferenceAnalysis: !!window.__soundyState?.referenceAnalysis
        });
        
        if (!hasGlobalUser || !hasGlobalRef) {
            console.error("[REF-COMP] ‚ùå Nenhum dado v√°lido encontrado - abortando render");
            console.table({
                userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0,
                refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0,
                globalUser: globalUser ? (Array.isArray(globalUser) ? globalUser.length : Object.keys(globalUser).length) : 0,
                globalRef: globalRef ? (Array.isArray(globalRef) ? globalRef.length : Object.keys(globalRef).length) : 0,
                hasUserAnalysis: !!analysis.userAnalysis,
                hasReferenceAnalysis: !!analysis.referenceAnalysis,
                soundyStateKeys: Object.keys(window.__soundyState || {})
            });
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (sem dados v√°lidos)");
            console.groupEnd();
            return;
        }
        
        // Aplicar fallback
        userBandsLocal = globalUser;
        refBandsLocal = globalRef;
        
        console.log("[REF-COMP] ‚úÖ Fallback global aplicado com sucesso");
    }

    // Atualizar vari√°veis globais
    userBands = userBandsLocal;
    refBands = refBandsLocal;
    
    // [AUDIT-FLOW] Log ap√≥s atribui√ß√£o final
    console.log("[AUDIT-FLOW] üîç Ap√≥s atribui√ß√£o final:", {
        userBands,
        refBands,
        userBandsIsValid: !!(userBandsLocal && (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length)),
        refBandsIsValid: !!(refBandsLocal && (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length))
    });
    
    // ‚úÖ LOG FINAL CONSOLIDADO
    const userBandsCount = userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0;
    const refBandsCount = refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0;
    
    console.log("[REF-COMP] ‚úÖ Bandas detectadas:", {
        userBands: userBandsCount,
        refBands: refBandsCount,
        userBandsType: userBands ? (Array.isArray(userBands) ? 'Array' : 'Object') : 'null',
        refBandsType: refBands ? (Array.isArray(refBands) ? 'Array' : 'Object') : 'null',
        source: hasUserBands && hasRefBands ? 'analysis-principal' : 'fallback-global'
    });
    
    console.log("‚úÖ [SAFE_REF_V3] Tracks resolvidas:", { 
        userTrack, 
        referenceTrack, 
        userBands: !!userBands, 
        refBands: !!refBands,
        userBandsCount,
        refBandsCount
    });
    
    // üß† SAFEGUARD FINAL: Verifica√ß√£o cr√≠tica antes de qualquer renderiza√ß√£o
    if (opts?.mode === "reference") {
        // SAFEGUARD: garantir que spectral_balance exista na estrutura
        if (opts?.referenceAnalysis && !opts?.referenceAnalysis?.technicalData?.spectral_balance) {
            console.warn("‚ö†Ô∏è [SAFEGUARD] spectral_balance ausente em referenceAnalysis ‚Äî aplicando patch.");
            if (!opts.referenceAnalysis.technicalData) opts.referenceAnalysis.technicalData = {};
            opts.referenceAnalysis.technicalData.spectral_balance = refBands;
        }
        
        if (opts?.userAnalysis && !opts?.userAnalysis?.technicalData?.spectral_balance) {
            console.warn("‚ö†Ô∏è [SAFEGUARD] spectral_balance ausente em userAnalysis ‚Äî aplicando patch.");
            if (!opts.userAnalysis.technicalData) opts.userAnalysis.technicalData = {};
            opts.userAnalysis.technicalData.spectral_balance = userBands;
        }
    }
    
    // üéØ CORRE√á√ÉO CR√çTICA: Fonte da verdade vem do caller - N√ÉO usar fallback 'genre'
    // Reusar stateV3 j√° declarado no patch V3 acima
    
    // üö® PRIORIDADE DE DETEC√á√ÉO DO MODO (sem fallback autom√°tico para genre):
    // 1. opts.mode (passado explicitamente pelo caller)
    // 2. stateV3.render.mode (j√° configurado anteriormente)
    // 3. stateV3.reference.isSecondTrack = true ‚Üí for√ßar 'reference'
    // 4. √öltimo recurso: 'genre'
    let explicitMode = opts.mode || stateV3?.render?.mode;
    
    // üéØ Se segunda faixa est√° ativa, FOR√áAR modo reference
    if (stateV3.reference?.isSecondTrack === true && !explicitMode) {
        explicitMode = 'reference';
        console.log('üî• [MODE-OVERRIDE] Segunda faixa detectada - for√ßando modo reference');
    }
    
    // Fallback final apenas se realmente necess√°rio
    if (!explicitMode) {
        explicitMode = 'genre';
        console.warn('‚ö†Ô∏è [MODE-FALLBACK] Nenhum modo detectado - usando genre como fallback');
    }
    
    const isReferenceMode = (opts?.mode === 'reference') 
        || (stateV3?.render?.mode === 'reference') 
        || (stateV3?.reference?.isSecondTrack === true && !opts?.mode);
    
    if (isReferenceMode) console.log('[REF-FLOW] renderReferenceComparisons in reference mode');
    
    const isReference = explicitMode === 'reference';
    
    // Salvar modo no estado (N√ÉO sobrescrever se j√° for reference)
    stateV3.render = stateV3.render || {};
    if (stateV3.render.mode !== 'reference' || explicitMode === 'reference') {
        stateV3.render.mode = explicitMode;
    }
    window.__soundyState = stateV3;
    
    // (Opcional) Log assertivo
    console.log('[RENDER-REF] MODO SELECIONADO:', explicitMode.toUpperCase());
    console.log('[ASSERT] mode=', explicitMode, 'isSecondTrack=', stateV3?.reference?.isSecondTrack, 'refJobId=', stateV3?.reference?.jobId);
    console.log('[ASSERT] opts.mode=', opts.mode, 'stateV3.render.mode=', stateV3.render.mode);
    
    // üö® CR√çTICO: N√ÉO reavaliar "se tem ref" para mudar o modo
    // O modo √© determin√≠stico e vem do caller
    const renderMode = explicitMode;
    
    // üéØ PATCH 5: Asserts de valida√ß√£o de modo (N√ÉO ABORTAM, apenas logam)
    if (renderMode === 'reference') {
        if (!stateV3?.reference?.analysis?.bands) {
            console.warn('‚ö†Ô∏è [ASSERT-MAIN] Modo reference sem stateV3.reference.analysis.bands - pode usar fallback');
        }
        if (!stateV3?.reference?.isSecondTrack) {
            console.warn('‚ö†Ô∏è [ASSERT-MAIN] Modo reference sem flag isSecondTrack');
        }
        if (!stateV3?.reference?.analysis) {
            console.warn('‚ö†Ô∏è [CRITICAL] Modo reference configurado mas sem dados de refer√™ncia no stateV3!');
            console.warn('‚ö†Ô∏è stateV3.reference:', stateV3?.reference);
        }
    } else if (renderMode === 'genre') {
        if (!window.__activeRefData?.bands) {
            console.warn('‚ö†Ô∏è [ASSERT-MAIN] Modo genre sem __activeRefData.bands - tentando fallback');
            console.warn('‚ö†Ô∏è __activeRefData:', window.__activeRefData);
        }
    }
    console.log('‚úÖ [PATCH-5] Asserts de modo executados:', { renderMode, hasRefBands: !!(stateV3?.reference?.analysis?.bands), hasGenreBands: !!(window.__activeRefData?.bands) });
    
    // üö® REMOVIDO: Detec√ß√£o legacy autom√°tica (causava auto-switch indevido)
    // O modo agora √© determin√≠stico e vem do caller via opts.mode
    // N√ÉO tentar "adivinhar" o modo baseado em analysis.mode ou estruturas
    
    // üéØ CORRE√á√ÉO: Definir hasNewStructure e hasOldStructure ANTES de usar
    const hasNewStructure = !!(analysis?.referenceAnalysis?.technicalData || analysis?.metrics);
    const hasOldStructure = !!(analysis?.referenceComparison && !hasNewStructure);
    
    let ref, titleText, userMetrics;
    
    // üîç [AUDITORIA_REF] Log de detec√ß√£o cr√≠tica
    console.log('[AUDITORIA_REF] Detec√ß√£o de modo:', {
        'analysis.mode': analysis.mode,
        'isReferenceMode': isReferenceMode,
        'hasNewStructure': hasNewStructure,
        'hasOldStructure': hasOldStructure,
        'window.__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
        'referenceAnalysisData': !!window.referenceAnalysisData
    });
    
    // üéØ USAR renderMode PARA DECIDIR O FLUXO (n√£o isReferenceMode)
    if (renderMode === 'reference') {
        console.log('[AUDITORIA_REF] Modo refer√™ncia detectado ‚Äì exibindo compara√ß√£o A/B entre faixas');
        
        // üî• PRIORIDADE M√ÅXIMA: Usar nova estrutura corrigida (userAnalysis/referenceAnalysis)
        if (opts.userAnalysis && opts.referenceAnalysis) {
            console.log('üî• [REF-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('üî• [REF-CORRECTED] Usando estrutura corrigida: opts.userAnalysis + opts.referenceAnalysis');
            console.log('üî• [REF-CORRECTED] userAnalysis existe:', !!opts.userAnalysis);
            console.log('üî• [REF-CORRECTED] referenceAnalysis existe:', !!opts.referenceAnalysis);
            console.log('üî• [REF-CORRECTED] userAnalysis.technicalData:', !!opts.userAnalysis.technicalData);
            console.log('üî• [REF-CORRECTED] referenceAnalysis.technicalData:', !!opts.referenceAnalysis.technicalData);
            console.log('üî• [REF-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            const userTech = opts.userAnalysis.technicalData || {};
            const refTech = opts.referenceAnalysis.technicalData || {};
            
            // üîç DIAGN√ìSTICO: Verificar estrutura das bandas
            console.log('üîç [DIAGN√ìSTICO] userTech.spectral_balance:', userTech.spectral_balance);
            console.log('üîç [DIAGN√ìSTICO] refTech.spectral_balance:', refTech.spectral_balance);
            console.log('üîç [DIAGN√ìSTICO] userTech.bandEnergies:', userTech.bandEnergies);
            console.log('üîç [DIAGN√ìSTICO] refTech.bandEnergies:', refTech.bandEnergies);
            console.log('üîç [DIAGN√ìSTICO] userTech.bands:', userTech.bands);
            console.log('üîç [DIAGN√ìSTICO] refTech.bands:', refTech.bands);
            
            userMetrics = userTech;
            ref = {
                // Valores BRUTOS da segunda faixa (refer√™ncia/alvo)
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.spectral_balance ?? refTech.bandEnergies ?? refTech.bands ?? null
            };
            
            // üéØ SEM√ÇNTICA CORRETA NO T√çTULO:
            // 1¬™ faixa = sua m√∫sica (atual) | 2¬™ faixa = refer√™ncia (alvo)
            const userFileName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || 'Sua M√∫sica';
            const refFileName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || 'Refer√™ncia';
            titleText = `ÔøΩ Compara√ß√£o da sua faixa com a refer√™ncia:\nAtual: ${userFileName}\nRefer√™ncia: ${refFileName}`;
            
            console.log('‚úÖ [REF-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            console.log('‚úÖ [REF-CORRECTED] Dados A/B extra√≠dos corretamente:');
            console.log('‚úÖ [REF-CORRECTED]   SUA M√öSICA (1¬™):', opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName);
            console.log('‚úÖ [REF-CORRECTED]   Bandas:', Object.keys(userMetrics.spectral_balance || {}));
            console.log('‚úÖ [REF-CORRECTED]   LUFS:', userMetrics.lufsIntegrated);
            console.log('‚úÖ [REF-CORRECTED]   REFER√äNCIA (2¬™):', opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName);
            console.log('‚úÖ [REF-CORRECTED]   Bandas:', Object.keys(ref.bands || {}));
            console.log('‚úÖ [REF-CORRECTED]   LUFS:', ref.lufs_target);
            console.log('‚úÖ [REF-CORRECTED]   Tabela: ESQUERDA=sua m√∫sica, DIREITA=refer√™ncia');
            console.log('‚úÖ [REF-CORRECTED] ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
            
            // üéØ LOG ASSERT_REF_FLOW
            console.log("[ASSERT_REF_FLOW ‚úÖ]", {
                mode: 'reference',
                userTrack: opts.userAnalysis?.fileName || opts.userAnalysis?.metadata?.fileName,
                referenceTrack: opts.referenceAnalysis?.fileName || opts.referenceAnalysis?.metadata?.fileName,
                userBands: Object.keys(userMetrics.spectral_balance || {}),
                refBands: Object.keys(ref.bands || {}),
                userLUFS: userMetrics.lufsIntegrated,
                refLUFS: ref.lufs_target
            });
        }
        // üéØ PRIORIDADE 0 (FALLBACK): analysis.referenceAnalysis (estrutura antiga)
        else if (analysis.referenceAnalysis && analysis.referenceAnalysis.technicalData) {
            console.log('‚úÖ [REF-COMP] Usando real reference analysis as target (primeira faixa)');
            
            const refTech = analysis.referenceAnalysis.technicalData;
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.bandEnergies ?? refTech.spectral_balance ?? refTech.bands ?? null
            };
            
            titleText = `üéµ ${analysis.referenceAnalysis.fileName || analysis.referenceAnalysis.metadata?.fileName || 'Faixa Base'}`;
            
            console.log('üìä [REF-COMP] baseBands/refBands resolved from referenceAnalysis:', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                hasBands: !!ref.bands,
                bandsKeys: ref.bands ? Object.keys(ref.bands) : []
            });
            console.log('‚úÖ [REF-COMP] Using real reference analysis as target');
        }
        // üéØ PRIORIDADE 1 (FALLBACK): analysis.referenceBands (estrutura centralizada)
        else if (analysis.referenceBands && analysis.mode === 'reference') {
            console.log('‚úÖ [RENDER-REF] Usando analysis.referenceBands (estrutura centralizada)');
            
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: analysis.referenceBands.lufsIntegrated || analysis.referenceBands.lufs_integrated,
                true_peak_target: analysis.referenceBands.truePeakDbtp || analysis.referenceBands.true_peak_dbtp,
                dr_target: analysis.referenceBands.dynamicRange || analysis.referenceBands.dynamic_range,
                lra_target: analysis.referenceBands.lra,
                stereo_target: analysis.referenceBands.stereoCorrelation || analysis.referenceBands.stereo_correlation,
                stereo_width_target: analysis.referenceBands.stereoWidth || analysis.referenceBands.stereo_width,
                spectral_centroid_target: analysis.referenceBands.spectralCentroidHz || analysis.referenceBands.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: analysis.referenceBands.spectral_balance || analysis.referenceBands.bands || null
            };
            
            titleText = `üéµ Faixa de Refer√™ncia`;
            
            console.log('üìä [RENDER-REF] Refer√™ncia (referenceBands):', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: ref.bands
            });
        }
        // ===== PRIORIDADE 2: NOVA ESTRUTURA (userTrack/referenceTrack) =====
        else if (hasNewStructure) {
            // üß† [PATCH V4] REFERENCE SCOPE LOCK FIX - Estabilizar escopo antes de render
            try {
                console.groupCollapsed("üß† [REF_SCOPE_LOCK]");
                console.log("üì¶ Contexto atual antes do render:", { opts, stateV3 });

                // üîí Buscar dados de compara√ß√£o em todos os escopos poss√≠veis
                let comparisonLock =
                    opts?.comparisonData ||
                    window?.lastComparisonData ||
                    stateV3?.reference?.comparisonData ||
                    {
                        userTrack:
                            opts?.userAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                            "Faixa do Usu√°rio",
                        referenceTrack:
                            opts?.referenceAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                            "Faixa de Refer√™ncia",
                        userBands:
                            opts?.userAnalysis?.bands ||
                            stateV3?.reference?.userAnalysis?.bands ||
                            {},
                        refBands:
                            opts?.referenceAnalysis?.bands ||
                            stateV3?.reference?.referenceAnalysis?.bands ||
                            {},
                    };

                // üîê Corrigir se ainda estiver faltando algo
                if (!comparisonLock.referenceTrack) {
                    comparisonLock.referenceTrack =
                        opts?.referenceAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                        "Faixa de Refer√™ncia";
                }
                if (!comparisonLock.userTrack) {
                    comparisonLock.userTrack =
                        opts?.userAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                        "Faixa do Usu√°rio";
                }

                // üîí Salvar globalmente para persistir escopo
                window.lastComparisonData = comparisonLock;

                console.log("‚úÖ [REF_SCOPE_LOCK] Estrutura estabilizada:", comparisonLock);
                console.groupEnd();

                // üß© Reatribuir vari√°veis seguras locais
                const userTrackLock = comparisonLock.userTrack;
                const referenceTrackLock = comparisonLock.referenceTrack;
                const userBandsLock = comparisonLock.userBands;
                const refBandsLock = comparisonLock.refBands;

                // Se ainda n√£o tiver bandas, abortar render seguro
                if (!refBandsLock || Object.keys(refBandsLock).length === 0) {
                    console.error(
                        "üö® [REF_SCOPE_LOCK] refBands ausente, abortando renderiza√ß√£o segura."
                    );
                    window.__REF_RENDER_LOCK__ = false;
                    window.comparisonLock = false;
                    console.log("[LOCK] comparisonLock liberado (refBands ausente)");
                    return;
                }

                // ‚úÖ Reaplicar no escopo principal
                opts.comparisonData = comparisonLock;
                window.comparisonData = comparisonLock;
            } catch (err) {
                console.error("üí• [REF_SCOPE_LOCK] Erro cr√≠tico ao reestabelecer escopo:", err);
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (erro escopo)");
                return;
            }
            
            console.log('‚úÖ [RENDER-REF] Usando NOVA estrutura (userTrack/referenceTrack)');
            
            // üß© Fix final do modal A/B - usar dados corretos de comparisonLock
            const refFile = 
                comparisonLock?.refFile ||
                comparisonLock?.referenceTrack ||
                opts?.referenceAnalysis?.fileName ||
                opts?.referenceAnalysis?.metadata?.fileName ||
                stateV3?.reference?.referenceAnalysis?.fileName ||
                "Faixa de refer√™ncia";

            const userFile = 
                comparisonLock?.userFile ||
                comparisonLock?.userTrack ||
                opts?.userAnalysis?.fileName ||
                opts?.userAnalysis?.metadata?.fileName ||
                stateV3?.reference?.userAnalysis?.fileName ||
                "Faixa do usu√°rio";

            console.log("[REF-FIX-FINAL] referenceTrackName resolvido:", refFile);
            console.log("[REF-FIX-FINAL] userTrackName resolvido:", userFile);
            
            // Extrair m√©tricas de opts ou stateV3
            const refAnalysis = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
            const userAnalysisData = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
            
            if (!refAnalysis || !userAnalysisData) {
                console.error("üí• [REF-FIX-FINAL] An√°lises n√£o encontradas, abortando");
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (an√°lises n√£o encontradas)");
                return;
            }
            
            const refMetrics = refAnalysis.metrics || refAnalysis;
            userMetrics = userAnalysisData.metrics || userAnalysisData;
            
            ref = {
                lufs_target: refMetrics.lufs || refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.peak || refMetrics.truePeakDbtp,
                dr_target: refMetrics.dr || refMetrics.dynamicRange,
                lra_target: refMetrics.lra,
                stereo_target: refMetrics.stereoCorrelation,
                stereo_width_target: refMetrics.stereoWidth,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refAnalysis.bands || comparisonLock?.refBands || {}
            };
            
            titleText = `üéµ ${refFile}`;
            
            console.log('üìä [RENDER-REF] Refer√™ncia:', {
                fileName: refFile,
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: Object.keys(ref.bands || {}).length
            });
            console.log('üìä [RENDER-REF] Usu√°rio:', {
                fileName: userFile,
                lufs: userMetrics.lufs || userMetrics.lufsIntegrated,
                dr: userMetrics.dr || userMetrics.dynamicRange
            });
        }
        // ===== ESTRUTURA ANTIGA (retrocompatibilidade) =====
        else if (hasOldStructure) {
            console.log('‚ö†Ô∏è [RENDER-REF] Usando estrutura ANTIGA (referenceMetrics) - considerar migra√ß√£o');
            
            const refMetrics = analysis.referenceComparison.referenceMetrics;
            ref = {
                lufs_target: refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.truePeakDbtp,
                dr_target: refMetrics.dynamicRange,
                lra_target: refMetrics.lra || 6,
                stereo_target: refMetrics.stereoCorrelation,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: null
            };
            titleText = "üéµ Faixa de Refer√™ncia";
            
            console.log('üéØ [RENDER-REF] Usando m√©tricas de refer√™ncia real:', refMetrics);
        }
    } else if (renderMode === 'genre') {
        // ===== MODO G√äNERO =====
        // üéØ S√ì LOGA "MODO G√äNERO" SE REALMENTE FOR GENRE
        console.log('üéµ [RENDER-REF] MODO G√äNERO');
        
        // üéØ LOG DE VERIFICA√á√ÉO: Garantir que targets de g√™nero sejam usados
        console.log('[TARGET-RESOLVE] Modo GENRE confirmado - buscando targets de g√™nero:', {
            hasWindowActiveRefData: !!window.__activeRefData,
            hasProdAiRefData: !!window.PROD_AI_REF_DATA,
            genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
        });
        
        // üéØ CORRE√á√ÉO: Fallback seguro para __activeRefData com m√∫ltiplas tentativas
        let __activeRefData = window.__activeRefData;
        
        // Tentativa 1: Usar dados globais
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('‚ö†Ô∏è [GENRE-MODE] __activeRefData n√£o dispon√≠vel, tentando PROD_AI_REF_DATA...');
            __activeRefData = window.PROD_AI_REF_DATA;
        }
        
        // Tentativa 2: Usar dados do analysis
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('‚ö†Ô∏è [GENRE-MODE] PROD_AI_REF_DATA n√£o dispon√≠vel, tentando analysis...');
            __activeRefData = analysis?.referenceComparison 
                || analysis?.genreTargets 
                || state?.genreTargets;
        }
        
        // Tentativa 3: Criar estrutura m√≠nima
        if (!__activeRefData || !__activeRefData.bands) {
            console.error('‚ùå [GENRE-MODE] NENHUMA FONTE DE DADOS DE G√äNERO ENCONTRADA!');
            console.error('‚ùå Debug:', {
                hasWindowActiveRefData: !!window.__activeRefData,
                hasProdAiRefData: !!window.PROD_AI_REF_DATA,
                hasAnalysisRefComparison: !!analysis?.referenceComparison,
                genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
            });
            
            container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;opacity:.6">
                <strong style="color:#ff6b6b;">‚ö†Ô∏è Refer√™ncias de g√™nero n√£o carregadas</strong><br>
                <span style="font-size:11px;">Tente recarregar a p√°gina ou selecionar outro g√™nero</span>
            </div>`; 
            return; 
        }
        
        // üö® CORRE√á√ÉO CR√çTICA: N√ÉO usar referenceComparisonMetrics no modo genre
        // Apenas usar targets de g√™nero
        ref = __activeRefData;
        titleText = window.PROD_AI_REF_GENRE || window.__activeRefGenre || 'G√™nero Musical';
        userMetrics = analysis.technicalData || {};
        
        console.log('‚úÖ [GENRE-MODE] Usando targets de g√™nero:', {
            genre: titleText,
            hasBands: !!ref.bands,
            bandsCount: ref.bands ? Object.keys(ref.bands).length : 0,
            bandsList: ref.bands ? Object.keys(ref.bands) : [],
            source: window.__activeRefData ? 'window.__activeRefData' : (window.PROD_AI_REF_DATA ? 'PROD_AI_REF_DATA' : 'analysis')
        });
    } else {
        // FALLBACK: N√£o deveria cair aqui
        console.warn('‚ö†Ô∏è [RENDER-REF] MODO INDETERMINADO - renderMode:', renderMode);
        container.innerHTML = '<div style="font-size:12px;opacity:.6">Modo de an√°lise n√£o identificado</div>'; 
        return;
    }
    
    // üéØ SOBRESCREVER com referenceComparisonMetrics APENAS se modo for 'reference'
    if (renderMode === 'reference' && referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('üéØ [RENDER-REF] MODO REFER√äNCIA ‚Äî COMPARA√á√ÉO ENTRE FAIXAS ATIVADA');
        console.log('‚úÖ [RENDER-REF] Sobrescrevendo com referenceComparisonMetrics');
        
        const targetMetrics = referenceComparisonMetrics.reference;
        userMetrics = referenceComparisonMetrics.user;
        
        ref = {
            lufs_target: targetMetrics.lufsIntegrated || targetMetrics.lufs_integrated,
            true_peak_target: targetMetrics.truePeakDbtp || targetMetrics.true_peak_dbtp,
            dr_target: targetMetrics.dynamicRange || targetMetrics.dynamic_range,
            lra_target: targetMetrics.lra,
            stereo_target: targetMetrics.stereoCorrelation || targetMetrics.stereo_correlation,
            stereo_width_target: targetMetrics.stereoWidth || targetMetrics.stereo_width,
            spectral_centroid_target: targetMetrics.spectralCentroidHz || targetMetrics.spectral_centroid,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300,
            bands: targetMetrics.spectral_balance || null
        };
        
        // üéØ SEM√ÇNTICA CORRETA: referenceFull = 2¬™ faixa (refer√™ncia/alvo)
        const userFileName = referenceComparisonMetrics.userFull?.metadata?.fileName || referenceComparisonMetrics.userFull?.fileName || 'Sua M√∫sica';
        const refFileName = referenceComparisonMetrics.referenceFull?.metadata?.fileName || referenceComparisonMetrics.referenceFull?.fileName || 'Refer√™ncia';
        titleText = `üéß Compara√ß√£o da sua faixa com a refer√™ncia:\nAtual: ${userFileName}\nRefer√™ncia: ${refFileName}`;
        
        // üéØ ASSERT CR√çTICO: Verificar se bands est√£o dispon√≠veis no modo reference
        console.log('[ASSERT_REF_DATA]', ref.bands ? '‚úÖ Reference bands loaded' : '‚ùå Missing bands');
        if (!ref.bands) {
            console.error('üö® [CRITICAL] Modo reference sem bandas! Bloqueando fallback de g√™nero.');
            console.error('üö® Debug:', {
                hasTargetMetrics: !!targetMetrics,
                targetMetricsKeys: targetMetrics ? Object.keys(targetMetrics) : [],
                hasSpectralBalance: !!targetMetrics?.spectral_balance,
                hasReferenceComparisonMetrics: !!referenceComparisonMetrics,
                referenceFullKeys: referenceComparisonMetrics.referenceFull ? Object.keys(referenceComparisonMetrics.referenceFull) : []
            });
        }
    } else if (renderMode === 'genre' && referenceComparisonMetrics) {
        // üö® LOG DE SEGURAN√áA: Confirmar que modo genre N√ÉO usa referenceComparisonMetrics
        console.log('‚úÖ [GENRE-MODE] referenceComparisonMetrics IGNORADO no modo g√™nero (correto)');
    }
    
    // üéØ Priorizar userMetrics (nova estrutura) sobre technicalData (legado)
    const tech = userMetrics || analysis.technicalData || {};
    
    console.log('üìä [RENDER-REF] Fonte de m√©tricas do usu√°rio:', userMetrics ? 'userMetrics (nova estrutura)' : 'technicalData (legado)');
    console.log('üìä [RENDER-REF] Modo final confirmado:', renderMode);
    console.log('üìä [RENDER-REF] ref.bands dispon√≠vel:', !!ref?.bands, 'keys:', ref?.bands ? Object.keys(ref.bands).length : 0);
    
    // Mapeamento de m√©tricas - RESTAURAR TABELA COMPLETA
    const rows = [];
    const addedLabels = new Set(); // üéØ Controle de duplica√ß√£o por nome
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '‚Äî';
    const pushRow = (label, val, target, tol, unit='') => {
        // ‚úÖ Epsilon para compara√ß√µes float precisas
        const EPS = 1e-6;
        
        // üéØ PREVEN√á√ÉO DE DUPLICATAS: evitar bandas com mesmo nome
        if (addedLabels.has(label)) {
            console.warn(`‚ö†Ô∏è Duplicata evitada: ${label}`);
            return;
        }
        addedLabels.add(label);
        // Usar sistema de enhancement se dispon√≠vel
        const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
            ? window.enhanceRowLabel(label, label.toLowerCase().replace(/[^a-z]/g, '')) 
            : label;
            
        // Tratar target null ou NaN como N/A explicitamente
        const targetIsNA = (target == null || target === '' || (typeof target==='number' && !Number.isFinite(target)));
        if (!Number.isFinite(val) && targetIsNA) return; // nada √∫til
        if (targetIsNA) {
            rows.push(`<tr>
                <td>${enhancedLabel}</td>
                <td>${Number.isFinite(val)?nf(val)+unit:'‚Äî'}</td>
                <td colspan="2" style="opacity:.55">N/A</td>
            </tr>`);
            return;
        }
        // üéØ CORRIGIDO: C√°lculo de diferen√ßa usando centerOfRange para ranges
        let diff = null;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max) && Number.isFinite(val)) {
            // Target √© um range: usar centro do range para c√°lculo de delta
            const targetForDelta = centerOfRange(target);
            if (typeof targetForDelta === 'number' && Number.isFinite(targetForDelta)) {
                diff = val - targetForDelta;
            } else {
                // Fallback: dist√¢ncia para o range
                const minNorm = Math.min(target.min, target.max);
                const maxNorm = Math.max(target.min, target.max);
                
                if (val >= minNorm - EPS && val <= maxNorm + EPS) {
                    diff = 0; // Dentro do range
                } else if (val < minNorm) {
                    diff = val - minNorm;
                } else {
                    diff = val - maxNorm;
                }
            }
        } else if (Number.isFinite(val) && Number.isFinite(target)) {
            // Target fixo: diferen√ßa tradicional
            diff = val - target;
        } else {
            // üéØ Sem crash se target n√£o for v√°lido
            diff = null;
        }
        
        // ‚úÖ Sistema de 3 cores com epsilon
        let diffCell;
        if (!Number.isFinite(diff)) {
            // Sem dados v√°lidos ‚Üí vermelho
            diffCell = '<td class="warn" style="text-align: center; padding: 8px;"><div style="font-size: 12px; font-weight: 600;">Corrigir</div></td>';
        } else if (tol === 0) {
            // L√≥gica para bandas espectrais (tol=0)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= EPS) {
                // ‚úÖ DENTRO DO RANGE ‚Üí Verde
                cssClass = 'ok';
                statusText = 'Ideal';
            } else if (absDiff <= 1.0 + EPS) {
                // ‚ö†Ô∏è Fora por at√© 1dB ‚Üí Amarelo
                cssClass = 'yellow';
                statusText = 'Ajuste leve';
            } else if (absDiff <= 3.0 + EPS) {
                // ‚ö†Ô∏è Fora por at√© 3dB ‚Üí Amarelo (era laranja)
                cssClass = 'yellow';
                statusText = 'Ajustar';
            } else {
                // ‚ùå Fora por >3dB ‚Üí Vermelho
                cssClass = 'warn';
                statusText = 'Corrigir';
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else if (!Number.isFinite(tol) || tol < 0) {
            // Fallback: toler√¢ncia padr√£o com epsilon
            const defaultTol = 1.0;
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            console.warn(`‚ö†Ô∏è [TOLERANCE_FALLBACK] M√©trica "${label}" sem toler√¢ncia v√°lida (tol=${tol}). Usando toler√¢ncia padr√£o: ${defaultTol}`);
            
            if (absDiff <= defaultTol + EPS) {
                // ‚úÖ ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / defaultTol;
                if (multiplicador <= 2 + EPS) {
                    // ‚ö†Ô∏è ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // ‚ùå ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else {
            // L√≥gica padr√£o com epsilon (LUFS, TP, DR, etc.)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= tol + EPS) {
                // ‚úÖ ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / tol;
                if (multiplicador <= 2 + EPS) {
                    // ‚ö†Ô∏è ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // ‚ùå ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        }
        
        // üéØ NOVO: Renderiza√ß√£o h√≠brida para targets fixos e ranges
        let targetDisplay;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max)) {
            // Target √© um range: exibir "min dB a max dB"
            targetDisplay = `${nf(target.min)}${unit} a ${nf(target.max)}${unit}`;
        } else if (Number.isFinite(target)) {
            // Target √© um valor fixo: exibir "valor dB"
            targetDisplay = `${nf(target)}${unit}`;
        } else {
            // Target n√£o definido
            targetDisplay = 'N/A';
        }
        
        // Adicionar toler√¢ncia se dispon√≠vel (apenas para targets fixos)
        const tolDisplay = (typeof target !== 'object' && tol != null) ? 
            `<span class="tol">¬±${nf(tol,2)}</span>` : '';
        
        rows.push(`<tr>
            <td>${enhancedLabel}</td>
            <td>${Number.isFinite(val)?nf(val)+unit:'‚Äî'}</td>
            <td>${targetDisplay}${tolDisplay}</td>
            ${diffCell}
        </tr>`);
    };
    // üéØ CENTRALIZA√á√ÉO DAS M√âTRICAS - Fun√ß√£o de acesso para compara√ß√£o por refer√™ncia
    const getMetricForRef = (metricPath, fallbackPath = null) => {
        // Prioridade: analysis.metrics > tech (technicalData) > fallback
        const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
        if (Number.isFinite(centralizedValue)) {
            // Log tempor√°rio para valida√ß√£o
            if (typeof window !== 'undefined' && window.METRICS_REF_VALIDATION !== false) {
                const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
                if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                    console.warn(`üéØ REF_METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                }
            }
            return centralizedValue;
        }
        
        // Fallback para technicalData legado
        const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
        return Number.isFinite(legacyValue) ? legacyValue : null;
    };
    
    const getNestedValue = (obj, path) => {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    };
    
    // üéØ CENTRALIZA√á√ÉO DAS M√âTRICAS - Fun√ß√£o de acesso para compara√ß√£o por refer√™ncia
    // Usar somente m√©tricas reais (sem fallback para RMS/Peak, que t√™m unidades e conceitos distintos)
    // Fun√ß√£o para obter o valor LUFS integrado usando m√©tricas centralizadas
    const getLufsIntegratedValue = () => {
        return getMetricForRef('lufs_integrated', 'lufsIntegrated');
    };
    
    // üß† NOVA PROTE√á√ÉO UNIVERSAL ‚Äî Usa resolveTargetMetric para buscar refer√™ncia real > g√™nero
    const lufsTarget = resolveTargetMetric(analysis, "lufsIntegrated", -14);
    const tpTarget = resolveTargetMetric(analysis, "truePeakDbtp", -1);
    const drTarget = resolveTargetMetric(analysis, "dynamicRange", 8);
    const lraTarget = resolveTargetMetric(analysis, "lra", 6);
    const stereoTarget = resolveTargetMetric(analysis, "stereoCorrelation", 0.1);
    const spectralTarget = resolveTargetMetric(analysis, "spectralCentroidHz", null);
    
    // Toler√¢ncias ainda v√™m de ref (ou padr√£o)
    const tolLufs = (ref && ref.tol_lufs !== undefined) ? ref.tol_lufs : 0.5;
    const tolTp = (ref && ref.tol_true_peak !== undefined) ? ref.tol_true_peak : 0.3;
    const tolDr = (ref && ref.tol_dr !== undefined) ? ref.tol_dr : 1.0;
    const tolLra = (ref && ref.tol_lra !== undefined) ? ref.tol_lra : 1.0;
    const tolStereo = (ref && ref.tol_stereo !== undefined) ? ref.tol_stereo : 0.08;
    const tolSpectral = (ref && ref.tol_spectral !== undefined) ? ref.tol_spectral : 300;
    
    console.log('üß† [RESOLVE-TARGETS] Targets universais resolvidos:', { 
        lufsTarget, tpTarget, drTarget, lraTarget, stereoTarget, spectralTarget 
    });
    
    // ADICIONAR TODAS AS M√âTRICAS PRINCIPAIS
    pushRow('Loudness Integrado (LUFS)', getLufsIntegratedValue(), lufsTarget, tolLufs, ' LUFS');
    pushRow('Pico Real (dBTP)', getMetricForRef('true_peak_dbtp', 'truePeakDbtp'), tpTarget, tolTp, ' dBTP');
    pushRow('DR', getMetricForRef('dynamic_range', 'dynamicRange'), drTarget, tolDr, '');
    pushRow('Faixa de Loudness ‚Äì LRA (LU)', getMetricForRef('lra'), lraTarget, tolLra, ' LU');
    pushRow('Stereo Corr.', getMetricForRef('stereo_correlation', 'stereoCorrelation'), stereoTarget, tolStereo, '');
    
    // üéØ ADICIONAR SPECTRAL CENTROID SE MODO REFER√äNCIA (usa resolveTargetMetric)
    if (isReferenceMode && spectralTarget !== null) {
        pushRow('Centro Espectral (Hz)', getMetricForRef('spectral_centroid', 'spectralCentroidHz'), 
                spectralTarget, tolSpectral, ' Hz');
    }
    
    // Bandas detalhadas Fase 2: usar m√©tricas centralizadas para bandas
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = tech.bandEnergies || null;
    
    // üîç DEBUG: Verificar estado das bandas e mapeamento
    console.log('üîç [DEBUG_BANDS] Verificando bandas espectrais:', {
        MODE: renderMode.toUpperCase(),
        MODE_SOURCE: renderMode === 'genre' ? 'GENRE TARGETS' : 'REFERENCE ANALYSIS',
        hasCentralizedBands: !!centralizedBands,
        centralizedBandsKeys: centralizedBands ? Object.keys(centralizedBands) : [],
        hasLegacyBands: !!legacyBandEnergies,
        legacyBandsKeys: legacyBandEnergies ? Object.keys(legacyBandEnergies) : [],
        hasRefBands: !!ref.bands,
        refBandsKeys: ref.bands ? Object.keys(ref.bands) : [],
        refBandsSource: renderMode === 'genre' ? 'FROM __activeRefData (genre)' : 'FROM referenceAnalysis or referenceComparisonMetrics'
    });
    
    // üéØ MAPEAMENTO CORRIGIDO: Bandas Calculadas ‚Üí Bandas de Refer√™ncia
    const bandMappingCalcToRef = {
        // Banda calculada: chave na refer√™ncia
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid', 
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho',
        // Varia√ß√µes adicionais
        'low_bass': 'low_bass',
        'low_mid': 'low_mid',
        'high_mid': 'high_mid',
        'presenca': 'presenca',
        'brilho': 'brilho'
    };
    
    // üéØ MAPEAMENTO REVERSO: Bandas de Refer√™ncia ‚Üí Bandas Calculadas
    const bandMappingRefToCalc = {
        'sub': 'sub',
        'low_bass': 'bass',
        'upper_bass': 'bass', // üéØ NOVO: upper_bass ‚Üí bass
        'low_mid': 'lowMid',
        'mid': 'mid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // üéØ ALIAS DE BANDAS: Nomes alternativos para busca
    const bandAliases = {
        'bass': ['low_bass', 'upper_bass'],
        'lowMid': ['low_mid'],
        'highMid': ['high_mid'],
        'presence': ['presenca'],
        'air': ['brilho']
    };
    
    // üéØ NOVA L√ìGICA: Priorizar bandas da nova estrutura em modo reference
    let bandsToUse, referenceBands;
    
    if (isReferenceMode && hasNewStructure && ref.bands) {
        // Usar bandas da referenceTrack.metrics.spectral_balance
        console.log('‚úÖ [RENDER-BANDS] Usando bandas da NOVA estrutura (referenceTrack)');
        referenceBands = ref.bands;
        bandsToUse = tech.spectral_balance || centralizedBands || legacyBandEnergies;
    } else {
        // Modo legado ou g√™nero
        bandsToUse = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
        referenceBands = isReferenceMode && analysis.referenceComparison?.comparison?.spectralBands;
    }
    
    // üéØ RENDERIZA√á√ÉO DE BANDAS EM MODO REFERENCE
    if (isReferenceMode && hasNewStructure && ref.bands && bandsToUse) {
        console.log('‚úÖ [RENDER-REF-BANDS] Renderizando bandas com NOVA estrutura');
        
        const bandNames = {
            sub: 'Sub (20‚Äì60Hz)',
            bass: 'Bass (60‚Äì150Hz)',
            lowMid: 'Low-Mid (150‚Äì500Hz)',
            mid: 'Mid (500‚Äì2kHz)',
            highMid: 'High-Mid (2‚Äì5kHz)',
            presence: 'Presence (5‚Äì10kHz)',
            air: 'Air (10‚Äì20kHz)'
        };
        
        // Iterar pelas bandas padr√£o
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            // Pegar valores do usu√°rio
            const userBand = bandsToUse[band];
            const userValue = userBand?.percentage || userBand?.energy_db;
            
            // Pegar valores da refer√™ncia
            const refBand = ref.bands[band];
            const refValue = refBand?.percentage || refBand?.energy_db;
            
            if (Number.isFinite(userValue) && Number.isFinite(refValue)) {
                pushRow(
                    bandNames[band] || band,
                    userValue,
                    refValue,
                    3.0, // Toler√¢ncia de 3% para bandas
                    '%'
                );
                
                console.log(`üìä [BAND-${band}] User: ${userValue.toFixed(1)}% | Ref: ${refValue.toFixed(1)}%`);
            }
        });
    }
    // üéØ RENDERIZA√á√ÉO DE BANDAS COM ESTRUTURA ANTIGA (referenceComparison.comparison.spectralBands)
    else if (referenceBands && typeof referenceBands === 'object') {
        console.log('‚ö†Ô∏è [RENDER-REF-BANDS] Usando bandas de referenceComparison (estrutura antiga)');
        
        const bandNames = {
            sub: 'Sub (20‚Äì60Hz)',
            bass: 'Bass (60‚Äì150Hz)',
            lowMid: 'Low-Mid (150‚Äì500Hz)',
            mid: 'Mid (500‚Äì2kHz)',
            highMid: 'High-Mid (2‚Äì5kHz)',
            presence: 'Presence (5‚Äì10kHz)',
            air: 'Air (10‚Äì20kHz)'
        };
        
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            if (referenceBands[band]) {
                const data = referenceBands[band];
                pushRow(
                    bandNames[band] || band,
                    data.user,
                    data.reference,
                    3.0,
                    data.unit
                );
            }
        });
    } 
    // üéµ RENDERIZA√á√ÉO DE BANDAS EM MODO G√äNERO
    else if (bandsToUse && ref.bands) {
        const normMap = (analysis?.technicalData?.refBandTargetsNormalized?.mapping) || null;
        const showNorm = (typeof window !== 'undefined' && window.SHOW_NORMALIZED_REF_TARGETS === true && normMap);
        
        // Mapeamento de nomes amig√°veis para as bandas com ranges de frequ√™ncia
        const bandDisplayNames = {
            sub: 'Sub (20‚Äì60Hz)',
            bass: 'Bass (60‚Äì150Hz)', 
            lowMid: 'Low-Mid (150‚Äì500Hz)',
            mid: 'Mid (500‚Äì2kHz)',
            highMid: 'High-Mid (2‚Äì5kHz)',
            presence: 'Presence (5‚Äì10kHz)',
            air: 'Air (10‚Äì20kHz)',
            brilho: 'Air (10‚Äì20kHz)'
        };
        
        // üéØ PROCESSAMENTO CORRIGIDO: Iterar por bandas de refer√™ncia e mapear para dados calculados
        console.log('üîÑ Processando bandas com mapeamento corrigido...');
        
        // üõ°Ô∏è FALLBACK: Verificar se ref.bands existe antes de iterar
        if (!ref.bands || typeof ref.bands !== 'object') {
            console.warn('‚ö†Ô∏è [REF-COMP] Fallback triggered (missing bands) - ref.bands n√£o existe');
            ref.bands = {}; // Criar objeto vazio para evitar erro
        }
        
        for (const [refBandKey, refBand] of Object.entries(ref.bands)) {
            // Encontrar a banda calculada correspondente
            const calcBandKey = bandMappingRefToCalc[refBandKey] || refBandKey;
            let bLocal = null;
            
            console.log(`üîç [BANDS] Processando: ${refBandKey} ‚Üí ${calcBandKey}`);
            
            // üéØ NOVO: Busca melhorada com sistema de alias
            const searchBandData = (bandKey) => {
                // Buscar diretamente
                if (centralizedBands && centralizedBands[bandKey]) {
                    return { rms_db: centralizedBands[bandKey].energy_db, source: 'centralized' };
                }
                if (legacyBandEnergies && legacyBandEnergies[bandKey]) {
                    return { ...legacyBandEnergies[bandKey], source: 'legacy' };
                }
                
                // Buscar por alias
                if (bandAliases[bandKey]) {
                    for (const alias of bandAliases[bandKey]) {
                        if (centralizedBands && centralizedBands[alias]) {
                            console.log(`üîÑ [ALIAS] ${bandKey} ‚Üí ${alias} (centralized)`);
                            return { rms_db: centralizedBands[alias].energy_db, source: 'centralized-alias' };
                        }
                        if (legacyBandEnergies && legacyBandEnergies[alias]) {
                            console.log(`üîÑ [ALIAS] ${bandKey} ‚Üí ${alias} (legacy)`);
                            return { ...legacyBandEnergies[alias], source: 'legacy-alias' };
                        }
                    }
                }
                
                return null;
            };
            
            // Buscar dados da banda
            bLocal = searchBandData(calcBandKey);
            
            // Se n√£o encontrou, tentar busca direta pela chave de refer√™ncia
            if (!bLocal) {
                bLocal = searchBandData(refBandKey);
                if (bLocal) {
                    console.log(`‚ö†Ô∏è [BANDS] Fallback para chave de refer√™ncia: ${refBandKey}`);
                }
            }
            
            // üéØ TRATAMENTO SILENCIOSO: Ignorar bandas n√£o encontradas sem erro
            if (!bLocal || !Number.isFinite(bLocal.rms_db)) {
                console.log(`üîá [BANDS] Ignorando banda inexistente: ${refBandKey} / ${calcBandKey}`);
                continue; // Pular silenciosamente
            }
            
            // Banda encontrada - processar normalmente
            console.log(`‚úÖ [BANDS] Encontrado ${refBandKey}: ${bLocal.rms_db}dB (${bLocal.source})`);
            
            // Log de valida√ß√£o entre sistemas
            if (typeof window !== 'undefined' && window.METRICS_BANDS_VALIDATION !== false && 
                bLocal.source === 'centralized' && legacyBandEnergies?.[calcBandKey]) {
                const legacyValue = legacyBandEnergies[calcBandKey].rms_db;
                if (Number.isFinite(legacyValue) && Math.abs(bLocal.rms_db - legacyValue) > 0.01) {
                    console.warn(`üéØ BAND_DIFF: ${calcBandKey} centralized=${bLocal.rms_db} vs legacy=${legacyValue}`);
                }
            }
            
            // üéØ NOVO: Determinar target e toler√¢ncia com helpers
            let tgt = null;
            let tolerance = null;
            
            // Prioridade 1: target_range (usar helpers para formata√ß√£o e toler√¢ncia)
            if (refBand.target_range && typeof refBand.target_range === 'object' &&
                Number.isFinite(refBand.target_range.min) && Number.isFinite(refBand.target_range.max)) {
                tgt = refBand.target_range;
                // ‚úÖ CORRIGIDO: Usar deriveTolerance() ao inv√©s de 0
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`üéØ [BANDS-FORMAT] Usando target_range para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            // Prioridade 2: target_db fixo
            else if (!refBand._target_na && Number.isFinite(refBand.target_db)) {
                tgt = refBand.target_db;
                // ‚úÖ CORRIGIDO: Usar deriveTolerance() com fallback
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`üéØ [BANDS-FORMAT] Usando target_db fixo para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            
            // Prioridade 3: Targets normalizados (se habilitado)
            if (showNorm && normMap && Number.isFinite(normMap[refBandKey])) {
                tgt = normMap[refBandKey];
                console.log(`üéØ [BANDS] Sobrescrevendo com target normalizado para ${refBandKey}: ${tgt}`);
            }
            
            // Nome para exibi√ß√£o
            const displayName = bandDisplayNames[calcBandKey] || bandDisplayNames[refBandKey] || refBandKey;
            
            // ‚úÖ CORRIGIDO: Usar centerOfRange para c√°lculo de delta
            const targetCenter = centerOfRange(tgt) ?? tgt ?? null;
            console.log(`üìä [BANDS] Adicionando: ${displayName}, valor: ${bLocal.rms_db}dB, target: ${formatTarget(tgt)}, tol: ${tolerance}`);
            
            // üéØ Passar targetCenter (n√∫mero) para c√°lculo correto de delta em pushRow
            pushRow(displayName, bLocal.rms_db, tgt, tolerance, ' dB');
        }
        
        // üéØ PROCESSAMENTO DE BANDAS EXTRAS: Bandas calculadas que n√£o est√£o na refer√™ncia
        console.log('üîÑ Verificando bandas extras n√£o mapeadas...');
        
        if (bandsToUse) {
            Object.keys(bandsToUse).forEach(calcBandKey => {
                // Filtrar chaves inv√°lidas (totais, metadados etc.)
                if (calcBandKey === '_status' || 
                    calcBandKey === 'totalPercentage' || 
                    calcBandKey === 'totalpercentage' ||
                    calcBandKey === 'metadata' ||
                    calcBandKey === 'total' ||
                    calcBandKey.toLowerCase().includes('total')) {
                    return; // Pular esta banda
                }
                
                // Verificar se esta banda j√° foi processada
                const refBandKey = bandMappingCalcToRef[calcBandKey];
                const alreadyProcessed = refBandKey && ref.bands[refBandKey];
                
                if (!alreadyProcessed) {
                    console.log(`üîç Processando banda extra: ${calcBandKey}`);
                    
                    const bandData = bandsToUse[calcBandKey];
                    let energyDb = null;
                    
                    if (typeof bandData === 'object' && Number.isFinite(bandData.energy_db)) {
                        energyDb = bandData.energy_db;
                    } else if (typeof bandData === 'object' && Number.isFinite(bandData.rms_db)) {
                        energyDb = bandData.rms_db;
                    } else if (Number.isFinite(bandData)) {
                        energyDb = bandData;
                    }
                    
                    if (Number.isFinite(energyDb)) {
                        const displayName = bandDisplayNames[calcBandKey] || 
                                          `${calcBandKey.charAt(0).toUpperCase() + calcBandKey.slice(1)} (Nova Banda)`;
                        
                        // Tentar buscar refer√™ncia direta por chave
                        const directRefData = ref.bands?.[calcBandKey];
                        let target = null;
                        let tolerance = null;
                        
                        // [BANDS-TOL-0] Suporte h√≠brido: target_range ou target_db (SEM TOLER√ÇNCIA)
                        if (directRefData?.target_range && typeof directRefData.target_range === 'object' &&
                            Number.isFinite(directRefData.target_range.min) && Number.isFinite(directRefData.target_range.max)) {
                            target = directRefData.target_range;
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        } else if (Number.isFinite(directRefData?.target_db)) {
                            target = { min: directRefData.target_db, max: directRefData.target_db };
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        }
                        
                        console.log(`üìä Adicionando banda extra: ${displayName}, valor: ${energyDb}dB, target: ${target || 'N/A'}`);
                        pushRow(displayName, energyDb, target, tolerance, ' dB');
                        
                        if (!target) {
                            console.warn(`‚ö†Ô∏è Banda sem refer√™ncia: ${calcBandKey} (valor: ${energyDb}dB)`);
                        }
                    }
                }
            });
        }
    } else {
        // Fallback melhorado: buscar todas as bandas espectrais dispon√≠veis
        const spectralBands = tech.spectral_balance || 
                            tech.spectralBands || 
                            analysis.metrics?.bands || {};
        
        // üéØ MAPEAMENTO COMPLETO com corre√ß√£o de nomes
        const bandMap = {
            sub: { refKey: 'sub', name: 'Sub (20‚Äì60Hz)', range: '20‚Äì60Hz' },
            bass: { refKey: 'low_bass', name: 'Bass (60‚Äì150Hz)', range: '60‚Äì150Hz' },
            lowMid: { refKey: 'low_mid', name: 'Low-Mid (150‚Äì500Hz)', range: '150‚Äì500Hz' },
            mid: { refKey: 'mid', name: 'Mid (500‚Äì2kHz)', range: '500‚Äì2000Hz' },
            highMid: { refKey: 'high_mid', name: 'High-Mid (2‚Äì5kHz)', range: '2000‚Äì5000Hz' },
            presence: { refKey: 'presenca', name: 'Presence (5‚Äì10kHz)', range: '5000‚Äì10000Hz' },
            air: { refKey: 'brilho', name: 'Air (10‚Äì20kHz)', range: '10000‚Äì20000Hz' }
        };
        
        // üéØ NOVO PROCESSAMENTO MODE-AWARE com resolver
        console.log('üîÑ Processando bandas espectrais (mode-aware resolver)...', {
            renderMode,
            hasRefBands: !!ref?.bands,
            refBandsKeys: ref?.bands ? Object.keys(ref.bands) : [],
            spectralBandsKeys: Object.keys(spectralBands),
            stateRefAnalysis: !!state?.reference?.analysis?.bands
        });
        
        if (spectralBands && Object.keys(spectralBands).length > 0) {
            // üéØ PATCH B: Extra√ß√£o de bandas mode-aware com bloqueio de fallback
            // isReferenceMode j√° definido no escopo superior
            
            let refBands = null;
            let userBands = null;
            
            if (isReferenceMode) {
                // 2¬™ faixa: refer√™ncia/alvo
                const refTech = opts?.referenceAnalysis?.technicalData
                             || state?.referenceAnalysis?.technicalData
                             || state?.reference?.referenceAnalysis?.technicalData
                             || referenceComparisonMetrics?.target
                             || referenceComparisonMetrics?.userFull?.technicalData /* legado confuso */ 
                             || null;
                
                // 1¬™ faixa: base/origem
                const userTech = opts?.userAnalysis?.technicalData
                              || state?.userAnalysis?.technicalData
                              || state?.reference?.userAnalysis?.technicalData
                              || referenceComparisonMetrics?.analyzed
                              || referenceComparisonMetrics?.referenceFull?.technicalData /* legado confuso */
                              || null;
                
                // üîç EXTRA√á√ÉO DE refBands com fallback seguro (NUNCA usar ranges de g√™nero)
                refBands = refTech?.spectral_balance ||
                          opts?.referenceAnalysis?.bands ||
                          opts?.referenceAnalysis?.frequencyBands ||
                          state?.referenceAnalysis?.bands ||
                          state?.referenceAnalysis?.frequencyBands ||
                          null;
                
                userBands = userTech?.spectral_balance || null;
                
                console.log('[REF-FLOW] bands sources', {
                    userBands: !!userBands, 
                    refBands: !!refBands,
                    userBandsKeys: userBands ? Object.keys(userBands).slice(0, 5) : [],
                    refBandsKeys: refBands ? Object.keys(refBands).slice(0, 5) : []
                });
                
                if (!refBands) {
                    console.error("üö® [REF-ERROR] Nenhum dado de bandas encontrado na refer√™ncia.");
                    console.error('[CRITICAL] Reference mode sem bandas da 2¬™ faixa! Abortando render.');
                    console.error('[CRITICAL] Proibido fallback de g√™nero no reference mode');
                    if (container) {
                        container.innerHTML = '<div style="color:red;">‚ùå Erro: bandas de refer√™ncia n√£o dispon√≠veis</div>';
                    }
                    return;
                }
                
                console.log("‚úÖ [AUDIT_REF_FIX] referenceAnalysis spectral_balance pronto:", refBands);
            } else {
                // GENRE: aqui SIM usa ranges de __activeRefData
                refBands  = (__activeRefData && __activeRefData.bands) || null;
                userBands = (analysis?.technicalData?.spectral_balance) || spectralBands || null;
            }
            
            // Conjunto para rastrear bandas j√° processadas
            const processedBandKeys = new Set();
            
            // üéØ Iterar por todas as bandas do usu√°rio
            const bandsToIterate = userBands || spectralBands;
            for (const rawKey of Object.keys(bandsToIterate)) {
                if (IGNORE_BANDS.has(rawKey) || processedBandKeys.has(rawKey)) continue;
                
                const bandKey = normalizeBandKey(rawKey);
                const userVal = pickNumeric(bandsToIterate[rawKey]);
                
                if (userVal === null) continue; // Sem valor do usu√°rio
                
                let targetDisplay = '‚Äî';
                let valueDisplay = '‚Äî';
                let deltaDisplay = '‚Äî';
                let targetValue = null;
                let tolDisplay = null;
                
                if (isReferenceMode) {
                    const refVal = getReferenceBandValue(refBands, bandKey); // retorna n√∫mero (dB) ou null
                    const userValCalc = getReferenceBandValue(userBands, bandKey);
                    
                    if (refVal == null) {
                        console.warn('[REF-FLOW] Banda sem valor na 2¬™ faixa:', bandKey);
                        targetDisplay = '‚Äî';
                        targetValue = null;
                    } else {
                        targetDisplay = formatDb(refVal);
                        targetValue = refVal;
                    }
                    
                    valueDisplay = (userValCalc == null) ? '‚Äî' : formatDb(userValCalc);
                    deltaDisplay = (userValCalc == null || refVal == null) ? '‚Äî' : formatDb(userValCalc - refVal);
                    tolDisplay = 0; // Sem toler√¢ncia em compara√ß√£o direta
                    
                } else {
                    // GENRE: range do JSON de g√™nero
                    const r = getGenreTargetRange(refBands, bandKey);
                    if (r) {
                        targetDisplay = `${formatDb(r.min)} a ${formatDb(r.max)}`;
                        targetValue = { min: r.min, max: r.max };
                        tolDisplay = r.tol;
                    } else {
                        targetDisplay = '‚Äî';
                        targetValue = null;
                    }
                    valueDisplay = formatDb(userVal);
                    deltaDisplay = '‚Äî'; // (delta num√©rico n√£o se aplica a range)
                }
                
                // üéØ Adicionar linha na tabela
                const label = bandMap[bandKey]?.name || `${bandKey.toUpperCase()}`;
                pushRow(label, userVal, targetValue, tolDisplay, ' dB');
                processedBandKeys.add(rawKey);
                processedBandKeys.add(bandKey);
            }
            
            console.log(`‚úÖ [BANDS-PROCESSED] ${processedBandKeys.size} bandas processadas no modo ${renderMode}`);
        } else {
            // Fallback para tonalBalance simplificado (mantido para compatibilidade)
            const tb = tech.tonalBalance || {};
            const legacyBandMap = { sub:'sub', low:'low_bass', mid:'mid', high:'brilho' };
            Object.entries(legacyBandMap).forEach(([tbKey, refBand]) => {
                const bData = tb[tbKey];
                const refBandData = ref.bands?.[refBand];
                if (bData && refBandData && Number.isFinite(bData.rms_db)) {
                    console.log(`üìä Banda legacy: ${tbKey.toUpperCase()}, valor: ${bData.rms_db}dB, target: ${refBandData.target_db}dB`);
                    pushRow(`${tbKey.toUpperCase()}`, bData.rms_db, refBandData.target_db, refBandData.tol_db, ' dB');
                }
            });
        }
    }
    
    // üéØ LOG DE RESUMO: Bandas processadas com sucesso
    const bandasDisponiveis = ref.bands ? Object.keys(ref.bands).length : 0;
    const bandasProcessadas = rows.length - 5; // Subtrair m√©tricas b√°sicas (LUFS, Peak, DR, LRA, Stereo)
    
    console.log('üìä [BANDS] Resumo do processamento de bandas:', {
        bandas_na_referencia: bandasDisponiveis,
        bandas_processadas: Math.max(0, bandasProcessadas),
        metricas_totais: rows.length,
        centralized_bands_ok: !!centralizedBands,
        legacy_bands_ok: !!legacyBandEnergies,
        modo_referencia: isReferenceMode
    });
    
    // üéØ [A/B-TABLE-FIX] CORRE√á√ÉO CR√çTICA: Renderizar tabela A/B com 2 colunas independentes
    // Modo REFERENCE: Extrair m√©tricas de userAnalysis (1¬™ faixa) e referenceAnalysis (2¬™ faixa)
    
    let abTableHTML = '';
    
    if (isReferenceMode && opts.userAnalysis && opts.referenceAnalysis) {
        console.log('üéØ [A/B-TABLE-FIX] Renderizando tabela A/B com 2 colunas independentes');
        
        const userTech = opts.userAnalysis.technicalData || {};
        const refTech = opts.referenceAnalysis.technicalData || {};
        
        // üéØ ASSERT CR√çTICO: Garantir que m√©tricas s√£o DIFERENTES
        if (userTech.lufsIntegrated === refTech.lufsIntegrated &&
            userTech.dynamicRange === refTech.dynamicRange &&
            userTech.truePeakDbtp === refTech.truePeakDbtp) {
            console.error('‚ùå [A/B-TABLE-FIX] ERRO CR√çTICO: user/ref metrics ID√äNTICAS - DOM duplicado ou fonte errada!');
            console.table({
                'User LUFS': userTech.lufsIntegrated,
                'Ref LUFS': refTech.lufsIntegrated,
                'User DR': userTech.dynamicRange,
                'Ref DR': refTech.dynamicRange,
                'User Peak': userTech.truePeakDbtp,
                'Ref Peak': refTech.truePeakDbtp
            });
            container.innerHTML = '<div class="card" style="margin-top:12px;"><div style="color:red;padding:20px;">‚ùå ERRO: M√©tricas id√™nticas detectadas. Recarregue a p√°gina.</div></div>';
            return;
        }
        
        // Helper format
        const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '‚Äî';
        
        // üéØ Helper para calcular status e cor baseado na diferen√ßa
        const getStatusAndColor = (diff, tolerance = 0.5) => {
            if (!Number.isFinite(diff)) {
                return { class: '', text: 'N/A', color: 'rgba(255,255,255,0.3)' };
            }
            
            const absDiff = Math.abs(diff);
            
            // L√≥gica adaptativa baseada no tipo de m√©trica
            if (absDiff <= tolerance) {
                // ‚úÖ IDEAL
                return { 
                    class: 'ok', 
                    text: 'Ideal',
                    icon: '‚úÖ'
                };
            } else if (absDiff <= tolerance * 6) {
                // ‚ö†Ô∏è AJUSTE LEVE
                return { 
                    class: 'yellow', 
                    text: 'Ajuste leve',
                    icon: '‚ö†Ô∏è'
                };
            } else {
                // ‚ùå CORRIGIR
                return { 
                    class: 'warn', 
                    text: 'Corrigir',
                    icon: '‚ùå'
                };
            }
        };
        
        // Construir linhas A/B com Delta e Status
        const abRows = [];
        
        const addABRow = (label, userVal, refVal, unit = '', dataMetric = '', tolerance = 0.5) => {
            const dataAttr = dataMetric ? ` data-metric="${dataMetric}"` : '';
            
            // Calcular diferen√ßa (Faixa 1 - Faixa 2)
            let delta = null;
            let deltaText = '‚Äî';
            
            if (Number.isFinite(userVal) && Number.isFinite(refVal)) {
                delta = userVal - refVal;
                const sign = delta > 0 ? '+' : '';
                deltaText = `${sign}${nf(delta)}${unit}`;
            }
            
            // Obter status e classe CSS
            const status = getStatusAndColor(delta, tolerance);
            
            abRows.push(`<tr${dataAttr}>
                <td class="metric-name">${label}</td>
                <td class="ab-user"${dataAttr}>${Number.isFinite(userVal) ? nf(userVal) + unit : '‚Äî'}</td>
                <td class="ab-ref"${dataAttr}>${Number.isFinite(refVal) ? nf(refVal) + unit : '‚Äî'}</td>
                <td class="delta-col">${deltaText}</td>
                <td class="status-col ${status.class}">
                    <div class="diff-cell-content">
                        <span class="diff-value">${status.icon}</span>
                        <span class="diff-status">${status.text}</span>
                    </div>
                </td>
            </tr>`);
        };
        
        // ===== M√âTRICAS PRINCIPAIS =====
        addABRow('Loudness (LUFS)', userTech.lufsIntegrated, refTech.lufsIntegrated, ' LUFS', 'lufs', 0.5);
        addABRow('True Peak (dBTP)', userTech.truePeakDbtp, refTech.truePeakDbtp, ' dBTP', 'truepeak', 0.3);
        addABRow('Dynamic Range (LU)', userTech.dynamicRange, refTech.dynamicRange, ' LU', 'dr', 1.0);
        addABRow('LRA (LU)', userTech.lra, refTech.lra, ' LU', 'lra', 1.0);
        addABRow('Stereo Corr.', userTech.stereoCorrelation, refTech.stereoCorrelation, '', 'stereo', 0.08);
        
        // ===== BANDAS ESPECTRAIS =====
        const userBands = userTech.spectral_balance || {};
        const refBands = refTech.spectral_balance || {};
        
        const bandNames = {
            sub: 'Sub (20-60Hz)',
            bass: 'Bass (60-150Hz)',
            lowMid: 'Low-Mid (150-500Hz)',
            mid: 'Mid (500-2kHz)',
            highMid: 'High-Mid (2-5kHz)',
            presence: 'Presence (5-10kHz)',
            air: 'Air (10-20kHz)'
        };
        
        Object.entries(bandNames).forEach(([key, name]) => {
            const userVal = userBands[key]?.energy_db ?? userBands[key]?.percentage ?? userBands[key];
            const refVal = refBands[key]?.energy_db ?? refBands[key]?.percentage ?? refBands[key];
            if (Number.isFinite(userVal) || Number.isFinite(refVal)) {
                addABRow(name, userVal, refVal, ' dB', `band-${key}`, 1.0);
            }
        });
        
        // Nomes das faixas
        const userName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || '1¬™ Faixa';
        const refName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || '2¬™ Faixa';
        
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title" style="
                background: linear-gradient(90deg, #7F00FF, #00FFFF);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                font-size: clamp(15px, 1.3vw, 18px);
                font-weight: 700;
                margin-bottom: 12px;
            ">üéµ COMPARA√á√ÉO A/B ENTRE FAIXAS</div>
            
            <!-- Header com nomes das faixas - Compacto e elegante -->
            <div class="ab-header" style="
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 10px; 
                padding: 10px; 
                background: linear-gradient(90deg, rgba(127, 0, 255, 0.08), rgba(0, 255, 255, 0.08));
                border-radius: 8px; 
                margin-bottom: 10px;
                border: 1px solid rgba(127, 0, 255, 0.12);
            ">
                <div class="track-name user-track" style="
                    padding: 8px 10px;
                    background: rgba(82, 247, 173, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #52f7ad;
                    box-shadow: 0 2px 6px rgba(82, 247, 173, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">üéß</span>
                        <span>Faixa 1</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${userName}</div>
                </div>
                <div class="track-name ref-track" style="
                    padding: 8px 10px;
                    background: rgba(255, 206, 77, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #ffce4d;
                    box-shadow: 0 2px 6px rgba(255, 206, 77, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">üéöÔ∏è</span>
                        <span>Faixa 2</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${refName}</div>
                </div>
            </div>
            
            <!-- Tabela de compara√ß√£o - Refinada e compacta -->
            <table class="ref-compare-table ab-compare-table" style="width: 100%;">
                <thead>
                    <tr>
                        <th style="text-align: left; padding-left: 12px;">M√©trica</th>
                        <th class="ab-user-header">Faixa 1</th>
                        <th class="ab-ref-header">Faixa 2</th>
                        <th>Œî</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="ab-comparison-body">${abRows.join('')}</tbody>
            </table>
        </div>`;
        
        // üéØ LOG DE VALIDA√á√ÉO P√ìS-RENDER
        console.group('üéØ [A/B-TABLE-VALIDATION] Valida√ß√£o p√≥s-renderiza√ß√£o');
        console.log('USER LUFS:', userTech.lufsIntegrated);
        console.log('REF LUFS:', refTech.lufsIntegrated);
        console.log('USER DR:', userTech.dynamicRange);
        console.log('REF DR:', refTech.dynamicRange);
        console.log('USER TruePeak:', userTech.truePeakDbtp);
        console.log('REF TruePeak:', refTech.truePeakDbtp);
        console.groupEnd();
        
    } else {
        // Modo GENRE ou fallback: usar tabela antiga
        console.warn('‚ö†Ô∏è [A/B-TABLE-FIX] Modo GENRE ou dados incompletos - usando tabela de refer√™ncia padr√£o');
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title">COMPARA√á√ÉO DE REFER√äNCIA (${titleText})</div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>M√©trica</th><th>Valor</th><th>Alvo</th><th>Œî</th>
                </tr></thead>
                <tbody>${rows.join('') || '<tr><td colspan="4" style="opacity:.6">Sem m√©tricas dispon√≠veis</td></tr>'}</tbody>
            </table>
        </div>`;
    }
    
    container.innerHTML = abTableHTML;
    
    // üéØ FOR√áAR VISIBILIDADE DA TABELA EM AMBOS OS MODOS
    console.log('[UI_RENDER] For√ßando renderiza√ß√£o da tabela comparativa');
    const tableEl = document.getElementById('referenceComparisons');
    if (tableEl) {
        tableEl.classList.remove('hidden');
        tableEl.style.display = ''; // Limpa inline display:none
        tableEl.style.visibility = 'visible';
        tableEl.style.opacity = '1';
        console.log('‚úÖ [RENDER-REF] Tabela for√ßada para vis√≠vel (mode:', renderMode, ')');
        
        // üéØ [DOM-VALIDATION] ASSERT CR√çTICO: Verificar que elementos A/B s√£o DISTINTOS
        if (isReferenceMode) {
            setTimeout(() => {
                const userLufsEl = document.querySelector('.ab-user[data-metric="lufs"]');
                const refLufsEl = document.querySelector('.ab-ref[data-metric="lufs"]');
                
                console.group('üéØ [DOM-VALIDATION] Verifica√ß√£o de elementos A/B');
                console.log('User LUFS Element:', userLufsEl);
                console.log('Ref LUFS Element:', refLufsEl);
                console.log('S√£o o mesmo elemento?', userLufsEl === refLufsEl);
                console.log('User LUFS innerHTML:', userLufsEl?.innerHTML);
                console.log('Ref LUFS innerHTML:', refLufsEl?.innerHTML);
                
                if (userLufsEl === refLufsEl) {
                    console.error('‚ùå [DOM-VALIDATION] ERRO CR√çTICO: Elementos .ab-user e .ab-ref s√£o o MESMO objeto!');
                } else if (!userLufsEl || !refLufsEl) {
                    console.error('‚ùå [DOM-VALIDATION] ERRO: Elementos n√£o encontrados no DOM!');
                } else {
                    console.log('‚úÖ [DOM-VALIDATION] Elementos A/B s√£o DISTINTOS e independentes');
                }
                console.groupEnd();
            }, 100);
        }
    } else {
        console.error('‚ùå [RENDER-REF] Elemento #referenceComparisons N√ÉO encontrado no DOM!');
    }
    
    // üéØ Verificar se wrapper/parent tamb√©m est√° vis√≠vel
    const wrapper = tableEl?.parentElement;
    if (wrapper) {
        wrapper.classList.remove('hidden');
        wrapper.classList.add('visible');
        wrapper.style.display = '';
    }
    
    // üõ°Ô∏è PASSO 3: VERIFICA√á√ÉO FINAL
    console.log('üéØ [AUDITORIA_REF] Compara√ß√£o de refer√™ncia renderizada com sucesso');
    console.log('üéØ [AUDITORIA_REF] Targets usados:', {
        lufs: lufsTarget,
        truePeak: tpTarget,
        dr: drTarget,
        lra: lraTarget,
        stereo: stereoTarget,
        totalRows: rows.length
    });
    
    // üéØ LOG FINAL DE SUCESSO COMPLETO
    console.log('‚úÖ [REF-COMP] renderReferenceComparisons SUCCESS', {
        mode: renderMode,
        usedReferenceAnalysis: !!analysis.referenceAnalysis,
        bandsResolved: ref.bands ? Object.keys(ref.bands).length : 0,
        rowsGenerated: rows.length,
        titleDisplayed: titleText,
        tableVisible: renderMode === 'reference'
    });
    
    // üéØ LOG FINAL DE VERIFICA√á√ÉO (conforme solicitado)
    console.log('[FINAL-CHECK] renderReferenceComparisons conclu√≠do com', {
        mode: renderMode,
        bands: Object.keys(ref?.bands || {}),
        bandsCount: Object.keys(ref?.bands || {}).length,
        tableVisible: !!document.querySelector('#referenceComparisons'),
        tableHasContent: rows.length > 0,
        userMetricsLoaded: !!userMetrics,
        refMetricsLoaded: !!ref,
        titleText: titleText
    });
    
    // ‚úÖ DESBLOQUEIO DO MODAL - Finalizar loading e exibir resultados
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (loading) {
        loading.style.display = 'none';
        console.log('[MODAL-FIX] ‚úÖ Loading ocultado');
    }
    
    if (results) {
        results.style.display = 'block';
        console.log('[MODAL-FIX] ‚úÖ Resultados exibidos');
    }
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        console.log('[MODAL-FIX] ‚úÖ Upload area ocultada');
    }
    
    console.log('[MODAL-FIX] ‚úÖ Loading encerrado com sucesso - modal desbloqueado');
    
    // Estilos injetados uma vez com indicadores visuais melhorados
    if (!document.getElementById('refCompareStyles')) {
        const style = document.createElement('style');
        style.id = 'refCompareStyles';
        style.textContent = `
        .ref-compare-table{width:100%;border-collapse:collapse;font-size:11px;}
        .ref-compare-table th{font-weight:500;padding:4px 6px;border-bottom:1px solid rgba(255,255,255,.12);font-size:11px;color:#fff;letter-spacing:.3px;}
        .ref-compare-table th:first-child{text-align:left;}
        .ref-compare-table th:not(:first-child){text-align:center;}
        .ref-compare-table td{padding:5px 6px;border-bottom:1px solid rgba(255,255,255,.06);color:#f5f7fa;} 
        .ref-compare-table td:first-child{text-align:left;}
        .ref-compare-table td:not(:first-child){text-align:center;}
        .ref-compare-table tr:last-child td{border-bottom:0;} 
        .ref-compare-table td.ok{color:#52f7ad;font-weight:600;} 
        .ref-compare-table td.ok::before{content:'‚úÖ ';margin-right:2px;}
        .ref-compare-table td.yellow{color:#ffce4d;font-weight:600;} 
        .ref-compare-table td.yellow::before{content:'‚ö†Ô∏è ';margin-right:2px;}
        .ref-compare-table td.warn{color:#ff7b7b;font-weight:600;} 
        .ref-compare-table td.warn::before{content:'‚ùå ';margin-right:2px;}
        .ref-compare-table .tol{opacity:.7;margin-left:4px;font-size:10px;color:#b8c2d6;} 
        .ref-compare-table tbody tr:hover td{background:rgba(255,255,255,.04);} 
        `;
        document.head.appendChild(style);
    }
    
    // üéØ ESTILOS DA TABELA CL√ÅSSICA DE G√äNERO
    if (!document.getElementById('classicGenreStyles')) {
        const genreStyle = document.createElement('style');
        genreStyle.id = 'classicGenreStyles';
        genreStyle.textContent = `
        .classic-genre-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .classic-genre-table th {
            font-weight: 600;
            padding: 6px 8px;
            border-bottom: 2px solid rgba(255,255,255,.15);
            font-size: 11px;
            color: #fff;
            text-align: left;
            letter-spacing: .5px;
            background: rgba(0,0,0,.2);
        }
        .classic-genre-table tbody tr {
            transition: background .2s ease;
        }
        .classic-genre-table tbody tr:hover {
            background: rgba(255,255,255,.05);
        }
        .classic-genre-table td {
            padding: 7px 8px;
            border-bottom: 1px solid rgba(255,255,255,.08);
            font-size: 11px;
        }
        .classic-genre-table tr:last-child td {
            border-bottom: 0;
        }
        
        /* üéØ CORES DE SEVERIDADE */
        .classic-genre-table .genre-row.ok {
            background: rgba(82, 247, 173, .05);
        }
        .classic-genre-table .genre-row.ok:hover {
            background: rgba(82, 247, 173, .12);
        }
        .classic-genre-table .genre-row.caution {
            background: rgba(255, 206, 77, .08);
        }
        .classic-genre-table .genre-row.caution:hover {
            background: rgba(255, 206, 77, .15);
        }
        .classic-genre-table .genre-row.warning {
            background: rgba(255, 165, 0, .1);
        }
        .classic-genre-table .genre-row.warning:hover {
            background: rgba(255, 165, 0, .18);
        }
        .classic-genre-table .genre-row.critical {
            background: rgba(255, 82, 82, .12);
        }
        .classic-genre-table .genre-row.critical:hover {
            background: rgba(255, 82, 82, .2);
        }
        
        /* üéØ COLUNAS ESPEC√çFICAS */
        .classic-genre-table .metric-name {
            font-weight: 500;
            color: #e1e8f0;
        }
        .classic-genre-table .metric-value {
            font-weight: 600;
            color: #52f7ad;
            text-align: center;
        }
        .classic-genre-table .metric-target {
            color: #9ca9ba;
            text-align: center;
            font-size: 10px;
        }
        .classic-genre-table .metric-diff {
            text-align: center;
            font-weight: 600;
        }
        .classic-genre-table .metric-diff.positive {
            color: #ff8a80;
        }
        .classic-genre-table .metric-diff.negative {
            color: #80d8ff;
        }
        .classic-genre-table .metric-severity {
            text-align: center;
            font-weight: 700;
            font-size: 10px;
            letter-spacing: .8px;
        }
        .classic-genre-table .metric-severity.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-severity.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-severity.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-severity.critical {
            color: #ff5252;
        }
        .classic-genre-table .metric-action {
            text-align: center;
            font-size: 10px;
            font-weight: 500;
        }
        .classic-genre-table .metric-action.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-action.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-action.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-action.critical {
            color: #ff5252;
        }
        `;
        document.head.appendChild(genreStyle);
    }
    
    // Garantir que o CSS do priority-banner esteja dispon√≠vel no modal
    if (!document.getElementById('priorityBannerStyles')) {
        const priorityStyle = document.createElement('style');
        priorityStyle.id = 'priorityBannerStyles';
        priorityStyle.textContent = `
        .priority-banner {
            display: flex !important;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            font-weight: 700;
            background: linear-gradient(90deg, #ff006a, #ff9800) !important;
            color: #fff !important;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 106, 0.3);
            animation: pulsePriority 1.5s infinite alternate;
            position: relative;
            z-index: 10;
        }
        
        .priority-icon {
            font-size: 20px;
            line-height: 1;
        }
        
        @keyframes pulsePriority {
            from { opacity: 0.8; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1.02); }
        }
        `;
        document.head.appendChild(priorityStyle);
    }
    
    // üîì CORRE√á√ÉO CR√çTICA: Liberar comparisonLock ao final da renderiza√ß√£o
    window.comparisonLock = false;
    console.log('[FIX-AUDIT] ‚úÖ comparisonLock liberado ap√≥s renderiza√ß√£o completa');
    console.log('[FIX-AUDIT] ‚úÖ RenderReferenceComparisons auditado e restaurado com sucesso');
    console.log('[FIX-AUDIT] ‚úÖ userBands e refBands preservadas');
    console.log('[FIX-AUDIT] ‚úÖ Render completo no modo reference');
    console.log('[FIX-AUDIT] ‚úÖ Cards e sugest√µes renderizados ap√≥s compara√ß√£o');
    console.groupEnd(); // Fecha [SAFE_RENDER_REF]
    
    // ==== PATCH 2 FINAL: Valida√ß√£o e limpeza ====
    if (opts.usedReferenceAnalysis !== true) {
        console.error("[REF-PATCH] usedReferenceAnalysis caiu pra false ‚Äî bug de wiring");
        throw new Error("Reference not used");
    }
    window.__refRenderInProgress = false;
}

// üîí C√ìPIA IMUT√ÅVEL DA FUN√á√ÉO ORIGINAL displayModalResults
// Esta c√≥pia garante que interceptadores sempre tenham acesso √† fun√ß√£o original
if (!window.__displayModalResultsOriginal) {
    console.log('[FIX] üîí Criando c√≥pia imut√°vel de displayModalResults');
    window.__displayModalResultsOriginal = displayModalResults;
    Object.freeze(window.__displayModalResultsOriginal);
    console.log('[FIX] ‚úÖ C√≥pia imut√°vel criada: window.__displayModalResultsOriginal');
}

/**
 * üéØ RENDERIZA√á√ÉO DE COMPARA√á√ÉO ENTRE DUAS FAIXAS
 * Exibe tabela comparativa lado a lado: Faixa 1 (refer√™ncia) vs Faixa 2 (usu√°rio)
 * @param {Object} referenceAnalysis - Dados da primeira faixa (refer√™ncia)
 * @param {Object} currentAnalysis - Dados da segunda faixa (usu√°rio)
 */
function renderTrackComparisonTable(baseAnalysis, referenceAnalysis) {
    // üéØ PAR√ÇMETROS CORRIGIDOS:
    // baseAnalysis = primeira faixa (alvo/base da compara√ß√£o)
    // referenceAnalysis = segunda faixa (atual/sendo comparada)
    
    console.log('üéØ [TRACK-COMPARE] Renderizando tabela comparativa entre faixas');
    console.log('üìä [TRACK-COMPARE] Base (1¬™ faixa - ALVO):', baseAnalysis);
    console.log('üìä [TRACK-COMPARE] Atual (2¬™ faixa - COMPARADA):', referenceAnalysis);
    
    // üéØ Definir modo reference no estado
    const state = window.__soundyState || {};
    state.render = state.render || {};
    state.render.mode = 'reference';
    console.log('‚úÖ [TRACK-COMPARE] Modo definido como reference no estado');
    
    // üéØ LOG AUDIT-MODE-FLOW (conforme solicitado)
    console.log('[AUDIT-MODE-FLOW]', {
        mode: state.render.mode,
        isSecondTrack: state.reference?.isSecondTrack,
        refJobId: state.reference?.jobId,
        hasRefAnalysis: !!state.reference?.analysis
    });
    
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('‚ùå Container referenceComparisons n√£o encontrado');
        return;
    }
    
    // üî• CORRE√á√ÉO: Usar dados DIRETOS do backend (sem reconstru√ß√£o)
    // ref = primeira faixa (BASE/ALVO)
    // curr = segunda faixa (ATUAL/COMPARADA)
    const ref = baseAnalysis; // ‚úÖ LEITURA DIRETA
    const curr = referenceAnalysis; // ‚úÖ LEITURA DIRETA
    
    const refTech = ref.technicalData || {};
    const currTech = curr.technicalData || {};
    
    // Helper para comparar valores e calcular status
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '‚Äî';
    const calcDiffPercent = (curr, ref) => {
        if (!Number.isFinite(curr) || !Number.isFinite(ref) || ref === 0) return null;
        return ((curr - ref) / Math.abs(ref)) * 100;
    };
    
    const getStatus = (diffPercent, tolerance = 10) => {
        if (diffPercent === null) return { class: '', text: 'N/A' };
        const absDiff = Math.abs(diffPercent);
        if (absDiff <= tolerance) return { class: 'ok', text: '‚úÖ Ideal' };
        if (absDiff <= tolerance * 2) return { class: 'yellow', text: '‚ö†Ô∏è Ajuste leve' };
        return { class: 'warn', text: '‚ùå Corrigir' };
    };
    
    // Construir linhas da tabela
    const rows = [];
    
    // Fun√ß√£o auxiliar para adicionar linha
    const addRow = (label, currVal, refVal, unit = '', tolerance = 10) => {
        const diffPercent = calcDiffPercent(currVal, refVal);
        const status = getStatus(diffPercent, tolerance);
        const diffText = diffPercent !== null ? `${diffPercent > 0 ? '+' : ''}${nf(diffPercent, 1)}%` : '‚Äî';
        
        rows.push(`<tr>
            <td>${label}</td>
            <td>${Number.isFinite(currVal) ? nf(currVal) + unit : '‚Äî'}</td>
            <td>${Number.isFinite(refVal) ? nf(refVal) + unit : '‚Äî'}</td>
            <td>${diffText}</td>
            <td class="${status.class}">${status.text}</td>
        </tr>`);
    };
    
    // ===== M√âTRICAS PRINCIPAIS =====
    addRow('Loudness (LUFS)', currTech.lufsIntegrated || currTech.lufs_integrated, 
           refTech.lufsIntegrated || refTech.lufs_integrated, ' LUFS', 5);
    
    addRow('True Peak (dBTP)', currTech.truePeakDbtp || currTech.true_peak_dbtp,
           refTech.truePeakDbtp || refTech.true_peak_dbtp, ' dBTP', 10);
    
    addRow('Dynamic Range (LU)', currTech.dynamicRange || currTech.dynamic_range,
           refTech.dynamicRange || refTech.dynamic_range, ' LU', 15);
    
    addRow('LRA (LU)', currTech.lra, refTech.lra, ' LU', 15);
    
    addRow('Stereo Correlation', currTech.stereoCorrelation || currTech.stereo_correlation,
           refTech.stereoCorrelation || refTech.stereo_correlation, '', 8);
    
    addRow('Spectral Centroid (Hz)', currTech.spectralCentroidHz || currTech.spectral_centroid,
           refTech.spectralCentroidHz || refTech.spectral_centroid, ' Hz', 10);
    
    // ===== BANDAS ESPECTRAIS =====
    const currBands = currTech.spectral_balance || {};
    const refBands = refTech.spectral_balance || {};
    
    const bandNames = {
        sub: 'Sub (20-60Hz)',
        bass: 'Bass (60-150Hz)',
        lowMid: 'Low-Mid (150-500Hz)',
        mid: 'Mid (500-2kHz)',
        highMid: 'High-Mid (2-5kHz)',
        presence: 'Presence (5-10kHz)',
        air: 'Air (10-20kHz)'
    };
    
    Object.entries(bandNames).forEach(([key, name]) => {
        const currVal = currBands[key]?.percentage;
        const refVal = refBands[key]?.percentage;
        if (Number.isFinite(currVal) && Number.isFinite(refVal)) {
            addRow(name, currVal, refVal, '%', 10);
        }
    });
    
    // Calcular scores comparativos
    const refScore = ref.score || 0;
    const currScore = curr.score || 0;
    const scoreDiff = currScore - refScore;
    
    // Montar HTML da tabela
    // üéØ LABELS DIN√ÇMICOS: Primeira faixa = BASE/ALVO, Segunda faixa = ATUAL
    container.innerHTML = `
        <div class="card" style="margin-top:12px;">
            <div class="card-title">üéµ COMPARA√á√ÉO ENTRE FAIXAS (Modo Reference)</div>
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 12px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA BASE (1¬™ - ALVO)</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${ref.metadata?.fileName || ref.fileName || 'Primeira Faixa'}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: #52f7ad;">${nf(refScore, 0)}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA DE REFER√äNCIA (2¬™ - ATUAL)</div>
                        <div style="font-weight: 600; font-size: 14px;">
                            ${curr.metadata?.fileName || curr.fileName || 'Segunda Faixa'}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: ${scoreDiff >= 0 ? '#52f7ad' : '#ff7b7b'};">${nf(currScore, 0)}</span>
                            <span style="opacity: 0.7; margin-left: 4px;">(${scoreDiff > 0 ? '+' : ''}${nf(scoreDiff, 0)})</span>
                        </div>
                    </div>
                </div>
            </div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>M√©trica</th>
                    <th>Faixa 2 (Ref/Atual)</th>
                    <th>Faixa 1 (Base/Alvo)</th>
                    <th>Diferen√ßa (%)</th>
                    <th>Status</th>
                </tr></thead>
                <tbody>${rows.join('')}</tbody>
            </table>
        </div>
    `;
    
    // üéØ AUDIT_REF_FIX: Log final de confirma√ß√£o do fluxo A/B
    // üîí GUARD: S√≥ executar logs de refer√™ncia se viewMode === "reference"
    if (getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('‚úÖ [TRACK-COMPARE] Tabela comparativa renderizada com sucesso');
        console.log('[REFERENCE-A/B FIXED ‚úÖ] Compara√ß√£o A/B entre faixas conclu√≠da');
        console.log('[AUDIT_REF_FIX] Tabela exibindo valores brutos da segunda faixa (refer√™ncia real)');
        console.log('[MODE LOCKED] reference - renderiza√ß√£o completa sem altera√ß√£o de modo');
        
        // üéâ LOG FINAL DE AUDITORIA
        console.log("‚úÖ [REFERENCE-A/B FIXED] Compara√ß√£o renderizada sem erros.");
        console.log("‚úÖ [AUDITORIA_FINAL_RENDER_REF] Render conclu√≠do com sucesso.");
    } else {
        console.log('[REFERENCE-GUARD] üö´ Logs de refer√™ncia bloqueados (viewMode:', getViewMode(), ')');
    }
    
    // üéØ VALIDA√á√ÉO FINAL P√ìS-FIX
    const validationData = {
        userTrack: ref.metadata?.fileName || ref.fileName || 'Primeira Faixa',
        refTrack: curr.metadata?.fileName || curr.fileName || 'Segunda Faixa',
        userLUFS: ref.technicalData?.lufsIntegrated || ref.technicalData?.lufs_integrated || 'N/A',
        refLUFS: curr.technicalData?.lufsIntegrated || curr.technicalData?.lufs_integrated || 'N/A',
        userDR: ref.technicalData?.dynamicRange || ref.technicalData?.dynamic_range || 'N/A',
        refDR: curr.technicalData?.dynamicRange || curr.technicalData?.dynamic_range || 'N/A',
        userPeak: ref.technicalData?.truePeakDbtp || ref.technicalData?.true_peak_dbtp || 'N/A',
        refPeak: curr.technicalData?.truePeakDbtp || curr.technicalData?.true_peak_dbtp || 'N/A',
        render: 'conclu√≠do sem erros'
    };
    
    console.log('‚úÖ [VALIDA√á√ÉO-FINAL] Modal Reference OK:', validationData);
    
    // ‚úÖ Libera lock ap√≥s renderiza√ß√£o
    window.comparisonLock = false;
    console.log("[LOCK] comparisonLock liberado");
    
    console.groupEnd();
}

// üéØ ===== SISTEMA DE SCORING AVAN√áADO =====
// Sistema completo de pontua√ß√£o por categorias com adapta√ß√£o por g√™nero

// 1. PESOS POR G√äNERO (ATUALIZADOS CONFORME ESPECIFICA√á√ÉO)
const GENRE_SCORING_WEIGHTS = {
    // Funk Mandela - Foco em Loudness e Din√¢mica
    'funk_mandela': {
        loudness: 0.32,    // Loudness cr√≠tico no funk
        dinamica: 0.23,    // Din√¢mica importante
        frequencia: 0.20,  // Frequ√™ncia equilibrada
        estereo: 0.15,     // Est√©reo moderado
        tecnico: 0.10      // T√©cnico b√°sico
    },
    
    // Funk Automotivo (similar ao Mandela)
    'funk_automotivo': {
        loudness: 0.32,
        dinamica: 0.23,
        frequencia: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Trap/Trance - Foco em Loudness e Frequ√™ncia
    'trap': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // Frequ√™ncia cr√≠tica
        estereo: 0.20,     // Est√©reo importante
        dinamica: 0.15,    // Din√¢mica moderada
        tecnico: 0.10      // T√©cnico b√°sico
    },
    
    'trance': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // Frequ√™ncia cr√≠tica
        estereo: 0.20,     // Est√©reo importante
        dinamica: 0.15,    // Din√¢mica moderada
        tecnico: 0.10      // T√©cnico b√°sico
    },
    
    // Eletr√¥nico - Foco em Frequ√™ncia e Est√©reo
    'eletronico': {
        frequencia: 0.30,  // Frequ√™ncia cr√≠tica
        estereo: 0.25,     // Est√©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // Din√¢mica moderada
        tecnico: 0.10      // T√©cnico b√°sico
    },
    
    // Funk Bruxaria - Similar ao Eletr√¥nico
    'funk_bruxaria': {
        frequencia: 0.30,  // Frequ√™ncia cr√≠tica
        estereo: 0.25,     // Est√©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // Din√¢mica moderada
        tecnico: 0.10      // T√©cnico b√°sico
    },
    
    // Hip Hop - Balanceado entre Frequ√™ncia e Din√¢mica
    'hip_hop': {
        frequencia: 0.30,
        dinamica: 0.25,
        loudness: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Pesos padr√£o (fallback) - Distribui√ß√£o equilibrada
    'default': {
        loudness: 0.25,
        frequencia: 0.25,
        dinamica: 0.20,
        estereo: 0.15,
        tecnico: 0.15
    }
};

// 2. FUN√á√ÉO PARA CALCULAR SCORE DE UMA M√âTRICA (VERS√ÉO MENOS PUNITIVA)
function calculateMetricScore(actualValue, targetValue, tolerance) {
    // Verificar se temos valores v√°lidos
    if (!Number.isFinite(actualValue) || !Number.isFinite(targetValue) || !Number.isFinite(tolerance) || tolerance <= 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff: 'N/A (valida√ß√£o falhou)',
                tolerance,
                result: null,
                condition: 'valida√ß√£o falhou',
                reason: !Number.isFinite(actualValue) ? 'actualValue inv√°lido' : 
                        !Number.isFinite(targetValue) ? 'targetValue inv√°lido' : 
                        !Number.isFinite(tolerance) ? 'tolerance inv√°lido' : 
                        'tolerance <= 0'
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (valida√ß√£o)', err);
        }
        return null; // M√©trica inv√°lida
    }
    
    const diff = Math.abs(actualValue - targetValue);
    
    // üéØ DENTRO DA TOLER√ÇNCIA = 100 pontos
    if (diff <= tolerance) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff,
                tolerance,
                result: 100,
                condition: 'diff <= tolerance',
                ratio: diff / tolerance
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (dentro toler√¢ncia)', err);
        }
        return 100;
    }
    
    // üéØ CURVA DE PENALIZA√á√ÉO MAIS JUSTA - GRADUAL E MENOS PUNITIVA
    // Œî at√© 1.5x toler√¢ncia ‚Üí ~80
    // Œî at√© 2x toler√¢ncia ‚Üí ~60  
    // Œî at√© 3x toler√¢ncia ‚Üí ~40
    // Œî acima de 3x toler√¢ncia ‚Üí ~20 (nunca zerar)
    
    const ratio = diff / tolerance;
    let result;
    
    if (ratio <= 1.5) {
        // Entre 1x e 1.5x toler√¢ncia: decaimento suave de 100 para 80
        result = Math.round(100 - ((ratio - 1) * 40)); // 100 - (0.5 * 40) = 80 no m√°ximo
    } else if (ratio <= 2.0) {
        // Entre 1.5x e 2x toler√¢ncia: de 80 para 60
        result = Math.round(80 - ((ratio - 1.5) * 40)); // 80 - (0.5 * 40) = 60 no m√°ximo
    } else if (ratio <= 3.0) {
        // Entre 2x e 3x toler√¢ncia: de 60 para 40
        result = Math.round(60 - ((ratio - 2) * 20)); // 60 - (1 * 20) = 40 no m√°ximo
    } else {
        // Acima de 3x toler√¢ncia: 20 (nunca zerar totalmente)
        result = 20;
    }
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateMetricScore',
            value: actualValue,
            target: targetValue,
            diff,
            tolerance,
            result,
            condition: 'diff > tolerance',
            ratio,
            penaltyLevel: ratio <= 1.5 ? '1-1.5x' : ratio <= 2.0 ? '1.5-2x' : ratio <= 3.0 ? '2-3x' : '>3x'
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateMetricScore (penaliza√ß√£o)', err);
    }
    
    return result;
}

// 3. CALCULAR SCORE DE LOUDNESS (LUFS, True Peak, Crest Factor)
function calculateLoudnessScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // LUFS Integrado (m√©trica principal de loudness)
    const lufsValue = metrics.lufs_integrated || tech.lufsIntegrated;
    if (Number.isFinite(lufsValue) && Number.isFinite(refData.lufs_target) && Number.isFinite(refData.tol_lufs)) {
        const score = calculateMetricScore(lufsValue, refData.lufs_target, refData.tol_lufs);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä LUFS: ${lufsValue} vs ${refData.lufs_target} (¬±${refData.tol_lufs}) = ${score}%`);
        }
    }
    
    // True Peak (importante para evitar clipping digital)
    const truePeakValue = metrics.true_peak_dbtp || tech.truePeakDbtp;
    if (Number.isFinite(truePeakValue) && Number.isFinite(refData.true_peak_target) && Number.isFinite(refData.tol_true_peak)) {
        const score = calculateMetricScore(truePeakValue, refData.true_peak_target, refData.tol_true_peak);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä True Peak: ${truePeakValue} vs ${refData.true_peak_target} (¬±${refData.tol_true_peak}) = ${score}%`);
        }
    }
    
    // Crest Factor (din√¢mica de picos)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Crest Factor: ${crestValue} vs ${refData.crest_target} (¬±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar m√©dia dos scores v√°lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateLoudnessScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`üîä Score Loudness Final: ${result}% (m√©dia de ${scores.length} m√©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateLoudnessScore',
            value: { lufs: metrics.lufs_integrated || tech.lufsIntegrated, truePeak: metrics.true_peak_dbtp || tech.truePeakDbtp, crest: tech.crestFactor || metrics.crest_factor },
            target: { lufs: refData.lufs_target, truePeak: refData.true_peak_target, crest: refData.crest_target },
            diff: 'ver logs individuais',
            tolerance: { lufs: refData.tol_lufs, truePeak: refData.tol_true_peak, crest: refData.tol_crest },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (final)', err);
    }
    
    return result;
}

// 4. CALCULAR SCORE DE DIN√ÇMICA (LRA, DR, Crest Consistency, Fator de Crista)
function calculateDynamicsScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // Dynamic Range (DR) - m√©trica principal de din√¢mica
    const drValue = metrics.dynamic_range || tech.dynamicRange;
    if (Number.isFinite(drValue) && Number.isFinite(refData.dr_target) && Number.isFinite(refData.tol_dr)) {
        const score = calculateMetricScore(drValue, refData.dr_target, refData.tol_dr);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Dynamic Range: ${drValue} vs ${refData.dr_target} (¬±${refData.tol_dr}) = ${score}%`);
        }
    }
    
    // LRA (Loudness Range) - varia√ß√£o de loudness
    const lraValue = metrics.lra || tech.lra;
    if (Number.isFinite(lraValue) && Number.isFinite(refData.lra_target) && Number.isFinite(refData.tol_lra)) {
        const score = calculateMetricScore(lraValue, refData.lra_target, refData.tol_lra);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä LRA: ${lraValue} vs ${refData.lra_target} (¬±${refData.tol_lra}) = ${score}%`);
        }
    }
    
    // Crest Factor (j√° inclu√≠do em Loudness, mas importante para din√¢mica tamb√©m)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Crest Factor (Din√¢mica): ${crestValue} vs ${refData.crest_target} (¬±${tolerance}) = ${score}%`);
        }
    }
    
    // Compress√£o detectada (se dispon√≠vel)
    const compressionRatio = tech.compressionRatio;
    if (Number.isFinite(compressionRatio) && refData.compression_target && Number.isFinite(refData.compression_target)) {
        const tolerance = refData.tol_compression || 1.0;
        const score = calculateMetricScore(compressionRatio, refData.compression_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Compress√£o: ${compressionRatio} vs ${refData.compression_target} (¬±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar m√©dia dos scores v√°lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateDynamicsScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`üìä Score Din√¢mica Final: ${result}% (m√©dia de ${scores.length} m√©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateDynamicsScore',
            value: { dr: metrics.dynamic_range || tech.dynamicRange, lra: metrics.lra || tech.lra, crest: tech.crestFactor || metrics.crest_factor, compression: tech.compressionRatio },
            target: { dr: refData.dr_target, lra: refData.lra_target, crest: refData.crest_target, compression: refData.compression_target },
            diff: 'ver logs individuais',
            tolerance: { dr: refData.tol_dr, lra: refData.tol_lra, crest: refData.tol_crest, compression: refData.tol_compression },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (final)', err);
    }
    
    return result;
}

// 5. CALCULAR SCORE DE EST√âREO (Largura, Correla√ß√£o, Balan√ßo L/R)
function calculateStereoScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // Correla√ß√£o Est√©reo (principal m√©trica de est√©reo)
    const stereoValue = metrics.stereo_correlation || tech.stereoCorrelation;
    if (Number.isFinite(stereoValue) && Number.isFinite(refData.stereo_target) && Number.isFinite(refData.tol_stereo)) {
        const score = calculateMetricScore(stereoValue, refData.stereo_target, refData.tol_stereo);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Correla√ß√£o Est√©reo: ${stereoValue} vs ${refData.stereo_target} (¬±${refData.tol_stereo}) = ${score}%`);
        }
    }
    
    // Largura Est√©reo (Width)
    const widthValue = tech.stereoWidth || metrics.stereo_width;
    if (Number.isFinite(widthValue) && refData.width_target && Number.isFinite(refData.width_target)) {
        const tolerance = refData.tol_width || 0.2;
        const score = calculateMetricScore(widthValue, refData.width_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Largura Est√©reo: ${widthValue} vs ${refData.width_target} (¬±${tolerance}) = ${score}%`);
        }
    }
    
    // Balan√ßo L/R (se dispon√≠vel)
    const balanceValue = tech.stereoBalance || metrics.stereo_balance;
    if (Number.isFinite(balanceValue)) {
        // Balan√ßo ideal √© 0 (perfeitamente centrado)
        const balanceTarget = refData.balance_target || 0.0;
        const balanceTolerance = refData.tol_balance || 0.1; // 10% de toler√¢ncia
        const score = calculateMetricScore(balanceValue, balanceTarget, balanceTolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Balan√ßo L/R: ${balanceValue} vs ${balanceTarget} (¬±${balanceTolerance}) = ${score}%`);
        }
    }
    
    // Separa√ß√£o de canais (se dispon√≠vel)
    const separationValue = tech.channelSeparation || metrics.channel_separation;
    if (Number.isFinite(separationValue) && refData.separation_target && Number.isFinite(refData.separation_target)) {
        const tolerance = refData.tol_separation || 5.0;
        const score = calculateMetricScore(separationValue, refData.separation_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`üìä Separa√ß√£o de Canais: ${separationValue} vs ${refData.separation_target} (¬±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar m√©dia dos scores v√°lidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateStereoScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateStereoScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`üéß Score Est√©reo Final: ${result}% (m√©dia de ${scores.length} m√©tricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateStereoScore',
            value: { correlation: metrics.stereo_correlation || tech.stereoCorrelation, width: tech.stereoWidth || metrics.stereo_width, balance: tech.stereoBalance || metrics.stereo_balance, separation: tech.channelSeparation || metrics.channel_separation },
            target: { correlation: refData.stereo_target, width: refData.width_target, balance: refData.balance_target, separation: refData.separation_target },
            diff: 'ver logs individuais',
            tolerance: { correlation: refData.tol_stereo, width: refData.tol_width, balance: refData.tol_balance, separation: refData.tol_separation },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateStereoScore (final)', err);
    }
    
    return result;
}

// 6. CALCULAR SCORE DE FREQU√äNCIA (BANDAS ESPECTRAIS)
function calculateFrequencyScore(analysis, refData) {
    if (!analysis || !refData || !refData.bands) return null;
    
    // üéØ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode n√£o existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const bandsToUse = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    console.log('[FREQ-SCORE] üéµ Fonte de bandas:', 
        technicalBands ? '‚úÖ technicalData.bands (prioridade 1)' : 
        centralizedBands ? '‚ö†Ô∏è metrics.bands (fallback 2)' : 
        spectralBalance ? '‚ö†Ô∏è spectral_balance (fallback 3)' : 
        '‚ö†Ô∏è bandEnergies (fallback 4 - legado)');
    
    console.log('[FREQ-SCORE] üéµ Bandas dispon√≠veis:', bandsToUse ? Object.keys(bandsToUse) : 'NENHUMA');
    
    if (!bandsToUse) return null;
    
    const scores = [];
    const isReferenceMode = refData._isReferenceMode === true;
    
    console.log('üéµ Calculando Score de Frequ√™ncia...', {
        mode: isReferenceMode ? 'REFERENCE (valores diretos)' : 'GENRE (target_range)',
        bandsAvailable: Object.keys(refData.bands)
    });
    
    // Mapeamento das bandas calculadas para refer√™ncia (exatamente as 7 bandas da tabela UI)
    const bandMapping = {
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid',
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho'
    };
    
    // Processar cada banda individualmente
    Object.entries(bandMapping).forEach(([calcBand, refBand]) => {
        // üéØ BUSCA EM CASCATA com ALIAS (branch imersao)
        const bandData = getBandDataWithCascade(calcBand, analysis);
        
        // üîá TRATAMENTO SILENCIOSO: ignorar bandas ausentes (branch imersao)
        if (!bandData || !Number.isFinite(bandData.energy_db)) {
            console.log(`üîá [SCORE-FREQ] Ignorando banda inexistente: ${calcBand}`);
            return; // ‚úÖ continue silencioso
        }
        
        const refBandData = refData.bands[refBand];
        
        if (refBandData) {
            const energyDb = bandData.energy_db;
            
            console.log(`[SCORE-FREQ] ‚úÖ ${calcBand}: ${energyDb.toFixed(2)} dB (${bandData.source})`);
            
            // üéØ CORRE√á√ÉO CR√çTICA: Detectar modo e usar valores apropriados
            let targetDb = null;
            let tolDb = null;
            
            if (isReferenceMode) {
                // üëâ MODO REFERENCE: Usar valor DIRETO da faixa de refer√™ncia (n√£o target_range)
                if (typeof refBandData === 'object' && Number.isFinite(refBandData.energy_db)) {
                    targetDb = refBandData.energy_db;
                } else if (typeof refBandData === 'object' && Number.isFinite(refBandData.rms_db)) {
                    targetDb = refBandData.rms_db;
                } else if (Number.isFinite(refBandData)) {
                    targetDb = refBandData;
                }
                // ¬±3 dB √© uma toler√¢ncia auditiva/operacional razo√°vel para bandas agregadas.
                tolDb = 3.0;
                
                if (targetDb !== null) {
                    console.log(`üéØ [SCORE-FREQ-REF] ${calcBand}: comparando com faixa de refer√™ncia ‚Üí target=${targetDb.toFixed(1)}dB (valor real), tol=0dB`);
                } else {
                    console.warn(`‚ö†Ô∏è [SCORE-FREQ-REF] ${calcBand}: sem valor na faixa de refer√™ncia`);
                }
            } else {
                // üëâ MODO GENRE: Usar target_range dos targets de g√™nero
                if (refBandData.target_range && typeof refBandData.target_range === 'object' &&
                    Number.isFinite(refBandData.target_range.min) && Number.isFinite(refBandData.target_range.max)) {
                    // Novo sistema: calcular alvo e toler√¢ncia a partir do range
                    targetDb = (refBandData.target_range.min + refBandData.target_range.max) / 2;
                    tolDb = (refBandData.target_range.max - refBandData.target_range.min) / 2;
                    console.log(`üéØ [SCORE-FREQ-GENRE] ${calcBand}: usando target_range [${refBandData.target_range.min}, ${refBandData.target_range.max}] ‚Üí target=${targetDb.toFixed(1)}dB, tol=${tolDb.toFixed(1)}dB`);
                } else if (Number.isFinite(refBandData.target_db) && Number.isFinite(refBandData.tol_db)) {
                    // Sistema legado
                    targetDb = refBandData.target_db;
                    tolDb = refBandData.tol_db;
                    console.log(`üéØ [SCORE-FREQ-GENRE] ${calcBand}: usando target_db=${targetDb}dB, tol_db=${tolDb}dB`);
                }
            }
            
            // Calcular score individual da banda
            if (Number.isFinite(targetDb) && Number.isFinite(tolDb)) {
                const score = calculateMetricScore(energyDb, targetDb, tolDb);
                if (score !== null) {
                    scores.push(score);
                    const delta = Math.abs(energyDb - targetDb);
                    const status = delta <= tolDb ? '‚úÖ' : '‚ùå';
                    console.log(`üéµ ${calcBand.toUpperCase()}: ${energyDb.toFixed(1)}dB vs ${targetDb.toFixed(1)}dB (¬±${tolDb.toFixed(1)}dB) = ${score}% ${status}`);
                }
            }
        }
    });
    
    // Se n√£o encontrou scores v√°lidos, retornar null
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateFrequencyScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0,
                isReferenceMode,
                bandsAvailable: refData.bands ? Object.keys(refData.bands) : []
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateFrequencyScore (no scores)', err);
        }
        return null;
    }
    
    // M√©dia aritm√©tica simples das bandas v√°lidas
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    
    console.log(`üéµ Score Frequ√™ncia Final: ${result}% (m√©dia de ${scores.length} bandas)`);
    console.log(`üéµ Scores individuais: [${scores.join(', ')}]`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateFrequencyScore',
            value: 'bandas espectrais (ver logs individuais)',
            target: 'bandas de refer√™ncia',
            diff: 'ver logs individuais por banda',
            tolerance: isReferenceMode ? '0 (modo reference)' : 'target_range',
            result,
            condition: 'average of ' + scores.length + ' bands',
            individualScores: scores,
            average,
            isReferenceMode,
            bandsProcessed: scores.length
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateFrequencyScore (final)', err);
    }
    
    return result;
}

// 7. CALCULAR SCORE T√âCNICO
// 7. CALCULAR SCORE T√âCNICO (Clipping, DC Offset, THD)
function calculateTechnicalScore(analysis, refData) {
    if (!analysis) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    console.log('üîß Calculando Score T√©cnico...');
    
    // 1. CLIPPING - Deve ser pr√≥ximo de 0% (PENALIZA√á√ÉO FORTE PARA PROBLEMAS CR√çTICOS)
    const clippingValue = tech.clipping || metrics.clipping || 0;
    if (Number.isFinite(clippingValue)) {
        let clippingScore = 100;
        
        if (clippingValue <= 0.001) { // ‚â§ 0.1% = perfeito
            clippingScore = 100;
        } else if (clippingValue <= 0.005) { // ‚â§ 0.5% = bom
            clippingScore = 80;
        } else if (clippingValue <= 0.01) { // ‚â§ 1% = aceit√°vel
            clippingScore = 60;
        } else if (clippingValue <= 0.02) { // ‚â§ 2% = problem√°tico
            clippingScore = 40;
        } else { // > 2% = cr√≠tico
            clippingScore = 20;
        }
        
        scores.push(clippingScore);
        console.log(`üîß Clipping: ${(clippingValue * 100).toFixed(3)}% = ${clippingScore}%`);
    }
    
    // 2. DC OFFSET - Deve ser pr√≥ximo de 0
    const dcOffsetValue = Math.abs(tech.dcOffset || metrics.dc_offset || 0);
    if (Number.isFinite(dcOffsetValue)) {
        let dcScore = 100;
        
        if (dcOffsetValue <= 0.001) { // ‚â§ 0.1% = perfeito
            dcScore = 100;
        } else if (dcOffsetValue <= 0.005) { // ‚â§ 0.5% = bom
            dcScore = 80;
        } else if (dcOffsetValue <= 0.01) { // ‚â§ 1% = aceit√°vel
            dcScore = 60;
        } else if (dcOffsetValue <= 0.02) { // ‚â§ 2% = problem√°tico
            dcScore = 40;
        } else { // > 2% = cr√≠tico
            dcScore = 20;
        }
        
        scores.push(dcScore);
        console.log(`üîß DC Offset: ${dcOffsetValue.toFixed(4)} = ${dcScore}%`);
    }
    
    // 3. THD (Total Harmonic Distortion) - Deve ser baixo
    const thdValue = tech.thd || metrics.thd || 0;
    if (Number.isFinite(thdValue)) {
        let thdScore = 100;
        
        if (thdValue <= 0.001) { // ‚â§ 0.1% = perfeito
            thdScore = 100;
        } else if (thdValue <= 0.005) { // ‚â§ 0.5% = bom
            thdScore = 80;
        } else if (thdValue <= 0.01) { // ‚â§ 1% = aceit√°vel
            thdScore = 60;
        } else if (thdValue <= 0.02) { // ‚â§ 2% = problem√°tico
            thdScore = 40;
        } else { // > 2% = cr√≠tico
            thdScore = 20;
        }
        
        scores.push(thdScore);
        console.log(`üîß THD: ${(thdValue * 100).toFixed(3)}% = ${thdScore}%`);
    }
    
    // 4. PROBLEMAS DETECTADOS (Issues) - PENALIZA√á√ÉO GRADUAL
    const issues = analysis.issues || [];
    let issuesScore = 100;
    
    issues.forEach(issue => {
        switch (issue.severity) {
            case 'critical':
                issuesScore = Math.max(20, issuesScore - 30); // N√£o zerar, m√≠nimo 20
                console.log(`üîß Issue CR√çTICO: ${issue.description} (-30%)`);
                break;
            case 'high':
                issuesScore = Math.max(40, issuesScore - 20); // M√≠nimo 40
                console.log(`üîß Issue ALTO: ${issue.description} (-20%)`);
                break;
            case 'medium':
                issuesScore = Math.max(60, issuesScore - 10); // M√≠nimo 60
                console.log(`üîß Issue M√âDIO: ${issue.description} (-10%)`);
                break;
            case 'low':
                issuesScore = Math.max(80, issuesScore - 5); // M√≠nimo 80
                console.log(`üîß Issue BAIXO: ${issue.description} (-5%)`);
                break;
        }
    });
    
    if (issues.length > 0) {
        scores.push(issuesScore);
        console.log(`üîß Issues Gerais: ${issuesScore}% (${issues.length} problemas)`);
    }
    
    // üéØ NOVA VALIDA√á√ÉO TRUE PEAK (CORRE√á√ÉO CR√çTICA)
    const truePeak = tech.truePeakDbtp || metrics.truePeakDbtp;
    let truePeakScore = 100; // Score padr√£o se n√£o houver dados
    let hasTruePeakData = false;
    
    if (Number.isFinite(truePeak)) {
        hasTruePeakData = true;
        console.log(`üîß True Peak: ${truePeak.toFixed(2)} dBTP`);
        
        if (truePeak <= -1.5) { // Excelente
            truePeakScore = 100;
            console.log(`üîß True Peak EXCELENTE: ${truePeakScore}%`);
        } else if (truePeak <= -1.0) { // Ideal
            truePeakScore = 90;
            console.log(`üîß True Peak IDEAL: ${truePeakScore}%`);
        } else if (truePeak <= -0.5) { // Bom
            truePeakScore = 80;
            console.log(`üîß True Peak BOM: ${truePeakScore}%`);
        } else if (truePeak <= 0.0) { // Aceit√°vel
            truePeakScore = 70;
            console.log(`üîß True Peak ACEIT√ÅVEL: ${truePeakScore}%`);
        } else if (truePeak <= 0.5) { // Problem√°tico
            truePeakScore = 40;
            console.log(`üîß True Peak PROBLEM√ÅTICO: ${truePeakScore}%`);
        } else { // Cr√≠tico
            truePeakScore = 20;
            console.log(`üîß True Peak CR√çTICO: ${truePeakScore}%`);
        }
        
        scores.push(truePeakScore);
    }
    
    // Se n√£o temos m√©tricas t√©cnicas espec√≠ficas, usar apenas issues
    if (scores.length === 0) {
        const result = Math.max(20, Math.round(issuesScore)); // Nunca zerar
        console.log(`üîß Score T√©cnico Final (apenas issues): ${result}%`);
        return result;
    }
    
    // M√©dia normalizada de todas as m√©tricas t√©cnicas (0-100)
    let average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    let result = Math.max(20, Math.round(average)); // Nunca zerar completamente
    
    // üö® HARD CAP: True Peak ESTOURADO (> 0.0 dBTP) limita score a 60%
    if (hasTruePeakData && truePeak > 0.0) {
        const maxScoreWithClipping = 60;
        const originalResult = result;
        result = Math.min(result, maxScoreWithClipping);
        
        console.log(`üö® HARD CAP APLICADO: True Peak estourado (${truePeak.toFixed(2)} dBTP)`);
        console.log(`üö® Score limitado de ${originalResult}% para ${result}% (m√°x: ${maxScoreWithClipping}%)`);
    }
    
    console.log(`üîß Score T√©cnico Final: ${result}% (m√©dia de ${scores.length} m√©tricas${hasTruePeakData ? ', True Peak inclu√≠do' : ''})`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateTechnicalScore',
            value: { clipping: tech.clipping || metrics.clipping, dcOffset: tech.dcOffset || metrics.dc_offset, thd: tech.thd || metrics.thd, truePeak: truePeak, issues: issues.length },
            target: 'valores ideais (0 para clipping/dc/thd, <0 para truePeak)',
            diff: 'N/A (avalia√ß√£o por faixas)',
            tolerance: 'N/A',
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average,
            hasTruePeakData,
            hardCapApplied: hasTruePeakData && truePeak > 0.0
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateTechnicalScore (final)', err);
    }
    
    return result;
}

// 8. FUN√á√ÉO PRINCIPAL: CALCULAR TODOS OS SCORES
function calculateAnalysisScores(analysis, refData, genre = null) {
    console.log('üéØ Calculando scores da an√°lise...', { genre });
    
    // üéØ [FLOW-FIX] M√©tricas recebidas dentro de calculateAnalysisScores
    console.log("[FLOW-FIX] M√©tricas recebidas dentro de calculateAnalysisScores:", {
        loudness: analysis.loudness,
        metrics: analysis.metrics,
        technicalData: analysis.technicalData
    });
    
    // üéØ [GENRE-FIX] Targets finais entregues ao score
    console.log("[GENRE-FIX] Targets finais entregues ao score:", {
        lufs_target: refData?.lufs_target,
        true_peak_target: refData?.true_peak_target,
        dr_target: refData?.dr_target,
        stereo_target: refData?.stereo_target,
        lra_target: refData?.lra_target,
        bands: refData?.bands ? Object.keys(refData.bands) : null,
        bandsCount: refData?.bands ? Object.keys(refData.bands).length : 0
    });
    
    // üéØ MODO G√äNERO: Detectar se √© modo g√™nero e se h√° targets carregados
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    // üéØ MODO G√äNERO: Extrair targets de g√™nero de referenceComparison
    let genreTargetBands = null;
    let genreTargetMetrics = null;
    
    if (isGenreMode && analysis?.referenceComparison) {
        const refComp = analysis.referenceComparison;
        
        // Buscar em m√∫ltiplos locais poss√≠veis (estrutura varia entre JSONs)
        const genreKey = genre || analysis.genre || analysis.genreId;
        const genreData = genreKey ? refComp[genreKey] : null;
        
        // üéØ CORRE√á√ÉO CR√çTICA: Extrair bandas do ROOT primeiro
        if (genreData?.bands) {
            genreTargetBands = genreData.bands;
            console.log('‚úÖ [GENRE-TARGETS] Usando bands do ROOT (correto):', Object.keys(genreTargetBands));
        } else if (genreData?.legacy_compatibility?.bands) {
            genreTargetBands = genreData.legacy_compatibility.bands;
            console.log('‚ö†Ô∏è [GENRE-TARGETS] Usando legacy_compatibility.bands (fallback):', Object.keys(genreTargetBands));
        } else if (genreData?.hybrid_processing?.spectral_bands) {
            genreTargetBands = genreData.hybrid_processing.spectral_bands;
            console.log('‚ö†Ô∏è [GENRE-TARGETS] Usando hybrid_processing.spectral_bands (fallback):', Object.keys(genreTargetBands));
        } else if (refComp.bands) {
            genreTargetBands = refComp.bands;
            console.log('‚ö†Ô∏è [GENRE-TARGETS] Usando bands direto do refComp (fallback):', Object.keys(genreTargetBands));
        }
        
        // üéØ CORRE√á√ÉO CR√çTICA: Extrair m√©tricas escalares do ROOT primeiro
        if (genreData && genreData.lufs_target !== undefined) {
            // ROOT tem targets v√°lidos (estrutura correta V2)
            genreTargetMetrics = {
                lufs_target: genreData.lufs_target,
                true_peak_target: genreData.true_peak_target,
                dr_target: genreData.dr_target,
                lra_target: genreData.lra_target,
                stereo_target: genreData.stereo_target,
                tol_lufs: genreData.tol_lufs || 1.0,
                tol_true_peak: genreData.tol_true_peak || 0.25,
                tol_dr: genreData.tol_dr || 1.25,
                tol_lra: genreData.tol_lra || 2.5,
                tol_stereo: genreData.tol_stereo || 0.065
            };
            console.log('‚úÖ [GENRE-TARGETS] M√©tricas extra√≠das do ROOT (correto):', {
                lufs: genreTargetMetrics.lufs_target,
                peak: genreTargetMetrics.true_peak_target,
                dr: genreTargetMetrics.dr_target,
                stereo: genreTargetMetrics.stereo_target
            });
        } else if (genreData?.legacy_compatibility) {
            // Fallback: legacy_compatibility (estrutura antiga)
            const lc = genreData.legacy_compatibility;
            genreTargetMetrics = {
                lufs_target: lc.lufs_target,
                true_peak_target: lc.true_peak_target,
                dr_target: lc.dr_target,
                lra_target: lc.lra_target,
                stereo_target: lc.stereo_target,
                tol_lufs: lc.tol_lufs || 1.0,
                tol_true_peak: lc.tol_true_peak || 0.25,
                tol_dr: lc.tol_dr || 1.25,
                tol_lra: lc.tol_lra || 2.5,
                tol_stereo: lc.tol_stereo || 0.065
            };
            console.log('‚ö†Ô∏è [GENRE-TARGETS] M√©tricas extra√≠das de legacy_compatibility (fallback)');
        } else if (genreData?.hybrid_processing?.original_metrics) {
            // Fallback 2: hybrid_processing (estrutura h√≠brida)
            const om = genreData.hybrid_processing.original_metrics;
            genreTargetMetrics = {
                lufs_target: om.lufs_integrated,
                true_peak_target: om.true_peak_dbtp,
                dr_target: om.dynamic_range,
                lra_target: om.lra,
                stereo_target: om.stereo_correlation,
                tol_lufs: 1.0,
                tol_true_peak: 0.25,
                tol_dr: 1.25,
                tol_lra: 2.5,
                tol_stereo: 0.065
            };
            console.log('‚ö†Ô∏è [GENRE-TARGETS] M√©tricas extra√≠das de hybrid_processing.original_metrics (fallback)');
        }
        
        // üéØ INJETAR targets de g√™nero em refData se dispon√≠veis
        if (genreTargetBands && Object.keys(genreTargetBands).length > 0) {
            console.log('‚úÖ [GENRE-TARGETS] Injetando bandas de g√™nero em refData');
            refData = {
                ...refData,
                bands: genreTargetBands,
                _isReferenceMode: false, // N√ÉO √© modo A/B
                _isGenreMode: true,
                _genreTargetsLoaded: true
            };
            
            // Mesclar m√©tricas se dispon√≠veis
            if (genreTargetMetrics) {
                refData = { ...refData, ...genreTargetMetrics };
            }
        } else {
            console.warn('‚ö†Ô∏è [GENRE-TARGETS] Targets de g√™nero n√£o encontrados em referenceComparison');
        }
    }
    
    // üîç [AUDIT-BANDS-IN-CALC] Log NO IN√çCIO do c√°lculo de scores
    try {
        const refBandsInCalc = refData?.bands || refData?._referenceBands;
        const userBandsInCalc = analysis?.bands || analysis?.technicalData?.spectral_balance || analysis?.metrics?.bands;
        console.log('[AUDIT-BANDS-IN-CALC]', {
            calcHasRefBands: !!refBandsInCalc,
            calcHasUserBands: !!userBandsInCalc,
            refBandsType: typeof refBandsInCalc,
            userBandsType: typeof userBandsInCalc,
            refBandsKeys: refBandsInCalc ? Object.keys(refBandsInCalc) : [],
            userBandsKeys: userBandsInCalc ? Object.keys(userBandsInCalc) : [],
            refBandsSample: refBandsInCalc ? Object.keys(refBandsInCalc).slice(0, 3) : 'undefined',
            userBandsSample: userBandsInCalc ? Object.keys(userBandsInCalc).slice(0, 3) : 'undefined',
            refDataKeys: refData ? Object.keys(refData) : [],
            isReferenceMode: refData?._isReferenceMode,
            isGenreMode: isGenreMode,
            genreTargetsLoaded: refData?._genreTargetsLoaded
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-CALC', err);
    }
    
    if (!analysis || !refData) {
        console.warn('‚ö†Ô∏è Dados insuficientes para calcular scores');
        return null;
    }
    
    // Calcular sub-scores
    const loudnessScore = calculateLoudnessScore(analysis, refData);
    const dynamicsScore = calculateDynamicsScore(analysis, refData);
    const stereoScore = calculateStereoScore(analysis, refData);
    const frequencyScore = calculateFrequencyScore(analysis, refData);
    const technicalScore = calculateTechnicalScore(analysis, refData);
    
    console.log('üìä Sub-scores calculados:', {
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        estereo: stereoScore,
        frequencia: frequencyScore,
        tecnico: technicalScore
    });
    
    // Determinar pesos por g√™nero
    // üéØ CORRE√á√ÉO: N√£o usar 'default' como fallback, usar null
    const genreKey = genre ? genre.toLowerCase().replace(/\s+/g, '_') : null;
    
    if (!genreKey) {
        console.warn('[GET-BAND-LABEL] G√™nero n√£o fornecido, usando label gen√©rico');
    }
    const weights = GENRE_SCORING_WEIGHTS[genreKey] || GENRE_SCORING_WEIGHTS['default'];
    
    console.log('‚öñÔ∏è Pesos aplicados:', weights);
    
    // CORRE√á√ÉO: Calcular score final com valores cont√≠nuos
    let weightedSum = 0;
    let totalWeight = 0;
    
    // Somar apenas os scores que existem, ajustando os pesos dinamicamente
    if (loudnessScore !== null) {
        weightedSum += loudnessScore * weights.loudness;
        totalWeight += weights.loudness;
    }
    
    if (dynamicsScore !== null) {
        weightedSum += dynamicsScore * weights.dinamica;
        totalWeight += weights.dinamica;
    }
    
    if (stereoScore !== null) {
        weightedSum += stereoScore * weights.estereo;
        totalWeight += weights.estereo;
    }
    
    if (frequencyScore !== null) {
        weightedSum += frequencyScore * weights.frequencia;
        totalWeight += weights.frequencia;
    }
    
    if (technicalScore !== null) {
        weightedSum += technicalScore * weights.tecnico;
        totalWeight += weights.tecnico;
    }
    
    // Calcular score final normalizado (permite valores cont√≠nuos como 67.3, depois arredonda)
    let finalScore = null;
    if (totalWeight > 0) {
        const rawFinalScore = weightedSum / totalWeight;
        finalScore = Math.round(rawFinalScore); // S√≥ arredondar no final
    }
    
    const result = {
        final: finalScore,
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        frequencia: frequencyScore,
        estereo: stereoScore,
        tecnico: technicalScore,
        weights: weights,
        genre: genreKey
    };
    
    // üéØ LOG DE AUDITORIA: Verificar subscores ap√≥s corre√ß√£o
    console.log('[AUDIT-SCORES-FIX] Subscores depois da corre√ß√£o:', {
        loudness: result.loudness,
        dinamica: result.dinamica,
        estereo: result.estereo,
        frequencia: result.frequencia,
        tecnico: result.tecnico,
        final: result.final
    });
    
    console.log('üéØ Score final calculado:', result);
    
    // üéØ AUDIT_REF_FIX: Log final de confirma√ß√£o do fluxo A/B
    // üîí GUARD: S√≥ executar logs de refer√™ncia se viewMode === "reference"
    if (refData._isReferenceMode === true && getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('[REFERENCE-A/B FIXED ‚úÖ] Compara√ß√£o A/B conclu√≠da com sucesso');
        console.log('[AUDIT_REF_FIX] Bands carregadas da segunda m√∫sica (refer√™ncia real)');
        console.log('[AUDIT_REF_FIX] ReferenceComparison gerado com dados A/B corretos');
    }
    
    // üéØ AUDIT LOG FINAL
    try {
        console.log('[AUDIT-FINAL-SCORES]', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            frequencia: result.frequencia,
            estereo: result.estereo,
            tecnico: result.tecnico,
            finalScore: result.final,
            weights: result.weights,
            genre: result.genre,
            weightedCalculation: {
                loudness: result.loudness !== null ? (result.loudness * result.weights.loudness) : 'N/A',
                dinamica: result.dinamica !== null ? (result.dinamica * result.weights.dinamica) : 'N/A',
                frequencia: result.frequencia !== null ? (result.frequencia * result.weights.frequencia) : 'N/A',
                estereo: result.estereo !== null ? (result.estereo * result.weights.estereo) : 'N/A',
                tecnico: result.tecnico !== null ? (result.tecnico * result.weights.tecnico) : 'N/A'
            },
            isReferenceMode: refData._isReferenceMode === true
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateAnalysisScores (final)', err);
    }
    
    return result;
}

// Recalcular apenas as sugest√µes baseadas em refer√™ncia (sem reprocessar o √°udio)
function updateReferenceSuggestions(analysis) {
    // üéØ CORRE√á√ÉO CR√çTICA: Usar getActiveReferenceComparisonMetrics() para detectar targets corretamente
    const activeComparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasActiveComparisonMetrics = !!activeComparisonMetrics;
    
    console.log('üîç [DEBUG-REF] updateReferenceSuggestions chamado:', {
        hasAnalysis: !!analysis,
        hasTechnicalData: !!analysis?.technicalData,
        hasActiveRefData: !!__activeRefData,
        hasReferenceComparisonMetrics: hasActiveComparisonMetrics, // ‚úÖ CORRIGIDO: usa fun√ß√£o nova
        hasReferenceComparisonMetricsOLD: !!referenceComparisonMetrics, // ‚ùå ANTIGO (para compara√ß√£o)
        activeRefGenre: __activeRefGenre,
        activeRefDataKeys: __activeRefData ? Object.keys(__activeRefData) : null,
        currentGenre: window.PROD_AI_REF_GENRE,
        mode: analysis?.mode,
        activeComparisonMetricsSource: activeComparisonMetrics ? 'detected' : 'none'
    });
    
    if (!analysis || !analysis.technicalData) {
        console.warn('üö® [DEBUG-REF] analysis ou technicalData ausentes');
        return;
    }
    
    // üéØ PRIORIDADE: Se temos compara√ß√£o entre faixas, usar referenceComparisonMetrics
    let targetMetrics = null;
    
    if (referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('‚úÖ [SUGGESTIONS] Usando referenceComparisonMetrics para sugest√µes (compara√ß√£o entre faixas)');
        
        // Construir targetMetrics no formato esperado
        const refMetrics = referenceComparisonMetrics.reference;
        targetMetrics = {
            lufs_target: refMetrics.lufsIntegrated || refMetrics.lufs_integrated,
            true_peak_target: refMetrics.truePeakDbtp || refMetrics.true_peak_dbtp,
            dr_target: refMetrics.dynamicRange || refMetrics.dynamic_range,
            lra_target: refMetrics.lra,
            stereo_target: refMetrics.stereoCorrelation || refMetrics.stereo_correlation,
            spectral_centroid_target: refMetrics.spectralCentroidHz || refMetrics.spectral_centroid,
            bands: refMetrics.spectral_balance || null,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300
        };
        
        console.log('üìä [SUGGESTIONS] Target metrics (2¬™ faixa):', {
            lufs: targetMetrics.lufs_target,
            peak: targetMetrics.true_peak_target,
            dr: targetMetrics.dr_target
        });
        
        // Usar targetMetrics como __activeRefData temporariamente para compatibilidade
        __activeRefData = targetMetrics;
    }
    
    if (!__activeRefData) {
        console.warn('üö® [DEBUG-REF] __activeRefData est√° null - tentando carregar g√™nero atual');
        
        // Tentar carregar dados de refer√™ncia do g√™nero atual
        if (window.PROD_AI_REF_GENRE) {
            console.log('üîÑ [DEBUG-REF] Tentando carregar dados para g√™nero:', window.PROD_AI_REF_GENRE);
            loadReferenceData(window.PROD_AI_REF_GENRE).then(() => {
                console.log('‚úÖ [DEBUG-REF] Dados carregados, reprocessando sugest√µes');
                updateReferenceSuggestions(analysis);
            }).catch(err => {
                console.error('‚ùå [DEBUG-REF] Erro ao carregar dados:', err);
            });
        } else {
            // Tentar com dados de refer√™ncia padr√£o embutidos
            console.log('üîÑ [DEBUG-REF] Usando dados de refer√™ncia embutidos');
            
            // Verificar se existem dados embutidos para o g√™nero detectado nos scores
            if (analysis.scores && analysis.scores.genre) {
                const detectedGenre = analysis.scores.genre;
                console.log('üéØ [DEBUG-REF] G√™nero detectado nos scores:', detectedGenre);
                
                // Usar dados embutidos se dispon√≠veis
                const embeddedRefs = {
                    eletrofunk: {
                        lufs_target: -8.3,
                        true_peak_target: -1,
                        dr_target: 10.1,
                        lra_target: 8.4,
                        stereo_target: 0.12,
                        bands: {
                            low_bass: { target_db: 13.3, tol_db: 2.36 },
                            low_mid: { target_db: 8.8, tol_db: 2.07 },
                            mid: { target_db: 2.5, tol_db: 1.81 },
                            high_mid: { target_db: -6.7, tol_db: 1.52 },
                            presenca: { target_db: -22.7, tol_db: 3.47 },
                            brilho: { target_db: -13.1, tol_db: 2.38 }
                        }
                    }
                };
                
                if (embeddedRefs[detectedGenre]) {
                    console.log('‚úÖ [DEBUG-REF] Usando dados embutidos para', detectedGenre);
                    __activeRefData = embeddedRefs[detectedGenre];
                    __activeRefGenre = detectedGenre;
                    // Continuar com o processamento
                } else {
                    console.warn('‚ùå [DEBUG-REF] G√™nero n√£o suportado nos dados embutidos:', detectedGenre);
                    return;
                }
            } else {
                console.warn('‚ùå [DEBUG-REF] Nenhuma estrat√©gia de recupera√ß√£o dispon√≠vel');
                return;
            }
        }
        
        // Se chegou at√© aqui sem return, __activeRefData foi definido pelos dados embutidos
        if (!__activeRefData) {
            return;
        }
    }
    
    // üõ°Ô∏è PROTE√á√ÉO: Evitar duplica√ß√£o - resetar flag se chamado via applyGenreSelection
    if (analysis._suggestionsGenerated) {
        console.log('üéØ [SUGGESTIONS] Recalculando sugest√µes para novo g√™nero (resetando flag)');
        analysis._suggestionsGenerated = false;
    }
    
    // üéØ SISTEMA MELHORADO: Usar Enhanced Suggestion Engine quando dispon√≠vel
    if (typeof window !== 'undefined' && window.enhancedSuggestionEngine && window.USE_ENHANCED_SUGGESTIONS !== false) {
        try {
            console.log('üéØ Usando Enhanced Suggestion Engine...');
            
            // üéØ INTERCEPT CR√çTICO: Usar reference targets se modo for reference
            const state = window.__soundyState || {};
            let targetDataForEngine = __activeRefData;
            
            if (state.render?.mode === 'reference') {
                // Buscar dados da primeira faixa (refer√™ncia) para usar como target
                const referenceBands = state.reference?.analysis?.technicalData?.spectral_balance
                    || state.reference?.analysis?.bands
                    || referenceComparisonMetrics?.referenceFull?.technicalData?.spectral_balance
                    || null;
                
                if (referenceBands) {
                    console.log('ÔøΩ [ENGINE-INTERCEPT] Modo reference detectado - usando bandas da primeira faixa como target');
                    targetDataForEngine = {
                        ...(__activeRefData || {}),
                        bands: referenceBands,
                        _isReferenceMode: true,
                        _referenceSource: 'first_track'
                    };
                } else {
                    console.warn('‚ö†Ô∏è [ENGINE-INTERCEPT] Modo reference mas sem bandas - usando genreTargets (fallback)');
                }
            }
            
            console.log('ÔøΩüîç [DEBUG-ENGINE] Dados sendo passados para Enhanced Engine:', {
                mode: state.render?.mode,
                isReferenceMode: state.render?.mode === 'reference',
                analysis: {
                    hasTechnicalData: !!analysis.technicalData,
                    technicalDataKeys: analysis.technicalData ? Object.keys(analysis.technicalData) : null,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsCount: analysis.suggestions?.length || 0
                },
                targetDataForEngine: {
                    isNull: targetDataForEngine === null,
                    isUndefined: targetDataForEngine === undefined,
                    type: typeof targetDataForEngine,
                    keys: targetDataForEngine ? Object.keys(targetDataForEngine) : null,
                    structure: targetDataForEngine ? 'present' : 'missing',
                    hasBands: !!targetDataForEngine?.bands,
                    isReferenceMode: targetDataForEngine?._isReferenceMode
                }
            });
            
            // üî• PROTE√á√ÉO: Preservar technicalData e genreTargets ANTES do enhancedSuggestionEngine
            const __engineProtected = {
                technicalData: structuredClone(analysis.technicalData || {}),
                genreTargets: structuredClone(analysis.data?.genreTargets || null),
                metadata: structuredClone(analysis.metadata || {}),
                score: analysis.score,
                classification: analysis.classification
            };
            console.log('[ENGINE-PROTECT] üõ°Ô∏è Dados protegidos antes de processAnalysis:', {
                techKeys: Object.keys(__engineProtected.technicalData).length,
                hasGT: !!__engineProtected.genreTargets
            });
            
            const enhancedAnalysis = window.enhancedSuggestionEngine.processAnalysis(analysis, targetDataForEngine);
            
            // üî• RESTAURA√á√ÉO: Restaurar dados protegidos DEPOIS do enhancedSuggestionEngine
            if (__engineProtected.technicalData && Object.keys(__engineProtected.technicalData).length > 0) {
                enhancedAnalysis.technicalData = structuredClone(__engineProtected.technicalData);
                console.log('[ENGINE-PROTECT] ‚úÖ technicalData restaurado ap√≥s processAnalysis');
            }
            if (__engineProtected.genreTargets) {
                if (!enhancedAnalysis.data) enhancedAnalysis.data = {};
                enhancedAnalysis.data.genreTargets = structuredClone(__engineProtected.genreTargets);
                console.log('[ENGINE-PROTECT] ‚úÖ genreTargets restaurado ap√≥s processAnalysis');
            }
            if (Object.keys(__engineProtected.metadata).length > 0) {
                enhancedAnalysis.metadata = structuredClone(__engineProtected.metadata);
            }
            if (__engineProtected.score !== null && __engineProtected.score !== undefined) {
                enhancedAnalysis.score = __engineProtected.score;
            }
            if (__engineProtected.classification) {
                enhancedAnalysis.classification = __engineProtected.classification;
            }
            
            // Substituir analysis pelo resultado protegido
            analysis = enhancedAnalysis;
            
            // üéØ PATCH 1: PRESERVAR sugest√µes backend SEM sobrescrever
            // Guardar sugest√µes originais (backend) separadamente
            const backendOriginalSuggestions = Array.isArray(analysis.suggestions) ? analysis.suggestions : [];
            analysis.backendSuggestions = backendOriginalSuggestions; // Sugest√µes originais do backend
            
            // Enhanced Engine cria campo SEPARADO - N√ÉO sobrescreve analysis.suggestions
            analysis.enhancedSuggestions = enhancedAnalysis.suggestions; // Sugest√µes recalculadas
            
            // ‚úÖ analysis.suggestions permanece com valores BACKEND (n√£o sobrescrever)
            // Cards agora podem escolher qual usar verificando genreTargets
            
            // Adicionar m√©tricas melhoradas √† an√°lise
            if (enhancedAnalysis.enhancedMetrics) {
                analysis.enhancedMetrics = enhancedAnalysis.enhancedMetrics;
            }
            
            // Adicionar log de auditoria
            if (enhancedAnalysis.auditLog) {
                analysis.auditLog = enhancedAnalysis.auditLog;
            }
            
            console.log(`üéØ [SUGGESTIONS] Backend suggestions (antigas): ${existingSuggestions.length} guardadas em backendSuggestions`);
            console.log(`üéØ [SUGGESTIONS] Enhanced Engine (NOVAS): ${enhancedAnalysis.suggestions.length} sugest√µes`);
            console.log(`üéØ [SUGGESTIONS] Total final (SEM MIXING): ${analysis.suggestions.length} sugest√µes`);
            console.log(`‚úÖ [FIX-CONSISTENCY] Cards e tabela agora usar√£o OS MESMOS targets/deltas`);
            
            // ü§ñ NOVA CAMADA DE IA: P√≥s-processamento inteligente de sugest√µes (Enhanced Engine)
            if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
                try {
                    console.log('ü§ñ [AI-LAYER] Enriquecendo sugest√µes do Enhanced Engine...');
                    
                    // Preparar contexto para IA
                    const aiContext = {
                        technicalData: analysis.technicalData,
                        genre: __activeRefGenre || analysis.genre,
                        referenceData: __activeRefData,
                        problems: analysis.problems,
                        enhancedMetrics: enhancedAnalysis.enhancedMetrics
                    };
                    
                    // Chamar IA de forma ass√≠ncrona
                    window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                        .then(enhancedSuggestions => {
                            if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                                // ‚úÖ aplicar ordem garantida ap√≥s IA
                                enhancedSuggestions = window.enhancedSuggestionEngine
                                    .enforceOrderedSuggestions(enhancedSuggestions);

                                analysis.suggestions = enhancedSuggestions;
                                analysis._aiEnhanced = true;
                                analysis._aiTimestamp = new Date().toISOString();
                                analysis._aiSource = 'enhanced_engine';
                                
                                console.log(`ü§ñ [AI-LAYER] ‚úÖ Enhanced Engine + IA: ${enhancedSuggestions.length} sugest√µes`);
                                
                                // üöÄ FOR√áA EXIBI√á√ÉO: Sempre mostrar interface IA
                                if (window.aiUIController) {
                                    console.log(`üöÄ [FORCE-AI-UI] For√ßando exibi√ß√£o da interface IA com ${enhancedSuggestions.length} sugest√µes`);
                                    window.aiUIController.checkForAISuggestions(analysis);
                                }
                                
                                // Re-renderizar se modal vis√≠vel
                                if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                                    displayModalResults(analysis);
                                }
                            }
                        })
                        .catch(error => {
                            console.warn('ü§ñ [AI-LAYER] ‚ùå Erro na IA do Enhanced Engine:', error);
                            
                            // üöÄ FOR√áA EXIBI√á√ÉO: Mostrar interface IA mesmo em caso de erro
                            setTimeout(() => {
                                if (window.aiUIController && analysis.suggestions) {
                                    console.log(`üöÄ [AI-UI-FORCE-ERROR] For√ßando interface IA aparecer ap√≥s erro com ${analysis.suggestions.length} sugest√µes`);
                                    window.aiUIController.checkForAISuggestions(analysis, true); // force = true
                                } else {
                                    console.warn('‚ö†Ô∏è [AI-UI-FORCE-ERROR] aiUIController n√£o encontrado ou sem sugest√µes');
                                }
                            }, 100);
                        });
                } catch (error) {
                    console.warn('ü§ñ [AI-LAYER] ‚ùå Erro na integra√ß√£o IA Enhanced Engine:', error);
                }
            }
            
            return;
            
        } catch (error) {
            console.warn('üö® Erro no Enhanced Suggestion Engine, usando fallback:', error);
            // Continuar com sistema legado em caso de erro
        }
    }
    
    // üîÑ SISTEMA LEGADO (fallback) - APENAS PARA SCORES, N√ÉO DEVE ALTERAR SUGEST√ïES
    console.log('üîÑ [FALLBACK] Sistema legado ativado - usando apenas para calcular scores');
    
    // IMPORTANTE: N√ÉO modificar analysis.suggestions aqui para n√£o interferir com Enhanced Engine
    // Apenas calcular scores se necess√°rio
    if (!analysis.scores && __activeRefData && analysis.technicalData) {
        try {
            analysis.scores = this.calculateFallbackScores(analysis.technicalData, __activeRefData);
            console.log('‚úÖ [FALLBACK] Scores calculados pelo sistema legado');
        } catch (error) {
            console.warn('‚ö†Ô∏è [FALLBACK] Erro ao calcular scores legados:', error);
        }
    }
    
    console.log('üéØ [FALLBACK] Sistema legado conclu√≠do sem alterar sugest√µes');
    
    return; // ‚ùå SISTEMA LEGADO DESATIVADO - Enhanced Engine deve ser usado para sugest√µes
    
    // ü§ñ NOVA CAMADA DE IA: P√≥s-processamento inteligente de sugest√µes
    // PONTO DE INTEGRA√á√ÉO SEGURO: Ap√≥s gera√ß√£o de todas as sugest√µes
    if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
        try {
            console.log('ü§ñ [AI-LAYER] Iniciando enriquecimento inteligente das sugest√µes...');
            
            // Preparar contexto para IA
            const aiContext = {
                technicalData: analysis.technicalData,
                genre: __activeRefGenre || analysis.genre,
                referenceData: __activeRefData,
                problems: analysis.problems
            };
            
            // Chamar IA de forma ass√≠ncrona com fallback
            window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                .then(enhancedSuggestions => {
                    if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                        // ‚úÖ aplicar ordem garantida ap√≥s IA
                        enhancedSuggestions = window.enhancedSuggestionEngine
                            .enforceOrderedSuggestions(enhancedSuggestions);

                        analysis.suggestions = enhancedSuggestions;
                        console.log(`ü§ñ [AI-LAYER] ‚úÖ ${enhancedSuggestions.length} sugest√µes enriquecidas com IA`);
                        
                        // Marcar que IA foi aplicada
                        analysis._aiEnhanced = true;
                        analysis._aiTimestamp = new Date().toISOString();
                        
                        // Re-renderizar modal se estiver vis√≠vel
                        if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                            console.log('üé® [AI-LAYER] Re-renderizando modal com sugest√µes IA');
                            displayModalResults(analysis);
                        }
                    } else {
                        console.warn('ü§ñ [AI-LAYER] ‚ö†Ô∏è IA retornou resultado vazio, mantendo sugest√µes originais');
                    }
                })
                .catch(error => {
                    console.warn('ü§ñ [AI-LAYER] ‚ùå Erro na camada de IA, mantendo sugest√µes originais:', error);
                    // Sistema continua funcionando normalmente com sugest√µes originais
                });
                
        } catch (error) {
            console.warn('ü§ñ [AI-LAYER] ‚ùå Erro na inicializa√ß√£o da IA, sistema continua normal:', error);
        }
    } else {
        console.log('ü§ñ [AI-LAYER] Sistema de IA desabilitado ou n√£o dispon√≠vel');
    }
    
    // üõ°Ô∏è Marcar que sugest√µes foram geradas (prote√ß√£o contra duplica√ß√£o)
    analysis._suggestionsGenerated = true;
}

/**
 * üî¢ Calcular scores b√°sicos quando Enhanced Engine n√£o est√° dispon√≠vel
 * @param {Object} technicalData - Dados t√©cnicos da an√°lise
 * @param {Object} referenceData - Dados de refer√™ncia
 * @returns {Object} Scores calculados
 */
function calculateFallbackScores(technicalData, referenceData) {
    const scores = {};
    
    try {
        // Score LUFS
        if (Number.isFinite(technicalData.lufsIntegrated) && Number.isFinite(referenceData.lufs_target)) {
            const delta = Math.abs(technicalData.lufsIntegrated - referenceData.lufs_target);
            const tolerance = referenceData.tol_lufs || 2.0;
            scores.lufs = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score True Peak
        if (Number.isFinite(technicalData.truePeakDbtp)) {
            if (technicalData.truePeakDbtp > 0) {
                scores.truePeak = 0; // Cr√≠tico
            } else if (technicalData.truePeakDbtp > -1.0) {
                scores.truePeak = 5; // Aceit√°vel mas n√£o ideal
            } else {
                scores.truePeak = 10; // Ideal
            }
        }
        
        // Score DR
        if (Number.isFinite(technicalData.dynamicRange) && Number.isFinite(referenceData.dr_target)) {
            const delta = Math.abs(technicalData.dynamicRange - referenceData.dr_target);
            const tolerance = referenceData.tol_dr || 2.0;
            scores.dr = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score geral (m√©dia dos scores dispon√≠veis)
        const availableScores = Object.values(scores).filter(s => Number.isFinite(s));
        if (availableScores.length > 0) {
            scores.overall = availableScores.reduce((sum, score) => sum + score, 0) / availableScores.length;
        }
        
        console.log('üìä [FALLBACK] Scores calculados:', scores);
        return scores;
        
    } catch (error) {
        console.error('‚ùå [FALLBACK] Erro ao calcular scores:', error);
        return {};
    }
}

// üé® Estilos do seletor de g√™nero (inje√ß√£o √∫nica, n√£o quebra CSS existente)
function injectRefGenreStyles() {
    if (document.getElementById('refGenreEnhancedStyles')) return; // j√° injetado
    const style = document.createElement('style');
    style.id = 'refGenreEnhancedStyles';
    style.textContent = `
    #audioRefGenreContainer{position:relative;gap:10px;padding:6px 10px 4px 10px;border:1px solid rgba(255,255,255,.06);background:linear-gradient(145deg,#0c111b,#0d1321);border-radius:10px;box-shadow:0 2px 6px -2px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,0.02);}
    #audioRefGenreContainer label{font-weight:500;letter-spacing:.3px;color:#9fb3d9;margin-right:4px;}
    #audioRefGenreSelect{appearance:none;-webkit-appearance:none;-moz-appearance:none;position:relative;padding:6px 32px 6px 12px;font-size:12px;line-height:1.2;background:rgba(20,32,54,.7);color:#f4f7fb;border:1px solid #1e2b40;border-radius:8px;cursor:pointer;font-family:inherit;transition:border .25s, background .25s, box-shadow .25s;min-width:140px;}
    #audioRefGenreSelect:hover{background:rgba(28,44,76,.85);}
    #audioRefGenreSelect:focus{outline:none;border-color:#249dff;box-shadow:0 0 0 2px rgba(36,157,255,.3);}
    #audioRefGenreSelect:active{transform:translateY(1px);} 
    #audioRefGenreContainer::after{content:"";position:absolute;top:13px;left: calc(10px + 140px);pointer-events:none;}
    #audioRefGenreContainer .select-wrap{position:relative;}
    /* Seta custom */
    #audioRefGenreContainer .select-wrap:after{content:"";position:absolute;right:12px;top:50%;width:7px;height:7px;border-right:2px solid #9fb3d9;border-bottom:2px solid #9fb3d9;transform:translateY(-60%) rotate(45deg);pointer-events:none;transition:transform .25s,border-color .25s;}
    #audioRefGenreSelect:focus + .arrow, #audioRefGenreContainer .select-wrap:focus-within:after{border-color:#53c2ff;}
    #audioRefStatus{font-size:11px;font-weight:500;letter-spacing:.4px;padding:4px 10px;border-radius:7px;background:#0d6efd;color:#fff;display:inline-flex;align-items:center;gap:6px;box-shadow:0 0 0 1px rgba(255,255,255,.06),0 2px 4px -1px rgba(0,0,0,.7);}
    #audioRefStatus::before{content:"";width:7px;height:7px;border-radius:50%;background:#3df29b;box-shadow:0 0 0 3px rgba(61,242,155,.25);} 
    #audioRefGenreContainer.dark #audioRefStatus{background:#14324f;}
    @media (max-width:600px){#audioRefGenreContainer{padding:6px 8px 4px 8px;gap:6px;}#audioRefGenreSelect{min-width:120px;padding:6px 28px 6px 10px;}}
    `;
    // Wrap opcional para setinha sem mexer HTML: inserir span ao redor do select
    const select = document.getElementById('audioRefGenreSelect');
    if (select && !select.parentElement.classList.contains('select-wrap')) {
        const wrap = document.createElement('div');
        wrap.className = 'select-wrap';
        wrap.style.position = 'relative';
        select.parentNode.insertBefore(wrap, select);
        wrap.appendChild(select);
    }
    document.head.appendChild(style);
}

// üé® Estilos do Modal de G√™nero Musical - Glassmorphism + Glitch
function injectGenreModalStyles() {
    if (document.getElementById('genreModalStyles')) return; // j√° injetado
    const style = document.createElement('style');
    style.id = 'genreModalStyles';
    style.textContent = `
    /* üéµ Novo Modal de G√™nero Musical - Glassmorphism */
    .genre-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        z-index: 10000;
        opacity: 1;
        transition: opacity 0.3s ease;
    }

    .genre-modal.hidden {
        display: none;
        opacity: 0;
    }

    .genre-modal-container {
        max-width: 720px;
        width: 90%;
        max-height: 90vh;
        background: radial-gradient(
    circle at 20% 20%, 
    rgba(93, 21, 134, 0.85) 0%,       /* Roxo vibrante no canto */
    rgba(0, 0, 0, 0.95) 60%,          /* Preto no centro */
    rgba(0, 102, 255, 0.4) 100%       /* Azul el√©trico nas bordas */
);
backdrop-filter: blur(8px);
box-shadow: 0 0 30px rgba(93, 21, 134, 0.4),
            0 0 60px rgba(0, 102, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        padding: 40px 32px 32px 32px;
        text-align: center;
        position: relative;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        box-shadow: 
            0 20px 40px rgba(91, 11, 156, 0.49),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: scale(1);
        transition: transform 0.2s ease;
        overflow: hidden;
    }

    /* LINHAS NEURAIS VANTA - FUNDO TECH */
    .genre-modal-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 40px,
                rgba(106, 154, 255, 0.03) 40px,
                rgba(106, 154, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 40px,
                rgba(106, 0, 255, 0.03) 40px,
                rgba(106, 0, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 60px,
                rgba(0, 212, 255, 0.02) 60px,
                rgba(0, 212, 255, 0.02) 61px
            );
        opacity: 0.6;
        animation: neural-grid-genre 15s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    /* Part√≠culas flutuantes */
    .genre-modal-container::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background-image: 
            radial-gradient(circle, rgba(106, 0, 255, 0.15) 1px, transparent 1px),
            radial-gradient(circle, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
        background-size: 50px 50px, 80px 80px;
        background-position: 0 0, 25px 25px;
        animation: particles-float-genre 20s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    @keyframes neural-grid-genre {
        0% {
            transform: translate(0, 0);
            opacity: 0.6;
        }
        50% {
            opacity: 0.4;
        }
        100% {
            transform: translate(40px, 40px);
            opacity: 0.6;
        }
    }

    @keyframes particles-float-genre {
        0% {
            transform: translate(0, 0) rotate(0deg);
        }
        100% {
            transform: translate(50px, 50px) rotate(360deg);
        }
    }

    /* Garante que conte√∫do fica acima do fundo neural */
    .genre-modal-container > * {
        position: relative;
        z-index: 5;
    }

    /* T√≠tulo com efeito glitch - Paleta roxo escuro + azul ciano */
    .genre-modal-title {
        font-family: 'Orbitron', 'Rajdhani', 'Montserrat Alternates', sans-serif;
        font-size: 2.2rem;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        margin-bottom: 12px;
        position: relative;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 
            0 0 12px rgba(0, 212, 255, 0.4),
            0 0 24px rgba(108, 0, 162, 0.2),
            0 0 40px rgba(0, 212, 255, 0.15);
    }

    .genre-modal-title.glitch::before,
    .genre-modal-title.glitch::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.85;
        pointer-events: none;
    }

    /* PARTE SUPERIOR ‚Äî Roxo escuro */
    .genre-modal-title.glitch::before {
        color: #6c00a2;
        animation: glitch-1 2s infinite alternate-reverse;
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }

    /* PARTE INFERIOR ‚Äî Azul ciano */
    .genre-modal-title.glitch::after {
        color: #00d4ff;
        animation: glitch-2 3s infinite alternate-reverse;
        clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }

    @keyframes glitch-1 {
        0% { transform: translateX(-2px); }
        100% { transform: translateX(2px); }
    }

    @keyframes glitch-2 {
        0% { transform: translateX(2px); }
        100% { transform: translateX(-2px); }
    }

    .genre-modal-subtitle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 1rem;
        margin-bottom: 32px;
        font-weight: 400;
    }

    /* Grid de g√™neros */
    .genre-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 32px;
    }

    /* üîß CORRE√á√ÉO FLASH BRANCO: Estado inicial expl√≠cito */
    .genre-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px 16px;
        
        /* Estado base: exatamente o visual glass atual */
        background: rgba(255, 255, 255, 0.05);
        background-color: transparent; /* Evita herdar branco do user-agent */
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        color: #ffffff;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        
        /* ‚ùå N√ÉO animar background - s√≥ transform, box-shadow, border-color, opacity */
        transition: 
            transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            opacity 0.25s ease;
        
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        
        /* Zera estilos nativos se for <button> */
        -webkit-appearance: none;
        appearance: none;
    }

    /* Prepaint: cards invis√≠veis enquanto CSS assenta */
    .genre-modal.prepaint .genre-card {
        opacity: 0;
    }

    .genre-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.1), 
            transparent);
        transition: left 0.6s ease;
    }

    .genre-card:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(36, 157, 255, 0.4);
        transform: scale(1.05) translateY(-2px);
        box-shadow: 
            0 10px 25px rgba(0, 0, 0, 0.4),
            0 0 0 1px rgba(36, 157, 255, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .genre-card:hover::before {
        left: 100%;
    }

    .genre-card:active {
        transform: scale(0.98) translateY(1px);
    }

    .genre-icon {
        font-size: 2rem;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
    }

    .genre-name {
        font-weight: 700;
        letter-spacing: 0.5px;
    }

    /* Bot√£o fechar */
    .genre-modal-close {
        background: rgba(255, 255, 255, 0.08);
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 0.9rem;
        cursor: pointer;
        /* ‚ùå N√ÉO animar background */
        transition: 
            border-color 0.2s ease,
            color 0.2s ease,
            opacity 0.2s ease;
        font-weight: 500;
        -webkit-appearance: none;
        appearance: none;
    }

    .genre-modal-close:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.4);
    }

    /* Responsividade */
    @media (max-width: 768px) {
        .genre-modal-container {
            width: 95%;
            padding: 32px 20px 24px 20px;
        }

        .genre-modal-title {
            font-size: 1.8rem;
        }

        .genre-grid {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .genre-card {
            padding: 16px 12px;
            gap: 8px;
        }

        .genre-icon {
            font-size: 1.5rem;
        }

        .genre-name {
            font-size: 0.85rem;
        }
    }

    @media (max-width: 480px) {
        .genre-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .genre-card {
            padding: 14px 10px;
        }
    }
    `;
    document.head.appendChild(style);
}

// ü§ñ Enviar an√°lise para chat
window.sendModalAnalysisToChat = async function sendModalAnalysisToChat() {
    __dbg('üéØ BOT√ÉO CLICADO: Pedir Ajuda √† IA');
    
    if (!currentModalAnalysis) {
        alert('Nenhuma an√°lise dispon√≠vel');
        __dbg('‚ùå Erro: currentModalAnalysis n√£o existe');
        return;
    }
    
    __dbg('ü§ñ Enviando an√°lise para chat...', currentModalAnalysis);
    
    try {
        // Gerar prompt personalizado baseado nos problemas encontrados
        const prompt = window.audioAnalyzer.generateAIPrompt(currentModalAnalysis);
        const message = `üéµ Analisei meu √°udio e preciso de ajuda para melhorar. Aqui est√£o os dados t√©cnicos:\n\n${prompt}`;
        
        __dbg('üìù Prompt gerado:', message.substring(0, 200) + '...');
        
        // Tentar diferentes formas de integrar com o chat
        let messageSent = false;
        
        // M√©todo 1: Usar diretamente o ProdAI Chatbot quando dispon√≠vel
        if (window.prodAIChatbot) {
            __dbg('üéØ Tentando enviar via ProdAI Chatbot...');
            try {
                // Se o chat ainda n√£o est√° ativo, ativar com a mensagem
                if (!window.prodAIChatbot.isActive && typeof window.prodAIChatbot.activateChat === 'function') {
                    __dbg('üöÄ Chat inativo. Ativando com a primeira mensagem...');
                    await window.prodAIChatbot.activateChat(message);
                    showTemporaryFeedback('üéµ An√°lise enviada para o chat!');
                    closeAudioModal();
                    messageSent = true;
                } else if (typeof window.prodAIChatbot.sendMessage === 'function') {
                    // Chat j√° ativo: preencher input ativo e enviar
                    const activeInput = document.getElementById('chatbotActiveInput');
                    if (activeInput) {
                        activeInput.value = message;
                        activeInput.focus();
                        activeInput.dispatchEvent(new Event('input', { bubbles: true }));
                        await window.prodAIChatbot.sendMessage();
                        showTemporaryFeedback('üéµ An√°lise enviada para o chat!');
                        closeAudioModal();
                        messageSent = true;
                    }
                }
            } catch (err) {
                __dwrn('‚ö†Ô∏è Falha ao usar ProdAIChatbot direto, tentando fallback...', err);
            }
        }
        // M√©todo 2: Inserir diretamente no input e simular envio
        else {
            __dbg('üéØ Tentando m√©todo alternativo...');
            
            const input = document.getElementById('chatbotActiveInput') || document.getElementById('chatbotMainInput');
            const sendBtn = document.getElementById('chatbotActiveSendBtn') || document.getElementById('chatbotSendButton');
            
            __dbg('üîç Elementos encontrados:', { input: !!input, sendBtn: !!sendBtn });
            
            if (input && sendBtn) {
                input.value = message;
                input.focus();
                
                // Disparar eventos para simular intera√ß√£o do usu√°rio
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                
                // Aguardar um pouco e clicar no bot√£o
                setTimeout(() => {
                    sendBtn.click();
                    __dbg('‚úÖ Bot√£o clicado');
                    showTemporaryFeedback('üéµ An√°lise enviada para o chat!');
                    closeAudioModal();
                }, 500);
                
                messageSent = true;
            }
        }
        
        if (!messageSent) {
            __dbg('‚ùå N√£o foi poss√≠vel enviar automaticamente, copiando para clipboard...');
            
            // Fallback: copiar para clipboard
            await navigator.clipboard.writeText(message);
            showTemporaryFeedback('üìã An√°lise copiada! Cole no chat manualmente.');
            __dbg('üìã Mensagem copiada para clipboard como fallback');
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao enviar an√°lise para chat:', error);
        showTemporaryFeedback('‚ùå Erro ao enviar an√°lise. Tente novamente.');
    }
}

// ÔøΩ Mostrar feedback tempor√°rio
// (defini√ß√£o duplicada de showTemporaryFeedback removida ‚Äî mantida a vers√£o consolidada abaixo)

// üìÑ Baixar relat√≥rio do modal (IMPLEMENTA√á√ÉO ROBUSTA COM VALIDA√á√ÉO)
async function downloadModalAnalysis() {
    // 1Ô∏è‚É£ VALIDA√á√ÉO: Verificar se an√°lise est√° dispon√≠vel no alias global
    const analysis = window.__soundyAI?.analysis || currentModalAnalysis;
    
    if (!analysis) {
        alert('‚ùå Nenhuma an√°lise dispon√≠vel.\n\nFa√ßa uma an√°lise antes de gerar o relat√≥rio.');
        console.error('[PDF-ERROR] An√°lise n√£o encontrada em window.__soundyAI.analysis ou currentModalAnalysis');
        return;
    }
    
    // üîç AUDITORIA: Mapear estrutura completa do objeto analysis
    console.log('üîç [AUDIT-PDF] ============ IN√çCIO DA AUDITORIA ============');
    console.log('üîç [AUDIT-PDF] Analysis root keys:', Object.keys(analysis));
    console.log('üîç [AUDIT-PDF] Fontes detectadas:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        userBands: analysis.user?.bands,
        diagnostics: analysis.diagnostics,
        problems: analysis.problems,
        _diagnostic: analysis._diagnostic,
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        score: analysis.score,
        userScore: analysis.user?.score
    });
    
    // üîç AUDITORIA: Comparar com valores da UI (modal Paperline)
    console.log('üîç [AUDIT-UI] Valores exibidos na UI:', {
        score: document.querySelector('.score-final-value')?.dataset?.value || document.querySelector('.score-final-value')?.textContent,
        bandSub: document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent,
        bandBass: document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent,
        bandMid: document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent,
        bandHigh: document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent
    });
    
    console.log('üìÑ [PDF-START] Iniciando gera√ß√£o de relat√≥rio PDF...');
    console.log('üìÑ [PDF-SOURCE] Fonte de dados:', {
        usingGlobalAlias: !!window.__soundyAI?.analysis,
        usingCurrentModal: !!currentModalAnalysis,
        fileName: analysis.fileName || analysis.metadata?.fileName,
        hasLoudness: !!(analysis.loudness || analysis.lufsIntegrated),
        hasTruePeak: !!(analysis.truePeak || analysis.truePeakDbtp)
    });
    
    // 2Ô∏è‚É£ VALIDA√á√ÉO: Verificar depend√™ncias
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('‚öôÔ∏è Carregando bibliotecas...');
        console.warn('‚ö†Ô∏è [PDF-WAIT] Aguardando carregamento de jsPDF/html2canvas...');
        
        // Retry ap√≥s 1s
        setTimeout(() => downloadModalAnalysis(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('‚öôÔ∏è Gerando relat√≥rio PDF...');
        
        // 3Ô∏è‚É£ VALIDA√á√ÉO CONTRA UI: Comparar dados do relat√≥rio com a UI
        validateAnalysisDataAgainstUI(analysis);
        
        // 4Ô∏è‚É£ NORMALIZAR: Extrair e formatar dados
        const normalizedData = normalizeAnalysisDataForPDF(analysis);
        
        // 5Ô∏è‚É£ GERAR HTML: Template profissional
        const reportHTML = generateReportHTML(normalizedData);
        
        // 6Ô∏è‚É£ PREPARAR CONTAINER: Inserir e tornar vis√≠vel
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template n√£o encontrado no DOM');
        }
        
        container.innerHTML = reportHTML;
        const elemento = container.firstElementChild;
        if (!elemento) {
            throw new Error('Template HTML n√£o foi renderizado corretamente');
        }
        
        // Salvar estilos originais
        const originalStyles = {
            display: container.style.display,
            visibility: container.style.visibility,
            position: container.style.position,
            left: container.style.left,
            top: container.style.top,
            zIndex: container.style.zIndex
        };
        
        // ‚úÖ PROPOR√á√ÉO FIXA A4: 794x1123 px (resolu√ß√£o base vertical)
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const A4_RATIO = A4_HEIGHT / A4_WIDTH; // 1.414 (propor√ß√£o A4)
        
        // For√ßar visibilidade tempor√°ria com propor√ß√£o A4 fixa
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.position = 'fixed';
        container.style.left = '50%';
        container.style.top = '0';
        container.style.transform = 'translateX(-50%)'; // Centralizar horizontalmente
        container.style.zIndex = '9999';
        container.style.width = `${A4_WIDTH}px`; // Largura fixa A4
        container.style.height = 'auto';
        container.style.margin = '0 auto';
        
        console.log('üìä [PDF-RENDER] Container preparado com propor√ß√£o A4:', {
            baseWidth: A4_WIDTH,
            baseHeight: A4_HEIGHT,
            ratio: A4_RATIO,
            containerWidth: elemento.offsetWidth,
            containerHeight: elemento.offsetHeight,
            isVisible: elemento.offsetWidth > 0 && elemento.offsetHeight > 0
        });
        
        // 7Ô∏è‚É£ AGUARDAR RENDERIZA√á√ÉO: 250ms base + scroll + 150ms
        await new Promise(r => setTimeout(r, 250));
        elemento.scrollIntoView({ behavior: 'instant', block: 'start' });
        await new Promise(r => setTimeout(r, 150));
        
        // ‚úÖ 8Ô∏è‚É£ CAPTURAR P√ÅGINAS SEPARADAMENTE com propor√ß√£o fixa A4
        console.log('üì∏ [PDF-CAPTURE] Iniciando captura em 2 p√°ginas l√≥gicas com propor√ß√£o A4 fixa...');
        
        // ‚úÖ PROPOR√á√ÉO FIXA: Sempre usar 794px (A4) com scale 2 (alta qualidade)
        // N√ÉO depende de viewport - garante consist√™ncia desktop/mobile
        const CAPTURE_WIDTH = A4_WIDTH; // 794px
        const CAPTURE_SCALE = 2; // Alta qualidade (1588px efetivos)
        const CAPTURE_BG = '#0a0a0f'; // Fundo escuro profissional
        
        console.log('ÔøΩ [PDF-A4-FIXED]', {
            captureWidth: CAPTURE_WIDTH,
            captureScale: CAPTURE_SCALE,
            backgroundColor: CAPTURE_BG,
            effectiveWidth: CAPTURE_WIDTH * CAPTURE_SCALE,
            note: 'Propor√ß√£o A4 fixa (n√£o depende de viewport)'
        });
        
        const section1 = elemento.querySelector('.pdf-section-metrics');
        const section2 = elemento.querySelector('.pdf-section-diagnostics');
        
        if (!section1 || !section2) {
            throw new Error('‚ùå Se√ß√µes PDF n√£o encontradas. Verifique as classes .pdf-section-metrics e .pdf-section-diagnostics');
        }
        
        console.log('ÔøΩ [PDF-CAPTURE] Capturando P√°gina 1 (M√©tricas)...');
        // ‚úÖ Fun√ß√£o gen√©rica e segura de captura A4 com wrapper virtual
        async function renderSectionToPDF(element, sectionName) {
            const wrapper = document.createElement('div');
            const isMobile = window.innerWidth < 768;
            wrapper.style.width = '794px';
            wrapper.style.height = '1123px';
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'flex-start';
            wrapper.style.justifyContent = 'center';
            wrapper.style.background = '#0a0a0f';
            wrapper.style.padding = '0';  // ‚úÖ Zero padding no wrapper
            wrapper.style.position = 'fixed';
            wrapper.style.left = '-9999px';
            wrapper.style.top = '0';
            wrapper.style.zIndex = '-1';
            wrapper.style.overflow = 'hidden';
            
            // Clona o conte√∫do e aplica padding no clone (n√£o no wrapper)
            const clone = element.cloneNode(true);
            clone.style.padding = isMobile ? '10px' : '20px';  // ‚úÖ Padding no conte√∫do
            clone.style.boxSizing = 'border-box';
            clone.style.width = '100%';
            clone.style.height = '100%';
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);
            
            // Aguarda renderiza√ß√£o
            await new Promise(r => setTimeout(r, 150));
            
            console.log(`üìê [PDF-WRAPPER] ${sectionName}:`, {
                declared: { width: '794px', height: '1123px' },
                computed: {
                    offsetWidth: wrapper.offsetWidth,
                    offsetHeight: wrapper.offsetHeight,
                    clientWidth: wrapper.clientWidth,
                    clientHeight: wrapper.clientHeight
                },
                usableArea: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    lostHeight: 1123 - wrapper.clientHeight
                },
                padding: isMobile ? '10px (clone)' : '20px (clone)',
                note: 'Padding aplicado no clone, n√£o no wrapper'
            });
            
            // Captura com par√¢metros fixos A4
            const canvas = await html2canvas(wrapper, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: '#0a0a0f',
                useCORS: true,
                allowTaint: true,
                logging: false,
                scale: 2
            });
            
            document.body.removeChild(wrapper);
            
            const ratio = (canvas.height / canvas.width).toFixed(3);
            const expectedRatio = (1123 / 794).toFixed(3);
            console.log(`üñºÔ∏è [PDF-CANVAS] ${sectionName}:`, {
                canvasSize: { width: canvas.width, height: canvas.height },
                ratio,
                expectedRatio,
                match: ratio === expectedRatio ? '‚úÖ' : '‚ö†Ô∏è'
            });
            
            return canvas;
        }
        
        const canvas1 = await renderSectionToPDF(section1, 'M√©tricas');
        
        const canvas2 = await renderSectionToPDF(section2, 'Diagn√≥stico');
        
        console.log('‚úÖ [PDF-CANVAS] P√°ginas capturadas:', {
            page1: { width: canvas1.width, height: canvas1.height },
            page2: { width: canvas2.width, height: canvas2.height }
        });
        
        if (canvas1.width === 0 || canvas1.height === 0 || canvas2.width === 0 || canvas2.height === 0) {
            throw new Error('Canvas vazio - verifique se as se√ß√µes est√£o vis√≠veis');
        }
        
        // ‚úÖ Valida√ß√£o final de propor√ß√£o A4
        const ratio1 = (canvas1.height / canvas1.width).toFixed(3);
        const ratio2 = (canvas2.height / canvas2.width).toFixed(3);
        const expectedRatio = (1123 / 794).toFixed(3);
        
        console.log('[PDF] Propor√ß√£o A4 preservada com sucesso (' + expectedRatio + ')');
        console.log('[PDF] Canvas1: ' + canvas1.width + 'x' + canvas1.height + ' | Canvas2: ' + canvas2.width + 'x' + canvas2.height);
        console.log('[PDF] Exporta√ß√£o conclu√≠da sem achatamento ‚úîÔ∏è');
        
        // ‚úÖ 9Ô∏è‚É£ GERAR PDF COM PROPOR√á√ÉO A4 E MARGENS (centraliza√ß√£o perfeita mobile)
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth(); // 210mm
        const pageHeight = pdf.internal.pageSize.getHeight(); // 297mm
        
        // ‚úÖ Zero margens para ambos dispositivos (100% fill A4)
        const SIDE_MARGIN_MM = 0;
        const TOP_MARGIN_MM = 0;
        const BOTTOM_MARGIN_MM = 0;
        
        console.log('ÔøΩ [PDF-A4-FORMAT]', {
            pageWidth,
            pageHeight,
            margins: 'ZERO (100% fill)',
            format: 'A4 Portrait (210x297mm)'
        });
        
        // ‚úÖ Fun√ß√£o unificada: preencher 100% A4 (desktop e mobile)
        function addCanvasAsA4PageCentered(cnv, sectionName) {
            // Come√ßar pela altura (preencher verticalmente)
            let imgHeight = pageHeight; // 297mm
            let imgWidth = (cnv.width * imgHeight) / cnv.height;
            
            // Se largura ultrapassar, reajustar por largura
            if (imgWidth > pageWidth) {
                imgWidth = pageWidth; // 210mm
                imgHeight = (cnv.height * imgWidth) / cnv.width;
            }
            
            // Posi√ß√£o absoluta no canto (sem margens)
            const x = 0;
            const y = 0;
            
            const fillPercentage = ((imgHeight / pageHeight) * 100).toFixed(1);
            
            console.log(`üìÑ [PDF-BUILD] ${sectionName}:`, {
                canvasSize: { width: cnv.width, height: cnv.height },
                pageSize: { width: pageWidth, height: pageHeight },
                imgWidth: imgWidth.toFixed(2),
                imgHeight: imgHeight.toFixed(2),
                position: { x, y },
                fillPercentage: `${fillPercentage}%`,
                margins: 'ZERO (100% fill)'
            });
            
            const imgData = cnv.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
        }
        
        // P√°gina 1 (M√©tricas)
        addCanvasAsA4PageCentered(canvas1, 'P√°gina 1 (M√©tricas)');
        
        // P√°gina 2 (Diagn√≥stico/Recomenda√ß√µes)
        pdf.addPage();
        addCanvasAsA4PageCentered(canvas2, 'P√°gina 2 (Diagn√≥stico)');
        
        // üîü DOWNLOAD: Nome descritivo com data
        const cleanFileName = (normalizedData.fileName || 'audio')
            .replace(/\.[^/.]+$/, '')
            .replace(/[^a-z0-9_-]/gi, '_');
        const dateStr = new Date().toISOString().split('T')[0];
        const fileName = `Relatorio_SoundyAI_${cleanFileName}_${dateStr}.pdf`;
        
        pdf.save(fileName);
        
        console.log('‚úÖ [PDF-SUCCESS] Relat√≥rio gerado:', fileName);
        showTemporaryFeedback('‚úÖ Relat√≥rio PDF baixado com sucesso!');
        
        // RESTAURAR: Estilos originais
        Object.assign(container.style, originalStyles);
        setTimeout(() => container.innerHTML = '', 100);
        
    } catch (error) {
        console.error('‚ùå [PDF-ERROR] Erro ao gerar relat√≥rio:', error);
        console.error('‚ùå [PDF-ERROR] Stack:', error.stack);
        showTemporaryFeedback('‚ùå Erro ao gerar PDF');
        alert(`Erro ao gerar relat√≥rio PDF:\n\n${error.message}\n\nVerifique o console para mais detalhes.`);
    }
}


// üîç VALIDA√á√ÉO: Comparar dados do relat√≥rio com a UI
function validateAnalysisDataAgainstUI(analysis) {
    console.log('üîç [PDF-VALIDATE] Iniciando valida√ß√£o contra UI...');
    console.log('üß† [PDF-AUDIT] An√°lise Global:', analysis);
    
    const assertEqual = (label, pdfValue, uiSelector, tolerance = 0.01) => {
        const uiElement = document.querySelector(uiSelector);
        if (!uiElement) {
            console.warn(`‚ö†Ô∏è [PDF-VALIDATE] Elemento UI n√£o encontrado: ${uiSelector}`);
            return;
        }
        
        let uiValue = uiElement.dataset?.value || 
                     uiElement.getAttribute('data-value') ||
                     parseFloat(uiElement.textContent.replace(/[^0-9.-]/g, ''));
        
        if (isNaN(uiValue)) {
            console.warn(`‚ö†Ô∏è [PDF-VALIDATE] Valor UI n√£o num√©rico em ${uiSelector}`);
            return;
        }
        
        if (pdfValue == null || isNaN(pdfValue)) {
            console.warn(`‚ö†Ô∏è [PDF-VALIDATE] Valor PDF ausente para ${label}`);
            return;
        }
        
        const diff = Math.abs(Number(pdfValue) - Number(uiValue));
        const ok = diff < tolerance;
        
        if (!ok) {
            console.warn(`üö® [PDF-VALIDATE] DIVERG√äNCIA em ${label}:`, {
                pdf: pdfValue,
                ui: uiValue,
                diferenca: diff.toFixed(3)
            });
        } else {
            console.log(`‚úÖ [PDF-VALIDATE] ${label}: OK (diff=${diff.toFixed(4)})`);
        }
    };
    
    try {
        const lufsValue = analysis.lufsIntegrated || analysis.loudness?.integrated || analysis.technicalData?.lufsIntegrated;
        if (lufsValue) assertEqual('LUFS Integrado', lufsValue, '[data-metric="lufs-integrated"]', 0.1);
        
        const truePeakValue = analysis.truePeakDbtp || analysis.truePeak?.maxDbtp || analysis.technicalData?.truePeakDbtp;
        if (truePeakValue) assertEqual('True Peak', truePeakValue, '[data-metric="true-peak"]', 0.1);
        
        const drValue = analysis.dynamicRange || analysis.dynamics?.range || analysis.technicalData?.dynamicRange;
        if (drValue) assertEqual('Dynamic Range', drValue, '[data-metric="dynamic-range"]', 0.5);
        
        if (analysis.score) assertEqual('Score', analysis.score, '.score-final-value', 1);
        
        console.log('‚úÖ [PDF-VALIDATE] Valida√ß√£o conclu√≠da');
    } catch (error) {
        console.error('‚ùå [PDF-VALIDATE] Erro na valida√ß√£o:', error);
    }
}

// üéØ Normalizar dados da an√°lise para formato compat√≠vel com PDF (NOVA VERS√ÉO ROBUSTA)
function normalizeAnalysisDataForPDF(analysis) {
    console.log('üìä [PDF-NORMALIZE] ============ IN√çCIO DA NORMALIZA√á√ÉO ============');
    console.log('üìä [PDF-NORMALIZE] Estrutura recebida:', {
        keys: Object.keys(analysis),
        fileName: analysis.fileName || analysis.metadata?.fileName,
        score: analysis.score,
        hasLufsRoot: !!analysis.lufsIntegrated,
        hasTruePeakRoot: !!analysis.truePeakDbtp,
        hasDRRoot: !!analysis.dynamicRange,
        hasBands: !!(analysis.bands || analysis.spectralBands)
    });
    
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return '‚Äî';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    const extract = (...paths) => {
        for (const path of paths) {
            if (typeof path === 'function') {
                const val = path();
                if (Number.isFinite(val)) return val;
            } else if (Number.isFinite(path)) {
                return path;
            }
        }
        return null;
    };
    
    const lufsIntegrated = extract(analysis.lufsIntegrated, analysis.loudness?.integrated, analysis.technicalData?.lufsIntegrated);
    const lufsShortTerm = extract(analysis.avgLoudness, analysis.loudness?.shortTerm, analysis.technicalData?.avgLoudness);
    const lufsMomentary = extract(lufsShortTerm, analysis.loudness?.momentary);
    const lra = extract(analysis.lra, analysis.loudness?.lra, analysis.technicalData?.lra);
    
    console.log('üéß [PDF-NORMALIZE] Loudness extra√≠do:', { integrated: lufsIntegrated, shortTerm: lufsShortTerm, momentary: lufsMomentary, lra });
    
    const truePeakDbtp = extract(analysis.truePeakDbtp, analysis.truePeak?.maxDbtp, analysis.technicalData?.truePeakDbtp);
    const clippingSamples = extract(analysis.truePeak?.clipping?.samples, analysis.clipping?.samples, 0);
    const clippingPercentage = extract(analysis.truePeak?.clipping?.percentage, analysis.clipping?.percentage, 0);
    
    console.log('‚öôÔ∏è [PDF-NORMALIZE] True Peak extra√≠do:', { maxDbtp: truePeakDbtp, clipping: { samples: clippingSamples, percentage: clippingPercentage }});
    
    const dynamicRange = extract(analysis.dynamicRange, analysis.dynamics?.range, analysis.technicalData?.dynamicRange);
    const crestFactor = extract(analysis.crestFactor, analysis.dynamics?.crest, analysis.technicalData?.crestFactor);
    
    console.log('üéöÔ∏è [PDF-NORMALIZE] Din√¢mica extra√≠da:', { range: dynamicRange, crest: crestFactor });
    
    const stereoWidth = extract(analysis.stereo?.width, analysis.stereoWidth, analysis.technicalData?.stereoWidth);
    const stereoCorrelation = extract(analysis.stereoCorrelation, analysis.stereo?.correlation, analysis.technicalData?.stereoCorrelation);
    const monoCompatibility = extract(analysis.stereo?.monoCompatibility, analysis.monoCompatibility);
    
    console.log('üéõÔ∏è [PDF-NORMALIZE] Stereo extra√≠do:', { width: stereoWidth, correlation: stereoCorrelation, monoCompatibility });
    
    // üîç AUDITORIA: Mapear todas as fontes poss√≠veis de bandas espectrais
    console.log('üìà [AUDIT-FREQ] Bandas dispon√≠veis em analysis:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        spectralBands_nested: analysis.spectral?.bands,
        userBands: analysis.user?.bands,
        userSpectralBands: analysis.user?.spectralBands,
        userSpectral: analysis.user?.spectral
    });
    
    // ‚úÖ FREQU√äNCIAS ‚Äî corrigindo campos energy_db, percentage e range
    const bandsSrc = analysis.bands || analysis.spectralBands || analysis.spectral?.bands || {};
    const extractBand = (band) => {
      if (!band) return { db: '‚Äî', pct: '‚Äî', range: '' };
      if (typeof band === 'number') return { db: band.toFixed(1), pct: '‚Äî', range: '' };
      const db = band.energy_db ?? band.rms_db ?? band.value ?? null;
      const pct = band.percentage ?? band.percent ?? null;
      const range = band.range ?? '';
      return {
        db: db !== null ? db.toFixed(1) : '‚Äî',
        pct: pct !== null ? pct.toFixed(1) + '%' : '‚Äî',
        range
      };
    };

    // Formata todas as bandas principais
    const spectral = {
      sub:  extractBand(bandsSrc.sub),
      bass: extractBand(bandsSrc.bass),
      lowMid: extractBand(bandsSrc.lowMid),
      mid:  extractBand(bandsSrc.mid),
      highMid: extractBand(bandsSrc.highMid),
      presence: extractBand(bandsSrc.presence),
      air: extractBand(bandsSrc.air)
    };

    console.log('ÔøΩ [PDF-FIX] Bandas espectrais resolvidas:', spectral);
    
    // ‚úÖ SCORE SINCRONIZADO COM A UI
    let score = analysis.scoring?.final 
             ?? analysis.user?.score 
             ?? analysis.scores?.final 
             ?? analysis.score 
             ?? 0;

    const uiScoreEl = document.querySelector('.score-final-value');
    if (uiScoreEl) {
      const scoreUI = parseFloat(uiScoreEl.dataset?.value || uiScoreEl.textContent || '0');
      if (!isNaN(scoreUI) && scoreUI > 0 && Math.abs(score - scoreUI) > 1) {
        console.warn('‚öôÔ∏è [PDF-FIX] Score ajustado com base na UI:', { old: score, new: scoreUI });
        score = scoreUI;
      }
    } else {
      console.warn('‚ö†Ô∏è [PDF-FIX] Elemento de score na UI n√£o encontrado, mantendo score:', score);
    }
    
    score = Math.round(score);
    const classification = analysis.classification || analysis.scoring?.classification || getClassificationFromScore(score);
    const fileName = analysis.fileName || analysis.metadata?.fileName || analysis.fileKey?.split('/').pop() || 'audio_sem_nome.wav';
    const duration = extract(analysis.duration, analysis.metadata?.duration, 0);
    const sampleRate = extract(analysis.sampleRate, analysis.metadata?.sampleRate, 44100);
    const channels = extract(analysis.channels, analysis.metadata?.channels, 2);
    
    // üîç AUDITORIA: Mapear todas as fontes poss√≠veis de diagn√≥sticos
    console.log('ü©∫ [AUDIT-DIAG] Diagn√≥stico dispon√≠vel em analysis:', {
        problems: analysis.problems,
        diagnostics: analysis.diagnostics,
        _diagnostic: analysis._diagnostic,
        userProblems: analysis.user?.problems,
        userDiagnostics: analysis.user?.diagnostics,
        problemsType: Array.isArray(analysis.problems) ? 'array' : typeof analysis.problems,
        diagnosticsType: Array.isArray(analysis.diagnostics) ? 'array' : typeof analysis.diagnostics
    });
    
    // ‚úÖ DIAGN√ìSTICO AUTOM√ÅTICO
    let diagnostics = [];

    if (analysis.diagnostics?.problems?.length > 0) {
      diagnostics = analysis.diagnostics.problems.map(p => p.message || p);
    } 
    else if (analysis.diagnostics?.suggestions?.length > 0) {
      diagnostics = analysis.diagnostics.suggestions.map(s => 
        `‚ö†Ô∏è ${s.message || s.type || 'Sugest√£o'} ‚Äî ${s.why || s.action || ''}`
      );
    } 
    else {
      diagnostics = ['‚úÖ Nenhum problema detectado'];
    }

    console.log('ü©∫ [PDF-FIX] Diagn√≥stico enriquecido:', diagnostics);
    
    // üîç AUDITORIA: Mapear todas as fontes poss√≠veis de sugest√µes
    console.log('üí° [AUDIT-SUG] Sugest√µes detectadas em analysis:', {
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        recommendations: analysis.recommendations,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        userSuggestions: analysis.user?.suggestions,
        userSuggestionsAdvanced: analysis.user?.suggestionsAdvanced,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        suggestionsType: Array.isArray(analysis.suggestions) ? `array[${analysis.suggestions?.length}]` : typeof analysis.suggestions,
        advancedType: Array.isArray(analysis.suggestionsAdvanced) ? `array[${analysis.suggestionsAdvanced?.length}]` : typeof analysis.suggestionsAdvanced
    });
    
    // ‚úÖ SUGEST√ïES ENRIQUECIDAS
    let suggestions = [];

    if (analysis.diagnostics?.suggestions?.length > 0) {
      suggestions = analysis.diagnostics.suggestions.map(s => {
        const title = s.message || s.type || 'Ajuste recomendado';
        const action = s.action ? ` ‚Üí ${s.action}` : '';
        const why = s.why ? ` (${s.why})` : '';
        return `${title}${action}${why}`;
      });
    } else if (Array.isArray(analysis.suggestions)) {
      suggestions = analysis.suggestions.map(s => 
        typeof s === 'string' ? s : s.message || s.type || 'Sugest√£o'
      );
    }

    console.log('üí° [PDF-FIX] Sugest√µes enriquecidas:', suggestions);
    
    // Normalizar para 'recommendations' (compatibilidade com retorno)
    const recommendations = suggestions.length > 0 ? suggestions : ['‚úÖ An√°lise completa'];
    
    const normalizedResult = {
        score,
        classification,
        fileName,
        duration,
        sampleRate,
        channels,
        bitDepth: analysis.bitDepth || analysis.metadata?.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(lufsIntegrated, 1),
            shortTerm: formatValue(lufsShortTerm, 1),
            momentary: formatValue(lufsMomentary, 1),
            lra: formatValue(lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeakDbtp, 2),
            clipping: { samples: clippingSamples || 0, percentage: formatValue(clippingPercentage, 2) }
        },
        dynamics: {
            range: formatValue(dynamicRange, 1),
            crest: formatValue(crestFactor, 1)
        },
        spectral: spectral,
        stereo: {
            width: formatValue(stereoWidth * 100, 1),
            correlation: formatValue(stereoCorrelation, 2),
            monoCompatibility: formatValue(monoCompatibility * 100, 1)
        },
        diagnostics: diagnostics.length > 0 ? diagnostics : ['‚úÖ Nenhum problema detectado'],
        recommendations: recommendations.length > 0 ? recommendations : ['‚úÖ An√°lise completa']
    };
    
    // üîç AUDITORIA: Resumo final comparativo
    console.log('üìä [AUDIT-PDF-SUMMARY] Resumo da Auditoria:', {
        hasFrequencies: !!(spectral.sub !== '‚Äî' || spectral.bass !== '‚Äî' || spectral.mid !== '‚Äî' || spectral.high !== '‚Äî'),
        frequenciesValues: spectral,
        hasDiagnostics: diagnostics.length > 0 && diagnostics[0] !== '‚úÖ Nenhum problema detectado',
        diagnosticsCount: diagnostics.length,
        hasSuggestions: recommendations.length > 0 && recommendations[0] !== '‚úÖ An√°lise completa',
        suggestionsCount: recommendations.length,
        suggestionsEnriched: analysis._suggestionsGenerated === true,
        score: score,
        scoreSource: analysis.score ? 'analysis.score' : (analysis.user?.score ? 'analysis.user.score' : 'scoreUI')
    });
    
    // üîç AUDITORIA: Comparar dados normalizados com valores da UI
    const uiSub = document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiBass = document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiMid = document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiHigh = document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent?.replace(/[^0-9.-]/g, '');
    
    console.log('üéö [AUDIT-FREQ-COMPARE] Compara√ß√£o UI vs PDF:', {
        sub: { ui: uiSub, pdf: spectral.sub, match: parseFloat(uiSub) === parseFloat(spectral.sub) },
        bass: { ui: uiBass, pdf: spectral.bass, match: parseFloat(uiBass) === parseFloat(spectral.bass) },
        mid: { ui: uiMid, pdf: spectral.mid, match: parseFloat(uiMid) === parseFloat(spectral.mid) },
        high: { ui: uiHigh, pdf: spectral.high, match: parseFloat(uiHigh) === parseFloat(spectral.high) }
    });
    
    console.log('‚úÖ [PDF-NORMALIZE] Resultado normalizado:', normalizedResult);
    console.log('üìä [PDF-NORMALIZE] ============ FIM DA NORMALIZA√á√ÉO ============');
    
    return normalizedResult;
}

// ÔøΩ Normalizar dados da an√°lise para formato compat√≠vel com PDF
function normalizeAnalysisData(analysis) {
    // üîç DIAGN√ìSTICO: Log completo da estrutura recebida
    console.log('üìä [PDF-NORMALIZE] ============ IN√çCIO DA NORMALIZA√á√ÉO ============');
    console.log('üìä [PDF-NORMALIZE] An√°lise completa recebida:', analysis);
    console.log('üìä [PDF-NORMALIZE] Chaves dispon√≠veis:', Object.keys(analysis));
    
    // üîß CORRE√á√ÉO: Dados podem estar na raiz, em metrics, ou em tech
    const metrics = analysis.metrics || {};
    const tech = analysis.tech || analysis.technicalData || {};
    
    console.log('üîç [PDF-NORMALIZE] Origem dos dados:', {
        hasMetrics: !!analysis.metrics,
        hasTech: !!analysis.tech,
        hasTechnicalData: !!analysis.technicalData,
        hasRootData: !!(analysis.loudness || analysis.truePeak || analysis.lufsIntegrated),
        metricsKeys: Object.keys(metrics),
        techKeys: Object.keys(tech)
    });
    
    // üîß CORRE√á√ÉO: Loudness pode estar em m√∫ltiplos lugares
    const loudness = metrics.loudness || tech.loudness || analysis.loudness || {
        // Fallback para propriedades na raiz
        integrated: analysis.lufsIntegrated,
        shortTerm: analysis.avgLoudness,
        momentary: analysis.avgLoudness,
        lra: analysis.lra
    };
    console.log('üéß [PDF-NORMALIZE] Loudness extra√≠do:', {
        source: metrics.loudness ? 'metrics' : (tech.loudness ? 'tech' : (analysis.loudness ? 'analysis.loudness' : 'raiz')),
        data: loudness,
        integrated: loudness.integrated,
        shortTerm: loudness.shortTerm,
        momentary: loudness.momentary,
        lra: loudness.lra
    });
    
    // üîß CORRE√á√ÉO: True Peak pode estar em m√∫ltiplos lugares
    const truePeak = metrics.truePeak || tech.truePeak || analysis.truePeak || {
        // Fallback para propriedades na raiz
        maxDbtp: analysis.truePeakDbtp,
        clipping: { samples: 0, percentage: 0 }
    };
    console.log('‚öôÔ∏è [PDF-NORMALIZE] True Peak extra√≠do:', {
        source: metrics.truePeak ? 'metrics' : (tech.truePeak ? 'tech' : (analysis.truePeak ? 'analysis.truePeak' : 'raiz')),
        data: truePeak,
        maxDbtp: truePeak.maxDbtp,
        clipping: truePeak.clipping
    });
    
    // üîß CORRE√á√ÉO: Din√¢mica pode estar em m√∫ltiplos lugares
    const dynamics = metrics.dynamics || tech.dynamics || analysis.dynamics || {
        // Fallback para propriedades na raiz
        range: analysis.dynamicRange,
        crest: analysis.crestFactor
    };
    console.log('üéöÔ∏è [PDF-NORMALIZE] Dynamics extra√≠do:', {
        source: metrics.dynamics ? 'metrics' : (tech.dynamics ? 'tech' : (analysis.dynamics ? 'analysis.dynamics' : 'raiz')),
        data: dynamics,
        range: dynamics.range,
        crest: dynamics.crest
    });
    
    // üîß CORRE√á√ÉO: Espectro pode estar em m√∫ltiplos lugares
    const spectral = metrics.spectral || tech.spectral || analysis.spectral || {};
    const bands = spectral.bands || analysis.spectralBands || analysis.bands || {};
    console.log('üìà [PDF-NORMALIZE] Spectral extra√≠do:', {
        source: metrics.spectral ? 'metrics' : (tech.spectral ? 'tech' : (analysis.spectral ? 'analysis.spectral' : (analysis.bands ? 'analysis.bands' : 'vazio'))),
        spectral: spectral,
        bands: bands,
        bandsKeys: Object.keys(bands)
    });
    
    // üîß CORRE√á√ÉO: Stereo pode estar em m√∫ltiplos lugares
    const stereo = metrics.stereo || tech.stereo || analysis.stereo || {};
    console.log('üéõÔ∏è [PDF-NORMALIZE] Stereo extra√≠do:', {
        source: metrics.stereo ? 'metrics' : (tech.stereo ? 'tech' : (analysis.stereo ? 'analysis.stereo' : 'vazio')),
        data: stereo,
        width: stereo.width,
        correlation: stereo.correlation,
        monoCompatibility: stereo.monoCompatibility
    });
    
    // Score e classifica√ß√£o
    const score = analysis.qualityOverall || analysis.score || 0;
    const classification = analysis.classification || getClassificationFromScore(score);
    
    // Diagn√≥sticos e recomenda√ß√µes
    const problems = analysis.problems || [];
    const suggestions = analysis.suggestions || [];
    const diagnostics = problems.length > 0 
        ? problems.map(p => p.message || p) 
        : ['‚úÖ Nenhum problema cr√≠tico detectado'];
    const recommendations = suggestions.length > 0 
        ? suggestions.map(s => s.message || s.action || s) 
        : ['‚úÖ An√°lise completa realizada com sucesso'];
    
    // Formata√ß√£o segura de valores
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'N/A';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    // Log do resultado final normalizado
    const normalizedResult = {
        score: Math.round(score),
        classification,
        fileName: analysis.fileName || 'audio_sem_nome.wav',
        duration: analysis.duration || 0,
        sampleRate: analysis.sampleRate || 44100,
        channels: analysis.channels || 2,
        bitDepth: analysis.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(loudness.integrated, 1),
            shortTerm: formatValue(loudness.shortTerm, 1),
            momentary: formatValue(loudness.momentary, 1),
            lra: formatValue(loudness.lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeak.maxDbtp, 2),
            clipping: {
                samples: truePeak.clipping?.samples || 0,
                percentage: formatValue(truePeak.clipping?.percentage, 2)
            }
        },
        dynamics: {
            range: formatValue(dynamics.range, 1),
            crest: formatValue(dynamics.crest, 1)
        },
        spectral: {
            sub: formatValue(bands.sub || bands.subBass, 1),
            bass: formatValue(bands.bass, 1),
            mid: formatValue(bands.mid || bands.midrange, 1),
            high: formatValue(bands.presence || bands.high || bands.treble, 1)
        },
        stereo: {
            width: formatValue(stereo.width, 1),
            correlation: formatValue(stereo.correlation, 2),
            monoCompatibility: formatValue(stereo.monoCompatibility, 1)
        },
        diagnostics,
        recommendations
    };
    
    console.log('‚úÖ [PDF-NORMALIZE] Resultado final normalizado:', normalizedResult);
    console.log('üìä [PDF-NORMALIZE] ============ FIM DA NORMALIZA√á√ÉO ============');
    
    return normalizedResult;
}

// üèÜ Classifica√ß√£o baseada em score
function getClassificationFromScore(score) {
    if (score >= 90) return 'üèÜ Profissional';
    if (score >= 75) return '‚≠ê Avan√ßado';
    if (score >= 60) return 'üëç Intermedi√°rio';
    if (score >= 40) return 'üìö B√°sico';
    return 'üîß Necessita Melhorias';
}

// üé® Gerar HTML profissional do relat√≥rio para PDF
function generateReportHTML(data) {
    // üîç AUDITORIA: Verificar dados recebidos para gera√ß√£o do HTML
    console.log('üìù [AUDIT-HTML] ============ IN√çCIO DA GERA√á√ÉO DO HTML ============');
    console.log('üìù [AUDIT-HTML] Dados recebidos:', {
        score: data.score,
        classification: data.classification,
        spectral: data.spectral,
        diagnostics: data.diagnostics,
        recommendations: data.recommendations,
        hasSpectralData: !!(data.spectral && (data.spectral.sub !== '‚Äî' || data.spectral.bass !== '‚Äî')),
        hasDiagnostics: data.diagnostics?.length > 0,
        hasRecommendations: data.recommendations?.length > 0
    });
    
    const date = new Date().toLocaleDateString('pt-BR');
    const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    
    // Formatar dura√ß√£o
    const minutes = Math.floor(data.duration / 60);
    const seconds = Math.floor(data.duration % 60);
    const durationStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
    
    return `
<div id="report-pdf-container" style="background: #0B0C14;">
    
    <!-- Estilos para otimiza√ß√£o desktop do PDF -->
    <style>
        /* Ajustes apenas para desktop (viewport >= 768px) */
        @media (min-width: 768px) {
            .frequency-spectrum-container {
                margin-top: -10px !important;
                margin-bottom: 20px !important;
            }
            
            .frequency-spectrum-cards {
                transform: scale(0.95);
                transform-origin: top center;
                margin-bottom: -10px;
            }
            
            .freq-card {
                height: 75px !important;
                padding: 10px !important;
            }
            
            /* Ajustes de rodap√© e recomenda√ß√µes (p√°gina 2) */
            .pdf-section-diagnostics .pdf-footer {
                margin-top: 25px !important;
                padding-bottom: 10px;
                position: relative;
                bottom: 0;
            }
            
            .pdf-section-recommendations {
                transform: scale(0.97);
                transform-origin: top center;
            }
        }
        
        /* Mobile mant√©m estilos originais (< 768px) */
        @media (max-width: 767px) {
            .frequency-spectrum-container {
                margin-top: 0 !important;
            }
            
            .frequency-spectrum-cards {
                transform: none;
            }
            
            .freq-card {
                height: auto !important;
            }
        }
    </style>
    
    <!-- ‚úÖ P√ÅGINA 1: M√âTRICAS PRINCIPAIS -->
    <div class="pdf-section-metrics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 32px; font-weight: 700; letter-spacing: -0.5px;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: #AAA;">Intelig√™ncia Artificial para Produtores Musicais</p>
            </div>
            <div style="text-align: right;">
                <h2 style="color: #8B5CF6; margin: 0; font-size: 24px; font-weight: 600;">Relat√≥rio de An√°lise</h2>
                <p style="font-size: 12px; color: #AAA; margin: 5px 0 0 0;">${date} √†s ${time}</p>
            </div>
        </div>

        <!-- Score Card -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); padding: 20px 30px; border-radius: 12px; color: white; margin-bottom: 30px; box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="margin: 0; font-size: 48px; font-weight: 700;">${data.score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h1>
                <p style="margin: 8px 0 0 0; font-size: 18px; opacity: 0.95; font-weight: 500;">${data.classification}</p>
            </div>
            <div style="font-size: 64px; opacity: 0.9;">üéµ</div>
        </div>
    </div>

    <!-- Informa√ß√µes do Arquivo -->
    <div style="background: rgba(255,255,255,0.05); padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #8B5CF6;">
        <p style="margin: 0; font-size: 12px; color: #AAA; text-transform: uppercase; letter-spacing: 0.5px;">ARQUIVO ANALISADO</p>
        <p style="margin: 8px 0 0 0; font-size: 16px; font-weight: 600; color: #FFF;">${data.fileName}</p>
        <p style="margin: 5px 0 0 0; font-size: 13px; color: #999;">
            ‚è±Ô∏è ${durationStr} min &nbsp;|&nbsp; üéöÔ∏è ${data.sampleRate}Hz &nbsp;|&nbsp; üîä ${data.channels === 2 ? 'Stereo' : data.channels + ' canais'}
        </p>
    </div>

    <!-- Grid de M√©tricas -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
        
        <!-- Loudness Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">üéß</span> Loudness
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Integrado:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.integrated} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Curto Prazo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.shortTerm} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Moment√¢neo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.momentary} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">LRA:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.lra} LU</span>
                </div>
            </div>
        </div>

        <!-- True Peak Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">‚öôÔ∏è</span> True Peak
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Pico Real:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.truePeak.maxDbtp} dBTP</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Clipping (samples):</span>
                    <span style="font-weight: 600; color: ${data.truePeak.clipping.samples > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.samples}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Clipping (%):</span>
                    <span style="font-weight: 600; color: ${parseFloat(data.truePeak.clipping.percentage) > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.percentage}%</span>
                </div>
            </div>
        </div>

        <!-- Din√¢mica Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">üéöÔ∏è</span> Din√¢mica
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Dynamic Range:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.range} dB</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Crest Factor:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.crest}</span>
                </div>
            </div>
        </div>

        <!-- Stereo Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">üéõÔ∏è</span> Stereo
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Largura Stereo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.width}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Correla√ß√£o:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.correlation}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Compat. Mono:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.monoCompatibility}%</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Espectro de Frequ√™ncias -->
    <div class="frequency-spectrum-container" style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid rgba(139, 92, 246, 0.2);">
        <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
            <span style="margin-right: 10px; font-size: 22px;">üìà</span> Espectro de Frequ√™ncias
        </h3>
        <div class="frequency-spectrum-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; font-size: 13px;">
            ${(() => {
                const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 768;
                const cardPadding = isDesktop ? '10px' : '12px';
                const fontSizeLarge = isDesktop ? '14px' : '18px';
                const marginTop = isDesktop ? '5px' : '8px';
                
                const renderBand = (label, band, range) => {
                    if (!band || !band.db) return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #AAA; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">‚Äî</p>
                        </div>
                    `;
                    return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #8B5CF6; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">${band.db} dB</p>
                        </div>
                    `;
                };
                
                return [
                    renderBand('SUB', data.spectral.sub, '20-60Hz'),
                    renderBand('GRAVE', data.spectral.bass, '60-150Hz'),
                    renderBand('LOW MID', data.spectral.lowMid, '150-500Hz'),
                    renderBand('M√âDIO', data.spectral.mid, '500-2kHz'),
                    renderBand('HIGH MID', data.spectral.highMid, '2-5kHz'),
                    renderBand('PRESENCE', data.spectral.presence, '5-10kHz'),
                    renderBand('AR', data.spectral.air, '10-20kHz')
                ].join('');
            })()}
        </div>
    </div>

    <!-- Rodap√© da P√°gina 1 -->
    <div style="text-align: center; padding-top: 40px; margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">SoundyAI ¬© 2025</p>
        <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">P√°gina 1/2 | M√©tricas Principais</p>
    </div>

    </div>
    <!-- FIM DA P√ÅGINA 1 -->

    <!-- ‚úÖ P√ÅGINA 2: DIAGN√ìSTICO E RECOMENDA√á√ïES -->
    <div class="pdf-section-diagnostics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header Simplificado (P√°gina 2) -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 28px; font-weight: 700;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 13px; color: #AAA;">Diagn√≥stico e Recomenda√ß√µes da IA</p>
            </div>
            <div style="text-align: right;">
                <p style="font-size: 14px; color: #AAA; margin: 0;">${data.fileName}</p>
                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">P√°gina 2/2</p>
            </div>
        </div>

        <!-- Diagn√≥stico -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">üß†</span> Diagn√≥stico Autom√°tico
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.diagnostics.map(d => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">‚Ä¢</span> ${d}
                </li>`).join('')}
            </ul>
        </div>

        <!-- Recomenda√ß√µes -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 50px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">üí°</span> Recomenda√ß√µes da IA
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.recommendations.map(r => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">‚Ä¢</span> ${r}
                </li>`).join('')}
            </ul>
        </div>

        <!-- Rodap√© Final -->
        <div style="position: absolute; bottom: 30px; left: 40px; right: 40px; text-align: center; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">
                SoundyAI ¬© 2025
            </p>
            <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">
                Intelig√™ncia Artificial para Produtores Musicais | Relat√≥rio gerado automaticamente
            </p>
        </div>

    </div>
    <!-- FIM DA P√ÅGINA 2 -->

</div>
    `;
}

// ÔøΩüìã Gerar relat√≥rio detalhado (LEGACY - mantido para compatibilidade)
function generateDetailedReport(analysis) {
    const now = new Date();
    let report = `üéµ PROD.AI - RELAT√ìRIO DE AN√ÅLISE DE √ÅUDIO\n`;
    report += `${'='.repeat(50)}\n\n`;
    report += `üìÖ Data: ${now.toLocaleString('pt-BR')}\n`;
    report += `üî¨ An√°lise realizada com tecnologia Web Audio API\n\n`;
    
    report += `üìä DADOS T√âCNICOS PRINCIPAIS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `Peak Level: ${analysis.technicalData.peak.toFixed(2)} dB\n`;
    report += `RMS Level: ${analysis.technicalData.rms.toFixed(2)} dB\n`;
    report += `Dynamic Range: ${analysis.technicalData.dynamicRange.toFixed(2)} dB\n`;
    report += `Duration: ${analysis.duration.toFixed(2)} seconds\n`;
    report += `Sample Rate: ${analysis.sampleRate || 'N/A'} Hz\n`;
    report += `Channels: ${analysis.channels || 'N/A'}\n\n`;
    
    if (analysis.technicalData?.dominantFrequencies?.length > 0) {
        report += `üéØ FREQU√äNCIAS DOMINANTES:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.technicalData.dominantFrequencies.slice(0, 10).forEach((freq, i) => {
            report += `${i + 1}. ${Math.round(freq.frequency)} Hz (${freq.occurrences} ocorr√™ncias)\n`;
        });
        report += `\n`;
    }
    
    if (analysis.problems.length > 0) {
        report += `üö® PROBLEMAS DETECTADOS:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.problems.forEach((problem, i) => {
            report += `${i + 1}. PROBLEMA: ${problem.message}\n`;
            report += `   SOLU√á√ÉO: ${problem.solution}\n`;
            report += `   SEVERIDADE: ${problem.severity}\n\n`;
        });
    }
    
    if (analysis.suggestions.length > 0) {
        report += `üí° SUGEST√ïES DE MELHORIA:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.suggestions.forEach((suggestion, i) => {
            report += `${i + 1}. ${suggestion.message}\n`;
            report += `   A√á√ÉO: ${suggestion.action}\n`;
            report += `   TIPO: ${suggestion.type}\n\n`;
        });
    }
    
    report += `üìù OBSERVA√á√ïES T√âCNICAS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `‚Ä¢ Esta an√°lise foi realizada usando Web Audio API\n`;
    report += `‚Ä¢ Para an√°lises mais avan√ßadas, considere usar ferramentas profissionais\n`;
    report += `‚Ä¢ Valores de refer√™ncia: RMS ideal para streaming: -14 LUFS\n`;
    report += `‚Ä¢ Peak ideal: m√°ximo -1 dB para evitar clipping\n`;
    report += `‚Ä¢ Dynamic range ideal: entre 8-15 dB para m√∫sica popular\n\n`;
    
    report += `üéµ Gerado por PROD.AI - Seu mentor de produ√ß√£o musical\n`;
    report += `üì± Para mais an√°lises: prod-ai-teste.vercel.app\n`;
    
    return report;
}

// üí¨ Mostrar feedback tempor√°rio
function showTemporaryFeedback(message) {
    // Criar elemento de feedback
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #00d4ff, #0096cc);
        color: #000;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10001;
        animation: slideInRight 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    `;
    feedback.textContent = message;
    
    // Adicionar anima√ß√£o CSS
    if (!document.getElementById('feedbackStyles')) {
        const style = document.createElement('style');
        style.id = 'feedbackStyles';
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(feedback);
    
    // Remover ap√≥s 3 segundos
    setTimeout(() => {
        feedback.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.parentNode.removeChild(feedback);
            }
        }, 300);
    }, 3000);
}

__dbg('üéµ Audio Analyzer Integration Script carregado!');

// Inicializar quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    __dbg('üéµ DOM carregado, inicializando Audio Analyzer...');
    initializeAudioAnalyzerIntegration();
});

// Fallback: se o DOM j√° estiver carregado
if (document.readyState !== 'loading') {
    // se DOM j√° pronto, inicializar uma vez
    initializeAudioAnalyzerIntegration();
}

// Utilit√°rio opcional: testar consist√™ncia das m√©tricas com rean√°lises repetidas do mesmo arquivo
// Uso (dev): window.__testConsistency(file, 3).then(console.log)
if (typeof window !== 'undefined' && !window.__testConsistency) {
    window.__testConsistency = async function(file, runs = 3) {
        const out = { runs: [], deltas: {} };
        for (let i = 0; i < runs; i++) {
            const t0 = performance.now();
            // üÜî CORRE√á√ÉO: Adicionar runId para fun√ß√µes de teste de consist√™ncia
            const testOptions = prepareAnalysisOptions({}, `consistency_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, testOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufs: res?.technicalData?.lufsIntegrated ?? res?.metrics?.lufs ?? null,
                truePeakDbtp: res?.technicalData?.truePeakDbtp ?? res?.metrics?.truePeakDbtp ?? null,
                dr: res?.technicalData?.dynamicRange ?? res?.metrics?.dynamicRange ?? null,
                lra: res?.technicalData?.lra ?? null,
                processingMs: res?.processingMs ?? (t1 - t0)
            });
        }
        // calcular deltas
        const vals = (key) => out.runs.map(r => r[key]).filter(v => Number.isFinite(v));
        const stats = (arr) => arr.length ? { min: Math.min(...arr), max: Math.max(...arr), spread: Math.max(...arr)-Math.min(...arr) } : null;
        out.deltas.lufs = stats(vals('lufs'));
        out.deltas.truePeakDbtp = stats(vals('truePeakDbtp'));
        out.deltas.dr = stats(vals('dr'));
        out.deltas.lra = stats(vals('lra'));
        return out;
    };
}

// üéØ FINAL: Display Reference Results
window.displayReferenceResults = function(referenceResults) {
    window.logReferenceEvent('displaying_reference_results', {
        baseline_source: referenceResults.baseline_source,
        has_suggestions: referenceResults.referenceSuggestions?.length > 0
    });
    
    try {
        const { comparisonData, referenceSuggestions, baseline_source } = referenceResults;
        
        if (baseline_source !== 'reference') {
            throw new Error(`Invalid baseline source: ${baseline_source}. Expected 'reference'`);
        }
        
        if (!comparisonData) {
            throw new Error('Missing comparison data in reference results');
        }

        const results = document.getElementById('results');
        if (!results) {
            throw new Error('Results container not found');
        }

        // Exibir se√ß√£o de compara√ß√£o
        displayComparisonSection(comparisonData, referenceSuggestions || []);
        
        // Se h√° sugest√µes, exibir
        if (referenceSuggestions && referenceSuggestions.length > 0) {
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = referenceSuggestions.map(suggestion => 
                    `<div class="suggestion-item">
                        <h4>${suggestion.category}</h4>
                        <p>${suggestion.text}</p>
                        <div class="suggestion-details">
                            <small>Diferen√ßa: ${suggestion.difference} | Threshold: ${suggestion.threshold}</small>
                        </div>
                    </div>`
                ).join('');
            }
        } else {
            // Audio id√™ntico - mostrar mensagem de sucesso
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = `
                    <div class="no-suggestions">
                        <h3>‚úÖ An√°lise de Refer√™ncia Conclu√≠da</h3>
                        <p>Os √°udios s√£o altamente similares. Diferen√ßas dentro da toler√¢ncia aceit√°vel.</p>
                    </div>
                `;
            }
        }
        
        window.logReferenceEvent('reference_results_displayed_successfully');
        
    } catch (error) {
        console.error('Error displaying reference results:', error);
        window.logReferenceEvent('reference_display_error', { 
            error: error.message,
            baseline_source: referenceResults.baseline_source 
        });
        
        // Fallback display
        const results = document.getElementById('results');
        if (results) {
            results.innerHTML = `
                <div class="error-display">
                    <h3>‚ùå Erro na Exibi√ß√£o dos Resultados</h3>
                    <p>Erro: ${error.message}</p>
                    <p>Baseline Source: ${referenceResults.baseline_source}</p>
                </div>
            `;
        }
    }
};

// =============== FUN√á√ïES DE NORMALIZA√á√ÉO DE DADOS ===============

/**
 * üéØ GERADOR DE SUGEST√ïES B√ÅSICAS
 * Gera sugest√µes baseadas nas m√©tricas t√©cnicas (fallback se backend n√£o enviar)
 * 
 * @param {Object} data - Dados normalizados da an√°lise
 * @returns {Array} - Array de sugest√µes estruturadas
 */
function generateBasicSuggestions(data) {
    const suggestions = [];
    const technicalData = data.technicalData || {};
    
    console.log('[SUG-AUDIT] üîç generateBasicSuggestions IN√çCIO:', {
        hasTechnicalData: !!technicalData,
        hasLufs: technicalData.lufsIntegrated != null,
        hasTruePeak: technicalData.truePeakDbtp != null,
        hasDR: technicalData.dynamicRange != null,
        hasLRA: technicalData.lra != null,
        hasBands: !!(technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands)
    });
    
    // Regra 1: LUFS Integrado
    if (technicalData.lufsIntegrated != null) {
        const lufs = technicalData.lufsIntegrated;
        const ideal = -10.5; // Padr√£o para streaming
        const delta = Math.abs(lufs - ideal);
        
        if (delta > 1.0) {
            suggestions.push({
                type: 'loudness',
                category: 'loudness',
                message: `LUFS Integrado est√° em ${lufs.toFixed(1)} dB quando deveria estar pr√≥ximo de ${ideal.toFixed(1)} dB`,
                action: delta > 3 ? `Ajustar loudness em ${(ideal - lufs).toFixed(1)} dB via limitador` : `Refinar loudness final`,
                priority: delta > 3 ? 'cr√≠tica' : 'alta',
                band: 'full_spectrum',
                delta: (ideal - lufs).toFixed(1)
            });
        }
    }
    
    // Regra 2: True Peak
    if (technicalData.truePeakDbtp != null) {
        const tp = technicalData.truePeakDbtp;
        if (tp > -1.0) {
            suggestions.push({
                type: 'clipping',
                category: 'mastering',
                message: `True Peak em ${tp.toFixed(2)} dBTP est√° acima do limite seguro de -1.0 dBTP (risco de clipping em convers√£o)`,
                action: `Aplicar limitador com ceiling em -1.0 dBTP ou reduzir gain em ${(tp + 1.0).toFixed(2)} dB`,
                priority: 'cr√≠tica',
                band: 'full_spectrum',
                delta: (tp + 1.0).toFixed(2)
            });
        }
    }
    
    // Regra 3: Dynamic Range
    if (technicalData.dynamicRange != null) {
        const dr = technicalData.dynamicRange;
        const minDR = 6.0;
        
        if (dr < minDR) {
            suggestions.push({
                type: 'dynamics',
                category: 'mastering',
                message: `Dynamic Range est√° em ${dr.toFixed(1)} dB quando deveria estar acima de ${minDR.toFixed(1)} dB (mix muito comprimido)`,
                action: `Reduzir compress√£o/limita√ß√£o para recuperar ${(minDR - dr).toFixed(1)} dB de din√¢mica`,
                priority: 'alta',
                band: 'full_spectrum',
                delta: (minDR - dr).toFixed(1)
            });
        }
    }
    
    // Regra 4: LRA (Loudness Range)
    if (technicalData.lra != null) {
        const lra = technicalData.lra;
        const minLRA = 3.0; // M√≠nimo recomendado para evitar fadiga auditiva
        const maxLRA = 15.0; // M√°ximo para manter consist√™ncia
        
        if (lra < minLRA) {
            suggestions.push({
                type: 'lra_low',
                category: 'dynamics',
                message: `LRA (Loudness Range) est√° em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (mix sem varia√ß√£o din√¢mica)`,
                action: `Aumentar varia√ß√£o din√¢mica em ${(minLRA - lra).toFixed(1)} LU via automa√ß√£o ou compress√£o seletiva`,
                priority: 'm√©dia',
                band: 'full_spectrum',
                delta: (minLRA - lra).toFixed(1)
            });
        } else if (lra > maxLRA) {
            suggestions.push({
                type: 'lra_high',
                category: 'dynamics',
                message: `LRA (Loudness Range) est√° em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (varia√ß√£o din√¢mica excessiva)`,
                action: `Reduzir varia√ß√£o din√¢mica em ${(lra - maxLRA).toFixed(1)} LU via compress√£o multibanda`,
                priority: 'm√©dia',
                band: 'full_spectrum',
                delta: (lra - maxLRA).toFixed(1)
            });
        }
    }
    
    // Regras 5-11: Bandas Espectrais (7 bandas)
    const bands = technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands || {};
    
    if (Object.keys(bands).length > 0) {
        const idealRanges = {
            sub: { min: -38, max: -28, name: 'Sub (20-60Hz)' },
            bass: { min: -31, max: -25, name: 'Bass (60-150Hz)' },
            lowMid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' },
            low_mid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' }, // Alias
            mid: { min: -23, max: -17, name: 'Mid (500Hz-2kHz)' },
            highMid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' },
            high_mid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' }, // Alias
            presence: { min: -23, max: -17, name: 'Presence (5-10kHz)' },
            air: { min: -30, max: -24, name: 'Air (10-20kHz)' }
        };
        
        for (const [band, ideal] of Object.entries(idealRanges)) {
            const bandData = bands[band];
            if (bandData && typeof bandData.energy_db === 'number') {
                const value = bandData.energy_db;
                
                if (value < ideal.min) {
                    const delta = ideal.min - value;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} est√° em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB abaixo do m√≠nimo)`,
                        action: `Aumentar ${ideal.name} em +${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'm√©dia',
                        band: band,
                        delta: `+${delta.toFixed(1)}`
                    });
                } else if (value > ideal.max) {
                    const delta = value - ideal.max;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} est√° em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB acima do m√°ximo)`,
                        action: `Reduzir ${ideal.name} em -${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'm√©dia',
                        band: band,
                        delta: `-${delta.toFixed(1)}`
                    });
                }
            }
        }
    }
    
    console.log(`[SUG-AUDIT] ‚úÖ generateBasicSuggestions FIM: ${suggestions.length} sugest√µes geradas`);
    suggestions.forEach((sug, i) => {
        console.log(`[SUG-AUDIT] Sugest√£o ${i + 1}/${suggestions.length}:`, {
            type: sug.type,
            category: sug.category,
            message: sug.message.substring(0, 60) + '...',
            priority: sug.priority
        });
    });
    
    return suggestions;
}

/**
 * üîß FUN√á√ÉO CORRIGIDA: Normalizar dados do backend (compat√≠vel com JSON antigo e novo)
 * Mapeia a resposta do backend para o formato que o front-end espera
 * ‚úÖ Compat√≠vel com JSON antigo e novo (pr√©/p√≥s Redis)
 */
function normalizeBackendAnalysisData(result) {
    // üî• PROTE√á√ÉO CR√çTICA: Preservar technicalData e genreTargets ANTES de qualquer manipula√ß√£o
    const __protected = {
        technicalData: structuredClone(result?.technicalData || result?.data?.technicalData || {}),
        genreTargets: structuredClone(result?.data?.genreTargets || result?.genreTargets || null),
        metadata: structuredClone(result?.metadata || {}),
        score: result?.score ?? null,
        classification: result?.classification ?? null
    };
    
    console.log('[NORMALIZE] üõ°Ô∏è PROTE√á√ÉO ATIVADA - Dados preservados:', {
        technicalDataKeys: Object.keys(__protected.technicalData).length,
        hasGenreTargets: !!__protected.genreTargets,
        genreTargetsKeys: __protected.genreTargets ? Object.keys(__protected.genreTargets) : null,
        hasMetadata: Object.keys(__protected.metadata).length > 0,
        score: __protected.score,
        classification: __protected.classification
    });
    
    // ‚úÖ STEP 5/6: Blindagem total ‚Äî clonar entrada para evitar muta√ß√£o de objetos compartilhados
    if (result && typeof result === 'object') {
        console.log('[NORMALIZE] üõ°Ô∏è Clonando entrada para evitar contamina√ß√£o');
        result = JSON.parse(JSON.stringify(result));
    }
    // ÔøΩÔ∏è PROTE√á√ÉO: Detectar normaliza√ß√£o duplicada
    if (result?.__normalized === true) {
        console.warn('[NORMALIZE] ‚ö†Ô∏è Objeto j√° foi normalizado anteriormente - retornando clone');
        console.warn('[NORMALIZE] jobId:', result?.jobId, 'fileName:', result?.metadata?.fileName);
        // Retornar clone profundo para evitar muta√ß√£o
        return deepCloneSafe(result);
    }
    
    // ÔøΩüîç AUDITORIA: Capturar estado ANTES de normaliza√ß√£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚öôÔ∏è normalizeBackendAnalysisData - ENTRADA');
    console.log('üìä result (antes de normalizar):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result,
        hasMetadata: !!result?.metadata,
        hasTechnicalData: !!result?.technicalData,
        alreadyNormalized: result?.__normalized === true
    });
    console.groupEnd();
    
    console.log("[BACKEND RESULT] Received analysis with data:", result);
    
    // üéØ PROTE√á√ÉO CR√çTICA: Preservar modo reference se segunda faixa est√° ativa
    const state = window.__soundyState || {};
    if (state.reference?.isSecondTrack && state.render?.mode !== 'reference') {
        console.warn('[FIX] Corrigindo mode: reference for√ßado (segunda faixa ativa)');
        state.render = state.render || {};
        state.render.mode = 'reference';
        window.__soundyState = state;
    }
    
    // ‚úÖ Compat√≠vel com JSON antigo e novo (pr√©/p√≥s Redis)
    const data = result?.data ?? result;
    const src = data.metrics || data.technicalData || data.loudness || data.spectral || data;

    if (!src) {
        console.error("[NORMALIZE] ‚ùå Nenhuma fonte de dados encontrada:", result);
        throw new Error("source is not defined");
    }

    console.log("[NORMALIZE] Source data extracted:", src);
    console.log("[NORMALIZE] Full data structure:", data);
    
    // üéØ CR√çTICO: Preservar data.genre e data.genreTargets (FONTE OFICIAL DO BACKEND)
    console.log("[NORMALIZE] üéµ Preservando genre do backend:", {
        'data.genre': data.genre,
        'result.data.genre': result?.data?.genre,
        'hasGenreTargets': !!(data.genreTargets || result?.data?.genreTargets)
    });

    const loudness = src.loudness || data.loudness || data.technicalData?.loudness || {};
    const dynamics = src.dynamics || data.dynamics || data.technicalData?.dynamics || {};
    const truePeak = src.truePeak || data.truePeak || data.technicalData?.truePeak || {};
    const energy = src.energy || data.energy || data.technicalData?.energy || {};
    const bands = src.bands || src.spectralBands || data.technicalData?.bands || data.technicalData?.spectralBands || data.spectralBands || {};

    // üéØ CR√çTICO: Genre e mode no n√≠vel RAIZ (prioridade m√°xima para leitura)
    const backendGenre = result?.genre || 
                         data.genre || 
                         result?.data?.genre || 
                         result?.metadata?.genre ||
                         null;
    
    const backendMode = result?.mode || 
                        data.mode || 
                        'genre';
    
    // üö® RESTAURA√á√ÉO DE G√äNERO: Se backend retornou null E modo √© genre, restaurar preservado
    const preservedGenre = window.__CURRENT_SELECTED_GENRE || window.__PRESERVED_GENRE__;
    const finalGenre = (backendMode === 'genre' && (!backendGenre || backendGenre === null))
                        ? preservedGenre
                        : backendGenre;
    
    if (backendMode === 'genre' && (!backendGenre || backendGenre === null) && preservedGenre) {
        console.warn('[NORMALIZE] ‚ö†Ô∏è Backend retornou genre NULL em modo genre!');
        console.warn('[NORMALIZE] üîÑ RESTAURANDO genre preservado:', preservedGenre);
        console.log('[GENRE-BEFORE-RESTORE]', { backendGenre, preservedGenre, finalGenre });
    }
    
    const normalized = {
        // Preservar estrutura original
        ...data,
        
        genre: finalGenre,
        mode: backendMode,
        
        // üéØ CR√çTICO: Garantir que data.genre venha da FONTE CORRETA
        // üî• CORRE√á√ÉO DEFINITIVA: SPREAD PRIMEIRO, DEPOIS SOBRESCREVER com valores corretos
        data: {
            // PRIMEIRO: Spread para preservar outros dados
            ...(data.data || {}),
            
            // DEPOIS: FOR√áAR genre e genreTargets (NUNCA podem ser sobrescritos!)
            genre: result?.genre || 
                   data.genre || 
                   result?.data?.genre || 
                   null,
            
            // üî• CORRE√á√ÉO FASE 2: Priorizar data.data.genreTargets (onde backend realmente envia)
            // Backend monta: { data: { genreTargets: {...} } }
            // Ordem correta: data.data > result.data > __protected > null
            genreTargets: data.data?.genreTargets ||     // ‚úÖ PRIORIDADE 1: Onde backend envia
                         result?.data?.genreTargets ||   // ‚úÖ PRIORIDADE 2: Fallback estrutura alternativa
                         __protected.genreTargets ||     // ‚úÖ PRIORIDADE 3: Backup protegido no in√≠cio
                         null
        },
        
        // üîç AUDITORIA CR√çTICA: Verificar se spread contaminou genre
        __genreAudit: {
            preSpreadGenre: result?.genre || data.genre || null,
            dataDataGenre: data.data?.genre || null,
            spreadContamination: !!(data.data?.genre === null && (result?.genre || data.genre)),
            timestamp: new Date().toISOString()
        },
        
        // üéØ M√©tricas normalizadas (RMS e LUFS separados)
        avgLoudness: energy.rms ?? 
                    src.avgLoudness ?? 
                    src.rms ??
                    data.technicalData?.avgLoudness ?? 
                    data.technicalData?.rms ??
                    data.energy?.rms ??
                    null,
        
        lufsIntegrated: loudness.integratedLUFS ?? 
                       loudness.integrated ?? 
                       src.lufsIntegrated ?? 
                       data.technicalData?.lufsIntegrated ?? 
                       data.loudness?.integrated ?? 
                       null,
                       
        lra: loudness.lra ?? 
             src.lra ?? 
             data.technicalData?.lra ?? 
             data.loudness?.lra ?? 
             null,
             
        truePeakDbtp: truePeak.maxDbtp ?? 
                     src.truePeakDbtp ?? 
                     data.technicalData?.truePeakDbtp ?? 
                     null,
                     
        dynamicRange: dynamics.range ?? 
                     src.dynamicRange ?? 
                     data.technicalData?.dynamicRange ?? 
                     null,
                     
        crestFactor: dynamics.crest ?? 
                    src.crestFactor ?? 
                    src.crest_factor ??
                    data.technicalData?.crestFactor ?? 
                    null,
                     
        bands: bands,
        
        // üéØ Preservar estruturas aninhadas originais para fallback
        loudness: data.loudness || loudness,
        dynamics: data.dynamics || dynamics,
        truePeak: data.truePeak || truePeak,
        energy: data.energy || energy,
        
        // Estruturas t√©cnicas
        technicalData: {
            // üî• CORRE√á√ÉO CR√çTICA: N√ÉO reconstruir technicalData - usar APENAS o que veio do backend
            // O backend J√Å envia technicalData completo com todas as m√©tricas
            // Qualquer reconstru√ß√£o aqui DESTR√ìI os dados originais
            ...(data.technicalData || {}),
            
            // ‚ö†Ô∏è FALLBACK M√çNIMO: Apenas se technicalData vier vazio (n√£o deveria acontecer)
            // Estes fallbacks S√ì ser√£o usados se o campo n√£o existir no technicalData original
        },
        
        // üéØ CRITICAL FIX: Adicionar objeto metrics com nomenclatura snake_case
        // Isso garante compatibilidade com calculateLoudnessScore/Dynamics/Stereo
        metrics: {
            lufs_integrated: loudness.integratedLUFS ?? 
                            loudness.integrated ?? 
                            src.lufsIntegrated ?? 
                            data.technicalData?.lufsIntegrated ?? 
                            data.loudness?.integrated ?? 
                            null,
            
            true_peak_dbtp: truePeak.maxDbtp ?? 
                           src.truePeakDbtp ?? 
                           data.technicalData?.truePeakDbtp ?? 
                           null,
            
            dynamic_range: dynamics.range ?? 
                          src.dynamicRange ?? 
                          data.technicalData?.dynamicRange ?? 
                          null,
            
            lra: loudness.lra ?? 
                src.lra ?? 
                data.technicalData?.lra ?? 
                data.loudness?.lra ?? 
                null,
            
            stereo_correlation: src.stereoCorrelation ?? 
                               data.technicalData?.stereoCorrelation ??
                               data.stereoCorrelation ??
                               null,
            
            stereo_width: src.stereoWidth ??
                         data.technicalData?.stereoWidth ??
                         data.stereoWidth ??
                         null,
            
            crest_factor: dynamics.crest ?? 
                         src.crestFactor ?? 
                         src.crest_factor ??
                         data.technicalData?.crestFactor ?? 
                         null
        },
        
        metadata: data.metadata ?? {},
        
        // Preservar outros campos importantes
        problems: data.problems || [],
        // ‚úÖ PATCH CR√çTICO: Preservar suggestions do backend SEMPRE
        // N√£o usar || [] pois isso sobrescreve array vazio vindo do backend
        suggestions: Array.isArray(data.suggestions) ? data.suggestions : [],
        duration: data.duration || null,
        sampleRate: data.sampleRate || null,
        channels: data.channels || null,
        score: data.score || null,
        classification: data.classification || null
    };

    // ‚úÖ AUDITORIA CR√çTICA PR√â-GERA√á√ÉO: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] PR√â-NORMALIZA√á√ÉO data.suggestions:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        willPreserve: Array.isArray(data.suggestions) && data.suggestions.length > 0
    });

    // ‚úÖ GARANTIR SUGEST√ïES B√ÅSICAS SE BACKEND N√ÉO ENVIOU
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Entrada:`, {
        hasSuggestions: Array.isArray(normalized.suggestions),
        suggestionsLength: normalized.suggestions?.length || 0,
        source: 'backend'
    });
    
    if (!normalized.suggestions || normalized.suggestions.length === 0) {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Gerando sugest√µes b√°sicas no frontend...`);
        normalized.suggestions = generateBasicSuggestions(normalized);
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > ‚úÖ ${normalized.suggestions.length} sugest√µes b√°sicas geradas no frontend`);
    } else {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > ‚úÖ ${normalized.suggestions.length} sugest√µes vindas do backend (preservadas)`);
    }
    
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Sa√≠da:`, {
        suggestionsLength: normalized.suggestions.length,
        sampleFirst: normalized.suggestions[0]?.message?.substring(0, 50) + '...'
    });

    console.log("‚úÖ [NORMALIZE] Parsed data:", normalized);
    console.log("‚úÖ [NORMALIZE] Normalized metrics:", {
        avgLoudness: normalized.technicalData.avgLoudness,
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        crestFactor: normalized.technicalData.crestFactor,
        bands: normalized.technicalData.bandEnergies || normalized.technicalData.spectral_balance
    });
    
    // ‚úÖ PATCH: garantir estrutura spectral_balance
    if (!normalized.technicalData.spectral_balance) {
        const sourceBands = result?.analysis?.bands || 
                           data?.bands || 
                           data?.frequencyBands || 
                           result?.bands ||
                           src?.spectral_balance ||
                           null;
        
        if (sourceBands) {
            normalized.technicalData.spectral_balance = sourceBands;
            console.log("‚úÖ [NORMALIZER] spectral_balance restaurado automaticamente");
        } else {
            console.warn("‚ö†Ô∏è [NORMALIZER] Nenhum dado de bandas detectado ‚Äî criando estrutura vazia");
            normalized.technicalData.spectral_balance = {
                sub: 0,
                bass: 0,
                low_mid: 0,
                mid: 0,
                high_mid: 0,
                presence: 0,
                air: 0
            };
        }
    }
    
    // ÔøΩÔøΩ LOGS ESPEC√çFICOS DAS M√âTRICAS PRINCIPAIS (AUDITORIA COMPLETA RMS + LUFS)
    console.log('[AUDITORIA-RMS-LUFS] RMS:', normalized.technicalData.avgLoudness, 'LUFS:', normalized.technicalData.lufsIntegrated);
    
    // ‚úÖ AUDITORIA CR√çTICA: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] data.suggestions FROM BACKEND:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        type: typeof data.suggestions,
        sample: data.suggestions?.[0]
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > RMS=', normalized.technicalData.avgLoudness, {
        'energy.rms': energy.rms,
        'src.avgLoudness': src.avgLoudness,
        'src.rms': src.rms,
        'technicalData.avgLoudness': data.technicalData?.avgLoudness,
        'technicalData.rms': data.technicalData?.rms
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > LUFS=', normalized.technicalData.lufsIntegrated, {
        'loudness.integrated': loudness.integrated,
        'loudness.integratedLUFS': loudness.integratedLUFS,
        'src.lufsIntegrated': src.lufsIntegrated,
        'technicalData.lufsIntegrated': data.technicalData?.lufsIntegrated
    });
    
    // üî• FASE 2 - LOG DE VALIDA√á√ÉO: Confirmar que genreTargets foi preservado
    console.log('[FASE2-VALIDATION] üéØ genreTargets ap√≥s normaliza√ß√£o:', {
        exists: !!normalized.data?.genreTargets,
        keys: normalized.data?.genreTargets ? Object.keys(normalized.data.genreTargets) : null,
        hasBands: !!normalized.data?.genreTargets?.bands,
        bandKeys: normalized.data?.genreTargets?.bands ? Object.keys(normalized.data.genreTargets.bands) : null,
        source: data.data?.genreTargets ? 'data.data' : 
                result?.data?.genreTargets ? 'result.data' : 
                __protected.genreTargets ? '__protected' : 'none'
    });
    
    console.log('[METRICS-FIX] normalizeBackendAnalysisData > CREST=', normalized.technicalData.crestFactor, {
        'dynamics.crest': dynamics.crest,
        'src.crestFactor': src.crestFactor,
        'src.crest_factor': src.crest_factor,
        'technicalData.crestFactor': data.technicalData?.crestFactor
    });

    // üéØ CR√çTICO: Injetar genreReference no formato EXATO que o frontend espera
    const activeRef = window.__activeRefData;
    if (activeRef) {
        // Formato para o frontend (tabela de compara√ß√£o)
        normalized.genreReference = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        // Compatibilidade com o Suggestion Engine
        normalized.data = normalized.data || {};
        normalized.data.genreTargets = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        console.log('[GENRE-REFERENCE-INJECT] ‚úÖ genreReference injetado para frontend:', {
            hasSpectralBands: !!normalized.genreReference.spectral_bands,
            hasLufs: !!normalized.genreReference.lufs,
            hasTruePeak: !!normalized.genreReference.true_peak,
            bandCount: normalized.genreReference.spectral_bands ? Object.keys(normalized.genreReference.spectral_bands).length : 0
        });
    } else {
        console.warn('[GENRE-REFERENCE-INJECT] ‚ö†Ô∏è window.__activeRefData n√£o dispon√≠vel - tabela de compara√ß√£o pode n√£o renderizar');
    }

    // ÔøΩÔ∏è MARCAR: Flag para prevenir normaliza√ß√£o duplicada
    normalized.__normalized = true;
    normalized.__normalizedAt = Date.now();
    console.log('[NORMALIZE] ‚úÖ Objeto marcado como normalizado:', normalized.jobId);

    // ÔøΩüîç AUDITORIA: Estado AP√ìS normaliza√ß√£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ‚úÖ normalizeBackendAnalysisData - SA√çDA');
    console.log('üìä normalized (resultado):', {
        jobId: normalized?.jobId,
        fileName: normalized?.metadata?.fileName || normalized?.fileName,
        lufs: normalized?.technicalData?.lufsIntegrated,
        objectId: normalized,
        sameAsInput: normalized === result
    });
    console.log('üìä result (input original - VERIFICAR SE MUDOU):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result
    });
    console.log('‚ö†Ô∏è VERIFICA√á√ÉO DE MUTA√á√ÉO:');
    console.log('  normalized === result?', normalized === result);
    console.log('  normalized.technicalData === result.technicalData?', normalized.technicalData === result.technicalData);
    console.log('  normalized.metadata === result.metadata?', normalized.metadata === result.metadata);
    if (normalized.technicalData === result.technicalData) {
        console.warn('üö® MUTA√á√ÉO DETECTADA: technicalData compartilha refer√™ncia!');
    }
    if (normalized.metadata === result.metadata) {
        console.warn('üö® MUTA√á√ÉO DETECTADA: metadata compartilha refer√™ncia!');
    }
    console.groupEnd();

    // ========================================
    // üîí BLINDAGEM CR√çTICA: Quebrar compartilhamento de ponteiros
    // ========================================
    if (normalized && normalized.metadata) {
      // quebra compartilhamento de ponteiro
      normalized.metadata = { ...normalized.metadata };
    }
    if (normalized && normalized.technicalData) {
      normalized.technicalData = { ...normalized.technicalData };
    }
    if (normalized && normalized.bands) {
      normalized.bands = cloneDeepSafe(normalized.bands);
    }

    // üî• RESTAURA√á√ÉO CR√çTICA: Restaurar dados protegidos do backend
    console.log('[NORMALIZE] üõ°Ô∏è RESTAURANDO dados protegidos do backend');
    
    if (__protected.technicalData && Object.keys(__protected.technicalData).length > 0) {
        console.log('[NORMALIZE] ‚úÖ Restaurando technicalData original:', Object.keys(__protected.technicalData).length, 'campos');
        normalized.technicalData = structuredClone(__protected.technicalData);
    } else {
        console.warn('[NORMALIZE] ‚ö†Ô∏è technicalData estava vazio na entrada - mantendo reconstru√≠do');
    }
    
    if (__protected.genreTargets) {
        if (!normalized.data) normalized.data = {};
        console.log('[NORMALIZE] ‚úÖ Restaurando genreTargets original:', Object.keys(__protected.genreTargets));
        normalized.data.genreTargets = structuredClone(__protected.genreTargets);
    } else {
        console.warn('[NORMALIZE] ‚ö†Ô∏è genreTargets estava ausente na entrada');
    }
    
    if (Object.keys(__protected.metadata).length > 0) {
        console.log('[NORMALIZE] ‚úÖ Restaurando metadata original');
        normalized.metadata = structuredClone(__protected.metadata);
    }
    
    if (__protected.score !== null) {
        console.log('[NORMALIZE] ‚úÖ Restaurando score original:', __protected.score);
        normalized.score = __protected.score;
    }
    
    if (__protected.classification !== null) {
        console.log('[NORMALIZE] ‚úÖ Restaurando classification original:', __protected.classification);
        normalized.classification = __protected.classification;
    }

    // ========================================
    // üîí RETORNO FINAL: Clone profundo para garantir isolamento total
    // ========================================
    const normalizedOut = cloneDeepSafe(normalized);
    Object.defineProperty(normalizedOut, 'sameAsInput', { value: false, enumerable: false });
    return normalizedOut;
}

// =============== FUN√á√ïES AUXILIARES ===============

// üß™ TESTE AUTOM√ÅTICO: Validar normaliza√ß√£o com JSON real
function testNormalizationCompatibility() {
    console.log("üß™ [TEST] Iniciando teste autom√°tico de compatibilidade...");
    
    // Teste 1: Formato antigo (pr√©-Redis)
    const oldFormat = {
        data: {
            metrics: {
                lufsIntegrated: -11.15,
                lra: 0.8,
                dynamicRange: 10.28
            },
            technicalData: {
                truePeakDbtp: -0.2,
                bands: {
                    bass: -12.5,
                    mid: -10.8,
                    treble: -15.2
                }
            }
        }
    };
    
    // Teste 2: Formato novo (p√≥s-Redis)
    const newFormat = {
        score: 100,
        classification: "Refer√™ncia Mundial",
        loudness: { integrated: -11.15, lra: 0.8 },
        truePeak: { maxDbtp: -0.2 },
        dynamics: { range: 10.28 },
        spectralBands: {
            bass: -12.5,
            mid: -10.8,
            treble: -15.2
        },
        metadata: { duration: 180 }
    };
    
    // Teste 3: Formato h√≠brido
    const hybridFormat = {
        metrics: { lufsIntegrated: -11.15 },
        loudness: { integrated: -12.0 },
        technicalData: { lra: 0.8, truePeakDbtp: -0.2 }
    };
    
    try {
        // üî• CORRE√á√ÉO: Usar dados DIRETOS (testes sem reconstru√ß√£o)
        const normalized1 = oldFormat; // ‚úÖ LEITURA DIRETA
        console.log("‚úÖ [TEST] Formato antigo DIRETO:", {
            lufs: normalized1.technicalData?.lufsIntegrated,
            lra: normalized1.technicalData?.lra,
            truePeak: normalized1.technicalData?.truePeakDbtp,
            dr: normalized1.technicalData?.dynamicRange
        });
        
        // üî• CORRE√á√ÉO: Usar dados DIRETOS (testes sem reconstru√ß√£o)
        const normalized2 = newFormat; // ‚úÖ LEITURA DIRETA
        console.log("‚úÖ [TEST] Formato novo DIRETO:", {
            lufs: normalized2.technicalData?.lufsIntegrated,
            lra: normalized2.technicalData?.lra,
            truePeak: normalized2.technicalData?.truePeakDbtp,
            dr: normalized2.technicalData?.dynamicRange
        });
        
        // üî• CORRE√á√ÉO: Usar dados DIRETOS (testes sem reconstru√ß√£o)
        const normalized3 = hybridFormat; // ‚úÖ LEITURA DIRETA
        console.log("‚úÖ [TEST] Formato h√≠brido normalizado:", {
            lufs: normalized3.technicalData.lufsIntegrated,
            lra: normalized3.technicalData.lra,
            truePeak: normalized3.technicalData.truePeakDbtp,
            dr: normalized3.technicalData.dynamicRange
        });
        
        // ‚úÖ Valida√ß√£o de estrutura
        const isValidStructure = (norm) => {
            return norm.technicalData && 
                   typeof norm.technicalData.lufsIntegrated !== 'undefined' &&
                   typeof norm.technicalData.lra !== 'undefined' &&
                   typeof norm.technicalData.truePeakDbtp !== 'undefined';
        };
        
        if (isValidStructure(normalized1) && isValidStructure(normalized2) && isValidStructure(normalized3)) {
            console.log("‚úÖ [TEST] Todos os formatos passaram na valida√ß√£o!");
            console.log("‚úÖ [TEST] Sistema de normaliza√ß√£o est√° funcionando corretamente");
            return true;
        } else {
            console.error("‚ùå [TEST] Falha na valida√ß√£o de estrutura");
            return false;
        }
        
    } catch (error) {
        console.error("‚ùå [TEST] Erro no teste de normaliza√ß√£o:", error);
        return false;
    }
}

// üöÄ Executar teste autom√°tico quando o arquivo carregar
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        setTimeout(() => {
            testNormalizationCompatibility();
        }, 1000);
    });
}

// üéØ FUN√á√ÉO: Aplicar corre√ß√£o de fallback ao score
    
    tech.lufsShortTerm = getRealValue('lufsShortTerm', 'lufs_short_term') ||
                        (backendData.loudness?.shortTerm && Number.isFinite(backendData.loudness.shortTerm) ? backendData.loudness.shortTerm : null);
    
    tech.lufsMomentary = getRealValue('lufsMomentary', 'lufs_momentary') ||
                        (backendData.loudness?.momentary && Number.isFinite(backendData.loudness.momentary) ? backendData.loudness.momentary : null);
    
    // LRA - CORRIGIR MAPEAMENTO PARA ESTRUTURA REAL: loudness.lra + technicalData.lra
    tech.lra = getRealValue('lra', 'loudnessRange', 'lra_tolerance', 'loudness_range') ||
              (backendData.loudness?.lra && Number.isFinite(backendData.loudness.lra) ? backendData.loudness.lra : null) ||
              (backendData.technicalData?.lra && Number.isFinite(backendData.technicalData.lra) ? backendData.technicalData.lra : null);
    
    console.log('üìä [NORMALIZE] M√©tricas mapeadas (apenas reais):', {
        peak: tech.peak,
        rms: tech.rms,
        dynamicRange: tech.dynamicRange,
        crestFactor: tech.crestFactor,
        truePeakDbtp: tech.truePeakDbtp,
        lufsIntegrated: tech.lufsIntegrated,
        lufsShortTerm: tech.lufsShortTerm,
        lufsMomentary: tech.lufsMomentary,
        lra: tech.lra
    });
    
    // üéØ LOG ESPEC√çFICO PARA AUDITORIA: LRA com estrutura real
    if (tech.lra !== null) {
        console.log('‚úÖ [LRA] SUCESSO: LRA mapeado corretamente =', tech.lra);
    } else {
        console.warn('‚ùå [LRA] PROBLEMA: LRA n√£o foi encontrado no backend data');
        console.log('üîç [LRA] Debug - poss√≠veis caminhos verificados:', {
            'backendData.loudness.lra': backendData.loudness?.lra,
            'backendData.technicalData.lra': backendData.technicalData?.lra,
            'source (technicalData)': source.lra || source.loudnessRange,
            'loudnessObject': backendData.loudness,
            'technicalDataObject': backendData.technicalData
        });
    }
    
    // Headroom - APENAS VALORES REAIS
    tech.headroomDb = getRealValue('headroomDb', 'headroom_db');
    tech.headroomTruePeakDb = getRealValue('headroomTruePeakDb');
    
    // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
    tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                            (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
    
    tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                      (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);
    
    tech.balanceLR = getRealValue('balanceLR', 'balance_lr') ||
                    (backendData.stereo?.balance && Number.isFinite(backendData.stereo.balance) ? backendData.stereo.balance : null);
    
    // Spectral - APENAS VALORES REAIS
    tech.spectralCentroid = getRealValue('spectralCentroid', 'spectral_centroid');
    tech.spectralRolloff = getRealValue('spectralRolloff', 'spectral_rolloff');
    tech.zeroCrossingRate = getRealValue('zeroCrossingRate', 'zero_crossing_rate');
    tech.spectralFlux = getRealValue('spectralFlux', 'spectral_flux');
    tech.spectralFlatness = getRealValue('spectralFlatness', 'spectral_flatness');
    
    // Problemas t√©cnicos - APENAS VALORES REAIS
    tech.clippingSamples = getRealValue('clippingSamples', 'clipping_samples');
    tech.clippingPct = getRealValue('clippingPct', 'clipping_pct');
    tech.dcOffset = getRealValue('dcOffset', 'dc_offset');
    tech.thdPercent = getRealValue('thdPercent', 'thd_percent');
    
    // Sample peaks por canal - APENAS VALORES REAIS
    tech.samplePeakLeftDb = getRealValue('samplePeakLeftDb', 'sample_peak_left_db');
    tech.samplePeakRightDb = getRealValue('samplePeakRightDb', 'sample_peak_right_db');
    
    // ===== NOVAS M√âTRICAS IMPLEMENTADAS =====
    
    // Spectral Bandwidth e outras m√©tricas espectrais
    tech.spectralBandwidth = getRealValue('spectralBandwidth', 'spectral_bandwidth');
    tech.spectralBandwidthHz = tech.spectralBandwidth; // Alias
    tech.spectralSpread = getRealValue('spectralSpread', 'spectral_spread');
    tech.spectralCrest = getRealValue('spectralCrest', 'spectral_crest');
    tech.spectralSkewness = getRealValue('spectralSkewness', 'spectral_skewness');
    tech.spectralKurtosis = getRealValue('spectralKurtosis', 'spectral_kurtosis');
    
    // üéµ SPECTRAL BALANCE - Mapear dados espectrais REAIS do backend
    if (source.spectral_balance || source.spectralBalance || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        
        const spectralSource = source.spectral_balance || source.spectralBalance || source.bands || 
                              backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        
        console.log('üîç [SPECTRAL] Fonte espectral detectada:', spectralSource);
        
        // Fun√ß√£o espec√≠fica para dados espectrais
        const getSpectralValue = (...paths) => {
            for (const path of paths) {
                const value = path.split('.').reduce((obj, key) => obj?.[key], spectralSource);
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            return null;
        };
        
        // Se spectral_balance √© string (ex: "balanced"), mapear para objeto
        if (typeof spectralSource === 'string') {
            tech.spectral_balance = {
                description: spectralSource,
                status: spectralSource
            };
            console.log('üìä [NORMALIZE] Spectral balance (string):', tech.spectral_balance);
        } else {
            tech.spectral_balance = {
                sub: getSpectralValue('sub', 'subBass', 'sub_bass'),
                bass: getSpectralValue('bass', 'low_bass', 'lowBass'),  // Normalizar para 'bass'
                lowMid: getSpectralValue('lowMid', 'low_mid', 'lowmid'),
                mid: getSpectralValue('mid', 'mids', 'middle'),
                highMid: getSpectralValue('highMid', 'high_mid', 'highmid'),
                presence: getSpectralValue('presence', 'presenca'),
                air: getSpectralValue('air', 'brilho', 'treble', 'high')
            };
            console.log('üìä [NORMALIZE] Spectral balance mapeado:', tech.spectral_balance);
        }
        
        // üéØ LOG ESPEC√çFICO PARA AUDITORIA: BANDAS ESPECTRAIS
        const bandasDetectadas = typeof tech.spectral_balance === 'object' && tech.spectral_balance.description ? 
            [`description: ${tech.spectral_balance.description}`] :
            Object.entries(tech.spectral_balance)
                .filter(([key, value]) => value !== null && key !== 'description' && key !== 'status')
                .map(([key, value]) => `${key}: ${value}`);
        
        if (bandasDetectadas.length > 0) {
            console.log(`‚úÖ [BANDAS] SUCESSO: ${bandasDetectadas.length} bandas mapeadas:`, bandasDetectadas.join(', '));
        } else {
            console.warn('‚ùå [BANDAS] PROBLEMA: Nenhuma banda espectral foi mapeada');
            console.log('üîç [BANDAS] Debug - caminhos verificados:', {
                'source.spectral_balance': source.spectral_balance,
                'source.spectralBalance': source.spectralBalance, 
                'source.bands': source.bands,
                'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
                'backendData.technicalData.bands': backendData.technicalData?.bands,
                'spectralSource': spectralSource
            });
        }
    } else {
        // N√£o definir se n√£o h√° dados reais
        tech.spectral_balance = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Nenhum dado espectral real encontrado');
        console.log('üîç [NORMALIZE] Debug espectral - caminhos verificados:', {
            'source.spectral_balance': source.spectral_balance,
            'source.spectralBalance': source.spectralBalance,
            'source.bands': source.bands,
            'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
            'backendData.technicalData.bands': backendData.technicalData?.bands
        });
    }
    
    // üé∂ BAND ENERGIES - Mapear energias das bandas de frequ√™ncia REAIS do backend
    if (source.bandEnergies || source.band_energies || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        const bandsSource = source.bandEnergies || source.band_energies || source.bands || 
                          backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        tech.bandEnergies = {};
        
        // Mapear bandas conhecidas - APENAS VALORES REAIS
        const bandMapping = {
            'sub': 'sub',
            'subBass': 'sub', 
            'sub_bass': 'sub',
            'low_bass': 'bass',  // Normalizar para 'bass'
            'lowBass': 'bass',
            'bass': 'bass',
            'upper_bass': 'bass',
            'upperBass': 'bass',
            'low_mid': 'lowMid',  // Normalizar para 'lowMid'
            'lowMid': 'lowMid',
            'lowmid': 'lowMid',
            'mid': 'mid',
            'mids': 'mid',
            'middle': 'mid',
            'high_mid': 'highMid',  // Normalizar para 'highMid'
            'highMid': 'highMid',
            'highmid': 'highMid',
            'upper_mid': 'highMid',
            'upperMid': 'highMid',
            'brilho': 'air',  // Normalizar para 'air'
            'brilliance': 'air',
            'air': 'air',
            'treble': 'air',
            'high': 'air',
            'presenca': 'presence',  // Normalizar para 'presence'
            'presence': 'presence'
        };
        
        Object.entries(bandMapping).forEach(([sourceKey, targetKey]) => {
            const bandData = bandsSource[sourceKey];
            if (bandData && typeof bandData === 'object') {
                // Pegar apenas valores reais, sem fallbacks
                const rms_db = Number.isFinite(bandData.rms_db) ? bandData.rms_db : 
                              Number.isFinite(bandData.energy_db) ? bandData.energy_db :
                              Number.isFinite(bandData.level) ? bandData.level : null;
                              
                const peak_db = Number.isFinite(bandData.peak_db) ? bandData.peak_db : null;
                const frequency_range = bandData.frequency_range || bandData.range || null;
                
                // S√≥ adicionar se tiver pelo menos um valor real
                if (rms_db !== null || peak_db !== null) {
                    tech.bandEnergies[targetKey] = {
                        rms_db: rms_db,
                        peak_db: peak_db,
                        frequency_range: frequency_range
                    };
                }
            }
        });
        
        console.log('üìä [NORMALIZE] Band energies mapeadas (apenas reais):', tech.bandEnergies);
        
        // Se n√£o conseguiu mapear nenhuma banda real, deixar null
        if (Object.keys(tech.bandEnergies).length === 0) {
            tech.bandEnergies = null;
            console.log('‚ö†Ô∏è [NORMALIZE] Nenhuma banda real encontrada - bandEnergies = null');
        }
    } else {
        tech.bandEnergies = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Dados de bandas n√£o encontrados - bandEnergies = null');
    }
    
    // üéº TONAL BALANCE - Estrutura simplificada para compatibilidade APENAS COM VALORES REAIS
    if (tech.bandEnergies && Object.keys(tech.bandEnergies).length > 0) {
        tech.tonalBalance = {
            sub: tech.bandEnergies.sub || null,
            low: tech.bandEnergies.low_bass || null,
            mid: tech.bandEnergies.mid || null,
            high: tech.bandEnergies.brilho || null
        };
        console.log('üìä [NORMALIZE] Tonal balance baseado em bandEnergies reais:', tech.tonalBalance);
    } else {
        tech.tonalBalance = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Nenhuma banda real para tonal balance - tonalBalance = null');
    }
    
    // üéØ FREQU√äNCIAS DOMINANTES - Estrutura completa com detailed
    if (source.dominantFrequencies || source.dominant_frequencies) {
        const rawData = source.dominantFrequencies || source.dominant_frequencies;
        
        // Se for string/n√∫mero simples, converter para structured format
        if (typeof rawData === 'string' || typeof rawData === 'number') {
            tech.dominantFrequencies = {
                value: rawData,
                unit: 'Hz'
            };
        } else if (rawData && typeof rawData === 'object') {
            // Se for object com detailed
            tech.dominantFrequencies = {
                value: rawData.value || rawData.primary || null,
                unit: rawData.unit || 'Hz',
                detailed: rawData.detailed || {
                    primary: rawData.primary || rawData.value || null,
                    secondary: rawData.secondary || null,
                    peaks: rawData.peaks || []
                }
            };
        } else {
            tech.dominantFrequencies = null;
        }
        console.log('üìä [NORMALIZE] Frequ√™ncias dominantes estruturadas:', tech.dominantFrequencies);
    } else {
        tech.dominantFrequencies = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Frequ√™ncias dominantes n√£o encontradas - dominantFrequencies = null');
    }
    
    // üîÑ DC OFFSET - Estrutura completa com canais L/R
    if (source.dcOffset || source.dc_offset) {
        const rawDcData = source.dcOffset || source.dc_offset;
        
        // Se for n√∫mero simples, converter para structured format
        if (typeof rawDcData === 'number') {
            tech.dcOffset = {
                value: rawDcData,
                unit: 'dB',
                detailed: {
                    L: rawDcData,
                    R: rawDcData,
                    severity: Math.abs(rawDcData) > 0.1 ? 'High' : Math.abs(rawDcData) > 0.01 ? 'Medium' : 'Low'
                }
            };
        } else if (rawDcData && typeof rawDcData === 'object') {
            // Se for object com detailed
            tech.dcOffset = {
                value: rawDcData.value || (rawDcData.detailed ? Math.max(Math.abs(rawDcData.detailed.L || 0), Math.abs(rawDcData.detailed.R || 0)) : null),
                unit: rawDcData.unit || 'dB',
                detailed: rawDcData.detailed || {
                    L: rawDcData.L || rawDcData.left || rawDcData.value || 0,
                    R: rawDcData.R || rawDcData.right || rawDcData.value || 0,
                    severity: rawDcData.severity || 'Low'
                }
            };
        } else {
            tech.dcOffset = null;
        }
        console.log('üìä [NORMALIZE] DC Offset estruturado:', tech.dcOffset);
    } else {
        tech.dcOffset = null;
        console.log('‚ö†Ô∏è [NORMALIZE] DC Offset n√£o encontrado - dcOffset = null');
    }
    
    // üìä SPECTRAL UNIFORMITY - Estrutura detalhada
    if (source.spectralUniformity || source.spectral_uniformity) {
        const rawSpectralData = source.spectralUniformity || source.spectral_uniformity;
        
        // Se for n√∫mero simples, converter para structured format
        if (typeof rawSpectralData === 'number') {
            tech.spectralUniformity = {
                value: rawSpectralData,
                unit: 'ratio',
                detailed: {
                    variance: rawSpectralData,
                    distribution: rawSpectralData > 0.8 ? 'Uniform' : rawSpectralData > 0.5 ? 'Moderate' : 'Irregular',
                    analysis: rawSpectralData > 0.7 ? 'Well-balanced frequency distribution' : 'Uneven spectral content'
                }
            };
        } else if (rawSpectralData && typeof rawSpectralData === 'object') {
            // Se for object com detailed
            tech.spectralUniformity = {
                value: rawSpectralData.value || rawSpectralData.variance || null,
                unit: rawSpectralData.unit || 'ratio',
                detailed: rawSpectralData.detailed || {
                    variance: rawSpectralData.variance || rawSpectralData.value || null,
                    distribution: rawSpectralData.distribution || 'Unknown',
                    analysis: rawSpectralData.analysis || 'Spectral analysis pending'
                }
            };
        } else {
            tech.spectralUniformity = null;
        }
        console.log('üìä [NORMALIZE] Spectral Uniformity estruturado:', tech.spectralUniformity);
    } else {
        tech.spectralUniformity = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Spectral Uniformity n√£o encontrado - spectralUniformity = null');
    }
    
    // üî¢ SCORES E QUALIDADE - MAPEAMENTO CORRETO PARA NOVA ESTRUTURA
    normalized.qualityOverall = backendData.score && Number.isFinite(backendData.score) ? backendData.score : null;
    
    if (backendData.qualityBreakdown && typeof backendData.qualityBreakdown === 'object') {
        normalized.qualityBreakdown = backendData.qualityBreakdown;
        console.log('üìä [NORMALIZE] Quality breakdown real encontrado:', normalized.qualityBreakdown);
    } else {
        normalized.qualityBreakdown = null;
        console.log('‚ö†Ô∏è [NORMALIZE] Quality breakdown n√£o encontrado - qualityBreakdown = null');
    }
    
    // üìä DADOS AUXILIARES DO NOVO FORMATO
    if (backendData.metadata) {
        normalized.processingMs = backendData.metadata.processingTime || backendData.performance?.workerTotalTimeMs || null;
        normalized.fileName = backendData.metadata.fileName || null;
        normalized.fileSize = backendData.metadata.fileSize || null;
        normalized.buildVersion = backendData.metadata.buildVersion || null;
        normalized.pipelineVersion = backendData.metadata.pipelineVersion || null;
    }
    
    if (backendData.classification) {
        normalized.classification = backendData.classification;
    }
    
    // üéØ DADOS DE SCORING DETALHADOS
    if (backendData.scoring) {
        normalized.scoring = backendData.scoring;
        console.log('üìä [NORMALIZE] Dados de scoring encontrados:', backendData.scoring);
    }
    
    // üö® PROBLEMAS/SUGEST√ïES DO NOVO ANALYZER - Integrar com structure completa
    if (source.problemsAnalysis || source.problems_analysis) {
        const problemsData = source.problemsAnalysis || source.problems_analysis;
        
        // Adicionar problemas do analyzer
        if (problemsData.problems && Array.isArray(problemsData.problems)) {
            problemsData.problems.forEach(problem => {
                normalized.problems.push({
                    type: problem.type || 'analysis',
                    message: problem.message || problem.description || 'Problema detectado',
                    solution: problem.solution || problem.recommendation || 'Verificar configura√ß√µes',
                    severity: problem.severity || 'medium',
                    source: 'problems_analyzer'
                });
            });
        }
        
        // Adicionar sugest√µes do analyzer
        if (problemsData.suggestions && Array.isArray(problemsData.suggestions)) {
            problemsData.suggestions.forEach(suggestion => {
                normalized.suggestions.push({
                    type: suggestion.type || 'optimization',
                    message: suggestion.message || suggestion.description || 'Sugest√£o de melhoria',
                    action: suggestion.action || suggestion.recommendation || 'Aplicar otimiza√ß√£o',
                    details: suggestion.details || suggestion.context || 'Detalhes n√£o dispon√≠veis',
                    source: 'problems_analyzer'
                });
            });
        }
        
        console.log('üìä [NORMALIZE] Problems/Suggestions do analyzer integrados:', {
            problemsAdded: problemsData.problems?.length || 0,
            suggestionsAdded: problemsData.suggestions?.length || 0
        });
    }
    
    // üö® PROBLEMAS - Garantir que existam alguns problemas/sugest√µes para exibir
    if (normalized.problems.length === 0) {
        // Detectar problemas b√°sicos baseados nas m√©tricas - APENAS SE VALORES EXISTEM
        if (Number.isFinite(tech.clippingSamples) && tech.clippingSamples > 0) {
            normalized.problems.push({
                type: 'clipping',
                message: `Clipping detectado (${tech.clippingSamples} samples)`,
                solution: 'Reduzir o ganho geral ou usar limitador',
                severity: 'high'
            });
        }
        
        if (tech.dcOffset && tech.dcOffset.detailed) {
            const maxDcOffset = Math.max(Math.abs(tech.dcOffset.detailed.L || 0), Math.abs(tech.dcOffset.detailed.R || 0));
            if (maxDcOffset > 0.01) {
                normalized.problems.push({
                    type: 'dc_offset', 
                    message: `DC Offset detectado (L: ${tech.dcOffset.detailed.L?.toFixed(4) || 'N/A'}, R: ${tech.dcOffset.detailed.R?.toFixed(4) || 'N/A'})`,
                    solution: 'Aplicar filtro DC remove',
                    severity: tech.dcOffset.detailed.severity === 'High' ? 'high' : 'medium'
                });
            }
        } else if (Number.isFinite(tech.dcOffset) && Math.abs(tech.dcOffset) > 0.01) {
            normalized.problems.push({
                type: 'dc_offset', 
                message: `DC Offset detectado (${tech.dcOffset.toFixed(4)})`,
                solution: 'Aplicar filtro DC remove',
                severity: 'medium'
            });
        }
        
        if (Number.isFinite(tech.thdPercent) && tech.thdPercent > 1) {
            normalized.problems.push({
                type: 'thd',
                message: `THD elevado (${tech.thdPercent.toFixed(2)}%)`,
                solution: 'Verificar satura√ß√£o e distor√ß√£o',
                severity: 'medium'
            });
        }
    }
    
    // üí° SUGEST√ïES - Garantir algumas sugest√µes b√°sicas - APENAS SE VALORES EXISTEM
    console.log('[SUGGESTIONS-GEN] üîç Verificando gera√ß√£o de sugest√µes b√°sicas...');
    console.log('[SUGGESTIONS-GEN] normalized.suggestions.length =', normalized.suggestions.length);
    console.log('[SUGGESTIONS-GEN] M√©tricas dispon√≠veis:', {
        dynamicRange: tech.dynamicRange,
        stereoCorrelation: tech.stereoCorrelation,
        lufsIntegrated: tech.lufsIntegrated,
        truePeakDbtp: tech.truePeakDbtp
    });
    
    if (normalized.suggestions.length === 0) {
        console.log('[SUGGESTIONS-GEN] ‚ö†Ô∏è Nenhuma sugest√£o do backend - gerando sugest√µes b√°sicas...');
        
        if (Number.isFinite(tech.dynamicRange) && tech.dynamicRange < 8) {
            normalized.suggestions.push({
                type: 'dynamics',
                message: 'Faixa din√¢mica baixa detectada',
                action: 'Considerar reduzir compress√£o/limita√ß√£o',
                details: `DR atual: ${tech.dynamicRange.toFixed(1)}dB`
            });
            console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de DR adicionada');
        }
        
        if (Number.isFinite(tech.stereoCorrelation) && tech.stereoCorrelation > 0.9) {
            normalized.suggestions.push({
                type: 'stereo',
                message: 'Imagem est√©reo muito estreita',
                action: 'Aumentar espacializa√ß√£o est√©reo',
                details: `Correla√ß√£o: ${tech.stereoCorrelation.toFixed(3)}`
            });
            console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de correla√ß√£o est√©reo adicionada');
        }
        
        if (Number.isFinite(tech.lufsIntegrated) && tech.lufsIntegrated < -30) {
            normalized.suggestions.push({
                type: 'loudness',
                message: 'Loudness muito baixo',
                action: 'Aumentar volume geral',
                details: `LUFS atual: ${tech.lufsIntegrated.toFixed(1)}`
            });
            console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de loudness baixo adicionada');
        }
        
        // üÜï NOVAS SUGEST√ïES BASEADAS EM M√âTRICAS COMUNS
        if (Number.isFinite(tech.truePeakDbtp) && tech.truePeakDbtp > -1.0) {
            normalized.suggestions.push({
                type: 'true_peak',
                message: 'True Peak muito pr√≥ximo de 0 dBFS',
                action: 'Reduzir True Peak para -1.0 dBTP para evitar clipping em convers√µes',
                details: `True Peak atual: ${tech.truePeakDbtp.toFixed(2)} dBTP`
            });
            console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de True Peak adicionada');
        }
        
        if (Number.isFinite(tech.lra) && tech.lra < 3) {
            normalized.suggestions.push({
                type: 'lra',
                message: 'Loudness Range (LRA) muito baixo',
                action: 'Mix muito comprimido - considerar reduzir compress√£o para mais din√¢mica',
                details: `LRA atual: ${tech.lra.toFixed(1)} LU`
            });
            console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de LRA adicionada');
        }
        
        // Sugest√µes baseadas em bandas de frequ√™ncia (se dispon√≠veis)
        if (tech.spectral_balance || tech.bandEnergies) {
            const bands = tech.spectral_balance || tech.bandEnergies;
            if (bands.bass != null && bands.bass < -6) {
                normalized.suggestions.push({
                    type: 'frequency_bass',
                    message: 'Pouca energia em graves (bass)',
                    action: 'Considerar aumentar frequ√™ncias baixas (60-250 Hz)',
                    details: `Bass: ${bands.bass.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de bass baixo adicionada');
            }
            
            if (bands.presence != null && bands.presence < -8) {
                normalized.suggestions.push({
                    type: 'frequency_presence',
                    message: 'Pouca energia em presen√ßa (presence)',
                    action: 'Aumentar clareza vocal e defini√ß√£o (2-6 kHz)',
                    details: `Presence: ${bands.presence.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de presence baixo adicionada');
            }
        }
        
        // Sugest√µes baseadas nas novas m√©tricas
        if (tech.spectralUniformity && tech.spectralUniformity.detailed) {
            const uniformity = tech.spectralUniformity.value || tech.spectralUniformity.detailed.variance;
            if (Number.isFinite(uniformity) && uniformity < 0.5) {
                normalized.suggestions.push({
                    type: 'spectral_balance',
                    message: 'Distribui√ß√£o espectral irregular detectada',
                    action: 'Considerar equaliza√ß√£o para melhor balanceamento',
                    details: `Uniformidade: ${uniformity.toFixed(3)}, ${tech.spectralUniformity.detailed.distribution || 'An√°lise pendente'}`
                });
                console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de uniformidade espectral adicionada');
            }
        }
        
        if (tech.dominantFrequencies && tech.dominantFrequencies.detailed) {
            const primary = tech.dominantFrequencies.detailed.primary;
            if (Number.isFinite(primary)) {
                if (primary < 80) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'Frequ√™ncia dominante muito baixa',
                        action: 'Verificar filtro high-pass ou conte√∫do sub-bass excessivo',
                        details: `Freq. prim√°ria: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de frequ√™ncia baixa adicionada');
                } else if (primary > 8000) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'Frequ√™ncia dominante muito alta',
                        action: 'Verificar conte√∫do excessivo de agudos',
                        details: `Freq. prim√°ria: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] ‚úÖ Sugest√£o de frequ√™ncia alta adicionada');
                }
            }
        }
        
        // üö® FALLBACK CR√çTICO: Sempre ter pelo menos uma sugest√£o
        if (normalized.suggestions.length === 0) {
            console.warn('[SUGGESTIONS-GEN] ‚ö†Ô∏è Nenhuma sugest√£o gerada - criando fallback gen√©rico');
            normalized.suggestions.push({
                type: 'general',
                message: 'An√°lise completa realizada',
                action: 'Suas m√©tricas de √°udio foram analisadas com sucesso',
                details: 'Revise os cards de m√©tricas acima para mais detalhes'
            });
        }
        
        console.log('[SUGGESTIONS-GEN] ‚úÖ Total de sugest√µes geradas:', normalized.suggestions.length);
    } else {
        console.log('[SUGGESTIONS-GEN] ‚úÖ Backend enviou', normalized.suggestions.length, 'sugest√µes');
    }
    
    console.log('‚úÖ [NORMALIZE] Normaliza√ß√£o conclu√≠da:', {
        hasTechnicalData: !!normalized.technicalData,
        hasSpectralBalance: !!normalized.technicalData.spectral_balance,
        hasBandEnergies: !!normalized.technicalData.bandEnergies,
        // Novas m√©tricas detalhadas
        hasDominantFreqs: !!normalized.technicalData.dominantFrequencies,
        hasDcOffset: !!normalized.technicalData.dcOffset,
        hasSpectralUniformity: !!normalized.technicalData.spectralUniformity,
        dominantFreqsStructure: normalized.technicalData.dominantFrequencies ? 'structured' : 'missing',
        dcOffsetStructure: normalized.technicalData.dcOffset ? 'structured' : 'missing',
        spectralUniformityStructure: normalized.technicalData.spectralUniformity ? 'structured' : 'missing',
        problemsCount: normalized.problems.length,
        suggestionsCount: normalized.suggestions.length,
        qualityScore: normalized.qualityOverall
    });
    
    // üéØ LOG DE RESUMO: M√©tricas normalizadas com sucesso
    const normalizedMetrics = Object.keys(normalized.technicalData).filter(key => 
        Number.isFinite(normalized.technicalData[key])
    );
    
    console.log('üìä [NORMALIZE] Resumo da normaliza√ß√£o:', {
        metricas_normalizadas: normalizedMetrics.length,
        metricas_disponiveis: normalizedMetrics,
        spectral_balance_ok: !!normalized.technicalData.spectral_balance,
        bandas_disponiveis: normalized.technicalData.bandEnergies ? 
            Object.keys(normalized.technicalData.bandEnergies).length : 0,
        problemas_detectados: normalized.problems.length,
        sugestoes_iniciais: normalized.suggestions.length
    });
    
    // üéØ LOG FINAL PARA DEBUG UI
    console.log("‚úÖ [UI_FIX] Normalized metrics:", {
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        spectral_balance: normalized.technicalData.spectral_balance,
        bandEnergies: normalized.technicalData.bandEnergies ? Object.keys(normalized.technicalData.bandEnergies) : null
    });
    
// =============== FUN√á√ïES UTILIT√ÅRIAS DO MODAL ===============

// üìÅ Ocultar √°rea de upload do modal
function hideUploadArea() {
    __dbg('üìÅ Ocultando √°rea de upload...');
    const uploadArea = document.getElementById('audioUploadArea');
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('‚úÖ Upload area ocultada');
    } else {
        __dbg('‚ùå Elemento audioUploadArea n√£o encontrado!');
    }
}

// üîÑ Mostrar loading de an√°lise
function showAnalysisLoading() {
    __dbg('üîÑ Exibindo loading de an√°lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (results) {
        results.style.display = 'none';
        __dbg('‚úÖ Results area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'block';
        __dbg('‚úÖ Loading area exibida');
    } else {
        __dbg('‚ùå Elemento audioAnalysisLoading n√£o encontrado!');
    }
}

// ‚èπÔ∏è Ocultar loading de an√°lise
function hideAnalysisLoading() {
    __dbg('‚èπÔ∏è Ocultando loading de an√°lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) {
        loading.style.display = 'none';
        __dbg('‚úÖ Loading area ocultada');
    } else {
        __dbg('‚ùå Elemento audioAnalysisLoading n√£o encontrado!');
    }
}

// üìä Mostrar resultados da an√°lise
function showAnalysisResults() {
    __dbg('üìä Exibindo resultados da an√°lise...');
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('‚úÖ Upload area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'none';
        __dbg('‚úÖ Loading area ocultada');
    }
    
    if (results) {
        results.style.display = 'block';
        __dbg('‚úÖ Results area exibida');
    } else {
        __dbg('‚ùå Elemento audioAnalysisResults n√£o encontrado!');
    }
}

// üé® INJETAR ESTILOS CSS PARA STATUS DE TRUE PEAK
function injectTruePeakStatusStyles() {
    if (document.getElementById('truePeakStatusStyles')) return; // j√° injetado
    
    const style = document.createElement('style');
    style.id = 'truePeakStatusStyles';
    style.textContent = `
        /* Status do True Peak */
        .status-excellent {
            color: #00ff88 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(0, 255, 136, 0.3);
        }
        
        .status-ideal {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .status-good {
            color: #17a2b8 !important;
            font-weight: 600;
        }
        
        .status-warning {
            color: #ffc107 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(255, 193, 7, 0.3);
        }
        
        .status-critical {
            color: #dc3545 !important;
            font-weight: 700;
            text-shadow: 0 0 3px rgba(220, 53, 69, 0.4);
            animation: criticalPulse 2s infinite;
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Responsive para mobile */
        @media (max-width: 600px) {
            .status-excellent,
            .status-ideal,
            .status-good,
            .status-warning,
            .status-critical {
                font-size: 11px;
                font-weight: 600;
            }
        }
    `;
    
    document.head.appendChild(style);
    console.log('üé® Estilos CSS do True Peak injetados');
}

// Injetar estilos automaticamente quando o DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', injectTruePeakStatusStyles);
} else {
    injectTruePeakStatusStyles();
}

// üéØ SISTEMA DE TOOLTIPS PARA M√âTRICAS
let currentTooltip = null;

window.showMetricTooltip = function(iconElement, event) {
    // Remover tooltip anterior se existir
    hideMetricTooltip();
    
    const tooltipText = iconElement.getAttribute('data-tooltip');
    if (!tooltipText) return;
    
    // Criar tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'metric-tooltip active';
    tooltip.textContent = tooltipText;
    document.body.appendChild(tooltip);
    
    currentTooltip = tooltip;
    
    // Posicionar tooltip
    const rect = iconElement.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    
    // Posicionar abaixo do √≠cone, centralizado
    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
    let top = rect.bottom + 10;
    
    // Ajustar se sair da tela
    const padding = 10;
    if (left < padding) left = padding;
    if (left + tooltipRect.width > window.innerWidth - padding) {
        left = window.innerWidth - tooltipRect.width - padding;
    }
    if (top + tooltipRect.height > window.innerHeight - padding) {
        // Mostrar acima do √≠cone se n√£o couber embaixo
        top = rect.top - tooltipRect.height - 10;
    }
    
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    
    // Ativar anima√ß√£o
    setTimeout(() => tooltip.classList.add('active'), 10);
};

window.hideMetricTooltip = function() {
    if (currentTooltip) {
        currentTooltip.classList.remove('active');
        setTimeout(() => {
            if (currentTooltip && currentTooltip.parentNode) {
                currentTooltip.parentNode.removeChild(currentTooltip);
            }
            currentTooltip = null;
        }, 300);
    }
};

// Fechar tooltip ao rolar a p√°gina
window.addEventListener('scroll', hideMetricTooltip);
window.addEventListener('resize', hideMetricTooltip);

// üß© CORRE√á√ÉO #7: Logs de debug autom√°ticos para valida√ß√£o
console.log("%c[SYSTEM CHECK] üîç Debug ativo para valida√ß√£o de fluxos genre/reference", "color:#7f00ff;font-weight:bold;");

// ========================================
// üö® SISTEMA DE MONITORAMENTO CONT√çNUO DE JOBID
// ========================================
/**
 * Monitora se os jobIds permanecem diferentes em modo reference
 * Detecta e corrige contamina√ß√£o automaticamente
 */
(function startJobIdMonitor() {
    let monitorInterval = null;
    
    function checkJobIdIntegrity() {
        const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
        
        if (mode === 'reference') {
            const current = window.__CURRENT_JOB_ID__;
            const reference = window.__REFERENCE_JOB_ID__;
            
            // Valida√ß√£o cr√≠tica
            if (current && reference && current === reference) {
                console.error('üö® [MONITOR] CONTAMINA√á√ÉO DETECTADA!');
                console.error('   currentJobId:', current);
                console.error('   referenceJobId:', reference);
                console.error('   Ambos s√£o IGUAIS - isso N√ÉO deveria acontecer!');
                console.trace();
                
                // Tenta recuperar do sessionStorage
                const recoveredJobId = sessionStorage.getItem('currentJobId');
                if (recoveredJobId && recoveredJobId !== reference) {
                    window.__CURRENT_JOB_ID__ = recoveredJobId;
                    console.log('‚úÖ [MONITOR] JobId recuperado do sessionStorage:', recoveredJobId);
                    console.log('‚úÖ [MONITOR] Contamina√ß√£o corrigida automaticamente');
                } else {
                    console.error('‚ùå [MONITOR] N√£o foi poss√≠vel recuperar currentJobId do sessionStorage');
                    console.error('‚ùå [MONITOR] Sistema pode estar em estado inconsistente');
                }
            }
        }
    }
    
    // Inicia monitoramento quando entrar em modo reference
    window.addEventListener('analysisMode', (e) => {
        if (e.detail?.mode === 'reference' && !monitorInterval) {
            console.log('üîç [MONITOR] Iniciando monitoramento de jobIds (intervalo: 1s)');
            monitorInterval = setInterval(checkJobIdIntegrity, 1000);
        } else if (e.detail?.mode !== 'reference' && monitorInterval) {
            console.log('üîç [MONITOR] Parando monitoramento de jobIds');
            clearInterval(monitorInterval);
            monitorInterval = null;
        }
    });
    
    // Inicia imediatamente se j√° estiver em modo reference
    if (window.currentAnalysisMode === 'reference') {
        console.log('üîç [MONITOR] Modo reference detectado - iniciando monitoramento');
        monitorInterval = setInterval(checkJobIdIntegrity, 1000);
    }
    
    console.log('‚úÖ [MONITOR] Sistema de monitoramento de jobIds ativado');
})();

window.addEventListener("beforeunload", () => {
    console.log("üßπ [CLEANUP] Encerrando sess√£o de an√°lise e limpando estado.");
});

// üéØ PATCH DEFINITIVO: Carregar corre√ß√£o da tabela de refer√™ncia
(function loadReferenceTablePatch() {
    console.log('üì¶ [INTEGRATION] Carregando patch definitivo da tabela de refer√™ncia...');
    
    // Tentar carregar o patch definitivo
    const script = document.createElement('script');
    script.src = 'patch-tabela-referencia-final.js';
    script.onload = function() {
        console.log('‚úÖ [INTEGRATION] Patch definitivo carregado com sucesso');
    };
    script.onerror = function() {
        console.warn('‚ö†Ô∏è [INTEGRATION] N√£o foi poss√≠vel carregar patch-tabela-referencia-final.js');
        console.log('üí° [INTEGRATION] A corre√ß√£o j√° foi aplicada diretamente no c√≥digo');
    };
    
    document.head.appendChild(script);
})();
