// Sistema Centralizado de Logs - Importado automaticamente
import { log, warn, error, info, debug } from './logger.js';

ï»¿// ğŸµ AUDIO ANALYZER INTEGRATION - VERSÃƒO REFATORADA
// Sistema de anÃ¡lise 100% baseado em processamento no back-end (Railway + Bucket)
// âš ï¸ REMOÃ‡ÃƒO COMPLETA: Web Audio API, AudioContext, processamento local
// âœ… NOVO FLUXO: Presigned URL â†’ Upload â†’ Job Creation â†’ Status Polling

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš¨ CONSTANTE FÃSICA ABSOLUTA - True Peak NUNCA pode ser > 0 dBTP
// Esta constante Ã© usada em TODO o sistema para garantir paridade tabela/cards
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TRUE_PEAK_HARD_CAP = 0.0; // dBTP - Limite absoluto para True Peak

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• MAPEAMENTO DE MÃ‰TRICAS PARA CATEGORIAS - TOPO DO ARQUIVO
// Usado para agrupar problemas no plano de correÃ§Ã£o
// DEVE estar no topo para evitar ReferenceError antes da inicializaÃ§Ã£o
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const METRIC_CATEGORY_MAP = {
    // LOUDNESS
    'LUFS': 'loudness',
    'Loudness': 'loudness',
    'Integrated': 'loudness',
    'True Peak': 'loudness',
    'TP': 'loudness',
    // FREQUÃŠNCIAS (BANDAS ESPECTRAIS)
    'Sub': 'frequency',
    'Subgrave': 'frequency',
    'Bass': 'frequency',
    'Grave': 'frequency',
    'Low Mid': 'frequency',
    'Low-Mid': 'frequency',
    'MÃ©dio-Grave': 'frequency',
    'Mid': 'frequency',
    'MÃ©dios': 'frequency',
    'High Mid': 'frequency',
    'High-Mid': 'frequency',
    'MÃ©dio-Alto': 'frequency',
    'Brilho': 'frequency',
    'Brightness': 'frequency',
    'PresenÃ§a': 'frequency',
    'Presence': 'frequency',
    'Air': 'frequency',
    // DINÃ‚MICA
    'DR': 'dynamics',
    'Dynamic Range': 'dynamics',
    'LRA': 'dynamics',
    'Loudness Range': 'dynamics',
    'Crest': 'dynamics',
    'Crest Factor': 'dynamics',
    // ESTÃ‰REO
    'Stereo': 'stereo',
    'Imagem EstÃ©reo': 'stereo',
    'Correlation': 'stereo',
    'Width': 'stereo',
    'Balance': 'stereo'
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›¡ï¸ NORMALIZADOR DE SEVERIDADE - ANTI-CRASH
// Garante que severity seja SEMPRE string, nunca causa erro de .toUpperCase()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function normalizeSeverity(severity) {
    if (!severity) return 'DESCONHECIDO';
    
    if (typeof severity === 'string') {
        return severity.toUpperCase().trim();
    }
    
    if (typeof severity === 'number') {
        const numMap = { 1: 'FINO', 2: 'ATENÃ‡ÃƒO', 3: 'CRÃTICA' };
        return numMap[severity] || 'DESCONHECIDO';
    }
    
    if (typeof severity === 'object') {
        if (severity.label) return String(severity.label).toUpperCase().trim();
        if (severity.level) {
            const levelMap = { 1: 'FINO', 2: 'ATENÃ‡ÃƒO', 3: 'CRÃTICA' };
            return levelMap[severity.level] || 'DESCONHECIDO';
        }
        if (severity.name) return String(severity.name).toUpperCase().trim();
    }
    
    return 'DESCONHECIDO';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›¡ï¸ VERIFICADOR DE PROBLEMA - Retorna true se severidade indica problema real
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isProblematicSeverity(severity) {
    const normalized = normalizeSeverity(severity);
    return normalized.includes('CRÃT') || 
           normalized.includes('ATEN') || 
           normalized.includes('WARN') ||
           normalized.includes('ALTA') ||
           normalized.includes('MODERADA');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ• HISTÃ“RICO DE ANÃLISES - Salvamento automÃ¡tico para usuÃ¡rios PRO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * ğŸ• Salva anÃ¡lise no histÃ³rico (APENAS para usuÃ¡rios PRO)
 * Processo assÃ­ncrono que NÃƒO bloqueia a exibiÃ§Ã£o do modal
 * 
 * @param {Object} analysisResult - JSON completo da anÃ¡lise
 * @returns {Promise<void>}
 */
async function saveAnalysisToHistory(analysisResult) {
    log('ğŸ• [HISTORY-SAVE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    log('ğŸ• [HISTORY-SAVE] Iniciando verificaÃ§Ã£o para salvar...');
    
    try {
        // 1. Verificar se usuÃ¡rio estÃ¡ autenticado
        const userId = window.auth?.currentUser?.uid;
        log('ğŸ• [HISTORY-SAVE] userId:', userId ? userId.slice(0, 8) + '...' : 'NÃƒO AUTENTICADO');
        
        if (!userId) {
            log('ğŸ• [HISTORY-SAVE] âŒ UsuÃ¡rio nÃ£o autenticado - pulando');
            return;
        }
        
        // 2. Detectar plano do usuÃ¡rio de MÃšLTIPLAS FONTES
        let userPlan = 'free';
        const planSources = {
            planCapabilities: window.PlanCapabilities?.detectUserPlan?.(),
            windowUserPlan: window.userPlan,
            analysisResultPlan: analysisResult?.plan,
            currentModalPlan: window.currentModalAnalysis?.plan,
            cachedPlan: window.__soundyUserPlan
        };
        
        log('ğŸ• [HISTORY-SAVE] ğŸ” Fontes de plano:', planSources);
        
        // Prioridade: PlanCapabilities > window.userPlan > analysisResult.plan > currentModal > cache
        userPlan = planSources.planCapabilities || 
                   planSources.windowUserPlan || 
                   planSources.analysisResultPlan ||
                   planSources.currentModalPlan ||
                   planSources.cachedPlan ||
                   'free';
        
        log('ğŸ• [HISTORY-SAVE] Plano detectado:', userPlan);
        
        // 3. Verificar se Ã© PRO/DJ/STUDIO
        // âœ… ATUALIZADO 2026-01-06: STUDIO adicionado
        const isPro = userPlan === 'pro' || userPlan === 'dj' || userPlan === 'studio';
        if (!isPro) {
            log(`ğŸ• [HISTORY-SAVE] â­ï¸ Plano "${userPlan}" nÃ£o tem histÃ³rico - pulando`);
            return;
        }
        
        // 4. Verificar se anÃ¡lise tem dados vÃ¡lidos (MAIS TOLERANTE)
        const hasValidData = (
            analysisResult && 
            (
                analysisResult.technicalData ||
                analysisResult.loudness ||
                analysisResult.lufs ||
                analysisResult.score !== undefined ||
                analysisResult.data?.technicalData
            )
        );
        
        log('ğŸ• [HISTORY-SAVE] ValidaÃ§Ã£o de dados:', {
            hasAnalysisResult: !!analysisResult,
            hasTechnicalData: !!analysisResult?.technicalData,
            hasLoudness: !!analysisResult?.loudness,
            hasLufs: !!analysisResult?.lufs,
            hasScore: analysisResult?.score !== undefined,
            hasDataTechnical: !!analysisResult?.data?.technicalData,
            RESULTADO: hasValidData ? 'âœ… VÃLIDO' : 'âŒ INVÃLIDO'
        });
        
        if (!hasValidData) {
            warn('ğŸ• [HISTORY-SAVE] âŒ AnÃ¡lise sem dados vÃ¡lidos - pulando');
            return;
        }
        
        // 5. Extrair nome do arquivo e tipo de anÃ¡lise
        const analysisMode = analysisResult.mode || analysisResult.analysisMode || 'genre';
        
        let trackName = 'AnÃ¡lise sem nome';
        let genreOrReferenceName = 'N/A';
        
        if (analysisMode === 'reference') {
            // AnÃ¡lise de referÃªncia
            trackName = analysisResult.metadata?.fileName || 
                       analysisResult.fileName || 
                       'MÃºsica Original';
            genreOrReferenceName = analysisResult.metadata?.referenceName || 
                                  analysisResult.referenceName || 
                                  'ReferÃªncia';
        } else {
            // AnÃ¡lise de gÃªnero
            trackName = analysisResult.metadata?.fileName || 
                       analysisResult.fileName || 
                       analysisResult.trackName ||
                       'AnÃ¡lise sem nome';
            genreOrReferenceName = analysisResult.data?.genre || 
                                  analysisResult.genre || 
                                  window.__CURRENT_SELECTED_GENRE || 
                                  'Unknown';
        }
        
        log('ğŸ• [HISTORY-SAVE] ğŸ’¾ Preparando para salvar:', {
            userId: userId.slice(0, 8) + '...',
            plan: userPlan,
            trackName: trackName,
            analysisType: analysisMode,
            genreOrReferenceName: genreOrReferenceName
        });
        
        // 6. Enviar para API
        const response = await fetch('/api/history', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-user-id': userId,
                'x-user-plan': userPlan
            },
            body: JSON.stringify({
                analysisResult: analysisResult
            })
        });
        
        log('ğŸ• [HISTORY-SAVE] Response status:', response.status);
        
        const data = await response.json();
        
        if (data.success) {
            log('ğŸ• [HISTORY-SAVE] âœ… AnÃ¡lise salva no histÃ³rico:', data.historyId);
        } else {
            warn('ğŸ• [HISTORY-SAVE] âš ï¸ Falha ao salvar:', data.error || data.message);
        }
        
    } catch (error) {
        // Erro nÃ£o-crÃ­tico - apenas loga, nÃ£o interrompe fluxo
        error('ğŸ• [HISTORY-SAVE] âŒ ERRO:', error.message);
        error('ğŸ• [HISTORY-SAVE] Stack:', error.stack);
    }
    
    log('ğŸ• [HISTORY-SAVE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ” VERIFICADOR CENTRALIZADO DE ENTITLEMENT - MODO REFERÃŠNCIA
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
/**
 * ğŸ” Verifica se o usuÃ¡rio pode usar o modo de referÃªncia
 * REGRA: Apenas plano PRO tem acesso ao modo referÃªncia
 * 
 * @returns {Promise<{allowed: boolean, plan: string}>}
 */
async function checkReferenceEntitlement() {
    try {
        // 1. Tentar detectar plano via PlanCapabilities (cache local)
        let currentPlan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
        
        // 2. Se plano Ã© 'free' mas usuÃ¡rio estÃ¡ autenticado, forÃ§ar refresh do Firestore
        if (currentPlan === 'free' && window.auth?.currentUser) {
            log('ğŸ” [ENTITLEMENT] Plano cache Ã© free, verificando Firestore...');
            try {
                const freshPlan = await window.PlanCapabilities?.fetchUserPlan?.();
                if (freshPlan) {
                    currentPlan = freshPlan;
                    log(`ğŸ” [ENTITLEMENT] Plano atualizado: ${currentPlan}`);
                }
            } catch (err) {
                warn('ğŸ” [ENTITLEMENT] Erro ao buscar plano:', err);
            }
        }
        
        // 3. REGRA: PRO, DJ ou STUDIO = permitido, qualquer outro = bloqueado
        // âœ… ATUALIZADO 2026-01-06: STUDIO agora tem acesso ao Modo ReferÃªncia
        const allowed = currentPlan === 'pro' || currentPlan === 'dj' || currentPlan === 'studio';
        
        log(`ğŸ” [ENTITLEMENT] checkReferenceEntitlement: plan=${currentPlan}, allowed=${allowed}`);
        
        return { allowed, plan: currentPlan };
    } catch (err) {
        error('ğŸ” [ENTITLEMENT] Erro crÃ­tico:', err);
        return { allowed: false, plan: 'free' };
    }
}

/**
 * ğŸ” VersÃ£o sÃ­ncrona para fail-safes (usa cache, menos precisa)
 * @returns {{shouldBlock: boolean, plan: string}}
 */
function checkReferenceEntitlementSync() {
    const plan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
    // âœ… ATUALIZADO 2026-01-06: STUDIO agora tem acesso ao Modo ReferÃªncia
    const shouldBlock = plan !== 'pro' && plan !== 'dj' && plan !== 'studio';
    
    log(`ğŸ” [ENTITLEMENT-SYNC] plan=${plan}, shouldBlock=${shouldBlock}`);
    
    return { shouldBlock, plan };
}

// Exportar globalmente
window.checkReferenceEntitlement = checkReferenceEntitlement;
window.checkReferenceEntitlementSync = checkReferenceEntitlementSync;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¯ MAPEAMENTO CENTRALIZADO: IDs LEGADOS â†’ IDs OFICIAIS
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
/**
 * ğŸ¯ MAPEAMENTO CENTRALIZADO: IDs LEGADOS â†’ IDs OFICIAIS
 * 
 * Esta funÃ§Ã£o Ã© o ÃšNICO ponto de conversÃ£o de gÃªneros legados.
 * Todo o sistema usa os novos IDs apÃ³s esta normalizaÃ§Ã£o.
 * 
 * MAPEAMENTO:
 * - trance â†’ progressive_trance
 * - phonk â†’ rap_drill
 * - funk_automotivo â†’ edm
 * - techno â†’ fullon
 * 
 * @param {string} genreId - ID do gÃªnero (pode ser legado ou novo)
 * @returns {string} - ID oficial normalizado
 */
function normalizeGenreId(genreId) {
  if (!genreId || typeof genreId !== 'string') {
    return genreId;
  }
  
  // Mapeamento de IDs legados para IDs oficiais
  const LEGACY_TO_OFFICIAL = {
    'trance': 'progressive_trance',
    'phonk': 'rap_drill',
    'funk_automotivo': 'edm',
    'techno': 'fullon'
  };
  
  const normalized = genreId.toLowerCase().trim();
  
  // Se Ã© um ID legado, converter para oficial
  if (LEGACY_TO_OFFICIAL[normalized]) {
    log(`[GENRE-NORMALIZE] ğŸ”„ Convertendo legado: "${normalized}" â†’ "${LEGACY_TO_OFFICIAL[normalized]}"`);
    return LEGACY_TO_OFFICIAL[normalized];
  }
  
  // JÃ¡ Ã© um ID oficial ou outro gÃªnero vÃ¡lido
  return normalized;
}

// Exportar globalmente para uso em outros mÃ³dulos
window.normalizeGenreId = normalizeGenreId;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ›¡ï¸ SAFE STATE MACHINE ACCESSOR
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
function getSafeStateMachine() {
  if (window.AnalysisStateMachine) {
    return window.AnalysisStateMachine;
  }
  
  // âœ… Retornar stub funcional completo ao invÃ©s de null
  warn('[SAFE-SM] StateMachine nÃ£o disponÃ­vel - usando stub funcional');
  return {
    getState: () => ({
      mode: window.currentAnalysisMode || 'genre',
      userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
      referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null,
      awaitingSecondTrack: !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has()),
      timestamp: new Date().toISOString()
    }),
    getMode: () => window.currentAnalysisMode || 'genre',
    setMode: (mode, opts = {}) => {
      log('[SAFE-SM-STUB] setMode:', mode, opts);
      window.currentAnalysisMode = mode;
      if (opts.userExplicitlySelected && typeof persistReferenceFlag === 'function') {
        persistReferenceFlag(mode === 'reference');
      }
    },
    isAwaitingSecondTrack: () => !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has()),
    isUserExplicitlySelected: () => window.userExplicitlySelectedReferenceMode || false,
    assertInvariants: () => true
  };
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¯ MODE ENGINE: Fonte Ãºnica de verdade para modo de anÃ¡lise
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
/**
 * ğŸ¯ Helper: Extrai compareMode de forma deterministica
 * @param {Object} input - Objeto de anÃ¡lise ou contexto
 * @returns {string} 'A_B' ou 'B_A' (fallback: 'A_B')
 */
function getCompareMode(input) {
    const mode = input?.compareMode || input?.analysis?.compareMode;
    if (mode === 'B_A' || mode === 'b_a') return 'B_A';
    return 'A_B'; // default seguro
}

/**
 * ğŸ¯ Helper: Extrai mÃ©tricas de anÃ¡lise de forma robusta
 * Tenta mÃºltiplas localizaÃ§Ãµes no payload para garantir compatibilidade
 * @param {Object} analysisOrResult - Objeto de anÃ¡lise ou resultado
 * @returns {Object} Objeto de mÃ©tricas (mesmo que vazio)
 */
function extractMetrics(analysisOrResult) {
    if (!analysisOrResult) return {};
    
    // Tentar mÃºltiplas localizaÃ§Ãµes (ordem de prioridade)
    const metrics = 
        analysisOrResult.data?.metrics ||
        analysisOrResult.metrics ||
        analysisOrResult.results?.metrics ||
        analysisOrResult.normalizedResult?.metrics ||
        analysisOrResult.referenceAnalysis?.data?.metrics ||
        {};
    
    return metrics;
}

/**
 * ğŸ¯ Helper: Extrai bands de anÃ¡lise de forma robusta
 * @param {Object} analysisOrResult - Objeto de anÃ¡lise ou resultado
 * @returns {Object} Objeto de bands (mesmo que vazio)
 */
function extractBands(analysisOrResult) {
    if (!analysisOrResult) return {};
    
    const bands = 
        analysisOrResult.bands ||
        analysisOrResult.technicalData?.spectral_balance ||
        analysisOrResult.data?.bands ||
        analysisOrResult.spectralBands ||
        {};
    
    return bands;
}

/**
 * ğŸ¯ Helper: Extrai mÃ©tricas A/B de forma tolerante (nÃ£o requer bands)
 * Valida existÃªncia de mÃ©tricas mÃ­nimas necessÃ¡rias para comparaÃ§Ã£o A/B
 * @param {Object} analysisOrResult - Objeto de anÃ¡lise ou resultado
 * @returns {Object} { ok: boolean, metrics: {...}, technicalData: {...}, debugShape: {...} }
 */
function extractABMetrics(analysisOrResult) {
    if (!analysisOrResult) {
        return { ok: false, metrics: {}, technicalData: {}, debugShape: { error: 'payload null' } };
    }
    
    // Tentar extrair technicalData de mÃºltiplas localizaÃ§Ãµes
    const technicalData = 
        analysisOrResult.technicalData ||
        analysisOrResult.data?.technicalData ||
        analysisOrResult.results?.technicalData ||
        {};
    
    // Extrair mÃ©tricas via helper existente
    const metrics = extractMetrics(analysisOrResult);
    
    // Validar se tem mÃ©tricas mÃ­nimas necessÃ¡rias para A/B
    const hasMinimalMetrics = (
        technicalData.lufsIntegrated != null ||
        technicalData.truePeakDbtp != null ||
        technicalData.dynamicRange != null ||
        metrics.lufsIntegrated != null ||
        metrics.truePeakDbtp != null ||
        metrics.dynamicRange != null
    );
    
    return {
        ok: hasMinimalMetrics,
        metrics: metrics,
        technicalData: technicalData,
        debugShape: {
            hasTechnicalData: !!technicalData,
            hasMetrics: !!metrics && Object.keys(metrics).length > 0,
            hasLufs: technicalData.lufsIntegrated != null || metrics.lufsIntegrated != null,
            hasTruePeak: technicalData.truePeakDbtp != null || metrics.truePeakDbtp != null,
            hasDR: technicalData.dynamicRange != null || metrics.dynamicRange != null,
            topLevelKeys: Object.keys(analysisOrResult)
        }
    };
}

/**
 * ğŸ¯ Helper: Recupera referenceJobId de forma robusta
 * Prioridade: window > sessionStorage > localStorage
 * @returns {string|null} jobId da referÃªncia ou null
 */
function getReferenceJobId() {
    // Prioridade 1: MemÃ³ria (mais rÃ¡pido e confiÃ¡vel)
    if (window.__REFERENCE_JOB_ID__) {
        return window.__REFERENCE_JOB_ID__;
    }
    
    // Prioridade 2: sessionStorage (dura sessÃ£o do navegador)
    try {
        const fromSession = sessionStorage.getItem('referenceJobId');
        if (fromSession) {
            log('[REF-FIX] Recuperado de sessionStorage:', fromSession);
            window.__REFERENCE_JOB_ID__ = fromSession; // Sincronizar
            return fromSession;
        }
    } catch (e) {
        warn('[REF-FIX] Erro ao ler sessionStorage:', e);
    }
    
    // Prioridade 3: localStorage (persiste entre sessÃµes)
    try {
        const fromLocal = localStorage.getItem('referenceJobId');
        if (fromLocal) {
            log('[REF-FIX] Recuperado de localStorage:', fromLocal);
            window.__REFERENCE_JOB_ID__ = fromLocal; // Sincronizar
            return fromLocal;
        }
    } catch (e) {
        warn('[REF-FIX] Erro ao ler localStorage:', e);
    }
    
    warn('[REF-FIX] Nenhum referenceJobId encontrado');
    return null;
}

/**
 * ğŸ¯ Helper: Salva referenceJobId em todos os locais
 * @param {string} jobId - ID do job da referÃªncia
 */
function saveReferenceJobId(jobId) {
    if (!jobId) {
        warn('[REF-FIX] Tentativa de salvar jobId vazio');
        return;
    }
    
    // Salvar em memÃ³ria
    window.__REFERENCE_JOB_ID__ = jobId;
    log('[REF-FIX] âœ… Salvo em window.__REFERENCE_JOB_ID__:', jobId);
    
    // Salvar em sessionStorage
    try {
        sessionStorage.setItem('referenceJobId', jobId);
        log('[REF-FIX] âœ… Salvo em sessionStorage');
    } catch (e) {
        error('[REF-FIX] âŒ Erro ao salvar em sessionStorage:', e);
    }
    
    // Salvar em localStorage
    try {
        localStorage.setItem('referenceJobId', jobId);
        log('[REF-FIX] âœ… Salvo em localStorage');
    } catch (e) {
        error('[REF-FIX] âŒ Erro ao salvar em localStorage:', e);
    }
}

/**
 * ï¿½ RENDERIZAR BLOCO DE IDENTIFICAÃ‡ÃƒO DA MÃšSICA
 * Exibe nome do arquivo, duraÃ§Ã£o, sample rate, bit depth, canais, gÃªnero e timestamp
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @returns {string} HTML do bloco de identificaÃ§Ã£o
 */
function renderMusicIdentificationBlock(analysis) {
    // ValidaÃ§Ã£o de entrada
    if (!analysis || typeof analysis !== 'object') {
        warn('[MUSIC-ID] âš ï¸ analysis invÃ¡lido ou ausente');
        return '';
    }
    
    // Extrair metadados
    const metadata = analysis.metadata || {};
    const fileName = metadata.fileName || analysis.fileName || 'Arquivo de Ã¡udio';
    
    // DuraÃ§Ã£o (converter segundos para mm:ss)
    const durationSeconds = metadata.duration || 0;
    const minutes = Math.floor(durationSeconds / 60);
    const seconds = Math.floor(durationSeconds % 60);
    const durationFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Sample Rate (converter Hz para kHz)
    const sampleRate = metadata.sampleRate || 48000;
    const sampleRateKHz = (sampleRate / 1000).toFixed(0);
    
    // Bit Depth
    const bitDepth = metadata.bitDepth || 32;
    
    // Canais (1=Mono, 2=EstÃ©reo, >2=Multicanal)
    const channels = metadata.channels || 2;
    const channelLabel = channels === 1 ? 'Mono' : channels === 2 ? 'EstÃ©reo' : `${channels} canais`;
    
    // GÃªnero (se modo gÃªnero)
    const mode = analysis.mode || 'genre';
    const genre = analysis.genre || analysis.genreName || null;
    
    // Timestamp da anÃ¡lise
    const timestamp = analysis.timestamp || Date.now();
    const now = new Date();
    const analysisDate = new Date(timestamp);
    const isToday = now.toDateString() === analysisDate.toDateString();
    const timestampLabel = isToday 
        ? `Analisado agora` 
        : `Analisado em ${analysisDate.toLocaleDateString('pt-BR')}`;
    
    // Logs de debug
    log('[MUSIC-ID] ğŸµ Renderizando bloco de identificaÃ§Ã£o:', {
        fileName,
        duration: durationFormatted,
        sampleRate: `${sampleRateKHz} kHz`,
        bitDepth: `${bitDepth}-bit`,
        channels: channelLabel,
        genre,
        mode,
        timestamp: timestampLabel
    });
    
    // Construir HTML
    const html = `
        <div class="music-identification-block">
            <div class="music-id-content">
                <!-- TÃ­tulo: Nome do arquivo com container -->
                <div class="music-id-title-container">
                    <h3 class="music-id-title">${escapeHtml(fileName)}</h3>
                </div>
                
                <!-- Linha separadora -->
                <div class="music-id-divider"></div>
                
                <!-- EspecificaÃ§Ãµes tÃ©cnicas -->
                <div class="music-id-specs">
                    ${durationSeconds > 0 ? `
                        <div class="music-id-spec-item">
                            <span class="music-id-spec-icon">â±ï¸</span>
                            <span class="music-id-spec-value">${durationFormatted}</span>
                        </div>
                    ` : ''}
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">ğŸ“Š</span>
                        <span class="music-id-spec-value">${sampleRateKHz} kHz</span>
                    </div>
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">ğŸšï¸</span>
                        <span class="music-id-spec-value">${bitDepth}-bit</span>
                    </div>
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">ğŸ”Š</span>
                        <span class="music-id-spec-value">${channelLabel}</span>
                    </div>
                </div>
                
                <!-- Contexto: GÃªnero + Timestamp -->
                <div class="music-id-context">
                    ${mode === 'genre' && genre ? `
                        <span class="music-id-genre-badge">
                            <span>ğŸµ</span>
                            <span>${formatGenreName(genre)}</span>
                        </span>
                    ` : ''}
                    
                    <span class="music-id-timestamp">${timestampLabel}</span>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

/**
 * ğŸ›¡ï¸ Helper: Escapa HTML para prevenir XSS
 * @param {string} text - Texto a ser escapado
 * @returns {string} Texto escapado
 */
function escapeHtml(text) {
    if (!text || typeof text !== 'string') return '';
    
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    
    return text.replace(/[&<>"']/g, m => map[m]);
}

/**
 * ğŸ¨ Helper: Formata nome de gÃªnero para exibiÃ§Ã£o
 * @param {string} genre - Nome do gÃªnero (snake_case)
 * @returns {string} Nome formatado (Title Case)
 */
function formatGenreName(genre) {
    if (!genre || typeof genre !== 'string') return '';
    
    // Mapa de nomes customizados
    const customNames = {
        'progressive_trance': 'Progressive Trance',
        'funk_mandela': 'Funk Mandela',
        'funk_bruxaria': 'Funk Bruxaria',
        'funk_bh': 'Funk BH',
        'edm': 'EDM',
        'eletronico': 'EletrÃ´nico'
    };
    
    // Se tiver nome customizado, usar
    if (customNames[genre]) {
        return customNames[genre];
    }
    
    // Caso contrÃ¡rio, converter snake_case para Title Case
    return genre
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
}

/**
 * ï¿½ğŸ¯ [AUDIT-FIX] Helper: Garante que container de referÃªncia A/B existe NO LOCAL CORRETO
 * PosiÃ§Ã£o: ABAIXO dos cards, ACIMA das sugestÃµes
 * @returns {HTMLElement|null} Container ou null se falhar
 */
function ensureReferenceContainer() {
    let container = document.getElementById('referenceComparisons');
    
    // Se jÃ¡ existe, verificar se estÃ¡ no lugar certo
    if (container) {
        const modalResults = document.getElementById('audioAnalysisResults');
        if (modalResults && !modalResults.contains(container)) {
            warn('[CONTAINER] âš ï¸ #referenceComparisons existe mas estÃ¡ FORA do modal ativo - removendo');
            container.remove();
            container = null;
        } else {
            log('[CONTAINER] âœ… #referenceComparisons jÃ¡ existe e estÃ¡ no modal correto');
            return container;
        }
    }
    
    // ğŸ¯ [AUDIT-FIX] Localizar ponto de inserÃ§Ã£o correto
    // Ordem desejada: Cards â†’ Tabela ComparaÃ§Ã£o â†’ SugestÃµes
    const modalResults = document.getElementById('audioAnalysisResults');
    const modalTechnical = document.getElementById('modalTechnicalData');
    
    // Buscar elemento de sugestÃµes (deve aparecer DEPOIS da tabela)
    const suggestionsContainer = modalResults?.querySelector('.ai-suggestions-container, #aiSuggestionsContainer, [class*="suggestion"]');
    
    let insertionPoint = null;
    let parentContainer = null;
    
    if (modalResults) {
        parentContainer = modalResults;
        
        // Se encontrou container de sugestÃµes, inserir ANTES dele
        if (suggestionsContainer) {
            insertionPoint = suggestionsContainer;
            log('[CONTAINER] ğŸ“ InserÃ§Ã£o: ANTES do container de sugestÃµes');
        } 
        // Se nÃ£o, inserir apÃ³s modalTechnicalData (onde ficam os cards)
        else if (modalTechnical && modalResults.contains(modalTechnical)) {
            insertionPoint = modalTechnical.nextSibling;
            log('[CONTAINER] ğŸ“ InserÃ§Ã£o: APÃ“S modalTechnicalData (cards)');
        }
        // Ãšltimo recurso: inserir no final de modalResults
        else {
            insertionPoint = null; // appendChild
            log('[CONTAINER] ğŸ“ InserÃ§Ã£o: FINAL de audioAnalysisResults');
        }
    } else {
        error('[CONTAINER] âŒ audioAnalysisResults nÃ£o encontrado - nÃ£o Ã© possÃ­vel criar container');
        return null;
    }
    
    // Criar container
    container = document.createElement('div');
    container.id = 'referenceComparisons';
    container.className = 'reference-comparisons-container';
    container.style.marginTop = '20px';
    container.style.marginBottom = '20px';
    
    // Inserir no local correto
    if (insertionPoint) {
        parentContainer.insertBefore(container, insertionPoint);
    } else {
        parentContainer.appendChild(container);
    }
    
    log('[CONTAINER] âœ… #referenceComparisons criado dinamicamente no local correto');
    log('[CONTAINER] ğŸ“Š PosiÃ§Ã£o relativa:', {
        'estÃ¡ em modalResults': modalResults.contains(container),
        'antes de sugestÃµes': suggestionsContainer ? container.nextSibling === suggestionsContainer : 'N/A',
        'depois de cards': modalTechnical ? modalTechnical.compareDocumentPosition(container) & Node.DOCUMENT_POSITION_FOLLOWING : 'N/A'
    });
    
    return container;
}

/**
 * ğŸ¯ HELPER PRINCIPAL: Normaliza anÃ¡lise para shape consistente
 * Garante que TODOS os dados tenham bands e metrics no top-level
 * @param {Object} raw - AnÃ¡lise bruta do backend ou store
 * @returns {Object} AnÃ¡lise normalizada com shape consistente
 */
function normalizeAnalysis(raw) {
    if (!raw) return null;
    
    log('[NORMALIZE] ğŸ”„ Normalizando anÃ¡lise:', { jobId: raw.jobId, hasData: !!raw.data, hasTechnicalData: !!raw.technicalData });
    
    // Base: clonar para nÃ£o mutar original
    const normalized = { ...raw };
    
    // 1. Extrair technicalData de todas as fontes possÃ­veis
    const technicalData = 
        raw.technicalData ||
        raw.data?.technicalData ||
        raw.results?.technicalData ||
        {};
    
    // 2. Extrair bands de todas as fontes
    const bands = 
        raw.bands ||
        raw.spectralBands ||
        technicalData.spectral_balance ||
        raw.data?.bands ||
        raw.results?.bands ||
        {};
    
    // 3. Extrair metrics usando helper existente
    const metrics = extractMetrics(raw);
    
    // 4. Garantir estrutura unificada no TOP-LEVEL
    normalized.bands = bands;
    normalized.metrics = metrics;
    normalized.technicalData = technicalData;
    
    // 5. Se technicalData tem spectral_balance mas bands nÃ£o foi copiado, garantir
    if (!normalized.bands || Object.keys(normalized.bands).length === 0) {
        if (technicalData.spectral_balance) {
            normalized.bands = technicalData.spectral_balance;
            log('[NORMALIZE] âœ… Copiado spectral_balance â†’ bands');
        }
    }
    
    // 6. Se metrics vazio mas technicalData tem valores, copiar
    if (!normalized.metrics || Object.keys(normalized.metrics).length === 0) {
        normalized.metrics = {
            lufsIntegrated: technicalData.lufsIntegrated,
            truePeakDbtp: technicalData.truePeakDbtp,
            dynamicRange: technicalData.dynamicRange,
            lra: technicalData.lra,
            rmsLeft: technicalData.rmsLeft,
            rmsRight: technicalData.rmsRight,
            crestFactor: technicalData.crestFactor,
            stereoCorrelation: technicalData.stereoCorrelation
        };
        log('[NORMALIZE] âœ… Copiado technicalData â†’ metrics');
    }
    
    log('[NORMALIZE] âœ… NormalizaÃ§Ã£o completa:', {
        hasBands: !!normalized.bands && Object.keys(normalized.bands).length > 0,
        hasMetrics: !!normalized.metrics && Object.keys(normalized.metrics).length > 0,
        bandsKeys: Object.keys(normalized.bands || {}),
        metricsKeys: Object.keys(normalized.metrics || {})
    });
    
    return normalized;
}

/**
 * ğŸ¯ HELPER: Retorna state machine seguro (nunca undefined)
 * @returns {Object} State machine real ou stub funcional
 */
function getSafeStateMachine() {
    if (window.AnalysisStateMachine) {
        return window.AnalysisStateMachine;
    }
    
    warn('[STATE-MACHINE] âš ï¸ AnalysisStateMachine nÃ£o carregado - usando stub');
    
    // Stub funcional que preserva estado
    return {
        getMode: () => window.currentAnalysisMode || 'genre',
        setMode: (mode, opts) => {
            log('[STATE-MACHINE-STUB] setMode:', mode, opts);
            window.currentAnalysisMode = mode;
            if (opts?.userExplicitlySelected) {
                window.userExplicitlySelectedReferenceMode = (mode === 'reference');
            }
        },
        getState: () => ({
            mode: window.currentAnalysisMode || 'genre',
            userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
            referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null,
            awaitingSecondTrack: !!window.__REFERENCE_JOB_ID__
        }),
        isReferenceCompare: () => window.currentAnalysisMode === 'reference'
    };
}

/**
 * ğŸ¯ Helper: Extrai identidade de track para validaÃ§Ã£o de duplicaÃ§Ã£o
 * @param {Object} track - Objeto de anÃ¡lise
 * @returns {Object} { jobId, fileKey, fileName }
 */
function getTrackIdentity(track) {
    const jobId = track?.jobId || null;
    const fileKey = track?.fileKey || track?.storageKey || track?.s3Key || null;
    const rawFileName = track?.fileName || track?.metadata?.fileName || null;
    const fileName = (typeof rawFileName === 'string' && rawFileName.trim().length > 0) 
                     ? rawFileName 
                     : null;
    return { jobId, fileKey, fileName };
}

/**
 * ğŸ¯ FONTE-DE-VERDADE: Detecta se hÃ¡ contexto de referÃªncia ativo
 * Verifica mÃºltiplas fontes para garantir detecÃ§Ã£o robusta
 */
function hasActiveReferenceContext() {
    const hasRefJobId = !!(window.__REFERENCE_JOB_ID__ || window.__soundyState?.referenceJobId);
    const hasFirstStore = !!(window.FirstAnalysisStore?.has?.());
    const hasRefData = !!(window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__);
    
    return hasRefJobId && (hasFirstStore || hasRefData);
}

/**
 * ğŸ§¹ ISOLAMENTO DO MODO REFERENCE: Limpa contaminaÃ§Ã£o de estado de gÃªnero
 * Garante que o modo reference nÃ£o seja influenciado por selectedGenre/genreTargets
 */
function resetGenreContextForReference() {
    log('[REFERENCE-ISOLATION] ğŸ§¹ Resetando contexto de gÃªnero para modo reference');
    
    // ğŸ¯ PATCH CRÃTICO D: Zerar TODAS variÃ¡veis de gÃªnero
    if (window.__soundyState) {
        window.__soundyState.selectedGenre = null;
        window.__soundyState.hasGenreTargets = false;
        window.__soundyState.currentAnalysisMode = 'reference';
        window.__soundyState.genreTargets = null;
    }
    
    // Zerar variÃ¡veis globais de gÃªnero
    window.__CURRENT_SELECTED_GENRE = null;
    window.PROD_AI_REF_GENRE = null;
    
    // Garantir que currentAnalysisMode estÃ¡ correto
    window.currentAnalysisMode = 'reference';
    
    // NÃ£o tocar em variÃ¡veis de UI (usuÃ¡rio pode ter selecionado gÃªnero no menu)
    // Apenas garantir que nÃ£o influenciam a anÃ¡lise de referÃªncia
    
    log('[REFERENCE-ISOLATION] âœ… Contexto isolado:', {
        selectedGenre: window.__soundyState?.selectedGenre,
        hasGenreTargets: window.__soundyState?.hasGenreTargets,
        currentAnalysisMode: window.currentAnalysisMode,
        CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE
    });
}

window.SOUNDY_MODE_ENGINE = {
    mode: "genre",          // "genre" | "reference_base" | "reference_compare"
    referenceBase: null,    // anÃ¡lise completa da primeira mÃºsica
    referenceJobId: null,   // jobId da primeira mÃºsica

    setGenre() {
        this.mode = "genre";
        this.referenceBase = null;
        this.referenceJobId = null;
        setViewMode("genre");
    },

    startReferenceBase(firstAnalysis) {
        this.mode = "reference_base";
        this.referenceBase = firstAnalysis;
        this.referenceJobId = firstAnalysis.jobId;
        setViewMode("genre"); // ainda se comporta visualmente como gÃªnero
    },

    startReferenceCompare() {
        this.mode = "reference_compare";
        setViewMode("reference");
    },

    isGenre() {
        return this.mode === "genre";
    },

    isReferenceBase() {
        return this.mode === "reference_base";
    },

    isReferenceCompare() {
        return this.mode === "reference_compare";
    },

    clear() {
        this.setGenre();
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ GENRE TARGETS UTILS - FONTE ÃšNICA DE VERDADE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * ğŸ¯ EXTRAI GENRE TARGETS DE UMA ANÃLISE (ALIAS COMPATÃVEL)
 * 
 * Esta Ã© uma funÃ§Ã£o alias que chama extractGenreTargets() principal.
 * Mantida para compatibilidade com cÃ³digo legado.
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise normalizado
 * @returns {Object|null} Targets do gÃªnero ou null
 */
function extractGenreTargetsFromAnalysis(analysis) {
    log('[GENRE-TARGETS-ALIAS] Redirecionando para extractGenreTargets()');
    return extractGenreTargets(analysis);
}

/**
 * Extrai gÃªnero de uma anÃ¡lise
 * ÃšNICA FONTE OFICIAL: analysis.data.genre
 * @param {Object} analysis - Objeto de anÃ¡lise normalizado
 * @returns {string|null} Nome do gÃªnero ou null
 */
function extractGenreFromAnalysis(analysis) {
    log('[GENRE-TARGETS-UTILS] ğŸµ Extraindo gÃªnero da anÃ¡lise');
    
    // ğŸ¯ PRIORIDADE 1: analysis.data.genre (BACKEND OFICIAL)
    if (analysis?.data?.genre) {
        log('[GENRE-TARGETS-UTILS] âœ… GÃªnero encontrado em analysis.data.genre:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // ğŸ¯ PRIORIDADE 2: analysis.genre (fallback direto)
    if (analysis?.genre) {
        log('[GENRE-TARGETS-UTILS] âš ï¸ GÃªnero encontrado em analysis.genre (fallback):', analysis.genre);
        return analysis.genre;
    }
    
    // ğŸ¯ PRIORIDADE 3: analysis.metadata.genre
    if (analysis?.metadata?.genre) {
        log('[GENRE-TARGETS-UTILS] âš ï¸ GÃªnero encontrado em analysis.metadata.genre (fallback):', analysis.metadata.genre);
        return analysis.metadata.genre;
    }
    
    warn('[GENRE-TARGETS-UTILS] âŒ Nenhum gÃªnero encontrado na anÃ¡lise');
    return null;
}

log('âœ… Genre Targets Utils carregado');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ GENRE-ONLY EXTRACTION UTILS - NUNCA AFETAM REFERENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ¯ FUNÃ‡ÃƒO UTILITÃRIA GLOBAL - OBTER TARGETS CORRETOS
 * 
 * CAMPO REAL DO POSTGRES: analysis.data.genreTargets
 * 
 * âŒ NÃƒO USAR:
 *    - analysis.targets
 *    - analysis.results.data.genreTargets
 *    - analysis.results.genreTargets
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise do backend
 * @returns {Object|null} Targets ou null
 */
function getCorrectTargets(analysis) {
    log('[TARGETS] ğŸ” Buscando targets corretos...');
    
    let targets = null;
    
    // ğŸš¨ PRIORIDADE MÃXIMA: analysis.data.targets (FLAT FORMAT COM OVERRIDE APLICADO!)
    // Este campo vem do pipeline com override de streaming jÃ¡ aplicado (-14 LUFS)
    if (analysis?.data?.targets && typeof analysis.data.targets === 'object') {
        error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  ğŸ¯ USANDO analysis.data.targets (FLAT + OVERRIDE)       â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('[TARGETS] lufs_target:', analysis.data.targets.lufs_target);
        error('[TARGETS] true_peak_target:', analysis.data.targets.true_peak_target);
        error('[TARGETS] soundDestination:', analysis.soundDestination);
        error('\n');
        return JSON.parse(JSON.stringify(analysis.data.targets)); // Deep copy
    }
    
    // ğŸ¯ PRIORIDADE 2: analysis.data.genreTargets
    if (analysis?.data?.genreTargets && typeof analysis.data.genreTargets === 'object') {
        log('[TARGETS] âœ… Usando analysis.data.genreTargets (CAMPO REAL DO POSTGRES)');
        targets = JSON.parse(JSON.stringify(analysis.data.genreTargets)); // Deep copy
    }
    
    // ğŸ¯ PRIORIDADE 3: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
    if (!targets) {
        const genre = analysis?.genre || analysis?.data?.genre;
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            log('[TARGETS] ğŸ“¦ Usando PROD_AI_REF_DATA[genre] como fallback');
            targets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
        }
    }
    
    if (!targets) {
        warn('[TARGETS] âš ï¸ Nenhum target encontrado');
        return null;
    }
    
    // ğŸ“¡ STREAMING MODE: Aplicar override de LUFS e TP (APENAS se nÃ£o veio de analysis.data.targets)
    // ğŸš¨ CORREÃ‡ÃƒO: Usar analysis.soundDestination (do backend) prioritariamente
    const soundDest = analysis?.soundDestination || getSoundDestinationMode();
    
    if (soundDest === 'streaming') {
        error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  ğŸ“¡ FRONTEND: APLICANDO OVERRIDE STREAMING               â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('[TARGETS] soundDestination:', soundDest);
        error('[TARGETS] ANTES: lufs_target =', targets.lufs_target);
        
        targets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
        targets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
        
        error('[TARGETS] DEPOIS: lufs_target =', targets.lufs_target);
        error('\n');
    }
    
    log('[TARGETS] Keys:', Object.keys(targets));
    return targets;
}

/**
 * ğŸ¯ EXTRAI TARGETS DO GÃŠNERO - FUNÃ‡ÃƒO DEFINITIVA E ROBUSTA
 * 
 * Esta funÃ§Ã£o NUNCA retorna undefined ou null.
 * Sempre retorna targets vÃ¡lidos usando fallbacks se necessÃ¡rio.
 * 
 * ESTRUTURA ACEITA:
 * - results.data.genreTargets (backend/worker/postgres)
 * - analysis.data.genreTargets (frontend)
 * 
 * FALLBACKS AUTOMÃTICOS:
 * - window.__activeRefData
 * - window.PROD_AI_REF_DATA[genre]
 * 
 * @param {Object} source - Objeto results (backend) ou analysis (frontend)
 * @returns {Object} Targets do gÃªnero (nunca null)
 */
function extractGenreTargets(source) {
    log('[EXTRACT-TARGETS] ğŸ” Iniciando extraÃ§Ã£o de targets');
    log('[EXTRACT-TARGETS] Tipo de objeto:', source?.constructor?.name || typeof source);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 1: IDENTIFICAR SE Ã‰ MODO GENRE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const mode = source?.mode || source?.data?.mode || 'unknown';
    log('[EXTRACT-TARGETS] Modo detectado:', mode);
    
    if (mode !== "genre") {
        log('[EXTRACT-TARGETS] âš ï¸ NÃ£o Ã© modo genre, retornando null');
        return null;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 2: EXTRAIR GÃŠNERO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const genre = source?.data?.genre || 
                  source?.genre || 
                  source?.metadata?.genre || 
                  'unknown';
    
    log('[EXTRACT-TARGETS] GÃªnero identificado:', genre);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 3: BUSCAR TARGETS NA ORDEM DE PRIORIDADE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log('[EXTRACT-TARGETS] ğŸ“¦ Testando fontes de targets:');
    log('[EXTRACT-TARGETS]   source.data.genreTargets:', !!source?.data?.genreTargets);
    log('[EXTRACT-TARGETS]   source.genreTargets:', !!source?.genreTargets);
    log('[EXTRACT-TARGETS]   source.targets:', !!source?.targets);
    log('[EXTRACT-TARGETS]   source.data.targets:', !!source?.data?.targets);
    
    let targets = null;
    let targetSource = null;
    
    // ğŸ¯ PRIORIDADE 1: source.data.genreTargets (BACKEND/FRONTEND OFICIAL)
    if (source?.data?.genreTargets && typeof source.data.genreTargets === 'object') {
        targets = source.data.genreTargets;
        targetSource = 'source.data.genreTargets (OFICIAL)';
        
        // ğŸ†• LOG STREAMING MODE: Verificar se targets foram overriden
        log('[EXTRACT-TARGETS] ğŸ“¡ STREAMING CHECK:', {
            soundDestination: source?.soundDestination,
            lufs_target: targets.lufs_target,
            true_peak_target: targets.true_peak_target,
            isStreamingOverride: targets.lufs_target === -14 && targets.true_peak_target === -1.0
        });
    }
    // ğŸ¯ PRIORIDADE 2: source.genreTargets (fallback direto)
    else if (source?.genreTargets && typeof source.genreTargets === 'object') {
        targets = source.genreTargets;
        targetSource = 'source.genreTargets';
    }
    // ğŸ¯ PRIORIDADE 3: source.targets (nomenclatura alternativa)
    else if (source?.targets && typeof source.targets === 'object') {
        targets = source.targets;
        targetSource = 'source.targets';
    }
    // ğŸ¯ PRIORIDADE 4: source.data.targets
    else if (source?.data?.targets && typeof source.data.targets === 'object') {
        targets = source.data.targets;
        targetSource = 'source.data.targets';
    }
    // ğŸ¯ PRIORIDADE 5: source.result.genreTargets
    else if (source?.result?.genreTargets && typeof source.result.genreTargets === 'object') {
        targets = source.result.genreTargets;
        targetSource = 'source.result.genreTargets';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 4: VALIDAR E RETORNAR SE ENCONTRADO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (targets && isValidTargetsStructure(targets)) {
        log('[EXTRACT-TARGETS] âœ… Targets encontrados em:', targetSource);
        log('[EXTRACT-TARGETS] ğŸ“Š Estrutura:', {
            hasLufs: !!targets.lufs,
            hasTruePeak: !!targets.truePeak,
            hasDr: !!targets.dr,
            hasBands: !!targets.bands,
            keys: Object.keys(targets)
        });
        return targets;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 5: FALLBACK 1 - window.__activeRefData
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    warn('[EXTRACT-TARGETS] âš ï¸ Targets nÃ£o encontrados no objeto principal');
    log('[EXTRACT-TARGETS] ğŸ”„ Tentando fallback: window.__activeRefData');
    
    if (typeof window !== 'undefined' && window.__activeRefData) {
        const activeData = window.__activeRefData;
        
        // Validar se gÃªnero bate
        const activeGenre = activeData.genre || activeData.data?.genre;
        if (activeGenre === genre || !activeGenre) {
            log('[EXTRACT-TARGETS] âœ… Usando window.__activeRefData');
            const fallbackTargets = activeData.targets || activeData.data?.genreTargets || activeData;
            
            if (isValidTargetsStructure(fallbackTargets)) {
                return fallbackTargets;
            }
        } else {
            warn('[EXTRACT-TARGETS] âš ï¸ window.__activeRefData ignorado - gÃªnero diferente:', activeGenre, 'â‰ ', genre);
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 6: FALLBACK 2 - window.PROD_AI_REF_DATA[genre]
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log('[EXTRACT-TARGETS] ğŸ”„ Tentando fallback: window.PROD_AI_REF_DATA[' + genre + ']');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        window.PROD_AI_REF_DATA[genre]) {
        
        log('[EXTRACT-TARGETS] âœ… Usando window.PROD_AI_REF_DATA[' + genre + ']');
        const fallbackTargets = window.PROD_AI_REF_DATA[genre];
        
        if (isValidTargetsStructure(fallbackTargets)) {
            return fallbackTargets;
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 7: FALLBACK 3 - window.PROD_AI_REF_DATA (objeto Ãºnico)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log('[EXTRACT-TARGETS] ğŸ”„ Tentando fallback: window.PROD_AI_REF_DATA (objeto Ãºnico)');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA === 'object') {
        
        // Verificar se Ã© um objeto Ãºnico (nÃ£o um dicionÃ¡rio de gÃªneros)
        if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
            log('[EXTRACT-TARGETS] âœ… Usando window.PROD_AI_REF_DATA (objeto Ãºnico)');
            return window.PROD_AI_REF_DATA;
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 8: ERRO CRÃTICO - NENHUM TARGET ENCONTRADO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    error('â•‘  âŒ ERRO CRÃTICO: NENHUM TARGET ENCONTRADO               â•‘');
    error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    error('[EXTRACT-TARGETS] Modo:', mode);
    error('[EXTRACT-TARGETS] GÃªnero:', genre);
    error('[EXTRACT-TARGETS] source.data:', source?.data);
    error('[EXTRACT-TARGETS] source.genreTargets:', source?.genreTargets);
    error('[EXTRACT-TARGETS] window.__activeRefData:', typeof window !== 'undefined' ? !!window.__activeRefData : 'N/A');
    error('[EXTRACT-TARGETS] window.PROD_AI_REF_DATA:', typeof window !== 'undefined' ? !!window.PROD_AI_REF_DATA : 'N/A');
    
    // Retornar estrutura vazia vÃ¡lida ao invÃ©s de null
    warn('[EXTRACT-TARGETS] âš ï¸ Retornando estrutura vazia vÃ¡lida');
    return {
        lufs: { target: -14, tolerance: 1 },
        truePeak: { target: -1, tolerance: 0.5 },
        dr: { target: 8, tolerance: 2 },
        stereo: { target: 100, tolerance: 10 },
        bands: {}
    };
}

/**
 * Valida se a estrutura de targets Ã© vÃ¡lida
 * @param {Object} targets - Objeto de targets
 * @returns {boolean} True se vÃ¡lido
 */
function isValidTargetsStructure(targets) {
    if (!targets || typeof targets !== 'object') {
        return false;
    }
    
    // Verificar se tem pelo menos uma das propriedades essenciais
    // ğŸ”§ CORREÃ‡ÃƒO: Aceitar tanto camelCase (lufs) quanto snake_case (lufs_target)
    const hasEssentials = targets.lufs || 
                         targets.truePeak || 
                         targets.dr || 
                         targets.bands ||
                         targets.legacy_compatibility ||
                         targets.lufs_target !== undefined ||  // ğŸ†• snake_case do backend
                         targets.true_peak_target !== undefined ||  // ğŸ†• snake_case do backend
                         targets.dr_target !== undefined;  // ğŸ†• snake_case do backend
    
    return hasEssentials;
}

/**
 * Extrai nome do gÃªnero SOMENTE no modo genre
 * âš ï¸ IMPORTANTE: Retorna genre normal se nÃ£o for modo genre
 * @param {Object} analysis - Objeto de anÃ¡lise
 * @returns {string} Nome do gÃªnero
 */
function extractGenreName(analysis) {
    // ğŸ›¡ï¸ BARREIRA: Se nÃ£o for modo genre, retorna genre normal
    if (analysis?.mode !== "genre") {
        return analysis?.genre || null;
    }
    
    log('[GENRE-ONLY-UTILS] ğŸµ Extraindo nome do gÃªnero no modo GENRE');
    
    // ğŸ¯ FONTE OFICIAL: analysis.data.genre
    if (analysis?.data?.genre) {
        log('[GENRE-ONLY-UTILS] âœ… GÃªnero encontrado:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // Fallback para analysis.genre
    if (analysis?.genre) {
        log('[GENRE-ONLY-UTILS] âš ï¸ Usando fallback analysis.genre:', analysis.genre);
        return analysis.genre;
    }
    
    warn('[GENRE-ONLY-UTILS] âŒ GÃªnero nÃ£o encontrado, usando "default"');
    return "default";
}

/**
 * Carrega targets padrÃ£o para um gÃªnero
 * @param {string} genreName - Nome do gÃªnero
 * @returns {Object} Targets padrÃ£o
 */
function loadDefaultGenreTargets(genreName = "default") {
    log('[GENRE-ONLY-UTILS] ğŸ“¦ Carregando targets padrÃ£o para:', genreName);
    
    // Tentar carregar de window.GENRE_TARGETS_DB
    if (window.GENRE_TARGETS_DB && window.GENRE_TARGETS_DB[genreName]) {
        log('[GENRE-ONLY-UTILS] âœ… Targets carregados de GENRE_TARGETS_DB');
        return window.GENRE_TARGETS_DB[genreName];
    }
    
    // Fallback: targets genÃ©ricos
    warn('[GENRE-ONLY-UTILS] âš ï¸ Usando targets genÃ©ricos');
    return {
        lufs_target: -14,
        true_peak_target: -1,
        dr_target: 8,
        lra_target: 6,
        stereo_target: 0.85,
        bands: {}
    };
}

log('âœ… Genre-Only Extraction Utils carregado');

// ğŸ” AUDITORIA DE STORAGE - Sistema de detecÃ§Ã£o de inconsistÃªncias
(function initStorageAudit() {
    console.group('%c[AUDITORIA-STORAGE] ğŸ§  Inicializando sistema de auditoria de storage', 'color:#A974FF;font-weight:bold;font-size:14px;');
    
    // 1ï¸âƒ£ Verificar localStorage atual
    const localRefJobId = localStorage.getItem('referenceJobId');
    const localRefAnalysis = localStorage.getItem('referenceAnalysis');
    
    log('%c[AUDITORIA-STORAGE] ğŸ“¦ localStorage:', 'color:#FFD700;font-weight:bold;');
    log('   referenceJobId:', localRefJobId || 'âŒ vazio');
    log('   referenceAnalysis:', localRefAnalysis ? `âœ… ${localRefAnalysis.length} bytes` : 'âŒ vazio');
    
    // 2ï¸âƒ£ Verificar sessionStorage atual
    const sessionRefJobId = sessionStorage.getItem('referenceJobId');
    const sessionRefAnalysis = sessionStorage.getItem('referenceAnalysis');
    const sessionCurrentJobId = sessionStorage.getItem('currentJobId');
    
    log('%c[AUDITORIA-STORAGE] ğŸ“¦ sessionStorage:', 'color:#FFD700;font-weight:bold;');
    log('   referenceJobId:', sessionRefJobId || 'âŒ vazio');
    log('   referenceAnalysis:', sessionRefAnalysis ? `âœ… ${sessionRefAnalysis.length} bytes` : 'âŒ vazio');
    log('   currentJobId:', sessionCurrentJobId || 'âŒ vazio');
    
    // 3ï¸âƒ£ Verificar variÃ¡veis globais
    log('%c[AUDITORIA-STORAGE] ğŸŒ VariÃ¡veis globais:', 'color:#FFD700;font-weight:bold;');
    log('   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'âŒ undefined');
    log('   window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__ || 'âŒ undefined');
    
    // 4ï¸âƒ£ Detectar inconsistÃªncias
    log('%c[AUDITORIA-STORAGE] ğŸ” AnÃ¡lise de consistÃªncia:', 'color:#A974FF;font-weight:bold;');
    
    if (localRefJobId && !sessionRefJobId) {
        log('%c   âš ï¸ PROBLEMA: referenceJobId apenas em localStorage', 'color:#FF5555;font-weight:bold;');
        log('   âš ï¸ Risco: Compartilhamento entre abas (localStorage Ã© global)');
        log('   âœ… SoluÃ§Ã£o: Migrar para sessionStorage (isolamento por aba)');
    }
    
    if (localRefJobId && sessionRefJobId && localRefJobId !== sessionRefJobId) {
        log('%c   âŒ INCONSISTÃŠNCIA CRÃTICA: JobIds diferentes!', 'color:#FF5555;font-weight:bold;');
        log('   localStorage.referenceJobId:', localRefJobId);
        log('   sessionStorage.referenceJobId:', sessionRefJobId);
    }
    
    if (!localRefJobId && !sessionRefJobId && !window.__REFERENCE_JOB_ID__) {
        log('%c   âœ… Estado limpo - sem referÃªncia ativa', 'color:#00FF88;');
    }
    
    if (localRefJobId || sessionRefJobId || window.__REFERENCE_JOB_ID__) {
        log('%c   ğŸ“Š ReferÃªncia ativa detectada:', 'color:#00C9FF;');
        log('   Prioridade: sessionStorage > window > localStorage');
    }
    
    console.groupEnd();
    
    // 5ï¸âƒ£ Criar utilitÃ¡rio global de storage com fallback
    window.StorageManager = {
        // Salvar referenceJobId
        setReferenceJobId(jobId) {
            log('%c[STORAGE-MANAGER] ğŸ’¾ Salvando referenceJobId:', 'color:#00FF88;font-weight:bold;', jobId);
            try {
                sessionStorage.setItem('referenceJobId', jobId);
                log('   âœ… Salvo em sessionStorage (isolado por aba)');
            } catch (e) {
                warn('   âš ï¸ Falha no sessionStorage, usando localStorage como fallback:', e.message);
                localStorage.setItem('referenceJobId', jobId);
            }
        },
        
        // Ler referenceJobId (prioridade: sessionStorage > window > localStorage)
        getReferenceJobId() {
            const sessionId = sessionStorage.getItem('referenceJobId');
            const windowId = window.__REFERENCE_JOB_ID__;
            const localId = localStorage.getItem('referenceJobId');
            
            const result = sessionId || windowId || localId;
            
            log('%c[STORAGE-MANAGER] ğŸ“– Lendo referenceJobId:', 'color:#FFD700;', result || 'âŒ nÃ£o encontrado');
            log('   sessionStorage:', sessionId || 'âŒ');
            log('   window.__REFERENCE_JOB_ID__:', windowId || 'âŒ');
            log('   localStorage:', localId || 'âŒ');
            
            return result;
        },
        
        // Salvar referenceAnalysis
        setReferenceAnalysis(analysis) {
            const json = JSON.stringify(analysis);
            log('%c[STORAGE-MANAGER] ğŸ’¾ Salvando referenceAnalysis:', 'color:#00FF88;font-weight:bold;', `${json.length} bytes`);
            try {
                sessionStorage.setItem('referenceAnalysis', json);
                log('   âœ… Salvo em sessionStorage');
            } catch (e) {
                warn('   âš ï¸ Falha no sessionStorage (quota?), usando localStorage:', e.message);
                try {
                    localStorage.setItem('referenceAnalysis', json);
                } catch (e2) {
                    error('   âŒ Falha em ambos storages:', e2.message);
                }
            }
        },
        
        // Ler referenceAnalysis
        getReferenceAnalysis() {
            const sessionData = sessionStorage.getItem('referenceAnalysis');
            const localData = localStorage.getItem('referenceAnalysis');
            
            const result = sessionData || localData;
            
            if (result) {
                try {
                    const parsed = JSON.parse(result);
                    log('%c[STORAGE-MANAGER] ğŸ“– referenceAnalysis recuperado:', 'color:#FFD700;', 
                        `${result.length} bytes`, 
                        sessionData ? '(sessionStorage)' : '(localStorage fallback)');
                    return parsed;
                } catch (e) {
                    error('%c[STORAGE-MANAGER] âŒ Erro ao parsear referenceAnalysis:', 'color:#FF5555;', e.message);
                    return null;
                }
            }
            
            log('%c[STORAGE-MANAGER] ğŸ“– referenceAnalysis:', 'color:#FFD700;', 'âŒ nÃ£o encontrado');
            return null;
        },
        
        // Limpar referÃªncia
        clearReference() {
            // ğŸš¨ BLINDAGEM ABSOLUTA: NUNCA limpar em modo genre
            if (window.__CURRENT_MODE__ === 'genre') {
                warn('[GENRE-PROTECT] âš ï¸ StorageManager.clearReference() BLOQUEADO em modo genre');
                warn('[GENRE-PROTECT]   - Preservando:', {
                    selectedGenre: window.__CURRENT_SELECTED_GENRE,
                    mode: window.__CURRENT_MODE__
                });
                return; // NÃƒO executar limpeza
            }

            log('%c[STORAGE-MANAGER] ğŸ—‘ï¸ Limpando referÃªncia...', 'color:#FF9500;font-weight:bold;');
            try {
                sessionStorage.removeItem('referenceJobId');
                sessionStorage.removeItem('referenceAnalysis');
                log('   âœ… sessionStorage limpo');
            } catch (e) {
                warn('   âš ï¸ Erro ao limpar sessionStorage:', e.message);
            }
            
            try {
                localStorage.removeItem('referenceJobId');
                localStorage.removeItem('referenceAnalysis');
                log('   âœ… localStorage limpo');
            } catch (e) {
                warn('   âš ï¸ Erro ao limpar localStorage:', e.message);
            }
            
            delete window.__REFERENCE_JOB_ID__;
            log('   âœ… window.__REFERENCE_JOB_ID__ removido');
        }
    };
    
    log('%c[AUDITORIA-STORAGE] âœ… Sistema de storage auditado e StorageManager criado', 'color:#00FF88;font-weight:bold;');
})();

// ========================================
// ğŸ†” VIRTUAL IDS E ÃNDICE DE PAPÃ‰IS (ANTI-SELF-COMPARE)
// ========================================
// SoluÃ§Ã£o definitiva: Virtual ID composto por jobId + role (USER ou REF)
// Mesmo que backend reutilize jobId, o VID mantÃ©m separaÃ§Ã£o por papel
window.CacheIndex ??= { USER: null, REF: null };

// ========================================
// ğŸ§  SISTEMA DE ARMAZENAMENTO ISOLADO FINAL
// ========================================
/**
 * Sistema simplificado e definitivo para armazenamento de anÃ¡lises.
 * Duas variÃ¡veis isoladas: primeira e segunda mÃºsica.
 * NUNCA mais usar window.__FIRST_ANALYSIS_FROZEN__ ou stateV3.reference.
 */
window.SoundyAI_Store = {
    first: null,   // primeira mÃºsica
    second: null,  // segunda mÃºsica
};

/**
 * Salva primeira anÃ¡lise (referÃªncia)
 * @param {object} data - Dados da anÃ¡lise
 */
function saveFirstAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.first = JSON.parse(JSON.stringify(data));
    
    log('âœ… [STORE] Primeira anÃ¡lise salva isolada');
    log('   - FileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
    log('   - JobId:', window.SoundyAI_Store.first?.jobId);
    log('   - LUFS:', window.SoundyAI_Store.first?.technicalData?.lufsIntegrated);
}

/**
 * Salva segunda anÃ¡lise (comparaÃ§Ã£o)
 * @param {object} data - Dados da anÃ¡lise
 */
function saveSecondAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.second = JSON.parse(JSON.stringify(data));
    
    log('âœ… [STORE] Segunda anÃ¡lise salva isolada');
    log('   - FileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
    log('   - JobId:', window.SoundyAI_Store.second?.jobId);
    log('   - LUFS:', window.SoundyAI_Store.second?.technicalData?.lufsIntegrated);
}

// ========================================
// ğŸ”¬ GERADOR DE SUGESTÃ•ES COMPARATIVAS A vs B
// ========================================

/**
 * Gera sugestÃµes de IA baseadas no delta entre duas anÃ¡lises (A vs B)
 * @param {object} userAnalysis - AnÃ¡lise da faixa atual (B)
 * @param {object} refAnalysis - AnÃ¡lise da referÃªncia (A)
 * @returns {array} - Array de sugestÃµes comparativas enriquecidas
 */
function buildComparativeAISuggestions(userAnalysis, refAnalysis) {
    log('[A/B-SUGGESTIONS] ğŸ”¬ Gerando sugestÃµes comparativas...');
    
    if (!userAnalysis || !refAnalysis) {
        warn('[A/B-SUGGESTIONS] âš ï¸ AnÃ¡lises incompletas - abortando geraÃ§Ã£o');
        return [];
    }

    // ğŸ” Leitura segura de mÃ©tricas (mÃºltiplos caminhos possÃ­veis)
    const extractMetric = (analysis, metric) => {
        const paths = {
            lufs: [
                analysis?.lufsIntegrated,
                analysis?.avgLoudness,
                analysis?.loudness?.integrated,
                analysis?.technicalData?.lufsIntegrated,
                analysis?.metrics?.loudness?.integrated
            ],
            lra: [
                analysis?.lra,
                analysis?.loudness?.lra,
                analysis?.technicalData?.lra,
                analysis?.metrics?.loudness?.lra
            ],
            tp: [
                analysis?.truePeakDbtp,
                analysis?.truePeak,
                analysis?.loudness?.truePeak,
                analysis?.truePeak?.maxDbtp,
                analysis?.technicalData?.truePeakDbtp,
                analysis?.metrics?.truePeak?.maxDbtp
            ],
            dr: [
                analysis?.dynamicRange,
                analysis?.dynamics?.dynamicRange,
                analysis?.dynamics?.range,
                analysis?.technicalData?.dynamicRange,
                analysis?.metrics?.dynamics?.range
            ],
            cf: [
                analysis?.crestFactor,
                analysis?.dynamics?.crestFactor,
                analysis?.dynamics?.crest,
                analysis?.technicalData?.crestFactor,
                analysis?.metrics?.dynamics?.crest
            ]
        };

        const values = paths[metric] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) {
                return val;
            }
        }
        return null;
    };

    // ğŸ“Š Extrair mÃ©tricas de ambas anÃ¡lises
    const U = {
        lufs: extractMetric(userAnalysis, 'lufs'),
        lra: extractMetric(userAnalysis, 'lra'),
        tp: extractMetric(userAnalysis, 'tp'),
        dr: extractMetric(userAnalysis, 'dr'),
        cf: extractMetric(userAnalysis, 'cf')
    };

    const R = {
        lufs: extractMetric(refAnalysis, 'lufs'),
        lra: extractMetric(refAnalysis, 'lra'),
        tp: extractMetric(refAnalysis, 'tp'),
        dr: extractMetric(refAnalysis, 'dr'),
        cf: extractMetric(refAnalysis, 'cf')
    };

    log('[A/B-SUGGESTIONS] ğŸ“Š MÃ©tricas extraÃ­das:', {
        user: U,
        reference: R
    });

    // ğŸ”¢ Calcular deltas (B - A)
    const Î” = {
        lufs: (U.lufs !== null && R.lufs !== null) ? (U.lufs - R.lufs) : null,
        lra: (U.lra !== null && R.lra !== null) ? (U.lra - R.lra) : null,
        tp: (U.tp !== null && R.tp !== null) ? (U.tp - R.tp) : null,
        dr: (U.dr !== null && R.dr !== null) ? (U.dr - R.dr) : null,
        cf: (U.cf !== null && R.cf !== null) ? (U.cf - R.cf) : null
    };

    log('[A/B-SUGGESTIONS] ğŸ”¢ Deltas calculados:', Î”);

    // ğŸšï¸ Thresholds de relevÃ¢ncia
    const TH = {
        lufs: 1.0,    // 1 LUFS = diferenÃ§a percebÃ­vel
        lra: 0.5,     // 0.5 LU = mudanÃ§a na dinÃ¢mica
        tp: 0.3,      // 0.3 dBTP = diferenÃ§a em headroom
        dr: 0.7,      // 0.7 dB = mudanÃ§a no range dinÃ¢mico
        cf: 0.7       // 0.7 = mudanÃ§a em transientes
    };

    const suggestions = [];

    // ==========================================
    // 1ï¸âƒ£ LOUDNESS (LUFS Integrado)
    // ==========================================
    if (Î”.lufs !== null && Math.abs(Î”.lufs) >= TH.lufs) {
        const maisBaixo = Î”.lufs < 0;
        const severidade = Math.abs(Î”.lufs) >= 3 ? "CRÃTICA" : (Math.abs(Î”.lufs) >= 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "Loudness (A vs B)",
            severidade: severidade,
            problema: `Sua faixa estÃ¡ ${maisBaixo ? "mais baixa" : "mais alta"} que a referÃªncia em ${Math.abs(Î”.lufs).toFixed(2)} LUFS. Faixa atual: ${U.lufs?.toFixed(2)} LUFS vs ReferÃªncia: ${R.lufs?.toFixed(2)} LUFS.`,
            causaProvavel: maisBaixo
                ? "Gain staging conservador na masterizaÃ§Ã£o ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo ou ganho de entrada muito alto.",
            solucao: maisBaixo
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Î”.lufs).toFixed(1)} dB. Use um limiter com ceiling adequado (-0.3 dBTP) e ajuste o input gain atÃ© atingir ${R.lufs?.toFixed(1)} LUFS.`
                : `Reduza o input gain do limiter em ${Math.abs(Î”.lufs).toFixed(1)} dB. Reequilibre os buses para evitar compressÃ£o excessiva e mantenha o ceiling em -1.0 dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer, Waves L2",
            dicaExtra: "Compare trechos equivalentes (drop/refrÃ£o) entre as faixas. Use medidores de loudness (Youlean, LUFS Meter) para monitoramento em tempo real.",
            parametros: {
                alvoLUFS: R.lufs,
                diferenca: Î”.lufs,
                ajusteSugerido: maisBaixo ? `+${Math.abs(Î”.lufs).toFixed(1)} dB` : `-${Math.abs(Î”.lufs).toFixed(1)} dB`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 2ï¸âƒ£ TRUE PEAK
    // ==========================================
    if (Î”.tp !== null && Math.abs(Î”.tp) >= TH.tp) {
        const maisAlto = Î”.tp > 0;
        const severidade = Math.abs(Î”.tp) >= 1.0 ? "CRÃTICA" : (Math.abs(Î”.tp) >= 0.5 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "True Peak (A vs B)",
            severidade: severidade,
            problema: `True Peak ${maisAlto ? "maior" : "menor"} que a referÃªncia em ${Math.abs(Î”.tp).toFixed(2)} dBTP. Faixa atual: ${U.tp?.toFixed(2)} dBTP vs ReferÃªncia: ${R.tp?.toFixed(2)} dBTP.`,
            causaProvavel: maisAlto 
                ? "Inter-sample peaks causados por limiter sem oversampling adequado ou clipping digital." 
                : "Headroom excessivo nÃ£o aproveitado - potencial de ganho adicional.",
            solucao: maisAlto
                ? `Ajuste o ceiling do limiter para mÃ¡ximo de -1.0 dBTP. Habilite oversampling 4x ou superior e revise o release time para evitar distorÃ§Ã£o intersample.`
                : `VocÃª pode aumentar o ceiling em atÃ© ${Math.abs(Î”.tp).toFixed(1)} dB mantendo margem segura. Ajuste para aproximadamente ${R.tp?.toFixed(1)} dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x-32x), iZotope Ozone Maximizer, Waves L2 Ultramaximizer",
            dicaExtra: "Use medidores de true peak (TT Dynamic Range Meter) e sempre mantenha -0.5 a -1.0 dBTP para distribuiÃ§Ã£o em streaming (Spotify, Apple Music).",
            parametros: {
                alvoTP: R.tp,
                diferenca: Î”.tp,
                ceilingRecomendado: maisAlto ? "-1.0 dBTP" : `${R.tp?.toFixed(1)} dBTP`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 3ï¸âƒ£ LRA (Loudness Range - Macro DinÃ¢mica)
    // ==========================================
    if (Î”.lra !== null && Math.abs(Î”.lra) >= TH.lra) {
        const maisEstatica = Î”.lra < 0;
        const severidade = Math.abs(Î”.lra) >= 2.0 ? "ALTA" : (Math.abs(Î”.lra) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "LRA / DinÃ¢mica Macro (A vs B)",
            severidade: severidade,
            problema: `Sua LRA estÃ¡ ${maisEstatica ? "mais baixa" : "mais alta"} que a referÃªncia em ${Math.abs(Î”.lra).toFixed(2)} LU. Faixa atual: ${U.lra?.toFixed(2)} LU vs ReferÃªncia: ${R.lra?.toFixed(2)} LU.`,
            causaProvavel: maisEstatica 
                ? "CompressÃ£o e limiting excessivos reduzindo contraste dinÃ¢mico entre seÃ§Ãµes." 
                : "DiferenÃ§as de arranjo, automaÃ§Ã£o de volume ou menos processamento dinÃ¢mico.",
            solucao: maisEstatica
                ? `Reduza ratio/threshold dos compressores de bus em 2-3 dB. Use automaÃ§Ã£o de volume para criar contrastes entre intro/verso/refrÃ£o/drop. Alivie o limiter para preservar dinÃ¢mica.`
                : `Ajuste levemente o bus compressor (ratio 2:1-3:1, attack 30ms, release auto) para apertar a macro dinÃ¢mica. Considere sidechain compression em elementos rÃ­tmicos.`,
            pluginRecomendado: "SSL Bus Compressor, Glue Compressor (Ableton), API 2500, VCA compressor",
            dicaExtra: "LRA ideal para mÃºsica eletrÃ´nica: 3-6 LU. Para rock/pop: 6-10 LU. Use automaÃ§Ã£o de ganho antes de processar para moldar a dinÃ¢mica desejada.",
            parametros: {
                alvoLRA: R.lra,
                diferenca: Î”.lra,
                tipoProcessamento: maisEstatica ? "Aliviar compressÃ£o" : "Apertar dinÃ¢mica"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 4ï¸âƒ£ DYNAMIC RANGE (DR)
    // ==========================================
    if (Î”.dr !== null && Math.abs(Î”.dr) >= TH.dr) {
        const severidade = Math.abs(Î”.dr) >= 2.0 ? "ALTA" : (Math.abs(Î”.dr) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "Dynamic Range (A vs B)",
            severidade: severidade,
            problema: `Dynamic Range difere em ${Math.abs(Î”.dr).toFixed(2)} dB da referÃªncia. Faixa atual: ${U.dr?.toFixed(2)} dB vs ReferÃªncia: ${R.dr?.toFixed(2)} dB.`,
            causaProvavel: "RelaÃ§Ã£o entre picos e RMS (mÃ©dia de energia) diferente da referÃªncia devido a processamento dinÃ¢mico distinto.",
            solucao: `Ajuste compressÃ£o nos subgrupos (drums, bass, synths) para aproximar DR de ${R.dr?.toFixed(1)} dB. Use clippers transparentes antes do limiter para controlar transientes sem perder corpo.`,
            pluginRecomendado: "Clipper transparente (StandardCLIP, K-Clip), bus compressor multi-banda",
            dicaExtra: "DR tÃ­pico por gÃªnero: EDM (4-6 dB), Pop (6-8 dB), Rock (8-12 dB). Valores muito baixos (<4 dB) indicam overprocessing.",
            parametros: {
                alvoDR: R.dr,
                diferenca: Î”.dr,
                drIdeal: R.dr?.toFixed(1) + " dB"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 5ï¸âƒ£ CREST FACTOR (RelaÃ§Ã£o Pico/RMS)
    // ==========================================
    if (Î”.cf !== null && Math.abs(Î”.cf) >= TH.cf) {
        const severidade = Math.abs(Î”.cf) >= 1.5 ? "MODERADA" : "LEVE";
        
        suggestions.push({
            categoria: "Crest Factor (A vs B)",
            severidade: severidade,
            problema: `Crest Factor difere em ${Math.abs(Î”.cf).toFixed(2)} dB da referÃªncia. Faixa atual: ${U.cf?.toFixed(2)} vs ReferÃªncia: ${R.cf?.toFixed(2)}.`,
            causaProvavel: "Transientes (kicks, snares, attacks) com intensidades diferentes entre as faixas.",
            solucao: `Ajuste attack/release de compressores para aproximar punch da referÃªncia. Use transient shapers para moldar ataques de percussÃ£o. CF alvo: ${R.cf?.toFixed(1)}.`,
            pluginRecomendado: "SPL Transient Designer, Oxford Transmod, Waves Trans-X, saturaÃ§Ã£o sutil (decapitator)",
            dicaExtra: "CF alto = mais transientes (>10 dB). CF baixo = som mais constante (<6 dB). Use saturaÃ§Ã£o para adicionar harmÃ´nicos e corpo sem aumentar picos.",
            parametros: {
                alvoCF: R.cf,
                diferenca: Î”.cf,
                ajusteTransientes: Î”.cf < 0 ? "Aumentar ataques" : "Suavizar transientes"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 6ï¸âƒ£ BANDAS ESPECTRAIS (A vs B) - MODO REFERENCE
    // ğŸ¯ CORREÃ‡ÃƒO: Adicionar sugestÃµes de bandas no modo referÃªncia
    // ==========================================
    const extractBandsFromAnalysis = (analysis) => {
        return analysis?.bands ||
               analysis?.technicalData?.spectral_balance ||
               analysis?.technicalData?.bands ||
               analysis?.metrics?.bands ||
               analysis?.metrics?.spectral_balance ||
               null;
    };

    const userBands = extractBandsFromAnalysis(userAnalysis);
    const refBands = extractBandsFromAnalysis(refAnalysis);

    log('[A/B-SUGGESTIONS] ğŸµ Bandas extraÃ­das:', {
        userHasBands: !!userBands,
        refHasBands: !!refBands,
        userBandKeys: userBands ? Object.keys(userBands) : null,
        refBandKeys: refBands ? Object.keys(refBands) : null
    });

    if (userBands && refBands) {
        // Mapeamento de nomes de bandas (snake_case â†’ display name)
        const bandNameMap = {
            'sub': { name: 'Sub Bass (20-60 Hz)', icon: 'ğŸ”Š' },
            'sub_bass': { name: 'Sub Bass (20-60 Hz)', icon: 'ğŸ”Š' },
            'low_bass': { name: 'Low Bass (60-120 Hz)', icon: 'ğŸ¸' },
            'upper_bass': { name: 'Upper Bass (120-250 Hz)', icon: 'ğŸ¸' },
            'bass': { name: 'Bass (60-250 Hz)', icon: 'ğŸ¸' },
            'low_mid': { name: 'Low Mids (250-500 Hz)', icon: 'ğŸ¹' },
            'lowMid': { name: 'Low Mids (250-500 Hz)', icon: 'ğŸ¹' },
            'mid': { name: 'Mids (500-2000 Hz)', icon: 'ğŸ¤' },
            'mids': { name: 'Mids (500-2000 Hz)', icon: 'ğŸ¤' },
            'high_mid': { name: 'High Mids (2-5 kHz)', icon: 'âœ¨' },
            'highMid': { name: 'High Mids (2-5 kHz)', icon: 'âœ¨' },
            'presence': { name: 'Presence (5-10 kHz)', icon: 'ğŸ””' },
            'presenca': { name: 'Presence (5-10 kHz)', icon: 'ğŸ””' },
            'air': { name: 'Air/Brilho (10-20 kHz)', icon: 'ğŸ’«' },
            'brilho': { name: 'Air/Brilho (10-20 kHz)', icon: 'ğŸ’«' },
            'brilliance': { name: 'Air/Brilho (10-20 kHz)', icon: 'ğŸ’«' }
        };

        // Threshold para considerar diferenÃ§a significativa em bandas (dB)
        const BAND_THRESHOLD_DB = 1.5; // 1.5 dB de diferenÃ§a

        // Iterar sobre todas as bandas disponÃ­veis na referÃªncia
        const allBandKeys = new Set([
            ...Object.keys(userBands),
            ...Object.keys(refBands)
        ]);

        let bandSuggestionsGenerated = 0;

        for (const bandKey of allBandKeys) {
            const userBand = userBands[bandKey];
            const refBand = refBands[bandKey];

            if (!userBand || !refBand) continue;

            // Extrair valores de energia (dB)
            const userValue = typeof userBand === 'object' 
                ? (userBand.energy_db ?? userBand.rms_db ?? userBand.percentage ?? userBand.value)
                : userBand;
            
            const refValue = typeof refBand === 'object'
                ? (refBand.energy_db ?? refBand.rms_db ?? refBand.percentage ?? refBand.value)
                : refBand;

            if (typeof userValue !== 'number' || typeof refValue !== 'number') continue;
            if (isNaN(userValue) || isNaN(refValue)) continue;

            const delta = userValue - refValue;
            const absDelta = Math.abs(delta);

            // Apenas gerar sugestÃ£o se diferenÃ§a for significativa
            if (absDelta < BAND_THRESHOLD_DB) continue;

            const bandInfo = bandNameMap[bandKey] || { name: bandKey, icon: 'ğŸµ' };
            const severidade = absDelta >= 4.0 ? "ALTA" : (absDelta >= 2.5 ? "MODERADA" : "LEVE");
            const direcao = delta > 0 ? "acima" : "abaixo";
            const acao = delta > 0 ? "Reduza" : "Aumente";

            suggestions.push({
                categoria: `${bandInfo.icon} ${bandInfo.name} (A vs B)`,
                severidade: severidade,
                metric: `band_${bandKey}`,
                type: 'band_adjust',
                subtype: bandKey,
                problema: `Banda ${bandInfo.name} estÃ¡ ${direcao} da referÃªncia em ${absDelta.toFixed(1)} dB. Sua faixa: ${userValue.toFixed(1)} dB vs ReferÃªncia: ${refValue.toFixed(1)} dB.`,
                causaProvavel: delta > 0
                    ? `Excesso de energia em ${bandInfo.name} pode causar turbidez ou mascaramento de outras frequÃªncias.`
                    : `DÃ©ficit de energia em ${bandInfo.name} pode resultar em mix thin ou falta de corpo nessa regiÃ£o.`,
                solucao: `${acao} a banda ${bandInfo.name} em aproximadamente ${absDelta.toFixed(1)} dB usando EQ paramÃ©trico ou shelving.`,
                pluginRecomendado: "FabFilter Pro-Q 3, Waves SSL G-EQ, iZotope Ozone EQ",
                dicaExtra: `Compare A/B para garantir que o ajuste aproxima sua faixa da referÃªncia. Use analisador de espectro para monitorar.`,
                parametros: {
                    banda: bandKey,
                    bandaNome: bandInfo.name,
                    valorAtual: userValue,
                    valorReferencia: refValue,
                    diferenca: delta,
                    ajusteSugerido: `${acao} ${absDelta.toFixed(1)} dB`
                },
                technical: {
                    delta: delta,
                    currentValue: userValue,
                    targetValue: refValue,
                    tolerance: BAND_THRESHOLD_DB
                },
                aiEnhanced: true,
                referenceMode: true
            });

            bandSuggestionsGenerated++;
        }

        log(`[A/B-SUGGESTIONS] ğŸµ Bandas espectrais: ${bandSuggestionsGenerated} sugestÃµes geradas`);
    } else {
        warn('[A/B-SUGGESTIONS] âš ï¸ Bandas nÃ£o disponÃ­veis para comparaÃ§Ã£o A/B');
    }

    // ==========================================
    // ğŸ“Š RESULTADO FINAL
    // ==========================================
    log(`[A/B-SUGGESTIONS] âœ… Geradas ${suggestions.length} sugestÃµes comparativas (mÃ©tricas + bandas)`);
    
    if (suggestions.length > 0) {
        log('[A/B-SUGGESTIONS] ğŸ“‹ Resumo das sugestÃµes:', 
            suggestions.map(s => `${s.categoria} (${s.severidade})`).join(', ')
        );
    }

    // ğŸ¯ CORREÃ‡ÃƒO: Aumentar limite para incluir mÃ©tricas E bandas (atÃ© 12 sugestÃµes)
    // Separar por tipo para garantir representaÃ§Ã£o de ambos
    const metricSuggestions = suggestions.filter(s => !s.referenceMode);
    const bandSuggestions = suggestions.filter(s => s.referenceMode === true);
    
    log(`[A/B-SUGGESTIONS] ğŸ“Š DistribuiÃ§Ã£o: ${metricSuggestions.length} mÃ©tricas + ${bandSuggestions.length} bandas`);

    // Ordenar por severidade
    const severityOrder = { "CRÃTICA": 0, "ALTA": 1, "MODERADA": 2, "IMPORTANTE": 3, "LEVE": 4 };
    const sortBySeverity = (a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5);

    // Garantir atÃ© 5 mÃ©tricas + atÃ© 7 bandas = 12 total
    const selectedMetrics = metricSuggestions.sort(sortBySeverity).slice(0, 5);
    const selectedBands = bandSuggestions.sort(sortBySeverity).slice(0, 7);
    
    const finalSuggestions = [...selectedMetrics, ...selectedBands]
        .sort(sortBySeverity);
    
    log(`[A/B-SUGGESTIONS] ğŸ¯ Final: ${finalSuggestions.length} sugestÃµes (${selectedMetrics.length} mÃ©tricas + ${selectedBands.length} bandas)`);
    
    return finalSuggestions;
}

// ========================================
// ğŸ¯ PATCH 2: SUGESTÃ•ES BASEADAS EM GÃŠNERO
// ========================================

/**
 * ğŸ¯ GERAR SUGESTÃ•ES BASEADAS EM TARGETS DE GÃŠNERO
 * @param {Object} analysis - AnÃ¡lise do usuÃ¡rio
 * @param {Object} genreTargets - Targets do gÃªnero (de analysis.data.genreTargets)
 * @returns {Array} - Array de sugestÃµes formatadas
 */
function buildGenreBasedAISuggestions(analysis, genreTargets) {
    log('[GENRE-SUGGESTIONS] ğŸ¯ Gerando sugestÃµes baseadas em gÃªnero...');
    
    if (!analysis || !genreTargets) {
        warn('[GENRE-SUGGESTIONS] âš ï¸ Dados incompletos - abortando geraÃ§Ã£o');
        return [];
    }

    // ğŸ” Extrair mÃ©tricas do usuÃ¡rio
    const extractMetric = (path) => {
        const paths = {
            lufs: [
                analysis.lufsIntegrated,
                analysis.avgLoudness,
                analysis.loudness?.integrated,
                analysis.technicalData?.lufsIntegrated
            ],
            lra: [
                analysis.lra,
                analysis.loudness?.lra,
                analysis.technicalData?.lra
            ],
            tp: [
                analysis.truePeakDbtp,
                analysis.truePeak?.maxDbtp,
                analysis.technicalData?.truePeakDbtp
            ],
            dr: [
                analysis.dynamicRange,
                analysis.dynamics?.range,
                analysis.technicalData?.dynamicRange
            ],
            stereo: [
                analysis.stereoCorrelation,
                analysis.stereo?.correlation,
                analysis.technicalData?.stereoCorrelation
            ]
        };

        const values = paths[path] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) return val;
        }
        return null;
    };

    // ğŸ“Š MÃ©tricas do usuÃ¡rio
    const U = {
        lufs: extractMetric('lufs'),
        lra: extractMetric('lra'),
        tp: extractMetric('tp'),
        dr: extractMetric('dr'),
        stereo: extractMetric('stereo')
    };

    // ğŸ¯ Targets do gÃªnero (estrutura flat do backend normalizado)
    const T = {
        lufs: genreTargets.lufs_target,
        lra: genreTargets.lra_target,
        tp: genreTargets.true_peak_target,
        dr: genreTargets.dr_target,
        stereo: genreTargets.stereo_target
    };

    // ğŸ”¢ TolerÃ¢ncias
    const TOL = {
        lufs: genreTargets.lufs_tolerance || 1.0,
        lra: genreTargets.lra_tolerance || 0.5,
        tp: genreTargets.true_peak_tolerance || 0.3,
        dr: genreTargets.dr_tolerance || 0.7,
        stereo: genreTargets.stereo_tolerance || 0.05
    };

    log('[GENRE-SUGGESTIONS] ğŸ“Š Dados:', { user: U, targets: T, tolerances: TOL });

    // ğŸ”¢ Calcular deltas
    const Î” = {
        lufs: (U.lufs !== null && T.lufs !== null) ? (U.lufs - T.lufs) : null,
        lra: (U.lra !== null && T.lra !== null) ? (U.lra - T.lra) : null,
        tp: (U.tp !== null && T.tp !== null) ? (U.tp - T.tp) : null,
        dr: (U.dr !== null && T.dr !== null) ? (U.dr - T.dr) : null,
        stereo: (U.stereo !== null && T.stereo !== null) ? (U.stereo - T.stereo) : null
    };

    const suggestions = [];
    const genreName = analysis.genre || analysis.data?.genre || 'este gÃªnero';

    // 1ï¸âƒ£ LUFS
    if (Î”.lufs !== null && Math.abs(Î”.lufs) > TOL.lufs) {
        const dentroDoAlvo = Math.abs(Î”.lufs) <= TOL.lufs;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Î”.lufs) > TOL.lufs * 2 ? "CRÃTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `Loudness (PadrÃ£o ${genreName})`,
            severidade,
            problema: `Sua faixa estÃ¡ ${Î”.lufs < 0 ? 'mais baixa' : 'mais alta'} que o padrÃ£o ${genreName} em ${Math.abs(Î”.lufs).toFixed(2)} LUFS. Atual: ${U.lufs?.toFixed(2)} LUFS | Alvo: ${T.lufs?.toFixed(1)} LUFS.`,
            causaProvavel: Î”.lufs < 0
                ? "Gain staging conservador ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo.",
            solucao: Î”.lufs < 0
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Î”.lufs).toFixed(1)} dB.`
                : `Reduza o input gain do limiter em ${Math.abs(Î”.lufs).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer",
            parametros: {
                alvoLUFS: T.lufs,
                diferenca: Î”.lufs,
                tolerancia: TOL.lufs
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 2ï¸âƒ£ TRUE PEAK
    if (Î”.tp !== null && Math.abs(Î”.tp) > TOL.tp) {
        const dentroDoAlvo = Math.abs(Î”.tp) <= TOL.tp;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Î”.tp) > TOL.tp * 2 ? "CRÃTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `True Peak (PadrÃ£o ${genreName})`,
            severidade,
            problema: `True Peak ${Î”.tp > 0 ? 'maior' : 'menor'} que o padrÃ£o em ${Math.abs(Î”.tp).toFixed(2)} dBTP. Atual: ${U.tp?.toFixed(2)} dBTP | Alvo: ${T.tp?.toFixed(1)} dBTP.`,
            causaProvavel: Î”.tp > 0
                ? "Inter-sample peaks causados por limiter sem oversampling adequado."
                : "Headroom excessivo nÃ£o aproveitado.",
            solucao: Î”.tp > 0
                ? `Ajuste o ceiling do limiter para mÃ¡ximo de -1.0 dBTP com oversampling 4x.`
                : `VocÃª pode aumentar o ceiling em atÃ© ${Math.abs(Î”.tp).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x)",
            parametros: {
                alvoTP: T.tp,
                diferenca: Î”.tp,
                tolerancia: TOL.tp
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 3ï¸âƒ£ DYNAMIC RANGE
    if (Î”.dr !== null && Math.abs(Î”.dr) > TOL.dr) {
        const dentroDoAlvo = Math.abs(Î”.dr) <= TOL.dr;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Î”.dr) > TOL.dr * 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: `Dynamic Range (PadrÃ£o ${genreName})`,
            severidade,
            problema: `DR difere do padrÃ£o ${genreName} em ${Math.abs(Î”.dr).toFixed(2)} dB. Atual: ${U.dr?.toFixed(2)} dB | Alvo: ${T.dr?.toFixed(1)} dB.`,
            solucao: `Ajuste compressÃ£o nos subgrupos para aproximar DR de ${T.dr?.toFixed(1)} dB.`,
            parametros: {
                alvoDR: T.dr,
                diferenca: Î”.dr,
                tolerancia: TOL.dr
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // ğŸµ BANDAS ESPECTRAIS V4.1 - CORRIGIDO PARA USAR MESMA FONTE QUE TABELA
    // O JSON de gÃªnero usa: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
    const targetBands = genreTargets.bands || genreTargets.spectralBands;
    
    if (targetBands && Object.keys(targetBands).length > 0) {
        const userBands = analysis.metrics?.bands || analysis.technicalData?.spectral_balance;
        
        if (userBands) {
            // V4.1: Iterar sobre TODAS as bandas do JSON de targets
            const ALL_JSON_BANDS = ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca'];
            
            // Mapeamento reverso: JSON key â†’ canonical key (para buscar valores do usuÃ¡rio)
            const REVERSE_MAP = {
                'low_bass': 'bass',
                'upper_bass': 'bass',
                'low_mid': 'lowMid',
                'high_mid': 'highMid',
                'brilho': 'air',
                'presenca': 'presence'
            };
            
            // Nomes legÃ­veis para cada banda
            const BAND_NAMES = {
                'sub': 'Sub Bass (20-60Hz)',
                'low_bass': 'Low Bass (60-120Hz)',
                'upper_bass': 'Upper Bass (120-250Hz)',
                'low_mid': 'Low Mids (250-500Hz)',
                'mid': 'Mids (500Hz-2kHz)',
                'high_mid': 'High Mids (2-5kHz)',
                'brilho': 'Air/Brilho (10-20kHz)',
                'presenca': 'Presence (5-10kHz)'
            };
            
            ALL_JSON_BANDS.forEach(jsonBand => {
                const targetDef = targetBands[jsonBand];
                if (!targetDef) return;
                
                // Buscar valor do usuÃ¡rio (tentar chave JSON e chave canÃ´nica)
                const canonicalKey = REVERSE_MAP[jsonBand] || jsonBand;
                const userValue = userBands[jsonBand]?.energy_db 
                               ?? userBands[jsonBand]?.percentage 
                               ?? userBands[canonicalKey]?.energy_db 
                               ?? userBands[canonicalKey]?.percentage;
                
                // Extrair target do JSON
                const targetValue = targetDef.target_db ?? targetDef.target ?? targetDef.percentage;
                const tolerance = targetDef.tol_db || targetDef.tolerance || 2.5;
                const bandName = BAND_NAMES[jsonBand] || jsonBand;
                
                if (userValue !== null && userValue !== undefined && targetValue !== null && targetValue !== undefined) {
                    const delta = userValue - targetValue;
                    
                    // V4.1: SÃ³ gerar sugestÃ£o se fora da tolerÃ¢ncia (COERENTE COM TABELA)
                    if (Math.abs(delta) > tolerance) {
                        // Determinar severidade baseada na severity do JSON ou no delta
                        const severity = targetDef.severity || (Math.abs(delta) > tolerance * 2 ? "ALTA" : "MODERADA");
                        
                        suggestions.push({
                            categoria: `Banda ${bandName} (PadrÃ£o ${genreName})`,
                            severidade: severity,
                            problema: `Banda ${bandName} ${delta > 0 ? 'acima' : 'abaixo'} do padrÃ£o em ${Math.abs(delta).toFixed(1)} dB. Atual: ${userValue.toFixed(1)} dB | Alvo: ${targetValue.toFixed(1)} dB.`,
                            solucao: delta > 0
                                ? `Reduza frequÃªncias ${bandName} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`
                                : `Aumente frequÃªncias ${bandName} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`,
                            parametros: {
                                banda: jsonBand,
                                bandaNome: bandName,
                                alvo: targetValue,
                                diferenca: delta,
                                tolerancia: tolerance
                            },
                            aiEnhanced: true,
                            genreBased: true
                        });
                    }
                }
            });
        }
    }

    log(`[GENRE-SUGGESTIONS] âœ… Geradas ${suggestions.length} sugestÃµes baseadas em gÃªnero`);
    
    // Limitar a 8 sugestÃµes mais relevantes (5 mÃ©tricas + top 3 bandas)
    const severityOrder = { "CRÃTICA": 0, "ALTA": 1, "MODERADA": 2, "OK": 3 };
    return suggestions
        .sort((a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5))
        .slice(0, 8);
}

// ========================================
// ğŸ¤– SISTEMA DE ESPERA POR ENRIQUECIMENTO IA
// ========================================

/**
 * Aguarda o enriquecimento IA (aiSuggestions) estar disponÃ­vel
 * @param {string} jobId - ID do job para consultar
 * @param {number} timeout - Tempo mÃ¡ximo de espera em ms (padrÃ£o: 10000ms = 10s)
 * @param {number} pollInterval - Intervalo entre consultas em ms (padrÃ£o: 1000ms = 1s)
 * @returns {Promise<object|null>} - Dados enriquecidos ou null se timeout
 */
async function waitForAIEnrichment(jobId, timeout = 10000, pollInterval = 1000) {
    // PATCH JOB-ID: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== 'string' || jobId === 'undefined') {
        error('[AI-SYNC] âŒ jobId invÃ¡lido ou undefined:', jobId);
        error('[AI-SYNC] âŒ Abortando waitForAIEnrichment - nÃ£o Ã© possÃ­vel consultar job invÃ¡lido');
        return null;
    }
    
    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    log('[AI-SYNC] â³ Aguardando enriquecimento IA...');
    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    log('[AI-SYNC] ğŸ†” Job ID:', jobId);
    log('[AI-SYNC] â±ï¸ Timeout:', timeout, 'ms');
    log('[AI-SYNC] ğŸ”„ Poll interval:', pollInterval, 'ms');
    
    const startTime = Date.now();
    let attempt = 0;
    
    while (Date.now() - startTime < timeout) {
        attempt++;
        const elapsed = Date.now() - startTime;
        
        log(`[AI-SYNC] ğŸ” Tentativa ${attempt} (${elapsed}ms/${timeout}ms)...`);
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`);
            
            if (!response.ok) {
                warn(`[AI-SYNC] âš ï¸ HTTP ${response.status} - Tentando novamente...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
            }
            
            const data = await response.json();
            
            log(`[AI-SYNC] ğŸ“¦ Resposta recebida (tentativa ${attempt}):`, {
                hasAiSuggestions: Array.isArray(data.aiSuggestions),
                aiSuggestionsLength: data.aiSuggestions?.length || 0,
                hasSuggestions: Array.isArray(data.suggestions),
                suggestionsLength: data.suggestions?.length || 0,
                status: data.status
            });
            
            // ğŸ¯ CORREÃ‡ÃƒO #5: Se status=completed E aiSuggestions>0, renderizar (nÃ£o esperar aiEnhanced)
            if (data.status === 'completed' && Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                log('[AI-SYNC] âœ… Status COMPLETED + aiSuggestions disponÃ­veis');
                log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                log('[AI-SYNC] ğŸ“Š Total:', data.aiSuggestions.length, 'sugestÃµes');
                log('[AI-SYNC] â±ï¸ Tempo decorrido:', Date.now() - startTime, 'ms');
                log('[AI-SYNC] ğŸ”“ Renderizando SEM esperar aiEnhanced (evitar loop)');
                return data;
            }
            
            // âœ… VERIFICAÃ‡ÃƒO SECUNDÃRIA: aiSuggestions existe E tem conteÃºdo com aiEnhanced
            if (Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                // Verificar se pelo menos 1 tem aiEnhanced: true
                const aiEnhancedCount = data.aiSuggestions.filter(s => s.aiEnhanced === true).length;
                
                log(`[AI-SYNC] ğŸ¯ aiSuggestions encontrado:`, {
                    total: data.aiSuggestions.length,
                    aiEnhanced: aiEnhancedCount
                });
                
                if (aiEnhancedCount > 0) {
                    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    log('[AI-SYNC] âœ…âœ…âœ… ENRIQUECIMENTO IA CONCLUÃDO! âœ…âœ…âœ…');
                    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    log('[AI-SYNC] ğŸ“Š Total:', data.aiSuggestions.length, 'sugestÃµes');
                    log('[AI-SYNC] ğŸ¤– Marcadas como aiEnhanced:', aiEnhancedCount);
                    log('[AI-SYNC] â±ï¸ Tempo decorrido:', Date.now() - startTime, 'ms');
                    log('[AI-SYNC] ğŸ“‹ Sample da primeira:', {
                        aiEnhanced: data.aiSuggestions[0]?.aiEnhanced,
                        categoria: data.aiSuggestions[0]?.categoria,
                        nivel: data.aiSuggestions[0]?.nivel,
                        hasProblema: !!data.aiSuggestions[0]?.problema,
                        hasSolucao: !!data.aiSuggestions[0]?.solucao
                    });
                    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    
                    return data;
                }
            }
            
            // Se chegou aqui, ainda aguardando
            log(`[AI-SYNC] â³ Aguardando aiSuggestions... (status: ${data.status})`);
            
        } catch (error) {
            error(`[AI-SYNC] âŒ Erro na tentativa ${attempt}:`, error.message);
        }
        
        // Aguardar antes da prÃ³xima tentativa
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout atingido
    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    log('[AI-SYNC] â±ï¸ TIMEOUT ATINGIDO');
    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    warn('[AI-SYNC] âš ï¸ Enriquecimento IA nÃ£o completou dentro do tempo limite');
    warn('[AI-SYNC] âš ï¸ Total de tentativas:', attempt);
    warn('[AI-SYNC] âš ï¸ Tempo decorrido:', Date.now() - startTime, 'ms');
    log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    return null;
}

/**
 * Mostra spinner visual de carregamento IA
 * @param {string} message - Mensagem a exibir
 */
function showAILoadingSpinner(message = 'Conectando Ã  IA...') {
    log('[AI-UI][SPINNER] ğŸ”„ Mostrando spinner:', message);
    
    // Tentar inserir no elemento de status do modal se existir
    const statusElement = document.querySelector('#ai-enrichment-status') || 
                         document.querySelector('.modal-status') ||
                         document.querySelector('.analysis-status');
    
    if (statusElement) {
        statusElement.innerHTML = `
            <div class="ai-loading-spinner" id="aiEnrichmentSpinner">
                <div class="spinner-icon">ğŸ”„</div>
                <div class="spinner-message">${message}</div>
                <div class="spinner-dots">
                    <span class="dot">â—</span>
                    <span class="dot">â—</span>
                    <span class="dot">â—</span>
                </div>
            </div>
        `;
        
        // Adicionar animaÃ§Ã£o via CSS inline
        const style = document.createElement('style');
        style.textContent = `
            .ai-loading-spinner {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background: rgba(0, 0, 0, 0.05);
                border-radius: 8px;
                margin: 10px 0;
            }
            .spinner-icon {
                font-size: 32px;
                animation: spin 2s linear infinite;
            }
            .spinner-message {
                font-size: 14px;
                color: #666;
                margin: 10px 0 5px 0;
                font-weight: 500;
            }
            .spinner-dots {
                display: flex;
                gap: 4px;
            }
            .spinner-dots .dot {
                font-size: 8px;
                animation: pulse 1.5s ease-in-out infinite;
            }
            .spinner-dots .dot:nth-child(2) {
                animation-delay: 0.2s;
            }
            .spinner-dots .dot:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
        `;
        
        if (!document.getElementById('aiSpinnerStyles')) {
            style.id = 'aiSpinnerStyles';
            document.head.appendChild(style);
        }
    } else {
        warn('[AI-UI][SPINNER] âš ï¸ Elemento de status nÃ£o encontrado');
    }
}

/**
 * Remove spinner visual de carregamento IA
 */
function hideAILoadingSpinner() {
    log('[AI-UI][SPINNER] âœ… Removendo spinner');
    
    const spinner = document.getElementById('aiEnrichmentSpinner');
    if (spinner) {
        spinner.remove();
    }
}

/**
 * ObtÃ©m par de anÃ¡lises para comparaÃ§Ã£o
 * @returns {object|null} { ref, curr } ou null se alguma anÃ¡lise estiver faltando
 */
function getComparisonPair() {
    const ref = window.SoundyAI_Store.first;
    const curr = window.SoundyAI_Store.second;
    
    if (!ref || !curr) {
        warn('âš ï¸ [STORE] Ainda falta uma das anÃ¡lises para comparar');
        warn('   - first:', !!ref);
        warn('   - second:', !!curr);
        return null;
    }
    
    log('ğŸ“¦ [STORE] Par de anÃ¡lises obtido');
    log('   - ref.jobId:', ref?.jobId);
    log('   - curr.jobId:', curr?.jobId);
    log('   - ref.fileName:', ref?.fileName || ref?.metadata?.fileName);
    log('   - curr.fileName:', curr?.fileName || curr?.metadata?.fileName);
    
    // ğŸ”’ AUDITORIA AUTOMÃTICA
    console.table({
        refJob: ref?.jobId,
        currJob: curr?.jobId,
        refName: ref?.fileName || ref?.metadata?.fileName,
        currName: curr?.fileName || curr?.metadata?.fileName,
        sameJob: ref?.jobId === curr?.jobId,
        sameName: (ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)
    });
    
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Usar identidade de track (jobId > fileKey > fileName)
    const refIdentity = getTrackIdentity(ref);
    const currIdentity = getTrackIdentity(curr);
    
    // Prioridade 1: jobId (chave primÃ¡ria)
    if (refIdentity.jobId && currIdentity.jobId && refIdentity.jobId === currIdentity.jobId) {
        error('ğŸš¨ [STORE-ERROR] CONTAMINAÃ‡ÃƒO DETECTADA!');
        error('   JobIds sÃ£o IGUAIS:', refIdentity.jobId);
        error('   Isso NÃƒO DEVERIA ACONTECER com sistema isolado');
        console.trace();
        return null; // Bloquear renderizaÃ§Ã£o se jobIds iguais
    }
    
    // Prioridade 2: fileKey (chave secundÃ¡ria)
    if (refIdentity.fileKey && currIdentity.fileKey && refIdentity.fileKey === currIdentity.fileKey) {
        warn('âš ï¸ [STORE-WARNING] FileKeys iguais (porÃ©m jobIds diferentes):', refIdentity.fileKey);
        warn('   Isso pode indicar re-upload do mesmo arquivo');
        // NÃ£o bloqueia reference BASE, apenas avisa
    }
    
    // Prioridade 3: fileName (terciÃ¡ria - apenas se ambos strings vÃ¡lidas)
    // âœ… CORREÃ‡ÃƒO: SÃ³ comparar fileName se AMBOS sÃ£o strings nÃ£o vazias
    const refHasValidFileName = refIdentity.fileName && typeof refIdentity.fileName === 'string' && refIdentity.fileName.trim().length > 0;
    const currHasValidFileName = currIdentity.fileName && typeof currIdentity.fileName === 'string' && currIdentity.fileName.trim().length > 0;
    
    if (refHasValidFileName && currHasValidFileName && refIdentity.fileName === currIdentity.fileName) {
        info('â„¹ï¸ [STORE-INFO] Nomes de arquivo iguais:', refIdentity.fileName);
        info('   Isso Ã© OK se jobIds/fileKeys forem diferentes');
    } else if (!refHasValidFileName || !currHasValidFileName) {
        info('â„¹ï¸ [STORE-INFO] fileName ausente/invÃ¡lido (normal no reference BASE)');
    }
    
    return { ref, curr };
}

// ========================================
// ğŸ”§ UTILIDADES DE CLONAGEM PROFUNDA
// ========================================
/**
 * Clone profundo seguro - tenta structuredClone, fallback para JSON
 * @param {*} obj - Objeto a ser clonado
 * @returns {*} Clone independente ou objeto original (Ãºltimo recurso)
 */
function cloneDeepSafe(obj) {
  if (!obj) return obj;
  try { return structuredClone(obj); } catch {}
  try { return JSON.parse(JSON.stringify(obj)); } catch {}
  return obj; // Ãºltimo recurso (nÃ£o deve acontecer)
}

// ========================================
// ğŸ”’ PASSO 2: PROTEÃ‡ÃƒO DE JOBID (ANTI-CONTAMINAÃ‡ÃƒO)
// ========================================
/**
 * Protege window.__CURRENT_JOB_ID__ contra sobrescrita acidental
 * Bloqueia tentativas de contaminar com __REFERENCE_JOB_ID__
 */
function protectCurrentJobId(initialValue) {
    // Armazena valor privado
    let _currentJobId = initialValue;
    
    // Redefine a propriedade com getter/setter protegido
    Object.defineProperty(window, '__CURRENT_JOB_ID__', {
        configurable: true,
        enumerable: true,
        set: function(value) {
            console.group('âš ï¸ [PROTECTION] Tentativa de alterar currentJobId');
            log('   - Valor antigo:', _currentJobId);
            log('   - Valor novo:', value);
            console.trace('   - Stack trace:');
            console.groupEnd();
            
            // BLOQUEIO: Se tentar contaminar com referenceJobId
            if (value && value === window.__REFERENCE_JOB_ID__) {
                error('âŒ [PROTECTION] BLOQUEADO! Tentativa de contaminar currentJobId com referenceJobId!');
                error('âŒ [PROTECTION] Mantendo valor original:', _currentJobId);
                return; // BLOQUEIA a alteraÃ§Ã£o
            }
            
            // BLOQUEIO: Se jÃ¡ tiver valor e tentar alterar sem justificativa
            if (_currentJobId && value && _currentJobId !== value) {
                warn('âš ï¸ [PROTECTION] Sobrescrita de currentJobId detectada!');
                warn('   Antigo:', _currentJobId);
                warn('   Novo:', value);
            }
            
            _currentJobId = value;
            log('âœ… [PROTECTION] currentJobId atualizado:', _currentJobId);
        },
        get: function() {
            return _currentJobId;
        }
    });
    
    log('ğŸ”’ [PROTECTION] ProteÃ§Ã£o de currentJobId ativada com valor inicial:', initialValue);
}

// ========================================
// ğŸ›¡ï¸ PASSO 3: FUNÃ‡ÃƒO SEGURA PARA OBTER JOBID
// ========================================
/**
 * Retorna o jobId correto baseado no modo, com proteÃ§Ã£o contra contaminaÃ§Ã£o
 * @param {string} mode - 'reference' ou 'genre'
 * @returns {string|null} jobId seguro
 */
/**
 * âš ï¸ DEPRECATED - USE getCorrectJobId() INSTEAD
 * Esta funÃ§Ã£o estÃ¡ DEPRECADA e serÃ¡ removida em versÃµes futuras.
 * MOTIVO: Acessa localStorage diretamente sem validaÃ§Ã£o, causando bug de comparaÃ§Ã£o com mesma mÃºsica.
 * @deprecated Use getCorrectJobId(context) em vez disso
 */
function getJobIdSafely(mode) {
    error('âš ï¸ [DEPRECATED] getJobIdSafely() estÃ¡ DEPRECADA! Use getCorrectJobId() em vez disso.');
    console.trace('ğŸ” [DEPRECATED] Stack trace de quem chamou a funÃ§Ã£o deprecada:');
    
    // Redirecionar para a funÃ§Ã£o correta
    if (mode === 'reference') {
        return getCorrectJobId('reference');
    } else if (mode === 'storage') {
        return getCorrectJobId('storage');
    } else {
        return getCorrectJobId('current');
    }
}

// ========================================
// ğŸ¯ FUNÃ‡ÃƒO UTILITÃRIA CRÃTICA: getCorrectJobId
// ========================================
/**
 * Retorna o jobId correto baseado no contexto
 * NUNCA use localStorage.getItem('referenceJobId') diretamente!
 * SEMPRE use esta funÃ§Ã£o!
 * 
 * @param {string} context - 'user'|'second'|'current' = segunda mÃºsica
 *                          'reference'|'first' = primeira mÃºsica
 *                          'storage' = fallback para localStorage
 * @returns {string|null} jobId correto para o contexto
 */
function getCorrectJobId(context) {
    const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
    
    console.group(`ğŸ¯ [GET-CORRECT-JOBID] Contexto: ${context}`);
    log('   - Modo atual:', mode);
    log('   - window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    log('   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    log('   - sessionStorage.currentJobId:', sessionStorage.getItem('currentJobId'));
    log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    
    if (mode === 'reference') {
        // Em modo reference, temos dois jobIds diferentes
        const currentJobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId');
        
        // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager para ler referenceJobId
        const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
        
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: NUNCA retornar jobIds iguais
        if (currentJobId && referenceJobId && currentJobId === referenceJobId) {
            error('âŒ [CRITICAL] JobIds sÃ£o iguais! Isso NÃƒO deveria acontecer!');
            error('   currentJobId:', currentJobId);
            error('   referenceJobId:', referenceJobId);
            error('   context:', context);
            console.trace();
            
            // Tenta recuperar do sessionStorage
            const recoveredJobId = sessionStorage.getItem('currentJobId');
            if (recoveredJobId && recoveredJobId !== referenceJobId) {
                warn('âš ï¸ [RECOVERY] JobId recuperado do sessionStorage:', recoveredJobId);
                window.__CURRENT_JOB_ID__ = recoveredJobId;
                console.groupEnd();
                return recoveredJobId;
            }
            
            throw new Error('FATAL: JobIds iguais em modo reference - contaminaÃ§Ã£o detectada!');
        }
        
        // Decide qual jobId usar baseado no contexto
        let selectedJobId;
        if (context === 'user' || context === 'second' || context === 'current') {
            selectedJobId = currentJobId;
            log('âœ… [JOB-ID] Retornando currentJobId (segunda mÃºsica):', selectedJobId);
        } else if (context === 'reference' || context === 'first') {
            selectedJobId = referenceJobId;
            log('âœ… [JOB-ID] Retornando referenceJobId (primeira mÃºsica):', selectedJobId);
        } else if (context === 'storage') {
            // Fallback para localStorage (compatibilidade)
            selectedJobId = referenceJobId;
            warn('âš ï¸ [JOB-ID] Contexto "storage" - retornando referenceJobId:', selectedJobId);
        } else {
            warn('âš ï¸ [JOB-ID] Contexto nÃ£o especificado:', context);
            selectedJobId = currentJobId; // Default: segunda mÃºsica
            log('   - Default: retornando currentJobId:', selectedJobId);
        }
        
        console.groupEnd();
        return selectedJobId;
    } else {
        // Modo normal: sÃ³ existe um jobId
        const jobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId') || localStorage.getItem('currentJobId');
        log('âœ… [JOB-ID] Modo normal - retornando:', jobId);
        console.groupEnd();
        return jobId;
    }
}

// ========================================
// ğŸ”„ HIDRATAÃ‡ÃƒO DE REFERÃŠNCIA (CorreÃ§Ã£o 1)
// ========================================
/**
 * Garante que a referÃªncia esteja hidratada e disponÃ­vel para comparaÃ§Ã£o A/B.
 * Fonte de verdade: AnalysisCache âœ FirstAnalysisStore âœ __FIRST_ANALYSIS_FROZEN__
 * @returns {Object} { ok: boolean, reason?: string, refId?: string, hasBands?: boolean, file?: string }
 */
function ensureReferenceHydrated() {
  try {
    const mode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
    // ğŸ¯ CORREÃ‡ÃƒO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');

    if (mode !== 'reference' || !refId) {
      return { ok: false, reason: 'no-ref-mode-or-id' };
    }

    // Fonte de verdade: AnalysisCache âœ FirstAnalysisStore âœ __FIRST_ANALYSIS_FROZEN__
    const cache = window.AnalysisCache;
    let ref = cache?.get?.(refId) || window.FirstAnalysisStore?.get?.() || window.__FIRST_ANALYSIS_FROZEN__;

    if (!ref) {
      return { ok: false, reason: 'no-ref-object' };
    }

    // deep clone SEM compartilhar metadata/bands
    const refClone = (typeof structuredClone === 'function') 
      ? structuredClone(ref) 
      : JSON.parse(JSON.stringify(ref));

    // Normalizar shape esperado (bands/technicalData/metadata)
    if (!refClone.bands && refClone.spectralBands) {
      refClone.bands = refClone.spectralBands;
    }

    // Publicar referÃªncia consistente no escopo global
    window.referenceAnalysisData = refClone;
    window.__FIRST_ANALYSIS_FROZEN__ = (typeof structuredClone === 'function') 
      ? structuredClone(refClone) 
      : JSON.parse(JSON.stringify(refClone));

    // SinalizaÃ§Ã£o
    log('[ensureReferenceHydrated] âœ… ReferÃªncia hidratada:', {
      refId,
      hasBands: !!refClone?.bands,
      file: refClone?.metadata?.fileName || refClone?.fileName
    });

    return { 
      ok: true, 
      refId, 
      hasBands: !!refClone?.bands, 
      file: refClone?.metadata?.fileName || refClone?.fileName 
    };
  } catch (e) {
    warn('[ensureReferenceHydrated] âŒ erro', e);
    return { ok: false, reason: 'exception', error: String(e) };
  }
}

// ========================================
// ğŸ›¡ï¸ GUARDIÃƒO GLOBAL: aiUIController Stub
// ========================================
/**
 * Garante que aiUIController sempre existe, mesmo antes do carregamento completo.
 * Cria stub temporÃ¡rio que Ã© substituÃ­do quando o controller real Ã© carregado.
 */
(function ensureAIUIController() {
  if (!window.aiUIController) {
    warn('[SAFE-BOOT] aiUIController ausente - criando stub temporario.');

    window.aiUIController = {
      renderMetricCards: () => warn('[STUB] renderMetricCards chamado antes da carga real.'),
      renderScoreSection: () => warn('[STUB] renderScoreSection chamado antes da carga real.'),
      renderSuggestions: () => warn('[STUB] renderSuggestions chamado antes da carga real.'),
      renderFinalScoreAtTop: () => warn('[STUB] renderFinalScoreAtTop chamado antes da carga real.'),
      checkForAISuggestions: () => warn('[STUB] checkForAISuggestions chamado antes da carga real.')
    };
  }

  // Espera ate o real ser carregado (quando o modulo UI inicializa)
  const observer = new MutationObserver(() => {
    if (window.aiUIController?.__ready) {
      log('[SAFE-BOOT] âœ… aiUIController real detectado, removendo stub.');
      
      // ========================================
      // âœ… AUDITORIA DE COMPATIBILIDADE
      // ========================================
      const requiredFunctions = [
        'renderMetricCards',
        'renderScoreSection',
        'renderSuggestions',
        'renderFinalScoreAtTop',
        'checkForAISuggestions'
      ];
      
      const missingFunctions = requiredFunctions.filter(
        fn => typeof window.aiUIController[fn] !== 'function'
      );
      
      if (missingFunctions.length === 0) {
        log('[COMPAT] âœ… aiUIController detectado com todas as funÃ§Ãµes esperadas');
        log('[COMPAT] FunÃ§Ãµes disponÃ­veis:', requiredFunctions);
      } else {
        error('[COMPAT-FAIL] âŒ FunÃ§Ãµes ausentes:', missingFunctions);
        error('[COMPAT-FAIL] Tipo de aiUIController:', typeof window.aiUIController);
        error('[COMPAT-FAIL] ProtÃ³tipo:', Object.getPrototypeOf(window.aiUIController));
      }
      
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
})();

// ========================================
// âœ… CORREÃ‡ÃƒO 4: Alias Seguro para aiUIController
// ========================================
// Garantir que funÃ§Ãµes legadas estejam disponÃ­veis como fallback
(function createAIUIControllerAliases() {
  if (!window.aiUIController) window.aiUIController = {};
  
  // Se renderMetricCards nÃ£o existe mas existe funÃ§Ã£o global, criar alias
  if (typeof window.aiUIController.renderMetricCards !== 'function' && 
      typeof window.renderMetricCards === 'function') {
    window.aiUIController.renderMetricCards = (...args) => window.renderMetricCards(...args);
    log('[ALIAS] âœ… Criado alias: aiUIController.renderMetricCards â†’ renderMetricCards');
  }
  
  if (typeof window.aiUIController.renderScoreSection !== 'function' && 
      typeof window.renderScoreSection === 'function') {
    window.aiUIController.renderScoreSection = (...args) => window.renderScoreSection(...args);
    log('[ALIAS] âœ… Criado alias: aiUIController.renderScoreSection â†’ renderScoreSection');
  }
  
  if (typeof window.aiUIController.renderSuggestions !== 'function' && 
      typeof window.renderSuggestions === 'function') {
    window.aiUIController.renderSuggestions = (...args) => window.renderSuggestions(...args);
    log('[ALIAS] âœ… Criado alias: aiUIController.renderSuggestions â†’ renderSuggestions');
  }
  
  if (typeof window.aiUIController.renderFinalScoreAtTop !== 'function' && 
      typeof window.renderFinalScoreAtTop === 'function') {
    window.aiUIController.renderFinalScoreAtTop = (...args) => window.renderFinalScoreAtTop(...args);
    log('[ALIAS] âœ… Criado alias: aiUIController.renderFinalScoreAtTop â†’ renderFinalScoreAtTop');
  }
})();

// ğŸ“ Carregar gerador de texto didÃ¡tico
if (typeof window !== 'undefined' && !window.SuggestionTextGenerator) {
    const script = document.createElement('script');
    script.src = 'suggestion-text-generator.js';
    script.async = true;
    script.onload = () => {
        log('[AudioIntegration] Gerador de texto didÃ¡tico carregado');
    };
    script.onerror = () => {
        warn('[AudioIntegration] Falha ao carregar gerador de texto didÃ¡tico');
    };
    document.head.appendChild(script);
}

// Debug flag (silencia logs em produÃ§Ã£o; defina window.DEBUG_ANALYZER = true para habilitar)
const __DEBUG_ANALYZER__ = true; // ğŸ”§ TEMPORÃRIO: Ativado para debug do problema
const __dbg = (...a) => { if (__DEBUG_ANALYZER__) log('[AUDIO-DEBUG]', ...a); };
const __dwrn = (...a) => { if (__DEBUG_ANALYZER__) warn('[AUDIO-WARN]', ...a); };

// ========================================
// ğŸ—‚ï¸ STORES GLOBAIS: AnalysisCache + FirstAnalysisStore
// ========================================
(function initGlobalStores() {
  if (!window.AnalysisCache) {
    // ğŸ”§ ImplementaÃ§Ã£o segura sem recursÃ£o infinita
    const _data = new Map();
    
    window.AnalysisCache = {
      _data: _data,
      
      get(key) {
        if (!key) return null;
        const value = this._data.get(key);
        return value ? cloneDeepSafe(value) : null;
      },
      
      set(key, value) {
        if (!key || !value) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(value)));
      },
      
      has(key) {
        return key ? this._data.has(key) : false;
      },
      
      delete(key) {
        return this._data.delete(key);
      },
      
      clear() {
        this._data.clear();
        log('[CACHE] ğŸ—‘ï¸ clear');
      },
      
      // ğŸ”§ API ESTENDIDA: Suporta Virtual IDs (vid) ou jobId simples
      put(keyOrAnalysis, analysis) {
        // Suporta: put(vid, analysis) ou put(analysis)
        let key, data;
        if (typeof keyOrAnalysis === 'string' && analysis) {
          key = keyOrAnalysis; // Virtual ID explÃ­cito
          data = analysis;
        } else {
          data = keyOrAnalysis;
          key = data?.jobId || data?.id; // Backward compatibility
        }
        
        if (!key || !data) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(data)));
        log('[CACHE] âœ… put', { 
          vid: key, 
          file: data?.fileName || data?.metadata?.fileName,
          isVirtualId: key.includes('::')
        });
      },
      
      ids() {
        return Array.from(this._data.keys());
      }
    };
    
    log('[BOOT] AnalysisCache âœ… (Virtual ID support, no recursion)');
  }

  if (!window.FirstAnalysisStore) {
    const _state = {
      user: null,      // Primeira faixa (USER)
      userVid: null,   // Virtual ID do user
      userJobId: null, // jobId original do user
      ref: null,       // Segunda faixa (REF)
      refVid: null,    // Virtual ID da ref
      refJobId: null   // jobId original da ref
    };

    window.FirstAnalysisStore = {
      // ========================================
      // ğŸ¯ API POR PAPEL (USER/REF)
      // ========================================
      setUser(analysis, vid, jobId) {
        if (_state.user) {
          warn('[FIRST-STORE] âš ï¸ USER jÃ¡ existe - nÃ£o sobrescrever');
          return; // set-once para user
        }
        _state.user = analysis;
        _state.userVid = vid;
        _state.userJobId = jobId || analysis?.jobId;
        log('[FIRST-STORE] âœ… setUser', { 
          vid, 
          jobId: _state.userJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      setRef(analysis, vid, jobId) {
        // REF pode ser sobrescrito (usuÃ¡rio pode trocar segunda faixa)
        _state.ref = analysis;
        _state.refVid = vid;
        _state.refJobId = jobId || analysis?.jobId;
        log('[FIRST-STORE] âœ… setRef', { 
          vid, 
          jobId: _state.refJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      getUser() {
        if (_state.user) return _state.user;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.USER);
          log('[FIRST-STORE] â™»ï¸ RESTORE USER from cache', { vid: window.CacheIndex.USER });
          return restored;
        }
        return null;
      },
      
      getRef() {
        if (_state.ref) return _state.ref;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.REF && window.AnalysisCache?.has(window.CacheIndex.REF)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.REF);
          log('[FIRST-STORE] â™»ï¸ RESTORE REF from cache', { vid: window.CacheIndex.REF });
          return restored;
        }
        return null;
      },
      
      has() { 
        return !!_state.user || !!(window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER));
      },
      
      // ========================================
      // ğŸ”§ COMPATIBILIDADE COM API ANTIGA
      // ========================================
      set(analysis) {
        // Backward compatibility: se nÃ£o tem user, assume que Ã© o primeiro
        if (!_state.user) {
          const jobId = analysis?.jobId || analysis?.id;
          const vid = `${jobId}::USER`;
          this.setUser(analysis, vid, jobId);
          window.CacheIndex.USER = vid;
          
          // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager ao invÃ©s de localStorage direto
          try { 
            window.StorageManager.setReferenceJobId(jobId || '');
          } catch (e) {
            warn('[FIRST-STORE] âš ï¸ Falha ao salvar referenceJobId:', e);
          }
        } else {
          warn('[FIRST-STORE] âš ï¸ set() chamado mas USER jÃ¡ existe - use setRef()');
        }
      },
      
      get() {
        // Backward compatibility: retorna user (primeira faixa)
        return this.getUser();
      },
      
      id() { return _state.userJobId; },
      jobId() { return _state.userJobId; },
      
      clear() { 
        _state.user = null;
        _state.userVid = null;
        _state.userJobId = null;
        _state.ref = null;
        _state.refVid = null;
        _state.refJobId = null;
        window.CacheIndex.USER = null;
        window.CacheIndex.REF = null;
        
        // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager
        try { 
          window.StorageManager.clearReference();
        } catch (e) {
          warn('[FIRST-STORE] âš ï¸ Falha ao limpar referÃªncia:', e);
        }
        
        log('[FIRST-STORE] ğŸ—‘ï¸ clear (USER + REF)');
      },
      
      // ========================================
      // ğŸ“Š DEBUG
      // ========================================
      _debug() {
        return {
          hasUser: !!_state.user,
          hasRef: !!_state.ref,
          userVid: _state.userVid,
          refVid: _state.refVid,
          userJobId: _state.userJobId,
          refJobId: _state.refJobId,
          cacheIndexUser: window.CacheIndex.USER,
          cacheIndexRef: window.CacheIndex.REF
        };
      }
    };
    log('[BOOT] FirstAnalysisStore âœ… (Role-based: USER/REF)');
  }
})();

// Alias global para compatibilidade com cÃ³digo existente
const FirstAnalysisStore = window.FirstAnalysisStore;

// ========================================
// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: Cache por Papel (Role)
// ========================================
/**
 * Salva resultado de anÃ¡lise com Virtual ID baseado no papel (USER ou REF)
 * @param {Object} result - Resultado da anÃ¡lise do backend
 * @param {Object} options - { isSecondTrack: boolean }
 * @returns {Object} { vid: string, clone: Object }
 */
function cacheResultByRole(result, { isSecondTrack }) {
  // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
  const base = result; // âœ… LEITURA DIRETA
  
  // Clone profundo para evitar mutaÃ§Ãµes
  const clone = (typeof structuredClone === 'function') 
    ? structuredClone(base) 
    : JSON.parse(JSON.stringify(base));
  
  // Criar Virtual ID: jobId + papel (USER ou REF)
  const jobId = result.jobId || result.id;
  const role = isSecondTrack ? 'REF' : 'USER';
  const vid = `${jobId}::${role}`;
  
  // Salvar no cache com VID
  window.AnalysisCache.put(vid, clone);
  
  // Atualizar Ã­ndice de papÃ©is
  if (isSecondTrack) {
    window.CacheIndex.REF = vid;
  } else {
    window.CacheIndex.USER = vid;
  }
  
  log('[VID] âœ… Cached by role', { 
    vid, 
    role, 
    jobId, 
    file: clone?.fileName || clone?.metadata?.fileName,
    isSecondTrack
  });
  
  return { vid, clone };
}

// ï¿½ï¸ GUARDS: Isolamento de jobIds para evitar self-compare
// Recebe objetos jÃ¡ clonados e garante que refFull tenha jobId Ãºnico se necessÃ¡rio
function refHardGuards({ userFull, refFull, secondAnalysis }) {
    // ========================================
    // âœ… CORREÃ‡ÃƒO 4: ValidaÃ§Ã£o de entrada
    // ========================================
    if (!userFull) {
        warn('[refHardGuards] âš ï¸ userFull invÃ¡lido');
        return { ok: false, reason: 'invalid-user' };
    }
    if (!refFull) {
        warn('[refHardGuards] âš ï¸ refFull invÃ¡lido');
        return { ok: false, reason: 'invalid-ref' };
    }

    const userId = userFull?.jobId || userFull?.id;
    const refId = refFull?.jobId || refFull?.id;
    const secondId = secondAnalysis?.jobId || secondAnalysis?.id;

    // Se jobIds sÃ£o iguais, forÃ§a isolamento adicionando sufixo __ref
    if (userId && refId && userId === refId) {
        warn('[GUARD] âš ï¸ jobIds iguais, isolando referÃªncia com sufixo __ref');
        // Clone para evitar mutaÃ§Ã£o do original
        refFull = (typeof structuredClone === 'function')
            ? structuredClone(refFull)
            : JSON.parse(JSON.stringify(refFull));
        refFull.jobId = `${refId}__ref`; // forÃ§a ID diferente
    }

    log('[GUARD] âœ… userJobId:', userId, '| refJobId:', refFull?.jobId || refFull?.id);
    return { ok: true, userFull, refFull };
}

// ï¿½ğŸ”’ CLONE PROFUNDO SEGURO (sem loops circulares)
// Substitui JSON.parse(JSON.stringify()) com proteÃ§Ã£o contra referÃªncias circulares
function deepCloneSafe(obj, seen = new WeakMap()) {
    // Primitivos e null retornam direto
    if (obj === null || typeof obj !== 'object') return obj;
    
    // Se jÃ¡ visitamos este objeto, retornar clone existente (evita loop infinito)
    if (seen.has(obj)) return seen.get(obj);
    
    // Criar estrutura base (array ou objeto)
    const clone = Array.isArray(obj) ? [] : {};
    
    // Registrar no mapa ANTES de clonar propriedades (previne recursÃ£o infinita)
    seen.set(obj, clone);
    
    // Clonar cada propriedade recursivamente
    for (const key in obj) {
        // Ignorar propriedades especÃ­ficas que causam loops circulares
        if (key === '_referenceAnalysis') {
            log('[DEEP-CLONE] âš ï¸ Propriedade circular ignorada:', key);
            continue;
        }
        
        // Verificar se propriedade Ã© prÃ³pria (nÃ£o herdada)
        if (Object.hasOwn(obj, key)) {
            clone[key] = deepCloneSafe(obj[key], seen);
        }
    }
    
    return clone;
}

// ï¿½ STRINGIFY SEGURO (sem loops circulares)
// Substitui JSON.stringify() com proteÃ§Ã£o contra referÃªncias circulares
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (key, value) => {
        // Detectar e marcar referÃªncias circulares
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
        }
        
        // Omitir propriedades especÃ­ficas que causam loops
        if (key === "_referenceAnalysis" || key === "referenceAnalysis") {
            return "[OmittedRef]";
        }
        
        // Omitir propriedades privadas (comeÃ§am com _)
        if (key && key.startsWith("_")) {
            return undefined;
        }
        
        return value;
    }, 2); // IndentaÃ§Ã£o de 2 espaÃ§os para legibilidade
}

// ï¿½ğŸ›¡ï¸ HELPER: Comparador robusto de faixas (evita falso self-compare)
function areSameTrack(a, b) {
    if (!a || !b) return false;

    // Prioridade 1: jobId
    const aj = a.jobId || a.id;
    const bj = b.jobId || b.id;
    if (aj && bj) return aj === bj;

    // Prioridade 2: fileKey
    if (a.fileKey && b.fileKey) return a.fileKey === b.fileKey;

    // Prioridade 3: fileName + sampleRate + duraÃ§Ã£o aproximada
    const nameEqual = a.fileName && b.fileName && a.fileName === b.fileName;
    const srA = a.sampleRate || a.metadata?.sampleRate;
    const srB = b.sampleRate || b.metadata?.sampleRate;
    const durA = a.duration || a.metadata?.duration;
    const durB = b.duration || b.metadata?.duration;
    if (nameEqual && srA && srB && srA === srB) {
        const diff = Math.abs((durA || 0) - (durB || 0));
        return diff < 0.2;
    }

    return false;
}

// =============== CLONE & SANITIZE (SEM CICLOS) ===============
function safeDeepClone(obj, cache = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (cache.has(obj)) return cache.get(obj);

    if (Array.isArray(obj)) {
        const arr = [];
        cache.set(obj, arr);
        obj.forEach(v => arr.push(safeDeepClone(v, cache)));
        return arr;
    }

    const clone = {};
    cache.set(obj, clone);

    for (const key of Object.keys(obj)) {
        // Remove referÃªncias internas e funÃ§Ãµes
        if (key.startsWith('_') || typeof obj[key] === 'function' || typeof obj[key] === 'symbol') continue;
        clone[key] = safeDeepClone(obj[key], cache);
    }

    return clone;
}

// Reduz o objeto de anÃ¡lise para apenas o necessÃ¡rio
function pickAnalysisFields(a) {
    if (!a) return a;
    const s = safeDeepClone(a);
    return {
        id: s.id ?? s.jobId,
        jobId: s.jobId ?? s.id,
        fileKey: s.fileKey,
        fileName: s.fileName,
        loudness: s.loudness,
        dynamics: s.dynamics,
        spectral: s.spectral,
        metrics: s.metrics,
        technicalData: s.technicalData,
        bands: s.bands,
        spectralBands: s.spectralBands,
        metadata: s.metadata,
    };
}

// NormalizaÃ§Ã£o segura (copia antes de processar)
function normalizeSafe(raw) {
    // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
    return pickAnalysisFields(raw); // âœ… LEITURA DIRETA
}

// ğŸ†” SISTEMA runId - FunÃ§Ã£o utilitÃ¡ria centralizada
function generateAnalysisRunId(context = 'ui') {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${context}_${timestamp}_${random}`;
}

// ğŸ›¡ï¸ HELPER: Preparar options com runId de forma segura
function prepareAnalysisOptions(baseOptions = {}, context = 'analysis') {
    // Gerar runId se nÃ£o fornecido
    if (!baseOptions.runId) {
        baseOptions.runId = generateAnalysisRunId(context);
    }
    
    // Configurar variÃ¡vel global para UI_GATE
    window.__CURRENT_ANALYSIS_RUN_ID__ = baseOptions.runId;
    
    __dbg(`ğŸ†” [runId] Preparado para anÃ¡lise: ${baseOptions.runId} (contexto: ${context})`);
    
    return { ...baseOptions };
}

// ğŸ” FUNÃ‡ÃƒO DE DIAGNÃ“STICO DO FLUXO DE REFERÃŠNCIA
window.diagnosticReferenceFlow = function() {
    log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    log('%cğŸ” DIAGNÃ“STICO COMPLETO DO FLUXO DE REFERÃŠNCIA', 'color:#00FFFF;font-weight:bold;');
    log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    
    log('%cğŸ“Š Estado Atual:', 'color:#FFD700;font-weight:bold;');
    log('  Mode:', currentAnalysisMode);
    log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'null');
    log('  localStorage.referenceJobId:', localStorage.getItem('referenceJobId') || 'null');
    
    log('%cğŸ—‚ï¸ Estado Global:', 'color:#FFD700;font-weight:bold;');
    log('  window.__soundyState:', window.__soundyState);
    log('  previousAnalysis:', window.__soundyState?.previousAnalysis?.jobId || 'null');
    log('  userAnalysis:', window.__soundyState?.userAnalysis?.jobId || 'null');
    log('  referenceAnalysis:', window.__soundyState?.referenceAnalysis?.jobId || 'null');
    
    log('%cğŸ’¾ Dados de ReferÃªncia:', 'color:#FFD700;font-weight:bold;');
    log('  FirstAnalysisStore:', FirstAnalysisStore.has() ? 'PRESENTE' : 'null');
    log('  window.referenceComparisonMetrics:', window.referenceComparisonMetrics ? 'PRESENTE' : 'null');
    
    log('%cğŸ¯ DiagnÃ³stico:', 'color:#00FF00;font-weight:bold;');
    // ğŸ¯ CORREÃ‡ÃƒO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');
    if (currentAnalysisMode === 'reference') {
        if (!refId) {
            log('  âœ… Primeira mÃºsica - pronto para receber segunda');
        } else {
            log('  âœ… Aguardando segunda mÃºsica');
            log(`  ğŸ“Œ Job ID da primeira: ${refId}`);
        }
    } else {
        log('  â„¹ï¸ Modo atual nÃ£o Ã© "reference"');
    }
    
    log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
    log('%cğŸ’¡ Para testar:', 'color:#FFFF00;');
    log('  1. FaÃ§a upload da primeira mÃºsica');
    log('  2. Verifique se [REF-SAVE âœ…] aparece');
    log('  3. FaÃ§a upload da segunda mÃºsica');
    log('  4. Verifique se [REF-LOAD âœ…] e [REF-FIX-PAYLOAD] aparecem');
    log('%câ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'color:#00FFFF;font-weight:bold;');
};

let currentModalAnalysis = null;
let __audioIntegrationInitialized = false; // evita listeners duplicados
let __refDataCache = {}; // cache por gÃªnero
let __activeRefData = null; // dados do gÃªnero atual
let __genreManifest = null; // manifesto de gÃªneros (opcional)
let __activeRefGenre = null; // chave do gÃªnero atualmente carregado em __activeRefData
let __refDerivedStats = {}; // estatÃ­sticas agregadas (ex: mÃ©dia stereo) por gÃªnero

// ğŸ¯ MODO REFERÃŠNCIA - VariÃ¡veis globais
let currentAnalysisMode = 'genre'; // 'genre' | 'reference'
let referenceStepState = {
    currentStep: 'userAudio', // 'userAudio' | 'referenceAudio' | 'analysis'
    userAudioFile: null,
    referenceAudioFile: null,
    userAnalysis: null,
    referenceAnalysis: null
};

// ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: Flag para rastrear se usuÃ¡rio EXPLICITAMENTE selecionou modo reference
// Impede que o sistema ative modo A/B automaticamente quando usuÃ¡rio estÃ¡ em modo genre
let userExplicitlySelectedReferenceMode = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” FUNÃ‡ÃƒO UTILITÃRIA: Verificar se existe contexto de referÃªncia ativo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function hasActiveReferenceContext() {
  const refFlow = window.referenceFlow;
  const refState = refFlow?.state;
  
  // Verificar mÃºltiplas fontes de contexto
  const checks = {
    awaitingSecond: refState?.stage === 'awaiting_second',
    hasBaseJobId: !!refState?.baseJobId,
    hasWindowRefJobId: !!window.__REFERENCE_JOB_ID__,
    hasSessionRefJobId: !!sessionStorage.getItem('__REFERENCE_JOB_ID__'),
    hasFirstAnalysisStore: window.FirstAnalysisStore?.has() === true,
    hasStorageManager: !!window.StorageManager?.getReferenceJobId()
  };
  
  const hasContext = Object.values(checks).some(v => v === true);
  
  log('[REF-GUARD] Verificando contexto ativo:', checks, 'â†’', hasContext);
  return hasContext;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” PERSISTÃŠNCIA DA FLAG userExplicitlySelectedReferenceMode
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function persistReferenceFlag(value) {
  const boolValue = value === true; // Garantir boolean
  userExplicitlySelectedReferenceMode = boolValue;
  sessionStorage.setItem('userExplicitlySelectedReferenceMode', String(boolValue));
  log('[REF-GUARD] Flag persistida:', boolValue);
}

function restoreReferenceFlag() {
  const stored = sessionStorage.getItem('userExplicitlySelectedReferenceMode');
  if (stored !== null) {
    // Parse correto: "true" â†’ true, "false" â†’ false
    userExplicitlySelectedReferenceMode = stored === 'true';
    log('[REF-GUARD] Flag restaurada:', userExplicitlySelectedReferenceMode);
  }
}

// Restaurar flag ao carregar
restoreReferenceFlag();

// ========================================
// ğŸ”¥ STATE MACHINE - VIEW MODE CONTROLLER
// ========================================
// Controla qual UI deve ser renderizada (gÃªnero vs referÃªncia)
// Impede contaminaÃ§Ã£o entre modos
window.__soundyViewMode = window.__soundyViewMode || "genre";

function setViewMode(mode) {
    const validModes = ["genre", "reference"];
    if (!validModes.includes(mode)) {
        error("[VIEW-MODE] âŒ Modo invÃ¡lido:", mode);
        return;
    }
    
    const oldMode = window.__soundyViewMode;
    window.__soundyViewMode = mode;
    
    log(`%c[VIEW-MODE] ğŸ”„ Alterado: ${oldMode} â†’ ${mode}`, 'color:#00D9FF;font-weight:bold;font-size:13px;');
    
    // Limpar estado do modo anterior
    if (mode === "genre" && oldMode === "reference") {
        log("[VIEW-MODE] ğŸ§¹ Limpando estado de referÃªncia ao mudar para gÃªnero");
        resetReferenceStateFully();
        
        // âœ… Resetar referenceFlow tambÃ©m
        if (window.referenceFlow) {
            window.referenceFlow.reset();
            log("[VIEW-MODE] âœ… ReferenceFlow resetado");
        }
    }
    
    // âœ… Iniciar novo fluxo de referÃªncia ao mudar para reference
    if (mode === "reference" && oldMode === "genre") {
        log("[VIEW-MODE] ğŸ¯ Iniciando novo fluxo de referÃªncia");
        if (window.referenceFlow) {
            window.referenceFlow.startNewReferenceFlow();
            log("[VIEW-MODE] âœ… ReferenceFlow iniciado");
        }
    }
}

function getViewMode() {
    return window.__soundyViewMode || "genre";
}

// ğŸ”’ GUARD: Bloqueia execuÃ§Ã£o de UI de referÃªncia no modo gÃªnero
function canRunReferenceUI(analysis) {
    // UI de referÃªncia sÃ³ pode renderizar na segunda track
    if (!SOUNDY_MODE_ENGINE.isReferenceCompare()) {
        return false;
    }

    if (!analysis) {
        return false;
    }

    const hasRefComparison = !!analysis.referenceComparison;
    const hasRefJobId = !!analysis.referenceJobId || !!analysis.metadata?.referenceJobId;

    if (!hasRefComparison && !hasRefJobId) {
        return false;
    }

    return true;
}

// ğŸ¯ COMPARAÃ‡ÃƒO ENTRE FAIXAS - Armazenamento da primeira anÃ¡lise
window.lastReferenceJobId = null;
// âŒ REMOVER: window.referenceAnalysisData agora Ã© definido como getter read-only dinamicamente
// quando a primeira anÃ¡lise Ã© salva via FirstAnalysisStore.setOnce()

// ğŸ¯ COMPARAÃ‡ÃƒO ENTRE FAIXAS - MÃ©tricas de comparaÃ§Ã£o (substitui __activeRefData quando em modo reference)
let referenceComparisonMetrics = null;

// ğŸ¯ JOBS - Sistema de acompanhamento de jobs remotos
let currentJobId = null;
let jobPollingInterval = null;

// ğŸ¯ FunÃ§Ãµes de Acessibilidade e GestÃ£o de Modais

function openModeSelectionModal() {
    // ğŸ”“ MODO ANÃ”NIMO: Verificar limite de anÃ¡lises
    if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
        if (!window.SoundyAnonymous.interceptAnalysis()) {
            log('ğŸš« [ANALYZER] AnÃ¡lise bloqueada - limite anÃ´nimo atingido');
            return;
        }
    }
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        // Bloquear scroll do body
        document.body.classList.add('modal-open');
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no primeiro botÃ£o
        const firstButton = modal.querySelector('.mode-card button');
        if (firstButton) {
            firstButton.focus();
        }
        
        // Adicionar listener para ESC
        document.addEventListener('keydown', handleModalEscapeKey);
        
        // Trap focus no modal
        trapFocus(modal);
    }
}

function closeModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        
        // Desbloquear scroll do body
        document.body.classList.remove('modal-open');
        
        // Remover listeners
        document.removeEventListener('keydown', handleModalEscapeKey);
        
        // Retornar foco para o botÃ£o que abriu o modal
        const audioAnalysisBtn = document.querySelector('button[onclick="openAudioModal()"]');
        if (audioAnalysisBtn) {
            audioAnalysisBtn.focus();
        }
    }
}

function handleModalEscapeKey(e) {
    if (e.key === 'Escape') {
        closeModeSelectionModal();
    }
}

function trapFocus(modal) {
    const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const handleTabKey = (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
            } else if (!e.shiftKey && document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
            }
        }
    };
    
    modal.addEventListener('keydown', handleTabKey);
}

// ğŸ¯ FunÃ§Ã£o Principal de SeleÃ§Ã£o de Modo
async function selectAnalysisMode(mode) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ENTITLEMENT GATE: Bloquear MODO REFERÃŠNCIA para FREE/PLUS IMEDIATAMENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (mode === 'reference') {
        // ğŸ” CORREÃ‡ÃƒO CRÃTICA: Se cache nÃ£o estiver preenchido, buscar do Firestore primeiro
        let currentPlan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
        
        // Se plano Ã© 'free' mas usuÃ¡rio estÃ¡ autenticado, forÃ§ar refresh do Firestore
        if (currentPlan === 'free' && window.auth?.currentUser) {
            log('ğŸ” [ENTITLEMENT] Plano cache Ã© free, mas usuÃ¡rio autenticado. Verificando Firestore...');
            try {
                const freshPlan = await window.PlanCapabilities?.fetchUserPlan?.();
                if (freshPlan) {
                    currentPlan = freshPlan;
                    log(`ğŸ” [ENTITLEMENT] Plano atualizado do Firestore: ${currentPlan}`);
                }
            } catch (err) {
                warn('ğŸ” [ENTITLEMENT] Erro ao buscar plano do Firestore:', err);
            }
        }
        
        // ğŸ” REGRA CRÃTICA: PRO e DJ nunca sÃ£o bloqueados no modo referÃªncia
        const shouldBlock = currentPlan !== 'pro' && currentPlan !== 'dj';
        
        log(`ğŸ” [ENTITLEMENT] VerificaÃ§Ã£o de Modo ReferÃªncia: plan=${currentPlan}, shouldBlock=${shouldBlock}`);
        
        if (shouldBlock) {
            log('ğŸ” [ENTITLEMENT] Modo ReferÃªncia BLOQUEADO - plano nÃ£o permite');
            
            // Mostrar modal de upgrade IMEDIATAMENTE (sem abrir file picker)
            if (window.EntitlementsHandler?.showUpgradeModal) {
                window.EntitlementsHandler.showUpgradeModal('reference', currentPlan);
            } else {
                // Fallback se handler nÃ£o estiver carregado
                alert('O Modo ReferÃªncia estÃ¡ disponÃ­vel apenas no plano PRO. FaÃ§a upgrade para usar esta funcionalidade!');
            }
            
            // PARAR AQUI - nÃ£o mudar modo, nÃ£o abrir modal, nÃ£o fazer nada mais
            return;
        }
        
        log('ğŸ” [ENTITLEMENT] Modo ReferÃªncia PERMITIDO - plano PRO confirmado');
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ğŸ” PR1: InstrumentaÃ§Ã£o - SeleÃ§Ã£o de modo
    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
    const previousMode = window.currentAnalysisMode;
    
    if (window.logStep) {
        window.logStep(traceId, 'MODE_SELECTED', {
            selectedMode: mode,
            previousMode: previousMode,
            userClick: true,
        });
    }
    
    // ğŸ” PR1: Detectar mudanÃ§a de modo
    if (window.detectModeChange && previousMode) {
        window.detectModeChange(previousMode, mode);
    }
    
    log('ğŸ¯ Modo selecionado:', mode);
    
    // ğŸ” AUDIT: Dump ANTES de setar state machine
    if (window.debugDump) window.debugDump('BEFORE_SET_MODE', { mode, previousMode });
    
    // ğŸ†• PR2: USAR STATE MACHINE (com guard robusto)
    const stateMachine = window.AnalysisStateMachine;
    if (!stateMachine) {
        error('%c[CRITICAL] AnalysisStateMachine nÃ£o disponÃ­vel!', 'color:red;font-weight:bold;font-size:14px;');
        error('[CRITICAL] Isso impede o fluxo de referÃªncia. Script pode nÃ£o ter carregado.');
        error('[CRITICAL] Tentando continuar com fallback para currentAnalysisMode...');
        
        // Fallback: usar apenas currentAnalysisMode se state machine nÃ£o existir
        window.currentAnalysisMode = mode;
        
        if (mode === 'reference') {
            userExplicitlySelectedReferenceMode = true;
            log('[FALLBACK] Flag userExplicitlySelectedReferenceMode ativada manualmente');
        }
    } else {
        // State machine disponÃ­vel - usar normalmente
        const currentState = stateMachine.getState();
        const currentMode = stateMachine.getMode();
        
        log('[PR2] State machine ANTES de setMode:', { currentMode, currentState });
        
        // Atualizar state machine com modo selecionado
        stateMachine.setMode(mode, { userExplicitlySelected: true });
        
        const newState = stateMachine.getState();
        const newMode = stateMachine.getMode();
        
        log('[PR2] State machine DEPOIS de setMode:', { newMode, newState });
        
        // ğŸ”’ VERIFICAR se setMode funcionou
        if (newMode !== mode) {
            error('%c[CRITICAL] setMode falhou! Esperado:', mode, 'Obtido:', newMode, 'color:red;font-weight:bold;');
            alert('Erro ao configurar modo de anÃ¡lise. Por favor, recarregue a pÃ¡gina.');
            return;
        }
        
        log('%c[PR2] âœ… State machine configurado com sucesso para:', mode, 'color:green;font-weight:bold;');
    }
    
    // ğŸ” AUDIT: Dump DEPOIS de setar state machine
    if (window.debugDump) window.debugDump('AFTER_SET_MODE', { mode, stateMachineState: stateMachine?.getState() });
    
    // ========================================
    // ğŸ”¥ BARREIRA 4: LIMPEZA AO SELECIONAR MODO GÃŠNERO
    // ========================================
    if (mode === 'genre') {
        // ğŸ” PR1: Log reset start
        if (window.logStep) {
            window.logStep(traceId, 'RESET_START', {
                reason: 'genre_mode_selected',
                willResetReferenceState: true,
            });
        }
        log('%c[GENRE-BARRIER] ğŸš§ BARREIRA 4 ATIVADA: Modo gÃªnero selecionado', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
        
        // ğŸ”¥ EXECUTAR LIMPEZA COMPLETA do estado de referÃªncia
        resetReferenceStateFully();
        
        // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Resetar flag de seleÃ§Ã£o explÃ­cita (legacy - state machine Ã© fonte de verdade)
        persistReferenceFlag(false);
        log('%c[PROTECTION] âœ… Flag userExplicitlySelectedReferenceMode resetada para false', 'color:#00FF88;font-weight:bold;');
        
        log('%c[GENRE-BARRIER] âœ… BARREIRA 4 CONCLUÃDA: Estado limpo ao selecionar gÃªnero', 'color:#00FF88;font-weight:bold;');
        
        // ğŸ” PR1: Log reset end
        if (window.logStep) {
            window.logStep(traceId, 'RESET_END', {
                userExplicitlySelectedReferenceMode: false,
                referenceStateCleared: true,
            });
        }
    }
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Definir flag quando usuÃ¡rio seleciona modo reference EXPLICITAMENTE (legacy)
    if (mode === 'reference') {
        persistReferenceFlag(true);
        log('%c[PROTECTION] âœ… Flag userExplicitlySelectedReferenceMode ATIVADA - usuÃ¡rio clicou em modo A/B', 'color:#FFD700;font-weight:bold;font-size:14px;');
        log('[REF_FIX] ğŸ¯ Modo Reference selecionado pelo usuÃ¡rio - estado serÃ¡ preservado');
        
        // ğŸ” PR1: Assert invariante
        if (window.assertInvariant) {
            window.assertInvariant(
                'REFERENCE_MODE_EXPLICIT_FLAG',
                userExplicitlySelectedReferenceMode === true,
                { mode: 'reference', flagValue: userExplicitlySelectedReferenceMode }
            );
        }
    }
    
    // Armazenar modo selecionado (legacy - state machine Ã© fonte de verdade)
    window.currentAnalysisMode = mode;
    
    // ğŸ” PR1: Validar consistÃªncia
    if (window.validateModeConsistency) {
        const validation = window.validateModeConsistency(mode);
        if (!validation.consistent) {
            warn('[MODE_INCONSISTENCY]', validation);
        }
    }
    
    // Fechar modal de seleÃ§Ã£o
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // ğŸ†• STREAMING MODE: Abrir modal de destino ANTES do modal de gÃªnero
        openSoundDestinationModal((destinationMode) => {
            log('[SELECT-MODE] Destino escolhido:', destinationMode);
            // Modo tradicional - abrir modal de anÃ¡lise normal
            openAnalysisModalForMode('genre');
        });
    } else if (mode === 'reference') {
        // Modo referÃªncia - abrir interface especÃ­fica (sem modal de destino)
        // Reference mode sempre usa targets da referÃªncia, nÃ£o precisa de Pista/Streaming
        setSoundDestinationMode('pista'); // Reset para default
        openAnalysisModalForMode('reference');
    }
}

// ğŸ¯ Modal de AnÃ¡lise por ReferÃªncia
function openReferenceAnalysisModal() {
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        // Configurar modal para modo referÃªncia
        const modalContent = modal.querySelector('.modal-content');
        const title = modalContent.querySelector('h2');
        const steps = document.getElementById('referenceProgressSteps');
        
        if (title) {
            title.textContent = 'ğŸµ AnÃ¡lise por MÃºsica de ReferÃªncia';
        }
        
        // Mostrar passos do progresso
        if (steps) {
            steps.style.display = 'block';
            updateProgressStep(1); // Primeiro passo ativo
        }
        
        // Modificar texto do botÃ£o de upload
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn) {
            uploadBtn.textContent = 'ğŸ“¤ Upload da MÃºsica Original';
            uploadBtn.onclick = () => handleReferenceFileSelection('original');
        }
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no botÃ£o de upload
        if (uploadBtn) {
            uploadBtn.focus();
        }
    }
}

// ğŸ¯ GestÃ£o de Progresso para Modo ReferÃªncia
function updateProgressStep(step) {
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((stepEl, index) => {
        const stepNumber = index + 1;
        stepEl.classList.remove('active', 'completed');
        
        if (stepNumber < step) {
            stepEl.classList.add('completed');
        } else if (stepNumber === step) {
            stepEl.classList.add('active');
        }
    });
}

// ï¿½ SISTEMA DE UPLOAD E ANÃLISE REMOTA
// âœ… FLUXO OFICIAL: Presigned URL â†’ Upload â†’ Job Creation â†’ Status Polling

// ï¿½ğŸ¯ SeleÃ§Ã£o de Arquivos para Modo ReferÃªncia (fileKeys apenas)
let uploadedFiles = {
    original: null,
    reference: null
};

/**
 * âœ… OBTER URL PRÃ‰-ASSINADA DO BACKEND
/**
 * Obter URL prÃ©-assinada do backend
/**
 * ğŸš€ OBTER URL PRÃ‰-ASSINADA DO BACKEND
 * @param {File} file - Arquivo para upload
 * @returns {Promise<{uploadUrl: string, fileKey: string}>}
 */
async function getPresignedUrl(file) {
  try {
    // Extrair extensÃ£o do arquivo
    const ext = file.name.split('.').pop().toLowerCase();

    __dbg('ğŸŒ Solicitando URL prÃ©-assinada...', {
      filename: file.name,
      ext,
           size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
    });

    // âœ… Agora manda "ext" 
    const response = await fetch(`/api/presign?ext=${encodeURIComponent(ext)}`, {
  method: "GET",
  headers: {
    "Accept": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao obter URL de upload: ${response.status} - ${errorText}`);
    }

    const data = await response.json();

    if (!data.uploadUrl || !data.fileKey) {
      throw new Error('Resposta invÃ¡lida do servidor: uploadUrl ou fileKey ausente');
    }

    return {
      uploadUrl: data.uploadUrl,
      fileKey: data.fileKey
    };
  } catch (error) {
    error('âŒ Erro ao obter URL prÃ©-assinada:', error);
    throw new Error(`Falha ao gerar URL de upload: ${error.message}`);
  }
}



/**
 * âœ… UPLOAD DIRETO PARA BUCKET VIA URL PRÃ‰-ASSINADA
 * @param {string} uploadUrl - URL prÃ©-assinada para upload
 * @param {File} file - Arquivo para upload
 * @returns {Promise<void>}
 */
async function uploadToBucket(uploadUrl, file) {
  try {
    __dbg('ğŸ“¤ Iniciando upload para bucket...', { 
      filename: file.name,
      size: `${(file.size / 1024 / 1024).toFixed(2)}MB`,
      url: uploadUrl.substring(0, 50) + '...'
    });

    showUploadProgress(`Enviando ${file.name} para anÃ¡lise...`);

    // ğŸ‘‡ sem headers, sÃ³ body = file
   const response = await fetch(uploadUrl, {
  method: "PUT",
  body: file
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
    }

    __dbg('âœ… Upload para bucket concluÃ­do com sucesso');
    showUploadProgress(`Upload concluÃ­do! Processando ${file.name}...`);

  } catch (error) {
    error('âŒ Erro no upload para bucket:', error);
    throw new Error(`Falha ao enviar arquivo para anÃ¡lise: ${error.message}`);
  }
}


/**
 * ğŸ†• PR2: CONSTRUIR PAYLOAD PARA MODO GENRE
 * @param {string} fileKey
 * @param {string} fileName
 * @param {string} idToken
 * @returns {Object} payload para mode=genre
 */
function buildGenrePayload(fileKey, fileName, idToken) {
    log('[PR2] buildGenrePayload()');
    
    // Obter gÃªnero selecionado
    let genre = window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE;
    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (!genre || typeof genre !== "string" || genre.trim() === "") {
        genre = genreSelect?.value || "default";
    }
    genre = genre.trim();
    
    // Obter targets do gÃªnero
    let genreTargets = null;
    const previousAnalysis = window.currentAnalysisData || window.__soundyState?.previousAnalysis;
    if (previousAnalysis) {
        log('[PR2] Extraindo targets da anÃ¡lise anterior');
        genreTargets = extractGenreTargetsFromAnalysis(previousAnalysis);
    }
    if (!genreTargets) {
        log('[PR2] FALLBACK: targets das variÃ¡veis globais');
        genreTargets = window.__CURRENT_GENRE_TARGETS || window.currentGenreTargets || window.__activeRefData?.targets;
    }
    
    // ValidaÃ§Ã£o obrigatÃ³ria
    if (!genre) {
        throw new Error('[PR2] buildGenrePayload: genre Ã© obrigatÃ³rio');
    }
    if (!genreTargets || Object.keys(genreTargets).length === 0) {
        warn('[PR2] buildGenrePayload: genreTargets ausentes ou vazios');
    }
    
    // ğŸ†• STREAMING MODE: Obter destino do som (pista/streaming)
    const soundDestination = getSoundDestinationMode();
    log('[PR2] soundDestination:', soundDestination);
    
    const payload = {
        fileKey,
        mode: 'genre',  // Mantido por compatibilidade
        analysisType: 'genre',  // ğŸ†• Campo explÃ­cito sem ambiguidade
        soundDestination,  // ğŸ†• 'pista' | 'streaming' - NUNCA undefined
        fileName,
        genre,
        genreTargets,
        hasTargets: !!genreTargets,
        idToken
    };
    
    log('[PR2] Genre payload:', {
        mode: payload.mode,
        analysisType: payload.analysisType,
        soundDestination: payload.soundDestination,
        genre: payload.genre,
        hasTargets: payload.hasTargets,
        targetKeys: genreTargets ? Object.keys(genreTargets).length : 0
    });
    
    return payload;
}

/**
 * ğŸ†• PR2: CONSTRUIR PAYLOAD PARA MODO REFERENCE
 * @param {string} fileKey
 * @param {string} fileName
 * @param {string} idToken
 * @param {Object} options
 * @param {boolean} options.isFirstTrack - Se Ã© primeira ou segunda track
 * @param {string|null} options.referenceJobId - Job ID da primeira track (null na primeira)
 * @returns {Object} payload para mode=reference
 */
function buildReferencePayload(fileKey, fileName, idToken, options = {}) {
    const { isFirstTrack = true, referenceJobId = null } = options;
    
    log('[REF-PAYLOAD] buildReferencePayload()', { isFirstTrack, referenceJobId });
    
    // ğŸ¯ PATCH CRÃTICO D: Garantir genre=null em TODAS chamadas
    if (isFirstTrack) {
        // âœ… PRIMEIRA TRACK: payload LIMPO sem genre/targets
        log('[REF-PAYLOAD] Reference primeira track - SEM genre/targets (base pura)');
        
        const payload = {
            fileKey,
            mode: 'reference',
            analysisType: 'reference',
            referenceStage: 'base',
            fileName,
            isReferenceBase: true,
            referenceJobId: null,
            genre: null, // ğŸ¯ PATCH D: ExplÃ­cito
            genreTargets: null, // ğŸ¯ PATCH D: ExplÃ­cito
            idToken
        };
        
        log('[REF-PAYLOAD] âœ… Reference primeira track (BASE) payload:', {
            mode: payload.mode,
            referenceStage: payload.referenceStage,
            hasGenre: payload.genre !== null,
            hasTargets: payload.genreTargets !== null,
            isReferenceBase: payload.isReferenceBase,
            referenceJobId: payload.referenceJobId
        });
        
        // ğŸ”’ SANITY CHECK: Garantir que NÃƒO tem genre/genreTargets
        if (payload.genre || payload.genreTargets) {
            error('[REF-PAYLOAD] SANITY_FAIL: Reference primeira track NÃƒO deve ter genre/targets!', payload);
            throw new Error('[REF-PAYLOAD] Reference primeira track (base) NÃƒO deve ter genre/genreTargets');
        }
        
        return payload;
    } else {
        // âœ… SEGUNDA TRACK: payload LIMPO (sem genre/targets) com referenceJobId para comparaÃ§Ã£o
        if (!referenceJobId) {
            throw new Error('[REF-PAYLOAD] buildReferencePayload: segunda track requer referenceJobId');
        }
        
        const payload = {
            fileKey,
            mode: 'reference',       // Mantido por compatibilidade
            analysisType: 'reference',  // ğŸ†• Campo explÃ­cito
            referenceStage: 'compare',  // ğŸ†• Indica segunda mÃºsica (comparaÃ§Ã£o)
            fileName,
            referenceJobId,          // JobId da primeira mÃºsica (BASE) - obrigatÃ³rio
            isReferenceBase: false,  // Flag legada mantida
            genre: null, // ğŸ¯ PATCH D: ExplÃ­cito
            genreTargets: null, // ğŸ¯ PATCH D: ExplÃ­cito
            idToken
        };
        
        log('[REF-PAYLOAD] âœ… Reference segunda track (COMPARAÃ‡ÃƒO) payload:', {
            mode: payload.mode,
            referenceJobId: payload.referenceJobId,
            hasGenre: payload.genre !== null, // âœ… Segunda track NÃƒO inclui genre
            hasTargets: payload.genreTargets !== null, // âœ… Segunda track NÃƒO inclui genreTargets
            isReferenceBase: payload.isReferenceBase
        });
        
        // ğŸ”’ SANITY CHECK: Garantir que NÃƒO tem genre/genreTargets
        if (payload.genre || payload.genreTargets) {
            error('[REF-PAYLOAD] SANITY_FAIL: Reference segunda track tem genre/targets!', payload);
            throw new Error('[REF-PAYLOAD] Reference segunda track NÃƒO deve ter genre/genreTargets');
        }
        
        return payload;
    }
}

/**
 * âœ… CRIAR JOB DE ANÃLISE NO BACKEND
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} mode - Modo de anÃ¡lise ('genre' ou 'reference')
 * @param {string} fileName - Nome original do arquivo
 * @returns {Promise<{jobId: string, success: boolean}>}
 */
async function createAnalysisJob(fileKey, mode, fileName) {
    try {
        __dbg('ğŸ”§ Criando job de anÃ¡lise...', { fileKey, mode, fileName });

        // ğŸ¯ SISTEMA DE MODOS DE ACESSO
        // Usar funÃ§Ã£o global getAccessMode() para determinar rota correta
        const accessMode = typeof window.getAccessMode === 'function' 
            ? window.getAccessMode() 
            : (window.SoundyAnonymous?.isAnonymousMode ? 'anonymous' : 'logged');
        
        // Obter visitorId do modo ativo (Demo ou Anonymous)
        const visitorId = window.SoundyDemo?.visitorId || window.SoundyAnonymous?.visitorId;
        
        log('ğŸ¯ [ACCESS-MODE] Modo detectado:', accessMode, { hasVisitorId: !!visitorId });
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”¥ MODO DEMO: Usa rota anÃ´nima (1 anÃ¡lise permitida)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (accessMode === 'demo') {
            log('ğŸ”¥ [DEMO] Modo demo ativo - usando rota anÃ´nima para 1 anÃ¡lise');
            
            // Demo sÃ³ permite modo genre (reference requer conta)
            if (mode === 'reference') {
                warn('âš ï¸ [DEMO] Modo reference nÃ£o disponÃ­vel no demo');
                window.SoundyDemo.showConversionModal('reference');
                throw new Error('Modo de referÃªncia requer conta. Crie uma conta para continuar.');
            }
            
            const demoVisitorId = window.SoundyDemo?.visitorId;
            if (!demoVisitorId) {
                error('âŒ [DEMO] visitorId nÃ£o disponÃ­vel');
                throw new Error('IdentificaÃ§Ã£o do demo nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');
            }
            
            // ğŸ›¡ï¸ Obter fingerprint forte do dispositivo
            let deviceFingerprint = null;
            let hardwareSummary = null;
            if (window.SoundyFingerprint) {
                try {
                    const fpData = await window.SoundyFingerprint.get();
                    deviceFingerprint = fpData.fingerprint_hash;
                    hardwareSummary = fpData.hardware_summary;
                    log('ğŸ” [DEMO] Fingerprint forte obtido:', deviceFingerprint?.substring(0, 16) + '...');
                } catch (e) {
                    warn('âš ï¸ [DEMO] Erro ao obter fingerprint forte:', e.message);
                }
            }
            
            // Usar mesma lÃ³gica do Anonymous, mas com visitorId do Demo
            const genreSelect = document.getElementById('audioRefGenreSelect');
            let demoGenre = window.__CURRENT_SELECTED_GENRE || 
                            window.PROD_AI_REF_GENRE || 
                            genreSelect?.value;
            
            if (!demoGenre || typeof demoGenre !== 'string' || demoGenre.trim() === '') {
                throw new Error('Por favor, selecione um gÃªnero antes de analisar.');
            }
            
            demoGenre = demoGenre.trim();
            
            const demoTargets = window.__CURRENT_GENRE_TARGETS || 
                                window.currentGenreTargets || 
                                window.__activeRefData?.targets;
            
            log('[DEMO] ğŸµ GÃªnero capturado:', demoGenre);
            
            const demoPayload = {
                fileKey,
                fileName,
                genre: demoGenre,
                genreTargets: demoTargets,
                visitorId: demoVisitorId,
                soundDestination: window.selectedSoundDestination || 'pista',
                analysisMode: 'genre',
                isDemo: true,
                // ğŸ›¡ï¸ Fingerprint forte para bloqueio definitivo
                fingerprintHash: deviceFingerprint,
                hardwareSummary: hardwareSummary
            };
            
            log('[DEMO] Payload para anÃ¡lise:', demoPayload);
            
            // Usar mesma rota anÃ´nima
            const response = await fetch('/api/audio/analyze-anonymous', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(demoPayload)
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                // ğŸ”¥ Verificar se backend sinaliza para mostrar modal de conversÃ£o
                if (data.showConversionModal || data.checkoutRequired || 
                    data.requiresLogin || data.error === 'ANON_ANALYSIS_LIMIT_REACHED' ||
                    data.error === 'DEMO_LIMIT_REACHED') {
                    log('ğŸš« [DEMO] Limite de anÃ¡lise atingido - mostrando modal de upgrade');
                    window.SoundyDemo.showConversionModal('analysis_limit');
                    // NÃƒO throw error - deixar modal de upgrade ser exibido sem modal de erro
                    return { blocked: true, showConversion: true };
                }
                throw new Error(data.message || `Erro ao criar job: ${response.status}`);
            }
            
            log('[DEMO] âœ… Job demo criado:', data.jobId);
            
            return {
                jobId: data.jobId,
                success: true,
                demo: true
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”“ MODO ANÃ”NIMO: Usar rota /analyze-anonymous (SEM AUTH)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (accessMode === 'anonymous') {
            log('ğŸ”“ [ANONYMOUS] Modo anÃ´nimo ativo - usando rota anÃ´nima');
            
            // AnÃ´nimos sÃ³ podem usar modo genre (reference requer conta)
            if (mode === 'reference') {
                warn('âš ï¸ [ANONYMOUS] Modo reference nÃ£o disponÃ­vel para anÃ´nimos');
                window.SoundyAnonymous.showLoginModal('reference');
                throw new Error('Modo de referÃªncia requer conta. Crie uma conta grÃ¡tis para continuar.');
            }
            
            if (!visitorId) {
                error('âŒ [ANONYMOUS] visitorId nÃ£o disponÃ­vel');
                throw new Error('IdentificaÃ§Ã£o de visitante nÃ£o disponÃ­vel. Recarregue a pÃ¡gina.');
            }
            
            // ï¿½ï¸ Obter fingerprint forte do dispositivo
            let deviceFingerprint = null;
            let hardwareSummary = null;
            if (window.SoundyFingerprint) {
                try {
                    const fpData = await window.SoundyFingerprint.get();
                    deviceFingerprint = fpData.fingerprint_hash;
                    hardwareSummary = fpData.hardware_summary;
                    log('ğŸ” [ANONYMOUS] Fingerprint forte obtido:', deviceFingerprint?.substring(0, 16) + '...');
                } catch (e) {
                    warn('âš ï¸ [ANONYMOUS] Erro ao obter fingerprint forte:', e.message);
                }
            }
            
            // ğŸ”§ FIX BUG 2: Obter gÃªnero corretamente (mesmo padrÃ£o do modo autenticado)
            const genreSelect = document.getElementById('audioRefGenreSelect');
            let anonymousGenre = window.__CURRENT_SELECTED_GENRE || 
                                 window.PROD_AI_REF_GENRE || 
                                 genreSelect?.value;
            
            // ValidaÃ§Ã£o obrigatÃ³ria de gÃªnero
            if (!anonymousGenre || typeof anonymousGenre !== 'string' || anonymousGenre.trim() === '') {
                error('âŒ [ANONYMOUS] GÃªnero nÃ£o selecionado!');
                error('   window.__CURRENT_SELECTED_GENRE:', window.__CURRENT_SELECTED_GENRE);
                error('   window.PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
                error('   genreSelect?.value:', genreSelect?.value);
                throw new Error('Por favor, selecione um gÃªnero antes de analisar.');
            }
            
            anonymousGenre = anonymousGenre.trim();
            
            // Obter targets do gÃªnero
            let anonymousTargets = window.__CURRENT_GENRE_TARGETS || 
                                   window.currentGenreTargets || 
                                   window.__activeRefData?.targets;
            
            log('[ANONYMOUS] ğŸµ GÃªnero capturado:', anonymousGenre);
            log('[ANONYMOUS] ğŸ¯ Targets capturados:', anonymousTargets ? 'SIM' : 'NÃƒO');
            
            // Construir payload anÃ´nimo com fingerprint forte
            const anonymousPayload = {
                fileKey,
                fileName,
                genre: anonymousGenre,
                genreTargets: anonymousTargets,
                visitorId,
                soundDestination: window.selectedSoundDestination || 'pista',
                // Metadados para debug
                analysisMode: 'genre',
                isAnonymous: true,
                // ğŸ›¡ï¸ Fingerprint forte para bloqueio definitivo
                fingerprintHash: deviceFingerprint,
                hardwareSummary: hardwareSummary
            };
            
            log('[ANONYMOUS] Payload para anÃ¡lise anÃ´nima:', anonymousPayload);
            
            // Usar rota anÃ´nima
            const response = await fetch('/api/audio/analyze-anonymous', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(anonymousPayload)
            });
            
            const data = await response.json();
            
            // Tratar limite atingido
            if (!response.ok) {
                if (data.requiresLogin || data.error === 'ANON_ANALYSIS_LIMIT_REACHED') {
                    log('ğŸš« [ANONYMOUS] Limite de anÃ¡lises atingido');
                    window.SoundyAnonymous.showLoginModal('analysis');
                    throw new Error(data.message || 'Limite de anÃ¡lises atingido. Crie uma conta grÃ¡tis para continuar.');
                }
                throw new Error(data.message || `Erro ao criar job: ${response.status}`);
            }
            
            log('[ANONYMOUS] âœ… Job anÃ´nimo criado:', data.jobId);
            
            // Atualizar contador local
            if (data.limits) {
                log(`ğŸ“Š [ANONYMOUS] AnÃ¡lises: ${data.limits.used}/${data.limits.limit}`);
            }
            
            return {
                jobId: data.jobId,
                success: true,
                anonymous: true
            };
        }

        // âœ… MODO AUTENTICADO: Obter Firebase ID Token ANTES de fazer o fetch
        log('ğŸ” Obtendo Firebase ID Token...');
        
        // Aguardar Firebase estar pronto
        if (typeof waitForFirebase === 'function') {
            await waitForFirebase();
        }
        
        // Tentar obter token (prioridade: currentUser > localStorage)
        let idToken = null;
        
        // Prioridade 1: Obter do currentUser
        const currentUser = window.auth?.currentUser;
        if (currentUser) {
            try {
                idToken = await currentUser.getIdToken();
                log('âœ… Token obtido do currentUser');
            } catch (err) {
                warn('âš ï¸ Erro ao obter token do currentUser:', err.message);
            }
        }
        
        // Prioridade 2: Fallback para localStorage
        if (!idToken) {
            idToken = localStorage.getItem('authToken') || localStorage.getItem('idToken');
            if (idToken) {
                log('âœ… Token obtido do localStorage (fallback)');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸš¨ FALLBACK: Se nÃ£o hÃ¡ token, tentar ativar modo anÃ´nimo
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!idToken) {
            warn('âš ï¸ [FALLBACK] Token nÃ£o encontrado, verificando se pode usar modo anÃ´nimo...');
            
            // Verificar se SoundyAnonymous estÃ¡ disponÃ­vel e habilitado
            if (window.SoundyAnonymous && window.SoundyAnonymous.isEnabled) {
                // Se ainda nÃ£o foi ativado, ativar agora
                if (!window.SoundyAnonymous.isAnonymousMode) {
                    log('ğŸ”„ [FALLBACK] Tentando ativar modo anÃ´nimo automaticamente...');
                    await window.SoundyAnonymous.activate();
                }
                
                // Verificar se ativou com sucesso
                if (window.SoundyAnonymous.isAnonymousMode && window.SoundyAnonymous.visitorId) {
                    log('âœ… [FALLBACK] Modo anÃ´nimo ativado! Redirecionando para rota anÃ´nima...');
                    
                    // Recursivamente chamar createAnalysisJob que agora irÃ¡ detectar modo anÃ´nimo
                    return createAnalysisJob(fileKey, mode, fileName);
                }
            }
            
            error('[CRITICAL] ID Token ausente e modo anÃ´nimo nÃ£o disponÃ­vel.');
            error('âŒ UsuÃ¡rio nÃ£o autenticado - nÃ£o Ã© possÃ­vel criar job');
            throw new Error('VocÃª precisa estar logado para analisar Ã¡udio.');
        }
        
        log('âœ… Token vÃ¡lido disponÃ­vel para envio');

        // ğŸ†• PR2: USAR STATE MACHINE como fonte de verdade
        const stateMachine = window.AnalysisStateMachine;
        if (!stateMachine) {
            error('%c[CRITICAL] AnalysisStateMachine nÃ£o disponÃ­vel em createAnalysisJob!', 'color:red;font-weight:bold;font-size:14px;');
            error('[CRITICAL] Modo solicitado:', mode);
            error('[CRITICAL] currentAnalysisMode:', window.currentAnalysisMode);
            
            // Se nÃ£o tem state machine MAS o mode Ã© reference, tentar continuar com fallback
            if (mode === 'reference') {
                warn('[FALLBACK] Tentando continuar reference sem state machine...');
                warn('[FALLBACK] Usando window.currentAnalysisMode e flags globais');
                
                // Criar payload manualmente sem state machine
                if (window.userExplicitlySelectedReferenceMode) {
                    // Determinar se Ã© primeira ou segunda track pelas flags globais
                    const hasFirstJobId = window.__REFERENCE_JOB_ID__ || window.lastReferenceJobId;
                    
                    payload = buildReferencePayload(fileKey, fileName, idToken, {
                        isFirstTrack: !hasFirstJobId,
                        referenceJobId: hasFirstJobId || null
                    });
                    
                    log('[FALLBACK] Payload reference criado:', payload);
                } else {
                    throw new Error('[CRITICAL] State machine ausente E userExplicitlySelectedReferenceMode=false. NÃ£o Ã© possÃ­vel processar reference.');
                }
            } else {
                // Modo genre nÃ£o precisa de state machine
                payload = buildGenrePayload(fileKey, fileName, idToken);
            }
        } else {
            // State machine disponÃ­vel - fluxo normal
            const currentState = stateMachine.getState();
            const currentSMMode = stateMachine.getMode();
            
            log('[PR2] Estado atual da mÃ¡quina:', { mode: currentSMMode, state: currentState });
            
            // ğŸ”’ VERIFICAÃ‡ÃƒO CRÃTICA: se mode Ã© reference, state machine DEVE estar em reference
            if (mode === 'reference' && currentSMMode !== 'reference') {
                error('%c[CRITICAL] INCONSISTÃŠNCIA DETECTADA!', 'color:red;font-weight:bold;font-size:16px;');
                error('[STATE] ParÃ¢metro mode:', mode);
                error('[STATE] stateMachine.getMode():', currentSMMode);
                error('[STATE] currentAnalysisMode:', window.currentAnalysisMode);
                error('[STATE] State completo:', currentState);
                
                warn('[FIX_ATTEMPT] Tentando corrigir state machine...');
                try {
                    stateMachine.setMode('reference', { userExplicitlySelected: true });
                    const fixedMode = stateMachine.getMode();
                    log('[FIX_RESULT] Novo mode:', fixedMode);
                    
                    if (fixedMode !== 'reference') {
                        throw new Error(`setMode falhou: ainda estÃ¡ em '${fixedMode}'`);
                    }
                    
                    log('%c[FIX_SUCCESS] State machine corrigido para reference', 'color:green;font-weight:bold;');
                } catch (fixError) {
                    error('[FIX_FAILED] NÃ£o foi possÃ­vel corrigir:', fixError);
                    throw new Error(`[INVARIANTE] State machine estÃ¡ em '${currentSMMode}' mas mode param Ã© '${mode}'. CorreÃ§Ã£o falhou: ${fixError.message}`);
                }
            }
            
            // Agora sim, continuar com o fluxo normal baseado no modo
            if (mode === 'genre') {
                log('[PR2] Usando buildGenrePayload');
                payload = buildGenrePayload(fileKey, fileName, idToken);
                
            } else if (mode === 'reference') {
                // MODO REFERENCE: usar ReferenceFlowController
                const refFlow = window.referenceFlow;
                if (!refFlow) {
                    throw new Error('[REF-FLOW] ReferenceFlowController nÃ£o disponÃ­vel');
                }
                
                const isFirstTrack = refFlow.isFirstTrack() || !refFlow.isAwaitingSecond();
                const referenceJobId = refFlow.getBaseJobId();
                
                log('[REF-FLOW] Usando buildReferencePayload', { isFirstTrack, referenceJobId });
            
            if (isFirstTrack) {
                // Primeira track: iniciar fluxo
                log('[REF-FLOW] onFirstTrackSelected() chamado');
                refFlow.onFirstTrackSelected();
                
                payload = buildReferencePayload(fileKey, fileName, idToken, {
                    isFirstTrack: true,
                    referenceJobId: null
                });
                
                // ğŸ”’ BIND: Marcar payload para binding posterior
                payload._pendingBinding = { track: 'base', baseJobId: null, referenceJobId: null };
            } else {
                // Segunda track: comparar
                if (!referenceJobId) {
                    throw new Error('[REF-FLOW] Segunda track requer baseJobId');
                }
                
                log('[REF-FLOW] onSecondTrackSelected() chamado');
                refFlow.onSecondTrackSelected();
                
                payload = buildReferencePayload(fileKey, fileName, idToken, {
                    isFirstTrack: false,
                    referenceJobId
                });
                
                // ğŸ”’ BIND: Marcar payload para binding posterior
                payload._pendingBinding = { track: 'compare', baseJobId: referenceJobId, referenceJobId };
            }
            
            } else {
                throw new Error(`[PR2] Modo invÃ¡lido: ${mode}`);
            }
        }
        
        // ğŸ” PR1: Trace ID para rastreamento
        const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
        if (window.logStep) {
            window.logStep(traceId, 'PAYLOAD_BUILD_END', {
                mode: payload.mode,
                isReferenceBase: payload.isReferenceBase || false,
                referenceJobId: payload.referenceJobId || null,
            });
        }
        
        // ğŸ” PR1: Log payload final (mascarado)
        if (window.logStep && window.maskSensitiveData) {
            const maskedPayload = window.maskSensitiveData(payload);
            window.logStep(traceId, 'PAYLOAD_BUILD_END', {
                payload: maskedPayload,
            });
        }
        
        // ğŸ” PR1: Sanity check do payload
        if (window.logStep) {
            const uiMode = window.currentAnalysisMode;
            const payloadMode = payload.mode;
            
            window.logStep(traceId, 'PAYLOAD_SANITY_CHECK', {
                uiMode,
                payloadMode,
                match: uiMode === payloadMode || (uiMode === 'reference' && payloadMode === 'genre' && payload.isReferenceBase),
                hasGenreInPayload: !!payload.genre,
                hasTargetsInPayload: !!payload.genreTargets,
                referenceJobIdPresent: !!payload.referenceJobId,
                isReferenceBase: payload.isReferenceBase || false,
            });
            
            // ğŸ†• PR2: VALIDAÃ‡ÃƒO RÃGIDA - Se mode=reference (segunda track), NÃƒO pode ter genre/targets
            if (payload.mode === 'reference' && payload.referenceJobId) {
                if (payload.genre || payload.genreTargets) {
                    error('%c[PR2-SANITY-FAIL]', 'color:#FF0000;font-weight:bold;', {
                        message: 'REFERENCE mode segunda track TEM genre/genreTargets!',
                        payload,
                        traceId,
                        stack: new Error().stack,
                    });
                    throw new Error('[PR2] SANITY FAIL: Reference segunda track nÃ£o pode ter genre/genreTargets');
                }
            }
        }
        
        log('[PR2] Payload final:', payload);
        
        // ï¿½ VALIDAÃ‡ÃƒO CRÃTICA: Verificar se AuthGate permite chamada autenticada
        if (window.AuthGate && window.AuthGate.shouldBlockAuthenticatedCall('/api/audio/analyze')) {
            error('ğŸš« [CREATEJOB] Tentativa de chamada autenticada bloqueada pelo AuthGate');
            error('   Estado:', {
                isAnonymousMode: window.SoundyAnonymous?.isAnonymousMode,
                forceCleanState: window.SoundyAnonymous?.forceCleanState,
                hasCurrentUser: !!window.auth?.currentUser
            });
            throw new Error('SessÃ£o invÃ¡lida. Por favor, faÃ§a login novamente ou use o modo anÃ´nimo.');
        }
        
        // ï¿½ğŸ” PR1: Log antes do request
        if (window.logStep && window.maskSensitiveData) {
            window.logStep(traceId, 'REQUEST_SENT', {
                endpoint: '/api/audio/analyze',
                payload: window.maskSensitiveData(payload),
            });
        }

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${idToken}`, // âœ… CORREÃ‡ÃƒO CRÃTICA: Token adicionado
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            
            // ğŸ¯ V2: Preservar JSON estruturado para ErrorMapper com SCOPE
            let structuredError = null;
            try {
                structuredError = JSON.parse(errorText);
                log('[ANALYZE] Erro estruturado do backend:', structuredError);
            } catch (e) {
                // NÃ£o Ã© JSON vÃ¡lido, usar texto
                warn('[ANALYZE] Erro nÃ£o Ã© JSON:', errorText);
            }
            
            // Se temos erro estruturado, criar Error com dados preservados
            if (structuredError && (structuredError.code || structuredError.error)) {
                const err = new Error(structuredError.message || `Erro ${response.status}`);
                err.structuredData = structuredError; // ğŸ”‘ Preservar dados para showModalError
                err.httpStatus = response.status;
                throw err;
            }
            
            throw new Error(`Erro ao criar job: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        log("[ANALYZE-RESPONSE]", data);

        // ğŸ”’ CAPTURA ROBUSTA: MÃºltiplas tentativas de obter jobId
        const newJobId =
            data.jobId ||
            data.id ||
            data.job?.id;

        if (!newJobId) {
            error("[ANALYZE] âŒ Nenhum jobId retornado pelo backend!", data);
            throw new Error('Resposta invÃ¡lida do servidor: jobId ausente');
        }

        __dbg('âœ… Job de anÃ¡lise criado:', { 
            jobId: newJobId,
            mode: data.mode,
            fileKey: data.fileKey
        });

        // ğŸ”’ BIND: Registrar binding se payload tinha _pendingBinding
        if (payload._pendingBinding && window.referenceFlow) {
            window.referenceFlow.bindJob(newJobId, payload._pendingBinding);
            log('[REF-BIND] Job bound apÃ³s POST:', newJobId, payload._pendingBinding);
        }

        return {
            jobId: newJobId,
            success: true
        };

    } catch (error) {
        error('âŒ Erro ao criar job de anÃ¡lise:', error);
        throw new Error(`Falha ao criar job de anÃ¡lise: ${error.message}`);
    }
}

/**
 * âœ… ACOMPANHAR STATUS DO JOB DE ANÃLISE
 * @param {string} jobId - ID do job
 * @returns {Promise<Object>} - Resultado da anÃ¡lise quando completa
 */
async function pollJobStatus(jobId) {
    // ğŸ”’ BLINDAGEM: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== "string") {
        error("[POLLING] âŒ jobId invÃ¡lido ou undefined:", jobId);
        return Promise.reject(new Error("Job ID invÃ¡lido - polling abortado"));
    }

    log("[POLLING] âœ… Iniciando com jobId vÃ¡lido:", jobId);

    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 60; // 5 minutos mÃ¡ximo (5s * 60 = 300s)
        let initialQueuePosition = null;
        
        const poll = async () => {
            try {
                attempts++;
                __dbg(`ğŸ”„ Verificando status do job (tentativa ${attempts}/${maxAttempts})...`);

                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao verificar status: ${response.status}`);
                }

                const jobData = await response.json();
                
                // ï¿½ PR1: Log resultado do polling (apenas no completed)
                if (jobData.status === 'completed' && window.logStep) {
                    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
                    const job = jobData.job || jobData;
                    window.logStep(traceId, 'POLL_RESULT_RECEIVED', {
                        jobId: jobId,
                        status: job.status,
                        mode: job.mode || job.results?.mode,
                        hasReferenceComparison: !!(job.results?.referenceComparison),
                        hasGenreTargets: !!(job.results?.data?.genreTargets || job.results?.genreTargets),
                    });
                }
                
                // ï¿½ğŸ”§ COMPATIBILIDADE: Suporte para formato novo (ok/job) e antigo
                const job = jobData.job || jobData;
                const status = job.status || jobData.status;
                
                __dbg(`ğŸ“Š Status do job:`, { 
                    status: status, 
                    progress: job.progress || jobData.progress || 'N/A' 
                });

                // Calcular progresso baseado na posiÃ§Ã£o da fila
                let calculatedProgress = 0;
                let progressMessage = 'ğŸš€ Inicializando...';
                
                // Obter status da fila se disponÃ­vel
                const queueStatus = window.getAudioQueueStatus ? window.getAudioQueueStatus() : null;
                
                if (status === 'queued') {
                    // Job na fila - calcular posiÃ§Ã£o
                    if (queueStatus && queueStatus.queue) {
                        const totalInQueue = queueStatus.queue.total || 0;
                        
                        // Armazenar posiÃ§Ã£o inicial na primeira tentativa
                        if (initialQueuePosition === null) {
                            initialQueuePosition = totalInQueue;
                        }
                        
                        // Calcular progresso: quanto mais prÃ³ximo de 0, mais perto de processar
                        if (initialQueuePosition > 0) {
                            calculatedProgress = Math.min(
                                Math.max(
                                    ((initialQueuePosition - totalInQueue) / initialQueuePosition) * 50, // 0-50% enquanto na fila
                                    5 // MÃ­nimo 5%
                                ),
                                50
                            );
                        } else {
                            calculatedProgress = 10;
                        }
                        
                        progressMessage = `â³ Na fila... PosiÃ§Ã£o: ${totalInQueue + 1} | Processando: ${queueStatus.running || 0}`;
                    } else {
                        calculatedProgress = 10;
                        progressMessage = 'â³ Aguardando processamento...';
                    }
                } else if (status === 'processing') {
                    // Job processando - 50% a 95%
                    if (job.progress || jobData.progress) {
                        // Se o backend enviar progresso especÃ­fico, usar e mapear para 50-95%
                        calculatedProgress = 50 + (jobData.progress * 0.45);
                    } else {
                        // Progresso incremental baseado em tentativas
                        calculatedProgress = 50 + Math.min((attempts - (initialQueuePosition || 0)) * 5, 45);
                    }
                    progressMessage = 'ğŸ”„ Analisando Ã¡udio...';
                } else if (status === 'completed' || status === 'done') {
                    calculatedProgress = 100;
                    progressMessage = 'âœ… AnÃ¡lise concluÃ­da!';
                }

                // Atualizar progresso na UI
                updateModalProgress(calculatedProgress, progressMessage);

                if (status === 'completed' || status === 'done') {
                    __dbg('âœ… Job concluÃ­do com sucesso');
                    
                    // ğŸ¯ NOVO: Verificar modo e decidir fluxo
                    let jobResult = job.results || jobData.results || job.result || jobData.result || jobData;
                    jobResult.jobId = jobId; // Incluir jobId no resultado
                    jobResult.mode = jobData.mode; // Incluir mode no resultado
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ğŸ” FRONTEND GUARD: Defesa em profundidade contra vazamento
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // Se por algum bug o backend enviar texto em modo reduced,
                    // sanitizar em memÃ³ria ANTES de renderizar (defesa extra)
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (jobResult.isReduced === true || jobResult.analysisMode === 'reduced') {
                        log('[FRONTEND-GUARD] ğŸ” Modo REDUCED detectado - Aplicando sanitizaÃ§Ã£o extra');
                        
                        const sanitizeItem = (s = {}) => ({
                            ...s,
                            // Preservar campos nÃ£o sensÃ­veis
                            categoria: s.categoria ?? s.category ?? null,
                            metricKey: s.metricKey ?? s.metric ?? null,
                            severity: s.severity ?? null,
                            type: s.type ?? null,
                            // Remover texto sensÃ­vel
                            problema: null,
                            causa: null,
                            solucao: null,
                            plugin: null,
                            dica: null,
                            texto: null,
                            content: null,
                            details: null,
                            raw: null,
                            description: null,
                        });
                        
                        if (Array.isArray(jobResult.suggestions)) {
                            jobResult.suggestions = jobResult.suggestions.map(sanitizeItem);
                        }
                        
                        if (Array.isArray(jobResult.aiSuggestions)) {
                            jobResult.aiSuggestions = jobResult.aiSuggestions.map(sanitizeItem);
                        }
                        
                        log('[FRONTEND-GUARD] âœ… SanitizaÃ§Ã£o extra aplicada');
                    }
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ğŸ” AUDITORIA COMPLETA - ESTRUTURA REAL DO JSON RECEBIDO
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    log('\n\nğŸ”ğŸ”ğŸ” [AUDIT] JSON RECEBIDO DO BACKEND ğŸ”ğŸ”ğŸ”');
                    log('[AUDIT] jobResult COMPLETO:', jobResult);
                    log('[AUDIT] Keys do jobResult:', Object.keys(jobResult));
                    log('[AUDIT] Tipo de jobResult:', typeof jobResult);
                    log('[AUDIT] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    log('[AUDIT] Verificando campos de targets:');
                    log('[AUDIT]   âœ“ jobResult.targets:', !!jobResult.targets);
                    log('[AUDIT]   âœ— jobResult.data?.genreTargets:', !!jobResult.data?.genreTargets);
                    log('[AUDIT]   âœ— jobResult.results?.genreTargets:', !!jobResult.results?.genreTargets);
                    log('[AUDIT]   âœ— jobResult.data?.targets:', !!jobResult.data?.targets);
                    log('[AUDIT]   âœ— jobResult.results?.targets:', !!jobResult.results?.targets);
                    log('[AUDIT] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    
                    if (jobResult.targets) {
                        log('[AUDIT] âœ… CAMPO CORRETO ENCONTRADO: jobResult.targets');
                        log('[AUDIT] Keys de targets:', Object.keys(jobResult.targets));
                        log('[AUDIT] Estrutura de targets:', {
                            hasLufsTarget: 'lufs_target' in jobResult.targets,
                            hasTruePeakTarget: 'true_peak_target' in jobResult.targets,
                            hasDrTarget: 'dr_target' in jobResult.targets,
                            hasStereoTarget: 'stereo_target' in jobResult.targets,
                            hasBands: 'bands' in jobResult.targets || 'spectral_bands' in jobResult.targets,
                            lufsValue: jobResult.targets.lufs_target,
                            truePeakValue: jobResult.targets.true_peak_target,
                            drValue: jobResult.targets.dr_target,
                            stereoValue: jobResult.targets.stereo_target
                        });
                    } else {
                        error('[AUDIT] âŒ CAMPO "targets" NÃƒO ENCONTRADO!');
                        error('[AUDIT] Estrutura recebida pode estar incorreta');
                    }
                    log('ğŸ”ğŸ”ğŸ” [AUDIT] FIM DA AUDITORIA ğŸ”ğŸ”ğŸ”\n\n');
                    
                    // ğŸ¯ PATCH CRÃTICO: Garantir que analysis.targets existe (caminho correto)
                    if (jobResult.targets) {
                        log('[POLLING] âœ… targets encontrado no jobResult (Postgres)');
                        log('[POLLING] Keys:', Object.keys(jobResult.targets));
                    } else if (jobResult.mode === 'genre') {
                        warn('[POLLING] âš ï¸ Modo genre mas "targets" ausente no JSON');
                        warn('[POLLING] Isso pode causar validaÃ§Ã£o incorreta de sugestÃµes');
                    }
                    
                    // ğŸ”¥ AUDITORIA CRÃTICA: Verificar technicalData APÃ“S polling
                    log('\n\nğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-TECHNICAL-DATA] FRONTEND POST-POLLING ğŸ”¥ğŸ”¥ğŸ”¥');
                    log('[AUDIT-TECHNICAL-DATA] jobResult.technicalData:', {
                      exists: !!jobResult.technicalData,
                      type: typeof jobResult.technicalData,
                      isEmpty: jobResult.technicalData && Object.keys(jobResult.technicalData).length === 0,
                      keys: jobResult.technicalData ? Object.keys(jobResult.technicalData) : [],
                      hasSampleFields: {
                        lufsIntegrated: jobResult.technicalData?.lufsIntegrated,
                        truePeakDbtp: jobResult.technicalData?.truePeakDbtp,
                        dynamicRange: jobResult.technicalData?.dynamicRange,
                        spectral_balance: !!jobResult.technicalData?.spectral_balance
                      }
                    });
                    log('[AUDIT-TECHNICAL-DATA] jobResult outros campos:', {
                      hasScore: jobResult.score !== undefined,
                      scoreValue: jobResult.score,
                      hasClassification: !!jobResult.classification,
                      hasTargets: !!jobResult.targets,
                      jobId: jobResult.jobId,
                      mode: jobResult.mode
                    });
                    log('ğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-TECHNICAL-DATA] END ğŸ”¥ğŸ”¥ğŸ”¥\n\n');
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // ï¿½ REFERENCE MODE: Detectar se Ã© base (1Âª mÃºsica) e abrir modal para 2Âª
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    const stateMachine = window.AnalysisStateMachine;
                    const isReferenceMode = jobResult.mode === 'reference' || stateMachine?.getMode() === 'reference';
                    const isReferenceBase = jobResult.referenceStage === 'base' || jobResult.requiresSecondTrack === true;
                    const hasNextAction = jobResult.nextAction === 'upload_second_track';
                    
                    // ğŸ” Log de trace para produÃ§Ã£o
                    const traceId = jobResult.traceId || window.referenceFlow?.state?.traceId || `trace_${Date.now()}`;
                    log('[POLL-TRACE]', {
                        traceId,
                        timestamp: new Date().toISOString(),
                        jobId: jobResult.id || jobResult.jobId || jobId,
                        status: jobResult.status,
                        mode: jobResult.mode,
                        referenceStage: jobResult.referenceStage,
                        nextAction: jobResult.nextAction,
                        requiresSecondTrack: jobResult.requiresSecondTrack,
                        baseJobId: window.referenceFlow?.state?.baseJobId,
                        willOpenModal: isReferenceMode && isReferenceBase && hasNextAction
                    });
                    
                    if (isReferenceMode && isReferenceBase) {
                        log('[POLLING][REFERENCE] ğŸ¯ Base completada', { hasNextAction, traceId });
                        log('[POLLING][REFERENCE] referenceStage:', jobResult.referenceStage);
                        log('[POLLING][REFERENCE] requiresSecondTrack:', jobResult.requiresSecondTrack);
                        log('[POLLING][REFERENCE] referenceJobId:', jobResult.referenceJobId);
                        
                        // Salvar state machine
                        if (stateMachine) {
                            try {
                                stateMachine.setReferenceFirstResult({
                                    firstJobId: jobResult.referenceJobId || jobId,
                                    firstResultSummary: {
                                        score: jobResult.score,
                                        jobId: jobResult.referenceJobId || jobId,
                                        technicalData: jobResult.technicalData || {},
                                        spectralBands: jobResult.spectralBands || {},
                                        classification: jobResult.classification
                                    }
                                });
                                log('[POLLING][REFERENCE] âœ… State machine atualizado');
                            } catch (err) {
                                error('[POLLING][REFERENCE] âŒ Erro ao atualizar state machine:', err);
                            }
                        }
                        
                        // Abrir modal para 2Âª mÃºsica
                        setTimeout(() => {
                            if (typeof openReferenceUploadModal === 'function') {
                                const refJobId = jobResult.referenceJobId || jobId;
                                openReferenceUploadModal(refJobId, jobResult);
                                log('[POLLING][REFERENCE] âœ… Modal da 2Âª mÃºsica aberto - referenceJobId:', refJobId);
                            } else {
                                error('[POLLING][REFERENCE] âŒ openReferenceUploadModal nÃ£o encontrada');
                                alert('âœ… MÃºsica A analisada! Por favor, clique em "ComparaÃ§Ã£o A/B" para enviar a MÃºsica B.');
                            }
                        }, 500);
                    } else if (isReferenceMode && !isReferenceBase) {
                        log('[POLLING][REFERENCE] ğŸ¯ Compare completado - preparando renderizaÃ§Ã£o');
                    }
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    resolve(jobResult);
                    return;
                }

                // âŒ JOB COM ERRO
                if (status === 'failed' || status === 'error') {
                    const errorMsg = job.error || jobData.error || 'Erro desconhecido no processamento';
                    reject(new Error(`Falha na anÃ¡lise: ${errorMsg}`));
                    return;
                }

                // Status 'queued', 'processing', etc. - continuar polling
                if (attempts >= maxAttempts) {
                    reject(new Error('Timeout: AnÃ¡lise demorou mais que o esperado'));
                    return;
                }

                // Aguardar 5 segundos antes da prÃ³xima verificaÃ§Ã£o
                setTimeout(poll, 5000);

            } catch (error) {
                error('âŒ Erro no polling:', error);
                reject(error);
            }
        };

        // Iniciar polling
        poll();
    });
}

/**
 * Mostrar progresso de upload na UI
 * @param {string} message - Mensagem de progresso
 */
function showUploadProgress(message) {
    const progressText = document.getElementById('audioProgressText');
    const connectionHint = document.getElementById('audioConnectionHint');
    const analysisWarning = document.querySelector('.audio-analysis-warning');
    
    if (progressText) {
        progressText.innerHTML = `ğŸŒ ${message}`;
    }
    
    // ğŸ¯ Mostrar dica de conexÃ£o APENAS durante upload para bucket
    const isUploadingToBucket = message.toLowerCase().includes('enviando') && 
                                (message.toLowerCase().includes('anÃ¡lise') || 
                                 message.toLowerCase().includes('bucket') ||
                                 message.toLowerCase().includes('bookit'));
    
    if (connectionHint) {
        connectionHint.style.display = isUploadingToBucket ? 'flex' : 'none';
    }
    
    // ğŸ¯ Ocultar aviso de anÃ¡lise durante upload, mostrar depois
    if (analysisWarning) {
        analysisWarning.style.display = isUploadingToBucket ? 'none' : 'flex';
    }
}

/**
 * Atualizar progresso do modal de anÃ¡lise
 * @param {number} percentage - Porcentagem (0-100)
 * @param {string} message - Mensagem de status
 */
function updateModalProgress(percentage, message) {
    const progressText = document.getElementById('audioProgressText');
    const progressBar = document.getElementById('audioProgressFill') || document.querySelector('.progress-fill');
    const connectionHint = document.getElementById('audioConnectionHint');
    const analysisWarning = document.querySelector('.audio-analysis-warning');
    
    if (progressText) {
        progressText.innerHTML = `${message}`;
    }
    
    // ğŸ¯ Ocultar dica de conexÃ£o e mostrar aviso de anÃ¡lise quando nÃ£o estiver mais em upload
    if (connectionHint) {
        connectionHint.style.display = 'none';
    }
    
    if (analysisWarning) {
        analysisWarning.style.display = 'flex';
    }
    
    if (progressBar) {
        // Garantir que a porcentagem estÃ¡ entre 0 e 100
        const clampedPercentage = Math.min(Math.max(percentage, 0), 100);
        progressBar.style.width = `${clampedPercentage}%`;
        
        __dbg(`ğŸ“Š Progresso atualizado: ${clampedPercentage.toFixed(1)}%`);
    }
}

/**
 * âœ… NOVA IMPLEMENTAÃ‡ÃƒO: SeleÃ§Ã£o de arquivo de referÃªncia com presigned URL
 * @param {string} type - Tipo do arquivo ('original' ou 'reference')
 */
function handleReferenceFileSelection(type) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” FAIL-SAFE: Bloqueio de entitlement no upload de referÃªncia
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        log(`ğŸ” [ENTITLEMENT FAIL-SAFE] Upload de referÃªncia BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.wav,.flac,.mp3,.m4a';
    input.style.display = 'none';

    input.onchange = async function (e) {
        const file = e.target.files[0];
        if (file) {
            // ğŸ”“ [ANONYMOUS-MODE] Interceptar anÃ¡lise em modo anÃ´nimo
            if (window.SoundyAnonymous?.isAnonymousMode) {
                const canProceed = window.SoundyAnonymous.interceptAnalysis();
                if (!canProceed) {
                    log('ğŸš« [ANONYMOUS] AnÃ¡lise referÃªncia (type) bloqueada - limite atingido');
                    return;
                }
            }
            
            try {
                // Validar arquivo
                if (file.size > 150 * 1024 * 1024) {
                    alert('âŒ Arquivo muito grande. Limite: 150MB');
                    return;
                }

                __dbg(`ğŸ¯ Processando arquivo ${type} com presigned URL:`, file.name);

                // ğŸŒ NOVO FLUXO: Presigned URL â†’ Upload â†’ Job Creation â†’ Polling
                
                // 1. Obter URL prÃ©-assinada
                const { uploadUrl, fileKey } = await getPresignedUrl(file);
                
                // 2. Upload direto para bucket
                await uploadToBucket(uploadUrl, file);
                
                // 3. Criar job de anÃ¡lise
                const jobResult = await createAnalysisJob(fileKey, 'reference', file.name);
                
                // ğŸ”¥ [DEMO] Se anÃ¡lise foi bloqueada, interromper fluxo
                if (jobResult.blocked || jobResult.showConversion) {
                    log('ğŸš« [DEMO] AnÃ¡lise bloqueada no modo reference - fluxo interrompido');
                    return; // Modal de conversÃ£o jÃ¡ estÃ¡ sendo exibido
                }
                
                const { jobId } = jobResult;
                
                // 4. Aguardar resultado da anÃ¡lise
                const analysisResult = await pollJobStatus(jobId);
                
                // ğŸ¯ REDUCED MODE AUTO-ACTIVATION: Detectar se backend retornou modo reduced
                // Isso acontece quando free/plus/pro atingem seu limite de anÃ¡lises completas
                if (analysisResult.analysisMode === 'reduced' || analysisResult.mode === 'reduced') {
                    log('%c[REDUCED-MODE-REF] âš ï¸ Backend sinalizou modo REDUCED', 'color:orange;font-weight:bold;font-size:14px;');
                    log('[REDUCED-MODE-REF] Ativando modo reduced automaticamente...');
                    
                    // ForÃ§ar window.analysisMode para 'reduced'
                    window.analysisMode = 'reduced';
                    
                    // Mostrar toast informativo (nÃ£o bloqueante)
                    if (window.showToast || window.Toastify) {
                        const message = 'VocÃª atingiu o limite de anÃ¡lises completas. Continuando em modo reduzido (mÃ©tricas bÃ¡sicas).';
                        if (window.showToast) {
                            window.showToast(message, 'warning');
                        } else if (window.Toastify) {
                            window.Toastify({
                                text: message,
                                duration: 7000,
                                gravity: "top",
                                position: "center",
                                backgroundColor: "#ff9800",
                                stopOnFocus: true
                            }).showToast();
                        }
                    }
                }
                
                // ğŸ¯ FIX CRÃTICO: Injetar file.name no resultado ANTES de salvar no store
                if (file && file.name) {
                    if (!analysisResult.fileName) {
                        analysisResult.fileName = file.name;
                        log('[FILENAME-FIX-REF] âœ… Injetado fileName:', file.name);
                    }
                    if (!analysisResult.metadata) {
                        analysisResult.metadata = {};
                    }
                    if (!analysisResult.metadata.fileName) {
                        analysisResult.metadata.fileName = file.name;
                        log('[FILENAME-FIX-REF] âœ… Injetado metadata.fileName:', file.name);
                    }
                }
                
                // ğŸ” LOG DE DEBUG: Verificar se anÃ¡lise estÃ¡ completa
                log('ğŸ” [DEBUG] AnÃ¡lise retornada do polling:', {
                    hasResult: !!analysisResult,
                    hasTechnicalData: !!analysisResult?.technicalData,
                    avgLoudness: analysisResult?.technicalData?.avgLoudness,
                    lufsIntegrated: analysisResult?.technicalData?.lufsIntegrated,
                    truePeakDbtp: analysisResult?.technicalData?.truePeakDbtp,
                    dynamicRange: analysisResult?.technicalData?.dynamicRange
                });
                
                // ğŸ§© AUDITORIA 1: Verificar se displayModalResults estÃ¡ disponÃ­vel
                log("[AUDITORIA] displayModalResults:", typeof window.displayModalResults);
                
                // Mostrar resultados no modal (com validaÃ§Ã£o interna de mÃ©tricas)
                const tryShowModal = (result, attempts = 0) => {
                    if (typeof window.displayModalResults === "function") {
                        log("âœ… [AUDITORIA] displayModalResults encontrada, exibindo modal...");
                        log("âœ… [RETRY_SUCCESS] Tentativa", attempts + 1, "bem-sucedida, chamando displayModalResults");
                        log("[DISPLAY] Metrics modal triggered from tryShowModal");
                        displayModalResults(result);
                    } else if (attempts < 10) {
                        warn("[AUDITORIA] displayModalResults nÃ£o disponÃ­vel, tentativa", attempts + 1);
                        setTimeout(() => tryShowModal(result, attempts + 1), 500);
                    } else {
                        error("[AUDITORIA] Falha ao exibir modal apÃ³s mÃºltiplas tentativas");
                        // Fallback: tentar exibir em modal simples
                        alert("AnÃ¡lise concluÃ­da, mas modal nÃ£o pÃ´de ser exibido. Verifique o console para dados.");
                        log("[AUDITORIA] Dados da anÃ¡lise:", result);
                    }
                };
                
                tryShowModal(analysisResult);
                
                // ï¿½ [ANONYMOUS-MODE] Registrar anÃ¡lise concluÃ­da
                if (window.SoundyAnonymous?.isAnonymousMode) {
                    window.SoundyAnonymous.registerAnalysis();
                    log('ğŸ“Š [ANONYMOUS] AnÃ¡lise registrada com sucesso');
                }
                
                // ï¿½ğŸ”¥ [DEMO-MODE] Registrar anÃ¡lise concluÃ­da
                if (window.SoundyDemo?.isActive) {
                    window.SoundyDemo.registerAnalysis();
                    log('ğŸ“Š [DEMO] AnÃ¡lise registrada com sucesso');
                }

                // 5. Armazenar resultado
                uploadedFiles[type] = {
                    fileKey: fileKey,
                    fileName: file.name,
                    analysisResult: analysisResult
                };

                log(`âœ… Arquivo ${type} processado com sucesso:`, file.name, "fileKey:", fileKey);

                // Atualizar interface
                updateFileStatus(type, file.name);

                // AvanÃ§ar fluxo
                if (type === "original") {
                    updateProgressStep(2);
                    promptReferenceFile();
                } else if (type === "reference") {
                    updateProgressStep(3);
                    enableAnalysisButton();
                }

            } catch (error) {
                error(`âŒ Erro no processamento do arquivo ${type}:`, error);
                alert(`âŒ Erro ao processar arquivo: ${error.message}`);

                // Abrir modal de anÃ¡lise em caso de erro
                abrirModalDeAnalise("Erro ao processar arquivo para anÃ¡lise.");
            }
        }
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}


function updateFileStatus(type, filename) {
    const statusContainer = document.getElementById('fileUploadStatus');
    if (!statusContainer) return;
    
    let statusDiv = statusContainer.querySelector(`#${type}FileStatus`);
    if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = `${type}FileStatus`;
        statusDiv.className = 'file-status';
        statusContainer.appendChild(statusDiv);
    }
    
    const label = type === 'original' ? 'ğŸµ MÃºsica Original' : 'ğŸ¯ ReferÃªncia';
    statusDiv.innerHTML = `
        <div class="file-item">
            <span class="file-label">${label}:</span>
            <span class="file-name">${filename}</span>
            <span class="file-check">âœ…</span>
        </div>
    `;
}

function promptReferenceFile() {
    const modal = document.getElementById('audioAnalysisModal');
    const uploadBtn = modal.querySelector('#uploadButton');
    
    if (uploadBtn) {
        uploadBtn.textContent = 'ğŸ¯ Upload da MÃºsica de ReferÃªncia';
        uploadBtn.onclick = () => handleReferenceFileSelection('reference');
    }
}

function enableAnalysisButton() {
    const modal = document.getElementById('audioAnalysisModal');
    let analyzeBtn = modal.querySelector('#analyzeReferenceBtn');
    
    if (!analyzeBtn) {
        analyzeBtn = document.createElement('button');
        analyzeBtn.id = 'analyzeReferenceBtn';
        analyzeBtn.className = 'btn btn-primary';
        analyzeBtn.textContent = 'ğŸ”¬ Iniciar AnÃ¡lise Comparativa';
        analyzeBtn.onclick = startReferenceAnalysis;
        
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn && uploadBtn.parentNode) {
            uploadBtn.parentNode.insertBefore(analyzeBtn, uploadBtn.nextSibling);
        }
    }
    
    analyzeBtn.style.display = 'block';
    analyzeBtn.disabled = false;
}

// ğŸ¯ AnÃ¡lise Comparativa
async function startReferenceAnalysis() {
    if (!uploadedFiles.original || !uploadedFiles.reference) {
        alert('âŒ Por favor, faÃ§a upload de ambos os arquivos');
        return;
    }

    updateProgressStep(4);

    try {
        showAnalysisProgress();

        // ğŸ¯ Extrair gÃªnero selecionado do dropdown
        const genreSelect = document.getElementById('audioRefGenreSelect');
        let selectedGenre = genreSelect?.value;
        
        // ğŸ¯ CORREÃ‡ÃƒO: Validar se Ã© string nÃ£o-vazia antes de fallback
        if (!selectedGenre || selectedGenre.trim() === '') {
            selectedGenre = window.PROD_AI_REF_GENRE || 'default';
        }
        
        log('[TRACE-GENRE][FRONTEND-REF] ğŸµ GÃªnero para anÃ¡lise de referÃªncia:', {
            'genreSelect.value': genreSelect?.value,
            'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE,
            'selectedGenre (final)': selectedGenre
        });

        // âœ… Obter token (prioridade: currentUser > localStorage)
        let token = null;
        const currentUser = window.auth?.currentUser;
        
        if (currentUser) {
            try {
                token = await currentUser.getIdToken();
                log('âœ… [REF-MODE] Token obtido do currentUser');
            } catch (err) {
                warn('âš ï¸ [REF-MODE] Erro ao obter token do currentUser:', err.message);
            }
        }
        
        if (!token) {
            token = localStorage.getItem('authToken') || localStorage.getItem('idToken');
            if (token) {
                log('âœ… [REF-MODE] Token obtido do localStorage (fallback)');
            }
        }
        
        if (!token) {
            error('[CRITICAL] ID Token ausente no localStorage apÃ³s login.');
            error('âŒ Token nÃ£o disponÃ­vel - usuÃ¡rio nÃ£o autenticado');
            throw new Error('VocÃª precisa estar logado para analisar Ã¡udio.');
        }

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}` // âœ… Token tambÃ©m no header
            },
            body: JSON.stringify({
                originalKey: uploadedFiles.original,
                referenceKey: uploadedFiles.reference,
                mode: 'reference',
                genre: selectedGenre, // ğŸ¯ FIX CRÃTICO: GÃªnero agora incluÃ­do
                idToken: token // âœ… CORREÃ‡ÃƒO CRÃTICA: Chave correta para backend (req.body.idToken)
            })
        });

        if (!response.ok) {
            throw new Error(`Erro na anÃ¡lise: ${response.status}`);
        }

        const result = await response.json();
        
        log('ğŸ” [REF-ANALYSIS] Resposta do POST /analyze:', result);
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA: result sÃ³ tem jobId, precisa fazer POLLING
        if (!result.success || !result.jobId) {
            throw new Error('Falha ao criar job de anÃ¡lise');
        }
        
        log('â³ [REF-ANALYSIS] Iniciando polling do job:', result.jobId);
        
        // Fazer polling atÃ© anÃ¡lise completar
        const pollInterval = 2000; // 2 segundos
        const maxAttempts = 60; // 2 minutos mÃ¡ximo
        let attempts = 0;
        let analysisComplete = false;
        let completeResult = null;
        
        while (!analysisComplete && attempts < maxAttempts) {
            attempts++;
            
            try {
                const pollResponse = await fetch(`/api/jobs/${result.jobId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!pollResponse.ok) {
                    throw new Error(`Erro ao consultar job: ${pollResponse.status}`);
                }
                
                const jobStatus = await pollResponse.json();
                
                log(`ğŸ”„ [REF-POLLING] Tentativa ${attempts}/${maxAttempts} - Status: ${jobStatus.status}`);
                
                if (jobStatus.status === 'completed' && jobStatus.results) {
                    analysisComplete = true;
                    completeResult = jobStatus.results;
                    log('âœ… [REF-POLLING] AnÃ¡lise completa!');
                    break;
                } else if (jobStatus.status === 'failed') {
                    throw new Error('AnÃ¡lise falhou no backend');
                }
                
                // Aguardar antes da prÃ³xima tentativa
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                
            } catch (pollError) {
                error('âŒ [REF-POLLING] Erro no polling:', pollError);
                throw pollError;
            }
        }
        
        if (!completeResult) {
            throw new Error('Timeout: AnÃ¡lise nÃ£o completou em 2 minutos');
        }
        
        // Agora sim, chamar com resultado COMPLETO
        displayReferenceComparison(completeResult);

    } catch (error) {
        error('âŒ Erro na anÃ¡lise:', error);
        alert('âŒ Erro durante a anÃ¡lise. Tente novamente.');
    }
}


function showAnalysisProgress() {
    const modal = document.getElementById('audioAnalysisModal');
    const content = modal.querySelector('.modal-content');
    
    // Criar overlay de progresso
    const progressOverlay = document.createElement('div');
    progressOverlay.id = 'analysisProgressOverlay';
    progressOverlay.className = 'analysis-progress-overlay';
    progressOverlay.innerHTML = `
        <div class="progress-content">
            <div class="spinner"></div>
            <h3>ğŸ”¬ Analisando Arquivos...</h3>
            <p>Processando caracterÃ­sticas espectrais e comparando com referÃªncia...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
        </div>
    `;
    
    content.appendChild(progressOverlay);
}

function displayReferenceComparison(data) {
    // ğŸ” DEBUG CRÃTICO: Ver exatamente o que chega aqui
    log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    log('ğŸ” [DEBUG] displayReferenceComparison CHAMADA');
    log('ğŸ” [DEBUG] Type of data:', typeof data);
    log('ğŸ” [DEBUG] Data keys:', data ? Object.keys(data) : 'null');
    log('ğŸ” [DEBUG] Data completo:', JSON.stringify(data, null, 2).substring(0, 500));
    log('ğŸ” [DEBUG] ValidaÃ§Ãµes:');
    log('  - data existe?', !!data);
    log('  - data.technicalData?', !!data?.technicalData);
    log('  - data._fromHistory?', data?._fromHistory);
    log('  - data.success?', data?.success);
    log('  - data.jobId?', data?.jobId);
    log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    const modal = document.getElementById('audioAnalysisModal');
    const progressOverlay = document.getElementById('analysisProgressOverlay');
    
    // Remover overlay de progresso
    if (progressOverlay) {
        progressOverlay.remove();
    }
    
    // ğŸ• HISTÃ“RICO PRO: Ponto Ãºnico de salvamento para anÃ¡lises de REFERÃŠNCIA
    // âœ… Salvar AQUI onde temos o dado completo
    if (data && !data._fromHistory && data.technicalData) {
        log('ğŸ• [HISTORY-SAVE] displayReferenceComparison detectou anÃ¡lise de referÃªncia');
        log('ğŸ• [HISTORY-SAVE] Estrutura do data:', {
            hasOriginal: !!data.original,
            hasReference: !!data.reference,
            hasComparison: !!data.comparison,
            hasTechnicalData: !!data.technicalData,
            hasMetadata: !!data.metadata,
            keys: Object.keys(data)
        });
        
        const referenceAnalysisData = {
            ...data,
            mode: 'reference',
            analysisMode: 'reference',
            metadata: data.metadata || {
                fileName: data.original?.metadata?.fileName || data.current?.fileName || 'MÃºsica Original',
                referenceName: data.base?.fileName || data.reference?.metadata?.fileName || 'ReferÃªncia'
            }
        };
        
        // Salvar assÃ­ncrono (nÃ£o bloqueia UI)
        saveAnalysisToHistory(referenceAnalysisData).catch(err => {
            warn('ğŸ• [HISTORY-SAVE] Erro ao salvar (nÃ£o crÃ­tico):', err);
        });
    } else {
        warn('ğŸ• [HISTORY-SAVE] âŒ AnÃ¡lise de referÃªncia NÃƒO serÃ¡ salva:', {
            hasData: !!data,
            isFromHistory: data?._fromHistory,
            hasTechnicalData: !!data?.technicalData
        });
    }
    
    // Criar seÃ§Ã£o de resultados
    const resultsSection = document.createElement('div');
    resultsSection.id = 'referenceResults';
    resultsSection.className = 'reference-results';
    
    resultsSection.innerHTML = generateComparisonHTML(data);
    
    const content = modal.querySelector('.modal-content');
    content.appendChild(resultsSection);
    
    // ğŸš« OCULTAR BOTÃƒO "PLANO DE CORREÃ‡ÃƒO" NO MODO REFERÃŠNCIA
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan) {
        btnCorrectionPlan.style.display = 'none';
        log('[REFERENCE-UI] ğŸ”’ BotÃ£o "Plano de CorreÃ§Ã£o" ocultado no modo referÃªncia');
    }
    
    // Scroll para resultados
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

function generateComparisonHTML(data) {
    const { original, reference, comparison } = data;
    
    return `
        <div class="comparison-header">
            <h3>ğŸ“Š AnÃ¡lise Comparativa ConcluÃ­da</h3>
            <div class="overall-similarity">
                <span class="similarity-label">Similaridade Geral:</span>
                <span class="similarity-score ${getSimilarityClass(comparison.overallSimilarity)}">
                    ${comparison.overallSimilarity}%
                </span>
            </div>
        </div>
        
        <div class="comparison-grid">
            <div class="comparison-section">
                <h4>ğŸµ MÃºsica Original</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(original)}
                </div>
            </div>
            
            <div class="comparison-section">
                <h4>ğŸ¯ MÃºsica de ReferÃªncia</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(reference)}
                </div>
            </div>
        </div>
        
        <div class="differences-section">
            <h4>ğŸ” Principais DiferenÃ§as</h4>
            <div class="differences-grid">
                ${generateDifferencesGrid(comparison.differences)}
            </div>
        </div>
        
        <div class="suggestions-section">
            <h4>ğŸ’¡ SugestÃµes de Melhoria</h4>
            <div class="suggestions-list">
                ${generateSuggestionsList(comparison.suggestions)}
            </div>
        </div>
    `;
}

function generateAudioAnalysisCard(analysis) {
    return `
        <div class="spectral-info">
            <div class="info-item">
                <span class="label">FrequÃªncia Fundamental:</span>
                <span class="value">${analysis.fundamentalFreq} Hz</span>
            </div>
            <div class="info-item">
                <span class="label">Faixa DinÃ¢mica:</span>
                <span class="value">${analysis.dynamicRange} dB</span>
            </div>
            <div class="info-item">
                <span class="label">Stereo Width:</span>
                <span class="value">${analysis.stereoWidth}%</span>
            </div>
        </div>
        
        <!-- REMOVED: Bandas de FrequÃªncia duplicada - consolidada nas mÃ©tricas avanÃ§adas -->
        <!-- frequency-bands section removed to avoid duplication -->
    `;
}

function generateDifferencesGrid(differences) {
    return differences.map(diff => `
        <div class="difference-item ${diff.severity}">
            <div class="diff-header">
                <span class="diff-parameter">${diff.parameter}</span>
                <span class="diff-value">${diff.difference}</span>
            </div>
            <div class="diff-description">${diff.description}</div>
        </div>
    `).join('');
}

function generateSuggestionsList(suggestions) {
    return suggestions.map(suggestion => `
        <div class="suggestion-item">
            <div class="suggestion-title">${suggestion.title}</div>
            <div class="suggestion-description">${suggestion.description}</div>
            <div class="suggestion-priority priority-${suggestion.priority}">
                Prioridade: ${suggestion.priority.toUpperCase()}
            </div>
        </div>
    `).join('');
}

function getSimilarityClass(similarity) {
    if (similarity >= 80) return 'high-similarity';
    if (similarity >= 60) return 'medium-similarity';
    return 'low-similarity';
}

// ğŸ¯ ExposiÃ§Ã£o de FunÃ§Ãµes Globais
window.openModeSelectionModal = openModeSelectionModal;
window.closeModeSelectionModal = closeModeSelectionModal;
window.selectAnalysisMode = selectAnalysisMode;

//! DEBUG: FunÃ§Ã£o de debug global para forÃ§ar recarga
window.forceReloadRefs = async function(genre = 'funk_bruxaria') {
    log('ğŸ”„ FORÃ‡A RECARGA DE REFERÃŠNCIAS:', genre);
    
    // Limpar tudo
    delete window.__refDataCache;
    window.__refDataCache = {};
    window.REFS_BYPASS_CACHE = true;
    window.__activeRefData = null;
    window.__activeRefGenre = null;
    delete window.PROD_AI_REF_DATA;
    
    log('ğŸ’¥ Cache limpo, forÃ§ando reload...');
    
    try {
        const result = await loadReferenceData(genre);
        log('âœ… Recarga forÃ§ada concluÃ­da:', {
            version: result.version,
            lufs_target: result.lufs_target,
            true_peak_target: result.true_peak_target,
            presenca_band: result.bands?.presenca?.target_db
        });
        
        // Resetar flag
        window.REFS_BYPASS_CACHE = false;
        return result;
    } catch (error) {
        error('ğŸ’¥ Erro na recarga forÃ§ada:', error);
        window.REFS_BYPASS_CACHE = false;
        throw error;
    }
};

// ğŸ” FunÃ§Ã£o de DiagnÃ³stico de ReferÃªncias (somente dev)
window.diagnosRefSources = function(genre = null) {
    const targetGenre = genre || __activeRefGenre || 'funk_bruxaria';
    const currentData = __activeRefData;
    const cached = __refDataCache[targetGenre];
    
    log('ğŸ¯ REFERÃŠNCIAS DIAGNÃ“STICO COMPLETO:', {
        requestedGenre: targetGenre,
        activeGenre: __activeRefGenre,
        currentSource: currentData ? 'loaded' : 'none',
        cacheExists: !!cached,
        REFS_ALLOW_NETWORK: typeof window !== 'undefined' ? window.REFS_ALLOW_NETWORK : 'undefined',
        currentData: currentData ? {
            version: currentData.version,
            num_tracks: currentData.num_tracks,
            lufs_target: currentData.lufs_target,
            true_peak_target: currentData.true_peak_target,
            stereo_target: currentData.stereo_target,
            sub_band: currentData.bands?.sub?.target_db,
            presenca_band: currentData.bands?.presenca?.target_db
        } : null
    });
    
    // Test fetch do JSON externo
    const testUrl = `/refs/out/${targetGenre}.json?v=diagnostic`;
    fetch(testUrl).then(r => r.json()).then(j => {
        const data = j[targetGenre];
        log('ğŸŒ EXTERNAL JSON TEST:', {
            url: testUrl,
            success: true,
            version: data?.version,
            num_tracks: data?.num_tracks,
            lufs_target: data?.lufs_target,
            true_peak_target: data?.true_peak_target,
            stereo_target: data?.stereo_target
        });
    }).catch(e => log('âŒ EXTERNAL JSON FAILED:', testUrl, e.message));
    
    return { targetGenre, currentData, cached };
};

// =============== ETAPA 2: Robustez & Completeness Helpers ===============
// Central logging para mÃ©tricas ausentes / NaN (evita console spam e facilita auditoria)
function __logMetricAnomaly(kind, key, context={}) {
    try {
        if (typeof window === 'undefined') return;
        const store = (window.__METRIC_ANOMALIES__ = window.__METRIC_ANOMALIES__ || []);
        const stamp = Date.now();
        store.push({ t: stamp, kind, key, ctx: context });
        if (window.DEBUG_ANALYZER) warn('[METRIC_ANOMALY]', kind, key, context);
        // Limitar tamanho
        if (store.length > 500) store.splice(0, store.length - 500);
    } catch {}
}

// Placeholder seguro para valores nÃ£o finitos (exibe 'â€”' e loga uma vez por chave por render)
function safeDisplayNumber(val, key, decimals=2) {
    if (!Number.isFinite(val)) { __logMetricAnomaly('non_finite', key); return 'â€”'; }
    return val.toFixed(decimals);
}

// ğŸ†• FunÃ§Ã£o para exibir estruturas complexas das novas mÃ©tricas
function safeDisplayComplexMetric(metric, type = 'generic') {
    if (!metric || typeof metric !== 'object') return 'â€”';
    
    switch (type) {
        case 'frequency':
            // Para dominantFrequencies
            if (metric.value !== undefined) {
                const unit = metric.unit || 'Hz';
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(1) : 'â€”';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        case 'dcOffset':
            // Para dcOffset com canais L/R
            if (metric.detailed && (metric.detailed.L !== undefined || metric.detailed.R !== undefined)) {
                const L = Number.isFinite(metric.detailed.L) ? metric.detailed.L.toFixed(4) : 'â€”';
                const R = Number.isFinite(metric.detailed.R) ? metric.detailed.R.toFixed(4) : 'â€”';
                return `L: ${L}, R: ${R}`;
            } else if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(4) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        case 'spectral':
            // Para spectralUniformity
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(3) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
            
        default:
            // Generic: tentar exibir value ou primeiro campo numÃ©rico
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(2) : 'â€”';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return 'â€”';
    }
}

// InvalidaÃ§Ã£o ampla de caches derivados quando gÃªnero mudar
function invalidateReferenceDerivedCaches() {
    try {
        if (typeof window === 'undefined') return;
        delete window.PROD_AI_REF_DATA; // forÃ§a reuso atualizado
    } catch {}
}

// Enriquecimento de objeto de referÃªncia: preencher lacunas e padronizar escala
function enrichReferenceObject(refObj, genreKey) {
    try {
        if (!refObj || typeof refObj !== 'object') return refObj;
        
        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Mapear hybrid_processing para propriedades root
        if (refObj.hybrid_processing && typeof refObj.hybrid_processing === 'object') {
            const hybrid = refObj.hybrid_processing;
            
            // Mapear original_metrics
            if (hybrid.original_metrics && typeof hybrid.original_metrics === 'object') {
                refObj.original_metrics = hybrid.original_metrics;
                
                // Mapear mÃ©tricas individuais para compatibilidade
                if (hybrid.original_metrics.lufs_integrated !== undefined) {
                    refObj.lufs_target = hybrid.original_metrics.lufs_integrated;
                }
                if (hybrid.original_metrics.true_peak_dbtp !== undefined) {
                    refObj.true_peak_target = hybrid.original_metrics.true_peak_dbtp;
                }
                if (hybrid.original_metrics.dynamic_range !== undefined) {
                    refObj.dr_target = hybrid.original_metrics.dynamic_range;
                }
                if (hybrid.original_metrics.stereo_correlation !== undefined) {
                    refObj.stereo_target = hybrid.original_metrics.stereo_correlation;
                }
                if (hybrid.original_metrics.lra !== undefined) {
                    refObj.lra_target = hybrid.original_metrics.lra;
                }
            }
            
            // Mapear spectral_bands (prioridade sobre legacy)
            if (hybrid.spectral_bands && typeof hybrid.spectral_bands === 'object') {
                refObj.spectral_bands = hybrid.spectral_bands;
                
                // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Normalizar chaves de snake_case â†’ camelCase
                if (!refObj.bands) {
                    const normalizedBands = {};
                    Object.keys(hybrid.spectral_bands).forEach(snakeKey => {
                        const camelKey = normalizeGenreBandName(snakeKey);
                        normalizedBands[camelKey] = hybrid.spectral_bands[snakeKey];
                    });
                    refObj.bands = normalizedBands;
                    log('[ENRICH] ğŸ¯ Bandas normalizadas:', Object.keys(normalizedBands));
                }
            }
        }
        
        // CORREÃ‡ÃƒO CRÃTICA: Mapear legacy_compatibility para propriedades root (fallback)
        if (refObj.legacy_compatibility && typeof refObj.legacy_compatibility === 'object') {
            const legacy = refObj.legacy_compatibility;
            
            // Mapear propriedades principais (apenas se nÃ£o foram definidas por hybrid)
            if (legacy.lufs_target !== undefined && refObj.lufs_target === undefined) refObj.lufs_target = legacy.lufs_target;
            if (legacy.tol_lufs !== undefined) refObj.tol_lufs = legacy.tol_lufs;
            if (legacy.true_peak_target !== undefined && refObj.true_peak_target === undefined) refObj.true_peak_target = legacy.true_peak_target;
            if (legacy.tol_true_peak !== undefined) refObj.tol_true_peak = legacy.tol_true_peak;
            if (legacy.dr_target !== undefined && refObj.dr_target === undefined) refObj.dr_target = legacy.dr_target;
            if (legacy.tol_dr !== undefined) refObj.tol_dr = legacy.tol_dr;
            if (legacy.lra_target !== undefined && refObj.lra_target === undefined) refObj.lra_target = legacy.lra_target;
            if (legacy.tol_lra !== undefined) refObj.tol_lra = legacy.tol_lra;
            if (legacy.stereo_target !== undefined && refObj.stereo_target === undefined) refObj.stereo_target = legacy.stereo_target;
            if (legacy.tol_stereo !== undefined) refObj.tol_stereo = legacy.tol_stereo;
            
            // Mapear bandas de frequÃªncia (apenas se nÃ£o foram definidas por hybrid)
            if (legacy.bands && typeof legacy.bands === 'object' && !refObj.bands) {
                refObj.bands = legacy.bands;
            }
        }
        
        // Feature flag geral
        const enabled = (typeof window === 'undefined') || window.ENABLE_REF_ENRICHMENT !== false;
        if (!enabled) return refObj;
        // Definir escala default se ausente
        if (!refObj.scale) refObj.scale = 'log_ratio_db';
        // Preencher stereo_target se ausente usando estatÃ­sticas agregadas (Etapa 2)
        if (refObj.stereo_target == null) {
            try {
                const g = (genreKey||'').toLowerCase();
                const stat = __refDerivedStats[g];
                if (stat && Number.isFinite(stat.avgStereo) && stat.countStereo >= 2) {
                    refObj.stereo_target = stat.avgStereo;
                    refObj.__stereo_filled = 'dataset_avg';
                } else {
                    // fallback heurÃ­stico
                    refObj.stereo_target = g.includes('trance') ? 0.17 : (g.includes('funk') ? 0.12 : 0.15);
                    refObj.__stereo_filled = 'heuristic';
                }
                refObj.tol_stereo = refObj.tol_stereo == null ? 0.08 : refObj.tol_stereo;
            } catch { /* noop */ }
        }
        // Garantir tol_stereo razoÃ¡vel
        if (refObj.tol_stereo == null) refObj.tol_stereo = 0.08;
        // Bandas: marcar N/A para target_db null e permitir comparaÃ§Ã£o ignorando
        if (refObj.bands && typeof refObj.bands === 'object') {
            for (const [k,v] of Object.entries(refObj.bands)) {
                if (!v || typeof v !== 'object') continue;
                if (v.target_db == null) {
                    v._target_na = true; // flag para UI
                }
            }
        }
        // NormalizaÃ§Ã£o opcional antecipada (apenas ajuste de metadado; cÃ¡lculo real feito no analyzer)
        if (window && window.PRE_NORMALIZE_REF_BANDS === true && refObj.bands) {
            const vals = Object.values(refObj.bands).map(b=>b&&Number.isFinite(b.target_db)?b.target_db:null).filter(v=>v!=null);
            const negRatio = vals.filter(v=>v<0).length/Math.max(1,vals.length);
            const posRatio = vals.filter(v=>v>0).length/Math.max(1,vals.length);
            // Se maioria positiva mas queremos alinhar a negativos, apenas anotar
            if (posRatio>0.7 && negRatio<0.3) refObj.__scale_mismatch_hint = 'positive_targets_vs_negative_measurements';
        }
    } catch (e) { warn('[refEnrich] falha', e); }
    return refObj;
}

// Fallback embutido inline para evitar 404 em produÃ§Ã£o
// ğŸ›ï¸ ATUALIZADO: Funk Mandela 2025-08-fixed-flex (18/08/2025) - Estrutura Fixed/Flex Implementada
const __INLINE_EMBEDDED_REFS__ = {
    manifest: { genres: [
        { key: 'trance', label: 'Trance' },
        { key: 'funk_mandela', label: 'Funk Mandela' },
        { key: 'funk_bruxaria', label: 'Funk Bruxaria' },
        { key: 'funk_automotivo', label: 'Funk Automotivo' },
        { key: 'eletronico', label: 'EletrÃ´nico' },
        { key: 'eletrofunk', label: 'Eletrofunk' },
        { key: 'funk_consciente', label: 'Funk Consciente' },
        { key: 'trap', label: 'Trap' }
    ]},
    byGenre: {
        trance: { lufs_target: -14, tol_lufs: 0.5, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 9.4, tol_dr: 0.8, lra_target: 10.7, tol_lra: 2.7, stereo_target: 0.17, tol_stereo: 0.03, bands: { sub:{target_db:-17.3,tol_db:2.5}, low_bass:{target_db:-14.6,tol_db:4.3}, upper_bass:{target_db:-14.8,tol_db:2.5}, low_mid:{target_db:-12.6,tol_db:3.7}, mid:{target_db:-12,tol_db:4.0}, high_mid:{target_db:-20.2,tol_db:3.6}, brilho:{target_db:-24.7,tol_db:2.5}, presenca:{target_db:-32.1,tol_db:3.6} } },
    // Perfil atualizado Funk Mandela 2025-08-mandela-targets.4-tolerances-updated - TOLERÃ‚NCIAS BIDIRECIONAIS ATUALIZADAS
    funk_mandela:   { 
        version: "2025-08-mandela-targets.4-tolerances-updated", 
        lufs_target: -8.0, tol_lufs: 2.5, tol_lufs_min: 2.5, tol_lufs_max: 2.5, 
        true_peak_target: -0.8, tol_true_peak: 1.0, true_peak_streaming_max: -1.2, true_peak_baile_max: -0.1, 
        dr_target: 8.0, tol_dr: 3.0, // Atualizado para Â±3.0 unidades
        lra_target: 9.0, lra_min: 6.5, lra_max: 11.5, tol_lra: 2.5, 
        stereo_target: 0.60, tol_stereo: 0.25, stereo_width_target: 0.20, stereo_width_tol: 0.25, // CorrelaÃ§Ã£o 0.60 Â± 0.25
        low_end_mono_cutoff: 100, clipping_sample_pct_max: 0.02, vocal_band_min_delta: -1.5,
        fixed: {
            lufs: { integrated: { target: -8.0, tolerance: 2.5 } },
            rms: { policy: "deriveFromLUFS" },
            truePeak: { streamingMax: -1.2, baileMax: -0.1, target: -8.0 },
            dynamicRange: { crest: { target: 8.0, min: 5.0, max: 11.0 } },
            lowEnd: { mono: { cutoffHz: 100 } },
            vocalPresence: { bandHz: [1000, 4000], vocalBandMinDeltaDb: -1.5 }
        },
        flex: {
            clipping: { samplePctMax: 0.02 },
            lra: { min: 6.5, max: 11.5, target: 9.0 },
            stereo: { correlation: { min: 0.35, max: 0.85 }, width: { min: 0.075, max: 0.325 } }
        },
        pattern_rules: { 
            hard_constraints: ["lufs", "truePeak", "dynamicRange", "lowEnd", "vocalPresence"], 
            soft_constraints: ["clipping", "lra", "stereo", "tonalCurve"] 
        }, 
        bands: { 
            sub:{target_db:-7.2,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            low_bass:{target_db:-8.9,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            upper_bass:{target_db:-12.8,tol_db:2.5,severity:"soft",range_hz:"120-200"}, 
            low_mid:{target_db:-9.2,tol_db:2.0,severity:"soft",range_hz:"200-500"}, 
            mid:{target_db:-6.8,tol_db:1.5,severity:"hard",vocal_presence_range:true,range_hz:"500-2000"}, 
            high_mid:{target_db:-12.3,tol_db:1.5,severity:"soft",range_hz:"2000-4000"}, 
            brilho:{target_db:-16.2,tol_db:2.0,severity:"soft",range_hz:"4000-8000"}, 
            presenca:{target_db:-19.1,tol_db:2.5,severity:"hard",vocal_presence_range:true,range_hz:"8000-12000"} 
        } 
    },
        funk_bruxaria: { 
            version: "1.0.1",
            generated_at: "2025-08-23T18:03:37.143Z",
            num_tracks: 29,
            lufs_target: -14,
            tol_lufs: 0.5,
            true_peak_target: -1.0,
            tol_true_peak: 1.0,
            dr_target: 7.4,
            tol_dr: 1.3,
            lra_target: 8.4,
            tol_lra: 2.8,
            stereo_target: 0.3,
            tol_stereo: 0.1,
            calor_target: -11.95,
            brilho_target: -17.69,
            clareza_target: -1.21,
            bands: {
                sub: { target_db: -12.5, tol_db: 3 },
                low_bass: { target_db: -15.2, tol_db: 3 },
                upper_bass: { target_db: -15.2, tol_db: 2.3 },
                low_mid: { target_db: -12, tol_db: 1.7 },
                mid: { target_db: -8.7, tol_db: 1.7 },
                high_mid: { target_db: -14.5, tol_db: 2.8 },
                brilho: { target_db: -17.7, tol_db: 2.2 },
                presenca: { target_db: -26.7, tol_db: 2.8 }
            }
        },
        funk_automotivo:{ lufs_target: -8,  tol_lufs: 1.2, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 8.1, tol_dr: 2.0, lra_target: 6.6, tol_lra: 4.0, stereo_target: 0.3, tol_stereo: 0.15, bands: { sub:{target_db:-7.6,tol_db:6.0}, low_bass:{target_db:-6.6,tol_db:4.5}, upper_bass:{target_db:-11.4,tol_db:3.5}, low_mid:{target_db:-8.2,tol_db:3.5}, mid:{target_db:-6.7,tol_db:3.0}, high_mid:{target_db:-12.8,tol_db:4.5}, brilho:{target_db:-16.6,tol_db:4.5}, presenca:{target_db:-22.7,tol_db:5.0} } },
        eletronico:     { 
            version: "1.0.1",
            lufs_target: -14, tol_lufs: 0.5, tol_lufs_min: 0.5, tol_lufs_max: 0.5,  
            true_peak_target: -1.0, tol_true_peak: 1.0, true_peak_streaming_max: -1.0, true_peak_baile_max: 0.0,
            dr_target: 10.1, tol_dr: 1.4, 
            lra_target: 5.2, lra_min: 1.2, lra_max: 9.2, tol_lra: 4, 
            stereo_target: 0.19, tol_stereo: 0.07, stereo_width_mids_highs_tolerance: "moderate",
            low_end_mono_cutoff: 80, clipping_sample_pct_max: 0.01, vocal_band_min_delta: -2.0,
            bands: { 
                sub:{target_db:-12.5,tol_db:3}, 
                low_bass:{target_db:-10.6,tol_db:3}, 
                upper_bass:{target_db:-13.7,tol_db:3}, 
                low_mid:{target_db:-12.1,tol_db:2.7}, 
                mid:{target_db:-11.8,tol_db:2.4}, 
                high_mid:{target_db:-19.1,tol_db:2.3}, 
                brilho:{target_db:-19.1,tol_db:2}, 
                presenca:{target_db:-24,tol_db:3} 
            } 
        },
        eletrofunk:     { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.12, tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        funk_consciente:{ lufs_target: -12, tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 10, tol_dr: 2, lra_target: 7, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        trap:           { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-16,tol_db:5.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } }
    }
};

// ğŸ”„ CRIAR ALIASES PARA COMPATIBILIDADE COM IDs LEGADOS
// Isso garante que anÃ¡lises antigas e fallbacks inline continuem funcionando
(function createInlineLegacyAliases() {
  const byGenre = __INLINE_EMBEDDED_REFS__.byGenre;
  const aliases = {
    'progressive_trance': 'trance',
    'edm': 'funk_automotivo'
  };
  
  Object.entries(aliases).forEach(([newId, legacyId]) => {
    // Se existe o legado, criar o novo ID
    if (byGenre[legacyId] && !byGenre[newId]) {
      byGenre[newId] = byGenre[legacyId];
      log(`[INLINE-ALIAS] Criado novo ID: "${newId}" a partir de "${legacyId}"`);
    }
    // Se existe o novo, criar alias legado
    else if (byGenre[newId] && !byGenre[legacyId]) {
      byGenre[legacyId] = byGenre[newId];
      log(`[INLINE-ALIAS] Criado alias: "${legacyId}" â†’ "${newId}"`);
    }
  });
})();

// Construir estatÃ­sticas agregadas (mÃ©dia stereo por gÃªnero) a partir de refs carregadas
function buildAggregatedRefStats() {
    try {
        const map = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre;
        if (!map) return;
        for (const [g, data] of Object.entries(map)) {
            if (!data || typeof data !== 'object') continue;
            // stereo_target jÃ¡ definido conta; se null ignorar
            if (Number.isFinite(data.stereo_target)) {
                const st = (__refDerivedStats[g] = __refDerivedStats[g] || { sumStereo:0, countStereo:0 });
                st.sumStereo += data.stereo_target; st.countStereo += 1;
            }
        }
        for (const [g, st] of Object.entries(__refDerivedStats)) {
            if (st.countStereo > 0) st.avgStereo = st.sumStereo / st.countStereo;
        }
    } catch (e) { if (window.DEBUG_ANALYZER) warn('buildAggregatedRefStats fail', e); }
}

// Carregar dinamicamente o fallback embutido se necessÃ¡rio
async function ensureEmbeddedRefsReady(timeoutMs = 2500) {
    try {
        if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
        // Se nÃ£o for explicitamente permitido, nÃ£o tentar carregar pela rede para evitar 404
        if (!(typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true)) return false;
        // Injetar script apenas uma vez
        if (typeof document !== 'undefined' && !document.getElementById('embeddedRefsScript')) {
            const s = document.createElement('script');
            s.id = 'embeddedRefsScript';
            s.src = '/refs/embedded-refs.js?v=' + Date.now();
            s.async = true;
            document.head.appendChild(s);
        }
        // Esperar atÃ© ficar disponÃ­vel ou timeout
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
            await new Promise(r => setTimeout(r, 100));
        }
        return (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) ? true : false;
    } catch { return false; }
}

// Helper: buscar JSON tentando mÃºltiplos caminhos (resiliente a diferenÃ§as local x produÃ§Ã£o)
async function fetchRefJsonWithFallback(paths) {
    let lastErr = null;
    for (const p of paths) {
        if (!p) continue;
        try {
            // ğŸ¯ CORREÃ‡ÃƒO: Usar window.location.origin para garantir caminho absoluto no deploy
            const baseUrl = (typeof window !== 'undefined' && window.location) 
                ? window.location.origin 
                : '';
            
            // Se o path jÃ¡ Ã© absoluto (comeÃ§a com http), nÃ£o adicionar origin
            const fullUrl = p.startsWith('http') ? p : `${baseUrl}${p.startsWith('/') ? '' : '/'}${p}`;
            
            // Cache-busting para evitar CDN retornar 404 ou versÃµes antigas
            const hasQ = fullUrl.includes('?');
            const url = fullUrl + (hasQ ? '&' : '?') + 'v=' + Date.now();
            
            if (__DEBUG_ANALYZER__) log('[refs] tentando fetch:', url);
            
            const res = await fetch(url, {
                cache: 'no-store',
                headers: { 
                    'Cache-Control': 'no-cache', 
                    'Pragma': 'no-cache',
                    'Accept': 'application/json'
                }
            });
            
            if (res.ok) {
                // ğŸ¯ VALIDAÃ‡ÃƒO: Verificar Content-Type (permissivo para servidores simples)
                const contentType = res.headers.get('content-type') || '';
                // Aceita: application/json, text/plain, text/json ou vazio (servidores dev)
                const isAcceptable = contentType.includes('json') || 
                                     contentType.includes('text/plain') || 
                                     contentType === '' ||
                                     !contentType.includes('text/html');
                if (!isAcceptable) {
                    // NÃ£o mostrar warning, apenas fazer throw silencioso para tentar prÃ³ximo path
                    throw new Error(`Content-Type HTML detectado: ${contentType}`);
                }
                
                if (__DEBUG_ANALYZER__) log('[refs] OK:', p);
                
                // Verificar se a resposta tem conteÃºdo JSON vÃ¡lido
                const text = await res.text();
                
                // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA: Detectar HTML no lugar de JSON
                if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                    error('[refs] âŒ ERRO: Servidor retornou HTML ao invÃ©s de JSON em', p);
                    error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                    throw new Error(`HTML retornado ao invÃ©s de JSON em ${p}`);
                }
                
                if (text.trim()) {
                    try {
                        const json = JSON.parse(text);
                        log('[refs] âœ… JSON vÃ¡lido carregado de:', p);
                        return json;
                    } catch (jsonError) {
                        error('[refs] âŒ JSON invÃ¡lido em', p);
                        error('[refs] Erro:', jsonError.message);
                        error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                        throw new Error(`JSON invÃ¡lido em ${p}: ${jsonError.message}`);
                    }
                } else {
                    warn('[refs] Resposta vazia em', p);
                    throw new Error(`Resposta vazia em ${p}`);
                }
            } else {
                if (__DEBUG_ANALYZER__) warn('[refs] Falha', res.status, 'em', p);
                lastErr = new Error(`HTTP ${res.status} @ ${p}`);
            }
        } catch (e) {
            if (__DEBUG_ANALYZER__) warn('[refs] Erro fetch', p, e?.message || e);
            lastErr = e;
        }
    }
    throw lastErr || new Error('Falha ao carregar JSON de referÃªncia (todas as rotas testadas)');
}

// ğŸ“š Carregar manifesto de gÃªneros (opcional). Se ausente, manter fallback.
async function loadGenreManifest() {
    // 1) Preferir embutido em window, depois inline
    try {
        const winEmb = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.manifest) || null;
        if (winEmb && Array.isArray(winEmb.genres)) { __genreManifest = winEmb.genres; return __genreManifest; }
    } catch {}
    if (!__genreManifest && __INLINE_EMBEDDED_REFS__?.manifest?.genres?.length) {
        __genreManifest = __INLINE_EMBEDDED_REFS__.manifest.genres;
        return __genreManifest;
    }
    // 2) Se permitido, tentar rede
    if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
        try {
            const json = await fetchRefJsonWithFallback([
                `/refs/out/genres.json`,
                `refs/out/genres.json`,
                `./refs/out/genres.json`,
                `../refs/out/genres.json`
            ]);
            if (json && Array.isArray(json.genres)) { __genreManifest = json.genres; return __genreManifest; }
        } catch (e) { __dwrn('Manifesto via rede indisponÃ­vel:', e.message || e); }
    }
    return __genreManifest || null;
}

// ğŸ·ï¸ Popular o <select> com base no manifesto, mantendo fallback e preservando seleÃ§Ã£o
function populateGenreSelect(manifestGenres) {
    const sel = document.getElementById('audioRefGenreSelect');
    if (!sel) return;
    if (!Array.isArray(manifestGenres) || manifestGenres.length === 0) {
        // Nada a fazer (fallback jÃ¡ em HTML)
        // Ainda assim, garantir que o gÃªnero ativo esteja presente como opÃ§Ã£o
        ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
        return;
    }
    // Salvar valor atual (se houver)
    const current = sel.value;
    // Limpar opÃ§Ãµes atuais e reconstruir
    while (sel.options.length) sel.remove(0);
    for (const g of manifestGenres) {
        if (!g || !g.key) continue;
        const opt = document.createElement('option');
        opt.value = String(g.key);
        opt.textContent = String(g.label || labelizeKey(g.key));
        sel.appendChild(opt);
    }
    // Garantir que gÃªnero ativo via URL/localStorage esteja presente
    ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
    // Restaurar seleÃ§Ã£o (priorizar PROD_AI_REF_GENRE > current > primeira opÃ§Ã£o)
    const target = window.PROD_AI_REF_GENRE || current || (sel.options[0] && sel.options[0].value);
    if (target) sel.value = target;
}

// ğŸ”¤ Converter chave em rÃ³tulo amigÃ¡vel (ex.: "funk_mandela" â†’ "Funk Mandela")
function labelizeKey(key) {
    if (!key) return '';
    return String(key)
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\b\w/g, c => c.toUpperCase());
}

// âœ… Garantir que a opÃ§Ã£o do gÃªnero ativo exista no select (para casos via URL)
function ensureActiveGenreOption(selectEl, genreKey) {
    if (!selectEl || !genreKey) return;
    const exists = Array.from(selectEl.options).some(o => o.value === genreKey);
    if (!exists) {
        const opt = document.createElement('option');
        opt.value = String(genreKey);
        opt.textContent = labelizeKey(genreKey);
        selectEl.appendChild(opt);
    }
}

/**
 * ğŸ¯ NOVA FUNÃ‡ÃƒO: Extrair targets de gÃªnero do JSON
 * Formato esperado do JSON:
 * {
 *   "nome_genero": {
 *     "version": "...",
 *     "hybrid_processing": {
 *       "original_metrics": {...},
 *       "spectral_bands": {...}  â† PRIORIDADE 1
 *     },
 *     "legacy_compatibility": {
 *       "bands": {...}  â† PRIORIDADE 2
 *     },
 *     "bands": {...}  â† PRIORIDADE 3 (fallback)
 *   }
 * }
 */
function extractGenreTargets(json, genreName) {
    // 1. Identificar o root real do gÃªnero
    let root = null;
    
    // Tentar: json[genreName]
    if (json && typeof json === 'object' && json[genreName]) {
        root = json[genreName];
    }
    // Tentar: json jÃ¡ Ã© o root (quando vem de cache ou embedded)
    else if (json && typeof json === 'object' && json.version) {
        root = json;
    }
    // Tentar: primeiro objeto no JSON
    else if (json && typeof json === 'object') {
        const firstKey = Object.keys(json)[0];
        if (firstKey && json[firstKey] && typeof json[firstKey] === 'object') {
            root = json[firstKey];
        }
    }
    
    if (!root) {
        error('[EXTRACT-TARGETS] âŒ Root nÃ£o encontrado no JSON para:', genreName);
        return null;
    }
    
    // 2. Buscar targets na ordem de prioridade
    let targets = null;
    let source = null;
    
    // ğŸ¯ PRIORIDADE 1: legacy_compatibility.bands (FONTE OFICIAL)
    if (root.legacy_compatibility?.bands) {
        targets = root.legacy_compatibility.bands;
        source = 'legacy_compatibility.bands';
    }
    // ğŸ¯ PRIORIDADE 2: hybrid_processing.spectral_bands (fallback)
    else if (root.hybrid_processing?.spectral_bands) {
        targets = root.hybrid_processing.spectral_bands;
        source = 'hybrid_processing.spectral_bands';
    }
    // ğŸ¯ PRIORIDADE 3: bands (fallback genÃ©rico)
    else if (root.bands) {
        targets = root.bands;
        source = 'bands';
    }
    // ğŸ¯ PRIORIDADE 4: hybrid_processing.original_metrics (Ãºltimo recurso)
    else if (root.hybrid_processing?.original_metrics) {
        targets = root.hybrid_processing.original_metrics;
        source = 'hybrid_processing.original_metrics';
    }
    
    if (!targets) {
        error('[EXTRACT-TARGETS] âŒ Nenhum target encontrado no JSON para:', genreName);
        return null;
    }
    
    // 3. Criar objeto de resultado completo
    const result = {
        ...root,
        targets: targets,
        targetSource: source
    };
    
    // Log silencioso - apenas em modo debug
    if (__DEBUG_ANALYZER__) {
        log('[EXTRACT-TARGETS] âœ…', genreName, 'â†’', source, '|', Object.keys(targets).length, 'bands');
    }
    
    return result;
}

async function loadReferenceData(genre) {
    try {
        // ğŸ¯ ALIAS DE FETCH: Mapeia novos IDs para JSONs legados existentes
        // Isso permite buscar trance.json quando o gÃªnero Ã© progressive_trance
        const FETCH_ALIAS = {
            'progressive_trance': 'trance',
            'rap_drill': 'phonk',
            'edm': 'funk_automotivo',
            'fullon': 'techno'
        };
        const fetchGenre = FETCH_ALIAS[genre] || genre;
        
        // Se feature flag de invalidar cache por troca de escala/gÃªnero estiver ativa, ignorar cache salvo
        const bypassCache = (typeof window !== 'undefined' && window.REFS_BYPASS_CACHE === true);
        if (!bypassCache && __refDataCache[genre]) {
            __activeRefData = __refDataCache[genre];
            __activeRefGenre = genre;
            
            // âœ… Log detalhado dos targets carregados do cache
            log('[LOAD-REF] ğŸ“¦ Carregado do cache:', {
                genre: genre,
                hasTargets: !!__activeRefData?.targets,
                targetKeys: __activeRefData?.targets ? Object.keys(__activeRefData.targets) : [],
                targetSource: __activeRefData?.targetSource
            });
            
            updateRefStatus('âœ” referÃªncias (cache)', '#0d6efd');
            return __activeRefData;
        }
        if (bypassCache) {
            delete __refDataCache[genre];
        }
        updateRefStatus('â³ carregando...', '#996600');
        
        if (__DEBUG_ANALYZER__) log('[refs] loadReferenceData:', { genre, fetchGenre, bypassCache });
        
        // PRIORIDADE CORRIGIDA: external > embedded > fallback
        // 1) Tentar carregar JSON externo primeiro (sempre, independente de REFS_ALLOW_NETWORK)
        // Usa fetchGenre para buscar o JSON legado correto
        try {
            const version = Date.now(); // Force cache bust
            const json = await fetchRefJsonWithFallback([
                `/refs/out/${fetchGenre}.json?v=${version}`,
                `refs/out/${fetchGenre}.json?v=${version}`,
                `./refs/out/${fetchGenre}.json?v=${version}`,
                `../refs/out/${fetchGenre}.json?v=${version}`
            ]);
            
            // âœ… NOVA LÃ“GICA: Usar extractGenreTargets para processar JSON
            const extractedData = extractGenreTargets(json, genre);
            
            if (extractedData && typeof extractedData === 'object' && extractedData.version) {
                const enrichedNet = enrichReferenceObject(extractedData, genre);
                __refDataCache[genre] = enrichedNet;
                __activeRefData = enrichedNet;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedNet;
                window.__activeRefData = enrichedNet; // âœ… Garantir disponibilidade global
                
                // Log silencioso - apenas em modo debug
                if (__DEBUG_ANALYZER__) {
                    log('[refs] âœ… Carregado (external):', genre, 'â†’', extractedData.version);
                }
                
                updateRefStatus('âœ” referÃªncias aplicadas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedNet;
            }
        } catch (netError) {
            // Silencioso: fallback para embedded Ã© comportamento normal em dev
            if (__DEBUG_ANALYZER__) {
                log('[refs] External fetch nÃ£o disponÃ­vel, usando embedded...');
            }
            
            // ğŸ”¥ CORREÃ‡ÃƒO LOOP INFINITO: ForÃ§ar refsReady se refs internas jÃ¡ carregaram
            if (!window.refsReady && window.embeddedRefsLoaded) {
                window.refsReady = true;
            }
        }
        
        // 2) Fallback para referÃªncias embutidas (embedded)
        // Usar fetchGenre (alias) para buscar nos dados embedded tambÃ©m
        const embWin = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre && window.__EMBEDDED_REFS__.byGenre[fetchGenre]) || null;
        const embInline = __INLINE_EMBEDDED_REFS__?.byGenre?.[fetchGenre] || null;
        const useData = embWin || embInline;
        if (useData && typeof useData === 'object') {
            // âœ… NOVA LÃ“GICA: Extrair targets corretamente (passa fetchGenre para encontrar a chave)
            const extractedData = extractGenreTargets(useData, fetchGenre);
            
            if (extractedData) {
                const enriched = enrichReferenceObject(structuredClone(extractedData), genre);
                __refDataCache[genre] = enriched;
                __activeRefData = enriched;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enriched;
                window.__activeRefData = enriched; // âœ… Garantir disponibilidade global
                
                // Log silencioso - apenas em modo debug
                if (__DEBUG_ANALYZER__) {
                    log('[refs] âœ… Carregado (embedded):', genre, 'â†’', extractedData.version || 'inline');
                }
                
                updateRefStatus('âœ” referÃªncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enriched;
            }
        }
        
        // 3) Legacy path REFS_ALLOW_NETWORK removido - nÃ£o mais necessÃ¡rio
        // O sistema agora usa fetch externo â†’ embedded â†’ fallback
        
        // 4) Ãšltimo recurso: trance inline (fallback)
        const fallback = __INLINE_EMBEDDED_REFS__?.byGenre?.trance;
        if (fallback) {
            const enrichedFb = enrichReferenceObject(structuredClone(fallback), 'trance');
            __refDataCache['trance'] = enrichedFb;
            __activeRefData = enrichedFb;
            __activeRefGenre = 'trance';
            window.PROD_AI_REF_DATA = enrichedFb;
            
            // Log apenas em debug
            if (__DEBUG_ANALYZER__) {
                log('[refs] âš ï¸ Usando fallback trance para:', genre);
            }
            
            updateRefStatus('âœ” referÃªncias embutidas (fallback)', '#0d6efd');
            try { buildAggregatedRefStats(); } catch {}
            return enrichedFb;
        }
        throw new Error('Sem referÃªncias disponÃ­veis');
    } catch (e) {
        warn('Falha ao carregar referÃªncias', genre, e);
        // Fallback: tentar EMBEDDED
        try {
            const embMap = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre || {};
            const emb = embMap[genre];
            if (emb && typeof emb === 'object') {
                const enrichedEmb = enrichReferenceObject(structuredClone(emb), genre);
                __refDataCache[genre] = enrichedEmb;
                __activeRefData = enrichedEmb;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedEmb;
                updateRefStatus('âœ” referÃªncias embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmb;
            }
            // Se o gÃªnero especÃ­fico nÃ£o existir, usar um padrÃ£o seguro (trance) se disponÃ­vel
            if (embMap && embMap.trance) {
                const enrichedEmbTr = enrichReferenceObject(structuredClone(embMap.trance), 'trance');
                __refDataCache['trance'] = enrichedEmbTr;
                __activeRefData = enrichedEmbTr;
                __activeRefGenre = 'trance';
                window.PROD_AI_REF_DATA = enrichedEmbTr;
                updateRefStatus('âœ” referÃªncias embutidas (fallback)', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmbTr;
            }
        } catch(_) {}
        updateRefStatus('âš  falha refs', '#992222');
        return null;
    }
}

function updateRefStatus(text, color) {
    const el = document.getElementById('audioRefStatus');
    if (el) { el.textContent = text; el.style.background = color || '#1f2b40'; }
}

/**
 * ğŸ”’ FUNÃ‡ÃƒO DE PRESERVAÃ‡ÃƒO DE GÃŠNERO
 * Garante que o gÃªnero selecionado NUNCA seja perdido em resets
 */
function preserveGenreState(sourceAnalysis = null) {
    log('[PRESERVE-GENRE] ğŸ”’ Preservando estado do gÃªnero');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Se foi passada uma anÃ¡lise, extrair targets dela primeiro
    if (sourceAnalysis) {
        log('[PRESERVE-GENRE] ğŸ¯ AnÃ¡lise fornecida - extraindo genre e targets (FONTE OFICIAL)');
        
        const extractedGenre = extractGenreFromAnalysis(sourceAnalysis);
        const extractedTargets = extractGenreTargetsFromAnalysis(sourceAnalysis);
        
        if (extractedGenre) {
            window.__CURRENT_SELECTED_GENRE = extractedGenre;
            window.PROD_AI_REF_GENRE = extractedGenre;
            log('[PRESERVE-GENRE] âœ… GÃªnero extraÃ­do de analysis.data.genre:', extractedGenre);
        }
        
        if (extractedTargets) {
            window.__CURRENT_GENRE_TARGETS = extractedTargets;
            window.currentGenreTargets = extractedTargets;
            log('[PRESERVE-GENRE] âœ… Targets extraÃ­dos de analysis.data.genreTargets:', Object.keys(extractedTargets));
        }
        
        // Se conseguiu extrair ambos, retornar
        if (extractedGenre && extractedTargets) {
            return;
        }
    }
    
    // Se __CURRENT_SELECTED_GENRE jÃ¡ existe, nÃ£o precisa restaurar
    if (window.__CURRENT_SELECTED_GENRE) {
        log('[PRESERVE-GENRE] âœ… __CURRENT_SELECTED_GENRE jÃ¡ existe:', window.__CURRENT_SELECTED_GENRE);
        return;
    }

    // Se o CURRENT nÃ£o existir, restaurar do refGenre
    if (window.PROD_AI_REF_GENRE) {
        window.__CURRENT_SELECTED_GENRE = window.PROD_AI_REF_GENRE;
        log('[PRESERVE-GENRE] âœ… __CURRENT_SELECTED_GENRE restaurado de PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
    }

    // Reatribuir targets
    if (window.__CURRENT_GENRE_TARGETS) {
        window.currentGenreTargets = window.__CURRENT_GENRE_TARGETS;
        log('[PRESERVE-GENRE] âœ… currentGenreTargets restaurado de __CURRENT_GENRE_TARGETS');
    }
}

function applyGenreSelection(genre) {
    if (!genre) return Promise.resolve();
    window.PROD_AI_REF_GENRE = genre;
    localStorage.setItem('prodai_ref_genre', genre);
    // InvalidaÃ§Ã£o de cache opcional
    if (typeof window !== 'undefined' && window.INVALIDATE_REF_CACHE_ON_GENRE_CHANGE === true) {
        try { delete __refDataCache[genre]; } catch {}
        invalidateReferenceDerivedCaches();
    }
    
    // ğŸ¯ FORÃ‡AR invalidaÃ§Ã£o para garantir nova referÃªncia
    try { 
        delete __refDataCache[genre]; 
        invalidateReferenceDerivedCaches();
        log('âœ… Cache invalidado para gÃªnero:', genre);
    } catch(e) { warn('âš ï¸ Falha na invalidaÃ§Ã£o:', e); }
    
    // Carregar refs e, se jÃ¡ houver anÃ¡lise no modal, atualizar sugestÃµes de referÃªncia e re-renderizar
    return loadReferenceData(genre).then(() => {
        // ğŸ”’ PATCH: Salvar gÃªnero e targets em TODAS as variÃ¡veis globais
        window.__CURRENT_SELECTED_GENRE = genre;
        window.PROD_AI_REF_GENRE = genre;
        
        // Extrair targets do __activeRefData carregado
        if (window.__activeRefData?.targets) {
            window.__CURRENT_GENRE_TARGETS = window.__activeRefData.targets;
            window.currentGenreTargets = window.__activeRefData.targets;
            log('[APPLY-GENRE] âœ… GÃªnero e targets salvos:', {
                genre: genre,
                hasTargets: true,
                targetKeys: Object.keys(window.__activeRefData.targets)
            });
        } else {
            warn('[APPLY-GENRE] âš ï¸ Targets nÃ£o encontrados em __activeRefData');
        }
        
        try {
            if (typeof currentModalAnalysis === 'object' && currentModalAnalysis) {
                // ğŸ¯ NOVO: Recalcular score com nova referÃªncia
                try {
                    if (typeof window !== 'undefined' && window.computeMixScore && __refData) {
                        // ğŸ¯ CORREÃ‡ÃƒO: Passar mode para garantir que gates V3 usem o limite correto
                        const mode = window.__SOUNDY_ANALYSIS_MODE__ || 'streaming';
                        const scoreResult = window.computeMixScore(currentModalAnalysis.technicalData, __refData, { mode });
                        currentModalAnalysis.qualityOverall = scoreResult?.scorePct ?? scoreResult;
                        log('âœ… Score recalculado para novo gÃªnero:', currentModalAnalysis.qualityOverall);
                    }
                } catch(e) { warn('âŒ Falha ao recalcular score:', e); }
                
                // Recalcular sugestÃµes reference_* com as novas tolerÃ¢ncias
                try { updateReferenceSuggestions(currentModalAnalysis); } catch(e) { warn('updateReferenceSuggestions falhou', e); }
                // Re-renderizaÃ§Ã£o completa para refletir sugestÃµes e comparaÃ§Ãµes
                try { 
                    // ğŸ”’ UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
                    const analysisRunId = currentModalAnalysis?.runId || currentModalAnalysis?.metadata?.runId;
                    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
                    
                    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                        warn(`ğŸš« [UI_GATE] Re-render cancelado - anÃ¡lise obsoleta (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
                        return;
                    }
                    
                    displayModalResults(currentModalAnalysis); 
                } catch(e) { warn('re-render modal falhou', e); }
            }
        } catch (e) { warn('re-render comparaÃ§Ã£o falhou', e); }
    });
}
// Expor global
if (typeof window !== 'undefined') {
    window.applyGenreSelection = applyGenreSelection;
}

// Health check utilitÃ¡rio (Etapa 2) â€“ avalia estabilidade das mÃ©tricas em mÃºltiplos runs
if (typeof window !== 'undefined' && !window.__audioHealthCheck) {
    window.__audioHealthCheck = async function(file, opts = {}) {
        const runs = opts.runs || 3;
        const delayMs = opts.delayMs || 0;
        const out = { runs: [], spreads: {}, anomalies: [] };
        for (let i=0;i<runs;i++) {
            const t0 = performance.now();
            // ğŸ†” CORREÃ‡ÃƒO: Adicionar runId para funÃ§Ãµes de health check
            const healthOptions = prepareAnalysisOptions({}, `health_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, healthOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufsIntegrated: res?.technicalData?.lufsIntegrated,
                truePeakDbtp: res?.technicalData?.truePeakDbtp,
                dynamicRange: res?.technicalData?.dynamicRange,
                lra: res?.technicalData?.lra,
                stereoCorrelation: res?.technicalData?.stereoCorrelation,
                processingMs: (res?.processingMs ?? (t1 - t0))
            });
            if (delayMs) await new Promise(r=>setTimeout(r, delayMs));
        }
        const collect = (key) => out.runs.map(r=>r[key]).filter(v=>Number.isFinite(v));
        const stats = (arr) => arr.length?{min:Math.min(...arr),max:Math.max(...arr),spread:Math.max(...arr)-Math.min(...arr)}:null;
        ['lufsIntegrated','truePeakDbtp','dynamicRange','lra','stereoCorrelation','processingMs'].forEach(k=>{
            out.spreads[k] = stats(collect(k));
        });
        // Anomalias agrupadas (do logger central)
        try { out.anomalies = (window.__METRIC_ANOMALIES__||[]).slice(-100); } catch {}
        return out;
    };
}

// ================== ACCEPTANCE TEST HARNESS (Etapa 3) ==================
// âš ï¸ REMOVIDO: Testes que dependem de Web Audio API
// TODO: Implementar testes baseados em anÃ¡lise remota se necessÃ¡rio

if (typeof window !== 'undefined' && !window.__runAcceptanceAudioTests) {
    window.__runAcceptanceAudioTests = async function(opts = {}) {
        warn('âš ï¸ Testes de aceitaÃ§Ã£o de Ã¡udio foram removidos devido Ã  migraÃ§Ã£o para anÃ¡lise remota');
        return { 
            skipped: true, 
            reason: 'Web Audio API removida - usar testes de backend' 
        };
    };
}

// Inicializar quando DOM carregar
document.addEventListener('DOMContentLoaded', function() {
    initializeAudioAnalyzerIntegration();
});


function initializeAudioAnalyzerIntegration() {
    if (__audioIntegrationInitialized) {
        __dbg('â„¹ï¸ IntegraÃ§Ã£o do Audio Analyzer jÃ¡ inicializada. Ignorando chamada duplicada.');
        return;
    }
    __audioIntegrationInitialized = true;
    __dbg('ğŸµ Inicializando integraÃ§Ã£o do Audio Analyzer...');
    // Habilitar flag de referÃªncia por gÃªnero via parÃ¢metro de URL (ex.: ?refgenre=trance)
    try {
        if (typeof window !== 'undefined') {
            const params = new URLSearchParams(window.location.search);
            const rg = params.get('refgenre');
            if (rg && !window.PROD_AI_REF_GENRE) {
                window.PROD_AI_REF_GENRE = String(rg).trim().toLowerCase();
                __dbg(`[REF-GÃŠNERO] Ativado via URL: ${window.PROD_AI_REF_GENRE}`);
            }
            // Flags de controle por URL (nÃ£o alteram CSS)
            if (params.has('surgical')) {
                const v = params.get('surgical');
                window.USE_SURGICAL_EQ = !(v === '0' || v === 'false');
                __dbg(`[FLAG] USE_SURGICAL_EQ = ${window.USE_SURGICAL_EQ}`);
            }
            if (params.has('useLog')) {
                const v = params.get('useLog');
                window.USE_LOG_BAND_ENERGIES = (v === '1' || v === 'true');
                __dbg(`[FLAG] USE_LOG_BAND_ENERGIES = ${window.USE_LOG_BAND_ENERGIES}`);
            }
            if (params.has('adv')) {
                const v = params.get('adv');
                const on = !(v === '0' || v === 'false');
                window.USE_ADVANCED_METRICS = on;
                window.USE_ADVANCED_LOUDNESS = on;
                window.USE_ADVANCED_TRUEPEAK = on;
                window.USE_ADVANCED_SPECTRUM = on;
                __dbg(`[FLAG] ADVANCED = ${on}`);
            }
            if (params.has('debug')) {
                const v = params.get('debug');
                window.DEBUG_ANALYZER = (v === '1' || v === 'true');
                __dbg(`[FLAG] DEBUG_ANALYZER = ${window.DEBUG_ANALYZER}`);
            }
            // Preferir mÃ©tricas avanÃ§adas (ITU/oversampling) quando disponÃ­veis, sem sobrescrever configs do usuÃ¡rio
            if (typeof window.PREFER_ADVANCED_METRICS === 'undefined') {
                window.PREFER_ADVANCED_METRICS = true;
                __dbg('[FLAG] PREFER_ADVANCED_METRICS = true (auto)');
            }
        }
    } catch (_) { /* noop */ }
    
    // Restaurar gÃªnero salvo
    try {
        const saved = localStorage.getItem('prodai_ref_genre');
        if (!window.PROD_AI_REF_GENRE && saved) window.PROD_AI_REF_GENRE = saved;
    } catch {}

    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (genreSelect) {
        // Popular dinamicamente a partir do manifesto, mantendo fallback
        loadGenreManifest().then(() => {
            populateGenreSelect(__genreManifest);
            // Listener de mudanÃ§a (garantir apenas um)
            genreSelect.onchange = () => applyGenreSelection(genreSelect.value);
            // Aplicar seleÃ§Ã£o atual
            const selected = genreSelect.value || window.PROD_AI_REF_GENRE;
            applyGenreSelection(selected);
        });
    }

    // BotÃ£o de anÃ¡lise de mÃºsica (novo design)
    const musicAnalysisBtn = document.getElementById('musicAnalysisBtn');
    if (musicAnalysisBtn) {
        musicAnalysisBtn.addEventListener('click', openAudioModal);
        __dbg('âœ… BotÃ£o de AnÃ¡lise de MÃºsica configurado');
    }
    
    // Modal de Ã¡udio
    setupAudioModal();
    
    __dbg('ğŸµ Audio Analyzer Integration carregada com sucesso!');
    
    // ğŸ§  Aguarda refs e cache ficarem prontos antes de liberar o ForceActivator
    function waitForRefsAndCacheBeforeReady() {
        const checkReady = () => {
            const ready = !!(window.audioAnalyzer && window.CACHE_CTX_AWARE_V1_API && window.refsReady);
            log("â³ [READY-CHECK] Estado atual:", {
                audioAnalyzer: !!window.audioAnalyzer,
                CACHE_CTX_AWARE_V1_API: !!window.CACHE_CTX_AWARE_V1_API,
                refsReady: !!window.refsReady
            });
            if (ready) {
                log("âœ… [GLOBAL] Todos os sistemas prontos. Disparando analysisReady...");
                const evt = new Event("analysisReady");
                document.dispatchEvent(evt);
                return true;
            }
            return false;
        };

        if (!checkReady()) {
            const interval = setInterval(() => {
                if (checkReady()) clearInterval(interval);
            }, 300);
        }
    }

    // ğŸ”¥ Chamar a funÃ§Ã£o de espera no ponto onde estava o dispatch antigo:
    waitForRefsAndCacheBeforeReady();

    // Aplicar estilos aprimorados ao seletor de gÃªnero
    try { injectRefGenreStyles(); } catch(e) { /* silencioso */ }
    
    // ğŸ†• Inicializar Modal de GÃªnero Musical
    try { initGenreModal(); } catch(e) { warn('Falha ao inicializar modal de gÃªnero:', e); }
}

// ============================================================================
// ï¿½ MODAL DE BOAS-VINDAS Ã€ ANÃLISE - NOVO SISTEMA
// ============================================================================

/**
 * ğŸŒŸ Abrir modal de boas-vindas
 * Modal inicial que apresenta o sistema e direciona para o guia tÃ©cnico
 */
function openWelcomeModal() {
    __dbg('ğŸ‰ Abrindo modal de boas-vindas Ã  anÃ¡lise...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) {
        error('âŒ Modal de boas-vindas nÃ£o encontrado no DOM');
        return;
    }
    
    // Bloquear scroll do body
    document.body.classList.add('modal-open');
    
    // Abrir modal com animaÃ§Ã£o
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    
    // Foco no modal para acessibilidade
    requestAnimationFrame(() => {
        modal.focus();
        
        // Foco no primeiro botÃ£o
        const firstBtn = modal.querySelector('.welcome-btn.primary');
        if (firstBtn) {
            firstBtn.focus();
        }
    });
    
    __dbg('âœ… Modal de boas-vindas aberto com sucesso');
}

/**
 * âŒ Fechar modal de boas-vindas
 */
function closeWelcomeModal() {
    __dbg('âŒ Fechando modal de boas-vindas...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        
        // Desbloquear scroll do body
        document.body.classList.remove('modal-open');
    }
    
    __dbg('âœ… Modal de boas-vindas fechado');
}

/**
 * ğŸ“– Abrir guia tÃ©cnico em nova aba
 */
function openTechnicalGuide() {
    __dbg('ğŸ“– Abrindo guia tÃ©cnico de anÃ¡lise...');
    
    // Abrir guia na mesma pasta (public/)
    window.open('guia-tecnico-analise.html', '_blank', 'noopener,noreferrer');
    
    // NÃ£o fecha o modal - usuÃ¡rio pode ler o guia e voltar
    __dbg('âœ… Guia tÃ©cnico aberto em nova aba');
}

/**
 * â–¶ï¸ Prosseguir para anÃ¡lise (fechar modal de boas-vindas e continuar fluxo)
 */
function proceedToAnalysis() {
    __dbg('â–¶ï¸ Prosseguindo para anÃ¡lise...');
    
    // Fechar modal de boas-vindas
    closeWelcomeModal();
    
    // Continuar com o fluxo original
    const isReferenceEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
    
    if (isReferenceEnabled) {
        // Abrir modal de seleÃ§Ã£o de modo
        openModeSelectionModal();
    } else {
        // Ir direto para modo gÃªnero
        selectAnalysisMode('genre');
    }
    
    __dbg('âœ… Fluxo de anÃ¡lise continuado');
}

// Expor funÃ§Ãµes globalmente para uso nos onclick do HTML
window.openWelcomeModal = openWelcomeModal;
window.closeWelcomeModal = closeWelcomeModal;
window.openTechnicalGuide = openTechnicalGuide;
window.proceedToAnalysis = proceedToAnalysis;

// ğŸ§ BETA DJS: FunÃ§Ãµes para controlar modal de encerramento
function openBetaExpiredModal() {
    const modal = document.getElementById('betaDjExpiredModal');
    if (!modal) {
        error('âŒ Modal betaDjExpiredModal nÃ£o encontrado');
        return;
    }
    
    log('ğŸ§ [BETA-DJ] Abrindo modal de encerramento do beta');
    modal.style.display = 'flex';
    
    // Salvar preferÃªncia no localStorage para nÃ£o exibir novamente na mesma sessÃ£o
    sessionStorage.setItem('betaDjModalShown', 'true');
}

function closeBetaExpiredModal() {
    const modal = document.getElementById('betaDjExpiredModal');
    if (modal) {
        modal.style.display = 'none';
        log('ğŸ§ [BETA-DJ] Modal de encerramento fechado');
    }
}

window.openBetaExpiredModal = openBetaExpiredModal;
window.closeBetaExpiredModal = closeBetaExpiredModal;

/**
 * âŒ¨ï¸ Configurar acessibilidade do modal de boas-vindas
 */
function setupWelcomeModalAccessibility() {
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) return;
    
    // ESC para fechar
    document.addEventListener('keydown', function handleWelcomeEscape(e) {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeWelcomeModal();
        }
    });
    
    // Tab navigation (trap focus)
    modal.addEventListener('keydown', function handleWelcomeTabNav(e) {
        if (e.key !== 'Tab') return;
        
        const focusableElements = modal.querySelectorAll(
            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
        }
    });
    
    __dbg('âŒ¨ï¸ Acessibilidade do modal de boas-vindas configurada');
}

// Inicializar acessibilidade quando DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupWelcomeModalAccessibility);
} else {
    setupWelcomeModalAccessibility();
}

// ============================================================================

// ğŸµ Abrir modal de anÃ¡lise de Ã¡udio (MODIFICADO para usar novo fluxo)
function openAudioModal() {
    window.logReferenceEvent('open_modal_requested');
    
    // ğŸŒŸ NOVO: Abrir modal de boas-vindas PRIMEIRO
    openWelcomeModal();
}

// ğŸ¯ NOVO: Abrir modal secundÃ¡rio para upload da mÃºsica de referÃªncia
function openReferenceUploadModal(referenceJobId, firstAnalysisResult) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” FAIL-SAFE: Bloqueio de entitlement no modal de referÃªncia
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        log(`ğŸ” [ENTITLEMENT FAIL-SAFE] Modal de referÃªncia BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    __dbg('ğŸ¯ Abrindo modal secundÃ¡rio para mÃºsica de referÃªncia', { referenceJobId });
    
    // ğŸ” PR1: Log tentativa de abrir modal
    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
    if (window.logStep) {
        window.logStep(traceId, 'OPEN_SECOND_MODAL_ATTEMPT', {
            referenceJobId,
            userExplicitlySelectedReferenceMode,
            currentMode: window.currentAnalysisMode,
        });
    }
    
    // ğŸ¯ PROTEÃ‡ÃƒO: Garantir que primeira anÃ¡lise estÃ¡ completa
    if (!firstAnalysisResult) {
        error('âŒ [PROTECTION] Primeira anÃ¡lise nÃ£o estÃ¡ completa - abortando abertura do modal de referÃªncia');
        alert('âš ï¸ A primeira anÃ¡lise ainda nÃ£o foi concluÃ­da. Por favor, aguarde.');
        return;
    }
    
    // ğŸ¯ PROTEÃ‡ÃƒO: Validar que hÃ¡ dados essenciais
    if (!firstAnalysisResult.technicalData) {
        error('âŒ [PROTECTION] Primeira anÃ¡lise nÃ£o contÃ©m technicalData - dados incompletos');
        alert('âš ï¸ A primeira anÃ¡lise nÃ£o foi concluÃ­da corretamente. Por favor, tente novamente.');
        return;
    }
    
    log('âœ… [PROTECTION] Primeira anÃ¡lise validada com sucesso:', {
        hasJobId: !!referenceJobId,
        hasTechnicalData: !!firstAnalysisResult.technicalData,
        hasScore: !!firstAnalysisResult.score
    });
    
    window.logReferenceEvent('reference_upload_modal_opened', { referenceJobId });
    
    // ğŸ¯ PERSISTIR DADOS DA PRIMEIRA FAIXA
    window.__REFERENCE_JOB_ID__ = referenceJobId;
    
    // ï¿½ HARD-GUARD: Salvar primeira anÃ¡lise no FirstAnalysisStore (IMUTÃVEL)
    log('[FirstAnalysisStore] ğŸ”’ Salvando primeira anÃ¡lise no store imutÃ¡vel...');
    
    // âœ… USAR NOVA API: FirstAnalysisStore.set() - clonagem interna
    FirstAnalysisStore.set(firstAnalysisResult);
    
    // âŒ REMOVER: NÃ£o usar mais window.referenceAnalysisData / window.__FIRST_ANALYSIS_RESULT__
    // A ÃšNICA fonte de verdade Ã© FirstAnalysisStore
    
    window.lastReferenceJobId = referenceJobId;
    
    log('âœ… [COMPARE-MODE] Primeira faixa salva:', {
        jobId: referenceJobId,
        score: firstAnalysisResult?.score,
        lufs: firstAnalysisResult?.technicalData?.lufsIntegrated,
        storeProtected: FirstAnalysisStore.has()
    });
    
    // ğŸ”¥ FIX-REFERENCE: NÃƒO chamar reset completo - apenas limpar UI visualmente
    // closeAudioModal();   // âŒ REMOVIDO - deletava __REFERENCE_JOB_ID__
    // resetModalState();   // âŒ REMOVIDO - deletava __REFERENCE_JOB_ID__

    // Resetar apenas UI (sem limpar flags globais)
    const uploadAreaFirst = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');

    if (uploadAreaFirst) uploadAreaFirst.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';

    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';

    log('[FIX-REFERENCE] Modal reaberto SEM limpar flags de referÃªncia');
    
    // ğŸ” AUDIT: Dump antes do guard de state machine
    const stateMachine = getSafeStateMachine();
    
    if (window.debugDump) window.debugDump('BEFORE_GUARD_STATE_MACHINE', { 
        stateMachineAvailable: !!stateMachine,
        isAwaitingSecondTrack: stateMachine?.isAwaitingSecondTrack(),
        stateMachineState: stateMachine?.getState()
    });
    
    // ğŸ†• PR2: GUARD USANDO STATE MACHINE
    if (stateMachine && !stateMachine.isAwaitingSecondTrack()) {
        error('%c[PR2-GUARD] âŒ BLOQUEIO: State machine nÃ£o estÃ¡ aguardando segunda track', 'color:#FF0000;font-weight:bold;font-size:14px;');
        error('[PR2-GUARD] Estado atual:', stateMachine.getState());
        
        // ğŸ” PR1: Log guard blocked
        if (window.logStep) {
            window.logStep(traceId, 'GUARD_BLOCKED', {
                guard: 'isAwaitingSecondTrack',
                value: false,
                reason: 'State machine not awaiting second track',
                stateMachineState: stateMachine.getState(),
                stack: new Error().stack,
            });
        }
        
        alert('âš ï¸ ERRO: Estado invÃ¡lido - nÃ£o Ã© possÃ­vel enviar segunda mÃºsica.');
        return;
    }
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: NÃ£o permitir ativaÃ§Ã£o de modo reference se usuÃ¡rio nÃ£o selecionou explicitamente
    // ğŸ†• FIX: Sincronizar com state machine que Ã© fonte de verdade
    const stateMachineExplicit = stateMachine?.isUserExplicitlySelected?.() || false;
    const hasContext = hasActiveReferenceContext();
    const isExplicitlySelected = userExplicitlySelectedReferenceMode || stateMachineExplicit || hasContext;
    
    log('[REF-GUARD] openReferenceUploadModal:', {
      userExplicit: userExplicitlySelectedReferenceMode,
      stateMachineExplicit,
      hasContext,
      allowed: isExplicitlySelected
    });
    
    if (!isExplicitlySelected) {
        // ğŸ” PR1: Log guard blocked
        if (window.logStep) {
            window.logStep(traceId, 'GUARD_BLOCKED', {
                guard: 'userExplicitlySelectedReferenceMode',
                legacyFlag: userExplicitlySelectedReferenceMode,
                stateMachineFlag: stateMachineExplicit,
                reason: 'User did not explicitly select reference mode',
                currentMode: window.currentAnalysisMode,
                referenceJobId: referenceJobId,
                stack: new Error().stack,
            });
        }
        
        error('%c[PROTECTION] âŒ BLOQUEIO ATIVADO: openReferenceUploadModal chamado mas flags de explicit = false', 'color:#FF0000;font-weight:bold;font-size:14px;');
        error('[PROTECTION] âŒ Legacy flag:', userExplicitlySelectedReferenceMode);
        error('[PROTECTION] âŒ StateMachine flag:', stateMachineExplicit);
        console.trace('[PROTECTION] Stack trace do bloqueio:');
        
        // ğŸ” PR1: Assert invariante violada
        if (window.assertInvariant) {
            window.assertInvariant(
                'OPEN_MODAL_REQUIRES_EXPLICIT_FLAG',
                false, // sempre falha aqui (proposital para log)
                {
                    userExplicitlySelectedReferenceMode,
                    stateMachineExplicit,
                    referenceJobId,
                    currentMode: window.currentAnalysisMode,
                }
            );
        }
        
        alert('âš ï¸ ERRO: Sistema tentou ativar modo A/B automaticamente. Por favor, selecione o modo A/B explicitamente.');
        return;
    }
    
    log('[REF_FIX] âœ… Flag explicit verificada - abrindo modal para 2Âª mÃºsica');
    
    // ğŸ¯ CORREÃ‡ÃƒO: Manter modo 'reference' para segunda mÃºsica tambÃ©m
    // O backend identifica que Ã© comparaÃ§Ã£o pela presenÃ§a do referenceJobId
    currentAnalysisMode = 'reference';
    log('%c[PROTECTION] âœ… currentAnalysisMode definido como reference - flag verificada', 'color:#00FF88;font-weight:bold;');
    
    // Abrir modal novamente
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        error('âŒ Modal de anÃ¡lise de Ã¡udio nÃ£o encontrado');
        return;
    }
    
    // Atualizar tÃ­tulo e instruÃ§Ãµes do modal
    const modalTitle = document.getElementById('audioModalTitle');
    const modalSubtitle = document.getElementById('audioModalSubtitle');
    
    if (modalTitle) {
        modalTitle.innerHTML = 'ğŸ¯ Upload da MÃºsica de ReferÃªncia';
    }
    
    if (modalSubtitle) {
        modalSubtitle.innerHTML = '<span id="audioModeIndicator">Etapa 2/2: Envie a mÃºsica de referÃªncia para comparaÃ§Ã£o</span>';
        modalSubtitle.style.display = 'block';
    }
    
    // Atualizar mensagem na Ã¡rea de upload
    const uploadAreaSecond = document.getElementById('audioUploadArea');
    if (uploadAreaSecond) {
        const uploadContent = uploadAreaSecond.querySelector('.upload-content h4');
        if (uploadContent) {
            uploadContent.textContent = 'Enviar mÃºsica de referÃªncia';
        }
        
        const uploadDescription = uploadAreaSecond.querySelector('.upload-content p');
        if (uploadDescription) {
            uploadDescription.textContent = 'Arraste a mÃºsica de referÃªncia aqui ou clique para selecionar';
        }
    }
    
    // Mostrar modal
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    
    // ğŸ¯ TRANSIÃ‡ÃƒO DE ESTADO: Modal 2 ABERTO â†’ REF_B_WAIT_UPLOAD
    log('%c[REF-FLOW] ğŸ¯ TRANSIÃ‡ÃƒO: Modal 2 ABERTO â†’ REF_B_WAIT_UPLOAD', 'color:#00FF88;font-weight:bold;font-size:14px;');
    log('[REF-FLOW] Estado atual:', {
        stage: 'REF_B_WAIT_UPLOAD',
        modal2Open: true,
        awaitingSecondUpload: true,
        referenceJobId: referenceJobId,
        currentMode: window.currentAnalysisMode
    });
    
    __dbg('âœ… Modal secundÃ¡rio de referÃªncia aberto');
}

// ğŸ¯ NOVO: Modal de SeleÃ§Ã£o de Modo
function openModeSelectionModal() {
    __dbg('ğŸ¯ Abrindo modal de seleÃ§Ã£o de modo...');
    
    // ğŸ”“ MODO ANÃ”NIMO: Verificar limite de anÃ¡lises
    if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
        if (!window.SoundyAnonymous.interceptAnalysis()) {
            log('ğŸš« [ANALYZER] AnÃ¡lise bloqueada - limite anÃ´nimo atingido');
            return;
        }
    }
    
    const modal = document.getElementById('analysisModeModal');
    if (!modal) {
        error('Modal de seleÃ§Ã£o de modo nÃ£o encontrado');
        return;
    }
    
    // Verificar se modo referÃªncia estÃ¡ habilitado e mostrar/esconder botÃ£o
    const referenceModeBtn = document.getElementById('referenceModeBtn');
    if (referenceModeBtn) {
        const isEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
        referenceModeBtn.style.display = isEnabled ? 'flex' : 'none';
        
        if (!isEnabled) {
            referenceModeBtn.disabled = true;
        }
    }
    
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('mode_selection_modal_opened');
}

function closeModeSelectionModal() {
    __dbg('âŒ Fechando modal de seleÃ§Ã£o de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    window.logReferenceEvent('mode_selection_modal_closed');
}

// ğŸ¯ NOVO: Selecionar modo de anÃ¡lise
function selectAnalysisMode(mode) {
    window.logReferenceEvent('analysis_mode_selected', { mode });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ENTITLEMENT GATE: Bloquear MODO REFERÃŠNCIA para FREE/PLUS IMEDIATAMENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (mode === 'reference') {
        const { shouldBlock, plan } = checkReferenceEntitlementSync();
        
        if (shouldBlock) {
            log(`ğŸ” [ENTITLEMENT] Modo ReferÃªncia BLOQUEADO (plan=${plan})`);
            
            if (window.EntitlementsHandler?.showUpgradeModal) {
                window.EntitlementsHandler.showUpgradeModal('reference', plan);
            } else {
                alert('O Modo ReferÃªncia estÃ¡ disponÃ­vel apenas no plano PRO. FaÃ§a upgrade!');
            }
            return; // PARAR - nÃ£o continuar
        }
        
        log('ğŸ” [ENTITLEMENT] Modo ReferÃªncia PERMITIDO - plano PRO confirmado');
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    if (mode === 'reference' && !window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED) {
        alert('Modo de anÃ¡lise por referÃªncia nÃ£o estÃ¡ disponÃ­vel no momento.');
        return;
    }
    
    currentAnalysisMode = mode;
    
    // Fechar modal de seleÃ§Ã£o de modo
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // ğŸ†• STREAMING MODE: Abrir modal de destino ANTES do modal de gÃªnero
        openSoundDestinationModal((destinationMode) => {
            log('[SELECT-MODE] Destino escolhido:', destinationMode);
            // Modo tradicional - abrir modal de anÃ¡lise normal
            openAnalysisModalForMode('genre');
        });
    } else if (mode === 'reference') {
        // Modo referÃªncia - abrir interface especÃ­fica (sem modal de destino)
        setSoundDestinationMode('pista'); // Reset para default
        openAnalysisModalForMode('reference');
    } else {
        // Fallback para outros modos
        openAnalysisModalForMode(mode);
    }
}

// ï¿½ NOVO MODAL DE GÃŠNERO MUSICAL - Sistema completo
// Feature flag para controlar ativaÃ§Ã£o
window.FEATURE_NEW_GENRE_MODAL = true; // Definir como false para usar seletor antigo

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ MODAL DE DESTINO DO SOM (PISTA vs STREAMING)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * @type {'pista' | 'streaming'}
 * @description Modo de destino do som - NUNCA deve ser undefined
 * @default 'pista'
 */
window.__SOUNDY_ANALYSIS_MODE__ = 'pista';

/**
 * ğŸ†• STREAMING TARGETS FIXOS
 */
const STREAMING_TARGETS = {
    lufs_target: -14,
    true_peak_target: -1.0
};

/**
 * ğŸ†• Aplica override de streaming nos targets (FRONTEND)
 * IMPORTANTE: Preserva TODAS as outras propriedades (DR, Stereo, Bands, etc)
 * SÃ³ altera LUFS e True Peak
 * @param {Object} targets - Targets originais
 * @returns {Object} - Targets com override se streaming
 */
function applyStreamingOverride(targets) {
    const mode = getSoundDestinationMode();
    if (mode !== 'streaming') return targets;
    
    if (!targets || typeof targets !== 'object') {
        log('[STREAMING] Criando targets minimos');
        return { lufs_target: -14, true_peak_target: -1.0 };
    }
    
    // Deep copy para preservar objetos aninhados (bands, etc)
    const result = JSON.parse(JSON.stringify(targets));
    
    // Apenas sobrescrever LUFS e True Peak
    result.lufs_target = -14;
    result.true_peak_target = -1.0;
    
    log('[STREAMING] Override aplicado: LUFS=-14, TP=-1.0');
    log('[STREAMING] Propriedades preservadas:', Object.keys(result));
    return result;
}

/**
 * Getter seguro para analysisMode (sempre retorna valor vÃ¡lido)
 */
function getSoundDestinationMode() {
    const mode = window.__SOUNDY_ANALYSIS_MODE__;
    if (mode !== 'pista' && mode !== 'streaming') {
        warn('[DEST-MODE] âš ï¸ Modo invÃ¡lido detectado, resetando para "pista"');
        window.__SOUNDY_ANALYSIS_MODE__ = 'pista';
        return 'pista';
    }
    return mode;
}

/**
 * Setter seguro para analysisMode
 * @param {'pista' | 'streaming'} mode
 */
function setSoundDestinationMode(mode) {
    if (mode !== 'pista' && mode !== 'streaming') {
        error('[DEST-MODE] âŒ Tentativa de setar modo invÃ¡lido:', mode);
        return false;
    }
    window.__SOUNDY_ANALYSIS_MODE__ = mode;
    log(`[DEST-MODE] âœ… Modo definido: ${mode}`);
    return true;
}

/**
 * Injetar estilos do modal de destino
 */
function injectDestinationModalStyles() {
    if (document.getElementById('destination-modal-styles')) return;
    
    const styles = document.createElement('style');
    styles.id = 'destination-modal-styles';
    styles.textContent = `
        /* ğŸ¯ Modal de Destino do Som - Glassmorphism Premium */
        #soundDestinationModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            z-index: 10001;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #soundDestinationModal.active {
            display: flex;
            opacity: 1;
        }
        
        .destination-modal-container {
            max-width: 800px;
            width: 90%;
            background: radial-gradient(
                circle at 20% 20%, 
                rgba(93, 21, 134, 0.85) 0%,
                rgba(0, 0, 0, 0.95) 60%,
                rgba(0, 102, 255, 0.4) 100%
            );
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 
                0 20px 40px rgba(91, 11, 156, 0.49),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            padding: 48px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: modalFadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes modalFadeIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Efeito de fundo neural */
        .destination-modal-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 40px, rgba(106, 154, 255, 0.03) 40px, rgba(106, 154, 255, 0.03) 41px),
                repeating-linear-gradient(90deg, transparent, transparent 40px, rgba(106, 0, 255, 0.03) 40px, rgba(106, 0, 255, 0.03) 41px);
            opacity: 0.6;
            pointer-events: none;
            z-index: 1;
        }
        
        .destination-modal-container > * {
            position: relative;
            z-index: 5;
        }
        
        .destination-modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #fff;
            margin-bottom: 12px;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }
        
        .destination-modal-subtitle {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 40px;
        }
        
        .destination-grid {
            display: flex;
            gap: 24px;
            justify-content: center;
        }
        
        .destination-card {
            flex: 1;
            max-width: 340px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 32px 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-appearance: none;
            appearance: none;
            color: inherit;
            font-family: inherit;
        }
        
        .destination-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .destination-card.pista:hover {
            border-color: rgba(255, 170, 0, 0.5);
            box-shadow: 0 0 30px rgba(255, 170, 0, 0.15);
        }

        .destination-card.streaming:hover {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.15);
        }
        
        .destination-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.2));
        }
        
        .destination-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 12px;
            color: #fff;
        }
        
        .destination-desc {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 20px;
            line-height: 1.4;
            min-height: 3em;
        }
        
        .destination-features {
            padding: 0;
            margin: 0;
            text-align: left;
            width: 100%;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 20px;
        }
        
        .destination-feature {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .destination-feature::before {
            content: 'âœ“';
            color: #00ff88;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .destination-grid {
                flex-direction: column;
                align-items: center;
            }
            .destination-card {
                width: 100%;
                max-width: 100%;
            }
            .destination-modal-container {
                padding: 32px 20px;
                max-height: 90vh;
                overflow-y: auto;
            }
            .destination-modal-title {
                font-size: 1.6rem;
            }
        }
    `;
    document.head.appendChild(styles);
}

/**
 * Criar modal de destino no DOM (se nÃ£o existir)
 */
function ensureDestinationModalExists() {
    if (document.getElementById('soundDestinationModal')) return;
    
    const modal = document.createElement('div');
    modal.id = 'soundDestinationModal';
    modal.innerHTML = `
        <div class="destination-modal-container">
            <div class="destination-modal-title">Onde esse som vai tocar?</div>
            <div class="destination-modal-subtitle">Escolha o destino para otimizar a anÃ¡lise</div>
            
            <div class="destination-grid">
                <button class="destination-card pista" data-mode="pista">
                    <div class="destination-icon">ğŸ”Š</div>
                    <div class="destination-name">Pista</div>
                    <div class="destination-desc">Para tocar alto em sistemas de som, carros, festas e shows.</div>
                    <div class="destination-features">
                        <div class="destination-feature">P.A, paredÃ£o e automotivo</div>
                        <div class="destination-feature">Mais impacto e pressÃ£o sonora</div>
                        <div class="destination-feature">Energia mÃ¡xima para pista</div>
                    </div>
                </button>
                
                <button class="destination-card streaming" data-mode="streaming">
                    <div class="destination-icon">ğŸ“¡</div>
                    <div class="destination-name">Streaming</div>
                    <div class="destination-desc">Para subir em plataformas digitais com padrÃ£o profissional.</div>
                    <div class="destination-features">
                        <div class="destination-feature">Spotify, Deezer, Apple Music</div>
                        <div class="destination-feature">Loudness padronizado (-14 LUFS)</div>
                        <div class="destination-feature">Evita distorÃ§Ã£o e normalizaÃ§Ã£o agressiva</div>
                    </div>
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelectorAll('.destination-card').forEach(card => {
        card.addEventListener('click', (e) => {
            const mode = card.dataset.mode;
            selectSoundDestination(mode);
        });
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            // NÃ£o fechar ao clicar fora - forÃ§ar escolha
        }
    });
}

/**
 * Abrir modal de destino do som
 * @param {Function} callback - FunÃ§Ã£o a chamar apÃ³s seleÃ§Ã£o
 */
function openSoundDestinationModal(callback) {
    log('[DEST-MODAL] ğŸ¯ Abrindo modal de destino do som...');
    
    injectDestinationModalStyles();
    ensureDestinationModalExists();
    
    // Guardar callback para chamar apÃ³s seleÃ§Ã£o
    window.__destinationModalCallback__ = callback;
    
    const modal = document.getElementById('soundDestinationModal');
    log('[DEST-MODAL] Modal encontrado:', !!modal);
    
    if (modal) {
        modal.classList.add('active');
        modal.style.display = 'flex'; // ForÃ§ar display flex como backup
        log('[DEST-MODAL] âœ… Modal ativado com classe active');
        
        // Focus no primeiro botÃ£o
        setTimeout(() => {
            const firstBtn = modal.querySelector('.destination-card');
            if (firstBtn) firstBtn.focus();
        }, 100);
    } else {
        error('[DEST-MODAL] âŒ Modal nÃ£o encontrado no DOM!');
        // Fallback: continuar sem o modal de destino
        if (typeof callback === 'function') {
            log('[DEST-MODAL] Usando fallback: modo pista');
            setSoundDestinationMode('pista');
            callback('pista');
        }
    }
}

/**
 * Fechar modal de destino
 */
function closeSoundDestinationModal() {
    const modal = document.getElementById('soundDestinationModal');
    if (modal) {
        modal.classList.remove('active');
        modal.style.display = 'none'; // Garantir que esconda
        log('[DEST-MODAL] Modal fechado');
    }
}

/**
 * Selecionar destino do som
 * @param {'pista' | 'streaming'} mode
 */
function selectSoundDestination(mode) {
    log(`[DEST-MODAL] âœ… Destino selecionado: ${mode}`);
    
    // Definir modo
    setSoundDestinationMode(mode);
    
    // Fechar modal
    closeSoundDestinationModal();
    
    // Chamar callback se existir
    if (typeof window.__destinationModalCallback__ === 'function') {
        window.__destinationModalCallback__(mode);
        window.__destinationModalCallback__ = null;
    }
}

// Expor funÃ§Ãµes globalmente
window.getSoundDestinationMode = getSoundDestinationMode;
window.setSoundDestinationMode = setSoundDestinationMode;
window.openSoundDestinationModal = openSoundDestinationModal;
window.closeSoundDestinationModal = closeSoundDestinationModal;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FIM DO MODAL DE DESTINO DO SOM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸµ FunÃ§Ãµes do Modal de GÃªnero Musical
function openGenreModal() {
    __dbg('[GENRE_MODAL] Abrindo modal de seleÃ§Ã£o de gÃªnero...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        error('[GENRE_MODAL] Modal nÃ£o encontrado no DOM');
        return;
    }
    
    // Injetar estilos se ainda nÃ£o foi feito
    injectGenreModalStyles();
    
    // ğŸ”§ CORREÃ‡ÃƒO FLASH BRANCO: Prepaint para evitar primeiro frame errado
    modal.classList.add('prepaint');  // Cards invisÃ­veis enquanto CSS aplica
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
    
    // Libera a transiÃ§Ã£o sÃ³ de opacity no prÃ³ximo frame
    requestAnimationFrame(() => {
        modal.classList.remove('prepaint');
        
        // Foco no primeiro botÃ£o de gÃªnero
        const firstGenreCard = modal.querySelector('.genre-card');
        if (firstGenreCard) {
            firstGenreCard.focus();
        }
    });
    
    // ğŸ¯ SCROLL FIX: Bloquear scroll do body quando modal aberto
    document.body.classList.add('modal-open');
    
    // Adicionar listeners de teclado
    modal.addEventListener('keydown', handleGenreModalKeydown);
    
    __dbg('[GENRE_MODAL] Modal aberto com sucesso (sem flash branco)');
}

function closeGenreModal() {
    __dbg('[GENRE_MODAL] Fechando modal de seleÃ§Ã£o de gÃªnero...');
    
    const modal = document.getElementById('newGenreModal');
    if (modal) {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        
        // ğŸ¯ SCROLL FIX: Liberar scroll do body ao fechar modal
        document.body.classList.remove('modal-open');
        
        // Remover listeners
        modal.removeEventListener('keydown', handleGenreModalKeydown);
    }
    
    __dbg('[GENRE_MODAL] Modal fechado');
}

function handleGenreModalKeydown(e) {
    if (e.key === 'Escape') {
        closeGenreModal();
    }
}

// ğŸ¯ InicializaÃ§Ã£o do Modal de GÃªnero
function initGenreModal() {
    __dbg('[GENRE_MODAL] Inicializando sistema do modal...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        warn('[GENRE_MODAL] Modal nÃ£o encontrado, inicializaÃ§Ã£o cancelada');
        return;
    }
    
    const genreCards = modal.querySelectorAll('.genre-card');
    const closeBtn = modal.querySelector('[data-close]');
    
    // ğŸ¯ Handler de clique nos gÃªneros
    genreCards.forEach(card => {
        card.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const genre = card.dataset.genre;
            if (!genre) {
                error('[GENRE_MODAL] GÃªnero nÃ£o definido no card');
                return;
            }
            
            __dbg('[GENRE_MODAL] GÃªnero selecionado:', genre);
            
            // ğŸ”¥ REUTILIZAR EXATAMENTE: Chamar applyGenreSelection como especificado
            if (typeof applyGenreSelection === 'function') {
                // âœ… CORREÃ‡ÃƒO CRÃTICA: Aguardar carregamento completo dos targets
                await applyGenreSelection(genre);
                
                // âœ… Log detalhado mostrando targets reais
                log('âœ… [GENRE_MODAL] Targets de gÃªnero carregados:', {
                    genre: genre,
                    hasActiveRefData: !!window.__activeRefData,
                    hasTargets: !!window.__activeRefData?.targets,
                    targetSource: window.__activeRefData?.targetSource,
                    targetKeys: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets) : [],
                    targetSample: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets).slice(0, 3) : [],
                    lufs_target: window.__activeRefData?.lufs_target,
                    true_peak_target: window.__activeRefData?.true_peak_target,
                    version: window.__activeRefData?.version
                });
                
                __dbg('[GENRE_MODAL] âœ… applyGenreSelection concluÃ­do com sucesso');
            } else {
                error('[GENRE_MODAL] applyGenreSelection nÃ£o estÃ¡ disponÃ­vel');
                return;
            }
            
            // ğŸ”¥ Fechar modal conforme especificaÃ§Ã£o
            closeGenreModal();
            
            // ğŸ”¥ CONTINUAR FLUXO: Abrir modal de upload automaticamente
            // âœ… CORREÃ‡ÃƒO: Removido setTimeout - targets jÃ¡ estÃ£o carregados
            openAnalysisModalForGenre();
        });
    });
    
    // Handler do botÃ£o fechar
    if (closeBtn) {
        closeBtn.addEventListener('click', closeGenreModal);
    }
    
    // Fechar clicando no fundo
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeGenreModal();
        }
    });
    
    __dbg('[GENRE_MODAL] Sistema inicializado com sucesso');
}

// ğŸ¯ Abrir modal de anÃ¡lise apÃ³s seleÃ§Ã£o de gÃªnero
function openAnalysisModalForGenre() {
    __dbg('[GENRE_MODAL] Abrindo modal de anÃ¡lise para gÃªnero selecionado...');
    
    // Usar o fluxo normal do modal de anÃ¡lise
    window.currentAnalysisMode = 'genre';
    
    // ğŸ¯ LIMPAR estado de referÃªncia ao entrar em modo genre (conforme solicitado)
    const state = window.__soundyState || {};
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        log('âœ… [GENRE-CLEANUP] Estado de referÃªncia limpo ao iniciar modo genre');
    }
    window.__soundyState = state;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        error('[GENRE_MODAL] Modal de anÃ¡lise nÃ£o encontrado');
        return;
    }
    
    // Configurar modal para modo gÃªnero
    configureModalForMode('genre');
    
    modal.style.display = 'flex';
    
    // âœ… CORREÃ‡ÃƒO CRÃTICA: NÃƒO resetar gÃªnero/targets aqui!
    // Apenas limpar estado visual de upload (preserva gÃªnero selecionado)
    clearAudioOnlyState();
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    __dbg('[GENRE_MODAL] Modal de anÃ¡lise aberto (gÃªnero preservado)');
}

// Expor funÃ§Ãµes globalmente
window.openGenreModal = openGenreModal;
window.closeGenreModal = closeGenreModal;

// ï¿½ğŸ¯ NOVO: Abrir modal de anÃ¡lise configurado para o modo
function openAnalysisModalForMode(mode) {
    __dbg(`ğŸµ Abrindo modal de anÃ¡lise para modo: ${mode}`);
    
    // ğŸ†• FEATURE FLAG: Verificar se deve usar novo modal de gÃªnero
    if (mode === 'genre' && window.FEATURE_NEW_GENRE_MODAL === true) {
        __dbg('ğŸ¨ Usando novo modal de gÃªnero musical');
        openGenreModal();
        return;
    }
    
    // CORREÃ‡ÃƒO CRÃTICA: Definir window.currentAnalysisMode sempre que o modal for aberto
    // FIX: Guard para evitar sobrescrever reference por genre inadvertidamente
    const stateMachine = window.AnalysisStateMachine;
    const currentStateMode = stateMachine?.getMode();
    
    // Se state machine estÃ¡ em reference e modo solicitado Ã© diferente, alertar
    if (currentStateMode === 'reference' && mode !== 'reference') {
        warn('[REF_FIX] âš ï¸ Tentativa de abrir modal em modo', mode, 'mas state machine estÃ¡ em reference');
        warn('[REF_FIX] Mantendo modo reference para preservar estado');
        // NÃ£o sobrescrever - manter reference
        mode = 'reference';
    }
    
    window.currentAnalysisMode = mode;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        error('Modal de anÃ¡lise nÃ£o encontrado');
        return;
    }
    
    // Configurar modal baseado no modo
    configureModalForMode(mode);
    
    // Reset state especÃ­fico do modo
    if (mode === 'reference') {
        resetReferenceState();
    }
    
    modal.style.display = 'flex';
    
    // âœ… FIX 2: Reset seletivo baseado no modo
    if (mode === 'genre') {
        // Modo gÃªnero: apenas limpar visual (preserva gÃªnero)
        clearAudioOnlyState();
    } else if (mode === 'comparison') {
        // Modo comparison: pode resetar
        resetModalState();
    }
    // ğŸ”’ Reference NÃƒO reseta (preserva estado da state machine)
    
    log('[REF_FIX] openAnalysisModalForMode:', mode, '- Reset aplicado:', mode === 'genre' || mode === 'comparison');
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('analysis_modal_opened', { mode });
}

// ğŸ¯ NOVO: Configurar modal baseado no modo selecionado
function configureModalForMode(mode) {
    const title = document.getElementById('audioModalTitle');
    const subtitle = document.getElementById('audioModalSubtitle');
    const modeIndicator = document.getElementById('audioModeIndicator');
    const genreContainer = document.getElementById('audioRefGenreContainer');
    const progressSteps = document.getElementById('referenceProgressSteps');
    
    if (mode === 'genre') {
        // Modo GÃªnero: comportamento original
        if (title) title.textContent = 'ğŸµ AnÃ¡lise de Ãudio';
        if (subtitle) subtitle.style.display = 'none';
        if (genreContainer) genreContainer.style.display = 'flex';
        if (progressSteps) progressSteps.style.display = 'none';
        
        // ğŸ”§ FIX: Limpar dados de referÃªncia ao trocar para modo genre
        if (window.__referenceComparisonActive) {
            log('[MODE_CHANGE] Trocando de REFERENCE para GENRE - limpando dados');
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            window.__referenceComparisonActive = false;
            
            log('[MODE_CHANGE] âœ… Dados de referÃªncia limpos para modo GENRE');
        }
        
    } else if (mode === 'reference') {
        // Modo ReferÃªncia: interface especÃ­fica
        if (title) title.textContent = 'ğŸ¯ AnÃ¡lise por ReferÃªncia';
        if (subtitle) {
            subtitle.style.display = 'block';
            if (modeIndicator) {
                modeIndicator.textContent = 'ComparaÃ§Ã£o direta entre suas mÃºsicas';
            }
        }
        if (genreContainer) genreContainer.style.display = 'none';
        if (progressSteps) progressSteps.style.display = 'flex';
        
        // Configurar steps iniciais
        updateReferenceStep('userAudio');
    }
}

// ğŸ¯ NOVO: Reset estado do modo referÃªncia (compatibilidade)
function resetReferenceState() {
    // ğŸš¨ BLINDAGEM ABSOLUTA: NUNCA resetar em modo genre
    if (window.__CURRENT_MODE__ === 'genre') {
        warn('[GENRE-PROTECT] âš ï¸ resetReferenceState() BLOQUEADO em modo genre');
        warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        return; // NÃƒO executar reset
    }

    referenceStepState = {
        currentStep: 'userAudio',
        userAudioFile: null,
        referenceAudioFile: null,
        userAnalysis: null,
        referenceAnalysis: null
    };
    
    window.logReferenceEvent('reference_state_reset');
}

// ğŸ¯ FUNÃ‡ÃƒO AUXILIAR: Obter gÃªnero ativo de mÃºltiplas fontes
function getActiveGenre(analysis, fallback) {
    // ğŸ¯ PRIORIDADE CORRETA: Fontes diretas ANTES de data.genre
    const genre = analysis?.genre ||             // âœ… 1Âª prioridade: valor direto
                 analysis?.genreId ||            // âœ… 2Âª prioridade: ID do gÃªnero
                 analysis?.metadata?.genre ||    // âœ… 3Âª prioridade: metadata
                 analysis?.data?.genre ||        // âš ï¸ 4Âª prioridade: pode ser null (contaminado)
                 fallback;                       // âœ… 5Âª prioridade: fallback
    
    log('[GET-ACTIVE-GENRE] GÃªnero detectado:', genre, '(fallback:', fallback, ')');
    log('[GET-ACTIVE-GENRE] Fontes verificadas:', {
        'analysis.genre': analysis?.genre,
        'analysis.genreId': analysis?.genreId,
        'analysis.metadata.genre': analysis?.metadata?.genre,
        'analysis.data.genre': analysis?.data?.genre,
        'fallback': fallback,
        'final': genre
    });
    return genre;
}

// ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Limpeza COMPLETA do estado de referÃªncia para modo gÃªnero
function resetReferenceStateFully(preserveGenre) {
    // âœ… PROTEÃ‡ÃƒO: NÃ£o limpar targets no modo gÃªnero
    const currentMode = window.currentAnalysisMode;
    if (currentMode === 'genre') {
        log('%c[GENRE-ISOLATION] ğŸ›¡ï¸ Modo GENRE detectado - IGNORANDO reset de referÃªncia', 'color:#FFD700;font-weight:bold;font-size:14px;');
        log('[GENRE-ISOLATION] âœ… Targets de gÃªnero preservados (reset bloqueado)');
        log('[REF_FIX] ğŸ”’ FIX 4: Flag userExplicitlySelectedReferenceMode preservada (guard 100%)');
        // ğŸ”’ FIX 4: NÃƒO resetar flag aqui - guard deve proteger TUDO
        return; // Sai SEM tocar em nada
    }
    
    console.group('%c[GENRE-ISOLATION] ğŸ§¹ Limpeza completa do estado de referÃªncia', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Resetar flag ao limpar estado de referÃªncia (SÃ“ se passou do guard)
    persistReferenceFlag(false);
    log('%c[PROTECTION] âœ… Flag userExplicitlySelectedReferenceMode resetada em resetReferenceStateFully', 'color:#00FF88;font-weight:bold;');
    
    // ===============================================================
    // ğŸ”’ BLOCO 1 â€” PRESERVAR GÃŠNERO ANTES DO RESET (MÃšLTIPLAS FONTES)
    // ===============================================================
    let __PRESERVED_GENRE__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ = preserveGenre ||
                             window.__CURRENT_SELECTED_GENRE ||
                             window.PROD_AI_REF_GENRE ||
                             (genreSelect ? genreSelect.value : null) ||
                             window.__CURRENT_GENRE ||
                             window.__soundyState?.render?.genre ||
                             window.__activeUserGenre;

        log("[SAFE-RESET] âš ï¸ Preservando gÃªnero selecionado:", __PRESERVED_GENRE__);
    } catch (e) {
        warn("[SAFE-RESET] Falha ao capturar gÃªnero antes do reset:", e);
    }
    
    // ğŸ¯ SALVAR GÃŠNERO ANTES DE LIMPAR (compatibilidade com cÃ³digo existente)
    const __savedGenre = __PRESERVED_GENRE__;
    
    if (__savedGenre) {
        log('[GENRE-ISOLATION] ğŸ’¾ Salvando gÃªnero antes da limpeza:', __savedGenre);
    }
    
    // 1ï¸âƒ£ Limpar variÃ¡veis globais window - CRÃTICO
    log('[GENRE-ISOLATION] 1ï¸âƒ£ Limpando variÃ¡veis globais window...');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Salvar targets do gÃªnero preservado ANTES de limpar
    let __savedGenreTargets = null;
    if (__savedGenre) {
        // PROD_AI_REF_DATA pode ser dicionÃ¡rio ou objeto Ãºnico
        if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object') {
            if (window.PROD_AI_REF_DATA[__savedGenre]) {
                // Estrutura de dicionÃ¡rio
                __savedGenreTargets = window.PROD_AI_REF_DATA[__savedGenre];
                log('[GENRE-ISOLATION] ğŸ’¾ Targets do gÃªnero salvos (dicionÃ¡rio):', __savedGenre);
            } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
                // Objeto Ãºnico
                __savedGenreTargets = window.PROD_AI_REF_DATA;
                log('[GENRE-ISOLATION] ğŸ’¾ Targets salvos (objeto Ãºnico):', __savedGenre);
            }
        }
        // Fallback para __activeRefData
        if (!__savedGenreTargets && window.__activeRefData) {
            __savedGenreTargets = window.__activeRefData;
            log('[GENRE-ISOLATION] ğŸ’¾ Targets salvos de __activeRefData:', __savedGenre);
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar PROD_AI_REF_DATA para false (nÃ£o delete)
    window.PROD_AI_REF_DATA = false;
    log('   âœ… window.PROD_AI_REF_DATA: false');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Restaurar targets do gÃªnero preservado
    if (__savedGenre && __savedGenreTargets) {
        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
            window.PROD_AI_REF_DATA = {};
        }
        window.PROD_AI_REF_DATA[__savedGenre] = __savedGenreTargets;
        window.__activeRefData = __savedGenreTargets;
        log(`[GENRE-ISOLATION] ğŸ”„ Targets restaurados para gÃªnero: ${__savedGenre}`);
        log('   âœ… window.PROD_AI_REF_DATA[' + __savedGenre + ']: restaurado');
        log('   âœ… window.__activeRefData: restaurado com targets do gÃªnero');
    } else {
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __activeRefData apenas se nÃ£o houver gÃªnero preservado
        window.__activeRefData = null;
        log('   âœ… window.__activeRefData: null');
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __REFERENCE_JOB_ID__
    SOUNDY_MODE_ENGINE.clear();
    delete window.__REFERENCE_JOB_ID__;
    log('   âœ… window.__REFERENCE_JOB_ID__: removido');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __REFERENCE_FILE_KEY__
    window.__REFERENCE_FILE_KEY__ = null;
    log('   âœ… window.__REFERENCE_FILE_KEY__: null');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __CURRENT_JOB_ID__
    window.__CURRENT_JOB_ID__ = null;
    log('   âœ… window.__CURRENT_JOB_ID__: null');
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Resetar __activeUserData
    window.__activeUserData = null;
    log('   âœ… window.__activeUserData: null');
    
    delete window.referenceAnalysisData;
    window.__referenceComparisonActive = false;
    window.__FIRST_ANALYSIS_FROZEN__ = undefined;
    log('   âœ… window.referenceAnalysisData: removido');
    log('   âœ… window.__referenceComparisonActive: false');
    
    // 2ï¸âƒ£ Limpar __soundyState
    log('[GENRE-ISOLATION] 2ï¸âƒ£ Limpando window.__soundyState...');
    if (window.__soundyState) {
        delete window.__soundyState.reference;
        delete window.__soundyState.referenceAnalysis;
        delete window.__soundyState.previousAnalysis;
        if (window.__soundyState.render) {
            window.__soundyState.render.mode = 'genre';
        }
        log('   âœ… __soundyState.reference: removido');
        log('   âœ… __soundyState.referenceAnalysis: removido');
        log('   âœ… __soundyState.render.mode: forÃ§ado para "genre"');
    }
    
    // 3ï¸âƒ£ Limpar localStorage
    log('[GENRE-ISOLATION] 3ï¸âƒ£ Limpando localStorage...');
    try {
        localStorage.removeItem('referenceJobId');
        localStorage.removeItem('referenceAnalysis');
        log('   âœ… localStorage.referenceJobId: removido');
        log('   âœ… localStorage.referenceAnalysis: removido');
    } catch (e) {
        warn('   âš ï¸ Falha ao limpar localStorage:', e.message);
    }
    
    // 4ï¸âƒ£ Limpar sessionStorage
    log('[GENRE-ISOLATION] 4ï¸âƒ£ Limpando sessionStorage...');
    try {
        sessionStorage.removeItem('referenceJobId');
        sessionStorage.removeItem('referenceAnalysis');
        log('   âœ… sessionStorage.referenceJobId: removido');
        log('   âœ… sessionStorage.referenceAnalysis: removido');
    } catch (e) {
        warn('   âš ï¸ Falha ao limpar sessionStorage:', e.message);
    }
    
    // 5ï¸âƒ£ Limpar Store (se existir)
    log('[GENRE-ISOLATION] 5ï¸âƒ£ Limpando SoundyAI_Store...');
    if (window.SoundyAI_Store) {
        delete window.SoundyAI_Store.first;
        delete window.SoundyAI_Store.second;
        log('   âœ… SoundyAI_Store.first: removido');
        log('   âœ… SoundyAI_Store.second: removido');
    }
    
    // 6ï¸âƒ£ Resetar referenceStepState
    log('[GENRE-ISOLATION] 6ï¸âƒ£ Resetando referenceStepState...');
    if (typeof referenceStepState !== 'undefined') {
        referenceStepState = {
            currentStep: 'userAudio',
            userAudioFile: null,
            referenceAudioFile: null,
            userAnalysis: null,
            referenceAnalysis: null
        };
        log('   âœ… referenceStepState: resetado');
    }
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Resetar flag de renderizaÃ§Ã£o de IA
    // Permite que o mÃ³dulo de sugestÃµes seja re-renderizado apÃ³s limpeza
    log('[GENRE-ISOLATION] 7ï¸âƒ£ Resetando flags de renderizaÃ§Ã£o de IA...');
    window.__AI_RENDER_COMPLETED__ = false;
    log('   âœ… window.__AI_RENDER_COMPLETED__: false (permitir re-renderizaÃ§Ã£o)');
    
    // ğŸ¯ RESTAURAR GÃŠNERO APÃ“S LIMPEZA
    if (__savedGenre) {
        log('[GENRE-ISOLATION] ğŸ”„ Restaurando gÃªnero:', __savedGenre);
        window.__CURRENT_GENRE = __savedGenre;
        
        if (!window.__soundyState) {
            window.__soundyState = {};
        }
        if (!window.__soundyState.render) {
            window.__soundyState.render = {};
        }
        
        window.__soundyState.render.genre = __savedGenre;
        window.__activeUserGenre = __savedGenre;
        window.PROD_AI_REF_GENRE = __savedGenre;  // âœ… CORREÃ‡ÃƒO: Sincronizar PROD_AI_REF_GENRE
        
        log('   âœ… window.__CURRENT_GENRE:', __savedGenre);
        log('   âœ… window.__soundyState.render.genre:', __savedGenre);
        log('   âœ… window.__activeUserGenre:', __savedGenre);
        log('   âœ… window.PROD_AI_REF_GENRE:', __savedGenre);
    }
    
    // ===============================================================
    // ğŸ”’ BLOCO 3 â€” RESTAURAR GÃŠNERO NO DROPDOWN APÃ“S O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;
            window.__CURRENT_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            log("[SAFE-RESET] âœ… GÃªnero restaurado no dropdown apÃ³s reset:", __PRESERVED_GENRE__);
        } else {
            warn("[SAFE-RESET] âš ï¸ Nenhum gÃªnero vÃ¡lido preservado para dropdown.");
        }
    } catch (e) {
        warn("[SAFE-RESET] Falha ao restaurar gÃªnero no dropdown:", e);
    }
    
    log('%c[GENRE-ISOLATION] âœ… Estado de referÃªncia completamente limpo', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

// ========================================
// ğŸ”¥ UI HELPERS - SHOW/HIDE SEÃ‡Ã•ES
// ========================================

function hideReferenceUI() {
    log('[UI-CONTROL] ğŸ™ˆ Ocultando elementos de UI de referÃªncia...');
    
    // Ocultar elementos especÃ­ficos de referÃªncia
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            log(`[UI-CONTROL]    âœ… Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showGenreUI() {
    log('[UI-CONTROL] ğŸ‘ï¸ Exibindo elementos de UI de gÃªnero...');
    
    // Exibir elementos especÃ­ficos de gÃªnero
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            log(`[UI-CONTROL]    âœ… Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

function hideGenreUI() {
    log('[UI-CONTROL] ğŸ™ˆ Ocultando elementos de UI de gÃªnero...');
    
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            log(`[UI-CONTROL]    âœ… Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showReferenceUI() {
    log('[UI-CONTROL] ğŸ‘ï¸ Exibindo elementos de UI de referÃªncia...');
    
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            log(`[UI-CONTROL]    âœ… Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

// ========================================
// ğŸ”¥ RENDERIZAÃ‡ÃƒO ISOLADA DE GÃŠNERO
// ========================================

// ğŸ¯ MÃ“DULO DE CONVERSÃƒO DE BANDAS (EXCLUSIVO PARA MODO GÃŠNERO)
// ========================================
/**
 * Converte nomes de bandas do backend para o formato esperado pelos targets de gÃªnero.
 * 
 * Backend envia: sub, bass, lowMid, mid, highMid, presence, air
 * Targets esperam: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
 * 
 * âš ï¸ USO EXCLUSIVO: Apenas para analysis.mode === "genre"
 * âŒ NUNCA usar para: mode === "reference", A/B, referenceComparison
 * 
 * @param {Object} bands - Bandas do backend (analysis.bands)
 * @returns {Object} Bandas convertidas para formato de targets de gÃªnero
 */
// ğŸ¯ SISTEMA DE ALIAS DE BANDAS (branch imersao)
const BAND_ALIASES = {
    'bass': ['low_bass', 'upper_bass'],
    'lowMid': ['low_mid'],
    'highMid': ['high_mid'],
    'presence': ['presenca'],
    'air': ['brilho']
};

/**
 * Busca banda com suporte a alias (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} bandsObject - Objeto com bandas
 * @returns {Object|null} Dados da banda ou null
 */
function searchBandWithAlias(bandKey, bandsObject) {
    if (!bandsObject || typeof bandsObject !== 'object') return null;
    
    // 1. Busca direta
    if (bandsObject[bandKey]) {
        return bandsObject[bandKey];
    }
    
    // 2. Busca por alias
    const aliases = BAND_ALIASES[bandKey];
    if (aliases) {
        for (const alias of aliases) {
            if (bandsObject[alias]) {
                log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias}`);
                return bandsObject[alias];
            }
        }
    }
    
    return null;
}

/**
 * Busca banda em mÃºltiplas fontes com cascata (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @returns {Object|null} Dados da banda com source
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FONTE ÃšNICA DA VERDADE: buildMetricRows()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * ğŸ“Š FUNÃ‡ÃƒO COMPARTILHADA: Gera rows de mÃ©tricas e bandas para TABELA e MODAL.
 * 
 * REGRAS OBRIGATÃ“RIAS:
 * 1. BANDAS: Se target_range existe, usar SOMENTE min/max (NÃƒO aplicar tolerÃ¢ncia)
 * 2. BANDAS: Fallback para target_db Â± tol_db SOMENTE se target_range ausente
 * 3. MÃ‰TRICAS: Sempre usar target Â± tolerance
 * 4. SEVERIDADE: Mesma lÃ³gica em todos os casos (calcSeverity)
 * 5. ALIAS: upper_bass â†’ bass (nÃ£o aparece como key final)
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @param {Object} targets - Targets de gÃªnero ou referÃªncia
 * @param {string} mode - 'genre' ou 'reference'
 * @returns {Array<Object>} rows com { key, type, label, value, targetText, min, max, target, delta, severity, severityClass, actionText, category }
 */
window.buildMetricRows = function(analysis, targets, mode = 'genre') {
    console.group('[BUILD_ROWS] ğŸ—ï¸ Construindo rows compartilhados');
    log('[BUILD_ROWS] Mode:', mode);
    log('[BUILD_ROWS] Targets:', targets ? Object.keys(targets) : 'null');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ PRIORIDADE 1: Usar comparisonResult do backend (FONTE ÃšNICA DA VERDADE)
    // Se disponÃ­vel, retornar diretamente sem cÃ¡lculo local
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const comparisonResult = analysis?.data?.comparisonResult;
    if (comparisonResult && Array.isArray(comparisonResult.rows) && comparisonResult.rows.length > 0) {
        log('[BUILD_ROWS] ğŸ¯ Usando comparisonResult do backend (FONTE ÃšNICA)');
        log('[BUILD_ROWS] Rows do backend:', comparisonResult.rows.length);
        
        // Adaptar formato se necessÃ¡rio (actionText vs action)
        const adaptedRows = comparisonResult.rows.map(row => ({
            ...row,
            actionText: row.action || row.actionText || 'â€”'
        }));
        
        console.groupEnd();
        return adaptedRows;
    }
    
    log('[BUILD_ROWS] âš ï¸ comparisonResult nÃ£o disponÃ­vel, usando cÃ¡lculo local');
    
    const rows = [];
    
    // âœ… FLAG DE CONTROLE
    if (!window.USE_TABLE_ROWS_FOR_MODAL) {
        warn('[BUILD_ROWS] âš ï¸ Flag USE_TABLE_ROWS_FOR_MODAL = false, usando lÃ³gica antiga');
        console.groupEnd();
        return rows;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”„ FALLBACK: Usar targets normalizados do backend
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const normalizedTargets = getNormalizedTargetsFromAnalysis(analysis);
    const useNormalizedTargets = normalizedTargets !== null;
    
    if (useNormalizedTargets) {
        log('[BUILD_ROWS] âœ… Usando referenceTargetsNormalized do backend');
    } else {
        log('[BUILD_ROWS] âš ï¸ Usando targets locais (fallback)');
    }
    
    // ğŸ¯ ALIAS MAP: upper_bass â†’ bass (nÃ£o aparece como key final)
    const BAND_ALIAS_MAP = {
        'upper_bass': 'bass',
        'low_bass': 'bass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // ğŸ¯ LISTA CANÃ”NICA DE BANDAS (ordem LOW END â†’ MID â†’ HIGH)
    // âš ï¸ CORREÃ‡ÃƒO: FrequÃªncias alinhadas com padrÃ£o do projeto
    // air = Brilho (4k-10k Hz), presence = PresenÃ§a (10k-20k Hz)
    const CANONICAL_BANDS = [
        { key: 'sub', label: 'ğŸ”‰ Sub (20-60 Hz)', category: 'LOW END' },
        { key: 'bass', label: 'ğŸ”Š Bass (60-150 Hz)', category: 'LOW END' },
        { key: 'lowMid', label: 'ğŸµ Low Mid (150-500 Hz)', category: 'MID' },
        { key: 'mid', label: 'ğŸµ Mid (500-2k Hz)', category: 'MID' },
        { key: 'highMid', label: 'ğŸ¸ High Mid (2k-4k Hz)', category: 'HIGH' },
        { key: 'air', label: 'âœ¨ Brilho (4k-10k Hz)', category: 'HIGH' },
        { key: 'presence', label: 'ğŸ’ PresenÃ§a (10k-20k Hz)', category: 'HIGH' }
    ];
    
    // ğŸ¯ HELPER: Calcular severidade (usando evaluateMetric como Single Source of Truth)
    const calcSeverity = (value, target, tolerance, options = {}) => {
        const { targetRange } = options;
        
        if (!Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        // Construir targetSpec para evaluateMetric
        let targetSpec = {};
        
        if (targetRange && typeof targetRange === 'object') {
            const min = targetRange.min ?? targetRange.min_db;
            const max = targetRange.max ?? targetRange.max_db;
            if (typeof min === 'number' && typeof max === 'number') {
                targetSpec = { min, max, tol: tolerance || 2.0 };
            }
        }
        
        // Se nÃ£o tem range, usar target Â± tol
        if (!targetSpec.min && !targetSpec.max) {
            if (target !== null && target !== undefined) {
                targetSpec = { target, tol: tolerance || 1.0 };
            } else {
                return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
            }
        }
        
        // ğŸ¯ Usar evaluateMetricForTable (SINGLE SOURCE OF TRUTH)
        return window.evaluateMetricForTable('metric', value, targetSpec);
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1ï¸âƒ£ MÃ‰TRICAS PRINCIPAIS - AGORA COM SUPORTE A MIN/MAX EXPLÃCITO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const genreData = targets;
    const technicalData = analysis.technicalData || {};
    
    // ğŸ”Š LUFS - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.lufs_target != null && Number.isFinite(technicalData.lufsIntegrated)) {
        
        // ğŸ¯ PRIORIDADE 1: Usar severidade prÃ©-calculada do backend (FONTE ÃšNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'lufs') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.lufs) {
            // Usar targets normalizados do backend
            const lufs = normalizedTargets.metrics.lufs;
            min = lufs.min;
            max = lufs.max;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} LUFS`;
            log(`[BUILD_ROWS] âœ… LUFS: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // Fallback: calcular localmente
            const lufsBounds = getMetricBounds(genreData, 'lufs');
            
            if (lufsBounds && lufsBounds.mode === 'minmax') {
                min = lufsBounds.min;
                max = lufsBounds.max;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} LUFS`;
                log(`[BUILD_ROWS] âš ï¸ LUFS: usando min/max local [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else {
                // Fallback para target Â± tol
                min = genreData.lufs_target - (genreData.tol_lufs || 1.0);
                max = genreData.lufs_target + (genreData.tol_lufs || 1.0);
                targetText = `${genreData.lufs_target.toFixed(1)} LUFS`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // ğŸ¯ USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÃTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            log(`[BUILD_ROWS] âœ… LUFS: severidade do backend = ${result.severity}`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            result = calcSeverity(technicalData.lufsIntegrated, genreData.lufs_target, genreData.tol_lufs || 1.0, 
                { targetRange: { min, max } });
        }
        
        rows.push({
            key: 'lufsIntegrated',
            type: 'metric',
            label: 'ğŸ”Š Loudness (LUFS)',
            value: technicalData.lufsIntegrated,
            targetText,
            min,
            max,
            target: genreData.lufs_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // ğŸšï¸ True Peak - AGORA COM SUPORTE A true_peak_min/true_peak_max
    // ğŸš¨ REGRA CRÃTICA: true_peak_max NUNCA pode ser > 0 dBTP
    if (genreData.true_peak_target != null && Number.isFinite(technicalData.truePeakDbtp)) {
        
        // ğŸ¯ PRIORIDADE 1: Usar severidade prÃ©-calculada do backend (FONTE ÃšNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'truePeak') : null;
        
        // Extrair bounds
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.truePeak) {
            // Usar targets normalizados do backend
            const tp = normalizedTargets.metrics.truePeak;
            min = tp.min;
            max = Math.min(tp.max, TRUE_PEAK_HARD_CAP); // ğŸš¨ GARANTIR HARD CAP
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dBTP`;
            log(`[BUILD_ROWS] âœ… True Peak: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}] hardCap=${tp.hardCap}`);
        } else {
            // Fallback: calcular localmente
            const tpBounds = getMetricBounds(genreData, 'true_peak');
            
            if (tpBounds && tpBounds.mode === 'minmax') {
                min = tpBounds.min;
                max = Math.min(tpBounds.max, TRUE_PEAK_HARD_CAP); // ğŸš¨ NUNCA > 0 dBTP
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dBTP`;
            } else {
                min = genreData.true_peak_target - (genreData.tol_true_peak || 0.5);
                max = Math.min(genreData.true_peak_target + (genreData.tol_true_peak || 0.5), TRUE_PEAK_HARD_CAP);
                targetText = `${genreData.true_peak_target.toFixed(1)} dBTP`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // ğŸ¯ USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÃTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            log(`[BUILD_ROWS] âœ… True Peak: severidade do backend = ${result.severity}`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            result = calculateTruePeakSeverityLocal(technicalData.truePeakDbtp, normalizedTargets || genreData);
        }
        
        rows.push({
            key: 'truePeak',
            type: 'metric',
            label: 'ğŸšï¸ True Peak (dBTP)',
            value: technicalData.truePeakDbtp,
            targetText,
            min,
            max,
            target: genreData.true_peak_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets // Debug: indicar fonte
        });
    }
    
    // ğŸ“Š DR - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.dr_target != null && Number.isFinite(technicalData.dynamicRange)) {
        
        // ğŸ¯ PRIORIDADE 1: Usar severidade prÃ©-calculada do backend (FONTE ÃšNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'dr') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.dr) {
            // Usar targets normalizados do backend
            const dr = normalizedTargets.metrics.dr;
            min = dr.min;
            max = dr.max;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} DR`;
            log(`[BUILD_ROWS] âœ… DR: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // Fallback: calcular localmente
            const drBounds = getMetricBounds(genreData, 'dr');
            
            if (drBounds && drBounds.mode === 'minmax') {
                min = drBounds.min;
                max = drBounds.max;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} DR`;
                log(`[BUILD_ROWS] âš ï¸ DR: usando min/max local [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else {
                // Fallback para target Â± tol
                min = genreData.dr_target - (genreData.tol_dr || 1.0);
                max = genreData.dr_target + (genreData.tol_dr || 1.0);
                targetText = `${genreData.dr_target.toFixed(1)} DR`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // ğŸ¯ USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÃTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            log(`[BUILD_ROWS] âœ… DR: severidade do backend = ${result.severity}`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            result = calcSeverity(technicalData.dynamicRange, genreData.dr_target, genreData.tol_dr || 1.0,
                { targetRange: { min, max } });
        }
        
        rows.push({
            key: 'dr',
            type: 'metric',
            label: 'ğŸ“Š Dynamic Range (DR)',
            value: technicalData.dynamicRange,
            targetText,
            min,
            max,
            target: genreData.dr_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // ğŸ§ Stereo - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.stereo_target != null && Number.isFinite(technicalData.stereoCorrelation)) {
        
        // ğŸ¯ PRIORIDADE 1: Usar severidade prÃ©-calculada do backend (FONTE ÃšNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'stereo') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.stereo) {
            // Usar targets normalizados do backend
            const stereo = normalizedTargets.metrics.stereo;
            min = stereo.min;
            max = stereo.max;
            targetText = `${min.toFixed(3)} a ${max.toFixed(3)}`;
            log(`[BUILD_ROWS] âœ… Stereo: usando normalizedTargets [${min.toFixed(3)}, ${max.toFixed(3)}]`);
        } else {
            // Fallback: calcular localmente
            min = genreData.stereo_target - (genreData.tol_stereo || 0.1);
            max = genreData.stereo_target + (genreData.tol_stereo || 0.1);
            targetText = `${genreData.stereo_target.toFixed(3)}`;
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // ğŸ¯ USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÃTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            log(`[BUILD_ROWS] âœ… Stereo: severidade do backend = ${result.severity}`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            result = calcSeverity(technicalData.stereoCorrelation, genreData.stereo_target, genreData.tol_stereo || 0.1);
        }
        
        rows.push({
            key: 'stereo',
            type: 'metric',
            label: 'ğŸ§ Stereo Correlation',
            value: technicalData.stereoCorrelation,
            targetText,
            min,
            max,
            target: genreData.stereo_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2ï¸âƒ£ BANDAS ESPECTRAIS - COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const userBands = technicalData.spectral_balance || technicalData.bands || analysis.bands || {};
    const targetBands = genreData.bands || genreData.spectral_bands || {};
    
    // ğŸ¯ Usar bandas normalizadas do backend se disponÃ­veis
    const normalizedBands = useNormalizedTargets ? normalizedTargets.bands : null;
    
    log('[BUILD_ROWS] ğŸµ Processando bandas:');
    log('[BUILD_ROWS]   - userBands keys:', Object.keys(userBands));
    log('[BUILD_ROWS]   - targetBands keys:', Object.keys(targetBands));
    log('[BUILD_ROWS]   - normalizedBands:', normalizedBands ? Object.keys(normalizedBands) : 'N/A');
    
    let bandsProcessed = 0;
    let bandsMissing = [];
    
    CANONICAL_BANDS.forEach(bandInfo => {
        const bandKey = bandInfo.key;
        
        // ğŸ” PRIORIDADE 1: Verificar se temos severidade prÃ©-calculada para esta banda
        const preCalcBandSeverity = useNormalizedTargets ? 
            getBandSeverityFromNormalized(normalizedTargets, bandKey) : null;
        
        // ğŸ” Buscar target (do backend normalizado ou local)
        let normalizedBand = normalizedBands?.[bandKey];
        let targetBand = targetBands[bandKey];
        
        if (!targetBand && !normalizedBand) {
            // Buscar por alias reverso (ex: 'bass' pode estar como 'low_bass' no target)
            const reverseAliases = {
                'bass': ['low_bass', 'upper_bass'],
                'lowMid': ['low_mid'],
                'highMid': ['high_mid'],
                'presence': ['presenca'],
                'air': ['brilho']
            };
            const aliases = reverseAliases[bandKey];
            if (aliases) {
                for (const alias of aliases) {
                    if (targetBands[alias]) {
                        targetBand = targetBands[alias];
                        log(`[BUILD_ROWS] ğŸ”„ Alias encontrado: ${bandKey} â† ${alias}`);
                        break;
                    }
                    if (normalizedBands?.[alias]) {
                        normalizedBand = normalizedBands[alias];
                        log(`[BUILD_ROWS] ğŸ”„ Normalized alias: ${bandKey} â† ${alias}`);
                        break;
                    }
                }
            }
        }
        
        if (!targetBand && !normalizedBand) {
            log(`[BUILD_ROWS] â­ï¸ Banda sem target: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // ğŸ” Buscar valor do usuÃ¡rio (mesma lÃ³gica anterior)
        const reverseAliases = {
            'bass': ['low_bass', 'upper_bass'],
            'lowMid': ['low_mid'],
            'highMid': ['high_mid'],
            'presence': ['presenca'],
            'air': ['brilho']
        };
        
        let bandData = userBands[bandKey];
        if (!bandData && reverseAliases[bandKey]) {
            for (const alias of reverseAliases[bandKey]) {
                if (userBands[alias]) {
                    bandData = userBands[alias];
                    log(`[BUILD_ROWS] ğŸ”„ User alias: ${bandKey} â† ${alias}`);
                    break;
                }
            }
        }
        
        if (!bandData) {
            log(`[BUILD_ROWS] â­ï¸ Banda sem dados user: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // Extrair valor
        let energyDb = typeof bandData === 'number' ? bandData : (bandData.energy_db ?? bandData.rms_db ?? null);
        if (!Number.isFinite(energyDb)) {
            log(`[BUILD_ROWS] â­ï¸ Banda sem valor numÃ©rico: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // ğŸ¯ PRIORIDADE 1: Usar targets normalizados do backend
        let targetText, min, max, target;
        
        if (normalizedBand) {
            // âœ… USAR TARGETS NORMALIZADOS DO BACKEND (FONTE ÃšNICA)
            min = normalizedBand.min;
            max = normalizedBand.max;
            target = normalizedBand.target;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dB`;
            log(`[BUILD_ROWS] âœ… ${bandKey}: normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            const targetRange = targetBand.target_range || targetBand.targetRange;
            
            if (targetRange && (typeof targetRange.min === 'number' || typeof targetRange.min_db === 'number')) {
                // âœ… Usar range explÃ­cito (NUNCA aplicar tolerÃ¢ncia)
                min = targetRange.min ?? targetRange.min_db;
                max = targetRange.max ?? targetRange.max_db;
                target = (min + max) / 2;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dB`;
                log(`[BUILD_ROWS] âš ï¸ ${bandKey}: fallback target_range [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else if (typeof targetBand.target_db === 'number') {
                // ğŸ”„ Fallback: target_db Â± tol_db
                target = targetBand.target_db;
                const tolerance = targetBand.tol_db ?? 2.0;
                min = target - tolerance;
                max = target + tolerance;
                targetText = `${target.toFixed(1)} dB (Â±${tolerance.toFixed(1)})`;
                log(`[BUILD_ROWS] âš ï¸ ${bandKey}: fallback target_db Â± tol_db`);
            } else {
                log(`[BUILD_ROWS] âŒ Banda sem target vÃ¡lido: ${bandKey}`);
                bandsMissing.push(bandKey);
                return;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcBandSeverity) {
            // ğŸ¯ USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcBandSeverity.severity,
                severityClass: preCalcBandSeverity.severity === 'CRÃTICA' ? 'critical' : 
                              preCalcBandSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcBandSeverity.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
                action: preCalcBandSeverity.action,
                diff: preCalcBandSeverity.delta
            };
            log(`[BUILD_ROWS] âœ… ${bandKey}: severidade do backend = ${result.severity}`);
        } else {
            // ğŸ”„ FALLBACK: calcular localmente
            result = calcSeverity(energyDb, target, null, { targetRange: { min, max } });
        }
        
        rows.push({
            key: bandKey,
            type: 'band',
            label: bandInfo.label,
            value: energyDb,
            targetText,
            min,
            max,
            target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: bandInfo.category,
            _sourceNormalized: !!normalizedBand
        });
        
        bandsProcessed++;
        log(`[BUILD_ROWS] âœ… ${bandKey}: ${energyDb.toFixed(2)} dB | ${result.severity} | normalized=${!!normalizedBand}`);
    });
    
    // ğŸ“Š LOGS DE VALIDAÃ‡ÃƒO
    log('[BUILD_ROWS] ğŸ“Š RESULTADO:');
    log(`[BUILD_ROWS]   - Total rows: ${rows.length}`);
    log(`[BUILD_ROWS]   - Bandas processadas: ${bandsProcessed}/7`);
    log(`[BUILD_ROWS]   - Bandas missing: ${bandsMissing.length}`, bandsMissing);
    log(`[BUILD_ROWS]   - Rows nÃ£o-OK: ${rows.filter(r => r.severity !== 'OK').length}`);
    console.groupEnd();
    
    return rows;
};

// âœ… FLAG GLOBAL
window.USE_TABLE_ROWS_FOR_MODAL = true;

/**
 * Normaliza nomes de bandas do backend para formato dos targets de gÃªnero.
 * Backend: ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air']
 * Targets: ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca']
 */
function normalizeGenreBandName(name) {
    // ğŸ¯ PATCH DEFINITIVO: Backend JÃ normalizou (low_bass â†’ bass, presenca â†’ presence, etc.)
    // NÃ£o converter novamente! Apenas garantir compatibilidade com snake_case legado
    const map = {
        // Se ainda receber snake_case (compatibilidade), converter para camelCase
        'low_bass': 'bass',
        'upper_bass': 'upperBass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air',
        // CamelCase jÃ¡ normalizado - retornar como estÃ¡
        'bass': 'bass',
        'upperBass': 'upperBass',
        'lowMid': 'lowMid',
        'highMid': 'highMid',
        'presence': 'presence',
        'air': 'air',
        'sub': 'sub',
        'mid': 'mid'
    };
    return map[name] || name;
}

function getBandDataWithCascade(bandKey, analysis) {
    // ğŸ¯ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    
    // 1. Prioridade: analysis.metrics.bands (centralizado - mantido por compatibilidade)
    if (analysis.metrics?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.metrics.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'centralized' 
            };
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO: 2. analysis.technicalData.bands (caminho REAL do backend - prioridade 2)
    if (analysis.technicalData?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'technical' 
            };
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO: 3. analysis.technicalData.spectral_balance (fonte real - alias de bands)
    if (analysis.technicalData?.spectral_balance) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectral_balance);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectral_balance' 
            };
        }
    }
    
    // 4. Fallback: tech.bandEnergies (legado)
    if (analysis.technicalData?.bandEnergies) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bandEnergies);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'legacy' 
            };
        }
    }
    
    // 5. Fallback: tech.spectralBands (legado)
    if (analysis.technicalData?.spectralBands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectralBands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectralBands' 
            };
        }
    }
    
    return null;
}

function mapBackendBandsToGenreBands(bands) {
    if (!bands || typeof bands !== 'object') {
        warn('[BAND-MAPPER] âš ï¸ Bandas invÃ¡lidas recebidas:', bands);
        return {};
    }
    
    console.group('[BAND-MAPPER] ğŸ”„ Convertendo bandas do backend para formato de gÃªnero');
    log('[BAND-MAPPER] Bandas originais (backend):', Object.keys(bands));
    
    const mapped = {
        // Mapeamento direto (mesma chave)
        sub: bands.sub || null,
        mid: bands.mid || null,
        
        // ConversÃµes necessÃ¡rias
        low_bass: bands.bass || null,           // bass â†’ low_bass
        upper_bass: null,                       // âŒ nÃ£o existe no backend atual
        low_mid: bands.lowMid || null,          // lowMid â†’ low_mid
        high_mid: bands.highMid || null,        // highMid â†’ high_mid
        brilho: bands.air || null,              // air â†’ brilho
        presenca: bands.presence || null        // presence â†’ presenca
    };
    
    log('[BAND-MAPPER] Bandas convertidas (targets):', Object.keys(mapped).filter(k => mapped[k] !== null));
    log('[BAND-MAPPER] Bandas ausentes:', Object.keys(mapped).filter(k => mapped[k] === null));
    console.groupEnd();
    
    return mapped;
}

/**
 * Aplica conversÃ£o de bandas EXCLUSIVAMENTE para modo gÃªnero.
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise completo
 * @returns {Object} AnÃ¡lise com bandas convertidas (analysis.genreBands)
 */
function applyGenreBandConversion(analysis) {
    // ğŸ›¡ï¸ GUARD: Apenas para modo gÃªnero
    if (analysis?.mode !== 'genre') {
        log('[BAND-MAPPER] â­ï¸ Modo nÃ£o Ã© gÃªnero, pulando conversÃ£o');
        return analysis;
    }
    
    console.group('[BAND-MAPPER] ğŸ¯ Aplicando conversÃ£o de bandas para modo GÃŠNERO');
    log('[BAND-MAPPER] Mode:', analysis.mode);
    log('[BAND-MAPPER] Bandas originais:', analysis.bands ? Object.keys(analysis.bands) : 'N/A');
    
    // Converter bandas do backend para formato de targets
    if (analysis.bands) {
        analysis.genreBands = mapBackendBandsToGenreBands(analysis.bands);
        log('[BAND-MAPPER] âœ… analysis.genreBands criado com', Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null).length, 'bandas');
    } else {
        warn('[BAND-MAPPER] âš ï¸ analysis.bands nÃ£o disponÃ­vel');
        analysis.genreBands = {};
    }
    
    console.groupEnd();
    return analysis;
}

function renderGenreView(analysis) {
    console.group('%c[GENRE-VIEW] ğŸ¨ Renderizando UI exclusiva de gÃªnero', 'color:#00C9FF;font-weight:bold;font-size:14px;');
    
    // ğŸ”¥ ISOLAMENTO TOTAL: Limpar TODAS as variÃ¡veis de referÃªncia
    log('[GENRE-VIEW] ğŸ§¹ LIMPANDO variÃ¡veis de referÃªncia...');
    analysis.referenceComparison = undefined;
    analysis.referenceComparisonMetrics = undefined;
    window.referenceComparisonMetrics = null;
    log('[GENRE-VIEW] âœ… VariÃ¡veis de referÃªncia limpas');
    
    // 1ï¸âƒ£ Validar anÃ¡lise
    if (!analysis) {
        error('[GENRE-VIEW] âŒ ERRO: AnÃ¡lise nÃ£o fornecida');
        console.groupEnd();
        return;
    }
    
    // 2ï¸âƒ£ Garantir limpeza completa
    log('[GENRE-VIEW] 1ï¸âƒ£ Executando limpeza preventiva...');
    // ğŸ¯ PRESERVAR GÃŠNERO durante o reset - USANDO extractGenreName
    const genreToPreserve = extractGenreName(analysis) || window.PROD_AI_REF_GENRE;
    resetReferenceStateFully(genreToPreserve);
    
    // ğŸ¯ GARANTIR que analysis.genre estÃ¡ definido
    if (genreToPreserve && !analysis.genre) {
        analysis.genre = genreToPreserve;
    }
    
    // 3ï¸âƒ£ Configurar ViewMode
    log('[GENRE-VIEW] 2ï¸âƒ£ Configurando ViewMode...');
    setViewMode("genre");
    
    // 4ï¸âƒ£ Controlar UI visibility
    log('[GENRE-VIEW] 3ï¸âƒ£ Controlando visibilidade de UI...');
    hideReferenceUI();
    showGenreUI();
    
    // 5ï¸âƒ£ Obter gÃªnero - USANDO NOVA FUNÃ‡ÃƒO GENRE-ONLY
    const genre = extractGenreName(analysis) || 'default';
    
    log('[GENRE-VIEW] 4ï¸âƒ£ GÃªnero identificado:', genre);
    
    // ğŸ¯ CONVERSÃƒO DE BANDAS: Backend â†’ Targets de gÃªnero
    log('[GENRE-VIEW] ğŸ”„ Aplicando conversÃ£o de bandas...');
    applyGenreBandConversion(analysis);
    log('[GENRE-VIEW] âœ… Bandas convertidas:', analysis.genreBands ? Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null) : 'N/A');
    
    // 6ï¸âƒ£ Obter targets de gÃªnero - SEMPRE USAR PROD_AI_REF_DATA COMO BASE
    // ğŸ¯ ESTRATÃ‰GIA: PROD_AI_REF_DATA[genre] tem TODAS as mÃ©tricas (DR, LRA, Stereo, Bandas)
    //    Depois aplicamos streaming override APENAS em LUFS e TP se necessÃ¡rio
    
    let genreTargets = null;
    
    // ğŸ¯ PRIORIDADE 1: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
    if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
        genreTargets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
        log('[GENRE-VIEW] ğŸ“¦ Targets BASE obtidos de PROD_AI_REF_DATA[genre]');
    }
    
    // ğŸ¯ FALLBACK: __activeRefData
    if (!genreTargets && window.__activeRefData) {
        genreTargets = JSON.parse(JSON.stringify(window.__activeRefData));
        log('[GENRE-VIEW] ğŸ“¦ Targets obtidos de __activeRefData (fallback)');
    }
    
    // ğŸ¯ FALLBACK 2: extractGenreTargets
    if (!genreTargets) {
        genreTargets = extractGenreTargets(analysis);
        log('[GENRE-VIEW] ğŸ“¦ Targets obtidos de extractGenreTargets');
    }
    
    // ğŸ“¡ STREAMING MODE: Aplicar override de LUFS e TP (mantÃ©m DR, LRA, Stereo, Bandas)
    if (getSoundDestinationMode() === 'streaming' && genreTargets) {
        log('[GENRE-VIEW] ğŸ“¡ STREAMING MODE DETECTADO - Aplicando override de LUFS/TP');
        genreTargets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
        genreTargets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
        log('[GENRE-VIEW] ğŸ“¡ Targets atualizados:', {
            lufs_target: genreTargets.lufs_target,
            true_peak_target: genreTargets.true_peak_target,
            dr_target: genreTargets.dr_target,
            lra_target: genreTargets.lra_target,
            stereo_target: genreTargets.stereo_target,
            bands: genreTargets.bands ? 'presente' : 'ausente'
        });
    }
    
    // ğŸ¯ FALLBACK 3: Carregar targets padrÃ£o se nada funcionar
    if (!genreTargets) {
        warn('[GENRE-VIEW] âš ï¸ Nenhum target encontrado - carregando defaults');
        genreTargets = loadDefaultGenreTargets(genre);
        // Salvar em analysis.data.genreTargets para uso posterior
        if (!analysis.data) analysis.data = {};
        analysis.data.genreTargets = genreTargets;
    }
    
    if (!genreTargets) {
        error('[GENRE-VIEW] âŒ CRÃTICO: Targets de gÃªnero nÃ£o disponÃ­veis - ABORTANDO');
        error('[GENRE-VIEW]    window.PROD_AI_REF_DATA:', window.PROD_AI_REF_DATA);
        error('[GENRE-VIEW]    window.__activeRefData:', window.__activeRefData);
        error('[GENRE-VIEW]    Tipo PROD_AI_REF_DATA:', typeof window.PROD_AI_REF_DATA);
        error('[GENRE-VIEW]    analysis.referenceComparison:', analysis.referenceComparison);
        error('[GENRE-VIEW] ğŸ” DIAGNÃ“STICO: Verificar se targets foram carregados antes de displayModalResults');
        console.groupEnd();
        return; // âŒ ABORTAR se nÃ£o houver targets
    } else {
        log('[GENRE-VIEW] 5ï¸âƒ£ Targets encontrados:', {
            hasBands: !!genreTargets?.bands,
            bandsCount: genreTargets?.bands ? Object.keys(genreTargets.bands).length : 0,
            hasLegacyCompatibility: !!genreTargets?.legacy_compatibility,
            hasLufsTarget: genreTargets?.lufs_target !== undefined,
            bandas: genreTargets?.bands ? Object.keys(genreTargets.bands) : 'N/A'
        });
    }
    
    // 7ï¸âƒ£ Renderizar tabela de comparaÃ§Ã£o de gÃªnero
    log('[GENRE-VIEW] 6ï¸âƒ£ Renderizando tabela de comparaÃ§Ã£o...');
    log('[GENRE-VIEW] ğŸ¯ GARANTIA: Chamando renderGenreComparisonTable com targets validados');
    log('[GENRE-VIEW] ğŸ” AUDIT: Targets sendo passados:', {
        hasHybridProcessing: !!genreTargets?.hybrid_processing,
        hasSpectralBands: !!genreTargets?.hybrid_processing?.spectral_bands,
        spectralBandsKeys: genreTargets?.hybrid_processing?.spectral_bands ? Object.keys(genreTargets.hybrid_processing.spectral_bands) : 'N/A'
    });
    
    renderGenreComparisonTable({
        analysis,
        genre,
        targets: genreTargets
    });
    
    log('[GENRE-VIEW] ğŸ¯ GARANTIA: renderGenreComparisonTable executado');
    log('[GENRE-VIEW] ğŸ” AUDIT: Verificando se #referenceComparisons foi preenchido...');
    
    const refCompContainer = document.getElementById('referenceComparisons');
    if (refCompContainer) {
        log('[GENRE-VIEW] âœ… Container encontrado:', {
            innerHTML: refCompContainer.innerHTML.length > 0 ? `${refCompContainer.innerHTML.length} chars` : 'VAZIO',
            display: window.getComputedStyle(refCompContainer).display,
            visibility: window.getComputedStyle(refCompContainer).visibility,
            opacity: window.getComputedStyle(refCompContainer).opacity
        });
    } else {
        error('[GENRE-VIEW] âŒ Container #referenceComparisons NÃƒO ENCONTRADO!');
    }
    
    log('%c[GENRE-VIEW] âœ… RenderizaÃ§Ã£o de gÃªnero concluÃ­da', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

/**
 * ğŸ¯ HELPER: Aplicar controle de realismo de masterizaÃ§Ã£o nas aÃ§Ãµes sugeridas
 * Garante que nenhuma sugestÃ£o mostre ajustes maiores que Â±5 dB
 * 
 * @param {number} realDiff - DiferenÃ§a real calculada (em dB)
 * @param {string} direction - 'increase' ou 'decrease'
 * @param {string} emoji - Emoji de severidade (ğŸ”´, ğŸŸ¡, âš ï¸, etc)
 * @returns {string} - Texto realista da aÃ§Ã£o sugerida
 */
function buildRealisticAction(realDiff, direction, emoji) {
    const absDiff = Math.abs(realDiff);
    
    // ğŸ¯ CLAMP: Valores acima de Â±5 dB devem ser expressos de forma genÃ©rica
    if (absDiff > 5.0) {
        if (direction === 'decrease') {
            return `${emoji} Reduzir suavemente (â‰ˆ âˆ’2 a âˆ’5 dB)`;
        } else {
            return `${emoji} Aumentar levemente (â‰ˆ +2 a +5 dB)`;
        }
    }
    
    // ğŸ¯ RANGE MÃ‰DIO: Mostrar valor aproximado ou range
    if (absDiff >= 1.0 && absDiff <= 5.0) {
        const roundedDiff = Math.round(absDiff * 2) / 2; // Arredondar para 0.5 dB
        if (direction === 'decrease') {
            return `${emoji} Reduzir ${roundedDiff.toFixed(1)} dB`;
        } else {
            return `${emoji} Aumentar ${roundedDiff.toFixed(1)} dB`;
        }
    }
    
    // ğŸ¯ AJUSTE FINO: Valores abaixo de 1 dB
    if (absDiff < 1.0) {
        if (direction === 'decrease') {
            return `${emoji} Reduzir levemente (â‰ˆ âˆ’${absDiff.toFixed(1)} dB)`;
        } else {
            return `${emoji} Aumentar levemente (â‰ˆ +${absDiff.toFixed(1)} dB)`;
        }
    }
    
    // Fallback (nÃ£o deveria chegar aqui)
    return `${emoji} Ajustar conforme necessÃ¡rio`;
}

/**
 * ğŸ¯ HELPER: Verificar se a mÃ©trica Ã© uma banda espectral (EQ/frequÃªncia)
 * Usado para aplicar controle de realismo APENAS em bandas espectrais
 * 
 * @param {string} metricKey - Chave da mÃ©trica (sub, bass, lufs, dr, etc)
 * @returns {boolean} - true se for banda espectral, false caso contrÃ¡rio
 */
function isSpectralBand(metricKey) {
    const SPECTRAL_BANDS = [
        'sub', 'bass', 'low_bass', 'upperBass', 'upper_bass',
        'lowMid', 'low_mid', 'mid', 'highMid', 'high_mid',
        'presence', 'presenca', 'air', 'brilho'
    ];
    return SPECTRAL_BANDS.includes(metricKey);
}

function renderGenreComparisonTable(options) {
    const { analysis, genre, targets } = options;
    
    console.group('[GENRE-TABLE] ğŸ“Š RENDERIZAÃ‡ÃƒO COMPLETA DE GÃŠNERO');
    log('[GENRE-TABLE] ğŸ¯ GÃªnero:', genre);
    log('[GENRE-TABLE] ğŸ“ Targets recebidos (parÃ¢metro):', targets);
    
    // ğŸ†• LOG DE DIAGNÃ“STICO STREAMING MODE
    log('[GENRE-TABLE] ğŸ“¡ STREAMING DIAGNÃ“STICO:', {
        soundDestination: analysis?.soundDestination,
        'analysis.data.genreTargets.lufs_target': analysis?.data?.genreTargets?.lufs_target,
        'analysis.data.genreTargets.true_peak_target': analysis?.data?.genreTargets?.true_peak_target,
        'targets.lufs_target': targets?.lufs_target,
        'targets.true_peak_target': targets?.true_peak_target,
        isStreaming: analysis?.soundDestination === 'streaming'
    });
    
    // ğŸ›¡ï¸ GUARD: Apenas para modo gÃªnero
    if (analysis?.mode !== 'genre') {
        warn('[GENRE-TABLE] â­ï¸ Modo nÃ£o Ã© gÃªnero, abortando renderizaÃ§Ã£o');
        console.groupEnd();
        return;
    }
    
    // Buscar container
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        error('[GENRE-TABLE] âŒ Container #referenceComparisons nÃ£o encontrado!');
        console.groupEnd();
        return;
    }
    
    // ï¿½ STREAMING OVERRIDE: Aplicar targets de streaming se necessÃ¡rio
    let genreData = applyStreamingOverride(targets);
    log('[GENRE-TABLE] ğŸ¯ Targets apÃ³s streaming check:', {
        lufs_target: genreData?.lufs_target,
        true_peak_target: genreData?.true_peak_target,
        mode: getSoundDestinationMode()
    });
    
    log('[GENRE-TABLE] ğŸ“¦ Genre data recebido (flat object):', Object.keys(genreData || {}));
    
    if (!genreData) {
        error('[GENRE-TABLE] âŒ CRÃTICO: Nenhum target disponÃ­vel!');
        error('[GENRE-TABLE]    - analysis.data.genreTargets:', !!analysis?.data?.genreTargets);
        error('[GENRE-TABLE]    - targets parameter:', !!targets);
        console.groupEnd();
        return;
    }
    
    log('[GENRE-TABLE] ğŸ“¦ Genre data:', {
        lufs_target: genreData.lufs_target,
        true_peak_target: genreData.true_peak_target,
        dr_target: genreData.dr_target,
        lra_target: genreData.lra_target,
        stereo_target: genreData.stereo_target,
        tol_lufs: genreData.tol_lufs,
        tol_true_peak: genreData.tol_true_peak,
        tol_dr: genreData.tol_dr,
        tol_lra: genreData.tol_lra,
        tol_stereo: genreData.tol_stereo,
        hasBands: !!genreData.bands
    });
    
    // ğŸ¯ EXTRAIR VALORES DO ANALYSIS (mesmas fontes usadas em calculateScore)
    const lufsIntegrated = analysis.loudness?.integrated ?? analysis.technicalData?.lufsIntegrated ?? null;
    const truePeakDbtp = analysis.truePeakDbtp ?? analysis.truePeak?.maxDbtp ?? analysis.technicalData?.truePeakDbtp ?? null;
    const dynamicRange = analysis.dynamicRange ?? analysis.dynamics?.range ?? analysis.technicalData?.dynamicRange ?? null;
    const lra = analysis.lra ?? analysis.loudness?.lra ?? analysis.technicalData?.lra ?? null;
    const stereoCorrelation = analysis.stereoCorrelation ?? analysis.stereo?.correlation ?? analysis.technicalData?.stereoCorrelation ?? null;
    
    log('[GENRE-TABLE] ğŸ“Š Valores extraÃ­dos do analysis:', {
        lufsIntegrated,
        truePeakDbtp,
        dynamicRange,
        lra,
        stereoCorrelation
    });
    
    // ğŸ¯ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode nÃ£o existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const userBands = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    log('[GENRE-TABLE] ğŸµ Fonte de bandas do usuÃ¡rio:', 
        technicalBands ? 'âœ… technicalData.bands (prioridade 1)' : 
        centralizedBands ? 'âš ï¸ metrics.bands (fallback 2)' : 
        spectralBalance ? 'âš ï¸ spectral_balance (fallback 3)' : 
        'âš ï¸ bandEnergies (fallback 4 - legado)');
    
    log('[GENRE-TABLE] ğŸµ Bandas disponÃ­veis:', userBands ? Object.keys(userBands) : 'NENHUMA');
    
    log('[GENRE-TABLE] ğŸµ Bandas do usuÃ¡rio:', userBands ? Object.keys(userBands) : 'N/A');
    
    // ğŸ¯ PATCH: Aceitar 'bands' (normalizado) OU 'spectral_bands' (com underscore) com normalizaÃ§Ã£o
    const targetBands = (() => {

        // ğŸ¯ PRIORIDADE 1: spectral_bands (estrutura correta do JSON com snake_case)
        if (genreData.spectral_bands && typeof genreData.spectral_bands === 'object' && Object.keys(genreData.spectral_bands).length > 0) {
            log('[GENRE-TABLE] ğŸ¯ Usando genreData.spectral_bands (normalizando)');
            
            // Normalizar chaves de snake_case â†’ camelCase
            const normalized = {};
            Object.keys(genreData.spectral_bands).forEach(snakeKey => {
                const camelKey = normalizeGenreBandName(snakeKey);
                normalized[camelKey] = genreData.spectral_bands[snakeKey];
            });
            
            log('[GENRE-TABLE] ğŸ¯ Bandas normalizadas:', Object.keys(normalized));
            return normalized;
        }

        // ğŸ¯ PRIORIDADE 2: bands (jÃ¡ normalizado via enrichReferenceObject)
        if (genreData.bands && Object.keys(genreData.bands).length > 0) {
            log('[GENRE-TABLE] ğŸ¯ Usando genreData.bands (jÃ¡ normalizado)');
            return genreData.bands;
        }

        // ğŸ¯ FALLBACK: extrair bandas da raiz (compatibilidade legado)
        const bandsFromRoot = {};
        const metricKeys = [
            'lufs_target','true_peak_target','dr_target','lra_target','stereo_target',
            'tol_lufs','tol_true_peak','tol_dr','tol_lra','tol_stereo'
        ];

        Object.keys(genreData).forEach(key => {
            const value = genreData[key];

            // Se Ã© um objeto, nÃ£o estÃ¡ na lista de mÃ©tricas e possui target_db = Ã© banda vÃ¡lida
            if (typeof value === 'object' && value !== null && 
                !metricKeys.includes(key) &&
                (value.target_db !== undefined || value.target !== undefined)
            ) {
                // Normalizar chave de snake_case â†’ camelCase
                const normalizedKey = normalizeGenreBandName(key);
                bandsFromRoot[normalizedKey] = value;
            }
        });

        log('[GENRE-TABLE] ğŸ¯ Bandas extraÃ­das da raiz (normalizadas):', Object.keys(bandsFromRoot));
        return bandsFromRoot;
    })();
    
    log('[GENRE-TABLE] ğŸ¯ Target bands (source):', genreData.bands ? 'bands' : (genreData.spectralBands ? 'spectralBands' : 'ROOT'));
    log('[GENRE-TABLE] ğŸ¯ Target bands (keys):', Object.keys(targetBands));
    
    // ğŸ¯ HELPER: Calcular severidade e aÃ§Ã£o baseado em diferenÃ§a e tolerÃ¢ncia
    const calcSeverity = (value, target, tolerance, options = {}) => {
        const { targetRange } = options;
        
        if (!Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        // ğŸ¯ NOVA LÃ“GICA: Priorizar target_range se existir
        if (targetRange && typeof targetRange === 'object') {
            // Suportar ambos formatos: { min, max } ou { min_db, max_db }
            const min = targetRange.min ?? targetRange.min_db;
            const max = targetRange.max ?? targetRange.max_db;
            
            if (typeof min !== 'number' || typeof max !== 'number') {
                // Range invÃ¡lido, usar fallback
                if (target === null || target === undefined) {
                    return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
                }
            } else {
                // âœ… Valor dentro do range
                if (value >= min && value <= max) {
                    return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff: 0 };
                }
                
                // âŒ Valor fora do range: calcular distÃ¢ncia atÃ© borda mais prÃ³xima
                let diff;
                let absDelta;
                if (value < min) {
                    diff = value - min;  // negativo (precisa subir)
                    absDelta = min - value;
                } else {
                    diff = value - max;  // positivo (precisa descer)
                    absDelta = value - max;
                }
                
                // Thresholds para severidade baseados na distÃ¢ncia
                // ğŸ¯ CONTROLE DE REALISMO: Usar buildRealisticAction APENAS para bandas espectrais
                if (absDelta >= 2) {
                    const direction = diff > 0 ? 'decrease' : 'increase';
                    const action = buildRealisticAction(absDelta, direction, 'ğŸ”´');
                    return { severity: 'CRÃTICA', severityClass: 'critical', action, diff };
                } else {
                    const direction = diff > 0 ? 'decrease' : 'increase';
                    const action = buildRealisticAction(absDelta, direction, 'âš ï¸');
                    return { severity: 'ATENÃ‡ÃƒO', severityClass: 'caution', action, diff };
                }
            }
        }
        
        // ğŸ”„ FALLBACK: LÃ³gica antiga com target fixo (para mÃ©tricas sem range)
        if (target === null || target === undefined) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        const diff = value - target;
        const absDiff = Math.abs(diff);
        
        if (absDiff <= tolerance) {
            return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff };
        } else if (absDiff <= tolerance * 2) {
            const action = diff > 0 ? `âš ï¸ Reduzir ${absDiff.toFixed(1)}` : `âš ï¸ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ATENÃ‡ÃƒO', severityClass: 'caution', action, diff };
        } else if (absDiff <= tolerance * 3) {
            const action = diff > 0 ? `ğŸŸ¡ Reduzir ${absDiff.toFixed(1)}` : `ğŸŸ¡ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ALTA', severityClass: 'warning', action, diff };
        } else {
            const action = diff > 0 ? `ğŸ”´ Reduzir ${absDiff.toFixed(1)}` : `ğŸ”´ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'CRÃTICA', severityClass: 'critical', action, diff };
        }
    };
    
    // Construir linhas da tabela
    const rows = [];
    let metricsCount = 0;
    let bandsCount = 0;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1ï¸âƒ£ MÃ‰TRICAS PRINCIPAIS (LUFS, TRUE PEAK, DR, LRA, STEREO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ğŸ”Š LUFS Integrado
    if (genreData.lufs_target !== null && genreData.lufs_target !== undefined) {
        const lufsValue = lufsIntegrated;
        if (Number.isFinite(lufsValue) && Number.isFinite(genreData.lufs_target)) {
            const result = calcSeverity(lufsValue, genreData.lufs_target, genreData.tol_lufs || 1.0);
            if (result && Number.isFinite(result.diff)) {
                // ğŸ” SECURITY GUARD: Verificar se deve renderizar valor real
                const canRender = shouldRenderRealValue('lufsIntegrated', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">ğŸ”Š Loudness (LUFS Integrado)</td>
                        <td class="metric-value">${canRender ? lufsValue.toFixed(2) + ' LUFS' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.lufs_target.toFixed(1) + ' LUFS' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} LUFS: ${lufsValue.toFixed(2)} | Target: ${genreData.lufs_target} | ${result.severity}`);
            }
        }
    }
    
    // ğŸšï¸ True Peak
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸš¨ REGRA ABSOLUTA: TRUE PEAK > 0.0 dBTP = CRÃTICA SEMPRE
    // Esta regra NÃƒO pode ser sobrescrita por tolerÃ¢ncia ou target do gÃªnero
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const TRUE_PEAK_HARD_CAP = 0.0; // dBTP - Limite mÃ¡ximo ABSOLUTO
    
    if (genreData.true_peak_target !== null && genreData.true_peak_target !== undefined) {
        const tpValue = truePeakDbtp;
        if (Number.isFinite(tpValue) && Number.isFinite(genreData.true_peak_target)) {
            let result;
            const tpTarget = genreData.true_peak_target;  // âœ… SSOT: target do gÃªnero
            
            // ğŸš¨ HARD LIMIT: TP > 0.0 = CRÃTICA (ignora tolerÃ¢ncia)
            // ğŸ”§ FIX: AÃ§Ã£o usa deltaToTarget (nÃ£o hardCap) para consistÃªncia com coluna "DiferenÃ§a"
            if (tpValue > TRUE_PEAK_HARD_CAP) {
                const deltaToTarget = tpValue - tpTarget;  // âœ… SSOT: sempre usa target do gÃªnero
                result = {
                    severity: 'CRÃTICA',
                    severityClass: 'critical',
                    action: `ğŸ”´ CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dB`,
                    diff: deltaToTarget
                };
                log('[GENRE-TABLE] ğŸš¨ TRUE PEAK CRÃTICO: TP > 0.0 dBTP detectado:', tpValue, '| deltaToTarget:', deltaToTarget);
            } else {
                // LÃ³gica normal para TP <= 0.0
                result = calcSeverity(tpValue, genreData.true_peak_target, genreData.tol_true_peak || 0.5);
            }
            
            if (result && Number.isFinite(result.diff)) {
                // ğŸ” SECURITY GUARD
                const canRender = shouldRenderRealValue('truePeak', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">ğŸšï¸ Pico Real (dBTP)</td>
                        <td class="metric-value">${canRender ? tpValue.toFixed(2) + ' dBTP' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.true_peak_target.toFixed(1) + ' dBTP' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} True Peak: ${tpValue.toFixed(2)} | Target: ${genreData.true_peak_target} | ${result.severity}`);
            }
        }
    }
    
    // ğŸ“Š Dynamic Range (DR)
    if (genreData.dr_target !== null && genreData.dr_target !== undefined) {
        const drValue = dynamicRange;
        if (Number.isFinite(drValue) && Number.isFinite(genreData.dr_target)) {
            const result = calcSeverity(drValue, genreData.dr_target, genreData.tol_dr || 1.0);
            if (result && Number.isFinite(result.diff)) {
                // ğŸ” SECURITY GUARD (DR Ã© LIBERADO)
                const canRender = shouldRenderRealValue('dr', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">ğŸ“Š DinÃ¢mica (DR)</td>
                        <td class="metric-value">${canRender ? drValue.toFixed(2) + ' DR' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.dr_target.toFixed(1) + ' DR' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} DR: ${drValue.toFixed(2)} | Target: ${genreData.dr_target} | ${result.severity}`);
            }
        }
    }
    
    // ğŸ“ˆ Loudness Range (LRA)
    if (genreData.lra_target !== null && genreData.lra_target !== undefined) {
        const lraValue = lra;
        if (Number.isFinite(lraValue) && Number.isFinite(genreData.lra_target)) {
            const result = calcSeverity(lraValue, genreData.lra_target, genreData.tol_lra || 2.0);
            if (result && Number.isFinite(result.diff)) {
                // ğŸ” SECURITY GUARD (LRA Ã© BLOQUEADO)
                const canRender = shouldRenderRealValue('lra', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">ğŸ“ˆ LRA (Faixa de Loudness)</td>
                        <td class="metric-value">${canRender ? lraValue.toFixed(2) + ' LU' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.lra_target.toFixed(1) + ' LU' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} LRA: ${lraValue.toFixed(2)} | Target: ${genreData.lra_target} | ${result.severity}`);
            }
        }
    }
    
    // ğŸ§ Stereo Correlation
    if (genreData.stereo_target !== null && genreData.stereo_target !== undefined) {
        const stereoValue = stereoCorrelation;
        if (Number.isFinite(stereoValue) && Number.isFinite(genreData.stereo_target)) {
            const result = calcSeverity(stereoValue, genreData.stereo_target, genreData.tol_stereo || 0.1);
            if (result && Number.isFinite(result.diff)) {
                // ğŸ” SECURITY GUARD (Stereo Ã© LIBERADO)
                const canRender = shouldRenderRealValue('stereo', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">ğŸ§ Imagem EstÃ©reo</td>
                        <td class="metric-value">${canRender ? stereoValue.toFixed(3) : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.stereo_target.toFixed(3) : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(3) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} Stereo: ${stereoValue.toFixed(3)} | Target: ${genreData.stereo_target} | ${result.severity}`);
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2ï¸âƒ£ BANDAS ESPECTRAIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ğŸ¯ PATCH: Usar nomenclatura NORMALIZADA (camelCase) igual ao backend
    const nomesBandas = {
        sub: 'ğŸ”‰ Sub (20-60 Hz)',
        bass: 'ğŸ”Š Bass (60-120 Hz)',           // â† low_bass normalizado
        upperBass: 'ğŸ”Š Upper Bass (120-250 Hz)', // â† upper_bass normalizado
        lowMid: 'ğŸµ Low Mid (250-500 Hz)',      // â† low_mid normalizado
        mid: 'ğŸµ Mid (500-2k Hz)',
        highMid: 'ğŸ¸ High Mid (2k-4k Hz)',      // â† high_mid normalizado
        presence: 'ğŸ’ PresenÃ§a (10k-20k Hz)',   // â† presenca normalizado
        air: 'âœ¨ Brilho (4k-10k Hz)',           // â† brilho normalizado
        // Compatibilidade com nomes legados (snake_case)
        low_bass: 'ğŸ”Š Bass (60-120 Hz)',
        upper_bass: 'ğŸ”Š Upper Bass (120-250 Hz)',
        low_mid: 'ğŸµ Low Mid (250-500 Hz)',
        high_mid: 'ğŸ¸ High Mid (2k-4k Hz)',
        presenca: 'ğŸ’ PresenÃ§a (10k-20k Hz)',
        brilho: 'âœ¨ Brilho (4k-10k Hz)'
    };
    
    // ğŸ¯ ITERAR APENAS SOBRE BANDAS QUE EXISTEM NOS DOIS LADOS (target-driven)
    // Previne erro: "Cannot read properties of undefined (reading 'toFixed')"
    if (targetBands && Object.keys(targetBands).length > 0) {
        Object.keys(targetBands).forEach(targetKey => {
            try {
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #1: Verificar se target tem estrutura vÃ¡lida
                const targetBand = targetBands[targetKey];
                if (!targetBand || typeof targetBand !== 'object') {
                    log(`[GENRE-TABLE] â­ï¸ Pulando banda com target invÃ¡lido: ${targetKey}`);
                    return;
                }
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #2: Validar se existe valor target (range ou db)
                const hasRange = targetBand.target_range 
                    && (typeof targetBand.target_range.min === 'number' || typeof targetBand.target_range.min_db === 'number')
                    && (typeof targetBand.target_range.max === 'number' || typeof targetBand.target_range.max_db === 'number');
                const hasTargetDb = typeof targetBand.target_db === 'number';
                
                if (!hasRange && !hasTargetDb) {
                    log(`[GENRE-TABLE] â­ï¸ Pulando banda sem target vÃ¡lido: ${targetKey}`);
                    return;
                }
                
                // ğŸ”„ NORMALIZAR nome da banda para buscar no userBands
                // targetKey jÃ¡ estÃ¡ normalizado (camelCase), procurar no userBands
                const bandData = userBands?.[targetKey];
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #3: Verificar se usuÃ¡rio tem essa banda
                if (!bandData) {
                    log(`[GENRE-TABLE] â­ï¸ Pulando banda sem dados do usuÃ¡rio: ${targetKey}`);
                    return;
                }
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #4: Extrair valor numÃ©rico com fallbacks seguros
                let energyDb = null;
                if (typeof bandData === 'number') {
                    energyDb = bandData;
                } else if (typeof bandData === 'object') {
                    energyDb = bandData.energy_db ?? bandData.rms_db ?? bandData.db ?? null;
                }
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #5: Validar que energyDb Ã© nÃºmero finito
                if (!Number.isFinite(energyDb)) {
                    log(`[GENRE-TABLE] ğŸ”‡ Banda sem valor numÃ©rico vÃ¡lido: ${targetKey} (valor: ${energyDb})`);
                    return;
                }
                
                // ğŸ¯ PRIORIZAR target_range (min/max) - IGNORAR tol_db
                const targetRange = hasRange ? targetBand.target_range : null;
                const targetValue = hasTargetDb ? targetBand.target_db : null;
                
                // âš ï¸ NÃƒO USAR tol_db - apenas para compatibilidade com fallback legado
                // Range Ã© a tolerÃ¢ncia quando existir
                
                // ğŸ§® Calcular severidade com suporte a range
                const result = calcSeverity(energyDb, targetValue, 2.0, { targetRange });
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #6: Validar resultado antes de usar
                if (!result || typeof result.diff !== 'number') {
                    warn(`[GENRE-TABLE] âš ï¸ Resultado de severidade invÃ¡lido para: ${targetKey}`);
                    return;
                }
                
                // ğŸ¨ Formatar coluna ALVO: mostrar range se existir, senÃ£o target fixo
                let targetLabel;
                if (targetRange) {
                    // Suportar ambos formatos: { min, max } ou { min_db, max_db }
                    const minValue = targetRange.min ?? targetRange.min_db;
                    const maxValue = targetRange.max ?? targetRange.max_db;
                    const minSafe = Number.isFinite(minValue) ? minValue.toFixed(1) : '?';
                    const maxSafe = Number.isFinite(maxValue) ? maxValue.toFixed(1) : '?';
                    targetLabel = `${minSafe} dB a ${maxSafe} dB`;
                } else if (targetValue !== null) {
                    targetLabel = `${targetValue.toFixed(1)} dB`;
                } else {
                    targetLabel = 'â€”';
                }
                
                const nomeAmigavel = nomesBandas[targetKey] || targetKey;
                
                // ï¿½ SECURITY GUARD: Verificar se banda deve ser renderizada
                const canRender = shouldRenderRealValue(targetKey, 'table', analysis);
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #7: Usar valores seguros em .toFixed()
                const energyDbSafe = canRender && Number.isFinite(energyDb) ? energyDb.toFixed(2) + ' dB' : renderSecurePlaceholder('value');
                const targetLabelSafe = canRender ? targetLabel : renderSecurePlaceholder('target');
                const diffSafe = canRender && Number.isFinite(result.diff) ? result.diff.toFixed(2) : '0.00';
                const diffSign = result.diff >= 0 ? '+' : '';
                const diffDisplay = canRender ? `${diffSign}${diffSafe} dB` : renderSecurePlaceholder('diff');
                const severityDisplay = canRender ? result.severity : renderSecurePlaceholder('severity');
                const actionDisplay = canRender ? result.action : renderSecurePlaceholder('action');
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">${nomeAmigavel}</td>
                        <td class="metric-value">${energyDbSafe}</td>
                        <td class="metric-target">${targetLabelSafe}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${diffDisplay}</td>
                        <td class="metric-severity ${result.severityClass}">${severityDisplay}</td>
                        <td class="metric-action ${result.severityClass}">${actionDisplay}</td>
                    </tr>
                `);
                bandsCount++;
                
                // Log mais informativo mostrando range quando disponÃ­vel
                const targetInfo = targetRange 
                    ? `[${(targetRange.min ?? targetRange.min_db).toFixed(1)}, ${(targetRange.max ?? targetRange.max_db).toFixed(1)}]` 
                    : (targetValue !== null ? targetValue.toFixed(1) : 'N/A');
                log(`[GENRE-TABLE] ${canRender ? 'âœ…' : 'ğŸ”’'} ${nomeAmigavel}: ${energyDb.toFixed(2)} dB | Target: ${targetInfo} | ${result.severity}`);
                
            } catch (err) {
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO #8: Capturar qualquer erro e continuar com prÃ³xima banda
                warn(`[GENRE-TABLE][SAFE-FAIL] Erro ao processar banda ${targetKey}:`, err.message);
                return; // Pular essa banda e continuar com as outras
            }
        });
    }
    
    // Renderizar HTML completo
    // ğŸ†• STREAMING MODE: Verificar se Ã© anÃ¡lise streaming e adicionar badge
    const isStreamingMode = analysis.soundDestination === 'streaming';
    const targetColumnHeader = isStreamingMode 
        ? 'Alvo <span class="streaming-badge" title="Targets otimizados para Streaming (LUFS -14, TP -1.0)">ğŸ“¡</span>'
        : 'Alvo';
    
    const tableHTML = `
        <div class="card genre-comparison-classic" style="margin-top:12px;">
            <div class="card-title">COMPARAÃ‡ÃƒO COM ${genre.toUpperCase()}${isStreamingMode ? ' <span class="streaming-mode-label">ğŸ“¡ Streaming</span>' : ''}</div>
            <table class="classic-genre-table">
                <thead>
                    <tr>
                        <th>MÃ©trica</th>
                        <th>Valor</th>
                        <th>${targetColumnHeader}</th>
                        <th>DiferenÃ§a</th>
                        <th>Severidade</th>
                        <th>AÃ§Ã£o Sugerida</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.join('')}
                </tbody>
            </table>
        </div>
    `;
    
    // ğŸ”¥ AUDITORIA CRÃTICA: Verificar container ANTES de inserir HTML
    log('[GENRE-TABLE-AUDIT] ğŸ” ANTES de innerHTML:', {
        containerExists: !!container,
        containerVisible: container ? window.getComputedStyle(container).display : 'N/A',
        containerOpacity: container ? window.getComputedStyle(container).opacity : 'N/A',
        containerParent: container ? container.parentElement?.id : 'N/A',
        tableHTMLLength: tableHTML.length,
        rowsCount: rows.length
    });
    
    try {
        container.innerHTML = tableHTML;
        
        // ğŸ”¥ AUDITORIA CRÃTICA: Verificar container DEPOIS de inserir HTML
        log('[GENRE-TABLE-AUDIT] ğŸ” DEPOIS de innerHTML:', {
            containerInnerHTMLLength: container.innerHTML.length,
            containerFirstChild: container.firstChild ? container.firstChild.className : 'N/A',
            tableExists: !!container.querySelector('.classic-genre-table'),
            rowsInDOM: container.querySelectorAll('tr').length
        });
    } catch (err) {
        error('[GENRE-TABLE-ERROR] âŒ Erro ao inserir HTML:', err);
        container.innerHTML = `<div class="error-message">âŒ Erro ao renderizar tabela: ${err.message}</div>`;
    }
    
    // ForÃ§ar visibilidade
    container.classList.remove('hidden');
    container.style.display = 'block';
    container.style.visibility = 'visible';
    container.style.opacity = '1';
    
    // ğŸ”¥ AUDITORIA FINAL: Verificar visibilidade computada
    const computedStyle = window.getComputedStyle(container);
    log('[GENRE-TABLE-AUDIT] ğŸ” VISIBILIDADE FINAL:', {
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        opacity: computedStyle.opacity,
        height: computedStyle.height,
        overflow: computedStyle.overflow
    });
    
    // ğŸ¨ INJETAR ESTILOS CSS PARA TABELA CLÃSSICA DE GÃŠNERO (branch imersao)
    if (!document.getElementById('classicGenreTableStyles')) {
        const style = document.createElement('style');
        style.id = 'classicGenreTableStyles';
        style.textContent = `
            /* ğŸ¯ TABELA CLÃSSICA DE GÃŠNERO */
            .genre-comparison-classic {
                background: linear-gradient(135deg, rgba(14, 20, 34, 0.95), rgba(31, 43, 64, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 16px;
                padding: 24px;
                margin-top: 16px;
            }
            
            .classic-genre-table {
                width: 100%;
                border-collapse: collapse;
                table-layout: fixed;
                font-size: 13px;
            }
            
            .classic-genre-table thead {
                background: rgba(0, 102, 255, 0.15);
                border-bottom: 2px solid rgba(36, 157, 255, 0.4);
            }
            
            .classic-genre-table th {
                font-weight: 600;
                padding: 12px 16px;
                text-align: center;
                font-size: 12px;
                color: #00f0ff;
                letter-spacing: 0.5px;
                text-transform: uppercase;
            }
            
            .classic-genre-table th:first-child {
                text-align: left;
                width: 20%;
            }
            
            .classic-genre-table th:nth-child(2) { width: 14%; }
            .classic-genre-table th:nth-child(3) { width: 14%; }
            .classic-genre-table th:nth-child(4) { width: 14%; }
            .classic-genre-table th:nth-child(5) { width: 14%; }
            .classic-genre-table th:nth-child(6) { width: 24%; }
            
            .classic-genre-table td {
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                color: #f5f7fa;
                text-align: center;
            }
            
            .classic-genre-table td:first-child {
                text-align: left;
                font-weight: 500;
            }
            
            .classic-genre-table tr:last-child td {
                border-bottom: 0;
            }
            
            .classic-genre-table tbody tr:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            
            /* ğŸ¨ CORES DE SEVERIDADE */
            .classic-genre-table .genre-row.ok {
                background: rgba(82, 247, 173, 0.08);
            }
            
            .classic-genre-table .genre-row.caution {
                background: rgba(255, 206, 77, 0.08);
            }
            
            .classic-genre-table .genre-row.warning {
                background: rgba(255, 165, 0, 0.08);
            }
            
            .classic-genre-table .genre-row.critical {
                background: rgba(255, 123, 123, 0.08);
            }
            
            .classic-genre-table .metric-severity.ok {
                color: #52f7ad;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.caution {
                color: #ffce4d;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.warning {
                color: #ffa500;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.critical {
                color: #ff7b7b;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-action {
                font-size: 12px;
            }
            
            .classic-genre-table .metric-diff.positive {
                color: #ffa500;
            }
            
            .classic-genre-table .metric-diff.negative {
                color: #00d4ff;
            }
            
            /* ğŸ¯ MOBILE RESPONSIVO - TABELA GÃŠNERO */
            @media (max-width: 768px) {
                .genre-comparison-classic {
                    padding: 12px !important;
                    border-radius: 12px !important;
                    overflow-x: hidden !important;
                }
                
                .classic-genre-table {
                    table-layout: fixed !important;
                    width: 100% !important;
                    font-size: 10px !important;
                    overflow-x: auto !important;
                    display: block !important;
                }
                
                .classic-genre-table thead,
                .classic-genre-table tbody,
                .classic-genre-table tr {
                    display: table !important;
                    width: 100% !important;
                    table-layout: fixed !important;
                }
                
                .classic-genre-table th {
                    padding: 8px 4px !important;
                    font-size: 9px !important;
                    letter-spacing: 0.3px !important;
                    line-height: 1.2 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table td {
                    padding: 8px 4px !important;
                    font-size: 10px !important;
                    line-height: 1.3 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table th:nth-child(1),
                .classic-genre-table td:nth-child(1) {
                    width: 22% !important;
                    text-align: left !important;
                }
                
                .classic-genre-table th:nth-child(2),
                .classic-genre-table td:nth-child(2),
                .classic-genre-table th:nth-child(3),
                .classic-genre-table td:nth-child(3),
                .classic-genre-table th:nth-child(4),
                .classic-genre-table td:nth-child(4) {
                    width: 14% !important;
                }
                
                .classic-genre-table th:nth-child(5),
                .classic-genre-table td:nth-child(5) {
                    width: 15% !important;
                }
                
                .classic-genre-table th:nth-child(6),
                .classic-genre-table td:nth-child(6) {
                    width: 21% !important;
                }
                
                .classic-genre-table td .icon,
                .classic-genre-table td i,
                .classic-genre-table td svg {
                    width: 12px !important;
                    height: 12px !important;
                    font-size: 12px !important;
                }
                
                .classic-genre-table .metric-severity {
                    font-size: 9px !important;
                    font-weight: 600 !important;
                }
                
                .classic-genre-table .metric-action {
                    font-size: 9px !important;
                }
                
                .classic-genre-table .metric-diff {
                    font-size: 9px !important;
                }
                
                .genre-comparison-classic .card-title {
                    font-size: 13px !important;
                    padding: 8px 0 !important;
                }
            }
            
            /* ğŸ†• STREAMING MODE BADGE */
            .streaming-badge {
                display: inline-block;
                font-size: 0.85em;
                margin-left: 4px;
                vertical-align: middle;
                cursor: help;
            }
            
            .streaming-mode-label {
                display: inline-block;
                background: linear-gradient(135deg, rgba(0, 200, 255, 0.2), rgba(0, 150, 255, 0.1));
                border: 1px solid rgba(0, 200, 255, 0.4);
                color: #00c8ff;
                font-size: 0.7em;
                padding: 2px 8px;
                border-radius: 12px;
                margin-left: 8px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                vertical-align: middle;
            }
        `;
        document.head.appendChild(style);
        log('[GENRE-TABLE] ğŸ¨ Estilos CSS injetados');
    }
    
    log('[GENRE-TABLE] âœ… Tabela COMPLETA renderizada:', {
        metricas: metricsCount,
        bandas: bandsCount,
        totalLinhas: rows.length
    });
    console.groupEnd();
}

// ğŸ¯ NOVO: Atualizar step ativo no modo referÃªncia
function updateReferenceStep(step) {
    const steps = ['userAudio', 'referenceAudio', 'analysis'];
    const stepElements = {
        userAudio: document.getElementById('stepUserAudio'),
        referenceAudio: document.getElementById('stepReferenceAudio'),
        analysis: document.getElementById('stepAnalysis')
    };
    
    // Reset todos os steps
    Object.values(stepElements).forEach(el => {
        if (el) {
            el.classList.remove('active', 'completed');
        }
    });
    
    // Marcar steps anteriores como completed
    const currentIndex = steps.indexOf(step);
    for (let i = 0; i < currentIndex; i++) {
        const stepElement = stepElements[steps[i]];
        if (stepElement) {
            stepElement.classList.add('completed');
        }
    }
    
    // Marcar step atual como active
    const currentElement = stepElements[step];
    if (currentElement) {
        currentElement.classList.add('active');
    }
    
    referenceStepState.currentStep = step;
    
    window.logReferenceEvent('reference_step_updated', { step, currentIndex });
}

// âŒ Fechar modal de anÃ¡lise de Ã¡udio
function closeAudioModal() {
    __dbg('âŒ Fechando modal de anÃ¡lise de Ã¡udio...');
    
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        currentModalAnalysis = null;
        
        // ğŸš« CRITICAL: Limpar globalmente tambÃ©m
        window.currentModalAnalysis = null;
        window.__CURRENT_ANALYSIS__ = null;
        
        // ğŸ›¡ï¸ FIX 3: Verificar se estÃ¡ aguardando segunda track ou em modo reference
        const stateMachine = window.AnalysisStateMachine;
        const isAwaitingSecond = stateMachine?.isAwaitingSecondTrack?.();
        const currentMode = stateMachine?.getMode() || window.currentAnalysisMode;
        
        if (isAwaitingSecond) {
            warn('[REF_FIX] ğŸ”’ closeAudioModal() - PRESERVANDO estado (awaitingSecondTrack)');
            log('[REF_FIX] Modal fechado mas estado Reference mantido');
            // NÃƒO chamar resetModalState nem destruir estado
            return; // Sai aqui sem destruir nada
        }
        
        if (currentMode === 'reference') {
            warn('[REF_FIX] ğŸ”’ closeAudioModal() - PRESERVANDO estado (modo Reference)');
            log('[REF_FIX] referenceJobId e flags preservados');
            // NÃƒO resetar se ainda estiver em reference
            return;
        }
        
        // âœ… SEGURO: SÃ³ reseta se NÃƒO for reference e NÃƒO estiver aguardando
        resetModalState();
        log('[REF_FIX] closeAudioModal() - Reset normal (modo:', currentMode, ')');
        
        // ğŸ”§ CORREÃ‡ÃƒO: Garantir que o modal pode ser usado novamente
        // Limpar cache de arquivos para forÃ§ar novo processamento
        const fileInput = document.getElementById('modalAudioFileInput');
        if (fileInput) {
            fileInput.value = ''; // Limpar input para permitir re-seleÃ§Ã£o do mesmo arquivo
        }
        
        // Resetar flags globais para prÃ³xima anÃ¡lise
        if (typeof window !== 'undefined') {
            delete window.__AUDIO_ADVANCED_READY__;
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        
        // ğŸ”§ FIX: Verificar se hÃ¡ comparaÃ§Ã£o ativa antes de limpar
        const hasActiveComparison = window.__referenceComparisonActive === true;
        
        // ğŸš¨ BLINDAGEM: NÃƒO limpar FirstAnalysisStore em modo genre
        const isGenreMode = window.__CURRENT_MODE__ === 'genre';
        
        if (!hasActiveComparison && !isGenreMode) {
            // ğŸ§¹ LIMPEZA COMPLETA: Apenas se nÃ£o houver comparaÃ§Ã£o ativa E nÃ£o for modo genre
            // ğŸ”’ HARD-GUARD: Limpar FirstAnalysisStore (Ãºnica fonte de verdade)
            FirstAnalysisStore.clear();
            
            // âŒ REMOVER: window.referenceAnalysisData agora Ã© read-only (nÃ£o pode ser setado)
            // Ele sempre aponta para FirstAnalysisStore.get(), que acabamos de limpar
            
            // Limpar Mode Engine
            SOUNDY_MODE_ENGINE.clear();
            
            referenceComparisonMetrics = null;
            window.lastReferenceJobId = null;
            
            // Limpar IDs de referÃªncia
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            
            log('[CLEANUP] closeAudioModal: LIMPEZA TOTAL (sem comparaÃ§Ã£o ativa)');
            log('[CLEANUP] FirstAnalysisStore limpo - window.referenceAnalysisData agora retorna null');
        } else if (isGenreMode) {
            // Preservar gÃªnero em modo genre
            log('[CLEANUP] closeAudioModal: PRESERVANDO gÃªnero (modo genre)');
            log('[GENRE-PROTECT] âš ï¸ Limpeza FirstAnalysisStore BLOQUEADA em modo genre');
            log('[GENRE-PROTECT]   - Preservando:', {
                selectedGenre: window.__CURRENT_SELECTED_GENRE,
                mode: window.__CURRENT_MODE__
            });
        } else {
            // Preservar dados de referÃªncia
            log('[CLEANUP] closeAudioModal: PRESERVANDO referÃªncia (comparaÃ§Ã£o ativa)');
            log('[CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            log('[CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
            log('[CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
        }
        
        // Limpeza de state global (sempre limpar estado temporÃ¡rio de renderizaÃ§Ã£o)
        const state = window.__soundyState || {};
        if (state.reference) {
            state.reference.analysis = null;
            state.reference.isSecondTrack = false;
            // NÃƒO limpar jobId se houver comparaÃ§Ã£o ativa
            if (!hasActiveComparison) {
                state.reference.jobId = null;
                state.reference.userAnalysis = null;
                state.reference.referenceAnalysis = null;
            }
        }
        
        // Limpar anÃ¡lises temporÃ¡rias mas preservar previousAnalysis se necessÃ¡rio
        state.userAnalysis = null;
        state.referenceAnalysis = null;
        if (!hasActiveComparison) {
            state.previousAnalysis = null;
        }
        
        state.render = state.render || {};
        state.render.mode = null;
        
        window.__soundyState = state;
        
        __dbg('âœ… Modal resetado e pronto para prÃ³xima anÃ¡lise');
    }
}

// ğŸ”„ Reset estado do modal
/**
 * ğŸ†• NOVA FUNÃ‡ÃƒO: Limpa APENAS estado visual de upload
 * NÃƒO toca em gÃªnero, targets ou localStorage
 * Usada ao abrir modal de anÃ¡lise (preserva seleÃ§Ã£o de gÃªnero)
 */
function clearAudioOnlyState() {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    const fileInput = document.getElementById('modalAudioFileInput');

    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    if (fileInput) fileInput.value = '';

    log('[AUDIO-RESET] âœ… Apenas estado de Ã¡udio foi limpo (gÃªnero preservado)');
    log('[AUDIO-RESET] ğŸ“Š GÃªnero mantido:', {
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE,
        __CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        hasTargets: !!window.__activeRefData
    });
}

function resetModalState() {
    __dbg('ğŸ”„ Resetando estado do modal...');
    
    // ï¿½ï¸ FIX 1: Verificar state machine primeiro, fallback para currentAnalysisMode
    const stateMachine = window.AnalysisStateMachine;
    const currentMode = stateMachine?.getMode() || window.currentAnalysisMode;
    
    // ğŸ”’ Guard primÃ¡rio: NUNCA resetar em modo reference
    if (currentMode === 'reference') {
        warn('[REF_FIX] ğŸ”’ resetModalState() BLOQUEADO - modo Reference ativo');
        log('[REF_FIX] Fonte:', stateMachine ? 'StateMachine' : 'currentAnalysisMode');
        return;
    }
    
    // ğŸ”’ Guard secundÃ¡rio: NUNCA resetar se aguardando segunda track
    if (stateMachine?.isAwaitingSecondTrack?.()) {
        warn('[REF_FIX] ğŸ”’ resetModalState() BLOQUEADO - aguardando segunda track');
        return;
    }
    
    // ğŸš¨ BLINDAGEM: NUNCA resetar em modo genre (guard original)
    // FIX: Remover dependÃªncia de window.__CURRENT_MODE__ (variÃ¡vel fantasma)
    if (currentMode === 'genre') {
        warn('[GENRE-PROTECT] âš ï¸ resetModalState() BLOQUEADO em modo genre');
        warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: currentMode
        });
        return; // NÃƒO executar reset
    }
    
    // âœ… CORREÃ‡ÃƒO: NÃƒO preservar gÃªnero em modo reference
    // Isso estava causando contaminaÃ§Ã£o de estado
    if (currentMode !== 'reference') {
        // ğŸ”’ PATCH: PRESERVAR GÃŠNERO SOMENTE EM MODO GENRE
        preserveGenreState();
    } else {
        log('[REF_FIX] ğŸ”’ preserveGenreState() BLOQUEADO - modo Reference nÃ£o usa gÃªnero');
    }
    
    // ===============================================================
    // ğŸ”’ BLOCO 1 â€” PRESERVAR GÃŠNERO ANTES DO RESET
    // ===============================================================
    let __PRESERVED_GENRE__ = null;
    let __PRESERVED_TARGETS__ = null;

    // âœ… CORREÃ‡ÃƒO: SÃ³ preservar gÃªnero se NÃƒO estiver em modo reference
    if (currentMode !== 'reference') {
        try {
            const genreSelect = document.getElementById("audioRefGenreSelect");

            __PRESERVED_GENRE__ =
                window.__CURRENT_SELECTED_GENRE ||
                window.PROD_AI_REF_GENRE ||
                (genreSelect ? genreSelect.value : null);
            
            __PRESERVED_TARGETS__ =
                window.__CURRENT_GENRE_TARGETS ||
                window.currentGenreTargets ||
                window.__activeRefData?.targets;

            log("[SAFE-RESET] âš ï¸ Preservando gÃªnero selecionado:", __PRESERVED_GENRE__);
            log("[SAFE-RESET] âš ï¸ Preservando targets:", __PRESERVED_TARGETS__ ? Object.keys(__PRESERVED_TARGETS__) : 'null');
        } catch (e) {
            warn("[SAFE-RESET] Falha ao capturar gÃªnero antes do reset:", e);
        }
    } else {
        log("[REF_FIX] ğŸ”’ PreservaÃ§Ã£o de gÃªnero/targets BLOQUEADA - modo Reference ativo");
    }
    
    // Mostrar Ã¡rea de upload
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    // Reset progress
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    currentModalAnalysis = null;
    
    // ğŸš« CRITICAL: Limpar globalmente tambÃ©m
    window.currentModalAnalysis = null;
    window.__CURRENT_ANALYSIS__ = null;
    
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';
    
    // ğŸ§© CORREÃ‡ÃƒO #4: Reset completo de estado (limpeza total)
    const state = window.__soundyState || {};
    
    // Limpar completamente estado de referÃªncia
    state.reference = null;
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    // Limpar modo de renderizaÃ§Ã£o
    if (!state.render) state.render = {};
    state.render.mode = null;
    
    window.__soundyState = state;
    
    // ğŸ”¥ FIX-REFERENCE: Verificar se estamos aguardando segunda mÃºsica ANTES de limpar
    const isAwaitingSecondTrack = currentAnalysisMode === 'reference' && window.__REFERENCE_JOB_ID__;
    
    log('[FIX_REFID_RESET] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log(`[FIX_REFID_RESET] Mode atual: ${currentAnalysisMode}`);
    log(`[FIX_REFID_RESET] Reference Job ID existe: ${window.__REFERENCE_JOB_ID__ ? 'SIM' : 'NÃƒO'}`);
    log(`[FIX_REFID_RESET] Aguardando segunda mÃºsica: ${isAwaitingSecondTrack ? 'SIM' : 'NÃƒO'}`);

    if (!isAwaitingSecondTrack) {
        // ğŸ§¼ LIMPEZA COMPLETA: SÃ³ limpar se NÃƒO estivermos aguardando segunda mÃºsica
        SOUNDY_MODE_ENGINE.clear();
        window.__REFERENCE_JOB_ID__ = null;
        window.referenceComparisonMetrics = null;
        window.lastReferenceJobId = null;
        delete window.__REFERENCE_JOB_ID__;
        localStorage.removeItem('referenceJobId');
        
        // âœ… LIMPAR FirstAnalysisStore
        FirstAnalysisStore.clear();
        
        log('[FIX_REFID_RESET] Estado limpo completamente âœ…');
        log('[FIX_REFID_RESET] Limpeza incluiu: window, localStorage e estado global');
        log('[FIX_REFID_RESET] Flags de referÃªncia LIMPAS (modo nÃ£o-reference)');
    } else {
        // Preservar IDs de referÃªncia para segunda mÃºsica
        log('[FIX_REFID_RESET] âš ï¸ PRESERVANDO flags de referÃªncia!');
        log(`[FIX_REFID_RESET] Reference Job ID mantido: ${window.__REFERENCE_JOB_ID__}`);
        log(`[FIX_REFID_RESET] localStorage.referenceJobId: ${localStorage.getItem('referenceJobId')}`);
        log('[FIX_REFID_RESET] Aguardando upload da segunda mÃºsica...');
    }
    log('[FIX_REFID_RESET] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

    // Flags internas
    delete window.__AUDIO_ADVANCED_READY__;
    delete window.__MODAL_ANALYSIS_IN_PROGRESS__;    log('[CLEANUP] resetModalState: estado global/flags limpos');
    
    // ===============================================================
    // ğŸ”’ BLOCO 3 â€” RESTAURAR GÃŠNERO E TARGETS APÃ“S O RESET
    // ===============================================================
    try {
        // âœ… CORREÃ‡ÃƒO: SÃ³ restaurar gÃªnero se NÃƒO estiver em modo reference
        if (currentMode !== 'reference') {
            const genreSelect = document.getElementById("audioRefGenreSelect");

            if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
                window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
                window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;

                if (genreSelect) {
                    genreSelect.value = __PRESERVED_GENRE__;
                }

                log("[SAFE-RESET] âœ… GÃªnero restaurado apÃ³s reset:", __PRESERVED_GENRE__);
            } else {
                warn("[SAFE-RESET] âš ï¸ Nenhum gÃªnero vÃ¡lido preservado.");
            }
        } else {
            log("[REF_FIX] ğŸ”’ RestauraÃ§Ã£o de gÃªnero BLOQUEADA - modo Reference ativo");
        }
        
        // ğŸ”’ PATCH: RESTAURAR TARGETS TAMBÃ‰M (somente em modo genre)
        if (__PRESERVED_TARGETS__ && currentMode !== 'reference') {
            window.__CURRENT_GENRE_TARGETS = __PRESERVED_TARGETS__;
            window.currentGenreTargets = __PRESERVED_TARGETS__;
            log("[SAFE-RESET] âœ… Targets restaurados apÃ³s reset:", Object.keys(__PRESERVED_TARGETS__));
        }
    } catch (e) {
        warn("[SAFE-RESET] Falha ao restaurar gÃªnero:", e);
    }
    
    // ğŸ”“ RESTAURAR BOTÃƒO "PLANO DE CORREÃ‡ÃƒO" (visÃ­vel em outros modos)
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan && currentMode !== 'reference') {
        btnCorrectionPlan.style.display = '';
        log('[RESET-UI] âœ… BotÃ£o "Plano de CorreÃ§Ã£o" restaurado');
    }
    
    __dbg('âœ… Estado do modal resetado completamente');
}

// âš™ï¸ Configurar modal de Ã¡udio
function setupAudioModal() {
    const modal = document.getElementById('audioAnalysisModal');
    const fileInput = document.getElementById('modalAudioFileInput');
    const uploadArea = document.getElementById('audioUploadArea');
    
    if (!modal || !fileInput || !uploadArea) {
        __dwrn('âš ï¸ Elementos do modal nÃ£o encontrados');
        return;
    }
    
    // Fechar modal clicando fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeAudioModal();
        }
    });
    
    // Fechar modal com ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeAudioModal();
        }
    });
    
    // Detectar se Ã© dispositivo mÃ³vel
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (!isMobile) {
        // Drag and Drop (apenas para desktop)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleModalFileSelection(files[0]);
            }
        });
    }
    
    // File input change event
    fileInput.addEventListener('change', (e) => {
        __dbg('ğŸ“ File input change triggered');
        if (e.target.files.length > 0) {
            __dbg('ğŸ“ File selected:', e.target.files[0].name);
            handleModalFileSelection(e.target.files[0]);
        }
    });
    
    // NÃ£o adicionar nenhum listener JS ao botÃ£o/label de upload!
    uploadArea.onclick = null;
    
    __dbg('âœ… Modal de Ã¡udio configurado com sucesso');
}

// ğŸ“ Processar arquivo selecionado no modal
/**
 * ğŸ¯ HELPER: Retorna state machine seguro (nunca undefined)
 * @returns {Object} State machine real ou stub funcional
 */
function getSafeStateMachine() {
    if (window.AnalysisStateMachine) {
        return window.AnalysisStateMachine;
    }
    
    warn('[STATE-MACHINE] âš ï¸ AnalysisStateMachine nÃ£o carregado - usando stub');
    
    // Stub funcional que preserva estado
    return {
        getMode: () => window.currentAnalysisMode || 'genre',
        setMode: (mode, opts) => {
            log('[STATE-MACHINE-STUB] setMode:', mode, opts);
            window.currentAnalysisMode = mode;
            if (opts?.userExplicitlySelected) {
                window.userExplicitlySelectedReferenceMode = (mode === 'reference');
            }
        },
        getState: () => ({
            mode: window.currentAnalysisMode || 'genre',
            userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
            referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null
        })
    };
}

async function handleModalFileSelection(file) {
    __dbg('ğŸ“ Arquivo selecionado no modal:', file.name);
    
    // ğŸ”“ [ANONYMOUS-MODE] Interceptar anÃ¡lise em modo anÃ´nimo - PONTO CRÃTICO DE BLOQUEIO
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            log('ğŸš« [ANONYMOUS] AnÃ¡lise bloqueada em handleModalFileSelection - limite atingido');
            return; // Modal de login jÃ¡ foi mostrado
        }
        log('âœ… [ANONYMOUS] AnÃ¡lise permitida em modo anÃ´nimo');
    }
    
    // ğŸ® [DEMO-MODE] Interceptar anÃ¡lise em modo demo
    if (window.SoundyDemo?.isActive) {
        const canProceed = window.SoundyDemo.interceptAnalysis();
        if (!canProceed) {
            log('ğŸš« [DEMO] AnÃ¡lise bloqueada - limite atingido');
            return; // Modal de conversÃ£o jÃ¡ foi mostrado
        }
        log('âœ… [DEMO] AnÃ¡lise permitida em modo demo');
    }
    
    // ï¿½ğŸ” [INVARIANTE #1] Verificar estado do mode ANTES de qualquer processamento
    const stateMachine = getSafeStateMachine();  // âœ… Nunca undefined
    const currentMode = stateMachine.getMode();
    
    console.group('[REF_DEBUG] ğŸ¯ handleModalFileSelection - INÃCIO');
    log('ğŸ“ Arquivo:', file.name);
    log('ğŸ¯ currentAnalysisMode (window):', window.currentAnalysisMode);
    log('ğŸ¯ StateMachine.getMode():', stateMachine?.getMode());
    log('ğŸ¯ StateMachine.state:', stateMachine?.getState());
    log('ğŸ”’ userExplicitlySelectedReferenceMode:', window.userExplicitlySelectedReferenceMode);
    log('ğŸ”‘ __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    log('ğŸ“Š FirstAnalysisStore:', FirstAnalysisStore?.has());
    console.groupEnd();
    
    // ğŸ§¹ ISOLAMENTO: Se modo reference, resetar contexto de gÃªnero
    if (window.currentAnalysisMode === 'reference' || currentMode === 'reference') {
        resetGenreContextForReference();
    }
    
    // ğŸ”’ [INVARIANTE #1] Se estamos em reference mas state machine nÃ£o estÃ¡, CORRIGIR
    if (window.currentAnalysisMode === 'reference' && currentMode !== 'reference') {
        error('%c[INVARIANTE #1 VIOLADA] currentAnalysisMode=reference mas StateMachine=' + currentMode, 'color:red;font-weight:bold;font-size:14px;');
        error('[FIX_ATTEMPT] Tentando corrigir state machine para reference...');
        
        if (stateMachine) {
            try {
                stateMachine.setMode('reference', { userExplicitlySelected: true });
                log('%c[FIX_SUCCESS] State machine corrigido para reference', 'color:green;font-weight:bold;');
            } catch (err) {
                error('[FIX_FAILED] NÃ£o foi possÃ­vel corrigir state machine:', err);
                alert('âš ï¸ ERRO: Estado inconsistente. Por favor, selecione o modo A/B novamente.');
                return;
            }
        } else {
            error('[FIX_FAILED] AnalysisStateMachine nÃ£o disponÃ­vel!');
            alert('âš ï¸ ERRO: Sistema nÃ£o inicializado corretamente.');
            return;
        }
    }
    
    // ========================================
    // ğŸ”’ DECLARAÃ‡ÃƒO DE ESCOPO GLOBAL: normalizedFirst
    // ========================================
    // Garantir que normalizedFirst sempre exista no escopo da funÃ§Ã£o
    let normalizedFirst = window.__FIRST_ANALYSIS_FROZEN__ 
        ? structuredClone(window.__FIRST_ANALYSIS_FROZEN__) 
        : null;
    
    // ğŸ”§ CORREÃ‡ÃƒO: Prevenir mÃºltiplas anÃ¡lises simultÃ¢neas
    if (typeof window !== 'undefined' && window.__MODAL_ANALYSIS_IN_PROGRESS__) {
        __dbg('âš ï¸ AnÃ¡lise jÃ¡ em progresso, ignorando nova seleÃ§Ã£o');
        return;
    }
    
    try {
        // Marcar anÃ¡lise em progresso
        if (typeof window !== 'undefined') {
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = true;
        }
        
        // ValidaÃ§Ã£o comum de arquivo
        if (!validateAudioFile(file)) {
            return; // validateAudioFile jÃ¡ mostra erro
        }
        
        // ğŸŒ NOVO FLUXO COMPLETO: Presigned URL â†’ Upload â†’ Job Creation â†’ Polling
        __dbg('ğŸŒ Iniciando fluxo de anÃ¡lise remota completo...');
        
        // Mostrar loading
        hideUploadArea();
        showAnalysisLoading();
        showUploadProgress(`Preparando upload de ${file.name}...`);
        
        // ğŸŒ ETAPA 1: Obter URL prÃ©-assinada
        const { uploadUrl, fileKey } = await getPresignedUrl(file);
        
        // ğŸŒ ETAPA 2: Upload direto para bucket
        await uploadToBucket(uploadUrl, file);
        
        // ğŸŒ ETAPA 3: Criar job de anÃ¡lise no backend
        const jobResult = await createAnalysisJob(fileKey, currentAnalysisMode, file.name);
        
        // ğŸ”¥ [DEMO] Se anÃ¡lise foi bloqueada, interromper fluxo (modal de upgrade jÃ¡ foi exibido)
        if (jobResult.blocked || jobResult.showConversion) {
            log('ğŸš« [DEMO] AnÃ¡lise bloqueada - fluxo interrompido');
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = false;
            return; // Modal de conversÃ£o jÃ¡ estÃ¡ sendo exibido
        }
        
        const { jobId } = jobResult;
        
        // ğŸŒ ETAPA 4: Acompanhar progresso e aguardar resultado
        showUploadProgress(`Analisando ${file.name}... Aguarde.`);
        const analysisResult = await pollJobStatus(jobId);
        
        // ğŸ¯ REDUCED MODE AUTO-ACTIVATION: Detectar se backend retornou modo reduced
        // Isso acontece quando free/plus/pro atingem seu limite de anÃ¡lises completas
        if (analysisResult.analysisMode === 'reduced' || analysisResult.mode === 'reduced') {
            log('%c[REDUCED-MODE] âš ï¸ Backend sinalizou modo REDUCED', 'color:orange;font-weight:bold;font-size:14px;');
            log('[REDUCED-MODE] Ativando modo reduced automaticamente...');
            log('[REDUCED-MODE] UsuÃ¡rio pode continuar analisando com mÃ©tricas limitadas');
            
            // ForÃ§ar window.analysisMode para 'reduced'
            window.analysisMode = 'reduced';
            
            // Mostrar toast informativo (nÃ£o bloqueante)
            if (window.showToast || window.Toastify) {
                const message = 'VocÃª atingiu o limite de anÃ¡lises completas. Continuando em modo reduzido (mÃ©tricas bÃ¡sicas).';
                if (window.showToast) {
                    window.showToast(message, 'warning');
                } else if (window.Toastify) {
                    window.Toastify({
                        text: message,
                        duration: 7000,
                        gravity: "top",
                        position: "center",
                        backgroundColor: "#ff9800",
                        stopOnFocus: true
                    }).showToast();
                }
            } else {
                // Fallback: log no console
                log('%c[REDUCED-MODE] âš ï¸ MODO REDUZIDO ATIVADO', 'color:orange;font-weight:bold;font-size:16px;');
                log('[REDUCED-MODE] MÃ©tricas disponÃ­veis: Score, LUFS, True Peak, Dynamic Range');
                log('[REDUCED-MODE] MÃ©tricas bloqueadas: FrequÃªncias, EstÃ©reo, Detalhes avanÃ§ados');
            }
        }
        
        // ğŸ“ FIX CRÃTICO: Injetar file.name no resultado ANTES de salvar no store
        // O backend retorna technicalData mas nÃ£o inclui fileName no resultado
        // Garantimos que fileName esteja disponÃ­vel em ambos os caminhos (root e metadata)
        if (file && file.name) {
            if (!analysisResult.fileName) {
                analysisResult.fileName = file.name;
                log('[FILENAME-FIX] âœ… Injetado fileName no analysisResult:', file.name);
            }
            if (!analysisResult.metadata) {
                analysisResult.metadata = {};
            }
            if (!analysisResult.metadata.fileName) {
                analysisResult.metadata.fileName = file.name;
                log('[FILENAME-FIX] âœ… Injetado metadata.fileName no analysisResult:', file.name);
            }
        }
        
        // ï¿½ğŸŒ ETAPA 5: Processar resultado baseado no modo e contexto
        // ğŸ¯ [FLUXO DETERMINÃSTICO] Usar BINDING como ÃšNICA fonte de verdade
        const jobMode = analysisResult.mode || currentAnalysisMode;
        
        // âœ… NOVO FLUXO: Usar binding de job (imutÃ¡vel e confiÃ¡vel)
        const refFlow = window.referenceFlow;
        const jobBinding = refFlow ? refFlow.getJobBinding(jobId) : null;
        
        const isFirstReferenceTrack = jobBinding && jobBinding.track === 'base';
        const isSecondTrack = jobBinding && jobBinding.track === 'compare';
        
        // ğŸ” [DEBUG] Log detalhado do estado
        console.group('[REF-FLOW] ğŸ¯ DeterminaÃ§Ã£o de Track (Primeira vs Segunda)');
        log('ğŸ“Š analysisResult.mode:', analysisResult?.mode);
        log('ğŸ¯ currentAnalysisMode:', currentAnalysisMode);
        log('ğŸ”‘ jobId retornado:', jobId);
        log('ğŸ”’ jobBinding:', jobBinding);
        log('ğŸ° ReferenceFlow.stage:', refFlow?.getStage());
        log('ğŸ” Binding Info:');
        log('  - track:', jobBinding?.track);
        log('  - baseJobId:', jobBinding?.baseJobId);
        log('  - referenceJobId:', jobBinding?.referenceJobId);
        log('âœ… RESULTADO:');
        log('  - isFirstReferenceTrack:', isFirstReferenceTrack);
        log('  - isSecondTrack:', isSecondTrack);
        console.groupEnd();
        
        if (isFirstReferenceTrack) {
            log('%c[REF-FLOW] ğŸ¯ PRIMEIRA TRACK EM REFERENCE MODE', 'color:cyan;font-weight:bold;font-size:14px;');
            
            // âœ… Chamar onFirstTrackCompleted quando job completa
            if (refFlow && jobId) {
                refFlow.onFirstTrackCompleted(analysisResult);
            }
            
            // ğŸ”’ [INVARIANTE #1] Garantir que state machine estÃ¡ em reference ANTES de startReferenceFirstTrack
            const stateMachine = getSafeStateMachine();
            const smMode = stateMachine?.getMode();
            if (smMode !== 'reference') {
                error('%c[INVARIANTE #1 VIOLADA] State machine nÃ£o estÃ¡ em reference antes de startReferenceFirstTrack!', 'color:red;font-weight:bold;font-size:14px;');
                error('[STATE] smMode:', smMode, '| currentAnalysisMode:', currentAnalysisMode);
                
                // Tentar corrigir
                if (stateMachine && currentAnalysisMode === 'reference') {
                    warn('[FIX_ATTEMPT] Corrigindo state machine para reference...');
                    stateMachine.setMode('reference', { userExplicitlySelected: true });
                    log('%c[FIX_SUCCESS] State machine corrigido', 'color:green;font-weight:bold;');
                } else {
                    alert('âš ï¸ ERRO: Estado inconsistente no modo referÃªncia. Por favor, recarregue a pÃ¡gina.');
                    return;
                }
            }
            
            // PRIMEIRA mÃºsica em modo reference: abrir modal para mÃºsica de referÃªncia
            __dbg('ğŸ¯ Primeira mÃºsica analisada - abrindo modal para segunda');
            
            // ========================================
            // ğŸ”’ SALVAR PRIMEIRA ANÃLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel USER
            const { vid: userVid, clone: userClone } = cacheResultByRole(analysisResult, { isSecondTrack: false });
            
            // ğŸ’¾ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveFirstAnalysis(userClone || analysisResult);
            
            // Atualizar normalizedFirst para uso nos logs e modal
            if (!normalizedFirst && userClone) {
                normalizedFirst = userClone;
                window.__FIRST_ANALYSIS_FROZEN__ = structuredClone(normalizedFirst); // Mantido para compatibilidade
                log('[SCOPE] âœ… normalizedFirst inicializado com userClone');
            }
            
            if (!window.FirstAnalysisStore?.has()) {
                // ï¿½ PR1: Log tentativa de salvar primeira track
                if (window.logStep) {
                    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
                    window.logStep(traceId, 'FIRST_TRACK_SAVED', {
                        jobId: analysisResult.jobId,
                        fileName: userClone?.fileName || userClone?.metadata?.fileName,
                        vid: userVid,
                        userExplicitlySelectedReferenceMode: userExplicitlySelectedReferenceMode,
                        willSaveAsReference: userExplicitlySelectedReferenceMode,
                    });
                }
                
                // PROTEÃ‡ÃƒO CRÃTICA: NÃ£o salvar como referÃªncia se modo nÃ£o foi selecionado explicitamente
                const hasContext = hasActiveReferenceContext();
                const allowSave = userExplicitlySelectedReferenceMode || hasContext;
                
                log('[REF-GUARD] Salvando primeira anÃ¡lise:', {
                  userExplicit: userExplicitlySelectedReferenceMode,
                  hasContext,
                  allowed: allowSave
                });
                
                if (!allowSave) {
                    warn('%c[PROTECTION] âš ï¸ BLOQUEIO: Tentativa de salvar __REFERENCE_JOB_ID__ mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FFA500;font-weight:bold;');
                    warn('[PROTECTION] âš ï¸ Sistema em modo genre - ignorando salvamento de referÃªncia');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃƒO executar salvamento de referÃªncia
                } else {
                    // Salvar como USER no FirstAnalysisStore
                    FirstAnalysisStore.setUser(userClone, userVid, analysisResult.jobId);
                    window.__REFERENCE_JOB_ID__ = analysisResult.jobId;
                    
                    log('[A/B] ğŸ§Š primeira faixa salva com VID', {
                        vid: userVid,
                        jobId: analysisResult.jobId, 
                        file: userClone?.fileName || userClone?.metadata?.fileName,
                        role: 'USER'
                    });
                    log('%c[PROTECTION] âœ… __REFERENCE_JOB_ID__ definido - flag verificada', 'color:#00FF88;font-weight:bold;');
                }
            }
            
            // ğŸ” AUDITORIA: Estado APÃ“S salvar primeira anÃ¡lise
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ’¾ Primeira AnÃ¡lise SALVA');
            log('âš™ï¸ Contexto: Salvamento da primeira faixa');
            log('ğŸ“Š analysisResult (original):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const storedFirst = FirstAnalysisStore.get();
            log('ğŸ”’ FirstAnalysisStore (clone):', {
                jobId: storedFirst?.jobId,
                fileName: storedFirst?.metadata?.fileName || storedFirst?.fileName,
                lufs: storedFirst?.technicalData?.lufsIntegrated,
                sameAsOriginal: false // sempre retorna clone
            });
            log('ğŸ’¡ VerificaÃ§Ã£o de isolamento:');
            log('  FirstAnalysisStore.get() !== analysisResult?', storedFirst !== analysisResult);
            log('  FirstAnalysisStore retorna clones:', true);
            console.groupEnd();
            
            // ========================================
            // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO: Garantir que normalizedFirst existe
            // ========================================
            if (!normalizedFirst) {
                warn('[WARN] normalizedFirst ausente â€” usando fallback do FirstAnalysisStore.');
                normalizedFirst = structuredClone(FirstAnalysisStore.getUser() || {});
            }
            
            log('[REF-SAVE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('[REF-SAVE âœ…] Primeira mÃºsica processada com sucesso!');
            log(`[REF-SAVE âœ…] Job ID salvo globalmente: ${normalizedFirst?.jobId || 'unknown'}`);
            log('[REF-SAVE âœ…] Locais de salvamento:');
            log('[REF-SAVE âœ…]   - window.__REFERENCE_JOB_ID__');
            log('[REF-SAVE âœ…]   - localStorage.referenceJobId');
            log('[REF-SAVE âœ…]   - window.AnalysisCache (imutÃ¡vel)');
            log('[REF-SAVE âœ…]   - window.FirstAnalysisStore (imutÃ¡vel + clonagem automÃ¡tica)');
            log(`[REF-SAVE âœ…] File Name: ${normalizedFirst?.metadata?.fileName || normalizedFirst?.fileName || 'unknown'}`);
            log(`[REF-SAVE âœ…] LUFS: ${normalizedFirst?.technicalData?.lufsIntegrated || 'N/A'} LUFS`);
            log(`[REF-SAVE âœ…] DR: ${normalizedFirst?.technicalData?.dynamicRange || 'N/A'} dB`);
            log('[REF-SAVE âœ…] Este ID serÃ¡ usado na segunda mÃºsica');
            log('[REF-SAVE âœ…] Primeira anÃ¡lise salva e congelada.');
            log('[REF-SAVE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ¯ TRANSIÃ‡ÃƒO DE ESTADO: REF_A_DONE â†’ REF_B_WAIT_UPLOAD
            log('%c[REF-FLOW] ğŸ¯ TRANSIÃ‡ÃƒO DE ESTADO: REF_A_DONE â†’ REF_B_WAIT_UPLOAD', 'color:#00FF88;font-weight:bold;font-size:14px;');
            log('[REF-FLOW] Estado atual:', {
                stage: 'REF_A_DONE',
                firstJobId: normalizedFirst?.jobId,
                hasFirstAnalysis: FirstAnalysisStore?.has(),
                currentMode: window.currentAnalysisMode,
                userExplicitFlag: window.userExplicitlySelectedReferenceMode
            });
            
            // âœ… Notificar referenceFlow sobre conclusÃ£o da primeira track
            if (refFlow && normalizedFirst) {
                refFlow.onFirstTrackCompleted(normalizedFirst);
                log('[REF-FLOW] âœ… onFirstTrackCompleted() chamado');
            }
            
            if (normalizedFirst && normalizedFirst.jobId) {
                openReferenceUploadModal(normalizedFirst.jobId, normalizedFirst);
            } else {
                error('[ERROR] âŒ NÃ£o foi possÃ­vel abrir modal: normalizedFirst invÃ¡lido');
            }
        } else if (isSecondTrack) {
            // âœ… SEGUNDA mÃºsica em modo reference: mostrar resultado comparativo
            log('%c[REF-FLOW] ğŸ¯ TRANSIÃ‡ÃƒO: REF_B_PROCESSING â†’ REF_B_DONE', 'color:#00FF88;font-weight:bold;font-size:14px;');
            log('[REF-FLOW] Segunda track detectada - bloco de comparaÃ§Ã£o A/B');
            log('[REF-FLOW] Estado atual:', {
                stage: 'REF_B_DONE',
                jobMode: jobMode,
                currentAnalysisMode: currentAnalysisMode,
                secondJobId: analysisResult?.jobId,
                baseJobId: refFlow?.getBaseJobId(),
                hasFirstAnalysis: FirstAnalysisStore?.has()
            });
            
            // âœ… Notificar referenceFlow sobre conclusÃ£o da segunda track
            if (refFlow) {
                refFlow.onCompareCompleted(analysisResult);
                log('[REF-FLOW] âœ… onCompareCompleted() chamado');
            }
            
            __dbg('ğŸ¯ Segunda mÃºsica analisada - exibindo resultado comparativo');
            
            // ========================================
            // ğŸ”’ SALVAR SEGUNDA ANÃLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel REF
            const { vid: refVid, clone: refClone } = cacheResultByRole(analysisResult, { isSecondTrack: true });
            
            // ğŸ’¾ SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveSecondAnalysis(refClone || analysisResult);
            
            // ğŸ¯ NORMALIZAR ANTES DE SALVAR: Garante shape consistente
            const refNormalized = normalizeAnalysis(refClone || analysisResult);
            
            // Salvar como REF no FirstAnalysisStore (mantido para compatibilidade)
            FirstAnalysisStore.setRef(refNormalized, refVid, analysisResult.jobId);
            
            log('[STORE-SAVE] âœ… ReferÃªncia salva NORMALIZADA:', {
                jobId: analysisResult.jobId,
                hasBands: !!refNormalized.bands && Object.keys(refNormalized.bands).length > 0,
                hasMetrics: !!refNormalized.metrics && Object.keys(refNormalized.metrics).length > 0
            });
            
            log('[A/B] ğŸ§Š segunda faixa salva com VID', {
                vid: refVid,
                jobId: analysisResult.jobId,
                file: refClone?.fileName || refClone?.metadata?.fileName,
                role: 'REF'
            });
            
            // ï¿½ AUDITORIA: Estado ANTES de construir estrutura A/B
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ¯ Segunda AnÃ¡lise RECEBIDA');
            log('âš™ï¸ Contexto: RecepÃ§Ã£o da segunda faixa');
            log('ğŸ“Š analysisResult (2Âª faixa):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const frozenFirst = FirstAnalysisStore.get();
            log('ğŸ”’ FirstAnalysisStore (1Âª faixa congelada):', {
                jobId: frozenFirst?.jobId,
                fileName: frozenFirst?.metadata?.fileName,
                lufs: frozenFirst?.technicalData?.lufsIntegrated
            });
            log('ğŸ’¾ window.__soundyState.previousAnalysis (1Âª faixa):', {
                jobId: window.__soundyState?.previousAnalysis?.jobId,
                fileName: window.__soundyState?.previousAnalysis?.metadata?.fileName,
                lufs: window.__soundyState?.previousAnalysis?.technicalData?.lufsIntegrated,
                objectId: window.__soundyState?.previousAnalysis
            });
            log('âš ï¸ CHECKPOINT CRÃTICO: Verificar se objetos sÃ£o distintos');
            log('  analysisResult !== previousAnalysis?', analysisResult !== window.__soundyState?.previousAnalysis);
            log('  analysisResult !== FirstAnalysisStore?', analysisResult !== FirstAnalysisStore.get());
            console.groupEnd();
            
            // ï¿½ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Primeira mÃºsica Ã© ATUAL (sua faixa), segunda Ã© REFERÃŠNCIA (alvo)
            const state = window.__soundyState || {};
            
            // ğŸ§Š PROTEÃ‡ÃƒO ANTIFALSA ATUALIZAÃ‡ÃƒO DA REFERÃŠNCIA
            if (state?.render?.mode === 'reference' && window.__FIRST_ANALYSIS_FROZEN__) {
                warn('[STATE-FIX] ğŸ”’ Bloqueando sobrescrita de referÃªncia - usando cÃ³pia congelada');
                warn('[STATE-FIX]   __FIRST_ANALYSIS_FROZEN__:', window.__FIRST_ANALYSIS_FROZEN__?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
                warn('[STATE-FIX]   analysisResult (2Âª faixa):', analysisResult?.fileName || analysisResult?.metadata?.fileName);
                
                // Garantir que previousAnalysis aponte para o frozen
                if (!state.previousAnalysis || state.previousAnalysis.jobId === analysisResult.jobId) {
                    warn('[STATE-FIX] âš ï¸ Corrigindo previousAnalysis contaminado');
                    state.previousAnalysis = JSON.parse(JSON.stringify(window.__FIRST_ANALYSIS_FROZEN__));
                }
            }
            
            if (state.previousAnalysis) {
                // âœ… SEMÃ‚NTICA CORRETA DO FLUXO A/B:
                // - Primeira faixa (previousAnalysis) = userAnalysis (SUA MÃšSICA/ATUAL)
                // - Segunda faixa (analysisResult) = referenceAnalysis (ALVO/REFERÃŠNCIA a alcanÃ§ar)
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: NÃ£o permitir isSecondTrack = true se usuÃ¡rio nÃ£o selecionou modo reference
                const hasContext = hasActiveReferenceContext();
                const allowSecondTrack = userExplicitlySelectedReferenceMode || hasContext;
                
                log('[REF-GUARD] Detectando segunda track (1):', {
                  userExplicit: userExplicitlySelectedReferenceMode,
                  hasContext,
                  allowed: allowSecondTrack
                });
                
                if (!allowSecondTrack) {
                    error('%c[PROTECTION] âŒ BLOQUEIO CRÃTICO: Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    error('[PROTECTION] âŒ Sistema em modo genre - NÃƒO pode processar segunda track');
                    error('[PROTECTION] âŒ state.previousAnalysis existe mas modo nÃ£o Ã© reference explÃ­cito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃƒO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone obrigatÃ³rio
                log('[STATE-FIX] ğŸ”’ Criando deep clones para evitar contaminaÃ§Ã£o de estado');
                state.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));      // 1Âª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));         // 2Âª = faixa de referÃªncia (alvo)
                
                // ğŸ¯ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));    // 1Âª faixa (sua mÃºsica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));       // 2Âª faixa (referÃªncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                log('%c[PROTECTION] âœ… isSecondTrack = true PERMITIDO - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('âœ… [REFERENCE-A/B-CORRECTED] AtribuiÃ§Ã£o correta A/B:');
                log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª Faixa (ATUAL/SUA MÃšSICA):', state.previousAnalysis.fileName || state.previousAnalysis.metadata?.fileName || '1Âª Faixa');
                log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª Faixa (REFERÃŠNCIA/ALVO):', analysisResult.fileName || analysisResult.metadata?.fileName || '2Âª Faixa');
                log('âœ… [REFERENCE-A/B-CORRECTED]   ComparaÃ§Ã£o: SUA MÃšSICA vs REFERÃŠNCIA');
                log('âœ… [REFERENCE-A/B-CORRECTED]   Modal mostrarÃ¡: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
                log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª tem bandas:', !!state.userAnalysis?.technicalData?.spectral_balance);
                log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª tem bandas:', !!state.referenceAnalysis?.technicalData?.spectral_balance);
                log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // ğŸ” AUDITORIA: Estado APÃ“S construir estrutura A/B
                console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ”§ Estrutura A/B CONSTRUÃDA');
                log('âš™ï¸ Contexto: Estrutura state.reference montada');
                log('ğŸ“Š state.userAnalysis (1Âª faixa - SUA MÃšSICA):', {
                    jobId: state.userAnalysis?.jobId,
                    fileName: state.userAnalysis?.metadata?.fileName || state.userAnalysis?.fileName,
                    lufs: state.userAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.userAnalysis
                });
                log('ğŸ“Š state.referenceAnalysis (2Âª faixa - REFERÃŠNCIA):', {
                    jobId: state.referenceAnalysis?.jobId,
                    fileName: state.referenceAnalysis?.metadata?.fileName || state.referenceAnalysis?.fileName,
                    lufs: state.referenceAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.referenceAnalysis
                });
                log('âš ï¸ VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
                log('  state.userAnalysis === state.referenceAnalysis?', state.userAnalysis === state.referenceAnalysis);
                log('  state.userAnalysis === analysisResult?', state.userAnalysis === analysisResult);
                log('  state.userAnalysis === state.previousAnalysis?', state.userAnalysis === state.previousAnalysis);
                log('  state.referenceAnalysis === analysisResult?', state.referenceAnalysis === analysisResult);
                log('ğŸ’¡ PrÃ³ximo passo: Normalizar analysisResult antes de enviar para displayModalResults');
                console.groupEnd();
                
                // ğŸ¯ LOG AUDIT-MODE-FLOW (conforme solicitado)
                log('[AUDIT-MODE-FLOW]', {
                    mode: 'reference',
                    isSecondTrack: state.reference.isSecondTrack,
                    refJobId: state.reference.jobId,
                    hasUserAnalysis: !!state.userAnalysis,
                    hasReferenceAnalysis: !!state.referenceAnalysis
                });
                
                // ğŸ¯ LOG ASSERT_REF_FLOW
                log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            } else if (FirstAnalysisStore.has()) {
                // ğŸ”¥ FALLBACK: Primeira mÃºsica Ã© ATUAL (sua faixa), segunda Ã© REFERÃŠNCIA (alvo)
                const firstAnalysis = FirstAnalysisStore.get(); // sempre clone
                
                // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: NÃ£o permitir isSecondTrack = true se usuÃ¡rio nÃ£o selecionou modo reference E nÃ£o hÃ¡ contexto ativo
                const hasContextFallback = hasActiveReferenceContext();
                const allowSecondTrackFallback = userExplicitlySelectedReferenceMode || hasContextFallback;
                
                log('[REF-GUARD] isSecondTrack (FALLBACK):', {
                    userExplicit: userExplicitlySelectedReferenceMode,
                    hasContext: hasContextFallback,
                    allowed: allowSecondTrackFallback
                });
                
                if (!allowSecondTrackFallback) {
                    error('%c[PROTECTION] âŒ BLOQUEIO CRÃTICO (FALLBACK): Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    error('[PROTECTION] âŒ Sistema em modo genre - NÃƒO pode processar segunda track');
                    error('[PROTECTION] âŒ FirstAnalysisStore.has() = true mas modo nÃ£o Ã© reference explÃ­cito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃƒO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone obrigatÃ³rio
                log('[STATE-FIX] ğŸ”’ FALLBACK - Criando deep clones para evitar contaminaÃ§Ã£o');
                state.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));    // 1Âª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                 // 2Âª = referÃªncia (alvo)
                
                // ğŸ¯ ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));  // 1Âª faixa (sua mÃºsica/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                // 2Âª faixa (referÃªncia/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                log('%c[PROTECTION] âœ… isSecondTrack = true PERMITIDO (FALLBACK) - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('âœ… [REFERENCE-A/B-CORRECTED] Fallback - AtribuiÃ§Ã£o correta A/B:');
                log('âœ… [REFERENCE-A/B-CORRECTED]   1Âª Faixa (ATUAL/SUA MÃšSICA):', firstAnalysis?.fileName);
                log('âœ… [REFERENCE-A/B-CORRECTED]   2Âª Faixa (REFERÃŠNCIA/ALVO):', analysisResult.fileName);
                log('âœ… [REFERENCE-A/B-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // ğŸ¯ LOG ASSERT_REF_FLOW
                log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userTrack: state.userAnalysis?.fileName || 'Sua mÃºsica (atual)',
                    referenceTrack: state.referenceAnalysis?.fileName || 'Faixa de referÃªncia (alvo)',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            }
            
            // ğŸš¨ AUDIT_REF_FIX: NÃƒO chamar handleGenreAnalysisWithResult em modo reference!
            // Esta funÃ§Ã£o limpa o estado e forÃ§a mode='genre', quebrando o fluxo A/B
            
            // PRESERVAR modo reference atÃ© o final (reutilizar state jÃ¡ declarado acima)
            if (!state.render) state.render = {};
            state.render.mode = 'reference';
            window.__soundyState = state;
            
            log('[AUDIT_REF_FIX] Preservando modo reference atÃ© final da renderizaÃ§Ã£o');
            log('[MODE LOCKED] reference - handleGenreAnalysisWithResult PULADO');
            
            // ğŸ” AUDITORIA: Estado ANTES de normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] âš™ï¸ ANTES de normalizeBackendAnalysisData');
            log('âš™ï¸ Contexto: Prestes a normalizar analysisResult (2Âª faixa)');
            log('ğŸ“Š analysisResult (ANTES de normalizar):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const checkFirst = FirstAnalysisStore.get();
            log('ğŸ”’ FirstAnalysisStore (NÃƒO deve mudar):', {
                jobId: checkFirst?.jobId,
                fileName: checkFirst?.metadata?.fileName,
                lufs: checkFirst?.technicalData?.lufsIntegrated
            });
            log('âš ï¸ PONTO CRÃTICO: normalizeBackendAnalysisData() vai modificar analysisResult?');
            console.groupEnd();
            
            // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
            // âŒ REMOVIDO: normalizeBackendAnalysisData() destrÃ³i dados
            const normalizedResult = analysisResult; // âœ… LEITURA DIRETA
            
            // ğŸ”’ POPULAR CACHE COM RESULTADO DIRETO
            AnalysisCache.put(normalizedResult);
            
            // ğŸ”ğŸ” AUDITORIA: Estado APÃ“S normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS de normalizeBackendAnalysisData');
            log('âš™ï¸ Contexto: NormalizaÃ§Ã£o concluÃ­da');
            log('ğŸ“Š normalizedResult (resultado da normalizaÃ§Ã£o):', {
                jobId: normalizedResult?.jobId,
                fileName: normalizedResult?.metadata?.fileName || normalizedResult?.fileName,
                lufs: normalizedResult?.technicalData?.lufsIntegrated,
                objectId: normalizedResult,
                sameAsOriginal: normalizedResult === analysisResult
            });
            log('ğŸ“Š analysisResult (APÃ“S normalizaÃ§Ã£o - pode ter mudado?):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            log('ğŸ”’ window.__FIRST_ANALYSIS_FROZEN__ (deve estar INTACTO):', {
                jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
                fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
                lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
                isFrozen: Object.isFrozen(window.__FIRST_ANALYSIS_FROZEN__)
            });
            log('ğŸ’¡ PrÃ³ximo: Enviar normalizedResult para displayModalResults()');
            console.groupEnd();
            
            // ï¿½ PARTE 3.4: Garantir atribuiÃ§Ã£o correta ANTES de displayModalResults
            // ğŸ”§ PARTE 1: Normalize reference comparison structure
            if (state.render.mode === "reference" && analysisResult && state.previousAnalysis) {
                // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone para evitar mutaÃ§Ã£o
                log('[STATE-FIX] ğŸ”’ Normalizando com deep clones');
                const firstResult = JSON.parse(JSON.stringify(state.previousAnalysis));
                const secondResult = JSON.parse(JSON.stringify(analysisResult));

                const normalizedUser = {
                    fileName: firstResult.fileName || firstResult.metadata?.fileName,
                    bands: firstResult.spectralBands || firstResult.bands || firstResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: firstResult.loudness?.integrated ?? firstResult.lufsIntegrated,
                        dr: firstResult.dynamics?.dr ?? firstResult.dynamicRange,
                        peak: firstResult.truePeak?.dbtp ?? firstResult.truePeakDbtp
                    }
                };

                const normalizedRef = {
                    fileName: secondResult.fileName || secondResult.metadata?.fileName,
                    bands: secondResult.spectralBands || secondResult.bands || secondResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: secondResult.loudness?.integrated ?? secondResult.lufsIntegrated,
                        dr: secondResult.dynamics?.dr ?? secondResult.dynamicRange,
                        peak: secondResult.truePeak?.dbtp ?? secondResult.truePeakDbtp
                    }
                };

                // ğŸ§Š PROTEÃ‡ÃƒO: Usar deep clone para state.reference
                state.reference = {
                    mode: "reference",
                    isSecondTrack: true,
                    userAnalysis: JSON.parse(JSON.stringify(normalizedUser)),
                    referenceAnalysis: JSON.parse(JSON.stringify(normalizedRef)),
                    analysis: {
                        bands: JSON.parse(JSON.stringify(normalizedRef.bands))
                    }
                };

                state.render.mode = 'reference';
                window.__soundyState = state;
                log("[REF-FIX] Estrutura final corrigida", state.reference);
            }
            
            // ğŸ”¥ FORCE MODE REFERENCE EXPLICITAMENTE ANTES DE displayModalResults
            // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: SÃ³ forÃ§ar modo reference se usuÃ¡rio selecionou explicitamente OU existe contexto ativo
            const hasContextForce = hasActiveReferenceContext();
            const allowForceMode = userExplicitlySelectedReferenceMode || hasContextForce;
            
            log('[REF-GUARD] ForÃ§ando modo reference:', {
              userExplicit: userExplicitlySelectedReferenceMode,
              hasContext: hasContextForce,
              requestedMode: 'reference',
              allowed: allowForceMode
            });
            
            if (!allowForceMode) {
                error('%c[PROTECTION] âŒ BLOQUEIO: Tentativa de forÃ§ar modo reference mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                error('[PROTECTION] âŒ Sistema em modo genre - NÃƒO pode forÃ§ar modo reference');
                console.trace('[PROTECTION] Stack trace do bloqueio:');
                // NÃƒO forÃ§ar modo reference
                return;
            }
            
            state.render = state.render || {};
            state.render.mode = 'reference';
            currentAnalysisMode = 'reference';
            window.__soundyState = state;
            
            log('%c[PROTECTION] âœ… Modo forÃ§ado para reference - flag verificada', 'color:#00FF88;font-weight:bold;');
            log('ğŸ”¥ğŸ”¥ğŸ”¥ [MODE-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('ğŸ”¥ [MODE-FORCE] âœ… Modo FORÃ‡ADO para reference antes de displayModalResults');
            log('ğŸ”¥ [MODE-FORCE] state.render.mode:', state.render.mode);
            log('ğŸ”¥ [MODE-FORCE] currentAnalysisMode:', currentAnalysisMode);
            log('ğŸ”¥ [MODE-FORCE] window.__soundyState.render.mode:', window.__soundyState.render.mode);
            log('ğŸ”¥ğŸ”¥ğŸ”¥ [MODE-FORCE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ”¥ CORREÃ‡ÃƒO: Preparar dados para comparaÃ§Ã£o A/B correta
            log('[REFERENCE-FLOW] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('[REFERENCE-FLOW] Segunda mÃºsica concluÃ­da - montando comparaÃ§Ã£o A/B');
            
            // ï¿½ PASSO 2: ATIVAR PROTEÃ‡ÃƒO DE CURRENTJOBID
            const currentJobId = normalizedResult?.jobId || analysisResult?.jobId;
            // ğŸ”§ CORREÃ‡ÃƒO: Usar StorageManager
            const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
            
            if (currentJobId) {
                log('ğŸ”’ [PROTECTION] Ativando proteÃ§Ã£o para currentJobId:', currentJobId);
                log('ğŸ” [PROTECTION] ReferenceJobId:', referenceJobId);
                
                // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que jobIds sÃ£o DIFERENTES
                if (currentJobId === referenceJobId) {
                    error('âŒ [MODAL-FILE] ERRO CRÃTICO: Backend retornou mesmo jobId!');
                    error('   currentJobId:', currentJobId);
                    error('   referenceJobId:', referenceJobId);
                    console.trace();
                    alert('ERRO: O backend retornou o mesmo jobId da primeira mÃºsica. Tente novamente.');
                    return;
                }
                
                log('âœ… [MODAL-FILE] Segunda mÃºsica analisada:');
                log('   Novo currentJobId:', currentJobId);
                log('   ReferenceJobId:', referenceJobId);
                log('   SÃ£o diferentes?', currentJobId !== referenceJobId ? 'âœ… SIM' : 'âŒ NÃƒO');
                
                // Salvar em mÃºltiplas camadas de proteÃ§Ã£o
                window.__CURRENT_JOB_ID__ = currentJobId;
                sessionStorage.setItem('currentJobId', currentJobId);
                
                protectCurrentJobId(currentJobId);
                log('âœ… [PROTECTION] ProteÃ§Ã£o ativada - currentJobId protegido contra contaminaÃ§Ã£o');
                log('âœ… [PROTECTION] sessionStorage.currentJobId salvo:', sessionStorage.getItem('currentJobId'));
            } else {
                warn('âš ï¸ [PROTECTION] currentJobId nÃ£o encontrado, proteÃ§Ã£o nÃ£o ativada');
            }
            
            // ï¿½ğŸ›¡ï¸ DEEP CLONE OBRIGATÃ“RIO: Evitar contaminaÃ§Ã£o de ponteiros que causa falso self-compare
            log('[DEEP-CLONE-GUARD] ğŸ”’ Clonando userAnalysis para evitar compartilhamento de metadata');
            const userAnalysis = structuredClone(state.previousAnalysis || state.userAnalysis);
            
            log('[DEEP-CLONE-GUARD] ğŸ”’ Clonando referenceAnalysisData para evitar compartilhamento de metadata');
            const referenceAnalysisData = structuredClone(normalizedResult || state.referenceAnalysis);
            
            // ğŸ” VALIDAÃ‡ÃƒO CRÃTICA: Confirmar que os clones sÃ£o independentes
            console.groupCollapsed('[INTEGRITY-CHECK] ğŸ”’ ValidaÃ§Ã£o de Clones Independentes');
            log('âœ… userAnalysis !== referenceAnalysisData?', userAnalysis !== referenceAnalysisData);
            log('âœ… userAnalysis.metadata !== referenceAnalysisData.metadata?', userAnalysis?.metadata !== referenceAnalysisData?.metadata);
            log('ğŸ“ userFileName:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            log('ğŸ“ refFileName:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            log('ğŸ†” userJobId:', userAnalysis?.jobId || userAnalysis?.id);
            log('ğŸ†” refJobId:', referenceAnalysisData?.jobId || referenceAnalysisData?.id);
            log('âš ï¸ Nomes iguais?', (userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName));
            log('âš ï¸ JobIds iguais?', (userAnalysis?.jobId || userAnalysis?.id) === (referenceAnalysisData?.jobId || referenceAnalysisData?.id));
            
            if ((userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName)) {
                error('ğŸš¨ CONTAMINAÃ‡ÃƒO DETECTADA: userFileName === refFileName!');
                error('ğŸš¨ Isso indica que os clones NÃƒO sÃ£o independentes ou que a fonte estÃ¡ contaminada!');
            } else {
                log('âœ… INTEGRIDADE CONFIRMADA: Arquivos sÃ£o diferentes');
            }
            console.groupEnd();
            
            log('[REFERENCE-COMPARE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('[REFERENCE-COMPARE] 1Âª FAIXA (SUA MÃšSICA):');
            log('[REFERENCE-COMPARE]   Nome:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            log('[REFERENCE-COMPARE]   technicalData:', !!userAnalysis?.technicalData);
            log('[REFERENCE-COMPARE]   spectral_balance:', userAnalysis?.technicalData?.spectral_balance ? 'SIM' : 'NÃƒO');
            log('[REFERENCE-COMPARE]   bandas:', userAnalysis?.technicalData?.spectral_balance ? Object.keys(userAnalysis.technicalData.spectral_balance) : 'NENHUMA');
            log('[REFERENCE-COMPARE]   LUFS:', userAnalysis?.technicalData?.lufsIntegrated);
            log('[REFERENCE-COMPARE] 2Âª FAIXA (REFERÃŠNCIA):');
            log('[REFERENCE-COMPARE]   Nome:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            log('[REFERENCE-COMPARE]   technicalData:', !!referenceAnalysisData?.technicalData);
            log('[REFERENCE-COMPARE]   spectral_balance:', referenceAnalysisData?.technicalData?.spectral_balance ? 'SIM' : 'NÃƒO');
            log('[REFERENCE-COMPARE]   bandas:', referenceAnalysisData?.technicalData?.spectral_balance ? Object.keys(referenceAnalysisData.technicalData.spectral_balance) : 'NENHUMA');
            log('[REFERENCE-COMPARE]   LUFS:', referenceAnalysisData?.technicalData?.lufsIntegrated);
            log('[REFERENCE-COMPARE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Marcar no normalizedResult que Ã© modo referÃªncia com dados corretos
            normalizedResult._isReferenceMode = true;
            // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CIRCULAR: usar clone seguro para evitar loops
            normalizedResult._userAnalysis = deepCloneSafe(userAnalysis);
            normalizedResult._referenceAnalysis = deepCloneSafe(referenceAnalysisData);
            
            // ==== CHECKPOINT AUDITORIA REF-CONTAMINAÃ‡ÃƒO ====
            console.group("[AUDITORIA REF-CONTAMINAÃ‡ÃƒO]");
            log("ğŸŒ window.referenceAnalysisData:", window.referenceAnalysisData?.metadata?.fileName || window.referenceAnalysisData?.fileName);
            log("ğŸ§Š __FIRST_ANALYSIS_FROZEN__:", window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.fileName);
            log("ğŸ“¦ analysis.metadata.fileName:", normalizedResult?.metadata?.fileName);
            console.groupEnd();
            
            // ========================================
            // ğŸ§  OBTER PAR DE ANÃLISES DO STORE ISOLADO
            // ========================================
            log('[STORE-FLOW] Obtendo par de anÃ¡lises do store isolado');
            const comparisonPair = getComparisonPair();
            
            if (comparisonPair) {
                log('âœ… [STORE-FLOW] Par obtido com sucesso');
                log('   - ref.jobId:', comparisonPair.ref?.jobId);
                log('   - curr.jobId:', comparisonPair.curr?.jobId);
                log('   - ref.fileName:', comparisonPair.ref?.fileName || comparisonPair.ref?.metadata?.fileName);
                log('   - curr.fileName:', comparisonPair.curr?.fileName || comparisonPair.curr?.metadata?.fileName);
                
                // âœ… USAR DADOS DO STORE COMO FONTE DE VERDADE
                normalizedResult._comparisonPair = comparisonPair;
                normalizedResult._useStoreData = true;
                
                log('ğŸ¯ [STORE-FLOW] Dados do store anexados ao normalizedResult');
            } else {
                warn('âš ï¸ [STORE-FLOW] Store nÃ£o pronto, usando dados legados');
            }
            
            log("[SAFE-MODAL] âœ… Fluxo reference intacto, iniciando renderizaÃ§Ã£o final.");
            
            // ========================================
            // ğŸ¤– AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL
            // ========================================
            log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            log('[AI-SYNC] ğŸ” Verificando status do enriquecimento IA...');
            log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // Verificar se aiSuggestions jÃ¡ estÃ¡ presente
            const hasAISuggestions = Array.isArray(normalizedResult.aiSuggestions) && 
                                     normalizedResult.aiSuggestions.length > 0 &&
                                     normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
            
            log('[AI-SYNC] ğŸ“Š Estado atual:', {
                hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
                aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
                aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
                jobId: normalizedResult.jobId
            });
            
            if (!hasAISuggestions) {
                log('[AI-SYNC] â³ aiSuggestions nÃ£o estÃ¡ pronto, aguardando enriquecimento...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    error('[AI-SYNC] âŒ jobId invÃ¡lido, nÃ£o Ã© possÃ­vel aguardar enriquecimento:', normalizedResult.jobId);
                    warn('[AI-SYNC] âš ï¸ Pulando enriquecimento IA - usando dados jÃ¡ disponÃ­veis');
                } else {
                    // Mostrar spinner visual
                    showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');
                    
                    try {
                        // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                    
                        if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                            // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                            normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        
                        log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        log('[AI-SYNC] âœ… Enriquecimento IA mesclado com sucesso!');
                        log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        log('[AI-SYNC] ğŸ“Š Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                        log('[AI-SYNC] ğŸ¤– Marcadas como aiEnhanced:', 
                            normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                        
                        // Atualizar cache com dados enriquecidos
                        AnalysisCache.put(normalizedResult);
                        
                    } else {
                        warn('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        warn('[AI-SYNC] âš ï¸ Enriquecimento IA nÃ£o completou a tempo');
                        warn('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                        warn('[AI-SYNC] â„¹ï¸ Modal serÃ¡ exibido com sugestÃµes base');
                        warn('[AI-SYNC] â„¹ï¸ IA pode estar desabilitada ou sobrecarregada');
                        }
                        
                    } catch (syncError) {
                        error('[AI-SYNC] âŒ Erro ao aguardar enriquecimento IA:', syncError);
                        warn('[AI-SYNC] â„¹ï¸ Continuando com sugestÃµes base...');
                    } finally {
                        // Remover spinner
                        hideAILoadingSpinner();
                    }
                } // PATCH JOB-ID: Fim do bloco de validaÃ§Ã£o
                
            } else {
                log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                log('[AI-SYNC] âœ… aiSuggestions jÃ¡ presente no resultado!');
                log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                log('[AI-SYNC] â„¹ï¸ NÃ£o Ã© necessÃ¡rio aguardar, exibindo imediatamente');
            }
            
            log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            log('[AI-SYNC] ğŸ¬ Iniciando renderizaÃ§Ã£o do modal...');
            log('[AI-SYNC] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // ========================================
            // âœ… CORREÃ‡ÃƒO: Aguardar enriquecimento IA antes de abrir modal
            // ========================================
            if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
                log('[AI-SYNC] â³ Enriquecimento IA ausente â€” aguardando resposta...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    error('[AI-SYNC] âŒ jobId invÃ¡lido, nÃ£o Ã© possÃ­vel aguardar enriquecimento:', normalizedResult.jobId);
                    warn('[AI-SYNC] âš ï¸ Pulando enriquecimento IA - abrindo modal com dados disponÃ­veis');
                } else {
                    showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');

                    try {
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                    if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                        normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        log(`[AI-SYNC] âœ… SugestÃµes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                    } else {
                        warn('[AI-SYNC] âš ï¸ Timeout ou IA nÃ£o retornou sugestÃµes vÃ¡lidas. Fallback para sugestÃµes base.');
                    }
                } catch (error) {
                    error('[AI-SYNC] âŒ Erro ao aguardar sugestÃµes enriquecidas:', error);
                } finally {
                    hideAILoadingSpinner();
                }
                } // PATCH JOB-ID: Fim do bloco de validaÃ§Ã£o
            }

            // âœ… Agora sim, exibe o modal com ou sem IA (fallback incluso)
            await displayModalResults(normalizedResult);
            log('[FIX-REFERENCE] Modal aberto apÃ³s segunda anÃ¡lise');
            
            // ğŸ” VALIDAÃ‡ÃƒO FINAL: Confirmar que __FIRST_ANALYSIS_FROZEN__ permanece intacto
            console.groupCollapsed('[POST-RENDER-VALIDATION] ğŸ”’ VerificaÃ§Ã£o Final de Integridade');
            log('ğŸ§Š __FIRST_ANALYSIS_FROZEN__ APÃ“S segunda anÃ¡lise:');
            log('   fileName:', window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
            log('   jobId:', window.__FIRST_ANALYSIS_FROZEN__?.jobId);
            log('   Ã‰ o mesmo que normalizedResult?', window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId);
            
            if (window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId) {
                error('ğŸš¨ FALHA CRÃTICA: __FIRST_ANALYSIS_FROZEN__ foi sobrescrito pela segunda anÃ¡lise!');
            } else {
                log('âœ… INTEGRIDADE MANTIDA: __FIRST_ANALYSIS_FROZEN__ permanece intacto');
            }
            console.groupEnd();
            
            // ========================================
            // âœ… CORREÃ‡ÃƒO 1: EARLY RETURN - Impedir limpeza no modo reference
            // ========================================
            if (currentAnalysisMode === 'reference' || jobMode === 'reference') {
                log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('âœ… [CLEANUP] MODO REFERENCE ATIVO - Limpeza bloqueada por early return');
                log('âœ… [CLEANUP] ReferÃªncia PRESERVADA intacta:');
                log('âœ… [CLEANUP]   - currentAnalysisMode:', currentAnalysisMode);
                log('âœ… [CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
                log('âœ… [CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                log('âœ… [CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
                log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Marcar que hÃ¡ uma comparaÃ§Ã£o ativa
                window.__referenceComparisonActive = true;
                
                // EARLY RETURN: NÃ£o executa nenhuma limpeza
                // Continua para o prÃ³ximo bloco de cÃ³digo sem deletar nada
            } else {
                // Modo normal (genre): limpar normalmente
                delete window.__REFERENCE_JOB_ID__;
                delete window.__FIRST_ANALYSIS_RESULT__;
                localStorage.removeItem('referenceJobId');
                
                log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('âœ… [CLEANUP] ReferÃªncia removida (modo genre)');
                log('âœ… [CLEANUP] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            }
            
            // ğŸ”’ MANTÃ‰M: window.referenceAnalysisData e referenceComparisonMetrics para renderizaÃ§Ã£o
        } else {
            // Modo genre: anÃ¡lise por gÃªnero tradicional
            __dbg('ğŸ¯ Exibindo resultado por gÃªnero');
            await handleGenreAnalysisWithResult(analysisResult, file.name);
        }

    } catch (error) {
        error('ğŸ”´ğŸ”´ğŸ”´ [ERRO-CRÃTICO-CAPTURADO] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('ğŸ”´ [ERRO-CRÃTICO] Erro capturado no handleModalFileSelection!');
        error('ğŸ”´ [ERRO-CRÃTICO] Error message:', error.message);
        error('ğŸ”´ [ERRO-CRÃTICO] Error stack:', error.stack);
        error('ğŸ”´ [ERRO-CRÃTICO] currentAnalysisMode ANTES:', currentAnalysisMode);
        error('ğŸ”´ğŸ”´ğŸ”´ [ERRO-CRÃTICO-CAPTURADO] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('âŒ Erro na anÃ¡lise do modal:', error);
        
        // ğŸ”“ FIX BUG 3: Em modo anÃ´nimo, NUNCA resetar genre/mode apÃ³s erro
        // Apenas permitir retry mantendo o estado atual
        const isAnonymousMode = window.SoundyAnonymous?.isAnonymousMode === true;
        if (isAnonymousMode) {
            log('ğŸ”“ [ANONYMOUS] Erro em modo anÃ´nimo - mantendo estado para retry');
            log('   ğŸµ Genre preservado:', window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE);
            log('   ğŸ¯ Mode preservado:', currentAnalysisMode);
            
            // Mostrar erro especÃ­fico mas NÃƒO resetar estado
            showModalError(error.message || 'Erro na anÃ¡lise. Tente novamente.');
            return; // EARLY RETURN - NÃƒO executa reset
        }
        
        // âœ… STEP 4/6: Bloquear fallback para genre em caso de self-compare ou circular structure
        const msg = String(error?.message || '');
        if (msg.includes('Self-compare') || msg.includes('circular structure')) {
            warn('[REF-FLOW] Erro de self-compare/circular structure â€” ignorando fallback pra genre.');
            showModalError('Erro de comparaÃ§Ã£o detectado. Aguardando nova anÃ¡lise...');
            return; // Aborta sem resetar modo
        }
        
        // ========================================
        // ğŸ›¡ï¸ [INVARIANTE #4] PROTEÃ‡ÃƒO: Fallback para gÃªnero SOMENTE se nÃ£o estiver em reference vÃ¡lido
        // ========================================
        if (currentAnalysisMode === 'reference') {
            console.group('[FALLBACK-GUARD] ğŸ›¡ï¸ Verificando seguranÃ§a do fallback');
            log('âš ï¸ Erro capturado durante reference mode');
            log('ğŸ“Š Verificando se Ã© seguro fazer fallback...');
            
            const smState = window.AnalysisStateMachine?.getState();
            const hasFirstAnalysis = window.FirstAnalysisStore?.has() || false;
            const hasContext = hasActiveReferenceContext();
            const smMode = smState?.mode;
            const userExplicitlySelected = smState?.userExplicitlySelected;
            
            log('[FALLBACK-GUARD] State Machine:', {
                mode: smMode,
                userExplicitlySelected,
                referenceFirstJobId: smState?.referenceFirstJobId,
                awaitingSecondTrack: smState?.awaitingSecondTrack
            });
            log('[FALLBACK-GUARD] FirstAnalysisStore.has():', hasFirstAnalysis);
            log('[FALLBACK-GUARD] hasActiveReferenceContext():', hasContext);
            log('[FALLBACK-GUARD] userExplicitlySelectedReferenceMode:', window.userExplicitlySelectedReferenceMode);
            console.groupEnd();
            
            // ğŸ”’ [INVARIANTE #4] NUNCA fazer fallback se:
            // 1. UsuÃ¡rio selecionou explicitamente reference OU
            // 2. JÃ¡ tem primeira anÃ¡lise salva OU
            // 3. Existe contexto ativo de referÃªncia
            const shouldBlockFallback = userExplicitlySelected || hasFirstAnalysis || hasContext;
            
            if (shouldBlockFallback) {
                log('%c[FALLBACK-GUARD] BLOQUEADO - mantendo reference mode', 'color:green;font-weight:bold;');
                log('[FALLBACK-GUARD] RazÃ£o:', 
                    userExplicitlySelected ? 'UsuÃ¡rio escolheu reference explicitamente' : 
                    hasFirstAnalysis ? 'JÃ¡ tem primeira anÃ¡lise salva' :
                    'Contexto ativo de referÃªncia detectado'
                );
                
                showModalError(
                    hasFirstAnalysis 
                        ? 'Erro temporÃ¡rio na segunda faixa. Tente fazer upload novamente.' 
                        : 'Erro na primeira faixa. Por favor, tente novamente.'
                );
                // âœ… NÃƒO resetar modo - apenas mostrar erro e permitir retry
                return;
            } else {
                warn('%c[FALLBACK-GUARD] Permitindo fallback - sem contexto ativo', 'color:orange;font-weight:bold;');
                
                // Perguntar ao usuÃ¡rio explicitamente
                const userWantsFallback = confirm(
                    'A anÃ¡lise de referÃªncia encontrou um erro.\n\n' +
                    'Deseja tentar novamente (OK) ou usar anÃ¡lise por gÃªnero (Cancelar)?'
                );
                
                if (!userWantsFallback) {
                    // UsuÃ¡rio escolheu fallback para gÃªnero
                    warn('[FALLBACK-GUARD] UsuÃ¡rio optou por fallback para gÃªnero');
                    currentAnalysisMode = 'genre';
                    persistReferenceFlag(false);
                    
                    // Atualizar state machine tambÃ©m
                    if (window.AnalysisStateMachine) {
                        window.AnalysisStateMachine.setMode('genre', { userExplicitlySelected: true });
                    }
                    
                    configureModalForMode('genre');
                } else {
                    // UsuÃ¡rio quer tentar reference novamente
                    log('[REF_DEBUG] UsuÃ¡rio optou por tentar reference novamente');
                    showModalError('Por favor, tente fazer upload da primeira faixa novamente.');
                }
            }
        } else {
            // Determinar tipo de erro para mensagem mais especÃ­fica
            let errorMessage = error.message;
            if (error.message.includes('Falha ao gerar URL de upload')) {
                errorMessage = 'Falha ao gerar URL de upload. Verifique sua conexÃ£o e tente novamente.';
            } else if (error.message.includes('Falha ao enviar arquivo para anÃ¡lise')) {
                errorMessage = 'Falha ao enviar arquivo para anÃ¡lise. Verifique sua conexÃ£o e tente novamente.';
            }
            
            showModalError(`Erro ao processar arquivo: ${errorMessage}`);
        }
    } finally {
        // ğŸµ WAV CLEANUP: Limpar otimizaÃ§Ãµes WAV em caso de erro
        try {
            if (window.wavMobileOptimizer) {
                window.wavMobileOptimizer.cleanupWAVOptimizations();
            }
        } catch (cleanupError) {
            warn('WAV cleanup error in finally (non-critical):', cleanupError);
        }
        
        // ğŸ”§ CORREÃ‡ÃƒO: Sempre limpar flag de anÃ¡lise em progresso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('âœ… Flag de anÃ¡lise em progresso removida');
    }
}

// ï¿½ NOVAS FUNÃ‡Ã•ES: AnÃ¡lise baseada em fileKey (pÃ³s-upload remoto)

/**
 * Processar anÃ¡lise por referÃªncia usando fileKey
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
// ğŸŒ NOVAS FUNÃ‡Ã•ES: AnÃ¡lise baseada em resultado remoto

/**
 * Processar anÃ¡lise por referÃªncia usando resultado remoto
 * @param {Object} analysisResult - Resultado da anÃ¡lise remota
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
async function handleReferenceAnalysisWithResult(analysisResult, fileKey, fileName) {
    __dbg('ğŸ¯ Processando anÃ¡lise por referÃªncia com resultado remoto:', { fileKey, fileName });
    
    window.logReferenceEvent('reference_analysis_with_result_started', { 
        fileKey,
        fileName 
    });
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de anÃ¡lise invÃ¡lido recebido do servidor');
        }
        
        updateModalProgress(90, 'ğŸ¯ Aplicando resultado da anÃ¡lise...');
        
        // Determinar se Ã© arquivo original ou de referÃªncia
        const isReference = currentAnalysisMode === 'reference' && uploadedFiles.original;
        const fileType = isReference ? 'reference' : 'original';
        
        // Armazenar resultado
        uploadedFiles[fileType] = {
            fileKey: fileKey,
            fileName: fileName,
            analysisResult: analysisResult
        };
        
        __dbg(`âœ… Arquivo ${fileType} armazenado:`, uploadedFiles[fileType]);
        
        // Atualizar display na interface
        updateReferenceFileDisplay(fileType, fileName);
        
        // Log do evento
        window.logReferenceEvent('reference_file_processed', {
            fileType,
            fileName,
            hasResult: !!analysisResult
        });
        
        // Verificar se ambos os arquivos estÃ£o prontos para comparaÃ§Ã£o
        if (uploadedFiles.original && uploadedFiles.reference) {
            enableReferenceComparison();
            updateModalProgress(100, 'âœ… Ambos os arquivos analisados! ComparaÃ§Ã£o disponÃ­vel.');
            
        
        }
        
    } catch (error) {
        error('âŒ Erro ao processar anÃ¡lise por referÃªncia:', error);
        window.logReferenceEvent('reference_analysis_error', { 
            error: error.message,
            fileKey,
            fileName 
        });
        throw error;
    }
}

/**
 * Processar anÃ¡lise por gÃªnero usando resultado remoto
 * @param {Object} analysisResult - Resultado da anÃ¡lise remota
 * @param {string} fileName - Nome original do arquivo
 */
async function handleGenreAnalysisWithResult(analysisResult, fileName) {
    __dbg('ğŸµ Processando anÃ¡lise por gÃªnero com resultado remoto:', { fileName });
    
    // ğŸ§© AUDIT_REF_FIX: Verificar se NÃƒO estamos em modo reference antes de limpar
    const state = window.__soundyState || {};
    const currentMode = state?.render?.mode || currentAnalysisMode;
    const isSecondTrack = state?.reference?.isSecondTrack || false;
    
    // ğŸš¨ PROTEÃ‡ÃƒO: NÃƒO limpar estado se estivermos em modo reference
    if (currentMode === 'reference' && isSecondTrack) {
        warn('âš ï¸ [AUDIT_REF_FIX] handleGenreAnalysisWithResult chamado em modo reference!');
        warn('âš ï¸ [AUDIT_REF_FIX] ABORTANDO limpeza para preservar dados A/B');
        log('[MODE LOCKED] reference - limpeza de estado BLOQUEADA');
        
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
        const normalizedResult = analysisResult; // âœ… LEITURA DIRETA
        
        // ğŸ”’ POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        return normalizedResult;
    }
    
    // ğŸš¨ BLINDAGEM: NÃƒO limpar estado em modo genre (preservar gÃªnero)
    if (window.__CURRENT_MODE__ === 'genre') {
        warn('[GENRE-PROTECT] âš ï¸ handleGenreAnalysisWithResult - limpeza BLOQUEADA em modo genre');
        log('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
        const normalizedResult = analysisResult; // âœ… LEITURA DIRETA
        AnalysisCache.put(normalizedResult);
        
        log('[GENRE-BEFORE-DISPLAY] ğŸµ Genre preservado:', {
            preservedGenre: window.__CURRENT_SELECTED_GENRE,
            normalizedGenre: normalizedResult.genre
        });
        
        // âœ… Continuar processamento SEM limpar estado
        updateModalProgress(90, 'ğŸµ Aplicando resultado da anÃ¡lise...');
        
        try {
            if (!analysisResult || typeof analysisResult !== 'object') {
                throw new Error('Resultado de anÃ¡lise invÃ¡lido recebido do servidor');
            }
            
            return normalizedResult;
        } catch (error) {
            error('âŒ Erro ao processar anÃ¡lise de gÃªnero:', error);
            throw error;
        }
    }
    
    // ğŸ§© CORREÃ‡ÃƒO #1: Limpeza completa APENAS em modo Reference (quando nÃ£o hÃ¡ segundo track)
    
    // Limpar completamente estado de referÃªncia
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        state.reference.userAnalysis = null;
        state.reference.referenceAnalysis = null;
    }
    
    // ForÃ§ar modo gÃªnero explicitamente
    if (!state.render) state.render = {};
    state.render.mode = 'genre';
    
    window.__soundyState = state;
    
    // ğŸ”’ HARD-GUARD: Limpar FirstAnalysisStore (Ãºnica fonte de verdade)
    FirstAnalysisStore.clear();
    log('[CLEANUP] handleGenreAnalysisWithResult: FirstAnalysisStore limpo');
    
    // âŒ REMOVER: window.referenceAnalysisData agora Ã© read-only (nÃ£o pode ser setado)
    window.referenceComparisonMetrics = null;
    window.lastReferenceJobId = null;
    
    log('ğŸšï¸ [FIX-GENRE] Estado completamente limpo, modo forÃ§ado para "genre"');
    
    // ğŸ”’ PATCH: PRESERVAR GÃŠNERO APÃ“S LIMPEZA
    preserveGenreState();
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de anÃ¡lise invÃ¡lido recebido do servidor');
        }
        
        updateModalProgress(90, 'ğŸµ Aplicando resultado da anÃ¡lise...');
        
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
        // âŒ REMOVIDO: normalizeBackendAnalysisData() destrÃ³i dados
        const normalizedResult = analysisResult; // âœ… LEITURA DIRETA
        
        // ğŸ”’ POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        // ========================================
        // ğŸ”¥ BARREIRA 3: LIMPEZA NO RECEBIMENTO DE ANÃLISE
        // ========================================
        // Se o backend retornar mode: "genre", garantir limpeza ANTES de processar
        const isGenreModeFromBackend = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreModeFromBackend) {
            log('%c[GENRE-BARRIER] ğŸš§ BARREIRA 3 ATIVADA: AnÃ¡lise de gÃªnero recebida do backend', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
            log('[GENRE-BARRIER] normalizedResult.mode:', normalizedResult.mode);
            log('[GENRE-BARRIER] normalizedResult.isReferenceBase:', normalizedResult.isReferenceBase);
            
            // ğŸ”¥ EXECUTAR LIMPEZA COMPLETA
            // ğŸ¯ PRESERVAR GÃŠNERO durante o reset
            const genreToPreserve = getActiveGenre(normalizedResult, window.PROD_AI_REF_GENRE);
            log('[GENRE-BARRIER] GÃªnero a preservar:', genreToPreserve);
            resetReferenceStateFully(genreToPreserve);
            
            // ğŸ¯ GARANTIR que normalizedResult.genre estÃ¡ definido
            if (genreToPreserve && !normalizedResult.genre) {
                normalizedResult.genre = genreToPreserve;
                log('[GENRE-BARRIER] normalizedResult.genre restaurado:', genreToPreserve);
            }
            
            // ğŸ”’ CONFIGURAR VIEW MODE
            setViewMode("genre");
            
            // ğŸ”’ FORÃ‡AR MODO GÃŠNERO
            window.currentAnalysisMode = 'genre';
            
            log('%c[GENRE-BARRIER] âœ… BARREIRA 3 CONCLUÃDA: Estado limpo antes de processar anÃ¡lise', 'color:#00FF88;font-weight:bold;');
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ¯ MODE ENGINE: ConfiguraÃ§Ã£o baseada em mode + isReferenceBase
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        // PRIMEIRA TRACK DO FLUXO A/B (mode: "genre" + isReferenceBase: true)
        if (normalizedResult.isReferenceBase === true && normalizedResult.mode === 'genre') {
            SOUNDY_MODE_ENGINE.startReferenceBase(normalizedResult);
            log('[MODE-ENGINE] Primeira track salva como referÃªncia base');
        }
        // SEGUNDA TRACK (mode: "reference" do backend)
        else if (normalizedResult.mode === 'reference') {
            SOUNDY_MODE_ENGINE.startReferenceCompare();
            log('[MODE-ENGINE] Segunda track detectada, modo A/B ativado');
        }
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA: Carregar targets de gÃªnero baseado em MODE, nÃ£o em referenceComparison
        const isGenreMode = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreMode) {
            log('[GENRE-TARGETS] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            log('[GENRE-TARGETS] ğŸµ MODO GÃŠNERO PURO DETECTADO');
            log('[GENRE-TARGETS] mode:', normalizedResult.mode);
            log('[GENRE-TARGETS] isReferenceBase:', normalizedResult.isReferenceBase);
            log('[GENRE-TARGETS] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            
            // ğŸ”’ LIMPAR referenceComparison residual de sessÃµes anteriores
            if (normalizedResult.referenceComparison) {
                log('[GENRE-TARGETS] âš ï¸ referenceComparison residual detectado - removendo');
                delete normalizedResult.referenceComparison;
            }
            
            // Carregar targets de gÃªnero de /refs/out/
            // ğŸ¯ CORREÃ‡ÃƒO: Usar getActiveGenre ao invÃ©s de fallback direto para "default"
            const genreId = getActiveGenre(normalizedResult, null);
            
            if (!genreId) {
                warn('[GENRE-TARGETS] âš ï¸ Nenhum gÃªnero detectado - pulando carregamento de targets');
                warn('[GENRE-TARGETS] Fontes verificadas:', {
                    'normalizedResult.genre': normalizedResult.genre,
                    'normalizedResult.genreId': normalizedResult.genreId,
                    'normalizedResult.metadata?.genre': normalizedResult.metadata?.genre,
                    'window.__CURRENT_GENRE': window.__CURRENT_GENRE,
                    'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE
                });
            } else {
                log(`[GENRE-TARGETS] Carregando targets para gÃªnero: ${genreId}`);
            }
            
            // ğŸ¯ VALIDAÃ‡ÃƒO: SÃ³ carregar se genreId for vÃ¡lido (nÃ£o vazio, nÃ£o 'default')
            if (genreId && genreId !== 'default') {
                try {
                    const response = await fetch(`/refs/out/${genreId}.json`);
                    if (response.ok) {
                        const rawJson = await response.json();
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Extrair o objeto interno do JSON
                        // O JSON tem estrutura: { "genreId": { ...dados... } }
                        const rootKey = Object.keys(rawJson)[0];
                        let targets = rawJson[rootKey] || rawJson;
                        
                        log('[GENRE-TARGETS] ğŸ“¦ JSON bruto carregado:', { 
                            rootKey, 
                            hasRootKey: !!rootKey,
                            targetKeys: Object.keys(targets)
                        });
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Enriquecer targets usando enrichReferenceObject
                        targets = enrichReferenceObject(targets, genreId);
                        log('[GENRE-TARGETS] ğŸ”§ Targets enriquecidos via enrichReferenceObject');
                        
                        // ğŸ” DIAGNÃ“STICO: Logs detalhados da estrutura apÃ³s enriquecimento
                        log('[GENRE-TARGETS] ğŸ“Š Estrutura targets (APÃ“S enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasSpectralBands: !!targets?.spectral_bands,
                            spectralBandsCount: targets?.spectral_bands ? Object.keys(targets.spectral_bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasOriginalMetrics: !!targets?.original_metrics,
                            hasLufsTarget: targets?.lufs_target !== undefined,
                            hasTruePeakTarget: targets?.true_peak_target !== undefined,
                            hasDrTarget: targets?.dr_target !== undefined,
                            hasStereoTarget: targets?.stereo_target !== undefined
                        });
                        
                        // ğŸ” DIAGNÃ“STICO: Amostra das bandas
                        if (targets?.bands) {
                            const sampleBand = Object.keys(targets.bands)[0];
                            log('[GENRE-TARGETS] ğŸ“‹ Amostra de banda:', sampleBand, targets.bands[sampleBand]);
                        }
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Criar referenceComparisonMetrics para UI
                        normalizedResult.referenceComparisonMetrics = {
                            bands: targets.bands || targets.spectral_bands,
                            spectralBands: targets.spectral_bands || targets.bands,
                            legacyBands: targets.legacy_compatibility?.bands,
                            originalMetrics: targets.original_metrics || targets.hybrid_processing?.original_metrics,
                            lufs_target: targets.lufs_target,
                            true_peak_target: targets.true_peak_target,
                            dr_target: targets.dr_target,
                            stereo_target: targets.stereo_target,
                            lra_target: targets.lra_target
                        };
                        log('[GENRE-TARGETS] ğŸ“¦ referenceComparisonMetrics criado:', {
                            hasBands: !!normalizedResult.referenceComparisonMetrics.bands,
                            hasOriginalMetrics: !!normalizedResult.referenceComparisonMetrics.originalMetrics
                        });
                        
                        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Atribuir targets a TODAS as variÃ¡veis globais
                        normalizedResult.referenceComparison = targets;
                        
                        // âœ… CORREÃ‡ÃƒO: Inicializar window.PROD_AI_REF_DATA como objeto se for false
                        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
                            window.PROD_AI_REF_DATA = {};
                            log('[GENRE-TARGETS] ğŸ”§ Inicializando window.PROD_AI_REF_DATA como objeto');
                        }
                        
                        // âœ… CORREÃ‡ÃƒO: Atribuir targets ao gÃªnero especÃ­fico
                        window.PROD_AI_REF_DATA[genreId] = targets;
                        log(`[GENRE-TARGETS] ğŸ“¦ window.PROD_AI_REF_DATA['${genreId}'] atribuÃ­do`);
                        
                        // âœ… CORREÃ‡ÃƒO: Atualizar __activeRefData
                        window.__activeRefData = targets;
                        log('[GENRE-TARGETS] ğŸ“¦ window.__activeRefData atualizado');
                        
                        // âœ… CORREÃ‡ÃƒO: Sincronizar gÃªnero ativo
                        window.__CURRENT_GENRE = genreId;
                        log(`[GENRE-TARGETS] ğŸ¯ window.__CURRENT_GENRE = '${genreId}'`);
                        
                        log(`[GENRE-TARGETS] âœ… Targets carregados e enriquecidos para ${genreId}`);
                        log('[GENRE-TARGETS] ğŸ“Š Estrutura targets (APÃ“S enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasLufsTarget: !!targets?.lufs_target,
                            hasTruePeakTarget: !!targets?.true_peak_target,
                            hasDrTarget: !!targets?.dr_target,
                            hasStereoTarget: !!targets?.stereo_target
                        });
                        log('[GENRE-TARGETS] ğŸ“‹ Targets.bands:', targets?.bands);
                    } else {
                        warn(`[GENRE-TARGETS] âš ï¸ Arquivo nÃ£o encontrado: /refs/out/${genreId}.json (${response.status})`);
                        warn(`[GENRE-TARGETS] Continuando sem targets especÃ­ficos do gÃªnero`);
                    }
                } catch (err) {
                    error("[GENRE-TARGETS] âŒ Erro ao carregar targets de gÃªnero:", err);
                    error("[GENRE-TARGETS] Continuando com targets padrÃ£o ou sem targets");
                }
            } else {
                warn('[GENRE-TARGETS] âš ï¸ GenreId invÃ¡lido ou "default" - pulando fetch:', genreId);
            }
        } else {
            log("[GENRE-TARGETS] âš ï¸ NÃ£o Ã© modo gÃªnero puro - pulando carregamento de targets");
            log("[GENRE-TARGETS] mode:", normalizedResult.mode);
            log("[GENRE-TARGETS] isReferenceBase:", normalizedResult.isReferenceBase);
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Gerar sugestÃµes no primeiro load
        if (__activeRefData && !normalizedResult._suggestionsGenerated) {
            log('ğŸ¯ [SUGGESTIONS] Engine chamado no primeiro load');
            try {
                updateReferenceSuggestions(normalizedResult, __activeRefData);
                normalizedResult._suggestionsGenerated = true;
                log(`ğŸ¯ [SUGGESTIONS] ${normalizedResult.suggestions?.length || 0} sugestÃµes geradas no primeiro load`);
            } catch (error) {
                error('âŒ [SUGGESTIONS] Erro ao gerar sugestÃµes no primeiro load:', error);
            }
        } else if (!__activeRefData) {
            log('ğŸ¯ [SUGGESTIONS] Dados de referÃªncia nÃ£o disponÃ­veis para gerar sugestÃµes');
        } else {
            log('ğŸ¯ [SUGGESTIONS] SugestÃµes jÃ¡ foram geradas anteriormente');
        }

        // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Sempre mostrar interface IA apÃ³s sugestÃµes serem processadas
        if (normalizedResult.suggestions && normalizedResult.suggestions.length > 0) {
            setTimeout(() => {
                log(`ğŸš€ [AI-UI-FORCE] Tentando forÃ§ar interface IA aparecer com ${normalizedResult.suggestions.length} sugestÃµes`);
                
                // Verificar mÃºltiplas formas de chamar a interface IA
                if (window.aiUIController) {
                    log(`ğŸš€ [AI-UI-FORCE] Usando aiUIController existente`);
                    window.aiUIController.checkForAISuggestions(normalizedResult, true);
                } else if (window.forceShowAISuggestions) {
                    log(`ğŸš€ [AI-UI-FORCE] Usando forceShowAISuggestions como fallback`);
                    window.forceShowAISuggestions(normalizedResult);
                } else {
                    warn('âš ï¸ [AI-UI-FORCE] Nenhum mÃ©todo de interface IA encontrado, criando interface bÃ¡sica...');
                    
                    // Criar interface bÃ¡sica na hora
                    const aiSection = document.createElement('div');
                    aiSection.id = 'ai-suggestions-section';
                    aiSection.style.cssText = `
                        margin: 20px 0; padding: 20px; border: 2px solid #4CAF50;
                        border-radius: 10px; background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
                        color: white; font-family: Arial, sans-serif;
                    `;
                    aiSection.innerHTML = `
                        <h3 style="color: #4CAF50; margin: 0 0 15px 0;">ğŸ¤– SugestÃµes Inteligentes</h3>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <p style="margin: 0 0 10px 0; color: #A5D6A7;">
                                ğŸ’¡ Interface IA carregada com ${normalizedResult.suggestions.length} sugestÃµes
                            </p>
                            <p style="margin: 0; font-size: 14px; color: #81C784;">
                                Configure uma API Key da OpenAI para sugestÃµes inteligentes personalizadas.
                            </p>
                            <button onclick="if(window.promptForAPIKey) window.promptForAPIKey(); else alert('Configure API Key da OpenAI para ativar IA')" 
                                    style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                âš™ï¸ Configurar IA
                            </button>
                        </div>
                    `;
                    
                    // Inserir na interface
                    const modal = document.getElementById('audioAnalysisModal');
                    const content = modal?.querySelector('.modal-content');
                    if (content) {
                        // Remover seÃ§Ã£o anterior se existir
                        const existing = content.querySelector('#ai-suggestions-section');
                        if (existing) existing.remove();
                        
                        // Adicionar nova seÃ§Ã£o
                        content.appendChild(aiSection);
                        log('âœ… [AI-UI-FORCE] Interface IA bÃ¡sica criada e inserida');
                    } else {
                        error('âŒ [AI-UI-FORCE] Modal nÃ£o encontrado para inserir interface');
                    }
                }
            }, 500); // Delay para garantir que o DOM esteja renderizado
        }
        
        // Definir como anÃ¡lise atual do modal
        currentModalAnalysis = normalizedResult;
        
        // ğŸš« CRITICAL: Expor globalmente para premium-blocker e outros sistemas
        window.currentModalAnalysis = normalizedResult;
        window.__CURRENT_ANALYSIS__ = normalizedResult;
        
        // ğŸ¯ ALIAS GLOBAL PARA RELATÃ“RIOS (Fonte de Verdade Ãšnica)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = normalizedResult;
            
            // Criar namespace global unificado
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = normalizedResult;
            
            log('âœ… [PDF-READY] AnÃ¡lise armazenada globalmente:', {
                hasGlobalAlias: !!window.__soundyAI.analysis,
                hasCurrentModal: !!window.currentModalAnalysis,
                hasCurrent: !!window.__CURRENT_ANALYSIS__,
                fileName: normalizedResult.metadata?.fileName || normalizedResult.fileName,
                plan: normalizedResult.plan,
                analysisMode: normalizedResult.analysisMode,
                score: normalizedResult.score,
                hasMetrics: !!(normalizedResult.loudness || normalizedResult.technicalData)
            });
        }
        
        // ğŸ”“ MODO ANÃ”NIMO: Registrar anÃ¡lise concluÃ­da
        if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
            window.SoundyAnonymous.registerAnalysis();
            log('ğŸ”“ [ANALYZER] AnÃ¡lise registrada no modo anÃ´nimo');
        }
        
        // âŒ REMOVIDO: Salvamento duplicado aqui
        // âœ… NOVO: Salvamento unificado acontece dentro de displayModalResults()
        // para garantir um Ãºnico ponto de salvamento
        
        updateModalProgress(100, `âœ… AnÃ¡lise de ${fileName} concluÃ­da!`);
        
        // ========================================
        // ğŸ¤– AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL (MODO GENRE)
        // ========================================
        log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        log('[AI-SYNC][GENRE] ğŸ” Verificando status do enriquecimento IA...');
        log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        // Verificar se aiSuggestions jÃ¡ estÃ¡ presente
        const hasAISuggestionsGenre = Array.isArray(normalizedResult.aiSuggestions) && 
                                      normalizedResult.aiSuggestions.length > 0 &&
                                      normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
        
        log('[AI-SYNC][GENRE] ğŸ“Š Estado atual:', {
            hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
            aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
            aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
            jobId: normalizedResult.jobId
        });
        
        if (!hasAISuggestionsGenre) {
            log('[AI-SYNC][GENRE] â³ aiSuggestions nÃ£o estÃ¡ pronto, aguardando enriquecimento...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                error('[AI-SYNC][GENRE] âŒ jobId invÃ¡lido, nÃ£o Ã© possÃ­vel aguardar enriquecimento:', normalizedResult.jobId);
                warn('[AI-SYNC][GENRE] âš ï¸ Pulando enriquecimento IA - usando dados jÃ¡ disponÃ­veis');
            } else {
                // Mostrar spinner visual
                showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');
            
            try {
                // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                const enrichedDataGenre = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                
                if (enrichedDataGenre && enrichedDataGenre.aiSuggestions && enrichedDataGenre.aiSuggestions.length > 0) {
                    // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                    normalizedResult.aiSuggestions = enrichedDataGenre.aiSuggestions;
                    
                    log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    log('[AI-SYNC][GENRE] âœ… Enriquecimento IA mesclado com sucesso!');
                    log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    log('[AI-SYNC][GENRE] ğŸ“Š Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                    log('[AI-SYNC][GENRE] ğŸ¤– Marcadas como aiEnhanced:', 
                        normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                    
                    // Atualizar cache com dados enriquecidos
                    AnalysisCache.put(normalizedResult);
                    
                } else {
                    warn('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    warn('[AI-SYNC][GENRE] âš ï¸ Enriquecimento IA nÃ£o completou a tempo');
                    warn('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    warn('[AI-SYNC][GENRE] â„¹ï¸ Modal serÃ¡ exibido com sugestÃµes base');
                    warn('[AI-SYNC][GENRE] â„¹ï¸ IA pode estar desabilitada ou sobrecarregada');
                }
                
            } catch (syncErrorGenre) {
                error('[AI-SYNC][GENRE] âŒ Erro ao aguardar enriquecimento IA:', syncErrorGenre);
                warn('[AI-SYNC][GENRE] â„¹ï¸ Continuando com sugestÃµes base...');
            } finally {
                // Remover spinner
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de validaÃ§Ã£o
            
        } else {
            log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            log('[AI-SYNC][GENRE] âœ… aiSuggestions jÃ¡ presente no resultado!');
            log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            log('[AI-SYNC][GENRE] â„¹ï¸ NÃ£o Ã© necessÃ¡rio aguardar, exibindo imediatamente');
        }
        
        log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        log('[AI-SYNC][GENRE] ğŸ¬ Iniciando renderizaÃ§Ã£o do modal...');
        log('[AI-SYNC][GENRE] â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        // ========================================
        // âœ… CORREÃ‡ÃƒO: Aguardar enriquecimento IA antes de abrir modal (MODO GENRE)
        // ========================================
        if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
            log('[AI-SYNC][GENRE] â³ Enriquecimento IA ausente â€” aguardando resposta...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                error('[AI-SYNC][GENRE] âŒ jobId invÃ¡lido, nÃ£o Ã© possÃ­vel aguardar enriquecimento:', normalizedResult.jobId);
                warn('[AI-SYNC][GENRE] âš ï¸ Pulando enriquecimento IA - abrindo modal com dados disponÃ­veis');
            } else {
                showAILoadingSpinner('ğŸ¤– Conectando Ã  IA para anÃ¡lise avanÃ§ada...');

                try {
                    const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                    normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                    log(`[AI-SYNC][GENRE] âœ… SugestÃµes enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                } else {
                    warn('[AI-SYNC][GENRE] âš ï¸ Timeout ou IA nÃ£o retornou sugestÃµes vÃ¡lidas. Fallback para sugestÃµes base.');
                }
            } catch (error) {
                error('[AI-SYNC][GENRE] âŒ Erro ao aguardar sugestÃµes enriquecidas:', error);
            } finally {
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de validaÃ§Ã£o
        }
        
        // âœ… Agora sim, exibe o modal com ou sem IA (fallback incluso)
        // ğŸ›¡ï¸ VERIFICAÃ‡ÃƒO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            await displayModalResults(normalizedResult);
            log("[DISPLAY] Modal aberto com sucesso (modo genre)");
        } else {
            error('âŒ [MODAL_MONITOR] FunÃ§Ã£o displayModalResults nÃ£o encontrada');
        }
        
    } catch (error) {
        error('âŒ Erro ao processar anÃ¡lise por gÃªnero:', error);
        throw error;
    }
}

/**
 * Atualizar display de arquivo de referÃªncia na interface
 * @param {string} fileType - Tipo do arquivo ('original' ou 'reference')
 * @param {string} fileName - Nome do arquivo
 */
function updateReferenceFileDisplay(fileType, fileName) {
    const displayElement = document.getElementById(`${fileType}FileDisplay`);
    if (displayElement) {
        displayElement.textContent = fileName;
        displayElement.style.display = 'block';
    }
    
    // Atualizar tambÃ©m elementos relacionados
    const labelElement = document.querySelector(`label[for="${fileType}FileInput"]`);
    if (labelElement) {
        labelElement.style.opacity = '0.7';
    }
}

/**
 * Habilitar botÃ£o de comparaÃ§Ã£o de referÃªncia
 */
function enableReferenceComparison() {
    const compareButton = document.getElementById('compareButton');
    if (compareButton) {
        compareButton.disabled = false;
        compareButton.style.opacity = '1';
        compareButton.style.cursor = 'pointer';
    }
    
    // Atualizar indicador visual
    const indicator = document.querySelector('.reference-ready-indicator');
    if (indicator) {
        indicator.style.display = 'block';
    }
}


/**
 * Mostrar mensagem do prÃ³ximo passo
 * @param {string} message - Mensagem a ser exibida
 */
function showNextStepMessage(message) {
    log(`â¡ï¸ ${message}`);
    
    // Implementar notificaÃ§Ã£o visual se necessÃ¡rio
    const notification = document.createElement('div');
    notification.className = 'next-step-notification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    // Remover apÃ³s 5 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 5000);
}

// ï¿½ğŸ¯ NOVO: ValidaÃ§Ã£o comum de arquivo
function validateAudioFile(file) {
    const MAX_UPLOAD_MB = 150;
    const MAX_UPLOAD_SIZE = MAX_UPLOAD_MB * 1024 * 1024;
    
    // Formatos aceitos: WAV, FLAC, MP3 (simplificado)
    const allowedTypes = ['audio/wav', 'audio/flac', 'audio/mpeg', 'audio/mp3'];
    const allowedExtensions = ['.wav', '.flac', '.mp3'];
    
    // Validar tipo de arquivo
    const isValidType = allowedTypes.includes(file.type.toLowerCase()) || 
                       allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
    
    if (!isValidType) {
        showModalError(`Formato nÃ£o suportado. Apenas WAV, FLAC e MP3 sÃ£o aceitos.
                      ğŸ’¡ Prefira WAV ou FLAC para maior precisÃ£o na anÃ¡lise.`);
        return false;
    }
    
    // Validar tamanho (novo limite: 60MB)
    if (file.size > MAX_UPLOAD_SIZE) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        showModalError(`Arquivo muito grande: ${sizeInMB}MB. 
                      Limite mÃ¡ximo: ${MAX_UPLOAD_MB}MB.`);
        return false;
    }
    
    // ğŸµ WAV MOBILE WARNING: Avisar sobre demora em arquivos WAV grandes no mobile
    const isWAV = file.name.toLowerCase().endsWith('.wav') || file.type.includes('wav');
    const isMobile = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
    const isLargeWAV = isWAV && file.size > 20 * 1024 * 1024; // >20MB
    
    if (isLargeWAV && isMobile) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        const estimatedTime = Math.ceil(file.size / (2 * 1024 * 1024)); // ~2MB/s no mobile
        
        warn(`â±ï¸ WAV grande no mobile: ${sizeInMB}MB - tempo estimado: ${estimatedTime}s`);
        
        // Mostrar aviso nÃ£o-bloqueante
        setTimeout(() => {
            if (document.getElementById('audioProgressText')) {
                document.getElementById('audioProgressText').innerHTML = 
                    `â±ï¸ Arquivo WAV grande (${sizeInMB}MB)<br>Tempo estimado: ${estimatedTime}-${estimatedTime*2}s<br>Aguarde...`;
            }
        }, 1000);
    }
    
    // Mostrar recomendaÃ§Ã£o para MP3
    if (file.type === 'audio/mpeg' || file.type === 'audio/mp3' || file.name.toLowerCase().endsWith('.mp3')) {
        log('ğŸ’¡ MP3 detectado - RecomendaÃ§Ã£o: Use WAV ou FLAC para maior precisÃ£o');
    }
    
    return true;
}

// ğŸ¯ NOVO: Processar arquivo no modo referÃªncia
async function handleReferenceFileSelection(file) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” FAIL-SAFE: Bloqueio de entitlement no upload de referÃªncia
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        log(`ğŸ” [ENTITLEMENT FAIL-SAFE] Upload de referÃªncia BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ğŸ”“ [ANONYMOUS-MODE] Interceptar anÃ¡lise em modo anÃ´nimo
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            log('ğŸš« [ANONYMOUS] AnÃ¡lise referÃªncia bloqueada - limite atingido');
            return;
        }
    }
    
    window.logReferenceEvent('reference_file_selected', { 
        step: referenceStepState.currentStep,
        fileName: file.name,
        fileSize: file.size 
    });
    
    if (referenceStepState.currentStep === 'userAudio') {
        // Primeiro arquivo: mÃºsica do usuÃ¡rio
        referenceStepState.userAudioFile = file;
        
        // ğŸ› DIAGNÃ“STICO: Verificar se estÃ¡ carregando dados de gÃªnero no modo referÃªncia
        log('ğŸ” [DIAGNÃ“STICO] Analisando USER audio em modo referÃªncia');
        log('ğŸ” [DIAGNÃ“STICO] Current mode:', window.currentAnalysisMode);
        log('ğŸ” [DIAGNÃ“STICO] Genre ativo antes da anÃ¡lise:', window.PROD_AI_REF_GENRE);
        log('ğŸ” [DIAGNÃ“STICO] Active ref data:', !!__activeRefData);
        
        // Analisar arquivo do usuÃ¡rio
        showModalLoading();
        updateModalProgress(10, 'ğŸµ Analisando sua mÃºsica...');
        
        // ğŸ¯ CORREÃ‡ÃƒO TOTAL: Analisar arquivo do usuÃ¡rio SEM aplicar targets
        const userAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparaÃ§Ãµes
          debugModeReference: true,
          // Garantir mesmas configuraÃ§Ãµes para ambos os arquivos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId
        const userOptionsWithRunId = prepareAnalysisOptions(userAnalysisOptions, 'user_ref');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, userOptionsWithRunId);
        
        // ğŸ› VALIDAÃ‡ÃƒO: Verificar que nÃ£o hÃ¡ comparaÃ§Ã£o com gÃªnero
        if (analysis.comparison || analysis.mixScore) {
          warn('âš ï¸ [AVISO] AnÃ¡lise do usuÃ¡rio contaminada com comparaÃ§Ã£o/score');
        }
        
        log('ğŸ” [DIAGNÃ“STICO] User analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        referenceStepState.userAnalysis = analysis;
        
        // AvanÃ§ar para prÃ³ximo step
        updateReferenceStep('referenceAudio');
        updateUploadAreaForReferenceStep();
        
        window.logReferenceEvent('user_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
        
    } else if (referenceStepState.currentStep === 'referenceAudio') {
        // Segundo arquivo: mÃºsica de referÃªncia
        referenceStepState.referenceAudioFile = file;
        
        // ğŸ› DIAGNÃ“STICO: Verificar anÃ¡lise do arquivo de referÃªncia
        log('ğŸ” [DIAGNÃ“STICO] Analisando REFERENCE audio em modo referÃªncia');
        log('ğŸ” [DIAGNÃ“STICO] Current mode:', window.currentAnalysisMode);
        log('ğŸ” [DIAGNÃ“STICO] Genre ativo antes da anÃ¡lise:', window.PROD_AI_REF_GENRE);
        
        // Analisar arquivo de referÃªncia (extraÃ§Ã£o de mÃ©tricas com MESMAS configuraÃ§Ãµes)
        showModalLoading();
        updateModalProgress(50, 'ğŸ¯ Analisando mÃºsica de referÃªncia...');
        
        // ğŸ¯ CORREÃ‡ÃƒO TOTAL: Usar EXATAMENTE as mesmas configuraÃ§Ãµes do usuÃ¡rio
        const refAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparaÃ§Ãµes
          debugModeReference: true,
          // ğŸ¯ GARANTIR parÃ¢metros idÃªnticos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId
        const refOptionsWithRunId = prepareAnalysisOptions(refAnalysisOptions, 'ref_audio');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, refOptionsWithRunId);
        
        // ğŸ› VALIDAÃ‡ÃƒO: Verificar que nÃ£o hÃ¡ comparaÃ§Ã£o com gÃªnero
        if (analysis.comparison || analysis.mixScore) {
          warn('âš ï¸ [AVISO] AnÃ¡lise da referÃªncia contaminada com comparaÃ§Ã£o/score');
        }
        
        log('ğŸ” [DIAGNÃ“STICO] Reference analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        // ğŸ¯ VALIDAÃ‡ÃƒO: Verificar se conseguimos extrair mÃ©tricas vÃ¡lidas
        const referenceMetrics = {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp
        };
        
        // ğŸš¨ ERRO CLARO: Falhar se nÃ£o conseguir extrair mÃ©tricas
        if (!Number.isFinite(referenceMetrics.lufs)) {
          throw new Error('REFERENCE_METRICS_FAILED: NÃ£o foi possÃ­vel extrair mÃ©tricas LUFS da mÃºsica de referÃªncia. Verifique se o arquivo Ã© vÃ¡lido.');
        }
        
        if (!Number.isFinite(referenceMetrics.stereoCorrelation)) {
          throw new Error('REFERENCE_METRICS_FAILED: NÃ£o foi possÃ­vel extrair correlaÃ§Ã£o estÃ©reo da mÃºsica de referÃªncia.');
        }
        
        log('âœ… [SUCESSO] MÃ©tricas da referÃªncia extraÃ­das:', referenceMetrics);
        
        referenceStepState.referenceAnalysis = analysis;
        referenceStepState.referenceMetrics = referenceMetrics;
        
        // Executar comparaÃ§Ã£o
        updateReferenceStep('analysis');
        await performReferenceComparison();
        
        // ğŸ¯ EXIBIR resultados da anÃ¡lise por referÃªncia
        const finalAnalysis = referenceStepState.finalAnalysis;
        
        updateModalProgress(100, 'âœ… AnÃ¡lise por referÃªncia concluÃ­da!');
        
        // ğŸ¯ LOGS finais de validaÃ§Ã£o
        log('ğŸ‰ [ANÃLISE POR REFERÃŠNCIA] ConcluÃ­da com sucesso:');
        log('  - Baseline source:', finalAnalysis.comparison?.baseline_source);
        log('  - LUFS difference:', finalAnalysis.comparison?.loudness?.difference?.toFixed(2));
        log('  - SugestÃµes:', finalAnalysis.suggestions?.length || 0);
        log('  - Sem gÃªnero:', !finalAnalysis.genre);
        
        // Exibir modal de resultados
        displayReferenceResults(finalAnalysis);
        
        window.logReferenceEvent('reference_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
    }
}

// ğŸ¯ NOVO: Processar arquivo no modo gÃªnero (comportamento original)
async function handleGenreFileSelection(file) {
    // ï¿½ [ANONYMOUS-MODE] Interceptar anÃ¡lise em modo anÃ´nimo
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            log('ğŸš« [ANONYMOUS] AnÃ¡lise gÃªnero bloqueada - limite atingido');
            return;
        }
    }
    
    // ï¿½ğŸ› DIAGNÃ“STICO: Confirmar que este Ã© o modo gÃªnero
    log('ğŸ” [DIAGNÃ“STICO] handleGenreFileSelection - modo:', window.currentAnalysisMode);
    log('ğŸ” [DIAGNÃ“STICO] Este deveria ser APENAS modo gÃªnero!');
    
    __dbg('ğŸ”„ Iniciando nova anÃ¡lise - forÃ§ando exibiÃ§Ã£o do loading');
    showModalLoading();
    updateModalProgress(10, 'âš¡ Carregando Algoritmos AvanÃ§ados...');
    
    // Aguardar audio analyzer carregar se necessÃ¡rio
    if (!window.audioAnalyzer) {
        __dbg('â³ Aguardando Audio Analyzer carregar...');
        updateModalProgress(30, 'ğŸ”§ Inicializando V2 Engine...');
        await waitForAudioAnalyzer();
    }

    // ğŸ› CORREÃ‡ÃƒO CRÃTICA: SÃ³ carregar referÃªncias de gÃªnero se estivermos NO MODO GÃŠNERO
    if (window.currentAnalysisMode === 'genre') {
        // ğŸ¯ FALLBACK SEGURO: Restaurar gÃªnero do localStorage se nÃ£o estiver setado
        if (!window.PROD_AI_REF_GENRE) {
            const savedGenre = localStorage.getItem('prodai_ref_genre');
            if (savedGenre) {
                log('ğŸ”§ [GENRE-FALLBACK] Restaurando gÃªnero do localStorage:', savedGenre);
                window.PROD_AI_REF_GENRE = savedGenre;
            } else {
                error('âŒ [GENRE-CRITICAL] GÃªnero nÃ£o encontrado - modo gÃªnero sem targets');
            }
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: RESETAR ESTADO DE REFERÃŠNCIA ANTES DE CARREGAR TARGETS DE GÃŠNERO
        // ğŸ¯ PRESERVAR GÃŠNERO durante o reset
        const currentGenre = window.PROD_AI_REF_GENRE || window.__CURRENT_GENRE;
        log('ğŸ§¹ [GENRE-MODE] Resetando estado de referÃªncia antes de carregar targets...');
        log('ğŸ§¹ [GENRE-MODE] GÃªnero preservado:', currentGenre);
        resetReferenceStateFully(currentGenre);
        
        // Garantir que referÃªncias do gÃªnero selecionado estejam carregadas antes da anÃ¡lise
        try {
            const genre = window.PROD_AI_REF_GENRE;
            log('ğŸ” [DIAGNÃ“STICO] Carregando referÃªncias de gÃªnero:', genre);
            
            // âœ… CORREÃ‡ÃƒO: Sempre carregar targets se gÃªnero existir
            if (genre) {
                updateModalProgress(25, `ğŸ“š Carregando referÃªncias: ${genre}...`);
                await loadReferenceData(genre);
                updateModalProgress(30, 'ğŸ“š ReferÃªncias ok');
                
                // âœ… VALIDAÃ‡ÃƒO: Confirmar que targets foram carregados
                if (!window.__activeRefData) {
                    error('âŒ [GENRE-CRITICAL] Falha ao carregar targets de gÃªnero');
                } else {
                    log('âœ… [GENRE-SUCCESS] Targets carregados:', {
                        genre,
                        hasBands: !!window.__activeRefData.bands,
                        lufsTarget: window.__activeRefData.lufs_target
                    });
                }
            }
        } catch (e) { 
            error('âŒ [GENRE-ERROR] Erro ao carregar referÃªncias de gÃªnero:', e);
        }
    } else {
        log('ğŸ” [DIAGNÃ“STICO] PULAR carregamento de referÃªncias - modo nÃ£o Ã© gÃªnero');
    }
    
    // Analisar arquivo
    __dbg('ğŸ”¬ Iniciando anÃ¡lise...');
    updateModalProgress(40, 'ğŸµ Processando Waveform Digital...');
    
    // ï¿½ WAV MOBILE OPTIMIZATION: Aplicar otimizaÃ§Ãµes especÃ­ficas para WAV
    try {
        // Carregar otimizador WAV se nÃ£o estiver disponÃ­vel
        if (typeof window.wavMobileOptimizer === 'undefined') {
            const optimizerScript = document.createElement('script');
            optimizerScript.src = '/lib/audio/wav-mobile-optimizer.js';
            optimizerScript.type = 'module';
            document.head.appendChild(optimizerScript);
            
            // Aguardar carregamento com timeout
            await new Promise((resolve) => {
                optimizerScript.onload = () => {
                    log('ğŸµ WAV optimizer carregado');
                    resolve();
                };
                optimizerScript.onerror = () => {
                    warn('âš ï¸ WAV optimizer falhou ao carregar');
                    resolve();
                };
                setTimeout(resolve, 1500); // fallback timeout
            });
        }
        
        // Aplicar otimizaÃ§Ãµes se disponÃ­vel
        if (window.wavMobileOptimizer) {
            const wavAnalysis = window.wavMobileOptimizer.applyWAVOptimizations(file);
            if (wavAnalysis.requiresOptimization) {
                updateModalProgress(45, `ğŸµ WAV ${wavAnalysis.sizeInMB}MB - otimizaÃ§Ã£o mobile ativa...`);
                log('ğŸµ WAV mobile optimizations applied:', wavAnalysis);
            }
        }
    } catch (optimizerError) {
        warn('âš ï¸ WAV optimizer failed, continuing with standard processing:', optimizerError);
    }
    
    // ï¿½ğŸ¯ CORREÃ‡ÃƒO: Passar modo correto para anÃ¡lise
    const analysisOptions = { 
      mode: window.currentAnalysisMode || 'genre' 
    };
    // ğŸ†” CORREÃ‡ÃƒO: Preparar options com runId para anÃ¡lise principal
    const optionsWithRunId = prepareAnalysisOptions(analysisOptions, 'main');
    const analysis = await window.audioAnalyzer.analyzeAudioFile(file, optionsWithRunId);
    currentModalAnalysis = analysis;
    
    // ğŸš« CRITICAL: Expor globalmente para premium-blocker
    window.currentModalAnalysis = analysis;
    window.__CURRENT_ANALYSIS__ = analysis;
    
    // ğŸµ WAV CLEANUP: Limpar otimizaÃ§Ãµes WAV apÃ³s conclusÃ£o
    try {
        if (window.wavMobileOptimizer) {
            window.wavMobileOptimizer.cleanupWAVOptimizations();
        }
    } catch (cleanupError) {
        warn('WAV cleanup error (non-critical):', cleanupError);
    }
    
    __dbg('âœ… AnÃ¡lise concluÃ­da:', analysis);
    
    updateModalProgress(90, 'ğŸ§  Computando MÃ©tricas AvanÃ§adas...');
    
    // Aguardar um pouco para melhor UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    updateModalProgress(100, 'âœ¨ AnÃ¡lise Completa - Pronto!');
    
    // Mostrar resultados
    setTimeout(() => {
        // ğŸ”’ FASE 2 UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
        const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
        const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
        
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`ğŸš« [UI_GATE] AnÃ¡lise cancelada - nÃ£o renderizar UI (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
            return;
        }
        
        // Telemetria: verificar elementos alvo antes de preencher o modal
        const exists = {
            audioUploadArea: !!document.getElementById('audioUploadArea'),
            audioAnalysisLoading: !!document.getElementById('audioAnalysisLoading'),
            audioAnalysisResults: !!document.getElementById('audioAnalysisResults'),
            modalTechnicalData: !!document.getElementById('modalTechnicalData')
        };
        __dbg('ğŸ›°ï¸ [Telemetry] Front antes de preencher modal (existÃªncia de elementos):', exists);
        
        // ğŸ”’ UI GATE: Verificar novamente antes de renderizar
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`ğŸš« [UI_GATE] VerificaÃ§Ã£o dupla - anÃ¡lise cancelada durante delay`);
            return;
        }
        
        // ğŸ›¡ï¸ VERIFICAÃ‡ÃƒO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            displayModalResults(analysis);
        } else {
            warn('âš ï¸ [MODAL_MONITOR] FunÃ§Ã£o displayModalResults nÃ£o encontrada, aguardando carregamento...');
            // Tentar novamente em 1 segundo
            setTimeout(() => {
                if (typeof displayModalResults === 'function') {
                    displayModalResults(analysis);
                } else {
                    error('âŒ [MODAL_MONITOR] Timeout - funÃ§Ã£o displayModalResults nÃ£o encontrada apÃ³s espera');
                }
            }, 1000);
        }
        
        // ğŸ”§ CORREÃ‡ÃƒO: Limpar flag de anÃ¡lise em progresso apÃ³s sucesso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('âœ… AnÃ¡lise concluÃ­da com sucesso - flag removida');
    }, 800);
}

// ğŸ¯ NOVO: Atualizar upload area para step de referÃªncia
function updateUploadAreaForReferenceStep() {
    const uploadArea = document.getElementById('audioUploadArea');
    if (!uploadArea) return;
    
    const uploadContent = uploadArea.querySelector('.upload-content');
    if (!uploadContent) return;
    
    // Limpar input de arquivo
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) {
        fileInput.value = '';
    }
    
    // Atualizar conteÃºdo baseado no step
    if (referenceStepState.currentStep === 'referenceAudio') {
        const icon = uploadContent.querySelector('.upload-icon');
        const title = uploadContent.querySelector('h4');
        const description = uploadContent.querySelector('p:not(.supported-formats):not(.format-recommendation)');
        
        if (icon) icon.textContent = 'ğŸ¯';
        if (title) title.textContent = 'MÃºsica de ReferÃªncia';
        if (description) description.textContent = 'Agora selecione a mÃºsica que servirÃ¡ como referÃªncia para comparaÃ§Ã£o';
    }
    
    // Mostrar upload area novamente
    uploadArea.style.display = 'block';
    
    // Esconder loading
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) loading.style.display = 'none';
    
    window.logReferenceEvent('upload_area_updated', { 
        step: referenceStepState.currentStep 
    });
}

// ğŸ¯ REESCRITA COMPLETA: ComparaÃ§Ã£o baseada exclusivamente na referÃªncia
async function performReferenceComparison() {
    window.logReferenceEvent('reference_comparison_started');
    
    try {
        updateModalProgress(70, 'ğŸ”„ Comparando as duas mÃºsicas...');
        
        const userAnalysis = referenceStepState.userAnalysis;
        const refAnalysis = referenceStepState.referenceAnalysis;
        const referenceMetrics = referenceStepState.referenceMetrics;
        
        if (!userAnalysis || !refAnalysis || !referenceMetrics) {
            throw new Error('COMPARISON_DATA_MISSING: AnÃ¡lises ou mÃ©tricas de referÃªncia nÃ£o encontradas');
        }
        
        // ğŸ¯ EXTRAIR mÃ©tricas do usuÃ¡rio (anÃ¡lise pura, sem comparaÃ§Ãµes)
        const userMetrics = {
            lufs: userAnalysis.technicalData?.lufsIntegrated,
            stereoCorrelation: userAnalysis.technicalData?.stereoCorrelation,
            dynamicRange: userAnalysis.technicalData?.dynamicRange,
            truePeak: userAnalysis.technicalData?.truePeakDbtp
        };
        
        // ğŸš¨ VALIDAÃ‡ÃƒO: Verificar mÃ©tricas do usuÃ¡rio
        if (!Number.isFinite(userMetrics.lufs)) {
            throw new Error('USER_METRICS_FAILED: NÃ£o foi possÃ­vel extrair mÃ©tricas LUFS da sua mÃºsica');
        }
        
        log('ğŸ” [COMPARAÃ‡ÃƒO] MÃ©tricas extraÃ­das:');
        log('  - UsuÃ¡rio:', userMetrics);
        log('  - ReferÃªncia:', referenceMetrics);
        
        // ğŸ¯ CALCULAR diferenÃ§as PURAS (referÃªncia como baseline)
        const differences = {
            lufs: userMetrics.lufs - referenceMetrics.lufs,
            stereoCorrelation: userMetrics.stereoCorrelation - referenceMetrics.stereoCorrelation,
            dynamicRange: userMetrics.dynamicRange - referenceMetrics.dynamicRange,
            truePeak: userMetrics.truePeak - referenceMetrics.truePeak
        };
        
        log('ğŸ” [COMPARAÃ‡ÃƒO] DiferenÃ§as calculadas:', differences);
        
        // ğŸ¯ GERAR sugestÃµes baseadas APENAS na referÃªncia
        const referenceSuggestions = [];
        const THRESHOLD = 0.2; // Ignorar diferenÃ§as menores que 0.2dB
        
        // Loudness (LUFS) - ğŸš¨ COM VERIFICAÃ‡ÃƒO DE HEADROOM SEGURO
        if (Math.abs(differences.lufs) > THRESHOLD) {
            const action = differences.lufs > 0 ? 'Diminuir' : 'Aumentar';
            const direction = differences.lufs > 0 ? 'decrease' : 'increase';
            const adjustmentDb = Math.abs(differences.lufs);
            
            // ğŸ”’ Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                const userTruePeak = userMetrics.truePeak;
                const clippingSamples = userAnalysis.technical?.clippingSamples || 0;
                const isClipped = clippingSamples > 0;
                const headroomSafetyMargin = -0.6; // Target true peak seguro
                
                // ğŸš¨ REGRA 1: Se CLIPPED, nÃ£o sugerir aumento
                if (isClipped) {
                    log(`[REF-HEADROOM] ğŸš¨ Clipping detectado - nÃ£o sugerindo aumento de ${adjustmentDb.toFixed(1)}dB`);
                    referenceSuggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: `ImpossÃ­vel igualar referÃªncia - Ã¡udio tem clipping`,
                        action: `Primeiro resolver clipping, depois ajustar para referÃªncia`,
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        baseline_source: 'reference_audio',
                        warning: `Clipping detectado (${clippingSamples} samples)`
                    });
                } 
                // ğŸš¨ REGRA 2: Verificar headroom disponÃ­vel
                else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        referenceSuggestions.push({
                            type: 'reference_loudness',
                            message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar Ã  mÃºsica de referÃªncia`,
                            action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            baseline_source: 'reference_audio',
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponÃ­vel`
                        });
                    } else {
                        log(`[REF-HEADROOM] âš ï¸ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB - bloqueando`);
                        referenceSuggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: `ImpossÃ­vel igualar referÃªncia - sem headroom suficiente`,
                            action: `True Peak ${userTruePeak.toFixed(1)}dBTP permite apenas +${availableHeadroom.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            baseline_source: 'reference_audio',
                            warning: `NecessÃ¡rio ${adjustmentDb.toFixed(1)}dB mas sÃ³ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    referenceSuggestions.push({
                        type: 'reference_loudness_conservative',
                        message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar referÃªncia (verificar clipping)`,
                        action: `${action} volume CUIDADOSAMENTE em ${adjustmentDb.toFixed(1)}dB`,
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        baseline_source: 'reference_audio',
                        warning: 'Sem dados True Peak - verifique clipping apÃ³s ajuste'
                    });
                }
            } else {
                // Diminuir Ã© sempre seguro
                referenceSuggestions.push({
                    type: 'reference_loudness',
                    message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar Ã  mÃºsica de referÃªncia`,
                    action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction,
                    baseline_source: 'reference_audio'
                });
            }
        }
        
        // Dynamic Range
        if (Math.abs(differences.dynamicRange) > THRESHOLD) {
            const action = differences.dynamicRange > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_dynamics',
                message: `${action} range dinÃ¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB para igualar Ã  referÃªncia`,
                action: `${action} range dinÃ¢mico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.dynamicRange),
                baseline_source: 'reference_audio'
            });
        }
        
        // Stereo Correlation
        if (Math.abs(differences.stereoCorrelation) > 0.05) { // 5% threshold para correlaÃ§Ã£o
            const action = differences.stereoCorrelation > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_stereo',
                message: `${action} correlaÃ§Ã£o estÃ©reo para igualar Ã  referÃªncia (diferenÃ§a: ${(differences.stereoCorrelation * 100).toFixed(1)}%)`,
                action: `Ajustar correlaÃ§Ã£o estÃ©reo`,
                frequency_range: 'N/A',
                baseline_source: 'reference_audio'
            });
        }
        
        // Pico Real
        if (Math.abs(differences.truePeak) > THRESHOLD) {
            const action = differences.truePeak > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_peak',
                message: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB para igualar Ã  referÃªncia`,
                action: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.truePeak),
                baseline_source: 'reference_audio'
            });
        }
        
        log(`ğŸ” [COMPARAÃ‡ÃƒO] SugestÃµes geradas: ${referenceSuggestions.length}`);
        
        // ğŸ¯ CRIAR anÃ¡lise final com comparaÃ§Ã£o pura
        const finalAnalysis = {
            ...userAnalysis,
            comparison: {
                mode: 'reference',
                baseline_source: 'reference_audio',
                loudness: {
                    user: userMetrics.lufs,
                    reference: referenceMetrics.lufs,
                    difference: differences.lufs,
                    baseline: referenceMetrics.lufs
                },
                dynamics: {
                    user: userMetrics.dynamicRange,
                    reference: referenceMetrics.dynamicRange,
                    difference: differences.dynamicRange,
                    baseline: referenceMetrics.dynamicRange
                },
                stereo: {
                    user: userMetrics.stereoCorrelation,
                    reference: referenceMetrics.stereoCorrelation,
                    difference: differences.stereoCorrelation,
                    baseline: referenceMetrics.stereoCorrelation
                },
                peak: {
                    user: userMetrics.truePeak,
                    reference: referenceMetrics.truePeak,
                    difference: differences.truePeak,
                    baseline: referenceMetrics.truePeak
                }
            },
            suggestions: referenceSuggestions,
            // ğŸš« NUNCA usar gÃªnero em modo referÃªncia
            genre: null,
            mixScore: null, // NÃ£o gerar score baseado em gÃªnero
            mixClassification: null
        };
        
        // ğŸ¯ LOGS de validaÃ§Ã£o final
        log('ğŸ‰ [SUCESSO] ComparaÃ§Ã£o por referÃªncia concluÃ­da:');
        log('  - Modo:', finalAnalysis.comparison.mode);
        log('  - Baseline source:', finalAnalysis.comparison.baseline_source);
        log('  - SugestÃµes:', referenceSuggestions.length);
        log('  - Sem contaminaÃ§Ã£o de gÃªnero:', !finalAnalysis.genre);
        
        referenceStepState.finalAnalysis = finalAnalysis;
        log('ğŸ” [DIAGNÃ“STICO] Reference analysis tem comparaÃ§Ã£o com gÃªnero:', !!refAnalysis.comparison);
        
        // ğŸ¯ NOVO: Verificar se anÃ¡lises estÃ£o "limpas" (sem contaminar com gÃªnero)
        const userClean = !userAnalysis.comparison && !userAnalysis.reference;
        const refClean = !refAnalysis.comparison && !refAnalysis.reference;
        log('ğŸ” [DIAGNÃ“STICO] User analysis clean (sem gÃªnero):', userClean);
        log('ğŸ” [DIAGNÃ“STICO] Reference analysis clean (sem gÃªnero):', refClean);
        
        // Gerar comparaÃ§Ã£o
        const comparison = generateComparison(userAnalysis, refAnalysis);
        
        // ğŸ› DIAGNÃ“STICO: Verificar se comparison estÃ¡ usando os dados corretos
        log('ğŸ” [DIAGNÃ“STICO] Comparison gerada:', comparison);
        log('ğŸ” [DIAGNÃ“STICO] baseline_source: reference_audio (confirmed)');
        
        // Gerar sugestÃµes baseadas na comparaÃ§Ã£o
        const suggestions = generateReferenceSuggestions(comparison);
        
        // ğŸ¯ CORREÃ‡ÃƒO #4: Garantir pelo menos 3 sugestÃµes A/B
        log('ğŸ” [AB-SUGGESTIONS] SugestÃµes geradas:', suggestions.length);
        if (suggestions.length < 3) {
            warn('[AB-SUGGESTIONS] âš ï¸ Menos de 3 sugestÃµes - gerando padrÃ£o');
            // Garantir pelo menos 3 sugestÃµes mÃ­nimas
            while (suggestions.length < 3) {
                suggestions.push({
                    type: 'reference_info',
                    message: 'AnÃ¡lise de comparaÃ§Ã£o A/B concluÃ­da',
                    action: 'Continue monitorando as diferenÃ§as entre suas faixas',
                    explanation: 'Use a tabela acima para identificar Ã¡reas de melhoria',
                    frequency_range: 'N/A',
                    adjustment_db: 0,
                    direction: 'info'
                });
            }
        }
        
        // ğŸ› DIAGNÃ“STICO: Verificar se sugestÃµes sÃ£o baseadas apenas na comparison
        log('ğŸ” [DIAGNÃ“STICO] SugestÃµes geradas (count):', suggestions.length);
        log('ğŸ” [DIAGNÃ“STICO] Primeiro tipo de sugestÃ£o:', suggestions[0]?.type);
        
        // Criar anÃ¡lise combinada para exibiÃ§Ã£o
        const combinedAnalysis = {
            ...userAnalysis,
            comparison,
            // ğŸ¯ CORREÃ‡ÃƒO #4: Merge seguro de sugestÃµes (user + A/B), sem duplicar
            suggestions: [
                ...(userAnalysis.suggestions || []),
                ...suggestions.filter(s => !userAnalysis.suggestions?.some(us => us.type === s.type))
            ],
            analysisMode: 'reference',
            referenceFile: referenceStepState.referenceAudioFile.name,
            userFile: referenceStepState.userAudioFile.name,
            // ğŸ¯ NOVO: Incluir mÃ©tricas da referÃªncia para renderReferenceComparisons
            referenceMetrics: {
                lufs: refAnalysis.technicalData?.lufsIntegrated,
                truePeakDbtp: refAnalysis.technicalData?.truePeakDbtp,
                dynamicRange: refAnalysis.technicalData?.dynamicRange,
                lra: refAnalysis.technicalData?.lra,
                stereoCorrelation: refAnalysis.technicalData?.stereoCorrelation,
                // ğŸ”§ CORREÃ‡ÃƒO: Criar estrutura de bands compatÃ­vel
                bands: refAnalysis.technicalData?.bandEnergies ? (() => {
                    const refBands = {};
                    const refBandEnergies = refAnalysis.technicalData.bandEnergies;
                    
                    // Criar estrutura de bands usando as mÃ©tricas da referÃªncia como targets
                    Object.entries(refBandEnergies).forEach(([bandName, bandData]) => {
                        if (bandData && Number.isFinite(bandData.rms_db)) {
                            refBands[bandName] = {
                                target_db: bandData.rms_db,  // Usar valor da referÃªncia como target
                                tol_db: 3.0,  // TolerÃ¢ncia padrÃ£o
                                _target_na: false
                            };
                        }
                    });
                    
                    return refBands;
                })() : null
            },
            // ğŸ› DIAGNÃ“STICO: Adicionar metadados para diagnÃ³stico
            _diagnostic: {
                baseline_source: 'reference_audio',
                mode: 'reference',
                userLufs: userAnalysis.technicalData?.lufsIntegrated,
                referenceLufs: refAnalysis.technicalData?.lufsIntegrated,
                difference: comparison.loudness?.difference,
                genreActive: window.PROD_AI_REF_GENRE,
                useGenreTargets: false,
                // ğŸ¯ NOVO: InformaÃ§Ãµes de normalizaÃ§Ã£o e janela
                usedWindowSeconds: 30, // TODO: pegar do analyzer quando implementado
                normalizedLUFS: {
                    user: userAnalysis.technicalData?.lufsIntegrated,
                    ref: refAnalysis.technicalData?.lufsIntegrated
                },
                analysisTimestamp: new Date().toISOString()
            }
        };
        
        log('ğŸ” [DIAGNÃ“STICO] Combined analysis diagnostic:', combinedAnalysis._diagnostic);
        
        currentModalAnalysis = combinedAnalysis;
        
        // ğŸš« CRITICAL: Expor globalmente para premium-blocker
        window.currentModalAnalysis = combinedAnalysis;
        window.__CURRENT_ANALYSIS__ = combinedAnalysis;
        
        // ğŸ¯ ALIAS GLOBAL PARA RELATÃ“RIOS (Modo ReferÃªncia)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = combinedAnalysis;
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = combinedAnalysis;
            
            log('âœ… [PDF-READY] ComparaÃ§Ã£o armazenada globalmente:', {
                mode: 'reference',
                hasComparison: !!combinedAnalysis.comparison,
                userFile: combinedAnalysis.userFile,
                referenceFile: combinedAnalysis.referenceFile
            });
        }
        
        updateModalProgress(100, 'âœ¨ ComparaÃ§Ã£o Completa!');
        
        // Mostrar resultados
        setTimeout(() => {
            // ğŸ”’ UI GATE: Verificar se anÃ¡lise ainda Ã© vÃ¡lida
            const analysisRunId = combinedAnalysis?.runId || combinedAnalysis?.metadata?.runId;
            const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
            
            if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                warn(`ğŸš« [UI_GATE] ComparaÃ§Ã£o cancelada - nÃ£o renderizar UI (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
                return;
            }
            
            displayModalResults(combinedAnalysis);
            window.logReferenceEvent('reference_comparison_completed');
        }, 800);
        
    } catch (error) {
        error('âŒ Erro na comparaÃ§Ã£o:', error);
        window.logReferenceEvent('reference_comparison_error', { error: error.message });
        showModalError(`Erro na comparaÃ§Ã£o: ${error.message}`);
    }
}

// ğŸ¯ NOVO: Gerar comparaÃ§Ã£o entre duas anÃ¡lises
function generateComparison(userAnalysis, refAnalysis) {
    const userTech = userAnalysis.technicalData || {};
    const refTech = refAnalysis.technicalData || {};
    
    return {
        loudness: {
            user: userTech.lufsIntegrated || null,
            reference: refTech.lufsIntegrated || null,
            difference: (userTech.lufsIntegrated && refTech.lufsIntegrated) 
                ? userTech.lufsIntegrated - refTech.lufsIntegrated 
                : null
        },
        dynamics: {
            user: userTech.lra || userTech.crestFactor || null,
            reference: refTech.lra || refTech.crestFactor || null,
            difference: (userTech.lra && refTech.lra) 
                ? userTech.lra - refTech.lra 
                : null
        },
        stereo: {
            user: userTech.stereoCorrelation || null,
            reference: refTech.stereoCorrelation || null,
            difference: (userTech.stereoCorrelation && refTech.stereoCorrelation) 
                ? userTech.stereoCorrelation - refTech.stereoCorrelation 
                : null
        },
        spectral: compareSpectralData(userTech, refTech)
    };
}

// ğŸ¯ NOVO: Comparar dados espectrais
function compareSpectralData(userTech, refTech) {
    const bandNames = ['subBass', 'bass', 'lowMid', 'mid', 'upperMid', 'presence', 'brilliance', 'air'];
    const comparisons = {};
    
    bandNames.forEach(band => {
        const userValue = userTech[`${band}Energy`] || userTech[`energy_${band}`] || null;
        const refValue = refTech[`${band}Energy`] || refTech[`energy_${band}`] || null;
        
        if (userValue !== null && refValue !== null) {
            comparisons[band] = {
                user: userValue,
                reference: refValue,
                difference: userValue - refValue
            };
        }
    });
    
    return comparisons;
}

// ğŸ¯ NOVO: Gerar sugestÃµes baseadas na comparaÃ§Ã£o
function generateReferenceSuggestions(comparison) {
    // ğŸ› DIAGNÃ“STICO: Logs para verificar fonte dos dados
    log('ğŸ” [DIAGNÃ“STICO] generateReferenceSuggestions called with:', comparison);
    log('ğŸ” [DIAGNÃ“STICO] Usando APENAS dados da comparison, nÃ£o genre targets');
    log('ğŸ” [DIAGNÃ“STICO] Genre ativo (NÃƒO usado):', window.PROD_AI_REF_GENRE);
    
    const suggestions = [];
    
    // SugestÃµes de loudness - ğŸš¨ COM VERIFICAÃ‡ÃƒO DE HEADROOM SEGURO
    if (comparison.loudness.difference !== null) {
        const diff = comparison.loudness.difference;
        log('ğŸ” [DIAGNÃ“STICO] Loudness difference:', diff);
        
        if (Math.abs(diff) > 1) {
            const adjustmentDb = Math.abs(diff);
            const direction = diff > 0 ? 'decrease' : 'increase';
            
            // ğŸ”’ Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                // Tentar acessar dados do usuÃ¡rio para verificaÃ§Ã£o de headroom
                const userTruePeak = comparison.userTruePeak || null;
                const userClipping = comparison.userClipping || 0;
                const isClipped = userClipping > 0;
                const headroomSafetyMargin = -0.6;
                
                if (isClipped) {
                    log(`[REF-HEADROOM] ğŸš¨ Clipping detectado - bloqueando aumento de ${adjustmentDb.toFixed(1)}dB`);
                    suggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: 'ImpossÃ­vel igualar referÃªncia - Ã¡udio tem clipping',
                        action: 'Primeiro resolver clipping, depois ajustar para referÃªncia',
                        explanation: 'Clipping detectado impede aumento seguro',
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        warning: `Clipping detectado (${userClipping} samples)`
                    });
                } else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        const suggestion = {
                            type: 'reference_loudness',
                            message: 'Sua mÃºsica estÃ¡ mais baixa que a referÃªncia',
                            action: `Aumentar volume em ${adjustmentDb.toFixed(1)}dB`,
                            explanation: 'Para match de loudness com a referÃªncia',
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponÃ­vel`
                        };
                        suggestions.push(suggestion);
                    } else {
                        log(`[REF-HEADROOM] âš ï¸ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB`);
                        suggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: 'ImpossÃ­vel igualar referÃªncia - sem headroom suficiente',
                            action: `True Peak permite apenas +${availableHeadroom.toFixed(1)}dB (necessÃ¡rio ${adjustmentDb.toFixed(1)}dB)`,
                            explanation: 'Aumentar mais causaria clipping (True Peak > -0.6 dBTP)',
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            warning: `NecessÃ¡rio ${adjustmentDb.toFixed(1)}dB mas sÃ³ ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    suggestions.push({
                        type: 'reference_loudness_conservative',
                        message: 'Sua mÃºsica estÃ¡ mais baixa que a referÃªncia (verificar clipping)',
                        action: `Aumentar CUIDADOSAMENTE volume em ${adjustmentDb.toFixed(1)}dB`,
                        explanation: 'Sem dados True Peak - risco de clipping',
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        warning: 'Verifique clipping apÃ³s ajuste'
                    });
                }
            } else {
                // Diminuir Ã© sempre seguro
                const suggestion = {
                    type: 'reference_loudness',
                    message: 'Sua mÃºsica estÃ¡ mais alta que a referÃªncia',
                    action: `Diminuir volume em ${adjustmentDb.toFixed(1)}dB`,
                    explanation: 'Para match de loudness com a referÃªncia',
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction
                };
                suggestions.push(suggestion);
            }
            
            log('ğŸ” [DIAGNÃ“STICO] SugestÃ£o de loudness processada com headroom check');
        }
    }
    
    // SugestÃµes espectrais
    Object.entries(comparison.spectral).forEach(([band, data]) => {
        log(`ğŸ” [DIAGNÃ“STICO] Spectral band ${band}:`, data);
        
        if (Math.abs(data.difference) > 2) {
            const freqRanges = {
                subBass: bandData.sub?.frequencyRange || '20-60 Hz',
                bass: bandData.bass?.frequencyRange || '60-150 Hz',
                lowMid: bandData.lowMid?.frequencyRange || '150-500 Hz',
                mid: bandData.mid?.frequencyRange || '500-2k Hz',
                upperMid: bandData.highMid?.frequencyRange || '2k-5k Hz',
                presence: bandData.presence?.frequencyRange || '5k-10k Hz',
                brilliance: bandData.air?.frequencyRange || '10k-20k Hz',
                air: bandData.air?.frequencyRange || '10k-20k Hz'
            };
            
            const suggestion = {
                type: 'reference_spectral',
                message: data.difference > 0 ? `Muito ${band} comparado Ã  referÃªncia` : `Pouco ${band} comparado Ã  referÃªncia`,
                action: data.difference > 0 ? `Cortar ${band}` : `RealÃ§ar ${band}`,
                explanation: `Para match espectral com a referÃªncia`,
                frequency_range: freqRanges[band] || 'N/A',
                adjustment_db: Math.abs(data.difference),
                direction: data.difference > 0 ? 'cut' : 'boost',
                q_factor: 1.0
            };
            
            log(`ğŸ” [DIAGNÃ“STICO] Adicionando sugestÃ£o espectral para ${band}:`, suggestion);
            suggestions.push(suggestion);
        }
    });
    
    log('ğŸ” [DIAGNÃ“STICO] Total sugestÃµes geradas:', suggestions.length);
    log('ğŸ” [DIAGNÃ“STICO] baseline_source: reference_audio (confirmed)');
    
    return suggestions;
}

// ğŸ¯ NOVO: Adicionar seÃ§Ã£o de comparaÃ§Ã£o com referÃªncia
function addReferenceComparisonSection(analysis) {
    const results = document.getElementById('audioAnalysisResults');
    if (!results) return;
    
    const comparison = analysis.comparison;
    const userFile = analysis.userFile || 'Sua mÃºsica';
    const referenceFile = analysis.referenceFile || 'MÃºsica de referÃªncia';
    
    // Criar seÃ§Ã£o de comparaÃ§Ã£o
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'reference-comparison-section';
    comparisonSection.innerHTML = `
        <div class="comparison-header">
            <h4>ğŸ¯ ComparaÃ§Ã£o com ReferÃªncia</h4>
            <div class="comparison-files">
                <span class="file-indicator user">ğŸ“„ ${userFile}</span>
                <span class="vs-indicator">vs</span>
                <span class="file-indicator reference">ğŸ¯ ${referenceFile}</span>
            </div>
        </div>
        
        <div class="comparison-content">
            <div class="comparison-grid">
                ${generateComparisonRow('Loudness', comparison.loudness, 'LUFS')}
                ${generateComparisonRow('Faixa DinÃ¢mica', comparison.dynamics, 'dB')}
                ${generateComparisonRow('CorrelaÃ§Ã£o EstÃ©reo', comparison.stereo, '')}
            </div>
            
            ${comparison.spectral && Object.keys(comparison.spectral).length > 0 ? `
                <div class="spectral-comparison">
                    <h5>ğŸ“Š AnÃ¡lise Espectral</h5>
                    <div class="spectral-grid">
                        ${Object.entries(comparison.spectral).map(([band, data]) => 
                            generateSpectralComparisonCard(band, data)
                        ).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
    
    // Inserir no inÃ­cio da seÃ§Ã£o de resultados
    const resultsHeader = results.querySelector('.results-header');
    if (resultsHeader) {
        resultsHeader.insertAdjacentElement('afterend', comparisonSection);
    } else {
        results.insertBefore(comparisonSection, results.firstChild);
    }
    
    window.logReferenceEvent('comparison_section_displayed');
}

// ğŸ¯ NOVO: Gerar linha de comparaÃ§Ã£o
function generateComparisonRow(label, comparisonData, unit) {
    if (!comparisonData || comparisonData.difference === null) {
        return `
            <div class="comparison-row unavailable">
                <div class="comparison-label">${label}</div>
                <div class="comparison-values">
                    <span class="comparison-unavailable">Dados insuficientes</span>
                </div>
            </div>
        `;
    }
    
    const userValue = comparisonData.user?.toFixed?.(1) || comparisonData.user || 'â€”';
    const refValue = comparisonData.reference?.toFixed?.(1) || comparisonData.reference || 'â€”';
    const diff = comparisonData.difference?.toFixed?.(1) || 'â€”';
    const diffClass = comparisonData.difference > 0 ? 'positive' : comparisonData.difference < 0 ? 'negative' : 'neutral';
    
    return `
        <div class="comparison-row">
            <div class="comparison-label">${label}</div>
            <div class="comparison-values">
                <div class="value-pair">
                    <span class="user-value">${userValue}${unit}</span>
                    <span class="ref-value">${refValue}${unit}</span>
                </div>
                <div class="difference-indicator ${diffClass}">
                    ${diff > 0 ? '+' : ''}${diff}${unit}
                </div>
            </div>
        </div>
    `;
}

// ğŸ¯ NOVO: Gerar card de comparaÃ§Ã£o espectral
function generateSpectralComparisonCard(band, data) {
    const bandNames = {
        subBass: 'Sub Bass',
        bass: 'Bass',
        lowMid: 'Low Mid',
        mid: 'Mid',
        upperMid: 'Upper Mid',
        presence: 'Presence',
        brilliance: 'Brilliance',
        air: 'Air'
    };
    
    const friendlyName = bandNames[band] || band;
    const diff = data.difference?.toFixed?.(1) || 'â€”';
    const diffClass = data.difference > 2 ? 'high-positive' : 
                      data.difference > 0.5 ? 'positive' : 
                      data.difference < -2 ? 'high-negative' : 
                      data.difference < -0.5 ? 'negative' : 'neutral';
    
    return `
        <div class="spectral-card ${diffClass}">
            <div class="spectral-band-name">${friendlyName}</div>
            <div class="spectral-difference">${diff > 0 ? '+' : ''}${diff}dB</div>
        </div>
    `;
}

// â³ Aguardar Audio Analyzer carregar
function waitForAudioAnalyzer() {
    return new Promise((resolve) => {
        if (window.audioAnalyzer) {
            resolve();
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (window.audioAnalyzer) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
        
        // Timeout apÃ³s 10 segundos
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
        }, 10000);
    });
}

// ï¿½ Atualizar progresso no modal
function updateModalProgress(percentage, message) {
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
    
    if (progressText) {
        progressText.textContent = message || `${percentage}%`;
    }
    
    __dbg(`ğŸ“ˆ Progresso: ${percentage}% - ${message}`);
}

// âŒ Mostrar erro no modal (usa ErrorMapper V3 com SCOPE e PLAN POLICY)
function showModalError(messageOrError, errorCode, meta = {}) {
    log('[showModalError] Recebido:', { messageOrError, errorCode, meta });
    
    // ğŸ¯ V3: Extrair dados estruturados se disponÃ­veis
    let structuredData = null;
    if (typeof messageOrError === 'object' && messageOrError !== null) {
        structuredData = messageOrError.structuredData || messageOrError;
    }
    
    // ğŸ”¥ [DEMO] Se Ã© erro de limite de demo, mostrar modal de upgrade ao invÃ©s de erro
    const message = typeof messageOrError === 'string' ? messageOrError : (messageOrError?.message || '');
    const isDemoLimitError = message && (
        message.includes('Limite') ||
        message.includes('limite') ||
        message.includes('demonstrativa') ||
        message.includes('demo') ||
        message.includes('DEMO') ||
        message.includes('acesso completo') ||
        message.includes('Libere')
    );
    
    if (isDemoLimitError && window.SoundyDemo?.isActive && typeof window.SoundyDemo.showConversionModal === 'function') {
        log('ğŸ”¥ [DEMO] Erro de limite detectado - mostrando modal de upgrade');
        window.SoundyDemo.showConversionModal('analysis_limit');
        return; // NÃƒO mostra modal de erro genÃ©rico
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    if (results) {
        results.style.display = 'block';
        
        // ğŸ›¡ï¸ PRESERVAR #referenceComparisons antes de limpar
        const refContainer = document.getElementById('referenceComparisons');
        const refHTML = refContainer ? refContainer.outerHTML : '';
        
        // ğŸ¯ V3: USAR ERROR MAPPER COM SCOPE E PLAN POLICY
        if (window.ErrorMapper && typeof window.ErrorMapper.mapBlockUi === 'function') {
            // Priorizar dados estruturados do backend
            const scope = structuredData?.scope || meta?.scope || 'analysis'; // Default: analysis para este arquivo
            const code = structuredData?.code || structuredData?.error || errorCode || meta?.errorCode;
            const feature = structuredData?.feature || meta?.feature;
            const plan = structuredData?.plan || meta?.plan || window.ErrorMapper.detectCurrentPlan();
            const backendMeta = structuredData?.meta || {};
            
            // Se nÃ£o tem cÃ³digo explÃ­cito, tentar extrair do texto
            let detectedCode = code;
            if (!detectedCode && message) {
                const codePatterns = [
                    /SYSTEM_PEAK_USAGE/i,
                    /LIMIT_REACHED/i,
                    /ANALYSIS_LIMIT/i,
                    /CHAT_LIMIT/i,
                    /HARD_CAP/i,
                    /DEMO_LIMIT/i,
                    /PLAN_REQUIRED/i,
                    /FEATURE_NOT_AVAILABLE/i,
                    /FEATURE_LOCKED/i,
                    /AUTH_REQUIRED/i,
                    /TIMEOUT/i,
                    /RATE_LIMIT/i
                ];
                for (const pattern of codePatterns) {
                    const match = message.match(pattern);
                    if (match) {
                        detectedCode = match[0].toUpperCase().replace(/-/g, '_');
                        break;
                    }
                }
            }
            
            // Se ainda nÃ£o tem cÃ³digo mas tem mensagem de limite, deduzir
            if (!detectedCode && message) {
                if (message.includes('limite') || message.includes('Limite')) {
                    detectedCode = 'LIMIT_REACHED';
                } else if (message.includes('alta demanda') || message.includes('ocupados')) {
                    detectedCode = 'SYSTEM_PEAK_USAGE';
                }
            }
            
            log('[showModalError] Chamando mapBlockUi com scope:', scope, 'code:', detectedCode, 'plan:', plan);
            
            const errorUi = window.ErrorMapper.mapBlockUi({
                scope: scope,
                code: detectedCode || 'SERVICE_ERROR',
                feature: feature,
                plan: plan,
                meta: {
                    ...meta,
                    ...backendMeta,
                    cap: backendMeta.cap || meta?.cap || meta?.limit,
                    used: backendMeta.used || meta?.used || meta?.current,
                    resetDate: backendMeta.resetDate || meta?.resetDate || meta?.nextReset
                }
            });
            
            // ğŸ¯ V3: VERIFICAR POLÃTICA DE DOWNGRADE PARA ANÃLISE
            const policy = errorUi._policy || window.ErrorMapper.getPlanPolicy(plan);
            const isLimitError = ['LIMIT_REACHED', 'HARD_CAP_REACHED', 'ANALYSIS_LIMIT_REACHED'].includes(detectedCode?.toUpperCase());
            
            if (scope === 'analysis' && isLimitError) {
                log('[showModalError] ğŸ¯ Verificando polÃ­tica de overflow para anÃ¡lise:', policy);
                
                if (policy.overflowAnalysis === 'downgrade_to_reduced') {
                    // FREE/PLUS/PRO: Mostrar modal mas permitir continuar em reduced
                    log('[showModalError] ğŸ“‰ Policy: downgrade_to_reduced - Permitindo modo reduced apÃ³s modal');
                    
                    // Configurar callback especial que abre upload em modo reduced
                    window.ErrorMapper.setRetryCallback(() => {
                        log('[showModalError] ğŸ”„ Retry callback: Entrando em modo reduced');
                        window.__forceReducedMode = true; // Flag para o prÃ³ximo upload
                        resetModalState();
                    });
                    
                    // Adicionar info de reduced no modal
                    if (policy.exposeLimits) {
                        const originalMessage = errorUi.message;
                        errorUi.message = originalMessage + '\n\nVocÃª ainda pode fazer anÃ¡lises no modo bÃ¡sico (Score, LUFS, True Peak).';
                        errorUi.secondaryCta = { label: 'ğŸ“Š Continuar Modo BÃ¡sico', action: 'retry' };
                    }
                } else if (policy.overflowAnalysis === 'system_peak_modal') {
                    // STUDIO: Apenas modal de alta demanda, sem downgrade
                    log('[showModalError] â³ Policy: system_peak_modal - Apenas retry, sem downgrade');
                    window.ErrorMapper.setRetryCallback(resetModalState);
                }
            } else {
                // Callback padrÃ£o
                window.ErrorMapper.setRetryCallback(resetModalState);
            }
            
            // Renderizar usando ErrorMapper
            window.ErrorMapper.renderErrorModal(errorUi, results);
            log('[showModalError] âœ… Erro renderizado com ErrorMapper V3:', errorUi.title, errorUi._debug);
        } else if (window.ErrorMapper && typeof window.ErrorMapper.mapErrorToUi === 'function') {
            // ğŸ”„ FALLBACK V1: mapErrorToUi (compatibilidade)
            warn('[showModalError] Usando mapErrorToUi (V1 fallback)');
            const errorUi = window.ErrorMapper.mapErrorToUi({
                code: errorCode || 'UNKNOWN',
                plan: meta?.plan || window.ErrorMapper.detectCurrentPlan(),
                feature: meta?.feature || 'analysis',
                meta: meta
            });
            window.ErrorMapper.setRetryCallback(resetModalState);
            window.ErrorMapper.renderErrorModal(errorUi, results);
        } else {
            // ğŸ”´ FALLBACK: renderizaÃ§Ã£o antiga se ErrorMapper nÃ£o disponÃ­vel
            warn('[showModalError] ErrorMapper nÃ£o disponÃ­vel, usando fallback');
            results.innerHTML = `
                <div style="color: #ff4444; text-align: center; padding: 30px;">
                    <div style="font-size: 3em; margin-bottom: 15px;">âš ï¸</div>
                    <h3 style="margin: 0 0 15px 0; color: #ff4444;">Erro na AnÃ¡lise</h3>
                    <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">${message}</p>
                    <button onclick="resetModalState()" style="
                        background: #ff4444; 
                        color: white; 
                        border: none; 
                        padding: 12px 25px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                        transition: background 0.3s;
                    " onmouseover="this.style.background='#ff3333'" 
                       onmouseout="this.style.background='#ff4444'">
                        Tentar Novamente
                    </button>
                </div>
            `;
        }
        
        // ğŸ›¡ï¸ RESTAURAR #referenceComparisons apÃ³s limpar
        if (refHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = refHTML;
            results.appendChild(tempDiv.firstElementChild);
            log('[ERROR-HANDLER] âœ… #referenceComparisons preservado durante erro');
        }
    }
}

// ï¿½ğŸ”„ Mostrar loading no modal
function showModalLoading() {
    __dbg('ğŸ”„ Exibindo tela de loading no modal...');
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    // ğŸ”§ CORREÃ‡ÃƒO: Garantir que o loading seja exibido corretamente
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    }
    if (results) {
        results.style.display = 'none';
        __dbg('âœ… Results area ocultada');
    }
    if (loading) {
        loading.style.display = 'block';
        __dbg('âœ… Loading area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
    
    // Reset progress
    updateModalProgress(0, 'ğŸ”„ Inicializando Engine de AnÃ¡lise...');
    __dbg('âœ… Progresso resetado e loading configurado');
}

// ğŸ“ˆ Simular progresso
// (funÃ§Ã£o de simulaÃ§Ã£o de progresso removida â€” nÃ£o utilizada)

// âœ… FUNÃ‡ÃƒO DE MODO REDUZIDO
/**
 * Renderizar interface em modo reduzido (FREE/PLUS sem anÃ¡lises restantes)
 * Mostra apenas: Score, True Peak, LUFS, Dynamic Range
 * Oculta: Bandas, Espectro, SugestÃµes, IA AvanÃ§ada
 */
// ========================================
// ğŸ¯ SISTEMA DE MASCARAMENTO DINÃ‚MICO PARA MODO REDUZIDO
// ========================================

/**
 * ğŸ” Escaneia o DOM e constrÃ³i mapeamento de mÃ©tricas por data-attribute
 * Aplica regras especÃ­ficas por seÃ§Ã£o conforme especificaÃ§Ã£o Reduced Mode
 * @param {Object} analysis - Dados da anÃ¡lise com JSON completo
 * @returns {Object} { allowedNodes: [], blockedNodes: [] }
 */
function buildMetricDomMap(analysis) {
    log('[DOM-SCAN] ğŸ” Iniciando escaneamento do DOM...');
    
    // ğŸ¯ REGRAS POR SEÃ‡ÃƒO - MÃ©tricas PERMITIDAS no modo reduced
    // âœ… LIBERADAS: DR, EstÃ©reo, Low Mid, High Mid, PresenÃ§a
    // ğŸ”’ BLOQUEADAS: LUFS, True Peak, LRA, Sub, Bass, Mid, Brilho, AvanÃ§adas
    const allowedPrimaryMetrics = [
        'dr',
        'dynamicRange',
        'scoreFinal'
    ];
    
    // (B) FREQUÃŠNCIAS: Low Mid, High Mid, PresenÃ§a LIBERADAS
    const allowedFrequencyMetrics = [
        'band_lowMid',
        'band_low_mid',
        'lowMid',
        'low_mid',
        'band_highMid',
        'band_high_mid',
        'highMid',
        'high_mid',
        'band_presence',
        'presence'
    ];
    
    // (C) MÃ‰TRICAS AVANÃ‡ADAS: Nenhuma (tudo borrado)
    const allowedAdvancedMetrics = [];
    
    // Lista completa para scan geral
    const allowedMetrics = [
        ...allowedPrimaryMetrics,
        ...allowedFrequencyMetrics
    ];
    
    const allowedNodes = [];
    const blockedNodes = [];
    
    // Buscar por todos os elementos com data-metric-key
    const modalContainer = document.getElementById('audioAnalysisResults');
    if (!modalContainer) {
        warn('[DOM-SCAN] âš ï¸ Container de resultados nÃ£o encontrado');
        return { allowedNodes, blockedNodes };
    }
    
    // Selecionar TODOS os elementos com data-metric-key
    const metricNodes = modalContainer.querySelectorAll('[data-metric-key]');
    
    metricNodes.forEach(el => {
        const key = el.getAttribute('data-metric-key');
        
        if (allowedMetrics.includes(key)) {
            allowedNodes.push({ key, el });
            log('[DOM-SCAN] âœ… MÃ©trica permitida encontrada:', key, '=', el.textContent.trim());
        } else {
            blockedNodes.push({ key, el });
            log('[DOM-SCAN] ğŸš« MÃ©trica BLOQUEADA encontrada:', key, '=', el.textContent.trim());
        }
    });
    
    log('[DOM-SCAN] âœ… Escaneamento completo:', {
        allowed: allowedNodes.length,
        blocked: blockedNodes.length
    });
    
    return { allowedNodes, blockedNodes };
}

/**
 * ğŸ”’ Aplica mÃ¡scaras visuais nas mÃ©tricas restritas
 * ATENÃ‡ÃƒO: Aplica blur SOMENTE nos valores numÃ©ricos, NUNCA nos labels
 * @param {Object} scanResult - { allowedNodes, blockedNodes }
 */
function applyReducedModeMasks(scanResult) {
    log('[MASK] ğŸ¨ Aplicando mÃ¡scaras visuais (valores apenas, labels preservados)...');
    
    const { allowedNodes, blockedNodes } = scanResult;
    let maskedCount = 0;
    
    // Log de mÃ©tricas permitidas
    allowedNodes.forEach(({ key }) => {
        log(`[ALLOWED] âœ… MÃ©trica permitida: ${key}`);
    });
    
    // Aplicar blur SOMENTE nos valores numÃ©ricos usando .metric-blur
    blockedNodes.forEach(({ key, el }) => {
        // Buscar spans/divs que contÃ©m valores (nÃºmeros, dB, LUFS, Hz, %, etc)
        const valueSelectors = [
            '.value',
            '.metric-value',
            'span[class*="value"]',
            'div[class*="value"]'
        ];
        
        let valueFound = false;
        
        for (const selector of valueSelectors) {
            const valueSpan = el.querySelector(selector);
            if (valueSpan && !valueSpan.classList.contains('metric-blur')) {
                // Aplicar classe de blur SOMENTE no valor
                valueSpan.classList.add('metric-blur');
                maskedCount++;
                valueFound = true;
                log(`[MASK] ğŸ”’ Blur aplicado no VALOR de: ${key} (selector: ${selector})`);
                break;
            }
        }
        
        // Se nÃ£o encontrar seletores especÃ­ficos, buscar elemento com texto numÃ©rico
        if (!valueFound) {
            const textContent = el.textContent.trim();
            // Verificar se contÃ©m nÃºmeros
            if (/\d+/.test(textContent)) {
                // Aplicar blur no elemento inteiro apenas se contiver nÃºmeros
                if (!el.classList.contains('metric-blur')) {
                    el.classList.add('metric-blur');
                    maskedCount++;
                    log(`[MASK] âš ï¸ Blur aplicado no elemento completo (contÃ©m nÃºmeros): ${key}`);
                }
            } else {
                log(`[MASK] â­ï¸ Ignorado (sem valores numÃ©ricos): ${key}`);
            }
        }
    });
    
    log(`[MASK] âœ… Total de ${maskedCount} mÃ©tricas mascaradas`);
}

/**
 * ğŸš« Oculta seÃ§Ãµes completas baseado em classes e padrÃµes
 */
function hideRestrictedSections() {
    log('[HIDE] ğŸš« Ocultando seÃ§Ãµes restritas...');
    
    // SeÃ§Ãµes que devem ser COMPLETAMENTE OCULTAS
    const sectionsToHide = [
        // SeÃ§Ãµes de diagnÃ³stico
        { selector: '[id*="diagnostic"]', name: 'Elementos de DiagnÃ³stico' },
        { selector: '.diagnostics-section', name: 'SeÃ§Ã£o de DiagnÃ³sticos' },
        
        // AnÃ¡lise espectral avanÃ§ada
        { selector: '[id*="spectral"]', name: 'Elementos Espectrais' },
        { selector: '.spectral-section', name: 'SeÃ§Ã£o Espectral' },
        { selector: '.advanced-spectrum-section', name: 'Espectro AvanÃ§ado' },
        
        // Problemas e anÃ¡lises avanÃ§adas
        { selector: '[id*="problem"]', name: 'Elementos de Problemas' },
        { selector: '.problems-section', name: 'SeÃ§Ã£o de Problemas' }
    ];
    
    let hiddenCount = 0;
    
    sectionsToHide.forEach(({ selector, name }) => {
        const elements = document.querySelectorAll(selector);
        if (elements.length > 0) {
            elements.forEach(el => {
                if (el && !el.classList.contains('plan-section-hidden')) {
                    el.classList.add('plan-section-hidden');
                    hiddenCount++;
                    log(`[HIDE] ğŸš« Ocultado: ${name} (${selector})`);
                }
            });
        }
    });
    
    log(`[HIDE] âœ… Total de ${hiddenCount} elementos ocultados`);
}

/**
 * ğŸ”’ Filtragem de sugestÃµes jÃ¡ aplicada no ai-suggestion-ui-controller.js
 * Esta funÃ§Ã£o foi removida pois a filtragem Ã© feita no momento da renderizaÃ§Ã£o
 */
function blurAISuggestionTexts() {
    log('[BLUR-AI] ğŸ”’ Aplicando blur em textos internos dos cards de IA...');
    
    // Selecionar todos os cards de sugestÃ£o IA
    const aiCards = document.querySelectorAll('.ai-suggestion-card');
    
    if (aiCards.length === 0) {
        log('[BLUR-AI] â­ï¸ Nenhum card de IA encontrado');
        return;
    }
    
    // Aplicar blur APENAS nos textos internos, mantendo estrutura e tÃ­tulos visÃ­veis
    aiCards.forEach((card, index) => {
        // Borrar conteÃºdos de texto dentro dos blocos, nÃ£o os tÃ­tulos
        const contentBlocks = card.querySelectorAll('.ai-block-content');
        
        contentBlocks.forEach(block => {
            if (!block.classList.contains('metric-blur')) {
                block.classList.add('metric-blur');
            }
        });
        
        log(`[BLUR-AI] âœ… Card ${index + 1}: ${contentBlocks.length} textos borrados`);
    });
    
    log(`[BLUR-AI] âœ… Total de ${aiCards.length} cards processados`);
}

/**
 * ğŸ¯ Aplica blur na tabela de comparaÃ§Ã£o (valores atual e alvo)
 * REGRA (D): Permitir APENAS LRA, DR, EstÃ©reo (BLOQUEAR frequÃªncias)
 * Blur: valores e targets de mÃ©tricas bloqueadas, labels ficam visÃ­veis
 */
function blurComparisonTableValues() {
    log('[BLUR-TABLE] ğŸ¨ Aplicando blur na tabela de comparaÃ§Ã£o...');
    
    // (D) TABELA COMPARAÃ‡ÃƒO: DR, EstÃ©reo, Low Mid, High Mid, PresenÃ§a permitidos
    // ğŸ”’ BLOQUEADAS: LUFS, True Peak, LRA, Sub, Bass, Mid, Brilho/Air
    const allowedTableMetrics = [
        'dr',
        'dynamicRange',
        'dynamic_range',
        'dinÃ¢mica',
        'stereo',
        'stereoCorrelation',
        'correlation',
        'estÃ©reo',
        'imagem estÃ©reo',
        'lowmid',
        'low mid',
        'low_mid',
        'highmid',
        'high mid',
        'high_mid',
        'presence',
        'presenÃ§a',
        'presenca'
    ];
    
    let blurredCount = 0;
    
    // Buscar todas as linhas da tabela de comparaÃ§Ã£o
    const comparisonTables = document.querySelectorAll('#referenceComparisons table, .genre-comparison-table, .comparison-table');
    
    comparisonTables.forEach(table => {
        const rows = table.querySelectorAll('tr');
        
        rows.forEach(row => {
            // Pegar o nome da mÃ©trica da primeira cÃ©lula (label)
            const firstCell = row.querySelector('td:first-child, th:first-child');
            if (!firstCell) return;
            
            const metricText = firstCell.textContent.toLowerCase().trim();
            const metricKey = row.getAttribute('data-metric-key');
            
            // Verificar se a mÃ©trica estÃ¡ na lista de permitidas
            const isAllowed = allowedTableMetrics.some(allowed => 
                metricText.includes(allowed.toLowerCase()) ||
                (metricKey && metricKey.toLowerCase().includes(allowed.toLowerCase()))
            );
            
            if (!isAllowed) {
                // Borrar valor atual e valor alvo SOMENTE (nÃ£o severidade, Ã­cones ou labels)
                const valueCells = row.querySelectorAll('.current-value, .target-value, td:nth-child(2), td:nth-child(3)');
                
                valueCells.forEach(cell => {
                    // NÃ£o borrar se for coluna de severidade ou aÃ§Ã£o
                    const cellText = cell.textContent.toLowerCase();
                    const isSeverityOrAction = cellText.includes('crÃ­tico') || 
                                              cellText.includes('atenÃ§Ã£o') || 
                                              cellText.includes('ok') ||
                                              cell.querySelector('.severity-badge') !== null ||
                                              cell.querySelector('[class*="icon"]') !== null;
                    
                    if (!isSeverityOrAction && !cell.classList.contains('metric-blur')) {
                        cell.classList.add('metric-blur');
                        blurredCount++;
                        log(`[BLUR-TABLE] ğŸ”’ Valor borrado: ${metricText}`);
                    }
                });
            } else {
                log(`[BLUR-TABLE] âœ… MÃ©trica permitida na tabela: ${metricText}`);
            }
        });
    });
    
    log(`[BLUR-TABLE] âœ… Total de ${blurredCount} valores na tabela borrados`);
}

/**
 * ğŸ“¢ Insere mensagem de upgrade no modal (compacta e dentro do container)
 */
function insertUpgradeNotice() {
    log('[UPGRADE] ğŸ“¢ Inserindo aviso de upgrade...');
    
    const modalContainer = document.getElementById('audioAnalysisResults');
    if (!modalContainer) {
        warn('[UPGRADE] âš ï¸ Container de resultados nÃ£o encontrado');
        return;
    }
    
    // Remover aviso anterior se existir
    const existingNotice = document.getElementById('reduced-mode-upgrade-notice');
    if (existingNotice) {
        existingNotice.remove();
    }
    
    // Criar novo aviso COMPACTO
    const notice = document.createElement('div');
    notice.id = 'reduced-mode-upgrade-notice';
    notice.className = 'upgrade-notice-compact';
    notice.innerHTML = `
        <div class="upgrade-notice-icon">ğŸ”’</div>
        <div class="upgrade-notice-content">
            <h4>AnÃ¡lises completas esgotadas</h4>
            <p>
                MÃ©tricas avanÃ§adas, sugestÃµes IA e diagnÃ³sticos disponÃ­veis no plano Plus.
            </p>
        </div>
        <button class="upgrade-notice-btn" onclick="window.location.href='/planos.html'">
            Ver planos
        </button>
    `;
    
    // Inserir no topo do container (DENTRO do modal, nÃ£o fora)
    modalContainer.insertBefore(notice, modalContainer.firstChild);
    
    log('[UPGRADE] âœ… Aviso de upgrade inserido');
}

/**
 * ğŸ¨ Injeta CSS dinÃ¢mico para mÃ¡scaras
 */
function injectReducedModeCSS() {
    // Verificar se CSS jÃ¡ foi injetado
    if (document.getElementById('reduced-mode-dynamic-css')) {
        return;
    }
    
    const style = document.createElement('style');
    style.id = 'reduced-mode-dynamic-css';
    style.textContent = `
        /* ğŸ”’ MÃ¡scara visual SOMENTE para valores numÃ©ricos - NUNCA para labels */
        .metric-blur {
            position: relative !important;
            filter: blur(7px) !important;
            opacity: 0.4 !important;
            pointer-events: none !important;
            user-select: none !important;
            user-select: none !important;
            display: inline-block !important;
        }
        
        /* Garantir que labels NUNCA sejam borrados */
        .metric-label,
        [class*="label"],
        [class*="name"],
        .metric-name {
            filter: none !important;
            opacity: 1 !important;
        }
        
        .metric-blur::after {
            content: "ğŸ”’" !important;
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-size: 11px !important;
            opacity: 0.8 !important;
            z-index: 10 !important;
        }
        
        /* SeÃ§Ãµes completamente ocultas */
        .plan-section-hidden {
            display: none !important;
        }
        
        /* ğŸ“¢ Aviso de upgrade ELEGANTE E COMPACTO */
        .upgrade-notice-compact {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            margin: 0 0 12px 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.12);
            animation: slideDown 0.3s ease-out;
            font-size: 0.9em;
        }
        
        .upgrade-notice-compact .upgrade-notice-icon {
            font-size: 1.5em;
            line-height: 1;
            flex-shrink: 0;
        }
        
        .upgrade-notice-compact .upgrade-notice-content {
            flex: 1;
        }
        
        .upgrade-notice-compact .upgrade-notice-content h4 {
            margin: 0 0 3px 0;
            font-size: 0.95em;
            font-weight: 700;
        }
        
        .upgrade-notice-compact .upgrade-notice-content p {
            margin: 0;
            font-size: 0.75em;
            line-height: 1.3;
            opacity: 0.9;
        }
        
        .upgrade-notice-compact .upgrade-notice-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 8px 16px;
            border-radius: 7px;
            font-size: 0.8em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            white-space: nowrap;
        }
        
        .upgrade-notice-compact .upgrade-notice-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .upgrade-notice-compact {
                flex-direction: column;
                text-align: center;
                padding: 12px 14px;
            }
            
            .upgrade-notice-compact .upgrade-notice-icon {
                font-size: 1.4em;
            }
            
            .upgrade-notice-compact .upgrade-notice-btn {
                width: 100%;
                padding: 10px 14px;
            }
        }
    `;
    
    document.head.appendChild(style);
    log('[CSS] âœ… CSS dinÃ¢mico injetado');
}

/**
 * ğŸ¯ FUNÃ‡ÃƒO PRINCIPAL: Renderiza modal em Modo Reduzido
 * @param {Object} analysis - Dados completos da anÃ¡lise
 */
function renderReducedModeAdvanced(analysis) {
    log('[REDUCED-MODE] ğŸ¯ Iniciando renderizaÃ§Ã£o avanÃ§ada do Modo Reduzido');
    log('[REDUCED-MODE] ğŸ“Š AnÃ¡lise recebida:', {
        hasData: !!analysis,
        keys: Object.keys(analysis || {}),
        analysisMode: analysis?.analysisMode,
        plan: analysis?.plan
    });
    
    try {
        // Injetar CSS uma Ãºnica vez
        injectReducedModeCSS();
        
        // Aguardar DOM estar pronto
        log('[REDUCED-MODE] â±ï¸ Aguardando renderizaÃ§Ã£o do DOM...');
        
        setTimeout(() => {
            try {
                // 1ï¸âƒ£ Escanear DOM e construir mapeamento
                const scanResult = buildMetricDomMap(analysis);
                
                // 2ï¸âƒ£ Aplicar mÃ¡scaras nas mÃ©tricas bloqueadas (SOMENTE nos valores)
                applyReducedModeMasks(scanResult);
                
                // 3ï¸âƒ£ Aplicar blur nos textos das sugestÃµes IA (mantÃ©m cards visÃ­veis)
                blurAISuggestionTexts();
                
                // 4ï¸âƒ£ Aplicar blur na tabela de comparaÃ§Ã£o (exceto mÃ©tricas permitidas)
                blurComparisonTableValues();
                
                // 5ï¸âƒ£ Ocultar seÃ§Ãµes restritas (NÃƒO inclui sugestÃµes)
                hideRestrictedSections();
                
                // 6ï¸âƒ£ Inserir aviso de upgrade
                insertUpgradeNotice();
                
                log('[REDUCED-MODE] âœ… Modo Reduzido renderizado com sucesso');
                log('[REDUCED-MODE] ğŸ“Š Resumo:', {
                    metricsAllowed: scanResult.allowedNodes.length,
                    metricsBlocked: scanResult.blockedNodes.length
                });
                
            } catch (innerError) {
                error('[REDUCED-MODE][ERROR] Erro no processo de mascaramento:', innerError);
                error('[REDUCED-MODE][ERROR] Stack:', innerError.stack);
            }
        }, 500); // Timeout para garantir que o DOM foi completamente renderizado
        
    } catch (error) {
        error('[REDUCED-MODE][ERROR] Erro ao inicializar modo reduzido:', error);
        error('[REDUCED-MODE][ERROR] Stack:', error.stack);
        
        // Em caso de erro, modal continua funcionando normalmente
        warn('[REDUCED-MODE] âš ï¸ Fallback: Modal renderizado sem mascaramento');
    }
}

// ========================================
// FIM DO SISTEMA DE MASCARAMENTO DINÃ‚MICO
// ========================================

// âœ… HELPER: Mascarar valor baseado em permissÃ£o do plano
function maskValue(value, isAllowed, options = {}) {
    const { placeholder = 'â€”', unit = '', decimalPlaces = null } = options;
    
    // Se nÃ£o permitido, retornar placeholder
    if (!isAllowed) {
        return placeholder;
    }
    
    // Se valor nÃ£o existe, retornar placeholder
    if (value === undefined || value === null) {
        return placeholder;
    }
    
    // Formatar valor se permitido
    if (decimalPlaces !== null && typeof value === 'number') {
        return `${value.toFixed(decimalPlaces)}${unit ? ' ' + unit : ''}`;
    }
    
    return `${value}${unit ? ' ' + unit : ''}`;
}

// âœ… HELPER SIMPLIFICADO: Aplicar classe de mÃ¡scara visual (apenas CSS)
function applyMaskClass(selector, isAllowed) {
    const element = document.querySelector(selector);
    if (!element) {
        warn(`[MASK] Elemento nÃ£o encontrado: ${selector}`);
        return;
    }
    
    if (!isAllowed) {
        // Adicionar classe de mÃ¡scara (blur + "Plano limitado" via CSS::after)
        element.classList.add('metric-masked');
    } else {
        // Remover mÃ¡scara se estava aplicada
        element.classList.remove('metric-masked');
    }
}

// âœ… HELPER: Ocultar/mostrar seÃ§Ã£o completamente
function toggleSectionVisibility(selector, isAllowed) {
    const element = document.querySelector(selector);
    if (!element) {
        warn(`[TOGGLE] Elemento nÃ£o encontrado: ${selector}`);
        return;
    }
    
    if (!isAllowed) {
        element.classList.add('plan-section-hidden');
    } else {
        element.classList.remove('plan-section-hidden');
    }
}

function renderReducedMode(data) {
    log('[PLAN-FILTER] ğŸ¯ Renderizando modo reduzido COM JSON COMPLETO:', data);
    log('[PLAN-FILTER] ğŸ“Š Campos recebidos:', Object.keys(data));
    
    // âœ… Obter features do plano (se disponÃ­veis no JSON)
    const planFeatures = data.planFeatures || {
        canSuggestions: false,
        canSpectralAdvanced: false,
        canAiHelp: false,
        canPdf: false
    };
    
    log('[PLAN-FILTER] ğŸ” Features do plano:', planFeatures);
    
    // Abrir modal de resultado
    const modal = document.getElementById('audioResultModal');
    const overlay = document.getElementById('audioModalOverlay');
    
    if (modal) {
        modal.style.display = 'block';
        modal.classList.add('show');
    }
    if (overlay) {
        overlay.style.display = 'block';
    }
    
    // Helper para atualizar campo de forma segura
    function updateField(selector, value) {
        const element = document.querySelector(selector);
        if (element) {
            element.textContent = value || 'â€”';
        }
    }
    
    // âœ… EXIBIR MÃ‰TRICAS PRINCIPAIS (SEMPRE VISÃVEIS) - TP, LUFS, DR, Score
    updateField('#audioScore', maskValue(data.score, true, { unit: '%' }));
    updateField('#audioLufs', maskValue(data.lufsIntegrated || data.lufs, true, { unit: 'LUFS', decimalPlaces: 1 }));
    updateField('#audioTruePeak', maskValue(data.truePeakDbtp || data.truePeak, true, { unit: 'dBTP', decimalPlaces: 2 }));
    updateField('#audioDynamicRange', maskValue(data.dynamicRange || data.dr, true, { unit: 'dB', decimalPlaces: 1 }));
    
    log('[PLAN-FILTER] âœ… MÃ©tricas principais renderizadas (sempre visÃ­veis)');
    
    // âœ… APLICAR MÃSCARAS NAS MÃ‰TRICAS AVANÃ‡ADAS (JSON completo preservado)
    const advancedMetrics = [
        { selector: '#audioHeadroom', value: data.headroom, unit: 'dB', decimals: 1 },
        { selector: '#audioLra', value: data.lra, unit: 'dB', decimals: 1 },
        { selector: '#audioStereoWidth', value: data.stereoWidth, unit: '', decimals: 2 },
        { selector: '#audioStereoCorrelation', value: data.stereoCorrelation, unit: '', decimals: 2 },
        { selector: '#audioPhaseCoherence', value: data.phaseCoherence, unit: '%', decimals: 0 },
        { selector: '#audioPeakToAverage', value: data.peakToAverage, unit: 'dB', decimals: 1 },
        { selector: '#audioCrestFactor', value: data.crestFactor, unit: 'dB', decimals: 1 }
    ];
    
    advancedMetrics.forEach(metric => {
        // Exibir valor REAL (nÃ£o placeholder) - mÃ¡scara visual Ã© aplicada via CSS
        const formattedValue = maskValue(metric.value, true, { 
            unit: metric.unit, 
            decimalPlaces: metric.decimals 
        });
        updateField(metric.selector, formattedValue);
        applyMaskClass(metric.selector, false); // Aplicar blur + overlay via CSS
    });
    
    log('[PLAN-FILTER] âœ… MÃ©tricas avanÃ§adas MASCARADAS (dados completos preservados)');
    
    // âœ… BANDAS ESPECTRAIS - Mascarar visualmente
    const spectralBands = [
        { selector: '#audioSubBass', key: 'sub_bass' },
        { selector: '#audioBass', key: 'bass' },
        { selector: '#audioLowMid', key: 'low_mid' },
        { selector: '#audioMid', key: 'mid' },
        { selector: '#audioHighMid', key: 'high_mid' },
        { selector: '#audioPresence', key: 'presence' },
        { selector: '#audioBrilliance', key: 'brilliance' },
        { selector: '#audioAir', key: 'air' }
    ];
    
    spectralBands.forEach(band => {
        const value = data.bands?.[band.key]?.db || data.spectralData?.[band.key]?.db;
        const formattedValue = maskValue(value, true, { 
            unit: 'dB', 
            decimalPlaces: 1 
        });
        updateField(band.selector, formattedValue);
        applyMaskClass(band.selector, planFeatures.canSpectralAdvanced);
    });
    
    log('[PLAN-FILTER] âœ… Bandas espectrais MASCARADAS');
    
    // âœ… OCULTAR SEÃ‡Ã•ES DE SUGESTÃ•ES/IA (se features nÃ£o permitem)
    const sectionsToHide = [
        { selector: '#suggestionsSection', allowed: planFeatures.canSuggestions },
        { selector: '#aiSuggestionsSection', allowed: planFeatures.canSuggestions },
        { selector: '#problemsSection', allowed: planFeatures.canSuggestions },
        { selector: '#diagnosticsSection', allowed: planFeatures.canSuggestions },
        { selector: '.ai-suggestion-card', allowed: planFeatures.canSuggestions },
        { selector: '.advanced-spectrum-section', allowed: planFeatures.canSpectralAdvanced }
    ];
    
    sectionsToHide.forEach(({ selector, allowed }) => {
        toggleSectionVisibility(selector, allowed);
    });
    
    log('[PLAN-FILTER] âœ… SeÃ§Ãµes de sugestÃµes/IA ocultadas conforme plano');
    
    // âœ… EXIBIR AVISO DE UPGRADE ATRAENTE
    const warningContainer = document.createElement('div');
    warningContainer.id = 'reducedModeWarning';
    warningContainer.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 24px;
        margin: 20px 0;
        border-radius: 16px;
        text-align: center;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.1);
    `;
    warningContainer.innerHTML = `
        <div style="font-size: 3em; margin-bottom: 10px;">ğŸ”’</div>
        <h3 style="margin: 0 0 12px 0; font-size: 1.4em; font-weight: 700;">Modo Reduzido Ativo</h3>
        <p style="margin: 12px 0; font-size: 1em; opacity: 0.95; line-height: 1.5;">
            ${data.limitWarning || 'VocÃª atingiu o limite de anÃ¡lises completas do seu plano atual.'}
        </p>
        <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; margin: 15px 0;">
            <p style="margin: 0; font-size: 0.9em; opacity: 0.9;">
                <strong>âœ… MÃ©tricas visÃ­veis:</strong> Score, True Peak, LUFS, Dynamic Range
            </p>
            <p style="margin: 8px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                <strong>ğŸ”’ Bloqueadas:</strong> MÃ©tricas avanÃ§adas, espectro, sugestÃµes IA
            </p>
        </div>
        <button id="upgradePlanBtn" style="
            background: white;
            color: #667eea;
            border: none;
            padding: 14px 36px;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 700;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            ğŸš€ Desbloquear AnÃ¡lise Completa
        </button>
    `;
    
    // Inserir aviso no inÃ­cio do modal
    const modalContent = document.querySelector('#audioResultModal .modal-content');
    if (modalContent) {
        // Remover aviso anterior se existir
        const oldWarning = document.getElementById('reducedModeWarning');
        if (oldWarning) {
            oldWarning.remove();
        }
        
        modalContent.insertBefore(warningContainer, modalContent.firstChild);
        log('[PLAN-FILTER] âœ… Aviso de upgrade exibido');
        
        // Adicionar evento de clique no botÃ£o de upgrade
        const upgradeBtn = document.getElementById('upgradePlanBtn');
        if (upgradeBtn) {
            upgradeBtn.addEventListener('click', () => {
                log('[PLAN-FILTER] ğŸš€ BotÃ£o de upgrade clicado');
                window.location.href = '/planos.html';
            });
        }
    }
    
    log('[PLAN-FILTER] âœ… Modo reduzido renderizado com JSON COMPLETO e mÃ¡scaras visuais');
}

// ğŸ“Š Mostrar resultados no modal
async function displayModalResults(analysis) {
    log('[DEBUG-DISPLAY] ğŸ§  InÃ­cio displayModalResults()');
    
    // ğŸ• HISTÃ“RICO PRO: Ponto Ãºnico de salvamento para anÃ¡lises de GÃŠNERO
    // (AnÃ¡lises de referÃªncia usam displayReferenceComparison)
    if (analysis && !analysis._fromHistory && analysis.technicalData) {
        const analysisMode = analysis.mode || analysis.analysisMode || 'genre';
        
        if (analysisMode === 'genre') {
            log('ğŸ• [HISTORY-SAVE] displayModalResults detectou anÃ¡lise de gÃªnero');
            
            // Salvar assÃ­ncrono (nÃ£o bloqueia UI)
            saveAnalysisToHistory(analysis).catch(err => {
                warn('ğŸ• [HISTORY-SAVE] Erro ao salvar (nÃ£o crÃ­tico):', err);
            });
        }
    }
    
    // âœ… VERIFICAÃ‡ÃƒO PRIORITÃRIA: Modo Reduzido (backend envia JSON completo, frontend aplica mÃ¡scara)
    const isReduced = analysis.analysisMode === 'reduced' || analysis.isReduced === true;
    
    if (isReduced) {
        log('[PLAN-FILTER] âš ï¸ MODO REDUZIDO DETECTADO - JSON completo recebido');
        log('[PLAN-FILTER] ğŸ“Š Campos do JSON:', Object.keys(analysis));
        log('[PLAN-FILTER] ğŸ¯ Usando sistema avanÃ§ado de mascaramento dinÃ¢mico...');
        
        // âœ… NÃƒO parar aqui! Continuar renderizaÃ§Ã£o normal
        // O sistema de mascaramento serÃ¡ aplicado APÃ“S o DOM ser renderizado
        
        // Armazenar flag global para aplicaÃ§Ã£o posterior
        window.__REDUCED_MODE_ACTIVE__ = true;
        window.__REDUCED_MODE_ANALYSIS__ = analysis;
    } else {
        window.__REDUCED_MODE_ACTIVE__ = false;
        window.__REDUCED_MODE_ANALYSIS__ = null;
    }
    
    log('[PLAN-FILTER] â„¹ï¸ Continuando renderizaÃ§Ã£o normal do modal...');
    
    // ğŸ”¥ FASE 2 - VALIDAÃ‡ÃƒO IMEDIATA: Verificar se genreTargets chegou atÃ© aqui
    console.group('[FASE2-VALIDATION] ğŸ¯ displayModalResults - ENTRADA');
    log('analysis.data.genreTargets:', analysis.data?.genreTargets ? 'âœ… PRESENTE' : 'âŒ AUSENTE');
    if (analysis.data?.genreTargets) {
        log('  â†’ Keys:', Object.keys(analysis.data.genreTargets));
        log('  â†’ Has bands:', !!analysis.data.genreTargets.bands);
        if (analysis.data.genreTargets.bands) {
            log('  â†’ Band keys:', Object.keys(analysis.data.genreTargets.bands));
        }
    }
    console.groupEnd();
    
    // ğŸ”¥ VALIDAÃ‡ÃƒO FINAL OBRIGATÃ“RIA: Verificar dados essenciais ANTES de exibir modal
    log("\n\nğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-FINAL-FRONT] VALIDAÃ‡ÃƒO COMPLETA ğŸ”¥ğŸ”¥ğŸ”¥");
    log("[AUDIT-FINAL-FRONT]", {
        hasTechnicalData: !!analysis.technicalData,
        techKeys: Object.keys(analysis.technicalData || {}),
        techKeyCount: Object.keys(analysis.technicalData || {}).length,
        hasGenreTargets: !!analysis.data?.genreTargets,
        gtKeys: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets) : null,
        gtKeyCount: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets).length : 0,
        hasScore: analysis.score !== undefined && analysis.score !== null,
        scoreValue: analysis.score,
        hasMetadata: !!analysis.metadata,
        metadataKeys: analysis.metadata ? Object.keys(analysis.metadata).length : 0,
        // Campos essenciais de technicalData
        essentialFields: {
            lufsIntegrated: analysis.technicalData?.lufsIntegrated,
            truePeakDbtp: analysis.technicalData?.truePeakDbtp,
            dynamicRange: analysis.technicalData?.dynamicRange,
            spectral_balance: analysis.technicalData?.spectral_balance ? Object.keys(analysis.technicalData.spectral_balance).length : 0,
            stereoCorrelation: analysis.technicalData?.stereoCorrelation,
            lra: analysis.technicalData?.lra
        },
        // Campos essenciais de genreTargets
        genreTargetsFields: analysis.data?.genreTargets ? {
            lufs: analysis.data.genreTargets.lufs,
            true_peak: analysis.data.genreTargets.true_peak,
            dr: analysis.data.genreTargets.dr,
            spectral_bands: analysis.data.genreTargets.spectral_bands ? Object.keys(analysis.data.genreTargets.spectral_bands).length : 0
        } : null
    });
    
    // âš ï¸ ALERTA se technicalData tiver menos de 10 campos
    if (analysis.technicalData && Object.keys(analysis.technicalData).length < 10) {
        error("[AUDIT-FINAL-FRONT] âŒ technicalData TEM POUCOS CAMPOS!");
        error("[AUDIT-FINAL-FRONT] Campos presentes:", Object.keys(analysis.technicalData));
        error("[AUDIT-FINAL-FRONT] MODAL PODE NÃƒO ABRIR CORRETAMENTE!");
    } else if (analysis.technicalData && Object.keys(analysis.technicalData).length >= 30) {
        log("[AUDIT-FINAL-FRONT] âœ… technicalData COMPLETO com", Object.keys(analysis.technicalData).length, "campos");
    }
    
    if (!analysis.data?.genreTargets) {
        // ğŸ” IDENTIFICAR O MODO DE ANÃLISE
        const mode = analysis.mode || window.currentAnalysisMode || 'single';
        
        // ğŸš« REFERENCE MODE: NÃ£o exige genreTargets - usa buildComparisonRows
        if (mode === 'reference') {
            log('[REFERENCE-MODE] âœ… Modo referÃªncia - genreTargets NÃƒO necessÃ¡rio');
            log('[REFERENCE-MODE] Tabela A vs B serÃ¡ construÃ­da via buildComparisonRows()');
            // Skip validaÃ§Ã£o - reference mode nÃ£o usa genreTargets
        } else {
            // âŒ GENRE MODE: genreTargets Ã© obrigatÃ³rio
            error("[GENRE-MODE] âŒ genreTargets AUSENTE!");
            error("[GENRE-MODE] Tabelas de comparaÃ§Ã£o NÃƒO vÃ£o funcionar!");
            
            // ğŸ©¹ PATCH CRÃTICO: Tentar reconstruir genreTargets do estado global (APENAS GENRE)
            if (mode === 'genre') {
                const genre = analysis.data?.genre || analysis.genre || window.__CURRENT_SELECTED_GENRE || window.__CURRENT_GENRE;
                const activeRef = window.__activeRefData || 
                                 (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) || 
                                 null;
                
                if (activeRef) {
                    const reconstructedTargets = activeRef.bands || 
                                               activeRef.spectralBands || 
                                               activeRef.spectral_bands ||
                                               (activeRef.targets && (activeRef.targets.bands || activeRef.targets.spectral_bands)) || 
                                               null;
                    
                    if (reconstructedTargets) {
                        log('[GENRE-FLOW-PATCH] âœ… genreTargets reconstruÃ­do do estado global:', {
                            genre,
                            keys: Object.keys(reconstructedTargets),
                            source: 'window.__activeRefData'
                        });
                        
                        // Garantir que analysis.data exista e persistir genreTargets
                        analysis.data = analysis.data || {};
                        analysis.data.genreTargets = reconstructedTargets;
                        
                        log("[GENRE-FLOW-PATCH] âœ… analysis.data.genreTargets restaurado com sucesso");
                    }
                }
            }
        }
    } else {
        log("[AUDIT-FINAL-FRONT] âœ… genreTargets presente com", Object.keys(analysis.data.genreTargets).length, "campos");
    }
    
    log("ğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-FINAL-FRONT] FIM DA VALIDAÃ‡ÃƒO ğŸ”¥ğŸ”¥ğŸ”¥\n\n");
    
    // ğŸ”¥ AUDITORIA CRÃTICA: Verificar technicalData DENTRO de displayModalResults
    log('\n\nğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-TECHNICAL-DATA] DISPLAY ENTRY ğŸ”¥ğŸ”¥ğŸ”¥');
    log('[AUDIT-TECHNICAL-DATA] analysis.technicalData:', {
      exists: !!analysis?.technicalData,
      type: typeof analysis?.technicalData,
      isEmpty: analysis?.technicalData && Object.keys(analysis.technicalData).length === 0,
      keys: analysis?.technicalData ? Object.keys(analysis.technicalData) : [],
      hasSampleFields: {
        lufsIntegrated: analysis?.technicalData?.lufsIntegrated,
        truePeakDbtp: analysis?.technicalData?.truePeakDbtp,
        dynamicRange: analysis?.technicalData?.dynamicRange,
        spectral_balance: !!analysis?.technicalData?.spectral_balance
      }
    });
    log('[AUDIT-TECHNICAL-DATA] analysis outros campos:', {
      hasScore: analysis?.score !== undefined,
      scoreValue: analysis?.score,
      hasClassification: !!analysis?.classification,
      hasData: !!analysis?.data,
      hasDataGenreTargets: !!analysis?.data?.genreTargets,
      jobId: analysis?.jobId,
      mode: analysis?.mode
    });
    log('ğŸ”¥ğŸ”¥ğŸ”¥ [AUDIT-TECHNICAL-DATA] END ğŸ”¥ğŸ”¥ğŸ”¥\n\n');
    
    // ğŸš¨ LOG DIAGNÃ“STICO: GÃªnero ANTES de exibir modal
    log('[GENRE-BEFORE-DISPLAY] ğŸµ Estado do gÃªnero:', {
        preservedGenre: window.__CURRENT_SELECTED_GENRE,
        analysisGenre: analysis?.genre,
        mode: window.__CURRENT_MODE__ || currentAnalysisMode,
        timestamp: new Date().toISOString()
    });

    // ========================================
    // âœ… CORREÃ‡ÃƒO 2: RESTAURAÃ‡ÃƒO DE DADOS DE REFERÃŠNCIA
    // ========================================
    // Verifica se dados de referÃªncia foram perdidos e restaura do cache
    
    // ğŸ¯ CORREÃ‡ÃƒO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
    console.group('ğŸ” [AUDIT-LOCALSTORAGE] displayModalResults - Leitura de referenceJobId');
    log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    log('   - Antes: window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    log('   - Mode:', currentAnalysisMode);
    
    // ğŸ¯ USA FUNÃ‡ÃƒO SEGURA ao invÃ©s de acesso direto
    const referenceJobId = getCorrectJobId('reference'); // Primeira mÃºsica
    
    log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
    console.trace('   - Stack trace:');
    console.groupEnd();
    
    if (referenceJobId && currentAnalysisMode === 'reference') {
        // Verificar se dados de referÃªncia estÃ£o ausentes
        const hasReferenceData = window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__;
        const hasFirstAnalysisStore = FirstAnalysisStore.has();
        
        if (!hasReferenceData && !hasFirstAnalysisStore) {
            warn('[RESTORE] âš ï¸ Dados de referÃªncia ausentes - tentando restaurar do cache');
            log('[RESTORE] referenceJobId:', referenceJobId);
            
            // Tentar restaurar do AnalysisCache
            if (window.AnalysisCache && window.AnalysisCache.has(referenceJobId)) {
                const cachedReference = window.AnalysisCache.get(referenceJobId);
                
                if (cachedReference) {
                    log('[RESTORE] âœ… ReferÃªncia encontrada no AnalysisCache');
                    
                    // Clone profundo para evitar contaminaÃ§Ã£o
                    const restoredReference = (typeof structuredClone === 'function')
                        ? structuredClone(cachedReference)
                        : JSON.parse(JSON.stringify(cachedReference));
                    
                    // Restaurar para FirstAnalysisStore
                    if (FirstAnalysisStore && typeof FirstAnalysisStore.set === 'function') {
                        FirstAnalysisStore.set(restoredReference);
                        log('[RESTORE] âœ… ReferÃªncia restaurada no FirstAnalysisStore');
                    }
                    
                    // Restaurar window.referenceAnalysisData
                    window.referenceAnalysisData = restoredReference;
                    window.__FIRST_ANALYSIS_FROZEN__ = Object.freeze(restoredReference);
                    
                    log('[RESTORE] âœ… Dados de referÃªncia completamente restaurados:', {
                        jobId: restoredReference.jobId,
                        fileName: restoredReference.metadata?.fileName || restoredReference.fileName
                    });
                } else {
                    error('[RESTORE] âŒ ReferÃªncia no cache estÃ¡ vazia');
                }
            } else {
                error('[RESTORE] âŒ ReferÃªncia nÃ£o encontrada no AnalysisCache');
                error('[RESTORE] Cache IDs disponÃ­veis:', window.AnalysisCache?.ids?.() || 'N/A');
            }
        } else {
            log('[RESTORE] âœ… Dados de referÃªncia jÃ¡ existem - restauraÃ§Ã£o nÃ£o necessÃ¡ria');
        }
    }

    // ========================================
    // âœ… PROTEÃ‡ÃƒO DEFINITIVA CONTRA ERRO DE INTERFACE
    // ========================================
    // Espera o mÃ³dulo aiUIController inicializar antes de renderizar
    let tries = 0;
    const MAX_TRIES = 30;
    const WAIT_MS = 150;

    while (
        (!window.aiUIController ||
         typeof window.aiUIController.renderMetricCards !== 'function' ||
         typeof window.aiUIController.renderScoreSection !== 'function') &&
        tries < MAX_TRIES
    ) {
        await new Promise(r => setTimeout(r, WAIT_MS));
        tries++;
        if (tries % 5 === 0) {
            warn(`[WAIT] aguardando aiUIController carregar... tentativa ${tries}`);
        }
    }

    // Falha definitiva â€” controller nunca carregou
    if (
        !window.aiUIController ||
        typeof window.aiUIController.renderMetricCards !== 'function'
    ) {
        error('[FATAL] aiUIController nÃ£o carregado apÃ³s todas as tentativas');
        alert('Erro ao carregar interface de resultados. Recarregue a pÃ¡gina.');
        return;
    }

    log('[SAFE] âœ… aiUIController detectado, renderizaÃ§Ã£o liberada.');

    // ğŸ” FLAG DE DEBUG PARA MÃ‰TRICAS PRINCIPAIS
    const DEBUG_MAIN_METRICS = true;
    const DEBUG_LABEL_AUDIT = true; // ğŸš¨ AUDITORIA DE LABELS
    let RENDER_ID = Date.now();

    // ========================================
    // âœ… CORREÃ‡ÃƒO 2: AB SAFETY - HidrataÃ§Ã£o e ForÃ§ar Modo Reference
    // ========================================
    const abState = ensureReferenceHydrated();
    const _modeNow = window.currentAnalysisMode || window.__soundyState?.render?.mode;

    // Se Ã© segunda faixa e temos refId vÃ¡lido, o modo Ã© obrigatoriamente 'reference'
    const isSecondTrack = !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has?.());
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO CRÃTICA: SÃ³ forÃ§ar modo reference se usuÃ¡rio selecionou explicitamente OU hÃ¡ contexto ativo
    if (isSecondTrack && _modeNow !== 'reference') {
        const hasContextDisplay = hasActiveReferenceContext();
        const allowDisplayReference = userExplicitlySelectedReferenceMode || hasContextDisplay;
        
        log('[REF-GUARD] displayModalResults isSecondTrack:', {
            userExplicit: userExplicitlySelectedReferenceMode,
            hasContext: hasContextDisplay,
            allowed: allowDisplayReference
        });
        
        if (!allowDisplayReference) {
            error('%c[PROTECTION] âŒ BLOQUEIO em displayModalResults: isSecondTrack detectado mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
            error('[PROTECTION] âŒ Sistema em modo genre - NÃƒO pode forÃ§ar modo reference');
            error('[PROTECTION] âŒ Abortando renderizaÃ§Ã£o A/B');
            console.trace('[PROTECTION] Stack trace do bloqueio:');
            // NÃƒO forÃ§ar modo reference - abortar
            return;
        }
        
        window.currentAnalysisMode = 'reference';
        if (window.__soundyState?.render) window.__soundyState.render.mode = 'reference';
        warn('[AB-FORCE] ForÃ§ando mode=reference porque hÃ¡ segunda faixa + referenceId.');
        log('%c[PROTECTION] âœ… Modo forÃ§ado para reference em displayModalResults - flag verificada', 'color:#00FF88;font-weight:bold;');
    }

    // Validar referÃªncia e tentar hidrataÃ§Ã£o se necessÃ¡rio
    if (isSecondTrack && (!abState.ok || !window.referenceAnalysisData?.bands)) {
        warn('[AB-BLOCK] ReferÃªncia inicial nÃ£o hidratada - tentando recuperar...');
        
        // ğŸ¯ TENTATIVA DE HIDRATAÃ‡ÃƒO: Recuperar de FirstAnalysisStore
        const refFromStore = FirstAnalysisStore?.getRef?.();
        
        // ğŸ” LOGS DIAGNÃ“STICOS
        log('[REF-FIX] ğŸ“¦ Verificando store:', {
            hasRefInStore: !!refFromStore,
            refKeys: refFromStore ? Object.keys(refFromStore) : null,
            refJobId: refFromStore?.jobId,
            hasMetrics: !!refFromStore?.metrics,
            hasTechnicalData: !!refFromStore?.technicalData
        });
        
        // ğŸ” NOVA VALIDAÃ‡ÃƒO: Verificar mÃ©tricas A/B ao invÃ©s de bands
        const refMetrics = extractABMetrics(refFromStore);
        log('[REF-FIX] ğŸ” ExtraÃ§Ã£o de mÃ©tricas:', {
            ok: refMetrics.ok,
            debugShape: refMetrics.debugShape
        });
        log('[AB-DATA] refFromStore keys:', refFromStore ? Object.keys(refFromStore) : null);
        log('[AB-DATA] ref metrics extraction:', refMetrics);
        
        if (refMetrics.ok) {
            log('[AB-HYDRATE] âœ… Recuperado de FirstAnalysisStore:', {
                jobId: refFromStore.jobId,
                fileName: refFromStore.fileName || refFromStore.metadata?.fileName,
                hasMetrics: refMetrics.ok,
                debugShape: refMetrics.debugShape
            });
            
            // Hidratar window.referenceAnalysisData
            window.referenceAnalysisData = {
                ...refFromStore,
                jobId: refFromStore.jobId,
                bands: refFromStore.bands || extractBands(refFromStore),
                metrics: refMetrics.metrics,
                technicalData: refMetrics.technicalData
            };
            
            // Atualizar abState
            abState.ok = true;
            abState.hasBands = true;
            
            log('[AB-HYDRATE] âœ… window.referenceAnalysisData hidratado com sucesso');
        } else {
            // âŒ DIAGNÃ“STICO DETALHADO antes de mostrar fallback
            error('[REF-FIX] âŒ HidrataÃ§Ã£o falhou - DIAGNÃ“STICO:');
            error('[REF-FIX]   1. FirstAnalysisStore.getRef() retornou:', refFromStore ? 'objeto' : 'null/undefined');
            error('[REF-FIX]   2. refFromStore.jobId:', refFromStore?.jobId);
            error('[REF-FIX]   3. refFromStore.technicalData existe?', !!refFromStore?.technicalData);
            error('[REF-FIX]   4. refFromStore.metrics existe?', !!refFromStore?.metrics);
            error('[REF-FIX]   5. extractABMetrics debugShape:', refMetrics.debugShape);
            error('[REF-FIX]   6. window.__REFERENCE_JOB_ID__:', getReferenceJobId());
            error('[REF-FIX]   7. Chaves disponÃ­veis:', refFromStore ? Object.keys(refFromStore) : 'N/A');
            error('[AB-BLOCK] abState:', abState);
            error('[AB-BLOCK] FirstAnalysisStore.getRef():', refFromStore);
            error('[AB-DATA] ref metrics extraction failed:', refMetrics.debugShape);
            
            // Renderizar fallback com diagnÃ³stico preciso
            const container = ensureReferenceContainer();
            if (container) {
                const diagnosticDetails = refFromStore 
                    ? `jobId: ${refFromStore.jobId || 'ausente'}, metrics: ${!!refFromStore.metrics ? 'presente' : 'ausente'}, technicalData: ${!!refFromStore.technicalData ? 'presente' : 'ausente'}`
                    : 'Store completamente vazio';
                
                container.innerHTML = `
                    <div class="card" style="margin-top: 20px; background: #2a1a1a; border: 2px solid #ff4444;">
                        <div class="card-title" style="color: #ff6666;">âš ï¸ ComparaÃ§Ã£o A/B IndisponÃ­vel</div>
                        <div style="padding: 15px; color: #ffaaaa; line-height: 1.6;">
                            <p><strong>Motivo:</strong> NÃ£o foi possÃ­vel recuperar mÃ©tricas da primeira mÃºsica.</p>
                            <p><strong>DiagnÃ³stico:</strong> ${diagnosticDetails}</p>
                            <p><strong>SoluÃ§Ã£o:</strong> Selecione novamente o modo "AnÃ¡lise de ReferÃªncia A/B" e faÃ§a upload das duas mÃºsicas.</p>
                        </div>
                    </div>
                `;
                container.style.display = 'block';
                log('[AB-FALLBACK] âœ… Mensagem de erro renderizada no DOM');
            }
            
            // NÃƒO abortar completamente - continuar renderizando cards da 2Âª mÃºsica
        }
    } else if (isSecondTrack) {
        log('[AB-SAFETY] âœ… ReferÃªncia validada:', {
            ok: abState.ok,
            refId: abState.refId,
            hasBands: abState.hasBands,
            file: abState.file
        });
    }

    // =========================================================================
    // ğŸ†” INFO: Sistema agora usa Virtual IDs (VID) para separaÃ§Ã£o por papel
    // =========================================================================
    // Mesmo que jobIds sejam iguais, Virtual IDs (jobId::USER e jobId::REF) mantÃªm separaÃ§Ã£o
    // O bloqueio de self-compare agora Ã© feito por conteÃºdo em renderReferenceComparisons
    log('[VID-INFO] âœ… Sistema usa Virtual IDs - jobId reutilizado nÃ£o causa self-compare', {
        currentJobId: analysis?.jobId,
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        storeHasUser: !!FirstAnalysisStore.getUser(),
        storeHasRef: !!FirstAnalysisStore.getRef()
    });
    
    // âœ… HARD-GUARD: Validar FirstAnalysisStore - se vazio, Ã© modo genre (nÃ£o reference)
    if (!FirstAnalysisStore.has()) {
        log('[INFO] FirstAnalysisStore vazio - modo genre (nÃ£o reference). Continuando render normalmente.');
        // âœ… NÃƒO RETORNA AQUI! Modo genre nÃ£o precisa de primeira anÃ¡lise
    } else {
        log('[HARD-GUARD] âœ… FirstAnalysisStore validado - primeira anÃ¡lise protegida:', {
            jobId: FirstAnalysisStore.get()?.jobId,
            fileName: FirstAnalysisStore.get()?.metadata?.fileName
        });
    }
    
    // =========================================================================
    // ï¿½ğŸš¨ DEBUG CRÃTICO: Timing e Estado dos Dados (detecta chamada prematura)
    // =========================================================================
    console.groupCollapsed("[DEBUG-DISPLAY] ğŸ§  InÃ­cio displayModalResults()");
    log("ğŸ“¦ analysis.metadata.fileName:", analysis?.metadata?.fileName);
    log("ğŸ§Š FirstAnalysisStore:", FirstAnalysisStore.has() ? FirstAnalysisStore.get()?.metadata?.fileName : 'null');
    log("ğŸ“Š analysis.metrics:", !!analysis?.metrics, "technicalData:", !!analysis?.technicalData);
    const storedFirstForDebug = FirstAnalysisStore.get();
    log("ğŸ“Š first.metrics:", !!storedFirstForDebug?.metrics, "technicalData:", !!storedFirstForDebug?.technicalData);
    console.groupEnd();
    
    // =========================================================================
    // ğŸš¨ AUDITORIA COMPLETA EM TEMPO DE EXECUÃ‡ÃƒO - DESCOBRIR POR QUE NÃƒO RENDERIZA
    // =========================================================================
    try {
        console.groupCollapsed('[AUDITORIA_REFERENCE_MODE] ğŸ” INVESTIGAÃ‡ÃƒO COMPLETA');
        log('[STEP 1] ğŸ” Modo recebido:', analysis?.mode);
        log('[STEP 2] ğŸ” ContÃ©m metrics?', !!analysis?.metrics);
        log('[STEP 3] ğŸ” ContÃ©m technicalData?', !!analysis?.technicalData);
        log('[STEP 4] ğŸ” ContÃ©m suggestions?', !!analysis?.suggestions);
        log('[STEP 5] ğŸ” FunÃ§Ãµes disponÃ­veis:', {
            renderMetricCards: typeof window.renderMetricCards,
            renderScoreSection: typeof window.renderScoreSection,
            renderSuggestions: typeof window.renderSuggestions,
            renderFinalScoreAtTop: typeof window.renderFinalScoreAtTop,
            renderAdvancedMetrics: typeof window.renderAdvancedMetrics,
        });
        log('[STEP 6] ğŸ” analysis (safe):', safeStringify(analysis || {}));
        console.groupEnd();
    } catch (e) {
        warn('[AUDITORIA_REFERENCE_MODE] âš ï¸ Falha ao logar analysis:', e.message);
    }
    
    // ğŸ” AUDITORIA: Estado AO ENTRAR em displayModalResults
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸš€ displayModalResults - ENTRADA');
    log('âš™ï¸ FunÃ§Ã£o: displayModalResults');
    log('ğŸ“Š analysis (parÃ¢metro recebido):', {
        jobId: analysis?.jobId,
        fileName: analysis?.metadata?.fileName || analysis?.fileName,
        lufs: analysis?.technicalData?.lufsIntegrated,
        mode: analysis?.mode,
        objectId: analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis
    });
    log('ğŸ§ analysis.userAnalysis:', analysis?.userAnalysis ? {
        fileName: analysis.userAnalysis?.metadata?.fileName || analysis.userAnalysis?.fileName,
        jobId: analysis.userAnalysis?.jobId,
        lufs: analysis.userAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.userAnalysis
    } : 'null');
    log('ğŸ§ analysis.referenceAnalysis:', analysis?.referenceAnalysis ? {
        fileName: analysis.referenceAnalysis?.metadata?.fileName || analysis.referenceAnalysis?.fileName,
        jobId: analysis.referenceAnalysis?.jobId,
        lufs: analysis.referenceAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.referenceAnalysis
    } : 'null');
    log('ğŸŒ Estado global atual:');
    const storedFirstForAudit = FirstAnalysisStore.get();
    log('  FirstAnalysisStore:', storedFirstForAudit ? {
        fileName: storedFirstForAudit.metadata?.fileName,
        jobId: storedFirstForAudit.jobId,
        lufs: storedFirstForAudit.technicalData?.lufsIntegrated
    } : 'null');
    log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
        fileName: window.__soundyState.previousAnalysis?.metadata?.fileName || window.__soundyState.previousAnalysis?.fileName,
        jobId: window.__soundyState.previousAnalysis?.jobId
    } : 'null');
    log('âš ï¸ VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
    log('  analysis.userAnalysis === analysis.referenceAnalysis?', analysis?.userAnalysis === analysis?.referenceAnalysis);
    console.groupEnd();
    
    // ğŸ¯ LOG INICIAL PARA CONFIRMAR CHAMADA DA FUNÃ‡ÃƒO APÃ“S CORREÃ‡Ã•ES
    log("âœ… [DISPLAY_MODAL] FunÃ§Ã£o displayModalResults chamada com dados:", analysis);
    log("âœ… [DISPLAY_MODAL] Estrutura dos dados recebidos:", Object.keys(analysis || {}));
    
    // ğŸ”’ PROTEÃ‡ÃƒO MODO REFERENCE: Evitar sobrescrita por interceptores
    if (analysis && analysis.mode === "reference") {
        const previous = window.__soundyState?.previousAnalysis;
        const user = analysis.userAnalysis || previous;
        const ref = analysis.referenceAnalysis || 
                    window.__soundyState?.referenceAnalysis || 
                    window.__soundyState?.reference?.referenceAnalysis || 
                    null;

        log("[REFERENCE-FLOW âœ…] ComparaÃ§Ã£o direta A/B antes da renderizaÃ§Ã£o:", {
            userTrack: user?.fileName || user?.metadata?.fileName,
            referenceTrack: ref?.fileName || ref?.metadata?.fileName,
            hasUserBands: !!(user?.technicalData?.spectral_balance || user?.bands),
            hasRefBands: !!(ref?.technicalData?.spectral_balance || ref?.bands),
        });

        // ğŸ”’ ProteÃ§Ã£o contra sobrescrita por interceptores
        if (user) Object.freeze(user);
        if (ref) Object.freeze(ref);

        const payload = {
            mode: "reference",
            userAnalysis: user,
            referenceAnalysis: ref,
        };

        // ==== PATCH 3: DEFINITIVO - FirstAnalysisStore + refHardGuards ====
        const first = FirstAnalysisStore.get();
        
        if (!first) {
            error('[A/B] âŒ Primeira anÃ¡lise nÃ£o encontrada no FirstAnalysisStore');
            warn('[A/B] âš ï¸ Renderizando apenas segunda anÃ¡lise como single');
            
            // Renderiza apenas a segunda como single (fallback seguro)
            if (typeof window.aiUIController !== 'undefined') {
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            return; // nÃ£o prossegue sem primeira anÃ¡lise
        }

        // âœ… MONTAGEM A/B COM ISOLAMENTO COMPLETO
        let userFull = first; // 1Âª faixa (jÃ¡ Ã© clone do FirstAnalysisStore.get())
        let refFull = (typeof structuredClone === 'function')
            ? structuredClone(analysis)
            : JSON.parse(JSON.stringify(analysis)); // 2Âª faixa (clone explÃ­cito)

        // ï¿½ï¸ APLICAR GUARDS: Isola jobIds se forem iguais
        ({ userFull, refFull } = refHardGuards({ userFull, refFull }));

        // ğŸ”¬ GERAR SUGESTÃ•ES COMPARATIVAS A vs B (se ainda nÃ£o existirem)
        const hasExistingSuggestions = Array.isArray(userFull?.aiSuggestions) && userFull.aiSuggestions.length > 0;
        
        if (!hasExistingSuggestions) {
            log('[A/B-FLOW] ğŸ”¬ Gerando sugestÃµes comparativas A vs B...');
            const comparativeSuggestions = buildComparativeAISuggestions(userFull, refFull);
            
            if (comparativeSuggestions.length > 0) {
                // Injetar sugestÃµes comparativas no userFull
                userFull.aiSuggestions = comparativeSuggestions;
                userFull.hasEnriched = true;
                userFull.mode = "compare";
                
                // ğŸ¯ CORREÃ‡ÃƒO: Popular PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA para Enhanced Suggestion Engine
                // Isso permite que o engine tambÃ©m processe bandas espectrais no modo reference
                const referenceComparisonData = comparativeSuggestions
                    .filter(s => s.referenceMode === true || s.type === 'band_adjust')
                    .map(s => ({
                        metric: s.subtype || s.metric,
                        name: s.categoria,
                        category: 'spectral_bands',
                        value: s.parametros?.valorAtual,
                        ideal: s.parametros?.valorReferencia,
                        delta: s.parametros?.diferenca,
                        tolerance: s.technical?.tolerance || 1.5,
                        severity: s.severidade
                    }));
                
                if (referenceComparisonData.length > 0) {
                    window.PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA = referenceComparisonData;
                    log('[A/B-FLOW] ğŸ¯ PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA populado:', {
                        total: referenceComparisonData.length,
                        bands: referenceComparisonData.map(r => r.metric).join(', ')
                    });
                }
                
                log('[A/B-FLOW] âœ… SugestÃµes comparativas injetadas:', {
                    quantidade: comparativeSuggestions.length,
                    metricas: comparativeSuggestions.filter(s => !s.referenceMode).length,
                    bandas: comparativeSuggestions.filter(s => s.referenceMode === true).length,
                    categorias: comparativeSuggestions.map(s => s.categoria).join(', ')
                });
            } else {
                warn('[A/B-FLOW] âš ï¸ Nenhuma sugestÃ£o comparativa gerada - mÃ©tricas insuficientes');
            }
        } else {
            log('[A/B-FLOW] â„¹ï¸ SugestÃµes jÃ¡ existem - pulando geraÃ§Ã£o comparativa');
        }

        // âœ… RENDER COMPLETO (nunca aborta por contaminaÃ§Ã£o - trabalha direto nos objetos)
        if (typeof window.aiUIController !== 'undefined') {
            window.aiUIController.renderMetricCards({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderScoreSection({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderSuggestions({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderFinalScoreAtTop({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.checkForAISuggestions({ mode: 'reference', user: userFull, reference: refFull });
        }

        log('[A/B-END] âœ…', {
            userFile: userFull?.fileName || userFull?.metadata?.fileName,
            refFile: refFull?.fileName || refFull?.metadata?.fileName,
            userId: userFull?.jobId || userFull?.id,
            refId: refFull?.jobId || refFull?.id
        });
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA DA AUDITORIA (linha 4502)
        // REMOVIDO return prematuro que bloqueava:
        // - NormalizaÃ§Ã£o de dados (linha 4822)
        // - CÃ¡lculo de scores (linha 4889)
        // - RenderizaÃ§Ã£o de cards (linha 6623)
        // - renderFinalScoreAtTop() (linha 6620)
        // - advancedMetricsCard() (linha 6636)
        // âŒ return; â† REMOVIDO
        
        log('[AUDIT-CORRECTION] âœ… Fluxo continuarÃ¡ para renderizar cards, scores e sugestÃµes');
        log('[AUDIT-CORRECTION] âœ… Return prematuro removido - pipeline completo ativado');
    } else if (analysis && analysis.mode === "genre") {
        // ğŸ¯ PATCH 1: MODO GÃŠNERO COM TARGETS
        log('[GENRE-FLOW] ğŸ¯ Renderizando modo gÃªnero com targets');
        
        // ğŸ¯ ESTRATÃ‰GIA: Obter targets COMPLETOS de PROD_AI_REF_DATA, depois aplicar streaming override
        const genre = analysis.genre || analysis.data?.genre;
        let genreTargets = null;
        
        // ğŸ¯ PRIORIDADE 1: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
        if (genre && window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
            genreTargets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
            log('[GENRE-FLOW] ğŸ“¦ Targets BASE obtidos de PROD_AI_REF_DATA[genre]');
        }
        
        // ğŸ¯ FALLBACK: analysis.data.genreTargets
        if (!genreTargets && analysis.data?.genreTargets) {
            genreTargets = JSON.parse(JSON.stringify(analysis.data.genreTargets));
            log('[GENRE-FLOW] ğŸ“¦ Targets obtidos de analysis.data.genreTargets (fallback)');
        }
        
        // ğŸ“¡ STREAMING MODE: Aplicar override de LUFS e TP (mantÃ©m DR, LRA, Stereo, Bandas)
        if (getSoundDestinationMode() === 'streaming' && genreTargets) {
            log('[GENRE-FLOW] ğŸ“¡ STREAMING MODE DETECTADO - Aplicando override de LUFS/TP');
            genreTargets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
            genreTargets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
            log('[GENRE-FLOW] ğŸ“¡ Targets atualizados para streaming:', {
                lufs_target: genreTargets.lufs_target,
                true_peak_target: genreTargets.true_peak_target
            });
        }
        
        if (!genreTargets) {
            warn('[GENRE-FLOW] âš ï¸ genreTargets nÃ£o encontrado em analysis.data!');
            warn('[GENRE-FLOW]    analysis.data:', analysis.data);
            warn('[GENRE-FLOW]    analysis.genreTargets:', analysis.genreTargets);
            
            // ğŸ©¹ PATCH: NÃƒO dar return - continuar com degradÃª
            warn('[GENRE-FLOW] âš ï¸ Modo DEGRADÃŠ: Renderizando sem tabela de comparaÃ§Ã£o');
            warn('[GENRE-FLOW] âœ… Score, mÃ©tricas e sugestÃµes serÃ£o exibidos normalmente');
            
            // Renderizar em modo single (sem targets)
            if (typeof window.aiUIController !== 'undefined') {
                log('[GENRE-FLOW] ğŸ¯ Renderizando em modo single (degradÃª)');
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            
            // âŒ NÃƒO dar return - deixar modal abrir normalmente
            // return; â† REMOVIDO
        } else {
            log('[GENRE-FLOW] âœ… genreTargets encontrado:', {
                lufs_target: genreTargets.lufs_target,
                true_peak_target: genreTargets.true_peak_target,
                dr_target: genreTargets.dr_target,
                spectralBands: genreTargets.spectralBands ? Object.keys(genreTargets.spectralBands) : null
            });
        
        // âœ… Renderizar tabela de comparaÃ§Ã£o com targets
        renderGenreComparisonTable({
            analysis,
            genre: analysis.genre || analysis.data.genre,
            targets: genreTargets
        });
        
        // âœ… Renderizar sugestÃµes com contexto de gÃªnero
        if (typeof window.aiUIController !== 'undefined') {
            log('[GENRE-FLOW] ğŸ¯ Renderizando sugestÃµes em modo gÃªnero');
            
            window.aiUIController.renderSuggestions({ 
                mode: 'genre', 
                user: analysis,
                targets: genreTargets
            });
            
            window.aiUIController.renderMetricCards({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderScoreSection({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderFinalScoreAtTop({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.checkForAISuggestions({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
        }
        
        log('[GENRE-FLOW] âœ… RenderizaÃ§Ã£o de modo gÃªnero concluÃ­da');
        } // â† Fechar else do genreTargets
    }
    
    // [AUDIT-FLOW-CHECK] Verificar se chegou aqui (deveria chegar sempre, inclusive no modo reference)
    log('[AUDIT-FLOW-CHECK] âœ… Fluxo continua apÃ³s blocos reference/genre - modo:', analysis?.mode);
    
    // ğŸ”’ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que mÃ©tricas essenciais estÃ£o presentes
    // CORRIGIDO: Verificar novos caminhos do backend Redis
    const hasEssentialMetrics = (
        analysis?.technicalData && 
        (
            Number.isFinite(analysis.technicalData.lufsIntegrated) ||
            Number.isFinite(analysis.technicalData.lufs_integrated) ||
            Number.isFinite(analysis.technicalData.avgLoudness) ||
            Number.isFinite(analysis.technicalData.dynamicRange) ||
            // NOVOS CAMINHOS: Estrutura do backend Redis
            Number.isFinite(analysis.loudness?.integrated) ||
            Number.isFinite(analysis.technicalData?.dr) ||
            // Fallback: Se tem score, provavelmente tem dados vÃ¡lidos
            Number.isFinite(analysis.score)
        )
    );
    
    if (!hasEssentialMetrics) {
        warn('âš ï¸ [UI_GATE] Aguardando mÃ©tricas essenciais... anÃ¡lise incompleta:', analysis);
        log('ğŸ” [UI_GATE] Debug - estrutura recebida:', {
            technicalData: analysis?.technicalData,
            loudness: analysis?.loudness,
            score: analysis?.score,
            hasScore: Number.isFinite(analysis?.score)
        });
        
        // CORREÃ‡ÃƒO: Verificar se Ã© estrutura nova mas vÃ¡lida
        if (analysis?.loudness || analysis?.technicalData || Number.isFinite(analysis?.score)) {
            warn("âš ï¸ [UI_GATE] Estrutura nova detectada, prosseguindo com dados disponÃ­veis");
        } else {
            warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: hasEssentialMetrics falhou - mode:', analysis?.mode);
            warn('[AUDITORIA_TIMING] normalizeBackendAnalysisData terminado?', !!window.currentAnalysisData);
            warn('[AUDITORIA_TIMING] displayModalResults chamado?', performance.now());
            // Tentar novamente em 2 segundos apenas se realmente nÃ£o hÃ¡ dados
            setTimeout(() => displayModalResults(analysis), 2000);
            return;
        }
    }
    
    log('âœ… [UI_GATE] MÃ©tricas essenciais presentes, exibindo resultados');
    
    // ğŸ”¥ CORREÃ‡ÃƒO COMPARAÃ‡ÃƒO A/B: Usar _userAnalysis (1Âª faixa = sua mÃºsica) para cards/mÃ©tricas
    if (analysis._isReferenceMode && analysis._userAnalysis && analysis._referenceAnalysis) {
        log('[REFERENCE-DISPLAY] ğŸ¯ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        log('[REFERENCE-DISPLAY] ğŸ¯ Modo A/B detectado - ConfiguraÃ§Ã£o correta:');
        log('[REFERENCE-DISPLAY] âœ… 1Âª faixa (SUA MÃšSICA/ATUAL):', analysis._userAnalysis?.fileName || analysis._userAnalysis?.metadata?.fileName);
        log('[REFERENCE-DISPLAY] âœ… 2Âª faixa (REFERÃŠNCIA/ALVO):', analysis._referenceAnalysis?.fileName || analysis._referenceAnalysis?.metadata?.fileName);
        log('[REFERENCE-DISPLAY] ğŸ“Š Cards principais: mostrarÃ£o mÃ©tricas da SUA MÃšSICA (1Âª faixa)');
        log('[REFERENCE-DISPLAY] ğŸ“Š Tabela comparativa: SUA MÃšSICA (esquerda) vs REFERÃŠNCIA (direita)');
        log('[REFERENCE-DISPLAY] ğŸ¯ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // Salvar anÃ¡lise de referÃªncia antes de substituir
        const originalReferenceAnalysis = analysis._referenceAnalysis;
        
        // SUBSTITUIR analysis pelos dados da PRIMEIRA faixa (sua mÃºsica/atual) para renderizaÃ§Ã£o dos cards
        const firstTrackAnalysis = analysis._userAnalysis;
        
        // Copiar propriedades importantes
        analysis = {
            ...firstTrackAnalysis,
            _isReferenceMode: true,
            _userAnalysis: firstTrackAnalysis,
            _referenceAnalysis: originalReferenceAnalysis,
            mode: 'reference' // Manter modo para lÃ³gica posterior
        };
        
        log('[REFERENCE-DISPLAY âœ…] Analysis substituÃ­do por dados da sua mÃºsica (1Âª faixa)');
        log('[REFERENCE-DISPLAY] MÃ©tricas da SUA MÃšSICA a serem exibidas nos cards:', {
            lufs: analysis.technicalData?.lufsIntegrated || analysis.loudness?.integrated,
            dr: analysis.technicalData?.dynamicRange || analysis.technicalData?.dr,
            tp: analysis.technicalData?.truePeakDbtp || analysis.truePeak?.maxDbtp
        });
    }
    
    // ğŸ¯ DETECÃ‡ÃƒO DE MODO COMPARAÃ‡ÃƒO ENTRE FAIXAS
    const isSecondTrackCheck = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
    const mode = analysis?.mode || currentAnalysisMode;
    
    // ğŸ”´ğŸ”´ğŸ”´ DIAGNÃ“STICO CRÃTICO: Por que nÃ£o estÃ¡ entrando no bloco A/B?
    log('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ”´ [DIAGNÃ“STICO-AB] Valores das variÃ¡veis da condicional:');
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   analysis?.mode:', analysis?.mode);
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   currentAnalysisMode:', currentAnalysisMode);
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   mode (final):', mode);
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   isSecondTrackCheck:', isSecondTrackCheck);
    log('ğŸ”´ [DIAGNÃ“STICO-AB] Condicional serÃ¡:', mode === 'reference' && isSecondTrackCheck);
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   mode === "reference"?', mode === 'reference');
    log('ğŸ”´ [DIAGNÃ“STICO-AB]   isSecondTrackCheck?', isSecondTrackCheck);
    log('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    // ğŸ¯ DEFINIR MODO NO ESTADO ANTES DE QUALQUER CÃLCULO
    const state = window.__soundyState || {};
    state.render = state.render || {};
    
    // ğŸ”´ FIX CRÃTICO: Remover verificaÃ§Ã£o de window.__FIRST_ANALYSIS_FROZEN__ da condicional
    // para permitir entrada no bloco e fazer recuperaÃ§Ã£o automÃ¡tica
    if (mode === 'reference' && isSecondTrackCheck) {
        log('ğŸ¯ [COMPARE-MODE] Modo reference detectado - Segunda faixa chegou');
        log('ğŸ“Š [COMPARE-MODE] window.__FIRST_ANALYSIS_FROZEN__ existe?', !!window.__FIRST_ANALYSIS_FROZEN__);
        log('ğŸ“Š [COMPARE-MODE] Segunda faixa:', analysis);
        
        // ğŸ¯ DEFINIR MODO REFERENCE NO ESTADO
        state.render.mode = 'reference';
        window.__soundyState = state;
        log('âœ… [COMPARE-MODE] Modo definido como REFERENCE no estado');
        
        // ğŸ¯ CRIAR ESTRUTURA DE COMPARAÃ‡ÃƒO ENTRE FAIXAS COM CÃ“PIA DEFENSIVA
        
        // ğŸ” AUDITORIA: Estado ANTES de deepCloneSafe + normalizeBackendAnalysisData
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ”’ ANTES deepCloneSafe + normalize');
        log('âš™ï¸ Contexto: Prestes a criar refNormalized e currNormalized');
        log('ğŸ“Š window.__FIRST_ANALYSIS_FROZEN__ (1Âª faixa):', {
            fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
            jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
            lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
            objectId: window.__FIRST_ANALYSIS_FROZEN__
        });
        log('ğŸ“Š analysis (2Âª faixa):', {
            fileName: analysis?.metadata?.fileName || analysis?.fileName,
            jobId: analysis?.jobId,
            lufs: analysis?.technicalData?.lufsIntegrated,
            objectId: analysis
        });
        log('ğŸ’¡ OperaÃ§Ã£o: deepCloneSafe() + normalizeBackendAnalysisData()');
        console.groupEnd();
        
        // ========================================
        // ğŸ§  PRIORIZAR DADOS DO STORE ISOLADO (FONTE DE VERDADE)
        // ========================================
        let refNormalized, currNormalized;
        
        // ğŸ”’ PRIORIDADE ABSOLUTA: Verificar SoundyAI_Store PRIMEIRO
        const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
        
        if (storeHasBoth) {
            log('ğŸ¯ [STORE-ABSOLUTE-PRIORITY] âœ… Store tem ambas anÃ¡lises - USANDO COMO FONTE ÃšNICA');
            log('   - Store.first.jobId:', window.SoundyAI_Store.first?.jobId);
            log('   - Store.second.jobId:', window.SoundyAI_Store.second?.jobId);
            log('   - Store.first.fileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
            log('   - Store.second.fileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
            
            // Normalizar dados do store (nÃ£o do comparisonPair que pode estar desatualizado)
            refNormalized = normalizeSafe(window.SoundyAI_Store.first);   // Primeira mÃºsica
            currNormalized = normalizeSafe(window.SoundyAI_Store.second); // Segunda mÃºsica
            
            log('âœ… [STORE-ABSOLUTE-PRIORITY] Dados do store normalizados:');
            log('   - refNormalized.jobId:', refNormalized?.jobId);
            log('   - currNormalized.jobId:', currNormalized?.jobId);
            log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
            
            // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Detectar contaminaÃ§Ã£o no store
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                error('ğŸš¨ [STORE-ERROR] âŒ CONTAMINAÃ‡ÃƒO NO STORE DETECTADA!');
                error('   - JobIds sÃ£o IGUAIS:', window.SoundyAI_Store.first.jobId);
                error('   - Isso indica bug no salvamento dos dados');
                console.trace();
            }
            
        } else if (analysis?._useStoreData && analysis?._comparisonPair) {
            log('ğŸ¯ [STORE-PRIORITY] Usando dados do comparisonPair (anexado ao analysis)');
            const pair = analysis._comparisonPair;
            
            // Normalizar dados do comparisonPair
            refNormalized = normalizeSafe(pair.ref);   // Primeira mÃºsica (referÃªncia)
            currNormalized = normalizeSafe(pair.curr); // Segunda mÃºsica (atual)
            
            log('âœ… [STORE-PRIORITY] Dados do comparisonPair normalizados:');
            log('   - refNormalized.jobId:', refNormalized?.jobId);
            log('   - currNormalized.jobId:', currNormalized?.jobId);
            log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
        } else {
            log('âš ï¸ [LEGACY-MODE] Store nÃ£o disponÃ­vel, usando modo legado');
            warn('âš ï¸ [LEGACY-WARN] ATENÃ‡ÃƒO: Modo legado pode ter contaminaÃ§Ã£o!');
            
            // ğŸ”’ HARD-GUARD: Usar FirstAnalysisStore.get() (Ãºnica fonte de verdade - modo legado)
            const firstAnalysis = FirstAnalysisStore.get();
            
            log('ğŸ”´ [AUDIT-CRITICAL] ANTES de criar refNormalized/currNormalized:');
            log('  FirstAnalysisStore.has():', FirstAnalysisStore.has());
            log('  firstAnalysis.metadata?.fileName:', firstAnalysis?.metadata?.fileName);
            log('  firstAnalysis.jobId:', firstAnalysis?.jobId);
            log('  analysis.metadata?.fileName:', analysis?.metadata?.fileName);
            log('  analysis.jobId:', analysis?.jobId);
            log('  ğŸš¨ SÃƒO O MESMO ARQUIVO?', firstAnalysis?.metadata?.fileName === analysis?.metadata?.fileName);
            log('  ğŸš¨ SÃƒO O MESMO JOBID?', firstAnalysis?.jobId === analysis?.jobId);
            
            // âœ… STEP 2/6 REFATORADO: NormalizaÃ§Ã£o segura sem ciclos (modo legado)
            log('[NORMALIZE-DEFENSIVE] ğŸ”’ Criando cÃ³pia isolada da 1Âª faixa (normalizeSafe)');
            refNormalized = normalizeSafe(firstAnalysis);
            
            log('[NORMALIZE-DEFENSIVE] ğŸ”’ Criando cÃ³pia isolada da 2Âª faixa (normalizeSafe)');
            currNormalized = normalizeSafe(analysis);
        }
        
        // ========================================
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA ABSOLUTA: ABORTAR SE JOBIDS IGUAIS
        // ========================================
        const refFileName = refNormalized?.metadata?.fileName || refNormalized?.fileName;
        const currFileName = currNormalized?.metadata?.fileName || currNormalized?.fileName;
        const refJobId = refNormalized?.jobId || refNormalized?.id;
        const currJobId = currNormalized?.jobId || currNormalized?.id;
        
        console.groupCollapsed('[PRE-VALIDATION] ğŸ” VerificaÃ§Ã£o de Integridade dos Objetos');
        log('ğŸ“ Arquivo 1 (ref):', refFileName);
        log('ğŸ“ Arquivo 2 (curr):', currFileName);
        log('ğŸ†” JobId 1 (ref):', refJobId);
        log('ğŸ†” JobId 2 (curr):', currJobId);
        log('âš ï¸ Nomes iguais?', refFileName === currFileName);
        log('âš ï¸ JobIds iguais?', refJobId === currJobId);
        log('âš ï¸ Objetos sÃ£o mesma referÃªncia?', refNormalized === currNormalized);
        log('âš ï¸ Metadata sÃ£o mesma referÃªncia?', refNormalized?.metadata === currNormalized?.metadata);
        console.groupEnd();
        
        // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Se jobIds forem iguais, ABORTAR IMEDIATAMENTE
        if (refJobId && currJobId && refJobId === currJobId) {
            error('ğŸš¨ğŸš¨ğŸš¨ [CRITICAL-ERROR] JOBIDS IGUAIS DETECTADOS! ğŸš¨ğŸš¨ğŸš¨');
            error('   - refJobId:', refJobId);
            error('   - currJobId:', currJobId);
            error('   - refFileName:', refFileName);
            error('   - currFileName:', currFileName);
            error('   - Sistema estÃ¡ tentando comparar a mÃºsica consigo mesma!');
            error('   - ABORTANDO renderizaÃ§Ã£o para evitar dados incorretos');
            console.trace();
            
            // Mostrar alerta ao usuÃ¡rio
            alert('âŒ ERRO CRÃTICO: Sistema detectou que estÃ¡ tentando comparar a mesma mÃºsica.\n\n' +
                  'JobId 1: ' + refJobId + '\n' +
                  'JobId 2: ' + currJobId + '\n\n' +
                  'Por favor, recarregue a pÃ¡gina e tente novamente com duas mÃºsicas DIFERENTES.');
            
            // ABORTAR renderizaÃ§Ã£o
            return;
        }
        
        log('âœ… [VALIDATION-PASS] JobIds sÃ£o diferentes - prosseguindo com renderizaÃ§Ã£o');
        
        // ğŸ›¡ï¸ ProteÃ§Ã£o contra auto-comparaÃ§Ã£o e renderizaÃ§Ã£o segura
        let isSelfCompare = false;
        
        // ========================================
        // ğŸ”§ VALIDAÃ‡ÃƒO INTELIGENTE: Usar jobId e VID em vez de apenas fileName
        // ========================================
        const sameFileName = refFileName === currFileName;
        const sameJobId = !!(refJobId && currJobId && refJobId === currJobId);
        
        // Verificar Virtual IDs (mais confiÃ¡vel que fileName)
        const refVid = refNormalized?.vid || window.CacheIndex?.REF;
        const currVid = currNormalized?.vid || window.CacheIndex?.USER;
        const sameVid = !!(refVid && currVid && refVid === currVid);
        
        // Fallback: areSameTrack() para validaÃ§Ã£o tÃ©cnica
        const sameTrack = areSameTrack(refNormalized, currNormalized);
        
        console.groupCollapsed('[SMART-VALIDATION] ğŸ§  AnÃ¡lise de Self-Compare (VID-aware)');
        log('ğŸ“‹ AnÃ¡lise completa:', {
            sameFileName,
            sameJobId,
            refVid,
            currVid,
            sameVid,
            sameTrack,
            decisao: (sameJobId || sameVid) 
                ? 'SELF-COMPARE REAL (jobId ou VID idÃªntico)' 
                : (sameFileName && !sameJobId && !sameVid) 
                    ? 'MESMO ARQUIVO, IDs DIFERENTES â†’ OK (nÃ£o Ã© self-compare)' 
                    : 'ARQUIVOS DIFERENTES'
        });
        console.groupEnd();
        
        // Self-compare detectado se: jobId OU VID idÃªnticos
        if (sameJobId || sameVid) {
            warn('[REF-GUARD] âš ï¸ Self-compare REAL detectado â€” marcando flag mas CONTINUANDO renderizaÃ§Ã£o A/B.');
            isSelfCompare = true;
            
            // ğŸ”¥ Marcar no estado que Ã© self-compare (sem interromper fluxo)
            if (!state.render) state.render = {};
            state.render.isSelfCompare = true;
            
            log('[REF-GUARD] ğŸ”„ Self-compare confirmado:', {
                sameJobId: sameJobId ? refJobId : false,
                sameVid: sameVid ? refVid : false,
                note: 'Score serÃ¡ 100% mas renderizaÃ§Ã£o continua'
            });
        } else if (sameFileName && !sameJobId && !sameVid) {
            log('[REF-GUARD] âœ… Mesmo arquivo mas IDs diferentes â†’ NÃ£o Ã© self-compare, continuando normalmente');
        } else if (sameTrack && !sameJobId && !sameVid) {
            log('[REF-GUARD] âš ï¸ areSameTrack() detectou semelhanÃ§a mas IDs sÃ£o diferentes â†’ Continuando normalmente');
        } else {
            log('[REF-GUARD] âœ… ValidaÃ§Ã£o passou - faixas sÃ£o diferentes');
        }
        
        // âœ… REVALIDAÃ‡ÃƒO: Garantir que nÃ£o Ã© falso-positivo
        // Se chegou aqui com isSelfCompare mas VIDs sÃ£o diferentes, corrigir
        if (isSelfCompare && refVid !== currVid) {
            warn('[REF-GUARD] â Corrigido selfCompare falso-positivo (VIDs diferentes):', {
                refVid,
                currVid,
                refFile: refFileName,
                currFile: currFileName
            });
            isSelfCompare = false;
            if (state.render) state.render.isSelfCompare = false;
        }
        
        // ğŸ› DEBUG A/B
        log('[DEBUG-A/B]', {
            ref: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            curr: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            same: areSameTrack(refNormalized, currNormalized),
        });
        
        // ğŸ” AUDITORIA: Estado APÃ“S criar refNormalized e currNormalized
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS refNormalized + currNormalized');
        log('âš™ï¸ Contexto: Clones normalizados criados');
        log('ğŸ“Š refNormalized (1Âª faixa normalizada):', {
            fileName: refNormalized?.metadata?.fileName,
            jobId: refNormalized?.jobId,
            lufs: refNormalized?.technicalData?.lufsIntegrated,
            objectId: refNormalized
        });
        log('ğŸ“Š currNormalized (2Âª faixa normalizada):', {
            fileName: currNormalized?.metadata?.fileName,
            jobId: currNormalized?.jobId,
            lufs: currNormalized?.technicalData?.lufsIntegrated,
            objectId: currNormalized
        });
        log('âš ï¸ VERIFICAÃ‡ÃƒO DE ISOLAMENTO:');
        log('  refNormalized !== currNormalized?', refNormalized !== currNormalized);
        log('  refNormalized !== window.__FIRST_ANALYSIS_FROZEN__?', refNormalized !== window.__FIRST_ANALYSIS_FROZEN__);
        log('  currNormalized !== analysis?', currNormalized !== analysis);
        log('  refNormalized.metadata?.fileName:', refNormalized?.metadata?.fileName);
        log('  currNormalized.metadata?.fileName:', currNormalized?.metadata?.fileName);
        log('  ğŸš¨ SAME FILE?', refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName);
        
        // ğŸ”´ VALIDAÃ‡ÃƒO CRÃTICA: Se os arquivos sÃ£o iguais, ABORTAR imediatamente
        if (refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName) {
            error('ğŸ”´ [AUDITORIA_STATE_FLOW] âŒâŒâŒ CONTAMINAÃ‡ÃƒO CONFIRMADA âŒâŒâŒ');
            error('ğŸ”´ refNormalized e currNormalized tÃªm O MESMO ARQUIVO!');
            error('ğŸ”´ Isso significa que window.__FIRST_ANALYSIS_FROZEN__ foi contaminado!');
            error('ğŸ”´ Sistema estÃ¡ comparando a mÃºsica consigo mesma!');
            console.table({
                'refNormalized.fileName': refNormalized?.metadata?.fileName,
                'refNormalized.jobId': refNormalized?.jobId,
                'currNormalized.fileName': currNormalized?.metadata?.fileName,
                'currNormalized.jobId': currNormalized?.jobId,
                'sameFile': refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName,
                'sameJobId': refNormalized?.jobId === currNormalized?.jobId
            });
        }
        console.groupEnd();
        
        // [REF-FLOW] Construindo mÃ©tricas A/B
        // âœ… SEMÃ‚NTICA CORRETA:
        // - refNormalized = 1Âª faixa = SUA MÃšSICA (atual) = userAnalysis
        // - currNormalized = 2Âª faixa = REFERÃŠNCIA (alvo a alcanÃ§ar) = referenceAnalysis
        
        // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: SÃ³ criar se ainda nÃ£o existir
        if (!referenceComparisonMetrics) {
            log('[STATE-FIX] âœ… Criando referenceComparisonMetrics pela primeira vez');
            referenceComparisonMetrics = {
                // ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                userTrack: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),        // 1Âª faixa (sua mÃºsica/atual)
                referenceTrack: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2Âª faixa (referÃªncia/alvo)
                
                userTrackFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceTrackFull: JSON.parse(JSON.stringify(currNormalized || null)),
                
                // LEGADO: manter por compatibilidade (mapeamento correto)
                user: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),       // 1Âª = sua mÃºsica (atual)
                reference: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2Âª = referÃªncia (alvo)
                userFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceFull: JSON.parse(JSON.stringify(currNormalized || null))
            };
        } else {
            warn('[STATE-FIX] âš ï¸ referenceComparisonMetrics jÃ¡ inicializado, nÃ£o sobrescrevendo');
            warn('[STATE-FIX]   Mantendo dados originais:', {
                userFile: referenceComparisonMetrics.userFull?.fileName || referenceComparisonMetrics.userFull?.metadata?.fileName,
                refFile: referenceComparisonMetrics.referenceFull?.fileName || referenceComparisonMetrics.referenceFull?.metadata?.fileName
            });
        }
        
        log('[REF-FLOW] âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        log('[REF-FLOW] âœ… MÃ©tricas A/B construÃ­das corretamente:');
        log('[REF-FLOW] âœ…   SUA MÃšSICA (1Âª):', refNormalized.metadata?.fileName);
        log('[REF-FLOW] âœ…   LUFS:', referenceComparisonMetrics.userTrack?.lufsIntegrated);
        log('[REF-FLOW] âœ…   REFERÃŠNCIA (2Âª):', currNormalized.metadata?.fileName);
        log('[REF-FLOW] âœ…   LUFS:', referenceComparisonMetrics.referenceTrack?.lufsIntegrated);
        log('[REF-FLOW] âœ…   Tabela: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
        log('[REF-FLOW] âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        log('[ASSERT] reference mode', {
            userIsFirst: !!(state?.userAnalysis || refNormalized),
            refIsSecond: !!(state?.referenceAnalysis || currNormalized)
        });
        
        // ğŸ§© PROTEÃ‡ÃƒO CONTRA DADOS INCOMPLETOS
        if (!currNormalized?.technicalData?.spectral_balance) {
            warn("âš ï¸ [REF-FIX] spectral_balance ausente em currNormalized, reconstruindo...");
            if (currNormalized?.bands) {
                currNormalized.technicalData.spectral_balance = currNormalized.bands;
            } else if (currNormalized?.technicalData?.bandEnergies) {
                currNormalized.technicalData.spectral_balance = currNormalized.technicalData.bandEnergies;
            } else {
                warn("âš ï¸ [REF-FIX] Criando estrutura vazia para currNormalized");
                if (!currNormalized.technicalData) currNormalized.technicalData = {};
                currNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }

        if (!refNormalized?.technicalData?.spectral_balance) {
            warn("âš ï¸ [REF-FIX] spectral_balance ausente em refNormalized, reconstruindo...");
            if (refNormalized?.bands) {
                refNormalized.technicalData.spectral_balance = refNormalized.bands;
            } else if (refNormalized?.technicalData?.bandEnergies) {
                refNormalized.technicalData.spectral_balance = refNormalized.technicalData.bandEnergies;
            } else {
                warn("âš ï¸ [REF-FIX] Criando estrutura vazia para refNormalized");
                if (!refNormalized.technicalData) refNormalized.technicalData = {};
                refNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }
        
        // ğŸ§© LOG DE AUDITORIA DETALHADO
        log("[ASSERT_REF_FLOW âœ…]", {
            userTrack: refNormalized?.metadata?.fileName || "primeira faixa",
            referenceTrack: currNormalized?.metadata?.fileName || "segunda faixa",
            userBands: Object.keys(refNormalized?.technicalData?.spectral_balance || {}),
            referenceBands: Object.keys(currNormalized?.technicalData?.spectral_balance || {})
        });
        
        // ğŸ§© PROTEÃ‡ÃƒO NO displayModalResults: ValidaÃ§Ã£o de referenceTrack
        if (!currNormalized?.metadata?.fileName && !currNormalized?.fileName) {
            warn("âš ï¸ [DISPLAY_MODAL_FIX] Reference track com dados incompletos â€” continuando com fallback...");
            // âŒ REMOVIDO: return que bloqueava renderizaÃ§Ã£o
            // Agora continua o fluxo com dados disponÃ­veis, mesmo que incompletos
        }
        
        // ğŸ§© CORREÃ‡ÃƒO #6: Chamada ÃšNICA de renderizaÃ§Ã£o (remover duplicaÃ§Ã£o)
        // SEMÃ‚NTICA CORRETA:
        // - userAnalysis = 1Âª faixa (SUA MÃšSICA - atual)
        // - referenceAnalysis = 2Âª faixa (REFERÃŠNCIA - alvo)
        
        // ğŸ” [A/B-DEBUG] Dados ANTES de renderReferenceComparisons
        log("[A/B-DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        log("[A/B-DEBUG] Dados antes do SAFE_RENDER_REF:");
        log("[A/B-DEBUG] refNormalized (1Âª faixa - SUA MÃšSICA):", {
            fileName: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            hasBands: !!refNormalized?.bands,
            hasSpectralBalance: !!refNormalized?.technicalData?.spectral_balance,
            bandsKeys: refNormalized?.bands ? Object.keys(refNormalized.bands) : [],
            spectralBalanceKeys: refNormalized?.technicalData?.spectral_balance ? Object.keys(refNormalized.technicalData.spectral_balance) : []
        });
        log("[A/B-DEBUG] currNormalized (2Âª faixa - REFERÃŠNCIA):", {
            fileName: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            hasBands: !!currNormalized?.bands,
            hasSpectralBalance: !!currNormalized?.technicalData?.spectral_balance,
            bandsKeys: currNormalized?.bands ? Object.keys(currNormalized.bands) : [],
            spectralBalanceKeys: currNormalized?.technicalData?.spectral_balance ? Object.keys(currNormalized.technicalData.spectral_balance) : []
        });
        log("[A/B-DEBUG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        // âœ… GARANTIR que bands esteja no nÃ­vel correto (userAnalysis.bands e referenceAnalysis.bands)
        if (!refNormalized.bands && refNormalized?.technicalData?.spectral_balance) {
            refNormalized.bands = refNormalized.technicalData.spectral_balance;
            log("[A/B-FIX] âœ… Bandas copiadas de technicalData.spectral_balance para bands (userAnalysis)");
        }
        
        if (!currNormalized.bands && currNormalized?.technicalData?.spectral_balance) {
            currNormalized.bands = currNormalized.technicalData.spectral_balance;
            log("[A/B-FIX] âœ… Bandas copiadas de technicalData.spectral_balance para bands (referenceAnalysis)");
        }
        
        log("[A/B-DEBUG] âœ… Bandas finais:", {
            userBandsLength: refNormalized?.bands ? Object.keys(refNormalized.bands).length : 0,
            referenceBandsLength: currNormalized?.bands ? Object.keys(currNormalized.bands).length : 0
        });
        
        // ğŸ§Š PROTEÃ‡ÃƒO ANTICONTAMINAÃ‡ÃƒO: Deep clone antes de renderizar
        log('[STATE-FIX] ğŸ”’ Criando frozen clones para renderReferenceComparisons');
        const frozenRef = JSON.parse(JSON.stringify(refNormalized));
        const frozenCurr = JSON.parse(JSON.stringify(currNormalized));
        
        // ğŸ” AUDITORIA DE INTEGRIDADE
        log('[STATE-INTEGRITY]', {
            refJobId: frozenRef.jobId,
            currJobId: frozenCurr.jobId,
            refFile: frozenRef.fileName || frozenRef.metadata?.fileName,
            currFile: frozenCurr.fileName || frozenCurr.metadata?.fileName,
            sameJob: frozenRef.jobId === frozenCurr.jobId,
            sameFile: (frozenRef.fileName || frozenRef.metadata?.fileName) === (frozenCurr.fileName || frozenCurr.metadata?.fileName),
            areIndependent: frozenRef !== frozenCurr,
            metadataIndependent: frozenRef.metadata !== frozenCurr.metadata
        });
        
        // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA: Garantir que jobIds sÃ£o DIFERENTES antes de renderizar
        console.group('ğŸ” [DISPLAY-MODAL] ValidaÃ§Ã£o de JobIds antes de renderizar');
        log('   - frozenRef.jobId:', frozenRef.jobId);
        log('   - frozenCurr.jobId:', frozenCurr.jobId);
        log('   - SÃ£o diferentes?', frozenRef.jobId !== frozenCurr.jobId);
        
        // Validar com getCorrectJobId() tambÃ©m
        const expectedCurrentJobId = getCorrectJobId('current');
        const expectedReferenceJobId = getCorrectJobId('reference');
        log('   - getCorrectJobId("current"):', expectedCurrentJobId);
        log('   - getCorrectJobId("reference"):', expectedReferenceJobId);
        log('   - Esses tambÃ©m sÃ£o diferentes?', expectedCurrentJobId !== expectedReferenceJobId);
        
        if (frozenRef.jobId === frozenCurr.jobId) {
            error('âŒ [DISPLAY-MODAL] ERRO: frozenRef e frozenCurr tÃªm o MESMO jobId!');
            error('   Isso significa que os dados estÃ£o contaminados!');
            console.trace();
            console.groupEnd();
            
            // Tentar recuperar usando getCorrectJobId
            warn('ğŸ”„ [DISPLAY-MODAL] Tentando recuperar dados corretos...');
            // Por enquanto, ABORTAR para evitar renderizaÃ§Ã£o incorreta
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o. Os dados estÃ£o contaminados. Recarregue a pÃ¡gina.');
            return;
        }
        
        log('âœ… [DISPLAY-MODAL] JobIds sÃ£o diferentes - prosseguindo com renderizaÃ§Ã£o');
        console.groupEnd();
        
        // ========================================
        // ğŸ§  USAR DADOS DO STORE SE DISPONÃVEL
        // ========================================
        let renderUserAnalysis, renderRefAnalysis;
        
        if (analysis?._useStoreData && analysis?._comparisonPair) {
            log('ğŸ¯ [RENDER-STORE] Usando dados do store isolado para renderizaÃ§Ã£o');
            renderUserAnalysis = frozenRef;   // JÃ¡ Ã© clone de comparisonPair.ref
            renderRefAnalysis = frozenCurr;   // JÃ¡ Ã© clone de comparisonPair.curr
        } else {
            log('âš ï¸ [RENDER-LEGACY] Usando dados legados para renderizaÃ§Ã£o');
            renderUserAnalysis = frozenRef;
            renderRefAnalysis = frozenCurr;
        }
        
        // ğŸ¯ [METRICS-DEBUG] LOG CRÃTICO DAS MÃ‰TRICAS ANTES DE RENDERIZAR
        console.group('ğŸ¯ [METRICS-DEBUG] MÃ©tricas ANTES de renderReferenceComparisons');
        console.table({
            'User LUFS': renderUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': renderRefAnalysis?.technicalData?.lufsIntegrated,
            'User DR': renderUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': renderRefAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': renderUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': renderRefAnalysis?.technicalData?.truePeakDbtp,
            'User JobId': renderUserAnalysis?.jobId,
            'Ref JobId': renderRefAnalysis?.jobId,
            'User File': renderUserAnalysis?.fileName || renderUserAnalysis?.metadata?.fileName,
            'Ref File': renderRefAnalysis?.fileName || renderRefAnalysis?.metadata?.fileName
        });
        log('âœ… [METRICS-DEBUG] Se os valores acima forem IGUAIS, hÃ¡ contaminaÃ§Ã£o!');
        console.groupEnd();
        
        // ğŸ”¥ NOVO: Construir tabela A vs B via buildComparisonRows em reference mode
        log('[REFERENCE-MODE] ğŸ”¨ Construindo tabela de comparaÃ§Ã£o A vs B');
        
        // ğŸ¯ CORREÃ‡ÃƒO: Usar extractMetrics para garantir acesso robusto Ã s mÃ©tricas
        const userMetrics = extractMetrics(renderUserAnalysis) || renderUserAnalysis;
        const refMetrics = extractMetrics(renderRefAnalysis) || renderRefAnalysis;
        
        log('[REFERENCE-MODE] ğŸ“Š MÃ©tricas extraÃ­das:', {
            userMetricsKeys: Object.keys(userMetrics),
            refMetricsKeys: Object.keys(refMetrics)
        });
        
        const comparisonRows = buildComparisonRows(userMetrics, refMetrics);
        
        if (comparisonRows && comparisonRows.length > 0) {
            log('[REFERENCE-MODE] âœ… Tabela construÃ­da com', comparisonRows.length, 'linhas');
            console.table(comparisonRows);
            
            // Anexar ao analysis para renderReferenceComparisons usar
            renderUserAnalysis.referenceComparisonRows = comparisonRows;
            renderRefAnalysis.referenceComparisonRows = comparisonRows;
            
            // TambÃ©m disponibilizar globalmente se necessÃ¡rio
            window.__REFERENCE_COMPARISON_ROWS__ = comparisonRows;
        } else {
            warn('[REFERENCE-MODE] âš ï¸ buildComparisonRows retornou vazio');
        }
        
        // ğŸ¯ Usar helper getCompareMode (NUNCA ctx.mode como fallback)
        const compareMode = getCompareMode(analysis);
        
        renderReferenceComparisons({
            mode: 'reference',
            compareMode: compareMode,  // âœ… Passar explicitamente
            userAnalysis: renderUserAnalysis,        // 1Âª faixa (sua mÃºsica) - CLONE INDEPENDENTE
            referenceAnalysis: renderRefAnalysis,    // 2Âª faixa (referÃªncia) - CLONE INDEPENDENTE
            analysis: {
                userAnalysis: renderUserAnalysis,
                referenceAnalysis: renderRefAnalysis
            },
            _useStoreData: analysis?._useStoreData  // Propagar flag
        });
        
        // âŒ REMOVIDO: renderTrackComparisonTable() - causava duplicaÃ§Ã£o
        // renderReferenceComparisons() jÃ¡ renderiza tudo
        log('âœ… [REFERENCE-RENDER] RenderizaÃ§Ã£o Ãºnica completa (sem duplicaÃ§Ã£o)');
        
        // Atualizar window.latestAnalysis para compatibilidade com IA e PDF
        window.latestAnalysis = {
            mode: "comparison",
            reference: window.referenceAnalysisData,
            current: analysis,
            scores: analysis.scores || {}
        };
        
        // âœ… CORREÃ‡ÃƒO CRÃTICA: NÃƒO retornar aqui!
        // Continuar para renderizar cards, scores e sugestÃµes
        log('[AUDIT-FIX] âœ… Continuando renderizaÃ§Ã£o completa (cards, scores, sugestÃµes)');
        
        // ğŸ¯ GARANTIR que sugestÃµes de IA sejam chamadas tambÃ©m no modo reference
        log('[AUDIT-FIX] ğŸ¤– Iniciando renderizaÃ§Ã£o de sugestÃµes de IA no modo reference');
        
        // âœ… CORREÃ‡ÃƒO: Garantir que analysisForSuggestions inclua suggestions completas
        const analysisForSuggestions = {
            ...(refNormalized || analysis),
            // âœ… Preservar suggestions da anÃ¡lise (pode vir do backend ou frontend)
            suggestions: 
                (refNormalized || analysis)?.suggestions || 
                (refNormalized || analysis)?.userAnalysis?.suggestions || 
                analysis?.suggestions ||
                [],
            mode: 'reference'
        };
        
        log('[SUG-AUDIT] reference deltas ready:', !!analysis.referenceComparison);
        log('[AUDIT-FIX] ğŸ“Š analysisForSuggestions preparado:', {
            hasSuggestions: !!analysisForSuggestions.suggestions,
            suggestionsLength: analysisForSuggestions.suggestions?.length || 0,
            mode: analysisForSuggestions.mode,
            hasReferenceComparison: !!analysisForSuggestions.referenceComparison
        });
        
        // ğŸ”¥ Chamada ao displayModalResults no fluxo normal (nÃ£o self-compare)
        if (typeof AISuggestionsIntegration?.displayModalResults === 'function') {
            AISuggestionsIntegration.displayModalResults(currNormalized);
        }
        
        // Chamar sugestÃµes de IA apÃ³s pequeno delay para garantir que DOM estÃ¡ pronto
        setTimeout(() => {
            if (window.aiUIController) {
                // ğŸ” PASSO 1: LOG CRÃTICO ANTES de checkForAISuggestions
                console.group('ğŸ” [PRE-AI-SUGGESTIONS] Estado ANTES de checkForAISuggestions');
                log('   - currentJobId (segunda mÃºsica):', window.__CURRENT_JOB_ID__);
                log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                log('   - analysisForSuggestions:', {
                    jobId: analysisForSuggestions?.jobId,
                    fileName: analysisForSuggestions?.fileName || analysisForSuggestions?.metadata?.fileName,
                    hasSuggestions: !!analysisForSuggestions?.suggestions,
                    suggestionsLength: analysisForSuggestions?.suggestions?.length || 0
                });
                
                // ğŸ” [AUDITORIA_DOM] Verificar estado do DOM de sugestÃµes
                const aiSection = document.getElementById('aiSuggestionsExpanded');
                const aiContent = document.getElementById('aiExpandedGrid');
                const existingSuggestions = aiContent?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                
                log('   [AUDITORIA_DOM] Estado ANTES:', {
                    aiSection: !!aiSection,
                    aiSectionVisible: aiSection?.style?.display !== 'none',
                    aiContent: !!aiContent,
                    suggestionsExistentes: existingSuggestions
                });
                console.groupEnd();
                
                log('[AUDIT-FIX] âœ… Chamando aiUIController.checkForAISuggestions');
                log('[AUDIT-FIX] Passando analysisForSuggestions com', analysisForSuggestions?.suggestions?.length || 0, 'sugestÃµes');
                window.aiUIController.checkForAISuggestions(analysisForSuggestions, true);
                
                // ğŸ” PASSO 2: LOG CRÃTICO DEPOIS de checkForAISuggestions
                setTimeout(() => {
                    console.group('ğŸ” [POST-AI-SUGGESTIONS] Estado DEPOIS de checkForAISuggestions');
                    log('   - currentJobId:', window.__CURRENT_JOB_ID__);
                    log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                    log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                    log('   - MUDOU?', window.__CURRENT_JOB_ID__ === window.__REFERENCE_JOB_ID__ ? 'âŒ CONTAMINADO!' : 'âœ… Intacto');
                    
                    // ğŸ” [AUDITORIA_DOM] Verificar estado do DOM de sugestÃµes DEPOIS
                    const aiSectionAfter = document.getElementById('aiSuggestionsExpanded');
                    const aiContentAfter = document.getElementById('aiExpandedGrid');
                    const cardsAfter = aiContentAfter?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                    
                    log('   [AUDITORIA_DOM] Estado DEPOIS:', {
                        aiSection: !!aiSectionAfter,
                        aiSectionVisible: aiSectionAfter?.style?.display !== 'none',
                        aiContent: !!aiContentAfter,
                        cards: cardsAfter
                    });
                    
                    if (cardsAfter === 0) {
                        error('   [AUDITORIA_DOM] âŒ NENHUM CARD FOI RENDERIZADO!');
                        error('   [AUDITORIA_DOM] PossÃ­veis causas:');
                        error('   [AUDITORIA_DOM]   1. analysisForSuggestions nÃ£o tem suggestions[]');
                        error('   [AUDITORIA_DOM]   2. FunÃ§Ã£o checkForAISuggestions retornou cedo');
                        error('   [AUDITORIA_DOM]   3. Erro no renderCompactPreview()');
                    } else {
                        log('   [AUDITORIA_DOM] âœ…', cardsAfter, 'cards renderizados com sucesso!');
                    }
                    console.groupEnd();
                }, 100); // Delay pequeno para dar tempo de renderizar
            } else if (window.forceShowAISuggestions) {
                log('[AUDIT-FIX] âœ… Chamando forceShowAISuggestions');
                window.forceShowAISuggestions(analysisForSuggestions);
            } else {
                warn('[AUDIT-FIX] âš ï¸ Nenhuma funÃ§Ã£o de IA disponÃ­vel');
            }
        }, 800);
        
        // âš ï¸ IMPORTANTE: NÃ£o usar return aqui - continuar fluxo normal
        // return; // â† REMOVIDO
    }
    else {
        // ğŸ”´ DIAGNÃ“STICO: Por que NÃƒO entrou no bloco A/B?
        error('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] NÃƒO ENTROU NO BLOCO A/B!');
        error('ğŸ”´ [DIAGNÃ“STICO-AB] Motivo:');
        if (mode !== 'reference') {
            error('ğŸ”´ [DIAGNÃ“STICO-AB]   âŒ mode !== "reference" (mode =', mode, ')');
        }
        if (!isSecondTrack) {
            error('ğŸ”´ [DIAGNÃ“STICO-AB]   âŒ isSecondTrack = false');
            error('ğŸ”´ [DIAGNÃ“STICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        }
        error('ğŸ”´ [DIAGNÃ“STICO-AB] Sistema VAI RENDERIZAR EM MODO SINGLE-TRACK!');
        error('ğŸ”´ğŸ”´ğŸ”´ [DIAGNÃ“STICO-AB] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO: Definir modo baseado no contexto real da anÃ¡lise
    // NÃƒO forÃ§ar genre se for primeira faixa de referÃªncia
    if (mode === 'reference' && !isSecondTrack) {
        // Primeira faixa em modo reference - manter modo reference mas nÃ£o renderizar ainda
        state.render.mode = 'reference';
        log('âœ… [REFERENCE-FIRST] Primeira faixa de referÃªncia - aguardando segunda');
    } else if (mode !== 'reference' || (mode === 'reference' && !window.referenceAnalysisData)) {
        // ğŸ” PARTE 3.3: Trava do modo Reference â€” NÃƒO forÃ§ar genre se estamos em fluxo de referÃªncia
        const isReferenceFlowLocked =
            (state?.reference?.isSecondTrack === true) ||
            (!!window.__REFERENCE_JOB_ID__ && state?.render?.mode === "reference");

        if (!isReferenceFlowLocked) {
            // Modo genre genuÃ­no
            state.render.mode = 'genre';
            log('âœ… [GENRE-MODE] Modo definido como GENRE no estado');
            
            // Limpar dados de referÃªncia para evitar contaminaÃ§Ã£o APENAS em modo genre
            if (state.reference) {
                state.reference.isSecondTrack = false;
                state.reference.analysis = null;
            }
        } else {
            log('ğŸ”’ [REF-LOCK] Modo reference travado â€” genre forÃ§ado bloqueado');
        }
    }
    window.__soundyState = state;
    
    // ğŸ”’ UI GATE: VerificaÃ§Ã£o final antes de renderizar
    const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
    
    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
        warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado: analysisRunId !== currentRunId', { analysisRunId, currentRunId, mode: analysis?.mode });
        warn(`ğŸš« [UI_GATE] displayModalResults cancelado - anÃ¡lise obsoleta (anÃ¡lise: ${analysisRunId}, atual: ${currentRunId})`);
        return;
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const technicalData = document.getElementById('modalTechnicalData');
    
    if (!results || !technicalData) {
        warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado: !results || !technicalData', { hasResults: !!results, hasTechnicalData: !!technicalData, mode: analysis?.mode });
        error('âŒ Elementos de resultado nÃ£o encontrados');
        return;
    }
    
    log('[AUDIT-FLOW-CHECK] âœ… Todos os gates passaram - continuando para renderizaÃ§Ã£o');
    
    // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: Abrir modal ANTES de renderizar modo gÃªnero
    // O container #referenceComparisons sÃ³ existe DEPOIS do modal ser aberto
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    results.style.display = 'block';
    log('[MODAL-OPEN] âœ… Modal aberto - results.style.display = "block"');
    
    // ğŸµ RENDERIZAR BLOCO DE IDENTIFICAÃ‡ÃƒO DA MÃšSICA (APENAS MODO GÃŠNERO)
    try {
        const musicIdContainer = document.getElementById('musicIdentificationBlock');
        const currentMode = analysis?.mode || window.currentAnalysisMode || 'genre';
        
        // âœ… CONDICIONAL: Renderizar APENAS em modo gÃªnero
        if (musicIdContainer) {
            if (currentMode === 'genre') {
                const musicIdHTML = renderMusicIdentificationBlock(analysis);
                musicIdContainer.innerHTML = musicIdHTML;
                musicIdContainer.style.display = 'block';
                log('[MUSIC-ID] âœ… Bloco de identificaÃ§Ã£o renderizado (modo gÃªnero)');
            } else {
                // ğŸš« Modo referÃªncia: OCULTAR bloco (nomes jÃ¡ aparecem no header A/B)
                musicIdContainer.innerHTML = '';
                musicIdContainer.style.display = 'none';
                log('[MUSIC-ID] â­ï¸ Bloco ocultado (modo referÃªncia - nomes jÃ¡ no header A/B)');
            }
        } else {
            warn('[MUSIC-ID] âš ï¸ Container #musicIdentificationBlock nÃ£o encontrado no DOM');
        }
    } catch (error) {
        error('[MUSIC-ID] âŒ Erro ao renderizar bloco de identificaÃ§Ã£o:', error);
    }
    
    // ğŸ“‹ PLANO DE CORREÃ‡ÃƒO: Registrar event listener APÃ“S modal ser renderizado
    (function registerCorrectionPlanListener() {
        const planBtn = document.getElementById('btnGenerateCorrectionPlan');
        log('[CORRECTION-PLAN] ğŸ” Buscando botÃ£o #btnGenerateCorrectionPlan:', planBtn);
        
        if (planBtn) {
            // Remover listener anterior se existir (evita duplicatas)
            planBtn.removeEventListener('click', window.handleGenerateCorrectionPlan);
            
            // Registrar novo listener
            planBtn.addEventListener('click', function(e) {
                log('[CORRECTION-PLAN] ğŸ–±ï¸ CLICK DETECTADO!');
                e.preventDefault();
                if (typeof window.handleGenerateCorrectionPlan === 'function') {
                    window.handleGenerateCorrectionPlan();
                } else {
                    error('[CORRECTION-PLAN] âŒ handleGenerateCorrectionPlan nÃ£o estÃ¡ definida!');
                    alert('Erro: funÃ§Ã£o nÃ£o encontrada. Recarregue a pÃ¡gina.');
                }
            });
            
            planBtn.dataset.listenerAttached = 'true';
            log('[CORRECTION-PLAN] âœ… Event listener registrado com sucesso!');
        } else {
            warn('[CORRECTION-PLAN] âš ï¸ BotÃ£o nÃ£o encontrado no DOM');
        }
    })();
    
    // ğŸ¯ FIX: Ocultar botÃ£o "Pedir ajuda Ã  IA" e texto de ajuda NO MODO REFERÃŠNCIA
    const currentModeForUI = analysis?.mode || window.currentAnalysisMode || 'genre';
    const btnAskAI = document.getElementById('btnAskAI');
    const aiHelperText = document.getElementById('aiHelperText');
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    
    if (currentModeForUI === 'reference') {
        log('[REFERENCE-UI] ğŸ”’ Modo referÃªncia - ocultando botÃ£o "Pedir ajuda Ã  IA", "Plano de CorreÃ§Ã£o" e texto de ajuda');
        if (btnAskAI) btnAskAI.style.display = 'none';
        if (aiHelperText) aiHelperText.style.display = 'none';
        if (btnCorrectionPlan) btnCorrectionPlan.style.display = 'none';
    } else {
        // ğŸ¯ Garantir visibilidade nos outros modos
        log('[GENRE-UI] âœ… Modo gÃªnero - exibindo botÃ£o "Pedir ajuda Ã  IA", "Plano de CorreÃ§Ã£o" e texto de ajuda');
        if (btnAskAI) btnAskAI.style.display = '';
        if (aiHelperText) aiHelperText.style.display = '';
        if (btnCorrectionPlan) btnCorrectionPlan.style.display = '';
    }
    
    // ğŸ¯ HOOK: Aplicar mÃ¡scaras de Modo Reduzido se necessÃ¡rio
    if (window.__REDUCED_MODE_ACTIVE__ && window.__REDUCED_MODE_ANALYSIS__) {
        log('[REDUCED-MODE] ğŸ”§ Aplicando sistema de mascaramento dinÃ¢mico...');
        
        // Aguardar um frame para garantir que o DOM foi atualizado
        requestAnimationFrame(() => {
            renderReducedModeAdvanced(window.__REDUCED_MODE_ANALYSIS__);
        });
    }
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Normalizar dados do backend para compatibilidade com front-end
    // âœ… PATCH: NormalizaÃ§Ã£o redundante REMOVIDA - dados jÃ¡ normalizados em handleModalFileSelection
    if (analysis && typeof analysis === 'object') {
        log('[AUDITORIA-RMS-LUFS] Verificando estado dos dados (jÃ¡ normalizados):', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.rms': analysis?.technicalData?.rms,
            'energy.rms': analysis?.energy?.rms,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'loudness.integrated': analysis?.loudness?.integrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
        });
        
        // ğŸš« PATCH: NormalizaÃ§Ã£o redundante REMOVIDA para evitar contaminaÃ§Ã£o
        // âŒ analysis = normalizeBackendAnalysisData(analysis);
        log('[NORMALIZE-SKIP] âœ… Evitando re-normalizaÃ§Ã£o destrutiva - dados jÃ¡ normalizados em handleModalFileSelection');
        log('[NORMALIZE-SKIP] âœ… Preservando integridade de referenceComparisonMetrics');
        
        log('[AUDITORIA-RMS-LUFS] Dados preservados:', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'loudness.integrated': analysis?.loudness?.integrated,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp,
            'energy.rms': analysis?.energy?.rms
        });
        log('ğŸ“Š [DEBUG] Dados preservados para exibiÃ§Ã£o:', analysis);
        
        // ğŸ¯ RECALCULAR hasReferenceComparisonMetrics APÃ“S NORMALIZAÃ‡ÃƒO
        const state = window.__soundyState || {};
        state.hasReferenceComparisonMetrics = computeHasReferenceComparisonMetrics(analysis);
        window.__soundyState = state;
        log('[ASSERT] hasReferenceComparisonMetrics recalculado apÃ³s normalizaÃ§Ã£o:', state.hasReferenceComparisonMetrics);
        
        // ğŸ›¡ï¸ PASSO 2: GARANTIR analysis.referenceComparison EXISTE
        if (!analysis.referenceComparison) {
            analysis.referenceComparison = {};
            log('ğŸ›¡ï¸ [PASSO 2] Criado analysis.referenceComparison vazio');
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Preencher targets de GÃŠNERO completos
        const mode = analysis?.mode || currentAnalysisMode || 'genre';
        const isGenreMode = mode === 'genre';
        
        if (isGenreMode) {
            // Obter targets de gÃªnero de mÃºltiplas fontes
            const genreTargets = window.__activeRefData || 
                                window.PROD_AI_REF_DATA?.[analysis.genre] || 
                                window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE] || 
                                {};
            
            log('ğŸ¯ [GENRE-TARGETS-MERGE] Mesclando targets de gÃªnero:', {
                hasGenreTargets: !!genreTargets,
                hasBands: !!(genreTargets.bands),
                source: window.__activeRefData ? '__activeRefData' : 'PROD_AI_REF_DATA'
            });
            
            if (genreTargets && Object.keys(genreTargets).length > 0) {
                // Fonte primÃ¡ria: referenceComparison ou referenceComparisonMetrics
                const src = genreTargets.referenceComparison || 
                           genreTargets.referenceComparisonMetrics || 
                           genreTargets;
                
                // âœ… CRÃTICO: Mesclar TODOS os targets incluindo bandas
                if (src.lufs_target != null)   analysis.referenceComparison.lufs_target   = src.lufs_target;
                if (src.tp_target != null)     analysis.referenceComparison.tp_target     = src.tp_target;
                if (src.dr_target != null)     analysis.referenceComparison.dr_target     = src.dr_target;
                if (src.lra_target != null)    analysis.referenceComparison.lra_target    = src.lra_target;
                if (src.stereo_target != null) analysis.referenceComparison.stereo_target = src.stereo_target;
                
                // âœ… CRÃTICO: Incluir BANDAS de gÃªnero
                if (src.bands && Object.keys(src.bands).length > 0) {
                    analysis.referenceComparison.bands = src.bands;
                    log('âœ… [GENRE-BANDS-MERGED] Bandas de gÃªnero incluÃ­das:', Object.keys(src.bands));
                }
                
                // Marcar como targets de gÃªnero
                analysis.referenceComparison._isGenreMode = true;
                analysis.referenceComparison._genreTargetsLoaded = true;
            } else {
                warn('âš ï¸ [GENRE-TARGETS-MERGE] Targets de gÃªnero nÃ£o encontrados, usando fallback');
                // Fallback com valores padrÃ£o
                if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = -14;
                if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = -1;
                if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = 8;
                if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = 6;
                if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = 0.1;
            }
        } else {
            // Modo referÃªncia: usar fallback simples
            const genreTargets = __activeRefData || {};
            if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = genreTargets.lufs_target ?? -14;
            if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = genreTargets.true_peak_target ?? -1;
            if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = genreTargets.dr_target ?? 8;
            if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = genreTargets.lra_target ?? 6;
            if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = genreTargets.stereo_target ?? 0.1;
        }
        
        log('âœ… [PASSO 2] analysis.referenceComparison garantido:', {
            hasBands: !!analysis.referenceComparison.bands,
            bandsCount: analysis.referenceComparison.bands ? Object.keys(analysis.referenceComparison.bands).length : 0,
            isGenreMode: analysis.referenceComparison._isGenreMode,
            targets: {
                lufs: analysis.referenceComparison.lufs_target,
                tp: analysis.referenceComparison.tp_target,
                dr: analysis.referenceComparison.dr_target
            }
        });
    }
    
    /* =========[ BLOCO: SCORES A/B â€“ substitui 4888â€“5050 ]========= */

    /** UtilitÃ¡rios robustos (nÃ£o colidem com nomes existentes) */
    const __EPS = 1e-3;
    const __DB_EPS = 0.5; // ~0.5 dB para "iguais"
    const __MIN_BANDS = 7;

    function __num(v){ return typeof v === 'number' && isFinite(v); }
    function __ae(a,b,eps=__EPS){ return __num(a) && __num(b) && Math.abs(a-b) <= eps; }
    function __keys(o){ return o ? Object.keys(o) : []; }

    function __getBandsSafe(from) {
      // aceita objetos tipo analysis, referenceFull, technicalData.spectral_balance etc.
      if (!from) return null;

      // 1) caminhos mais provÃ¡veis
      const td = from.technicalData || from.technical_data || null;
      if (td && td.spectral_balance) return td.spectral_balance;
      if (from.metrics && from.metrics.bands) return from.metrics.bands;
      if (from.bands) return from.bands;

      // 2) objetos jÃ¡ no formato bandas
      const maybeBands = (from.sub || from.lowMid || from.low_mid) ? from : null;
      if (maybeBands) return maybeBands;

      return null;
    }

    function __normalizeBandKeys(b) {
      if (!b) return null;
      // normaliza low_mid->lowMid, high_mid->highMid etc.
      const map = {
        sub: 'sub', bass: 'bass',
        low_mid: 'lowMid', lowmid: 'lowMid', lowMid: 'lowMid',
        mid: 'mid',
        high_mid: 'highMid', highmid: 'highMid', highMid: 'highMid',
        presence: 'presence', air: 'air',
        total: 'totalPercentage', total_percentage: 'totalPercentage', totalPercentage: 'totalPercentage',
        _status: '_status'
      };
      const out = {};
      for (const k of Object.keys(b)) {
        const nk = map[k] || k;
        out[nk] = b[k];
      }
      return out;
    }

    function __bandsAreMeaningful(bands) {
      if (!bands) return false;
      const k = __keys(bands).filter(k => ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (k.length < __MIN_BANDS) return false;
      // precisa ter variaÃ§Ã£o real (evita vetor todo zero)
      const vals = k.map(k => bands[k]).filter(__num);
      if (vals.length < __MIN_BANDS) return false;
      const max = Math.max(...vals), min = Math.min(...vals);
      return isFinite(max) && isFinite(min) && (Math.abs(max - min) > 0.2); // >0.2 dB de amplitude mÃ­nima
    }

    function __bandsSimilar(a, b, epsDb = __DB_EPS) {
      if (!a || !b) return false;
      const ak = __keys(a), bk = __keys(b);
      const common = ak.filter(k => bk.includes(k) && ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (common.length < __MIN_BANDS) return false;
      let equal = 0;
      for (const k of common) {
        if (__num(a[k]) && __num(b[k]) && Math.abs(a[k] - b[k]) <= epsDb) equal++;
      }
      return equal >= __MIN_BANDS; // praticamente iguais
    }

    function __tracksLookSame(userTd, refTd, userMd, refMd, userBands, refBands) {
      // ========================================
      // ğŸ”§ CORREÃ‡ÃƒO: DetecÃ§Ã£o segura de self-compare usando jobId e VID
      // ========================================
      // Recuperar objetos completos para acessar jobId e vid
      const userFull = referenceComparisonMetrics?.userFull || {};
      const refFull = referenceComparisonMetrics?.referenceFull || {};
      
      // CritÃ©rio 1: jobId idÃªntico (mais confiÃ¡vel)
      const sameJobId = !!(userFull?.jobId && refFull?.jobId && userFull.jobId === refFull.jobId);
      
      // CritÃ©rio 2: Virtual ID idÃªntico (detecta mesmo jobId::ROLE)
      const sameVid = !!(userFull?.vid && refFull?.vid && userFull.vid === refFull.vid);
      
      // CritÃ©rio 3: Fallback - fileName idÃªntico APENAS se nÃ£o hÃ¡ jobId em nenhum dos dois
      const sameName = (
        !userFull?.jobId && 
        !refFull?.jobId && 
        !!userMd?.fileName && 
        !!refMd?.fileName && 
        userMd.fileName === refMd.fileName
      );
      
      // CritÃ©rios tÃ©cnicos (mantidos para validaÃ§Ã£o adicional)
      const sameLufs = __ae(userTd?.lufsIntegrated, refTd?.lufsIntegrated, 0.05);
      const sameTp   = __ae(userTd?.truePeakDbtp,  refTd?.truePeakDbtp,  0.05);
      const sameDr   = __ae(userTd?.dynamicRange,  refTd?.dynamicRange,  0.1);
      const sameCent = __ae(userTd?.spectralCentroidHz, refTd?.spectralCentroidHz, 5);
      const sameBands = __bandsSimilar(userBands, refBands);
      
      // Self-compare detectado se:
      // 1. jobId idÃªntico OU
      // 2. VID idÃªntico OU
      // 3. Sem jobId em ambos E fileName idÃªntico OU
      // 4. Todas as mÃ©tricas tÃ©cnicas idÃªnticas E bands similares
      const isSelfCompare = sameJobId || sameVid || sameName || (sameLufs && sameTp && sameDr && sameCent && sameBands);
      
      // Log de auditoria
      log("[COMPARE-FLAG] selfCompare:", isSelfCompare, {
        userJobId: userFull?.jobId || 'N/A',
        refJobId: refFull?.jobId || 'N/A',
        sameJobId,
        userVid: userFull?.vid || window.CacheIndex?.USER || 'N/A',
        refVid: refFull?.vid || window.CacheIndex?.REF || 'N/A',
        sameVid,
        userFile: userMd?.fileName || 'N/A',
        refFile: refMd?.fileName || 'N/A',
        sameName,
        technicalMatch: sameLufs && sameTp && sameDr && sameCent && sameBands,
        criteria: {
          sameJobId,
          sameVid,
          sameName,
          sameLufs,
          sameTp,
          sameDr,
          sameCent,
          sameBands
        }
      });
      
      return isSelfCompare;
    }

    /** 1) Extrai estruturas normalizadas que jÃ¡ existem nesse ponto do fluxo */
    // ğŸ”§ FIX CRÃTICO: Mudado de const para let para permitir recuperaÃ§Ã£o em caso de contaminaÃ§Ã£o
    let userFull  = referenceComparisonMetrics?.userFull;       // 1Âª faixa (sua mÃºsica)
    let refFull   = referenceComparisonMetrics?.referenceFull;  // 2Âª faixa (referÃªncia)
    
    // ï¿½ HARD-GUARD: Se userFull estÃ¡ undefined, recuperar de FirstAnalysisStore.get()
    if (!userFull && FirstAnalysisStore.has()) {
        warn('[SAFEGUARD] userFull estÃ¡ undefined â€” recuperando de FirstAnalysisStore');
        userFull = structuredClone(FirstAnalysisStore.get());
        log('[SAFEGUARD] âœ… userFull recuperado:', {
            fileName: userFull?.metadata?.fileName,
            jobId: userFull?.jobId
        });
    }

    let userTd    = referenceComparisonMetrics?.userTrack   || {};
    let refTd     = referenceComparisonMetrics?.referenceTrack || {};
    let userMd    = userFull?.metadata || {};
    let refMd     = refFull?.metadata  || {};

    // bandas A/B normalizadas + keys padronizadas
    let userBands = __normalizeBandKeys(__getBandsSafe(userFull));
    let refBands  = __normalizeBandKeys(__getBandsSafe(refFull));

    /** 2) Hard-gates antes de montar o objeto de score */
    const isReferenceMode = !!(referenceComparisonMetrics && referenceComparisonMetrics.reference);
    
    // ğŸ” LOG DE VERIFICAÃ‡ÃƒO MÃNIMO (temporÃ¡rio - conforme item 7 do plano)
    log('[AB-CHECK]', {
        userJobId: userFull?.jobId,
        refJobId: refFull?.jobId,
        userName: userFull?.metadata?.fileName,
        refName: refFull?.metadata?.fileName
    });
    
    // âœ… PATCH: ValidaÃ§Ã£o de integridade ANTES de calcular selfCompare
    log('[INTEGRITY-CHECK] Validando dados antes de calcular score:', {
        userFileName: userMd.fileName,
        refFileName: refMd.fileName,
        userLUFS: userTd.lufsIntegrated,
        refLUFS: refTd.lufsIntegrated,
        sameFile: userMd.fileName === refMd.fileName,
        sameLUFS: userTd.lufsIntegrated && refTd.lufsIntegrated ? 
            Math.abs(userTd.lufsIntegrated - refTd.lufsIntegrated) < 0.05 : false
    });
    
    // ğŸš¨ PATCH: Alerta crÃ­tico se arquivos sÃ£o iguais (contaminaÃ§Ã£o detectada)
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        error('[INTEGRITY-CHECK] âŒ FALHA CRÃTICA: userFile === refFile');
        error('[INTEGRITY-CHECK] âŒ ProvÃ¡vel contaminaÃ§Ã£o de dados!');
        error('[INTEGRITY-CHECK] âŒ Tentando recuperar de state.previousAnalysis...');
        
        // Tentar recuperar userFull de previousAnalysis
        if (state.previousAnalysis.metadata?.fileName !== refMd.fileName) {
            warn('[INTEGRITY-CHECK] âš ï¸ Recuperando userFull de state.previousAnalysis');
            
            // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: SEMPRE usar clone para evitar contaminaÃ§Ã£o de ponteiros
            log('[SAFEGUARD] Clonando state.previousAnalysis para evitar referÃªncia compartilhada');
            const recoveredUserFull = structuredClone(state.previousAnalysis);
            const recoveredUserMd = recoveredUserFull.metadata || {};
            const recoveredUserTd = recoveredUserFull.technicalData || {};
            const recoveredUserBands = __normalizeBandKeys(__getBandsSafe(recoveredUserFull));
            
            // Reatribuir variÃ¡veis recuperadas
            userFull = recoveredUserFull;
            userMd = recoveredUserMd;
            userTd = recoveredUserTd;
            userBands = recoveredUserBands;
            
            log('[INTEGRITY-CHECK] âœ… Dados recuperados de state.previousAnalysis:', {
                fileName: recoveredUserMd.fileName,
                lufs: recoveredUserTd.lufsIntegrated
            });
        }
    }
    
    // ğŸ” AUDITORIA: Estado ANTES de calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ğŸ¯ ANTES de __tracksLookSame (selfCompare)');
    log('âš™ï¸ Contexto: Prestes a calcular selfCompare');
    log('ğŸ“Š userMd (1Âª faixa metadata):', {
        fileName: userMd?.fileName,
        objectId: userMd
    });
    log('ğŸ“Š refMd (2Âª faixa metadata):', {
        fileName: refMd?.fileName,
        objectId: refMd
    });
    log('ğŸ“Š userTd (1Âª faixa technicalData):', {
        lufs: userTd?.lufsIntegrated,
        dr: userTd?.dynamicRange,
        objectId: userTd
    });
    log('ğŸ“Š refTd (2Âª faixa technicalData):', {
        lufs: refTd?.lufsIntegrated,
        dr: refTd?.dynamicRange,
        objectId: refTd
    });
    log('ğŸ“Š userFull (origem):', {
        fileName: userFull?.metadata?.fileName,
        jobId: userFull?.jobId,
        objectId: userFull
    });
    log('ğŸ“Š refFull (origem):', {
        fileName: refFull?.metadata?.fileName,
        jobId: refFull?.jobId,
        objectId: refFull
    });
    log('âš ï¸ PRÃ‰-VERIFICAÃ‡ÃƒO DE CONTAMINAÃ‡ÃƒO:');
    log('  userMd.fileName === refMd.fileName?', userMd?.fileName === refMd?.fileName);
    log('  userFull === refFull?', userFull === refFull);
    log('  userTd === refTd?', userTd === refTd);
    console.groupEnd();
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Detectar e corrigir contaminaÃ§Ã£o ANTES de __tracksLookSame
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        warn('[FIX] ğŸš¨ DetecÃ§Ã£o de self-compare FALSO â€“ isolando referenceAnalysis');
        warn('[FIX] userFull foi contaminado com dados de refFull');
        warn('[FIX] Tentando recuperar de FirstAnalysisStore...');
        
        // ï¿½ HARD-GUARD: SEMPRE usar FirstAnalysisStore.get() como fonte confiÃ¡vel
        if (!FirstAnalysisStore.has()) {
            error('[FIX] âŒ FirstAnalysisStore vazio! Abortando recuperaÃ§Ã£o...');
            return;
        }
        
        // Recuperar primeira anÃ¡lise de fonte confiÃ¡vel (APENAS FirstAnalysisStore)
        const safeUserFull = structuredClone(FirstAnalysisStore.get());
        userFull = safeUserFull;
        userMd = safeUserFull.metadata || {};
        userTd = safeUserFull.technicalData || {};
        userBands = __normalizeBandKeys(__getBandsSafe(safeUserFull));
        
        log('[FIX] âœ… userFull recuperado:', {
            fileName: userMd.fileName,
            lufs: userTd.lufsIntegrated,
            source: 'FirstAnalysisStore'
        });
    }
    
    // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO FINAL: Garantir que userFull e refFull sÃ£o DIFERENTES apÃ³s todas as recuperaÃ§Ãµes
    console.group('ğŸ” [FINAL VALIDATION] VerificaÃ§Ã£o final de contaminaÃ§Ã£o');
    log('userMd.fileName:', userMd?.fileName);
    log('refMd.fileName:', refMd?.fileName);
    log('userFull.jobId:', userFull?.jobId);
    log('refFull.jobId:', refFull?.jobId);
    log('userFull === refFull?', userFull === refFull);
    log('userMd === refMd?', userMd === refMd);
    log('userTd === refTd?', userTd === refTd);
    log('userBands === refBands?', userBands === refBands);
    console.groupEnd();
    
    // âœ… VALIDAÃ‡ÃƒO FINAL: Log apenas, nÃ£o bloqueia renderizaÃ§Ã£o
    if (userMd?.fileName === refMd?.fileName || userFull?.jobId === refFull?.jobId) {
        warn('[INFO] âš ï¸ Mesmo jobId/fileName detectado (self-compare falso). Continuando render normalmente.');
        warn('[INFO] userMd.fileName:', userMd?.fileName);
        warn('[INFO] refMd.fileName:', refMd?.fileName);
        warn('[INFO] userFull.jobId:', userFull?.jobId);
        warn('[INFO] refFull.jobId:', refFull?.jobId);
        // âœ… NÃƒO RETORNA AQUI! Continua o fluxo para permitir renderizaÃ§Ã£o
    } else {
        log('[FINAL VALIDATION] âœ… Dados validados - userFull e refFull sÃ£o DIFERENTES');
    }
    
    // âœ… STEP 6/6 (FINAL): Integrity check - apenas log, nÃ£o bloqueia
    if (areSameTrack(userFull, refFull)) {
        warn('[INFO] âš ï¸ areSameTrack() retornou true (self-compare falso). Continuando render normalmente.');
        // âœ… NÃƒO RETORNA AQUI! Continua o fluxo para permitir renderizaÃ§Ã£o
    } else {
        log('[INTEGRITY CHECK] âœ… userFull e refFull sÃ£o diferentes â€” prosseguindo com cÃ¡lculo');
    }
    
    // ğŸ¯ ROOT CAUSE FIX: Detectar modo gÃªnero ANTES de calcular refBandsOK
    // Em modo gÃªnero, refBands vem de genreTargets, NÃƒO de referenceAnalysis!
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    let finalRefBands = refBands;
    
    if (isGenreMode) {
        log('ğŸ¯ [GENRE-BANDS-FIX] Modo GÃŠNERO detectado - buscando bandas de genreTargets');
        
        // Buscar bandas dos targets de gÃªnero carregados
        const genreTargets = window.__activeRefData || 
                           analysis?.referenceComparison || 
                           (analysis?.genre ? window.PROD_AI_REF_DATA?.[analysis.genre] : null);
        
        if (genreTargets) {
            // Tentar extrair bandas de diferentes estruturas possÃ­veis
            finalRefBands = genreTargets.bands || 
                          genreTargets.legacy_compatibility?.bands ||
                          genreTargets.hybrid_processing?.spectral_bands ||
                          null;
            
            log('ğŸ¯ [GENRE-BANDS-FIX] Bandas de gÃªnero encontradas:', {
                source: genreTargets.bands ? 'bands' : 
                       genreTargets.legacy_compatibility?.bands ? 'legacy_compatibility.bands' :
                       genreTargets.hybrid_processing?.spectral_bands ? 'hybrid_processing.spectral_bands' : 'null',
                bands: finalRefBands ? Object.keys(finalRefBands) : 'null',
                genre: analysis?.genre
            });
        } else {
            warn('âš ï¸ [GENRE-BANDS-FIX] Targets de gÃªnero NÃƒO encontrados! refBands serÃ¡ null');
        }
    } else {
        log('ğŸ”„ [AB-MODE] Modo A/B detectado - usando refBands de referenceAnalysis');
    }
    
    const selfCompare = __tracksLookSame(userTd, refTd, userMd, refMd, userBands, finalRefBands);
    const refBandsOK  = __bandsAreMeaningful(finalRefBands);
    const userBandsOK = __bandsAreMeaningful(userBands);

    // ğŸ§ª MODO VERIFICAÃ‡ÃƒO: Log estruturado com console.table
    console.table({
        'userFile': userMd?.fileName || 'N/A',
        'refFile': refMd?.fileName || 'N/A',
        'sameFile': userMd?.fileName === refMd?.fileName,
        'userJobId': userFull?.jobId || 'N/A',
        'refJobId': refFull?.jobId || 'N/A',
        'sameJobId': userFull?.jobId === refFull?.jobId,
        'userLUFS': userTd?.lufsIntegrated || 'N/A',
        'refLUFS': refTd?.lufsIntegrated || 'N/A',
        'userBandsOK': userBandsOK,
        'refBandsOK': refBandsOK,
        'isGenreMode': isGenreMode,
        'finalRefBands': finalRefBands ? 'OK' : 'null'
    });
    
    log('[VERIFY_AB_ORDER]', {
      mode: state.render.mode,
      isGenreMode: isGenreMode,
      userFile: userMd.fileName, refFile: refMd.fileName,
      userLUFS: userTd.lufsIntegrated, refLUFS: refTd.lufsIntegrated,
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      refBands: refBandsOK  ? __keys(finalRefBands)  : 'ausente',
      selfCompare
    });
    
    // ğŸ” AUDITORIA: Estado APÃ“S calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… DEPOIS de __tracksLookSame');
    log('âš™ï¸ Contexto: selfCompare calculado');
    log('ğŸ¯ selfCompare:', selfCompare);
    log('ğŸ¯ refBandsOK:', refBandsOK);
    log('ğŸ¯ userBandsOK:', userBandsOK);
    log('ğŸ¯ disableFrequency serÃ¡:', !refBandsOK || !userBandsOK || selfCompare);
    if (selfCompare) {
        warn('âš ï¸ selfCompare TRUE detectado - score serÃ¡ 100%');
        warn('âš ï¸ Verificar se Ã© legÃ­timo (mesma faixa 2x) ou contaminaÃ§Ã£o');
    }
    console.groupEnd();

    /** 2.5) FUNÃ‡ÃƒO CRÃTICA: Injetar targets de gÃªnero em refData */
    function injectGenreTargetsIntoRefData(refData, genreTargets) {
        if (!refData || !genreTargets) return refData;
        
        const fields = [
            "lufs_target",
            "true_peak_target",
            "dr_target",
            "lra_target",
            "stereo_target",
            "bands",
            "tol_lufs",
            "tol_true_peak",
            "tol_dr",
            "tol_lra",
            "tol_stereo"
        ];
        
        fields.forEach(key => {
            if (genreTargets[key] !== undefined) {
                refData[key] = genreTargets[key];
            }
        });
        
        log("[GENRE-FIX] Targets injetados em refData:", {
            lufs_target: refData.lufs_target,
            true_peak_target: refData.true_peak_target,
            dr_target: refData.dr_target,
            stereo_target: refData.stereo_target,
            hasBands: !!refData.bands,
            bandsCount: refData.bands ? Object.keys(refData.bands).length : 0
        });
        
        return refData;
    }

    /** 3) Se referÃªncia nÃ£o Ã© vÃ¡lida ou A==B, rebaixa o score de frequÃªncia via "disable" e re-normaliza pesos */
    let disableFrequency = false;
    let referenceDataForScores = null;

    if (!refBandsOK || !userBandsOK || selfCompare) {
      disableFrequency = true;
      warn('âš ï¸ [SCORES-GUARD] Desativando score de FrequÃªncia:',
        { refBandsOK, userBandsOK, selfCompare, isGenreMode });

      // monta alvo somente com mÃ©tricas escalares (sem bandas)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: null, // forÃ§a desativado
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _disabledBands: true
      };
    } else {
      // fluxo normal (A/B saudÃ¡vel OU modo gÃªnero com targets)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: finalRefBands, // <- bandas reais (de referÃªncia A/B ou gÃªnero)
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _referenceAnalysisFull: refFull // ğŸ¯ PATCH: anÃ¡lise completa de referÃªncia para extraÃ§Ã£o de bandas no subscore
      };
    }

    log('[SCORE-FIX] Bandas preparadas p/ cÃ¡lculo:', {
      disableFrequency, 
      refBands: referenceDataForScores.bands ? __keys(referenceDataForScores.bands) : 'desativado',
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      isGenreMode: isGenreMode
    });

    /** 4) CÃ¡lculo seguro com proteÃ§Ã£o de tolerÃ¢ncia e re-balanceamento de pesos */
    function __safeCalculateAnalysisScores(analysisObj, refData, genre) {
      // Protege tolerÃ¢ncias (evita tolDb=0)
      if (!refData || typeof refData !== 'object') refData = {};
      if (!__num(refData.tol_spectral) || refData.tol_spectral <= 0) refData.tol_spectral = 300;

      // ğŸ¯ CORREÃ‡ÃƒO: Detectar modo gÃªnero e targets de mÃºltiplas fontes
      const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
      
      // ğŸ¯ CORREÃ‡ÃƒO: Buscar targets de gÃªnero de todas as fontes possÃ­veis
      const genreTargets = window.__activeRefData || 
                          window.PROD_AI_REF_DATA?.[analysisObj?.genre] || 
                          window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE];
      
      const genreBands = genreTargets?.bands || 
                        genreTargets?.referenceComparison?.bands ||
                        analysisObj?.referenceComparison?.bands;
      
      // âœ… CRÃTICO: hasGenreTargets deve ser true se houver targets ou bandas
      const hasGenreTargets = isGenreMode && (
        !!genreTargets || 
        !!(analysisObj?.referenceComparison?._genreTargetsLoaded) ||
        !!(analysisObj?.referenceComparison?.bands)
      );
      
      const hasRefBands = !!(genreBands && Object.keys(genreBands).length > 0);
      const refBandsOK = hasRefBands;
      
      log('ğŸ” [SCORES-GUARD-ENHANCED]', {
        isGenreMode,
        hasGenreTargets,
        hasRefBands,
        refBandsOK,
        analysisMode: analysisObj?.mode,
        viewMode: window.__soundyState?.render?.mode,
        refDataHasBands: !!(refData?.bands),
        genreTargetsFound: !!genreTargets,
        genreBandsCount: genreBands ? Object.keys(genreBands).length : 0,
        isReferenceMode: refData?._isReferenceMode,
        disabledBands: refData?._disabledBands
      });

      // Chama o cÃ¡lculo original
      const out = calculateAnalysisScores(analysisObj, refData, genre) || {};

      // ğŸ¯ DECISÃƒO DE DESATIVAR FREQUÃŠNCIA:
      // - Modo REFERENCE: desativar se !refData.bands ou _disabledBands
      // - Modo GENRE: NÃƒO desativar se houver targets de gÃªnero carregados
      const shouldDisableFrequency = isGenreMode 
        ? (!hasGenreTargets && (!refData.bands || refData._disabledBands)) // Modo gÃªnero: sÃ³ desativar se NÃƒO houver targets
        : (!refData.bands || refData._disabledBands); // Modo reference: desativar se sem bandas A/B
      
      if (shouldDisableFrequency) {
        const subs = out.subscores || out; // compat: alguns retornam direto
        const weights = {
          loudness: 0.32, dinamica: 0.23, frequencia: 0.0, estereo: 0.15, tecnico: 0.30 // soma = 1.0
        };
        // recomputa final de forma defensiva
        const lv = __num(subs.loudness)   ? subs.loudness   : 0;
        const dv = __num(subs.dinamica)   ? subs.dinamica   : 0;
        const ev = __num(subs.estereo)    ? subs.estereo    : 0;
        const tv = __num(subs.tecnico)    ? subs.tecnico    : 0;
        const final = Math.round(
          lv*weights.loudness + dv*weights.dinamica + ev*weights.estereo + tv*weights.tecnico
        );
        out.final = final;
        out._weightsApplied = weights;
        out._freqDisabled = true;
        warn('âš ï¸ [SCORES-GUARD] FrequÃªncia desativada â‡’ pesos re-normalizados', weights);
      } else if (isGenreMode && hasGenreTargets) {
        log('âœ… [SCORES-GUARD] Modo GÃŠNERO: FrequÃªncia ATIVADA (targets de gÃªnero disponÃ­veis)');
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸš¨ V3.4: GATES PROPORCIONAIS (substituem caps fixos)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const techData = analysisObj?.technicalData || analysisObj?.metrics || {};
      const truePeak = techData.truePeakDbtp ?? techData.true_peak_dbtp ?? null;
      const clipping = techData.clippingPct ?? techData.clipping_pct ?? 0;
      const dcOffset = Math.abs(techData.dcOffset ?? techData.dc_offset ?? 0);
      const lufs = techData.lufsIntegrated ?? techData.lufs_integrated ?? null;
      
      // Determinar modo e targets
      const mode = window.__soundyState?.render?.mode || 'streaming';
      const MODE_TARGETS = {
        streaming: { truePeak: { target: -1.0, max: -1.0 }, lufs: { target: -14.0, max: -12.0 } },
        pista: { truePeak: { target: -0.3, max: 0.0 }, lufs: { target: -9.0, max: -6.0 } },
        reference: { truePeak: { target: -1.0, max: 0.0 }, lufs: { target: -14.0, max: -8.0 } }
      };
      const targets = MODE_TARGETS[mode] || MODE_TARGETS.streaming;
      const tpMax = targets.truePeak?.max ?? 0;
      const tpTarget = targets.truePeak?.target ?? tpMax;
      const lufsMax = targets.lufs?.max ?? -12;
      const lufsTarget = targets.lufs?.target ?? -14;
      
      // ğŸ¯ V3.4: FunÃ§Ã£o de cap PROPORCIONAL para True Peak
      // Quanto mais passou do limite, menor o cap (mas NUNCA fixo em 35)
      function calculateTruePeakCap(tp, max, target) {
        if (tp === null) return 100;
        
        const excess = tp - max; // Quanto passou do mÃ¡ximo
        
        if (excess <= 0) return 100; // Dentro do limite
        
        // Escala proporcional: +0.1 = 90%, +0.5 = 75%, +1.0 = 60%, +2.0 = 45%, +3.0 = 35%
        // FÃ³rmula: cap = 95 - (excess * 20), com mÃ­nimo de 35
        const cap = Math.max(35, Math.round(95 - (excess * 20)));
        return cap;
      }
      
      // ğŸ¯ V3.4: FunÃ§Ã£o de cap PROPORCIONAL para LUFS
      function calculateLufsCap(lufsValue, max, target) {
        if (lufsValue === null) return 100;
        
        const excess = lufsValue - max; // Quanto passou do mÃ¡ximo (valores mais altos = piores)
        
        if (excess <= 0) return 100; // Dentro do limite
        
        // Escala proporcional: +1 LU = 90%, +2 LU = 80%, +4 LU = 65%, +6 LU = 50%
        // FÃ³rmula: cap = 95 - (excess * 7.5), com mÃ­nimo de 50
        const cap = Math.max(50, Math.round(95 - (excess * 7.5)));
        return cap;
      }
      
      // Preservar score bruto SEMPRE
      const finalRaw = out.final;
      out.finalRaw = finalRaw;
      
      let gatesTriggered = [];
      let caps = [];
      
      // GATE #1: TRUE PEAK (proporcional ao excesso)
      if (truePeak !== null && truePeak > tpMax) {
        const tpCap = calculateTruePeakCap(truePeak, tpMax, tpTarget);
        const excess = truePeak - tpMax;
        const severity = truePeak > 0 ? 'CRITICAL' : (excess > 0.5 ? 'HIGH' : 'MODERATE');
        
        caps.push(tpCap);
        gatesTriggered.push({ 
          type: `TRUE_PEAK_${severity}`, 
          value: truePeak, 
          limit: tpMax,
          excess: excess.toFixed(2),
          cap: tpCap,
          description: `True Peak ${truePeak.toFixed(2)} dBTP (+${excess.toFixed(2)} dB acima do limite)`
        });
        warn(`[V3-GATE] âš ï¸ TRUE PEAK ${severity}: ${truePeak.toFixed(2)} dBTP (excesso: +${excess.toFixed(2)} dB) â†’ cap ${tpCap}%`);
      }
      
      // GATE #2: CLIPPING SEVERO (> 5%) - mantÃ©m proporcional
      if (clipping > 5) {
        const clipCap = Math.max(30, Math.round(80 - (clipping - 5) * 4));
        caps.push(clipCap);
        gatesTriggered.push({ 
          type: 'CLIPPING_SEVERE', 
          value: clipping, 
          cap: clipCap,
          description: `Clipping ${clipping.toFixed(2)}% (aceitÃ¡vel: < 5%)`
        });
        warn(`[V3-GATE] âš ï¸ CLIPPING SEVERO: ${clipping.toFixed(2)}% â†’ cap ${clipCap}%`);
      }
      
      // GATE #3: LUFS EXCESSIVO (proporcional ao excesso)
      if (lufs !== null && lufs > lufsMax) {
        const lufsCap = calculateLufsCap(lufs, lufsMax, lufsTarget);
        const excess = lufs - lufsMax;
        
        caps.push(lufsCap);
        gatesTriggered.push({ 
          type: 'LUFS_EXCESSIVE', 
          value: lufs, 
          limit: lufsMax,
          excess: excess.toFixed(1),
          cap: lufsCap,
          description: `LUFS ${lufs.toFixed(1)} (+${excess.toFixed(1)} LU acima do limite)`
        });
        warn(`[V3-GATE] âš ï¸ LUFS EXCESSIVO: ${lufs.toFixed(1)} (excesso: +${excess.toFixed(1)} LU) â†’ cap ${lufsCap}%`);
      }
      
      // APLICAR MENOR CAP (se houver gates)
      if (caps.length > 0) {
        const scoreCap = Math.min(...caps);
        
        if (out.final > scoreCap) {
          warn(`[V3-GATE] ğŸ“‰ Score capado: ${out.final}% â†’ ${scoreCap}%`);
          out.final = scoreCap;
          out._scoreCapped = true;
        }
      }
      
      // Preservar metadados de gates
      out._gatesTriggered = gatesTriggered;
      out._capsApplied = caps;
      
      // Log de diagnÃ³stico
      log('[V3-GATE] ğŸ“Š DiagnÃ³stico V3.4:', {
        truePeak, tpMax, tpTarget,
        lufs, lufsMax, lufsTarget,
        clipping,
        mode,
        finalRaw,
        finalCapped: out.final,
        gatesTriggered: gatesTriggered.map(g => `${g.type}: cap ${g.cap}%`),
        scoreCapped: out._scoreCapped || false
      });

      return out;
    }

    /** 5) EXECUTA o cÃ¡lculo com o objeto blindado */
    const detectedGenre = analysis.metadata?.genre || analysis.genre || __activeRefGenre;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” PARTE 4: TESTE DE INSPEÃ‡ÃƒO OBRIGATÃ“RIO (PRÃ‰-CÃLCULO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.group("ğŸ” [AUDIT-BACKEND-FLOW] MÃ‰TRICAS RECEBIDAS DO BACKEND");
    log("ğŸ“Š analysis.technicalData:", analysis.technicalData);
    log("ğŸ“Š analysis.metrics:", analysis.metrics);
    log("ğŸ”‘ Keys technicalData:", Object.keys(analysis.technicalData || {}));
    log("ğŸ”‘ Keys metrics:", Object.keys(analysis.metrics || {}));
    log("ğŸ“ MÃ©tricas especÃ­ficas:");
    log("  - technicalData.lufsIntegrated:", analysis.technicalData?.lufsIntegrated);
    log("  - metrics.lufs_integrated:", analysis.metrics?.lufs_integrated);
    log("  - technicalData.truePeakDbtp:", analysis.technicalData?.truePeakDbtp);
    log("  - metrics.true_peak_dbtp:", analysis.metrics?.true_peak_dbtp);
    log("  - technicalData.dynamicRange:", analysis.technicalData?.dynamicRange);
    log("  - metrics.dynamic_range:", analysis.metrics?.dynamic_range);
    log("  - technicalData.lra:", analysis.technicalData?.lra);
    log("  - metrics.lra:", analysis.metrics?.lra);
    log("  - technicalData.stereoCorrelation:", analysis.technicalData?.stereoCorrelation);
    log("  - metrics.stereo_correlation:", analysis.metrics?.stereo_correlation);
    log("  - technicalData.stereoWidth:", analysis.technicalData?.stereoWidth);
    log("  - metrics.stereo_width:", analysis.metrics?.stereo_width);
    log("ğŸ“Œ Targets para cÃ¡lculo (refData):");
    log("  - lufs_target:", referenceDataForScores?.lufs_target);
    log("  - true_peak_target:", referenceDataForScores?.true_peak_target);
    log("  - dr_target:", referenceDataForScores?.dr_target);
    log("  - lra_target:", referenceDataForScores?.lra_target);
    log("  - stereo_target:", referenceDataForScores?.stereo_target);
    log("  - bands:", referenceDataForScores?.bands ? Object.keys(referenceDataForScores.bands) : 'null');
    console.groupEnd();
    
    // ğŸ¯ [GENRE-FIX] CRÃTICO: Aplicar targets de gÃªnero SOMENTE no modo genre
    // âš ï¸ NUNCA AFETA MODO REFERENCE
    if (isGenreMode) {
        log("[GENRE-FIX] âœ… Modo genre detectado - aplicando targets oficiais");
        
        // ğŸ¯ USAR NOVA FUNÃ‡ÃƒO: extractGenreTargets (FONTE OFICIAL)
        const officialGenreTargets = extractGenreTargets(analysis);
        
        if (officialGenreTargets) {
            log("[GENRE-FIX] âœ… Targets encontrados em analysis.data.genreTargets (FONTE OFICIAL)");
            log("[GENRE-FIX] Targets:", {
                lufs_target: officialGenreTargets.lufs_target,
                true_peak_target: officialGenreTargets.true_peak_target,
                dr_target: officialGenreTargets.dr_target,
                stereo_target: officialGenreTargets.stereo_target,
                hasBands: !!officialGenreTargets.bands,
                bandsCount: officialGenreTargets.bands ? Object.keys(officialGenreTargets.bands).length : 0
            });
            
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, officialGenreTargets);
        } else if (window.__activeRefData) {
            // ğŸ¯ FALLBACK: Usar window.__activeRefData apenas se nÃ£o houver targets oficiais
            warn("[GENRE-FIX] âš ï¸ FALLBACK: Usando window.__activeRefData");
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, window.__activeRefData);
        } else {
            // ğŸ¯ FALLBACK FINAL: Carregar defaults
            warn("[GENRE-FIX] âš ï¸ Nenhum target encontrado - carregando defaults");
            const defaultTargets = loadDefaultGenreTargets(extractGenreName(analysis));
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, defaultTargets);
        }
    }
    // ğŸ›¡ï¸ MODO REFERENCE: NÃ£o fazer NADA - referenceDataForScores permanece intacto
    
    // ğŸ¯ [FLOW-FIX] Calculando scores APÃ“S normalizaÃ§Ã£o de mÃ©tricas
    log("[FLOW-FIX] Calculando scores APÃ“S normalizaÃ§Ã£o de mÃ©tricas.");
    
    const analysisScores = __safeCalculateAnalysisScores(analysis, referenceDataForScores, detectedGenre);

    if (analysisScores) {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ” TAREFA 1: AUDITORIA COMPLETA DA ESTRUTURA DE SCORES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.group('ğŸ” [AUDIT-SCORES] ESTRUTURA COMPLETA DE analysisScores');
        log('[AUDIT-SCORES] analysisScores bruto:', analysisScores);
        log('[AUDIT-SCORES] keys:', Object.keys(analysisScores || {}));
        log('[AUDIT-SCORES] Subscores individuais:');
        log('  - analysisScores.loudness:', analysisScores.loudness);
        log('  - analysisScores.dinamica:', analysisScores.dinamica);
        log('  - analysisScores.dynamics:', analysisScores.dynamics);
        log('  - analysisScores.estereo:', analysisScores.estereo);
        log('  - analysisScores.stereo:', analysisScores.stereo);
        log('  - analysisScores.frequency:', analysisScores.frequency);
        log('  - analysisScores.frequencia:', analysisScores.frequencia);
        log('  - analysisScores.technical:', analysisScores.technical);
        log('  - analysisScores.tecnico:', analysisScores.tecnico);
        log('  - analysisScores.subscores (objeto):', analysisScores.subscores);
        if (analysisScores.subscores) {
            log('    â†’ subscores.loudness:', analysisScores.subscores.loudness);
            log('    â†’ subscores.dynamics:', analysisScores.subscores.dynamics);
            log('    â†’ subscores.stereo:', analysisScores.subscores.stereo);
            log('    â†’ subscores.frequency:', analysisScores.subscores.frequency);
            log('    â†’ subscores.technical:', analysisScores.subscores.technical);
        }
        log('  - analysisScores.breakdown:', analysisScores.breakdown);
        log('  - analysisScores.final:', analysisScores.final);
        log('  - analysisScores.composite:', analysisScores.composite);
        
        // ğŸ” PARTE 5: DIAGNÃ“STICO FINAL - Identificar subscores NULL
        const nullScores = [];
        if (analysisScores.loudness === null || analysisScores.loudness === undefined) nullScores.push('loudness');
        if (analysisScores.dinamica === null || analysisScores.dinamica === undefined) nullScores.push('dinamica');
        if (analysisScores.estereo === null || analysisScores.estereo === undefined) nullScores.push('estereo');
        if (analysisScores.frequencia === null || analysisScores.frequencia === undefined) nullScores.push('frequencia');
        if (analysisScores.tecnico === null || analysisScores.tecnico === undefined) nullScores.push('tecnico');
        
        if (nullScores.length > 0) {
            error('âŒ [AUDIT-SCORES] SUBSCORES NULL DETECTADOS:', nullScores);
            error('âš ï¸ [AUDIT-SCORES] Causa provÃ¡vel: mÃ©tricas ausentes em analysis.metrics ou analysis.technicalData');
        } else {
            log('âœ… [AUDIT-SCORES] TODOS OS SUBSCORES SÃƒO VÃLIDOS');
        }
        console.groupEnd();
        
        // Adicionar scores Ã  anÃ¡lise
        analysis.scores = analysisScores;
        log('âœ… Scores calculados e adicionados Ã  anÃ¡lise');
        
        // TambÃ©m armazenar globalmente
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_SCORES__ = analysisScores;
        }
    } else {
        warn('âš ï¸ NÃ£o foi possÃ­vel calcular scores (dados insuficientes)');
    }

    /* =========[ /BLOCO: SCORES A/B ]========= */
    
    // ğŸ”¥ REMOVIDO: Modal jÃ¡ foi aberto no inÃ­cio da funÃ§Ã£o (linha 8350)
    // Remover duplicaÃ§Ã£o de abertura do modal que estava causando problemas no modo gÃªnero
    
    // ğŸ¯ NOVO: Verificar se Ã© modo referÃªncia e adicionar seÃ§Ã£o de comparaÃ§Ã£o
    if (analysis.analysisMode === 'reference' && analysis.comparison) {
        addReferenceComparisonSection(analysis);
    }
    
    // Marcar se pacote avanÃ§ado chegou (LUFS integrado + Pico Real + LRA)
    // ğŸ” AUDITORIA: Verificar mÃºltiplos caminhos para lufsIntegrated e truePeakDbtp
    const lufsValue = analysis?.technicalData?.lufs_integrated ?? 
                     analysis?.technicalData?.lufsIntegrated ??
                     analysis?.metrics?.loudness?.integrated ??
                     analysis?.loudness?.integrated;
    
    const truePeakValue = analysis?.technicalData?.truePeakDbtp ??
                         analysis?.truePeak?.maxDbtp;
    
    const advancedReady = (
        Number.isFinite(lufsValue) && Number.isFinite(truePeakValue)
    );
    
    // ğŸ¯ LOGS DE DIAGNÃ“STICO - MÃ‰TRICAS PRINCIPAIS
    log('[METRICS-FIX] advancedReady:', advancedReady);
    log('[METRICS-FIX] LUFS=', lufsValue, {
        'technicalData.lufs_integrated': analysis?.technicalData?.lufs_integrated,
        'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
        'metrics.loudness.integrated': analysis?.metrics?.loudness?.integrated,
        'loudness.integrated': analysis?.loudness?.integrated
    });
    log('[METRICS-FIX] TRUEPEAK=', truePeakValue, {
        'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
        'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
    });
    
    if (typeof window !== 'undefined') window.__AUDIO_ADVANCED_READY__ = advancedReady;

    // Helpers seguros com bloqueio de fallback se advanced nÃ£o pronto
    const safeFixed = (v, d=1) => (Number.isFinite(v) ? v.toFixed(d) : 'â€”');
    const safeHz = (v) => (Number.isFinite(v) ? `${Math.round(v)} Hz` : 'â€”');
    const pct = (v, d=0) => (Number.isFinite(v) ? `${(v*100).toFixed(d)}%` : 'â€”');
    const tonalSummary = (tb) => {
        if (!tb || typeof tb !== 'object') return 'â€”';
        const parts = [];
        if (tb.sub && Number.isFinite(tb.sub.rms_db)) parts.push(`Sub ${tb.sub.rms_db.toFixed(1)}dB`);
        if (tb.low && Number.isFinite(tb.low.rms_db)) parts.push(`Low ${tb.low.rms_db.toFixed(1)}dB`);
        if (tb.mid && Number.isFinite(tb.mid.rms_db)) parts.push(`Mid ${tb.mid.rms_db.toFixed(1)}dB`);
        if (tb.high && Number.isFinite(tb.high.rms_db)) parts.push(`High ${tb.high.rms_db.toFixed(1)}dB`);
        return parts.length ? parts.join(' â€¢ ') : 'â€”';
    };

        // Layout com cards e KPIs, mantendo o container #modalTechnicalData
        
        // ğŸ”’ SISTEMA DE RENDERIZAÃ‡ÃƒO SEGURA (usando SecureRenderUtils)
        const isReducedModeSecure = (typeof window !== 'undefined' && window.SecureRenderUtils) 
            ? window.SecureRenderUtils.isReducedMode(analysis)
            : false;
        
        log('[SECURE-RENDER-INTEGRATION] Modo Reduced:', isReducedModeSecure);
        
        const kpi = (value, label, cls='', metricKey='', section='primary') => {
            // Se SecureRenderUtils disponÃ­vel, usar renderizaÃ§Ã£o segura
            if (typeof window !== 'undefined' && window.SecureRenderUtils && metricKey) {
                return window.SecureRenderUtils.renderSecureKPI(
                    value, 
                    label, 
                    metricKey, 
                    section, 
                    analysis, 
                    { className: cls, decimals: 1 }
                );
            }
            
            // Fallback (modo compatibilidade)
            const metricKeyAttr = metricKey ? ` data-metric-key="${metricKey}"` : '';
            return `
            <div class="kpi ${cls}"${metricKeyAttr}>
                <div class="kpi-value"${metricKeyAttr}>${value}</div>
                <div class="kpi-label">${label}</div>
            </div>`;
        };

        const scoreKpi = Number.isFinite(analysis.qualityOverall) ? kpi(Number(analysis.qualityOverall.toFixed(1)), 'SCORE GERAL', 'kpi-score', 'scoreFinal') : '';
        const timeKpi = Number.isFinite(analysis.processingMs) ? kpi(analysis.processingMs, 'TEMPO (MS)', 'kpi-time') : '';

        // ğŸ¯ Removido title="" para evitar tooltip nativo do browser conflitando com TooltipManager
        const src = (k) => (analysis.technicalData?._sources && analysis.technicalData._sources[k]) ? ` data-src="${analysis.technicalData._sources[k]}"` : '';
        
        // ğŸ”¥ DETECÃ‡ÃƒO DE AMBIENTE DEV/PROD
        const isDev = typeof window !== 'undefined' && (
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname.includes('dev') ||
            window.location.port === '3000'
        );
        
        // ğŸ¯ TOOLTIP REGISTRY COMPLETO - 100% ESPECÃFICO (SEM FALLBACKS GENÃ‰RICOS)
        // Estrutura: 'metricKey': { title, body, variant }
        // REGRA: Se nÃ£o houver entry aqui, NÃƒO mostrar Ã­cone "i" (prod) ou LOGAR WARNING (dev)
        const TOOLTIP_REGISTRY = {
            // === CARD 1: MÃ‰TRICAS PRINCIPAIS ===
            'rmsPeak300msDbfs': {
                title: 'Pico RMS (300ms)',
                body: 'Mede o volume mÃ¡ximo em janelas de 300ms. Representa o "pico percebido" - o momento mais alto da faixa sem considerar clipping instantÃ¢neo. Usado para avaliar headroom dinÃ¢mico.',
                variant: 'default'
            },
            'samplePeak': {
                title: 'Sample Peak (dBFS)',
                body: 'Maior amplitude instantÃ¢nea registrada entre os canais L/R. Deve ficar abaixo de 0 dBFS para evitar clipping digital. Valores acima de -0.1 dBFS sÃ£o considerados crÃ­ticos.',
                variant: 'default'
            },
            'truePeakDbtp': {
                title: 'Pico Real (dBTP)',
                body: 'Pico real que ocorre ENTRE as amostras digitais, detectado via oversampling 4x. Crucial para evitar clipping em conversÃµes D/A. Ideal: â‰¤ -1.0 dBTP. CrÃ­tico se > 0 dBTP.',
                variant: 'warning'
            },
            'avgLoudness': {
                title: 'Volume MÃ©dio (RMS)',
                body: 'NÃ­vel RMS mÃ©dio ao longo da faixa. Representa o volume "sustentado" - quanto de energia contÃ­nua o Ã¡udio tem. Diferente de picos, indica a "forÃ§a geral" do mix.',
                variant: 'default'
            },
            'lufsIntegrated': {
                title: 'Loudness (LUFS Integrado)',
                body: 'Loudness integrada no tempo pelo padrÃ£o ITU-R BS.1770-4. Usado por Spotify, Apple Music e YouTube. Meta: -14 LUFS (streaming) ou -16 LUFS (broadcast).',
                variant: 'primary'
            },
            'lufsShortTerm': {
                title: 'LUFS Curto Prazo (Short-Term)',
                body: 'Loudness em janelas de 3 segundos. Mostra variaÃ§Ãµes rÃ¡pidas de volume, Ãºtil para detectar partes muito altas/baixas. Complementa o LUFS integrado.',
                variant: 'secondary'
            },
            'dynamicRange': {
                title: 'DinÃ¢mica (DR)',
                body: 'Dynamic Range - diferenÃ§a entre as partes mais altas e mais baixas da faixa. Valores altos (>10 dB) = mix com "respiro" e punch. Valores baixos (<6 dB) = loudness war / brick-wall limiting.',
                variant: 'primary'
            },
            'lra': {
                title: 'ConsistÃªncia de Volume (LRA)',
                body: 'Loudness Range - mede a variaÃ§Ã£o de volume ao longo do tempo. 0 LU = volume perfeitamente estÃ¡vel (suspeito). 5-15 LU = dinÃ¢mica natural. >20 LU = variaÃ§Ãµes extremas.',
                variant: 'primary'
            },
            'stereoCorrelation': {
                title: 'Imagem EstÃ©reo',
                body: 'CorrelaÃ§Ã£o entre canais L/R. +1 = mono perfeito, 0 = estÃ©reo amplo, -1 = fase invertida (problema grave). Ideal: 0.5 a 0.9. Valores negativos causam cancelamento em mono.',
                variant: 'primary'
            },
            'stereoWidth': {
                title: 'Abertura EstÃ©reo (%)',
                body: 'Percentual de abertura do campo estÃ©reo. 0% = mono, 100% = estÃ©reo mÃ¡ximo. Valores altos (>80%) criam sensaÃ§Ã£o de amplitude e espacialidade. Cuidado com phase issues.',
                variant: 'primary'
            },
            
            // === CARD 2: ANÃLISE DE FREQUÃŠNCIAS ===
            'band_sub': {
                title: 'Subgrave (20â€“60 Hz)',
                body: 'FrequÃªncias ultra-graves, sentidas fisicamente mais que ouvidas. RegiÃ£o do sub-bass e kick fundamental. Excesso causa "lama" no mix, falta causa som "magro".',
                variant: 'frequency'
            },
            'band_bass': {
                title: 'Graves (60â€“150 Hz)',
                body: 'Corpo principal do kick e baixo. Define a "fundaÃ§Ã£o" do mix. Muito = som abafado, pouco = falta de corpo. CrÃ­tico para gÃªneros como hip-hop, EDM e rock.',
                variant: 'frequency'
            },
            'band_lowMid': {
                title: 'MÃ©dios-Graves (150â€“500 Hz)',
                body: 'Base harmÃ´nica de instrumentos graves e vocais masculinos. Excesso causa "boxiness" (som encaixotado). Fundamental para clareza sem perder corpo.',
                variant: 'frequency'
            },
            'band_mid': {
                title: 'MÃ©dios (500 Hzâ€“2 kHz)',
                body: 'RegiÃ£o de mÃ¡xima sensibilidade auditiva. Vocais, guitarras, snares vivem aqui. Muito = som nasal, pouco = falta de presenÃ§a. A "alma" do mix.',
                variant: 'frequency'
            },
            'band_highMid': {
                title: 'MÃ©dios-Agudos (2â€“5 kHz)',
                body: 'Ataque, clareza e definiÃ§Ã£o de instrumentos. RegiÃ£o da "mordida" de guitarras e "corte" de vocais. Excesso = fadiga auditiva, falta = som apagado.',
                variant: 'frequency'
            },
            'band_presence': {
                title: 'PresenÃ§a (5â€“10 kHz)',
                body: 'Brilho, clareza e "ar" do mix. Pratos, harmonics de vocais, sibilÃ¢ncia. Muito = som duro/agressivo, pouco = som abafado/distante. Define o "polish" final.',
                variant: 'frequency'
            },
            'band_air': {
                title: 'Ar (10â€“20 kHz)',
                body: 'FrequÃªncias super-agudas, sensaÃ§Ã£o de "espaÃ§o" e "abertura". Harmonics sutis e reverbs vivem aqui. Muito = sibilÃ¢ncia, falta = som fechado. Define a "respiraÃ§Ã£o" do mix.',
                variant: 'frequency'
            },
            'spectralCentroidHz': {
                title: 'FrequÃªncia Central (Hz)',
                body: 'Centro de massa espectral - mostra onde estÃ¡ concentrada a maior parte da energia. Valores baixos (<2 kHz) = som escuro/grave, valores altos (>4 kHz) = som brilhante/agudo.',
                variant: 'frequency'
            },
            
            // === CARD 3: MÃ‰TRICAS AVANÃ‡ADAS ===
            'samplePeakLeftDb': {
                title: 'Sample Peak L (dBFS)',
                body: 'Pico mÃ¡ximo do canal esquerdo. Valores prÃ³ximos de 0 dBFS indicam risco de clipping. Compare com o canal R para detectar desbalanceamento.',
                variant: 'advanced'
            },
            'samplePeakRightDb': {
                title: 'Sample Peak R (dBFS)',
                body: 'Pico mÃ¡ximo do canal direito. Deve estar balanceado com o canal L (diferenÃ§a < 1 dB). DesbalanÃ§os grandes (>3 dB) indicam problemas de mixagem.',
                variant: 'advanced'
            },
            'thd': {
                title: 'THD (Total Harmonic Distortion)',
                body: 'DistorÃ§Ã£o harmÃ´nica total - mede harmonics indesejados gerados pelo sistema. < 0.5% = limpo, 0.5-1% = leve warmth, > 1% = distorÃ§Ã£o audÃ­vel. Pode ser intencional (tape saturation).',
                variant: 'advanced'
            },
            'headroomDb': {
                title: 'Headroom (dB)',
                body: 'EspaÃ§o disponÃ­vel atÃ© 0 dBFS. Indica margem de seguranÃ§a para picos. < 1 dB = risco alto de clipping, 1-3 dB = aceitÃ¡vel, > 3 dB = conservador. Crucial para mastering.',
                variant: 'advanced'
            },
            'crestFactor': {
                title: 'Fator de Crista (Crest Factor)',
                body: 'DiferenÃ§a entre pico e RMS mÃ©dio. Indica "punch" e headroom dinÃ¢mico. Valores baixos (< 6 dB) = muito comprimido (loudness war), valores altos (> 12 dB) = dinÃ¢mica natural.',
                variant: 'advanced'
            },
            'spectralCentroid': {
                title: 'Centro Espectral (Hz)',
                body: 'Ponto de equilÃ­brio espectral - frequÃªncia onde 50% da energia estÃ¡ abaixo e 50% acima. Indica o "brilho" geral do mix. Valores tÃ­picos: 1-4 kHz.',
                variant: 'advanced'
            },
            'spectralRolloff': {
                title: 'Rolloff Espectral 85% (Hz)',
                body: 'FrequÃªncia onde 85% da energia espectral estÃ¡ concentrada. Indica extensÃ£o de agudos. < 8 kHz = som escuro, > 12 kHz = som brilhante. Ãštil para detectar filtros passa-baixa.',
                variant: 'advanced'
            },
            'spectralBandwidthHz': {
                title: 'Largura Espectral (Hz)',
                body: 'DispersÃ£o das frequÃªncias ao redor do centrÃ³ide. Valores altos = espectro "espalhado" (som rico/complexo), valores baixos = espectro concentrado (som simples/monotonal).',
                variant: 'advanced'
            },
            'spectralKurtosis': {
                title: 'Kurtosis Espectral',
                body: 'Mede "picosdade" do espectro. Valores altos (> 3) indicam harmonics fortes ou distorÃ§Ã£o. Valores baixos (< 3) indicam espectro uniforme. Ãštil para detectar harshness.',
                variant: 'advanced'
            },
            'spectralSkewness': {
                title: 'Assimetria Espectral',
                body: 'Mede se o espectro "pende" mais para graves ou agudos. Positivo = mais energia em agudos, negativo = mais energia em graves. PrÃ³ximo de 0 = balanceado.',
                variant: 'advanced'
            },
            'dominantFrequencies': {
                title: 'FrequÃªncias Dominantes',
                body: 'As 5 frequÃªncias com maior energia espectral. Ãštil para identificar resonÃ¢ncias, fundamentais de instrumentos e problemas de acÃºmulo de energia.',
                variant: 'advanced'
            },
            'zeroCrossings': {
                title: 'Zero Crossings Rate',
                body: 'Taxa de cruzamento por zero - relacionada ao conteÃºdo de alta frequÃªncia. Valores altos = muitos agudos/ruÃ­do, valores baixos = predominÃ¢ncia de graves. Ãštil para classificaÃ§Ã£o de timbre.',
                variant: 'advanced'
            },
            'mfcc1': {
                title: 'MFCC 1',
                body: 'Primeiro coeficiente Mel-Frequency Cepstral. Representa caracterÃ­sticas timbrÃ­sticas gerais. Usado em algoritmos de reconhecimento de Ã¡udio e ML.',
                variant: 'advanced'
            },
            'mfcc2': {
                title: 'MFCC 2',
                body: 'Segundo coeficiente MFCC - captura nuances espectrais de mÃ©dio termo. Complementa o MFCC 1 para anÃ¡lise de timbre.',
                variant: 'advanced'
            },
            'mfcc3': {
                title: 'MFCC 3',
                body: 'Terceiro coeficiente MFCC - captura detalhes espectrais finos. Usado em fingerprinting e anÃ¡lise avanÃ§ada de timbre.',
                variant: 'advanced'
            },
            'suggestions': {
                title: 'SugestÃµes DisponÃ­veis',
                body: 'NÃºmero de sugestÃµes tÃ©cnicas geradas pela IA com base na anÃ¡lise. Cada sugestÃ£o aponta problemas especÃ­ficos e soluÃ§Ãµes prÃ¡ticas para melhorar o Ã¡udio.',
                variant: 'success'
            },
            
            // === CARD 4: PROBLEMAS TÃ‰CNICOS ===
            'clippingSamples': {
                title: 'Clipping Samples',
                body: 'NÃºmero de amostras em 0 dBFS. Indica distorÃ§Ã£o digital grave. 0 samples = limpo, > 100 samples = problema audÃ­vel. Use limiters com lookahead para evitar.',
                variant: 'error'
            },
            'dcOffset': {
                title: 'DC Offset',
                body: 'Componente DC (corrente contÃ­nua) no sinal de Ã¡udio. Deve estar prÃ³ximo de zero. Valores > 0.01 podem causar clipping assimÃ©trico e problemas em processamento. Corrija com filtro HP.',
                variant: 'warning'
            },
            'thdPercent': {
                title: 'THD %',
                body: 'Percentual de distorÃ§Ã£o harmÃ´nica total. < 0.5% = transparente, 0.5-1% = coloraÃ§Ã£o sutil, > 1% = distorÃ§Ã£o evidente. Pode ser desejÃ¡vel em alguns contextos (warmth, saturation).',
                variant: 'warning'
            },
            
            // === VALIDAÃ‡Ã•ES / CONSISTÃŠNCIAS ===
            'drConsistency': {
                title: 'DR ConsistÃªncia',
                body: 'Verifica se o Dynamic Range medido Ã© consistente com outras mÃ©tricas. Î” pequeno = bom. Î” grande = possÃ­vel problema de mediÃ§Ã£o ou Ã¡udio muito processado.',
                variant: 'default'
            },
            'crestConsistency': {
                title: 'Crest Factor ConsistÃªncia',
                body: 'Verifica se o Crest Factor estÃ¡ dentro do esperado para o tipo de Ã¡udio. InconsistÃªncias indicam processamento excessivo ou problemas de dinÃ¢mica.',
                variant: 'default'
            },
            'lraPlausibility': {
                title: 'LRA Plausibilidade',
                body: 'Verifica se o Loudness Range Ã© plausÃ­vel para o conteÃºdo. Valores muito baixos ou muito altos podem indicar problemas de mediÃ§Ã£o ou Ã¡udio atÃ­pico.',
                variant: 'default'
            },
            
            // === SUBSCORES ===
            'loudness': {
                title: 'Subscore: Loudness',
                body: 'Avalia LUFS integrado, picos e headroom. Boa loudness = volume competitivo sem clipagem. Meta: -14 LUFS com True Peak < -1 dBTP.',
                variant: 'default'
            },
            'dynamic': {
                title: 'Subscore: DinÃ¢mica',
                body: 'Avalia Dynamic Range (DR) e Loudness Range (LRA). Boa dinÃ¢mica = mix com punch, respiraÃ§Ã£o e contraste. Evita "loudness war".',
                variant: 'default'
            },
            'frequency': {
                title: 'Subscore: FrequÃªncia',
                body: 'Avalia balanÃ§o espectral entre graves, mÃ©dios e agudos. Bom balanÃ§o = mix claro e cheio, sem acÃºmulos ou buracos. Todas as bandas devem estar presentes.',
                variant: 'default'
            },
            'stereo': {
                title: 'Subscore: EstÃ©reo',
                body: 'Avalia correlaÃ§Ã£o e abertura estÃ©reo. Bom estÃ©reo = imagem ampla sem phase issues. Deve soar bem tanto em estÃ©reo quanto em mono.',
                variant: 'default'
            },
            'technical': {
                title: 'Subscore: TÃ©cnico',
                body: 'Avalia problemas tÃ©cnicos: clipping, DC offset, THD, phase. Score 100% = Ã¡udio tecnicamente limpo, sem artefatos digitais ou distorÃ§Ãµes indesejadas.',
                variant: 'default'
            },
            
            // === SCORE FINAL E DIAGNÃ“STICO ===
            'scoreFinal': {
                title: 'Score Final',
                body: 'MÃ©dia ponderada de todos os subscores. Reflete a qualidade tÃ©cnica geral do Ã¡udio. 90-100% = excelente, 70-89% = bom, 50-69% = aceitÃ¡vel, <50% = problemas graves.',
                variant: 'primary'
            },
            'diagnostico': {
                title: 'DiagnÃ³stico Geral',
                body: 'ClassificaÃ§Ã£o qualitativa baseada no score final: EXCELENTE (90-100%), MUITO BOM (80-89%), BOM (70-79%), REGULAR (60-69%), NECESSITA AJUSTES (50-59%), CRÃTICO (<50%).',
                variant: 'primary'
            }
        };
        
        // ï¿½ LOG DE DIAGNÃ“STICO: Confirmar que TOOLTIP_REGISTRY foi carregado
        if (isDev) {
            const registryKeys = Object.keys(TOOLTIP_REGISTRY);
            log(`âœ… [TOOLTIP-INIT] TOOLTIP_REGISTRY carregado com ${registryKeys.length} tooltips`);
        }
        
        // ï¿½ğŸ”’ FUNÃ‡ÃƒO DE LOOKUP SEGURA (retorna null se nÃ£o encontrar, NÃƒO usa fallback)
        // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Verifica se TOOLTIP_REGISTRY existe antes de acessar
        const getTooltip = (metricKey) => {
            if (!metricKey) return null;
            
            // ğŸ›¡ï¸ SAFETY: Se TOOLTIP_REGISTRY nÃ£o existir, retornar null sem quebrar
            if (typeof TOOLTIP_REGISTRY === 'undefined') {
                if (isDev) {
                    error('[TOOLTIP-ERROR] TOOLTIP_REGISTRY nÃ£o estÃ¡ definido! Sistema de tooltips nÃ£o foi inicializado.');
                }
                return null;
            }
            
            // Tentar busca direta primeiro
            let tooltip = TOOLTIP_REGISTRY[metricKey];
            
            // Se nÃ£o encontrou, tentar variaÃ§Ãµes da chave
            if (!tooltip) {
                // Tentar sem prefixo band_
                if (metricKey.startsWith('band_')) {
                    tooltip = TOOLTIP_REGISTRY[metricKey];
                }
                // Tentar com lowercase
                if (!tooltip) {
                    const lowerKey = metricKey.toLowerCase();
                    tooltip = TOOLTIP_REGISTRY[lowerKey];
                }
            }
            
            // Se nÃ£o encontrar E estiver em DEV, logar warning
            if (!tooltip && isDev) {
                // Usar conjunto global para evitar logs duplicados
                if (!window._missingTooltipKeys) window._missingTooltipKeys = new Set();
                if (!window._missingTooltipKeys.has(metricKey)) {
                    window._missingTooltipKeys.add(metricKey);
                    warn(`[TOOLTIP-MISSING] MÃ©trica sem tooltip: "${metricKey}". Adicione entry no TOOLTIP_REGISTRY.`);
                }
            }
            
            return tooltip || null;
        };
        
        const row = (label, valHtml, keyForSource=null, metricKey=null, section='primary') => {
            // ï¿½ [LABEL-AUDIT][RENDER] Log ANTES de qualquer transformaÃ§Ã£o
            const originalLabel = label;
            const originalKey = keyForSource;
            
            // ğŸ”’ RENDERIZAÃ‡ÃƒO SEGURA: Detectar se valHtml contÃ©m valor numÃ©rico
            // Se contiver, extrair o valor e usar SecureRenderUtils
            if (typeof window !== 'undefined' && window.SecureRenderUtils && metricKey) {
                // Tentar extrair valor numÃ©rico de valHtml
                const match = valHtml.match(/([-]?\d+\.?\d*)/);
                if (match) {
                    const numericValue = parseFloat(match[1]);
                    
                    // Extrair unidade (o que vem depois do nÃºmero)
                    const unit = valHtml.replace(match[0], '').trim();
                    
                    // ğŸ¯ Buscar tooltip usando novo sistema (getTooltip + TOOLTIP_REGISTRY)
                    const tooltipData = metricKey ? getTooltip(metricKey) : null;
                    
                    // Usar renderizaÃ§Ã£o segura
                    return window.SecureRenderUtils.renderSecureRow(
                        label,
                        numericValue,
                        unit,
                        metricKey,
                        section,
                        analysis,
                        { keyForSource, tooltip: tooltipData }
                    );
                }
            }
            
            // Fallback: renderizaÃ§Ã£o tradicional (sem nÃºmeros ou SecureRenderUtils nÃ£o disponÃ­vel)
            // ğŸš¨ PONTO CRÃTICO: window.enhanceRowLabel PODE TROCAR O LABEL AQUI
            const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
                ? window.enhanceRowLabel(label, keyForSource) 
                : label;
            
            // ğŸ” [LABEL-AUDIT][RENDER] Log DEPOIS do enhanceRowLabel
            if (DEBUG_LABEL_AUDIT && metricKey) {
                const labelChanged = originalLabel !== enhancedLabel;
                log(`[LABEL-AUDIT][RENDER] metricKey="${metricKey}" section="${section}"`, {
                    originalLabel,
                    enhancedLabel,
                    labelChanged,
                    keyForSource: originalKey,
                    valueHtml: valHtml.substring(0, 50),
                    enhanceRowLabelExists: !!(window.enhanceRowLabel)
                });
                
                if (labelChanged) {
                    warn(`ğŸš¨ [LABEL-AUDIT] LABEL FOI ALTERADO POR enhanceRowLabel!`, {
                        de: originalLabel,
                        para: enhancedLabel,
                        metricKey,
                        keyForSource: originalKey
                    });
                    // Stack trace para ver quem chamou
                    console.trace('[LABEL-AUDIT] Stack trace do enhanceRowLabel:');
                }
            }
            
            // Limpar label (trim) e capitalizar primeira letra
            const cleanLabel = enhancedLabel.trim();
            const capitalizedLabel = cleanLabel.charAt(0).toUpperCase() + cleanLabel.slice(1);
            
            // ğŸ¯ BUSCAR TOOLTIP NO REGISTRY
            const tooltipData = metricKey ? getTooltip(metricKey) : null;
            
            // ğŸ¯ Se nÃ£o houver tooltip vÃ¡lido, ESCONDER o Ã­cone (nÃ£o usar fallback TODO visÃ­vel)
            let tooltipIconHtml = '';
            if (tooltipData && tooltipData.body) {
                const tooltipTitle = tooltipData.title.replace(/"/g, '&quot;');
                const tooltipBody = tooltipData.body.replace(/"/g, '&quot;');
                const tooltipVariant = tooltipData.variant || 'default';
                tooltipIconHtml = `<span class="metric-info-icon" 
                       data-tooltip-title="${tooltipTitle}"
                       data-tooltip-body="${tooltipBody}"
                       ${tooltipVariant !== 'default' ? `data-tooltip-variant="${tooltipVariant}"` : ''}
                       style="margin-left: 4px; cursor: pointer;">â„¹ï¸</span>`;
                
                // Log em DEV para mÃ©tricas COM tooltip
                if (isDev && !tooltipData) {
                    warn(`[TOOLTIP-MISSING] metricKey="${metricKey}" label="${capitalizedLabel}"`);
                }
            }
            
            const labelHtml = `<div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                 <span>${capitalizedLabel}</span>${tooltipIconHtml}
               </div>`;
            
            // ğŸ¯ Adicionar data-metric-key para rastreamento + data-original-label para auditoria
            const metricKeyAttr = metricKey ? ` data-metric-key="${metricKey}"` : '';
            const originalLabelAttr = DEBUG_LABEL_AUDIT ? ` data-original-label="${originalLabel}"` : '';
            
            return `
                <div class="data-row"${keyForSource?src(keyForSource):''}${metricKeyAttr}${originalLabelAttr}>
                    <span class="label" data-label-source="row-function">${labelHtml}</span>
                    <span class="value"${metricKeyAttr}>${valHtml}</span>
                </div>`;
        };

        // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ãµes de acesso unificado com fallbacks robustos
        const getNestedValue = (obj, path) => {
            if (!obj || !path) return null;
            return path.split('.').reduce((current, key) => current?.[key], obj);
        };

        // ğŸ”§ getMetricWithFallback: Suporta mÃºltiplos caminhos de fallback em ordem de prioridade
        const getMetricWithFallback = (paths, defaultValue = null) => {
            if (!Array.isArray(paths)) paths = [paths];
            
            for (const pathConfig of paths) {
                let value = null;
                
                if (typeof pathConfig === 'string') {
                    // Caminho simples: tenta metrics > technicalData
                    value = getNestedValue(analysis.metrics, pathConfig) ?? 
                           getNestedValue(analysis.technicalData, pathConfig);
                } else if (Array.isArray(pathConfig)) {
                    // Array de caminhos aninhados: ['loudness', 'integrated']
                    value = getNestedValue(analysis, pathConfig.join('.'));
                }
                
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            
            return defaultValue;
        };

        const getMetric = (metricPath, fallbackPath = null) => {
            // Prioridade: metrics centralizadas > technicalData legado > fallback
            const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
            if (Number.isFinite(centralizedValue)) {
                // Log temporÃ¡rio para validaÃ§Ã£o
                if (typeof window !== 'undefined' && window.METRICS_UI_VALIDATION !== false) {
                    const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
                    if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                        warn(`ğŸ¯ METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                    }
                }
                return centralizedValue;
            }
            
            // Fallback para technicalData legado
            const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
            return Number.isFinite(legacyValue) ? legacyValue : null;
        };

        const safePct = (v) => (Number.isFinite(v) ? `${(v*100).toFixed(0)}%` : 'â€”');
        const monoCompat = (s) => s ? s : 'â€”';

        // FunÃ§Ã£o para obter o valor LUFS integrado usando mÃ©tricas centralizadas
        const getLufsIntegratedValue = () => {
            return getMetric('lufs_integrated', 'lufsIntegrated');
        };

        // ğŸ¯ FUNÃ‡ÃƒO DE STATUS DO TRUE PEAK (REFATORADA - APENAS ALERTA CLIPPING)
        // âœ… Card sÃ³ avisa quando estÃ¡ estourado (> 0 dBTP)
        // âŒ Card nÃ£o elogia quando estÃ¡ negativo (apenas exibe valor numÃ©rico)
        const getTruePeakStatus = (value) => {
            if (!Number.isFinite(value)) return { status: '', class: '' };
            
            // Apenas alerta quando estÃ¡ clipando (> 0 dBTP)
            if (value > 0.0) return { status: 'ESTOURADO', class: 'status-critical' };
            
            // Para valores negativos, nÃ£o exibir status (apenas valor numÃ©rico)
            return { status: '', class: '' };
        };

        // ğŸ¯ HELPER: Obter Sample Peak (max de L/R) de forma robusta
        const getSamplePeakMaxDbfs = (analysis) => {
            const leftDb = analysis.technicalData?.samplePeakLeftDb;
            const rightDb = analysis.technicalData?.samplePeakRightDb;
            
            // Verificar se ambos sÃ£o nÃºmeros finitos
            if (!Number.isFinite(leftDb) || !Number.isFinite(rightDb)) {
                return null;
            }
            
            return Math.max(leftDb, rightDb);
        };

        const col1 = [
            // ğŸŸ£ CARD 1: MÃ‰TRICAS PRINCIPAIS - Chaves canÃ´nicas
            
            // ğŸ¯ DEBUG: Imprimir valores das mÃ©tricas ANTES de renderizar
            (() => {
                console.group('ğŸ” [METRICS-DEBUG] Card MÃ‰TRICAS PRINCIPAIS - Valores Brutos');
                log('ğŸ“Š technicalData.peak (Pico RMS 300ms):', analysis.technicalData?.peak);
                log('ğŸ“Š technicalData.avgLoudness (Volume MÃ©dio RMS):', analysis.technicalData?.avgLoudness);
                log('ğŸ“Š technicalData.samplePeakLeftDb:', analysis.technicalData?.samplePeakLeftDb);
                log('ğŸ“Š technicalData.samplePeakRightDb:', analysis.technicalData?.samplePeakRightDb);
                log('ğŸ“Š Sample Peak Max (calculado):', getSamplePeakMaxDbfs(analysis));
                log('ğŸ“Š technicalData.truePeakDbtp:', analysis.technicalData?.truePeakDbtp);
                console.groupEnd();
                return ''; // NÃ£o renderiza nada, sÃ³ debug
            })(),
            
            // ğŸ¯ 1. RMS Peak (300ms): technicalData.peak
            (() => {
                const rmsPeakValue = getMetric('rmsPeak300msDbfs') ?? getMetric('rmsPeak300msDb') ?? getMetric('rmsPeakDbfs') ?? getMetric('peak_db', 'peak');
                if (!Number.isFinite(rmsPeakValue) || rmsPeakValue === 0) {
                    return '';
                }
                log('âœ… [RENDER] Pico RMS (300ms) =', rmsPeakValue, 'dB');
                return row('Pico RMS (300ms)', `${safeFixed(rmsPeakValue)} dB`, 'rmsPeak300msDbfs', 'rmsPeak300msDbfs', 'primary');
            })(),
            
            // ğŸ¯ 2. Sample Peak (dBFS): max(samplePeakLeftDb, samplePeakRightDb)
            (() => {
                const samplePeakDbfs = getSamplePeakMaxDbfs(analysis);
                
                if (samplePeakDbfs === null) {
                    warn('âš ï¸ [RENDER] Sample Peak nÃ£o disponÃ­vel (left ou right ausente)');
                    return '';
                }
                
                const spStatus = getTruePeakStatus(samplePeakDbfs);
                log('âœ… [RENDER] Sample Peak (dBFS) =', samplePeakDbfs, 'dBFS');
                return row('Sample Peak (dBFS)', `${safeFixed(samplePeakDbfs, 1)} dBFS <span class="${spStatus.class}">${spStatus.status}</span>`, 'samplePeak', 'samplePeak', 'primary');
            })(),
            
            // ğŸ¯ 3. True Peak (dBTP): technicalData.truePeakDbtp
            (() => {
                const tpValue = getMetric('truePeakDbtp') ?? getMetricWithFallback([['truePeak','maxDbtp'], 'technicalData.truePeakDbtp']);
                
                if (!advancedReady) {
                    warn('âš ï¸ [RENDER] Pico Real BLOQUEADO por advancedReady=false');
                    return '';
                }
                if (tpValue === null || tpValue === undefined) {
                    warn('âš ï¸ [RENDER] Pico Real NÃƒO ENCONTRADO');
                    return '';
                }
                if (!Number.isFinite(tpValue)) {
                    warn('âš ï¸ [RENDER] Pico Real valor invÃ¡lido:', tpValue);
                    return '';
                }
                
                const tpStatus = getTruePeakStatus(tpValue);
                log('âœ… [RENDER] Pico Real (dBTP) =', tpValue, 'dBTP');
                return row('Pico Real (dBTP)', `${safeFixed(tpValue, 2)} dBTP <span class="${tpStatus.class}">${tpStatus.status}</span>`, 'truePeakDbtp', 'truePeakDbtp', 'primary');
            })(),
            
            // ğŸ¯ 4. Volume MÃ©dio (RMS): technicalData.avgLoudness
            (() => {
                const rmsValue = analysis.technicalData?.avgLoudness ?? analysis.technicalData?.rms;
                
                // Exibir sempre, mesmo se 0 (valor tÃ©cnico vÃ¡lido)
                if (rmsValue === null || rmsValue === undefined) {
                    warn('âš ï¸ [RENDER] Volume MÃ©dio (RMS) NÃƒO ENCONTRADO');
                    return row('Volume MÃ©dio (RMS)', `â€”`, 'avgLoudness', 'avgLoudness', 'primary');
                }
                if (!Number.isFinite(rmsValue)) {
                    warn('âš ï¸ [RENDER] Volume MÃ©dio (RMS) valor invÃ¡lido:', rmsValue);
                    return row('Volume MÃ©dio (RMS)', `â€”`, 'avgLoudness', 'avgLoudness', 'primary');
                }
                
                log('âœ… [RENDER] Volume MÃ©dio (RMS) =', rmsValue, 'dBFS');
                return row('Volume MÃ©dio (RMS)', `${safeFixed(rmsValue, 1)} dBFS`, 'avgLoudness', 'avgLoudness', 'primary');
            })(),
            
            // ğŸ¯ Loudness (LUFS) - loudness perceptiva em LUFS
            (() => {
                const lufsValue = getMetricWithFallback([
                    ['loudness', 'integrated'],
                    'lufs_integrated',
                    'lufsIntegrated',
                    'technicalData.lufsIntegrated'
                ]);
                log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) - advancedReady:', advancedReady, 'lufsValue:', lufsValue);
                
                if (!advancedReady) {
                    warn('[AUDITORIA-RMS-LUFS] col1 > LUFS BLOQUEADO por advancedReady=false');
                    return '';
                }
                // ğŸ¯ Exibir sempre, mesmo se 0
                if (lufsValue === null || lufsValue === undefined) {
                    warn('[AUDITORIA-RMS-LUFS] col1 > LUFS NÃƒO ENCONTRADO - exibindo 0');
                    return row('Loudness (LUFS Integrado)', `0.0 LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
                }
                if (!Number.isFinite(lufsValue)) {
                    warn('[AUDITORIA-RMS-LUFS] col1 > LUFS valor invÃ¡lido:', lufsValue);
                    return row('Loudness (LUFS Integrado)', `0.0 LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
                }
                log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) RENDERIZADO:', lufsValue, 'LUFS');
                return row('Loudness (LUFS Integrado)', `${safeFixed(lufsValue, 1)} LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
            })(),
            
            // ğŸ¯ LUFS Curto Prazo (Short-Term) - exibido logo apÃ³s LUFS Integrado
            (() => {
                const lufsShortTermValue = analysis.technicalData?.lufsShortTerm ?? analysis.loudness?.shortTerm ?? null;
                if (!advancedReady) {
                    return '';
                }
                if (lufsShortTermValue === null || lufsShortTermValue === undefined || !Number.isFinite(lufsShortTermValue)) {
                    log('[AUDITORIA-RMS-LUFS] col1 > LUFS Curto Prazo nÃ£o disponÃ­vel ou invÃ¡lido');
                    return '';
                }
                log('[AUDITORIA-RMS-LUFS] col1 > LUFS Curto Prazo RENDERIZADO:', lufsShortTermValue, 'LUFS');
                return row('LUFS Curto Prazo (Short-Term)', `${safeFixed(lufsShortTermValue, 1)} LUFS`, 'lufsShortTerm', 'lufsShortTerm', 'secondary');
            })(),
            
            row('DinÃ¢mica (DR)', `${safeFixed(getMetric('dynamic_range', 'dynamicRange'))} dB`, 'dynamicRange', 'dynamicRange', 'primary'),
            row('ConsistÃªncia de Volume (LU)', `${safeFixed(getMetric('lra', 'lra'))} LU`, 'lra', 'lra', 'primary'),
            // Imagem EstÃ©reo (movido de col2)
            row('Imagem EstÃ©reo', Number.isFinite(getMetric('stereo_correlation', 'stereoCorrelation')) ? safeFixed(getMetric('stereo_correlation', 'stereoCorrelation'), 3) : 'â€”', 'stereoCorrelation', 'stereoCorrelation', 'primary'),
            // Abertura EstÃ©reo (movido de col2)
            row('Abertura EstÃ©reo (%)', Number.isFinite(getMetric('stereo_width', 'stereoWidth')) ? `${safeFixed(getMetric('stereo_width', 'stereoWidth') * 100, 0)}%` : 'â€”', 'stereoWidth', 'stereoWidth', 'primary')
            ];

        // ğŸ” [DEBUG_MAIN_METRICS] Sistema de Tracking Completo
        if (DEBUG_MAIN_METRICS) {
            const trackingData = [];
            
            // Linha 1: Pico RMS (300ms)
            const rmsPeakValue = getMetric('rmsPeak300msDbfs') ?? getMetric('rmsPeak300msDb') ?? getMetric('rmsPeakDbfs') ?? getMetric('peak_db', 'peak');
            trackingData.push({
                rowId: 1,
                labelHardcoded: 'Pico RMS (300ms)',
                labelKeyUsed: 'peak',
                valueKeyUsed: 'peak / rmsPeak300msDbfs',
                computedLabel: 'Pico RMS (300ms)',
                value: rmsPeakValue,
                rawSourcePath: 'analysis.technicalData.peak',
                actualSourceValue: analysis.technicalData?.peak
            });
            
            // Linha 2: Sample Peak
            const samplePeakDbfs = getSamplePeakMaxDbfs(analysis);
            trackingData.push({
                rowId: 2,
                labelHardcoded: 'Sample Peak (dBFS)',
                labelKeyUsed: 'samplePeak',
                valueKeyUsed: 'max(samplePeakLeftDb, samplePeakRightDb)',
                computedLabel: 'Sample Peak (dBFS)',
                value: samplePeakDbfs,
                rawSourcePath: 'Math.max(technicalData.samplePeakLeftDb, technicalData.samplePeakRightDb)',
                actualSourceValue: `L:${analysis.technicalData?.samplePeakLeftDb} R:${analysis.technicalData?.samplePeakRightDb}`
            });
            
            // Linha 3: True Peak
            const tpValue = getMetric('truePeakDbtp') ?? getMetricWithFallback([['truePeak','maxDbtp'], 'technicalData.truePeakDbtp']);
            trackingData.push({
                rowId: 3,
                labelHardcoded: 'Pico Real (dBTP)',
                labelKeyUsed: 'truePeakDbtp',
                valueKeyUsed: 'truePeakDbtp',
                computedLabel: 'Pico Real (dBTP)',
                value: tpValue,
                rawSourcePath: 'analysis.technicalData.truePeakDbtp',
                actualSourceValue: analysis.technicalData?.truePeakDbtp
            });
            
            // Linha 4: Volume MÃ©dio (RMS)
            const rmsValue = analysis.technicalData?.avgLoudness ?? analysis.technicalData?.rms;
            trackingData.push({
                rowId: 4,
                labelHardcoded: 'Volume MÃ©dio (RMS)',
                labelKeyUsed: 'avgLoudness',
                valueKeyUsed: 'avgLoudness',
                computedLabel: 'Volume MÃ©dio (RMS)',
                value: rmsValue,
                rawSourcePath: 'analysis.technicalData.avgLoudness',
                actualSourceValue: analysis.technicalData?.avgLoudness
            });
            
            // Linha 5: LUFS
            const lufsValue = getMetricWithFallback([
                ['loudness', 'integrated'],
                'lufs_integrated',
                'lufsIntegrated',
                'technicalData.lufsIntegrated'
            ]);
            trackingData.push({
                rowId: 5,
                labelHardcoded: 'Loudness (LUFS Integrado)',
                labelKeyUsed: 'lufsIntegrated',
                valueKeyUsed: 'lufsIntegrated / lufs_integrated',
                computedLabel: 'Loudness (LUFS Integrado)',
                value: lufsValue,
                rawSourcePath: 'analysis.technicalData.lufsIntegrated',
                actualSourceValue: analysis.technicalData?.lufsIntegrated
            });
            
            console.groupCollapsed(`ğŸ” [MAIN_METRICS] render #${RENDER_ID}`);
            console.table(trackingData);
            log('ğŸ“¦ technicalData keys:', Object.keys(analysis.technicalData || {}));
            log('ğŸ“¦ technicalData completo:', analysis.technicalData);
            console.trace('ğŸ” Stack trace:');
            console.groupEnd();
        }

        // Juntar HTML
        const col1Html = col1.join('');

        // ğŸ” [DEBUG_MAIN_METRICS] Log do HTML gerado
        if (DEBUG_MAIN_METRICS) {
            console.group(`ğŸ” [MAIN_METRICS] HTML Gerado #${RENDER_ID}`);
            log('ğŸ“ col1Html length:', col1Html.length);
            log('ğŸ“ col1Html preview:', col1Html.substring(0, 500));
            log('ğŸ“ col1 array length:', col1.length);
            log('ğŸ“ col1 array items:', col1.map((item, idx) => ({ idx, isEmpty: item === '', length: item.length })));
            console.groupEnd();
        }

        // ğŸ” [DEBUG_MAIN_METRICS] Ler DOM renderizado e comparar
        if (DEBUG_MAIN_METRICS) {
            // Agendar leitura do DOM apÃ³s renderizaÃ§Ã£o
            setTimeout(() => {
                const modalTechData = document.getElementById('modalTechnicalData');
                if (!modalTechData) {
                    warn('[MAIN_METRICS] modalTechnicalData nÃ£o encontrado no DOM');
                    return;
                }
                
                const dataRows = modalTechData.querySelectorAll('.data-row');
                const domContent = [];
                
                dataRows.forEach((row, idx) => {
                    const labelEl = row.querySelector('.label');
                    const valueEl = row.querySelector('.value');
                    
                    if (labelEl && valueEl) {
                        domContent.push({
                            domIndex: idx + 1,
                            domLabelText: labelEl.textContent.trim().replace(/â„¹ï¸/g, '').trim(),
                            domValueText: valueEl.textContent.trim(),
                            domLabelHTML: labelEl.innerHTML.substring(0, 100),
                            domValueHTML: valueEl.innerHTML.substring(0, 100),
                            metricKey: row.getAttribute('data-metric-key'),
                            originalLabel: row.getAttribute('data-original-label')
                        });
                    }
                });
                
                console.groupCollapsed(`ğŸ” [MAIN_METRICS] DOM Renderizado #${RENDER_ID}`);
                console.table(domContent.slice(0, 5)); // Primeiras 5 linhas (mÃ©tricas principais)
                log('ğŸ“Š Total de rows no DOM:', dataRows.length);
                console.groupEnd();
                
                // ğŸ” [LABEL-AUDIT] Instalar MutationObserver
                if (DEBUG_LABEL_AUDIT) {
                    log('ğŸ” [LABEL-AUDIT] Instalando MutationObserver...');
                    
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'characterData' || mutation.type === 'childList') {
                                const target = mutation.target;
                                const parentLabel = target.nodeType === Node.TEXT_NODE 
                                    ? target.parentElement 
                                    : target;
                                
                                // Verificar se Ã© uma label
                                if (parentLabel && (
                                    parentLabel.classList.contains('label') || 
                                    parentLabel.classList.contains('metric-label-friendly') ||
                                    parentLabel.closest('.label')
                                )) {
                                    const row = parentLabel.closest('.data-row');
                                    const metricKey = row ? row.getAttribute('data-metric-key') : null;
                                    const originalLabel = row ? row.getAttribute('data-original-label') : null;
                                    
                                    console.group('ğŸš¨ [LABEL-AUDIT][MUTATION] Label foi alterada!');
                                    log('Timestamp:', new Date().toISOString());
                                    log('metricKey:', metricKey);
                                    log('originalLabel (data-attr):', originalLabel);
                                    log('Label atual (textContent):', parentLabel.textContent.trim());
                                    log('Tipo de mutaÃ§Ã£o:', mutation.type);
                                    log('Target:', mutation.target);
                                    log('Elemento pai:', parentLabel);
                                    
                                    // Stack trace
                                    const e = new Error('[LABEL-AUDIT] Label mutated');
                                    log('Stack trace:');
                                    log(e.stack);
                                    console.groupEnd();
                                }
                            }
                        });
                    });
                    
                    // Observar todo o container de mÃ©tricas
                    observer.observe(modalTechData, {
                        childList: true,
                        subtree: true,
                        characterData: true,
                        characterDataOldValue: true
                    });
                    
                    log('âœ… [LABEL-AUDIT] MutationObserver instalado com sucesso');
                    
                    // Guardar referÃªncia global para debug
                    window.__LABEL_AUDIT_OBSERVER__ = observer;
                    
                    // ğŸ“Š Imprimir relatÃ³rio resumido no console apÃ³s 2s
                    setTimeout(() => {
                        console.group('ğŸ“‹ [LABEL-AUDIT] RELATÃ“RIO RESUMIDO');
                        log('%cğŸ” AUDITORIA DE LABELS - Card "MÃ©tricas Principais"', 'font-size:14px;font-weight:bold;color:#00ffff');
                        log('');
                        log('%cğŸ“Œ CAUSA RAIZ IDENTIFICADA:', 'font-weight:bold;color:#ff6b6b');
                        log('   Sistema friendly-labels.js com busca por substring causa matches espÃºrios');
                        log('   Arquivo: public/friendly-labels.js linha 159-195');
                        log('   FunÃ§Ã£o: window.enhanceRowLabel()');
                        log('');
                        log('%cğŸš¨ PROBLEMA:', 'font-weight:bold;color:#ffd700');
                        log('   1. enhanceRowLabel() busca substring em labels');
                        log('   2. "Sample Peak (dBFS)" contÃ©m "peak" â†’ match com \'peak\': \'Pico RMS (300ms)\'');
                        log('   3. Primeiro match vence, causando labels trocados');
                        log('');
                        log('%cğŸ’¡ SOLUÃ‡ÃƒO SUGERIDA:', 'font-weight:bold;color:#00ff92');
                        log('   OpÃ§Ã£o 1: Desabilitar enhanceRowLabel para mÃ©tricas principais (section === "primary")');
                        log('   OpÃ§Ã£o 2: Melhorar lÃ³gica de match (exato antes de substring)');
                        log('   OpÃ§Ã£o 3: Whitelist de keys permitidas para substring match');
                        log('');
                        log('%cğŸ“„ RELATÃ“RIO COMPLETO:', 'font-weight:bold');
                        log('   Arquivo: REPORT_LABEL_AUDIT.md');
                        log('   Para desabilitar auditoria: DEBUG_LABEL_AUDIT = false (linha ~12037)');
                        log('');
                        log('%cğŸ” DADOS COLETADOS:', 'font-weight:bold');
                        log('   - Logs [LABEL-AUDIT][RENDER]: Antes/depois do enhanceRowLabel');
                        log('   - Logs [LABEL-AUDIT][MUTATION]: MudanÃ§as pÃ³s-render (se houver)');
                        log('   - Tabelas [MAIN_METRICS]: Mapeamento original vs DOM final');
                        console.groupEnd();
                    }, 2000);
                }
            }, 500); // Aguardar 500ms para DOM estar pronto
        }

        // ğŸ¯ RESUMO FINAL: Card montado com sucesso
        console.group('âœ… [METRICS-FINAL] Card MÃ‰TRICAS PRINCIPAIS - Resumo');
        log('ğŸ¯ Linha 1: Pico RMS (300ms) â†’ technicalData.peak');
        log('ğŸ¯ Linha 2: Sample Peak (dBFS) â†’ max(samplePeakLeftDb, samplePeakRightDb)');
        log('ğŸ¯ Linha 3: Pico Real (dBTP) â†’ technicalData.truePeakDbtp');
        log('ğŸ¯ Linha 4: Volume MÃ©dio (RMS) â†’ technicalData.avgLoudness');
        log('ğŸ“Š HTML gerado:', col1.length > 0 ? 'OK' : 'VAZIO');
        console.groupEnd();

        // ğŸ¯ SANITY CHECK: ValidaÃ§Ã£o leve das mÃ©tricas principais (nÃ£o bloqueia renderizaÃ§Ã£o)
        (() => {
            const rmsPeak = getMetric('rmsPeak300msDbfs') ?? getMetric('peak');
            const avgRms = analysis.technicalData?.avgLoudness;
            const samplePeak = getSamplePeakMaxDbfs(analysis);
            
            console.group('ğŸ” [METRICS-SANITY] ValidaÃ§Ã£o de ConsistÃªncia');
            
            // Check 1: RMS Peak deve ser maior (menos negativo) que RMS mÃ©dio
            if (Number.isFinite(rmsPeak) && Number.isFinite(avgRms) && rmsPeak < avgRms) {
                warn('âš ï¸ Alerta: Pico RMS (300ms) menor que Volume MÃ©dio (RMS)', {
                    rmsPeak300ms: rmsPeak,
                    avgLoudness: avgRms,
                    diff: avgRms - rmsPeak
                });
            } else {
                log('âœ… Pico RMS vs Volume MÃ©dio: OK');
            }
            
            // Check 2: Sample Peak principal deve corresponder ao max(L,R) em mÃ©tricas avanÃ§adas
            if (Number.isFinite(samplePeak)) {
                const advancedL = analysis.technicalData?.samplePeakLeftDb;
                const advancedR = analysis.technicalData?.samplePeakRightDb;
                const maxAdvanced = Math.max(advancedL || -Infinity, advancedR || -Infinity);
                
                if (Math.abs(samplePeak - maxAdvanced) > 0.1) {
                    debug('â„¹ï¸ Info: Sample Peak principal difere de max(L,R) avanÃ§ado', {
                        samplePeakPrincipal: samplePeak,
                        samplePeakLeft: advancedL,
                        samplePeakRight: advancedR,
                        maxAdvanced: maxAdvanced,
                        diff: Math.abs(samplePeak - maxAdvanced)
                    });
                } else {
                    log('âœ… Sample Peak vs max(L,R): OK');
                }
            }
            
            console.groupEnd();
        })();

        const col2 = (() => {
            // ğŸ”µ CARD 2: ANÃLISE DE FREQUÃŠNCIAS - Reorganizado com sub-bandas espectrais
            const rows = [];
            
            // Sub-bandas espectrais (movidas de advancedMetricsCard)
            const spectralBands = analysis.technicalData?.spectral_balance || 
                                analysis.technicalData?.spectralBands || 
                                analysis.metrics?.bands || {};
            
            if (Object.keys(spectralBands).length > 0) {
                const bandMap = {
                    sub: { name: 'Subgrave (20â€“60 Hz)', range: '20-60Hz' },
                    bass: { name: 'Graves (60â€“150 Hz)', range: '60-150Hz' },
                    lowMid: { name: 'MÃ©dios-Graves (150â€“500 Hz)', range: '150-500Hz' },
                    mid: { name: 'MÃ©dios (500 Hzâ€“2 kHz)', range: '500-2000Hz' },
                    highMid: { name: 'MÃ©dios-Agudos (2â€“5 kHz)', range: '2000-5000Hz' },
                    presence: { name: 'PresenÃ§a (5â€“10 kHz)', range: '5000-10000Hz' },
                    air: { name: 'Ar (10â€“20 kHz)', range: '10000-20000Hz' }
                };
                
                Object.keys(bandMap).forEach(bandKey => {
                    const bandData = spectralBands[bandKey];
                    if (bandData && typeof bandData === 'object') {
                        const energyDb = bandData.energy_db;
                        const percentage = bandData.percentage;
                        const status = bandData.status;
                        
                        if (status && status !== 'not_calculated') {
                            let displayValue = '';
                            if (Number.isFinite(energyDb) && Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB (${safeFixed(percentage, 1)}%)`;
                            } else if (Number.isFinite(energyDb)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB`;
                            } else if (Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(percentage, 1)}%`;
                            } else {
                                displayValue = 'nÃ£o calculado';
                            }
                            const metricKey = `band_${bandKey}`;
                            
                            // âœ… PRIORIZAR: Usar frequencyRange do backend se existir
                            const displayName = bandData.frequencyRange 
                                ? `${bandMap[bandKey].name.split('(')[0].trim()} (${bandData.frequencyRange})`
                                : bandMap[bandKey].name;
                            
                            rows.push(row(displayName, displayValue, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`, metricKey, 'frequency'));
                        }
                    } else if (Number.isFinite(bandData)) {
                        const metricKey = `band_${bandKey}`;
                        
                        // âœ… Fallback tambÃ©m usa range do backend se existir
                        const displayName = bandMap[bandKey].name;
                        
                        rows.push(row(displayName, `${safeFixed(bandData, 1)} dB`, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`, metricKey, 'frequency'));
                    }
                });
            }
            
            // FrequÃªncia Central (mantÃ©m aqui)
            rows.push(row('FrequÃªncia Central (Hz)', Number.isFinite(getMetric('spectral_centroid', 'spectralCentroidHz')) ? safeHz(getMetric('spectral_centroid', 'spectralCentroidHz')) : 'â€”', 'spectralCentroidHz', 'spectralCentroidHz', 'frequency'));
            
            return rows.join('');
            // REMOVED: CorrelaÃ§Ã£o EstÃ©reo - movido para col1
            // REMOVED: Largura EstÃ©reo - movido para col1
        })();

            // ğŸ§© CORREÃ‡ÃƒO #5: Exibir frequÃªncias dominantes na UI (removido bloqueio)
            // FrequÃªncias dominantes agora visÃ­veis
            log('ğŸ›ï¸ [DEBUG] Exibindo mÃ©tricas de frequÃªncia na UI');
            
            const col3 = [
                // REMOVED: Dominant Frequencies UI (mantendo cÃ¡lculo interno para suggestions)
                
                // REMOVED: clipping (%) - ocultado da interface conforme solicitado
                // REMOVED: dc offset - ocultado da interface conforme solicitado
                (Number.isFinite(getMetric('thd', 'thd')) ? row('thd', `${safeFixed(getMetric('thd', 'thd'), 2)}%`, 'thd') : ''),
                
                // REMOVED: DinÃ¢mica e Fator de Crista duplicados - jÃ¡ exibidos em col1
                // REMOVED: row('CorrelaÃ§Ã£o EstÃ©reo (largura)') - duplicado de col2
                // REMOVED: row('fator de crista') - duplicado de col1
                // REMOVED: row('DinÃ¢mica (diferenÃ§a entre alto/baixo)') - duplicado de col1 com DR e LRA
                
                // REMOVED: Placeholders hardcoded - substituir por valores reais quando disponÃ­veis
                // row('crest consist', 'Î”=4.43 check', 'crestConsist'),
                // row('VariaÃ§Ã£o de Volume (consistÃªncia)', 'ok', 'volumeConsistency'),
                
                // REMOVED: Problemas - ocultado da interface conforme solicitado
                // REMOVED: SugestÃµes - movido para o final do card MÃ‰TRICAS AVANÃ‡ADAS
                // row('SugestÃµes', (analysis.suggestions?.length || 0) > 0 ? `<span class="tag tag-success">${analysis.suggestions.length} disponÃ­vel(s)</span>` : 'â€”')
                // REMOVED: col3Extras (dominant frequencies UI)
            ].join('');

            // Card extra: MÃ©tricas AvanÃ§adas (expandido para Web Audio API compatibility)
            const advancedMetricsCard = () => {
                const rows = [];
                
                // === MÃ‰TRICAS DE PICO E CLIPPING (seÃ§Ã£o principal) ===
                
                // REMOVED: True Peak (dBTP) - agora exclusivo do card MÃ‰TRICAS PRINCIPAIS
                // Se truePeakDbtp estiver mapeado no card de avanÃ§adas, remova de lÃ¡. 
                // True Peak deve existir apenas em MÃ©tricas Principais para evitar duplicaÃ§Ã£o
                
                // Picos por canal separados (Sample Peak)
                if (Number.isFinite(analysis.technicalData?.samplePeakLeftDb)) {
                    rows.push(row('Sample Peak L (dBFS)', `${safeFixed(analysis.technicalData.samplePeakLeftDb, 1)} dBFS`, 'samplePeakLeftDb', 'samplePeakLeftDb', 'advanced'));
                }
                if (Number.isFinite(analysis.technicalData?.samplePeakRightDb)) {
                    rows.push(row('Sample Peak R (dBFS)', `${safeFixed(analysis.technicalData.samplePeakRightDb, 1)} dBFS`, 'samplePeakRightDb', 'samplePeakRightDb', 'advanced'));
                }
                
                // REMOVED: Clipping (%) - ocultado da interface conforme solicitado
                
                // REMOVED: Clipping samples - ocultado da interface conforme solicitado
                
                // REMOVED: DC OFFSET - ocultado da interface conforme solicitado
                
                // === THD (Total Harmonic Distortion) ===
                if (Number.isFinite(analysis.technicalData?.thd)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thd, 4)}%`, 'thd', 'thd', 'advanced'));
                } else if (Number.isFinite(analysis.technicalData?.thdPercent)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thdPercent, 4)}%`, 'thdPercent', 'thd', 'advanced'));
                }
                
                // === HEADROOM ===
                if (Number.isFinite(analysis.technicalData?.headroomDb)) {
                    rows.push(row('headroom (dB)', `${safeFixed(analysis.technicalData.headroomDb, 1)} dB`, 'headroomDb', 'headroomDb', 'advanced'));
                }
                
                // === FATOR DE CRISTA (movido de MÃ‰TRICAS PRINCIPAIS) ===
                const crestValue = getMetricWithFallback([
                    ['dynamics', 'crest'],
                    'crest_factor',
                    'crestFactor',
                    'technicalData.crestFactor'
                ]);
                if (Number.isFinite(crestValue)) {
                    log('[METRICS-FIX] advancedMetricsCard > Fator de Crista RENDERIZADO:', crestValue, 'dB');
                    rows.push(row('Fator de Crista (Crest Factor)', `${safeFixed(crestValue, 2)} dB`, 'crestFactor', 'crestFactor', 'advanced'));
                } else {
                    warn('[METRICS-FIX] advancedMetricsCard > Fator de Crista NÃƒO ENCONTRADO ou invÃ¡lido:', crestValue);
                }
                
                // ğŸŸ¢ CARD 3: MÃ‰TRICAS AVANÃ‡ADAS - Sub-bandas espectrais REMOVIDAS (movidas para col2)
                // === MÃ‰TRICAS ESPECTRAIS AVANÃ‡ADAS ===
                
                // Centro Espectral
                if (Number.isFinite(analysis.technicalData?.spectralCentroid)) {
                    rows.push(row('Centro Espectral (Hz)', `${Math.round(analysis.technicalData.spectralCentroid)} Hz`, 'spectralCentroid', 'spectralCentroid', 'advanced'));
                }
                
                // Spectral Rolloff (ExtensÃ£o de agudos)
                if (Number.isFinite(analysis.technicalData?.spectralRolloff)) {
                    rows.push(row('Rolloff Espectral 85% (Hz)', `${Math.round(analysis.technicalData.spectralRolloff)} Hz`, 'spectralRolloff', 'spectralRolloff', 'advanced'));
                }
                
                // Spectral Flatness (Uniformidade espectral) - OCULTADO DA UI (sempre retorna 0, mÃ©trica instÃ¡vel)
                // O cÃ¡lculo permanece no backend, apenas nÃ£o Ã© exibido na interface
                // if (Number.isFinite(analysis.technicalData?.spectralFlatness)) {
                //     rows.push(row('Uniformidade Espectral (%)', `${safeFixed(analysis.technicalData.spectralFlatness * 100, 2)}%`, 'spectralFlatness', 'spectralFlatness', 'advanced'));
                // }
                
                // Spectral Bandwidth (Bandas espectrais)
                if (Number.isFinite(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))) {
                    rows.push(row('Largura Espectral (Hz)', `${safeHz(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))}`, 'spectralBandwidthHz', 'spectralBandwidthHz', 'advanced'));
                }
                
                // Spectral Kurtosis
                if (Number.isFinite(analysis.technicalData?.spectralKurtosis)) {
                    rows.push(row('Kurtosis Espectral', `${safeFixed(analysis.technicalData.spectralKurtosis, 3)}`, 'spectralKurtosis', 'spectralKurtosis', 'advanced'));
                }
                
                // Spectral Skewness
                if (Number.isFinite(analysis.technicalData?.spectralSkewness)) {
                    rows.push(row('Assimetria Espectral', `${safeFixed(analysis.technicalData.spectralSkewness, 3)}`, 'spectralSkewness', 'spectralSkewness', 'advanced'));
                }
                
                // === REMOVIDO: BANDAS ESPECTRAIS DETALHADAS (Sub, Bass, Low-Mid, etc.) ===
                // As sub-bandas espectrais foram movidas para o card "ANÃLISE DE FREQUÃŠNCIAS" (col2)
                // Comentado para evitar duplicaÃ§Ã£o
                
                if (false && Object.keys({}).length > 0) {
                    // REMOVIDO: CÃ³digo de bandas espectrais (sub, bass, lowMid, etc.)
                    // As sub-bandas espectrais foram movidas para col2 (ANÃLISE DE FREQUÃŠNCIAS)
                    // Este bloco foi comentado para evitar duplicaÃ§Ã£o
                }
                
                // ğŸ§© CORREÃ‡ÃƒO #5: Exibir frequÃªncias dominantes e uniformidade espectral
                // === FREQUÃŠNCIAS DOMINANTES ===
                if (Array.isArray(analysis.technicalData?.dominantFrequencies) && analysis.technicalData.dominantFrequencies.length > 0) {
                    const freqList = analysis.technicalData.dominantFrequencies
                        .slice(0, 5)
                        .map(f => `${Math.round(f)}Hz`)
                        .join(', ');
                    rows.push(row('FrequÃªncias Dominantes', freqList, 'dominantFrequencies', 'dominantFrequencies', 'advanced'));
                    log('ğŸ›ï¸ [DEBUG] FrequÃªncias dominantes exibidas:', freqList);
                }
                
                // === UNIFORMIDADE ESPECTRAL === (OCULTADO DA UI - mÃ©trica instÃ¡vel, sempre retorna 0)
                // O cÃ¡lculo permanece no backend, apenas nÃ£o Ã© exibido na interface
                // if (Number.isFinite(analysis.technicalData?.spectralUniformity)) {
                //     rows.push(row('uniformidade espectral', `${safeFixed(analysis.technicalData.spectralUniformity, 3)}`, 'spectralUniformity'));
                //     log('ğŸ›ï¸ [DEBUG] Uniformidade espectral exibida:', analysis.technicalData.spectralUniformity);
                // }
                
                // === ZEROS CROSSING RATE ===
                if (Number.isFinite(analysis.technicalData?.zcr)) {
                    rows.push(row('Zero Crossings Rate', `${Math.round(analysis.technicalData.zcr)}`, 'zeroCrossings', 'zeroCrossings', 'advanced'));
                }
                
                // === MFCC (primeiros coeficientes) ===
                if (Array.isArray(analysis.technicalData?.mfcc) && analysis.technicalData.mfcc.length > 0) {
                    analysis.technicalData.mfcc.slice(0, 3).forEach((coeff, idx) => {
                        if (Number.isFinite(coeff)) {
                            const mfccKey = `mfcc${idx + 1}`;
                            rows.push(row(`MFCC ${idx + 1}`, `${safeFixed(coeff, 3)}`, mfccKey, mfccKey, 'advanced'));
                        }
                    });
                }
                
                // === SUGESTÃ•ES DISPONÃVEIS (movido de SCORES & DIAGNÃ“STICO) ===
                const suggestionsCount = analysis.suggestions?.length || 0;
                log('[AUDITORIA-SUGESTOES] SugestÃµes detectadas:', suggestionsCount);
                
                if (suggestionsCount > 0) {
                    rows.push(row('SugestÃµes', `<span class="tag tag-success">${suggestionsCount} DISPONÃVEL${suggestionsCount > 1 ? 'S' : ''}</span>`, 'suggestions', 'suggestions', 'advanced'));
                }
                
                return rows.join('') || row('Status', 'Sem mÃ©tricas avanÃ§adas disponÃ­veis');
            };

            // Card extra: Problemas TÃ©cnicos detalhados
            const techProblems = () => {
                const rows = [];
                let hasActualProblems = false;
                
                // ===== SEMPRE MOSTRAR TODAS AS MÃ‰TRICAS TÃ‰CNICAS =====
                
                // 1. Clipping - SEMPRE mostrar com valores reais
                const clipVal = Number.isFinite(analysis.technicalData?.clippingSamples) ? analysis.technicalData.clippingSamples : 0;
                const clipPct = Number.isFinite(analysis.technicalData?.clippingPct) ? analysis.technicalData.clippingPct : 0;
                // ğŸ¯ CLIPPING PRECEDENCE V2: Usar nova lÃ³gica de precedÃªncia
                const peak = Number.isFinite(analysis.technicalData?.peak) ? analysis.technicalData.peak : -Infinity;
                const truePeak = Number.isFinite(analysis.technicalData?.truePeakDbtp) ? analysis.technicalData.truePeakDbtp : null;
                
                // Verificar se temos dados do novo sistema de precedÃªncia
                const precedenceData = analysis.technicalData?._singleStage;
                let hasClippingProblem, clipText, clipClass;
                
                if (precedenceData && precedenceData.source === 'enhanced-clipping-v2') {
                    // ğŸš€ Usar novo sistema de precedÃªncia
                    const isClipped = precedenceData.finalState === 'CLIPPED';
                    const isTruePeakOnly = precedenceData.finalState === 'TRUE_PEAK_ONLY';
                    hasClippingProblem = isClipped || isTruePeakOnly;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = isClipped ? 'error' : 'warn'; // CLIPPED Ã© mais severo que TRUE_PEAK_ONLY
                        
                        const details = [];
                        if (isClipped) {
                            details.push(`ğŸ”´ CLIPPED: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                            if (precedenceData.precedenceApplied) {
                                details.push(`TP override: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                            }
                        } else if (isTruePeakOnly) {
                            details.push(`ğŸŸ¡ TruePeak: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        }
                        
                        if (precedenceData.clippingSamples > 0) {
                            details.push(`${precedenceData.clippingSamples} samples (${precedenceData.clippingPct.toFixed(3)}%)`);
                        }
                        
                        clipText = details.join(' | ');
                    } else {
                        // Estado limpo com novo sistema
                        const safeDetails = [];
                        safeDetails.push(`âœ… Sample: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                        safeDetails.push(`TP: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        safeDetails.push(`${precedenceData.clippingSamples} samples`);
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                } else {
                    // ğŸ”„ Fallback para sistema legado
                    const hasPeakClipping = peak > -0.1;
                    const hasTruePeakClipping = truePeak !== null && truePeak > -0.1;
                    const hasSampleClipping = clipVal > 0;
                    const hasPercentageClipping = clipPct > 0;
                    
                    hasClippingProblem = hasPeakClipping || hasTruePeakClipping || hasSampleClipping || hasPercentageClipping;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = 'warn';
                        
                        const details = [];
                        if (hasPeakClipping) details.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (hasTruePeakClipping) details.push(`TruePeak: ${truePeak.toFixed(2)}dBTP`);
                        if (hasSampleClipping) details.push(`${clipVal} samples (${clipPct.toFixed(3)}%)`);
                        
                        clipText = details.join(' | ');
                    } else {
                        const safeDetails = [];
                        safeDetails.push(`${clipVal} samples`);
                        if (peak > -Infinity) safeDetails.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (truePeak !== null) safeDetails.push(`TP: ${truePeak.toFixed(2)}dBTP`);
                        
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                }
                rows.push(row('Clipping', `<span class="${clipClass}">${clipText}</span>`, 'clippingSamples', 'clippingSamples', 'advanced'));
                
                // 2. DC Offset - SEMPRE mostrar (usando nova estrutura)
                let dcVal, hasDcProblem, dcClass;
                if (analysis.dcOffset && Number.isFinite(analysis.dcOffset.maxAbsDC)) {
                    // Usar nova estrutura detalhada
                    dcVal = analysis.dcOffset.maxAbsDC;
                    hasDcProblem = analysis.dcOffset.needsCorrection || analysis.dcOffset.severity !== 'none';
                    dcClass = hasDcProblem ? (analysis.dcOffset.isCritical ? 'error' : 'warn') : '';
                    if (hasDcProblem) hasActualProblems = true;
                    const dcDetails = `Max: ${safeFixed(dcVal, 4)} | L: ${safeFixed(analysis.dcOffset.leftDC, 4)} | R: ${safeFixed(analysis.dcOffset.rightDC, 4)} | ${analysis.dcOffset.severity}`;
                    rows.push(row('DC Offset (Detalhado)', `<span class="${dcClass}">${dcDetails}</span>`, 'dcOffset', 'dcOffset', 'advanced'));
                } else {
                    // Fallback para estrutura legada
                    dcVal = Number.isFinite(analysis.technicalData?.dcOffset) ? analysis.technicalData.dcOffset : 0;
                    hasDcProblem = Math.abs(dcVal) > 0.01;
                    if (hasDcProblem) hasActualProblems = true;
                    dcClass = hasDcProblem ? 'warn' : '';
                    rows.push(row('DC Offset', `<span class="${dcClass}">${safeFixed(dcVal, 4)}</span>`, 'dcOffset', 'dcOffset', 'advanced'));
                }
                
                // 3. THD - SEMPRE mostrar
                const thdVal = Number.isFinite(analysis.technicalData?.thdPercent) ? analysis.technicalData.thdPercent : 0;
                const hasThdProblem = thdVal > 1.0;
                if (hasThdProblem) hasActualProblems = true;
                const thdClass = hasThdProblem ? 'warn' : '';
                rows.push(row('THD', `<span class="${thdClass}">${safeFixed(thdVal, 2)}%</span>`, 'thdPercent', 'thdPercent', 'advanced'));
                
                // 4. Stereo Correlation - SEMPRE mostrar
                const stereoCorr = Number.isFinite(analysis.technicalData?.stereoCorrelation) ? analysis.technicalData.stereoCorrelation : 0;
                const hasStereoProb = stereoCorr !== null && (stereoCorr < -0.3 || stereoCorr > 0.95);
                if (hasStereoProb) hasActualProblems = true;
                const stereoClass = hasStereoProb ? 'warn' : '';
                let stereoText = safeFixed(stereoCorr, 3);
                if (hasStereoProb) {
                    const status = stereoCorr < -0.3 ? 'Fora de fase' : 'Mono demais';
                    stereoText += ` (${status})`;
                }
                rows.push(row('Stereo Corr.', `<span class="${stereoClass}">${stereoText}</span>`, 'stereoCorrelation', 'stereoCorrelation', 'advanced'));
                
                // 5. Fator de Crista - SEMPRE mostrar  
                const crestVal = Number.isFinite(analysis.technicalData?.crestFactor) ? analysis.technicalData.crestFactor : 0;
                const hasCrestProblem = crestVal < 6 || crestVal > 20; // Valores normais: 6-20dB
                if (hasCrestProblem) hasActualProblems = true;
                const crestClass = hasCrestProblem ? 'warn' : '';
                rows.push(row('Fator de Crista', `<span class="${crestClass}">${safeFixed(crestVal, 1)} dB</span>`, 'crestFactor', 'crestFactor', 'advanced'));
                
                // ConsistÃªncia (se disponÃ­vel) - mas sempre tentar mostrar
                if (analysis.metricsValidation && Object.keys(analysis.metricsValidation).length) {
                    const mv = analysis.metricsValidation;
                    const badge = (k,v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:${v==='ok'?'#143f2b':(v==='warn'?'#4d3808':'#4a1d1d')};color:${v==='ok'?'#29c182':(v==='warn'?'#ffce4d':'#ff7d7d')};margin-left:6px;">${v}</span>`;
                    
                    if (mv.dynamicRangeConsistency) {
                        rows.push(row('DR ConsistÃªncia', `Î”=${mv.dynamicRangeDelta || '0'} ${badge('dr', mv.dynamicRangeConsistency)}`, 'drConsistency', 'drConsistency', 'advanced'));
                        if (mv.dynamicRangeConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('DR ConsistÃªncia', `<span style="opacity:0.6;">Î”=0 ${badge('dr', 'ok')}</span>`, 'drConsistency', 'drConsistency', 'advanced'));
                    }
                    
                    if (mv.crestFactorConsistency) {
                        rows.push(row('Crest Consist.', `Î”=${mv.crestVsExpectedDelta || '0'} ${badge('cf', mv.crestFactorConsistency)}`, 'crestConsistency', 'crestConsistency', 'advanced'));
                        if (mv.crestFactorConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Î”=0 ${badge('cf', 'ok')}</span>`, 'crestConsistency', 'crestConsistency', 'advanced'));
                    }
                    
                    if (mv.lraPlausibility) {
                        rows.push(row('LRA PlausÃ­vel', badge('lra', mv.lraPlausibility), 'lraPlausibility', 'lraPlausibility', 'advanced'));
                        if (mv.lraPlausibility !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('LRA PlausÃ­vel', `<span style="opacity:0.6;">${badge('lra', 'ok')}</span>`, 'lraPlausibility', 'lraPlausibility', 'advanced'));
                    }
                } else {
                    // Mostrar como nÃ£o disponÃ­vel/OK
                    const badge = (v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:#143f2b;color:#29c182;margin-left:6px;">${v}</span>`;
                    rows.push(row('DR ConsistÃªncia', `<span style="opacity:0.6;">Î”=0 ${badge('ok')}</span>`, 'drConsistency', 'drConsistency', 'advanced'));
                    rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Î”=0 ${badge('ok')}</span>`, 'crestConsistency', 'crestConsistency', 'advanced'));
                    rows.push(row('LRA PlausÃ­vel', `<span style="opacity:0.6;">${badge('ok')}</span>`, 'lraPlausibility', 'lraPlausibility', 'advanced'));
                }
                
                return rows.join('');
            };

            // Card extra: DiagnÃ³stico & SugestÃµes listados
            const diagCard = () => {
                // =========================================================================
                // ğŸš¨ AUDITORIA: RENDERIZAÃ‡ÃƒO DE SUGESTÃ•ES
                // =========================================================================
                log('[RENDER_SUGGESTIONS] âœ… Iniciada');
                
                const blocks = [];
                
                // ğŸ” DEBUG: Verificar estado das sugestÃµes
                log('ğŸ” [DEBUG_SUGGESTIONS] analysis.suggestions:', analysis.suggestions);
                log('ğŸ” [DEBUG_SUGGESTIONS] anÃ¡lise completa de sugestÃµes:', {
                    hasAnalysis: !!analysis,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsType: typeof analysis.suggestions,
                    suggestionsLength: analysis.suggestions?.length || 0,
                    suggestionsArray: analysis.suggestions
                });

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ğŸ¯ NORMALIZAÃ‡ÃƒO E VALIDAÃ‡ÃƒO BASEADA NA TABELA
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                /**
                 * Normaliza nomes de severidade para padrÃ£o Ãºnico
                 * @param {string|object} sev - Severidade (string ou objeto com .level/.label)
                 * @returns {string} - 'OK', 'ATENÃ‡ÃƒO', 'ALTA', 'CRÃTICA', 'N/A'
                 */
                const normalizeSeverity = (sev) => {
                    if (!sev) return 'N/A';
                    
                    const str = (typeof sev === 'object' ? (sev.level || sev.label || '') : String(sev)).toLowerCase().trim();
                    
                    // Mapear variaÃ§Ãµes para padrÃ£o da tabela
                    if (str === 'ok' || str === 'ideal' || str === 'perfeito') return 'OK';
                    if (str.includes('aten') || str === 'warning' || str === 'caution' || str === 'ajuste_leve' || str === 'leve') return 'ATENÃ‡ÃƒO';
                    if (str.includes('alt') || str === 'high') return 'ALTA';
                    if (str.includes('crit') || str.includes('crÃ­t') || str === 'corrigir' || str === 'severa' || str === 'critical') return 'CRÃTICA';
                    
                    // Se nÃ£o reconhecer, assumir que precisa atenÃ§Ã£o
                    return 'ATENÃ‡ÃƒO';
                };
                
                /**
                 * Normaliza chaves de mÃ©tricas para buscar nos dados
                 * @param {string} key - Chave da mÃ©trica
                 * @returns {string} - Chave normalizada
                 */
                const normalizeMetricKey = (key) => {
                    if (!key) return '';
                    const k = String(key).toLowerCase().replace(/[^a-z0-9_]/g, '');
                    
                    // MÃ©tricas principais
                    if (k.includes('loudness') || k.includes('lufs') || k === 'lufsintegrated') return 'loudness_integrated';
                    if (k.includes('truepeak') || k.includes('dbtp') || k === 'tp') return 'true_peak';
                    if (k.includes('dynamic') || k === 'dr') return 'dynamics';
                    if (k === 'lra' || k.includes('loudnessrange')) return 'lra';
                    if (k.includes('stereo') || k.includes('image')) return 'stereo';
                    
                    return k;
                };
                
                /**
                 * Normaliza chaves de bandas espectrais
                 * @param {string} key - Chave da banda
                 * @returns {string} - Chave normalizada
                 */
                const normalizeBandKey = (key) => {
                    if (!key) return '';
                    const k = String(key).toLowerCase().replace(/[^a-z0-9_]/g, '');
                    
                    // Remover prefixo band_ se existir
                    const clean = k.replace(/^band_/, '');
                    
                    // Mapeamento de aliases
                    if (clean === 'sub' || clean === 'subbass') return 'sub';
                    if (clean === 'bass' || clean === 'lowbass' || clean === 'low_bass') return 'bass';
                    if (clean === 'upperbass' || clean === 'upper_bass') return 'upperBass';
                    if (clean === 'lowmid' || clean === 'low_mid') return 'lowMid';
                    if (clean === 'mid' || clean === 'midrange') return 'mid';
                    if (clean === 'highmid' || clean === 'high_mid') return 'highMid';
                    if (clean === 'presence' || clean === 'presenca' || clean === 'presenÃ§a') return 'presence';
                    if (clean === 'air' || clean === 'brilliance' || clean === 'brilho') return 'air';
                    
                    return clean;
                };
                
                /**
                 * Calcula severidade da mÃ©trica usando MESMA LÃ“GICA DA TABELA
                 * @param {number} value - Valor medido
                 * @param {number} target - Valor target
                 * @param {number} tolerance - TolerÃ¢ncia
                 * @param {object} options - { targetRange }
                 * @returns {object} - { severity, diff, action }
                 */
                const calcTableSeverity = (value, target, tolerance, options = {}) => {
                    const { targetRange } = options;
                    
                    if (!Number.isFinite(value)) {
                        return { severity: 'N/A', diff: 0, action: 'Sem dados' };
                    }
                    
                    // PRIORIDADE: target_range
                    if (targetRange && typeof targetRange === 'object') {
                        const min = targetRange.min ?? targetRange.min_db;
                        const max = targetRange.max ?? targetRange.max_db;
                        
                        if (typeof min === 'number' && typeof max === 'number') {
                            // Dentro do range = OK
                            if (value >= min && value <= max) {
                                return { severity: 'OK', diff: 0, action: 'âœ… Dentro do padrÃ£o' };
                            }
                            
                            // Fora do range: calcular distÃ¢ncia
                            let diff, absDelta;
                            if (value < min) {
                                diff = value - min;
                                absDelta = min - value;
                            } else {
                                diff = value - max;
                                absDelta = value - max;
                            }
                            
                            if (absDelta >= 2) {
                                const action = diff > 0 ? `Reduzir ${absDelta.toFixed(1)}` : `Aumentar ${absDelta.toFixed(1)}`;
                                return { severity: 'CRÃTICA', diff, action };
                            } else {
                                const action = diff > 0 ? `Reduzir ${absDelta.toFixed(1)}` : `Aumentar ${absDelta.toFixed(1)}`;
                                return { severity: 'ATENÃ‡ÃƒO', diff, action };
                            }
                        }
                    }
                    
                    // FALLBACK: target Â± tolerance
                    if (target === null || target === undefined) {
                        return { severity: 'N/A', diff: 0, action: 'Sem dados' };
                    }
                    
                    const diff = value - target;
                    const absDiff = Math.abs(diff);
                    
                    if (absDiff <= tolerance) {
                        return { severity: 'OK', diff, action: 'âœ… Dentro do padrÃ£o' };
                    } else if (absDiff <= tolerance * 2) {
                        return { severity: 'ATENÃ‡ÃƒO', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    } else if (absDiff <= tolerance * 3) {
                        return { severity: 'ALTA', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    } else {
                        return { severity: 'CRÃTICA', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    }
                };
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ğŸ›¡ï¸ FILTRO MASTER: Validar cada sugestÃ£o contra severidade da TABELA
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                const validateSuggestionAgainstTable = (sug) => {
                    try {
                        // Extrair dados da anÃ¡lise
                        const metrics = analysis?.data?.metrics;
                        const targets = analysis?.data?.genreTargets;
                        
                        if (!metrics || !targets) {
                            warn('[SUGGESTION_VALIDATOR] Sem metrics/targets - permitindo sugestÃ£o', sug.metric);
                            return { valid: true, reason: 'no_data_to_validate' };
                        }
                        
                        // Normalizar mÃ©trica/banda
                        const metricRaw = sug.metric || sug.type || '';
                        const isBand = metricRaw.includes('band_') || metricRaw.includes('Bass') || metricRaw.includes('Mid') || metricRaw.includes('Sub');
                        
                        let measuredValue = null;
                        let targetConfig = null;
                        let metricName = '';
                        
                        if (isBand) {
                            const bandKey = normalizeBandKey(metricRaw);
                            metricName = `band_${bandKey}`;
                            
                            // Buscar valor medido
                            const bandData = metrics.bands?.[bandKey];
                            if (bandData) {
                                measuredValue = bandData.energy_db ?? bandData.rms_db ?? bandData.db ?? bandData.value;
                            }
                            
                            // Buscar target
                            targetConfig = targets.bands?.[bandKey];
                        } else {
                            const metricKey = normalizeMetricKey(metricRaw);
                            metricName = metricKey;
                            
                            // Mapeamento de mÃ©tricas principais
                            const metricMap = {
                                'loudness_integrated': { key: 'loudness', targetKey: 'lufs', tolKey: 'tol_lufs' },
                                'true_peak': { key: 'truePeak', targetKey: 'truePeak', tolKey: 'tol_true_peak' },
                                'dynamics': { key: 'dr', targetKey: 'dr', tolKey: 'tol_dr' },
                                'lra': { key: 'lra', targetKey: 'lra', tolKey: 'tol_lra' },
                                'stereo': { key: 'stereo', targetKey: 'stereo', tolKey: 'tol_stereo' }
                            };
                            
                            const mapping = metricMap[metricKey];
                            if (mapping) {
                                const metricData = metrics[mapping.key];
                                measuredValue = metricData?.value ?? metricData;
                                
                                targetConfig = {
                                    target: targets[mapping.targetKey]?.target,
                                    tolerance: targets[mapping.targetKey]?.tolerance ?? targets[mapping.tolKey] ?? 1.0,
                                    target_range: targets[mapping.targetKey]?.target_range
                                };
                            }
                        }
                        
                        // Se nÃ£o conseguiu encontrar valor ou target, permitir (fail-safe)
                        if (!Number.isFinite(measuredValue) || !targetConfig) {
                            warn('[SUGGESTION_VALIDATOR] âš ï¸ NÃ£o encontrou dados para validar:', {
                                metric: metricName,
                                measuredValue,
                                hasTarget: !!targetConfig
                            });
                            return { valid: true, reason: 'incomplete_data' };
                        }
                        
                        // Calcular severidade usando MESMA lÃ³gica da tabela
                        const tableSeverity = calcTableSeverity(
                            measuredValue,
                            targetConfig.target ?? targetConfig.target_db,
                            targetConfig.tolerance ?? targetConfig.tol_db ?? 2.0,
                            { targetRange: targetConfig.target_range }
                        );
                        
                        // Normalizar severidade da sugestÃ£o
                        const sugSeverity = normalizeSeverity(sug.severity);
                        
                        // REGRA ABSOLUTA: Se tabela diz OK, PROIBIR sugestÃ£o
                        if (tableSeverity.severity === 'OK') {
                            log(`[SUGGESTION_VALIDATOR] âŒ BLOQUEADO: ${metricName} estÃ¡ OK na tabela`, {
                                measured: measuredValue.toFixed(2),
                                tableSeverity: tableSeverity.severity,
                                sugSeverity: sugSeverity,
                                diff: tableSeverity.diff
                            });
                            return { valid: false, reason: 'table_says_ok', tableSeverity: 'OK' };
                        }
                        
                        // Se tabela diz que precisa atenÃ§Ã£o/correÃ§Ã£o, PERMITIR
                        log(`[SUGGESTION_VALIDATOR] âœ… PERMITIDO: ${metricName}`, {
                            measured: measuredValue.toFixed(2),
                            tableSeverity: tableSeverity.severity,
                            sugSeverity: sugSeverity,
                            diff: tableSeverity.diff
                        });
                        
                        return { 
                            valid: true, 
                            reason: 'table_confirms_issue',
                            tableSeverity: tableSeverity.severity,
                            tableCalc: tableSeverity
                        };
                        
                    } catch (error) {
                        error('[SUGGESTION_VALIDATOR] Erro ao validar:', error);
                        return { valid: true, reason: 'validation_error' };  // Fail-safe: permitir em caso de erro
                    }
                };

                // ğŸš€ INTEGRAÃ‡ÃƒO SISTEMA ULTRA-AVANÃ‡ADO V2: Enriquecimento direto das sugestÃµes existentes
                let enrichedSuggestions = analysis.suggestions || [];
                
                if (typeof window.UltraAdvancedSuggestionEnhancer !== 'undefined' && enrichedSuggestions.length > 0) {
                    try {
                        log('ğŸš€ [ULTRA_V2] Iniciando sistema ultra-avanÃ§ado V2...');
                        log('ğŸ“Š [ULTRA_V2] SugestÃµes para enriquecer:', enrichedSuggestions.length);
                        
                        const ultraEnhancer = new window.UltraAdvancedSuggestionEnhancer();
                        
                        // Preparar contexto de anÃ¡lise
                        const analysisContext = {
                            detectedGenre: analysis.detectedGenre || 'general',
                            fileName: analysis.fileName,
                            duration: analysis.duration,
                            sampleRate: analysis.sampleRate,
                            mode: analysis.mode || 'genre',
                            // âœ… MODO REFERENCE: Adicionar dados de comparaÃ§Ã£o A/B
                            referenceComparison: analysis.referenceComparison || null,
                            referenceJobId: analysis.referenceJobId || null,
                            referenceFileName: analysis.referenceFileName || null
                        };
                        
                        // ğŸ¯ MODO GENRE: Usar EXCLUSIVAMENTE analysis.data (metrics + genreTargets)
                        // âŒ SEM FALLBACKS - se nÃ£o existir, lista vazia
                        if (analysis.mode === "genre") {
                            // âœ… EXTRAIR METRICS de analysis.data.metrics
                            const metrics = analysis?.data?.metrics;
                            const correctTargets = getCorrectTargets(analysis);
                            
                            if (!metrics) {
                                error('[ULTRA_V2] âŒ CRÃTICO: analysis.data.metrics nÃ£o encontrado');
                                throw new Error('NO_METRICS_FROM_BACKEND');
                            }
                            
                            if (!correctTargets) {
                                error('[ULTRA_V2] âŒ CRÃTICO: analysis.data.genreTargets nÃ£o encontrado (Postgres)');
                                throw new Error('NO_TARGETS_FROM_POSTGRES');
                            }
                            
                            log('[ULTRA_V2] âœ… Injetando metrics e correctTargets em analysisContext');
                            log('[ULTRA_V2] Metrics:', {
                                loudness: metrics.loudness,
                                truePeak: metrics.truePeak,
                                dr: metrics.dr,
                                stereo: metrics.stereo,
                                hasBands: !!metrics.bands
                            });
                            log('[ULTRA_V2] Targets:', {
                                lufs: correctTargets.lufs,
                                truePeak: correctTargets.truePeak,
                                dr: correctTargets.dr,
                                stereo: correctTargets.stereo,
                                hasBands: !!correctTargets.bands
                            });
                            
                            // âœ… INJETAR NO CONTEXT
                            analysisContext.metrics = metrics;
                            analysisContext.correctTargets = correctTargets;
                        }
                        // ğŸ›¡ï¸ MODO REFERENCE: NÃ£o injetar nada - usa dados de comparaÃ§Ã£o A/B
                        
                        // âœ… Log para modo reference
                        if (analysisContext.mode === 'reference' && analysisContext.referenceComparison) {
                            log('[ULTRA_V2] ğŸ¯ Modo reference detectado - enriquecendo com dados de comparaÃ§Ã£o A/B');
                            log('[ULTRA_V2] ReferÃªncia:', analysisContext.referenceFileName);
                            log('[ULTRA_V2] Deltas disponÃ­veis:', Object.keys(analysisContext.referenceComparison));
                        }
                        
                        // ğŸš€ Enriquecer sugestÃµes existentes
                        const ultraResults = ultraEnhancer.enhanceExistingSuggestions(enrichedSuggestions, analysisContext);
                        
                        if (ultraResults && ultraResults.enhancedSuggestions && ultraResults.enhancedSuggestions.length > 0) {
                            enrichedSuggestions = ultraResults.enhancedSuggestions;
                            
                            log('âœ¨ [ULTRA_V2] Sistema ultra-avanÃ§ado V2 aplicado com sucesso!', {
                                originalCount: analysis.suggestions?.length || 0,
                                enhancedCount: enrichedSuggestions.length,
                                processingTime: ultraResults.metadata?.processingTimeMs,
                                educationalLevel: ultraResults.metadata?.educationalLevel
                            });
                            
                            // Adicionar mÃ©tricas do sistema ultra-avanÃ§ado Ã  anÃ¡lise
                            if (!analysis.enhancedMetrics) analysis.enhancedMetrics = {};
                            analysis.enhancedMetrics.ultraAdvancedSystem = {
                                applied: true,
                                version: ultraResults.metadata?.version,
                                processingTimeMs: ultraResults.metadata?.processingTimeMs,
                                enhancedCount: enrichedSuggestions.length,
                                educationalLevel: ultraResults.metadata?.educationalLevel,
                                originalCount: ultraResults.metadata?.originalCount
                            };
                            
                            // âœ… Log da primeira sugestÃ£o enriquecida para debug
                            if (enrichedSuggestions.length > 0) {
                                const firstEnhanced = enrichedSuggestions[0];
                                log('ğŸ“ [ULTRA_V2] Exemplo de sugestÃ£o enriquecida:', {
                                    original: firstEnhanced.message,
                                    educationalTitle: firstEnhanced.educationalContent?.title,
                                    hasDAWExamples: !!(firstEnhanced.educationalContent?.dawExamples),
                                    severity: firstEnhanced.severity?.label,
                                    priority: firstEnhanced.priority
                                });
                            }
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… VALIDAÃ‡ÃƒO FINAL: Confirmar sistema configurado corretamente
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            if (analysisContext.mode === 'genre' && analysisContext.correctTargets && analysisContext.metrics) {
                                log('');
                                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                                log('âœ… [VALIDAÃ‡ÃƒO FINAL] Sistema de SugestÃµes IA Configurado');
                                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                                log('ğŸ“Š Fonte de Metrics: analysis.data.metrics');
                                log('ğŸ“Š Fonte de Targets: analysis.data.genreTargets (Postgres)');
                                log('ğŸ“Š Modo de AnÃ¡lise:', analysisContext.mode);
                                log('ğŸ“Š Metrics Injetados:', {
                                    loudness: analysisContext.metrics.loudness?.value,
                                    truePeak: analysisContext.metrics.truePeak?.value,
                                    dr: analysisContext.metrics.dr?.value,
                                    stereo: analysisContext.metrics.stereo?.value
                                });
                                log('ğŸ“Š Targets Injetados:', {
                                    lufs: analysisContext.correctTargets.lufs?.target,
                                    truePeak: analysisContext.correctTargets.truePeak?.target,
                                    dr: analysisContext.correctTargets.dr?.target,
                                    stereo: analysisContext.correctTargets.stereo?.target
                                });
                                log('ğŸ“Š DiferenÃ§as Calculadas:', {
                                    lufs: (analysisContext.metrics.loudness?.value - analysisContext.correctTargets.lufs?.target).toFixed(2),
                                    truePeak: (analysisContext.metrics.truePeak?.value - analysisContext.correctTargets.truePeak?.target).toFixed(2),
                                    dr: (analysisContext.metrics.dr?.value - analysisContext.correctTargets.dr?.target).toFixed(2),
                                    stereo: (analysisContext.metrics.stereo?.value - analysisContext.correctTargets.stereo?.target).toFixed(4)
                                });
                                log('ğŸ“Š Total de SugestÃµes Enriquecidas:', enrichedSuggestions.length);
                                log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                                log('');
                            }
                            
                        } else {
                            warn('âš ï¸ [ULTRA_V2] Sistema nÃ£o retornou sugestÃµes vÃ¡lidas:', ultraResults);
                        }
                        
                    } catch (error) {
                        error('âŒ [ULTRA_V2] Erro no sistema ultra-avanÃ§ado V2:', error);
                        // Manter sugestÃµes originais em caso de erro
                    }
                } else {
                    if (typeof window.UltraAdvancedSuggestionEnhancer === 'undefined') {
                        log('âš ï¸ [ULTRA_V2] Sistema ultra-avanÃ§ado V2 nÃ£o estÃ¡ disponÃ­vel');
                    } else {
                        log('âš ï¸ [ULTRA_V2] Nenhuma sugestÃ£o para processar');
                    }
                }
                
                // ğŸ›¡ï¸ FILTRO MASTER: Validar TODAS as sugestÃµes contra severidade da TABELA
                log('[SUGGESTION_FILTER] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('[SUGGESTION_FILTER] Iniciando validaÃ§Ã£o de', enrichedSuggestions.length, 'sugestÃµes');
                
                let countOk = 0;
                let countBlocked = 0;
                let countAllowed = 0;
                let countErrors = 0;
                
                const validatedSuggestions = enrichedSuggestions.filter((s, idx) => {
                    const validation = validateSuggestionAgainstTable(s);
                    
                    if (!validation.valid) {
                        countBlocked++;
                        if (validation.tableSeverity === 'OK') countOk++;
                        log(`[SUGGESTION_FILTER] âŒ #${idx + 1} BLOQUEADO:`, {
                            metric: s.metric || s.type,
                            reason: validation.reason,
                            tableSeverity: validation.tableSeverity
                        });
                        return false;
                    }
                    
                    countAllowed++;
                    if (validation.reason === 'validation_error') countErrors++;
                    return true;
                });
                
                log('[SUGGESTION_FILTER] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                log('[SUGGESTION_FILTER] ğŸ“Š RESULTADO DA VALIDAÃ‡ÃƒO:');
                log('[SUGGESTION_FILTER]   - Total recebidas:', enrichedSuggestions.length);
                log('[SUGGESTION_FILTER]   - âœ… Permitidas:', countAllowed);
                log('[SUGGESTION_FILTER]   - âŒ Bloqueadas:', countBlocked);
                log('[SUGGESTION_FILTER]   - ğŸ”´ Falso-positivos (OK na tabela):', countOk);
                log('[SUGGESTION_FILTER]   - âš ï¸ Erros de validaÃ§Ã£o:', countErrors);
                log('[SUGGESTION_FILTER] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Atualizar analysis.suggestions com as sugestÃµes validadas
                analysis.suggestions = validatedSuggestions;

                // Helpers para embelezar as sugestÃµes sem mudar layout/IDs
                const formatNumbers = (text, decimals = 2) => {
                    if (!text || typeof text !== 'string') return '';
                    return text.replace(/(-?\d+\.\d{3,})/g, (m) => {
                        const n = parseFloat(m);
                        return Number.isFinite(n) ? n.toFixed(decimals) : m;
                    });
                };
                const renderSuggestionItem = (sug) => {
                    // ğŸš€ PRIORIDADE: Verificar se tem conteÃºdo educacional do Sistema Ultra-AvanÃ§ado V2
                    const hasUltraV2Content = sug.educationalContent && sug.educationalContent.title;
                    
                    if (hasUltraV2Content) {
                        // ï¿½ SISTEMA ULTRA-AVANÃ‡ADO V2: Renderizar com conteÃºdo educacional completo
                        const edu = sug.educationalContent;
                        const severity = sug.severity || { level: 'medium', color: '#FF9800', label: 'Moderada' };
                        
                        // Extrair frequÃªncia se disponÃ­vel
                        const freqMatch = (edu.action || sug.action || '').match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz|khz|kHz)/i);
                        const frequency = freqMatch ? freqMatch[1] : null;
                        
                        return `
                            <div class="enhanced-card ultra-advanced-v2">
                                <div class="card-header">
                                    <h4 class="card-title">${edu.title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency}${frequency > 1000 ? 'Hz' : 'kHz'}</span>` : ''}
                                        <span class="severity-badge ${severity.level}" style="background-color: ${severity.color};">${severity.label}</span>
                                        <span class="priority-badge">P${sug.priority || 5}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: ${severity.color};">
                                    <strong>ğŸ“š ExplicaÃ§Ã£o:</strong> ${edu.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50;">
                                    <div class="card-action-title">ğŸ”§ AÃ§Ã£o Recomendada</div>
                                    <div class="card-action-content">${edu.action}</div>
                                </div>
                                
                                ${edu.dawExamples ? `
                                    <div class="card-daw-examples" style="background: rgba(33, 150, 243, 0.1); border-color: #2196F3; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                                        <div class="card-daw-title" style="font-weight: bold; margin-bottom: 8px; color: #2196F3;">ğŸ›ï¸ Exemplos por DAW</div>
                                        ${Object.entries(edu.dawExamples).map(([daw, instruction]) => 
                                            `<div style="margin-bottom: 6px;"><strong>${daw}:</strong> ${instruction}</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                                
                                ${edu.expectedResult ? `
                                    <div class="card-result" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                                        <div class="card-result-title" style="font-weight: bold; margin-bottom: 8px; color: #4CAF50;">âœ¨ Resultado Esperado</div>
                                        <div class="card-result-content">${edu.expectedResult}</div>
                                    </div>
                                ` : ''}
                                
                                ${edu.technicalDetails ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa; font-weight: bold;">ğŸ“‹ Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;">${edu.technicalDetails}</div>
                                    </details>
                                ` : ''}
                                
                                ${sug.educationalMetadata ? `
                                    <div class="educational-metadata" style="margin-top: 12px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; font-size: 11px; color: #888;">
                                        ğŸ“– Tempo de leitura: ${sug.educationalMetadata.estimatedReadTime} | 
                                        ğŸ¯ Dificuldade: ${sug.educationalMetadata.practicalDifficulty} | 
                                        ğŸ§  Conceitos: ${sug.educationalMetadata.concepts?.join(', ') || 'N/A'}
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    // ğŸ”„ FALLBACK: Sistema anterior se nÃ£o tiver conteÃºdo Ultra-AvanÃ§ado V2
                    const hasTextGenerator = typeof window.SuggestionTextGenerator !== 'undefined';
                    let didacticText = null;
                    
                    if (hasTextGenerator) {
                        try {
                            const generator = new window.SuggestionTextGenerator();
                            didacticText = generator.generateDidacticText(sug);
                        } catch (error) {
                            warn('[RenderSuggestion] Erro no gerador de texto:', error);
                        }
                    }
                    
                    // Usar texto didÃ¡tico se disponÃ­vel, senÃ£o usar texto original
                    const title = didacticText?.title || sug.message || '';
                    const explanation = didacticText?.explanation || sug.explanation || '';
                    const action = didacticText?.action || sug.action || '';
                    const rationale = didacticText?.rationale || '';
                    const technical = didacticText?.technical || sug.details || '';
                    
                    // ğŸ¯ SISTEMA MELHORADO: Verificar se tem informaÃ§Ãµes de severidade e prioridade
                    const hasEnhancedInfo = sug.severity && sug.priority;
                    const severityColor = hasEnhancedInfo ? sug.severity.color : '#9fb3d9';
                    const severityLevel = hasEnhancedInfo ? sug.severity.level : 'medium';
                    const severityLabel = hasEnhancedInfo ? sug.severity.label : '';
                    const priority = hasEnhancedInfo ? sug.priority : 0;
                    const confidence = hasEnhancedInfo ? sug.confidence : 1;
                    
                    // Detectar tipo de sugestÃ£o
                    const isSurgical = sug.type === 'surgical_eq' || (sug.subtype && ['sibilance', 'harshness', 'clipping'].includes(sug.subtype));
                    const isBandAdjust = sug.type === 'band_adjust';
                    const isClipping = sug.type === 'clipping' || title.toLowerCase().includes('clipping');
                    const isBalance = sug.type === 'balance' || title.toLowerCase().includes('balance');
                    
                    // Determinar classe do card
                    let cardClass = 'enhanced-card';
                    if (isSurgical) cardClass += ' surgical';
                    else if (isBandAdjust) cardClass += ' band-adjust';
                    else if (isClipping) cardClass += ' clipping';
                    else if (isBalance) cardClass += ' balance';
                    else cardClass += ' problem';
                    
                    // Extrair frequÃªncia e valores tÃ©cnicos
                    const freqMatch = (title + ' ' + action).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                    const frequency = freqMatch ? freqMatch[1] : null;
                    
                    const dbMatch = action.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                    const dbValue = dbMatch ? dbMatch[1] : null;
                    
                    const qMatch = action.match(/Q\s*[=:]?\s*(\d+(?:\.\d+)?)/i);
                    const qValue = qMatch ? qMatch[1] : null;
                    
                    // Extrair faixa de frequÃªncia se disponÃ­vel
                    const frequencyRange = sug.frequency_range || '';
                    const adjustmentDb = sug.adjustment_db;
                    
                    // ğŸš¨ VERIFICAR SE Ã‰ UM AVISO CRÃTICO
                    if (didacticText?.isCritical) {
                        return `
                            <div class="${cardClass} critical-alert">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸš¨ Problema CrÃ­tico</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge severa">CRÃTICO</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: #f44336;">
                                    <strong>âš ï¸ Problema:</strong> ${didacticText.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                    <div class="card-action-title" style="color: #f44336;">
                                        ğŸš¨ AÃ§Ã£o Urgente
                                    </div>
                                    <div class="card-action-content">${didacticText.action}</div>
                                </div>
                                
                                <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                    <div class="card-impact-title" style="color: #f44336;">âš ï¸ Por que Ã© crÃ­tico</div>
                                    <div class="card-impact-content">${didacticText.rationale}</div>
                                </div>
                            </div>`;
                    }
                    
                    if (isSurgical) {
                        // Card cirÃºrgico aprimorado
                        const context = title.replace(/\[\d+Hz\]/, '').replace(/\d+Hz/, '').trim();
                        const severity = severityLevel === 'high' ? 'alta' : (severityLevel === 'medium' ? 'moderada' : 'leve');
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸ”§ CorreÃ§Ã£o CirÃºrgica</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severity}">${severity}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>Problema detectado:</strong> ${context || explanation || 'RessonÃ¢ncia problemÃ¡tica identificada'}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸ›ï¸ AÃ§Ã£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequency || qValue || dbValue) ? `
                                    <div class="card-technical">
                                        ${frequency ? `
                                            <div class="tech-item">
                                                <div class="tech-label">FrequÃªncia</div>
                                                <div class="tech-value">${frequency} Hz</div>
                                            </div>
                                        ` : ''}
                                        ${dbValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ganho</div>
                                                <div class="tech-value">${dbValue} dB</div>
                                            </div>
                                        ` : ''}
                                        ${qValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Q Factor</div>
                                                <div class="tech-value">${qValue}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">âš ï¸ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    } 
                    
                    else if (isBandAdjust) {
                        // Card de ajuste de banda aprimorado
                        const shouldBoost = adjustmentDb > 0 || action.toLowerCase().includes('aumentar') || action.toLowerCase().includes('boost');
                        const actionIcon = shouldBoost ? 'ğŸ“ˆ' : 'ğŸ“‰';
                        const actionType = shouldBoost ? 'Boost' : 'Corte';
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">${actionIcon} Ajuste de Banda</h4>
                                    <div class="card-badges">
                                        ${frequencyRange ? `<span class="frequency-badge">${frequencyRange}</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${actionType}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>AnÃ¡lise:</strong> ${explanation || title}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸšï¸ Como Ajustar
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequencyRange || adjustmentDb) ? `
                                    <div class="card-technical">
                                        ${frequencyRange ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Faixa</div>
                                                <div class="tech-value">${frequencyRange}</div>
                                            </div>
                                        ` : ''}
                                        ${adjustmentDb ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ajuste</div>
                                                <div class="tech-value">${adjustmentDb > 0 ? '+' : ''}${adjustmentDb.toFixed(1)} dB</div>
                                            </div>
                                        ` : ''}
                                        ${sug.details ? `
                                            <div class="tech-item" style="grid-column: span 2;">
                                                <div class="tech-label">Status</div>
                                                <div class="tech-value" style="font-size: 10px;">${sug.details.replace('Atual:', '').replace('Alvo:', 'â†’')}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">ğŸ’¡ Resultado Esperado</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    else {
                        // ğŸš¨ VERIFICAR SE Ã‰ TRUE PEAK COM MENSAGEM ESPECIAL
                        const isTruePeak = sug.type === 'reference_true_peak' || sug.metricType === 'true_peak' || 
                                         title.toLowerCase().includes('true peak') || title.toLowerCase().includes('tp');
                        const hasSpecialAlert = sug.specialAlert || sug.priorityWarning;
                        
                        if (isTruePeak && hasSpecialAlert) {
                            // Card especial para True Peak com mensagem de prioridade
                            return `
                                <div class="${cardClass} true-peak-priority">
                                    <div class="card-header">
                                        <h4 class="card-title">âš¡ ${title}</h4>
                                        <div class="card-badges">
                                            <span class="priority-badge primeiro">PRIMEIRO</span>
                                            <span class="severity-badge critica">CRÃTICO</span>
                                        </div>
                                    </div>
                                    
                                    ${sug.priorityWarning ? `
                                        <div class="priority-warning" style="background: rgba(255, 193, 7, 0.2); border: 1px solid #FFC107; border-radius: 6px; padding: 12px; margin: 12px 0; color: #856404;">
                                            ${sug.priorityWarning}
                                        </div>
                                    ` : ''}
                                    
                                    ${explanation ? `
                                        <div class="card-description" style="border-left-color: #FF5722;">
                                            <strong>âš ï¸ Por que Ã© prioritÃ¡rio:</strong> ${explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(255, 87, 34, 0.1); border-color: #FF5722;">
                                        <div class="card-action-title" style="color: #FF5722;">
                                            ğŸš¨ CorreÃ§Ã£o PrioritÃ¡ria
                                        </div>
                                        <div class="card-action-content">${action}</div>
                                    </div>
                                    
                                    ${sug.why ? `
                                        <div class="card-impact" style="background: rgba(255, 87, 34, 0.05); border-color: #FF5722;">
                                            <div class="card-impact-title" style="color: #FF5722;">ğŸ”´ Motivo da Prioridade</div>
                                            <div class="card-impact-content">${sug.why}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${technical ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                        </details>
                                    ` : ''}
                                </div>`;
                        }
                        
                        // Card genÃ©rico melhorado
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">ğŸµ ${title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${severityLabel || 'info'}</span>
                                    </div>
                                </div>
                                
                                ${explanation ? `
                                    <div class="card-description">
                                        <strong>ExplicaÃ§Ã£o:</strong> ${explanation}
                                    </div>
                                ` : ''}
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        ğŸ”§ AÃ§Ã£o Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">âš ï¸ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    }
                };
                if ((analysis.problems?.length || 0) > 0) {
                    // ğŸ¯ FunÃ§Ã£o local para deduplicar problemas por tipo
                    const deduplicateByType = (items) => {
                        const seen = new Map();
                        const deduplicated = [];
                        for (const item of items) {
                            if (!item || !item.type) continue;
                            
                            // ğŸ¯ CORREÃ‡ÃƒO: Para band_adjust, usar type + subtype como chave Ãºnica
                            let uniqueKey = item.type;
                            if (item.type === 'band_adjust' && item.subtype) {
                                uniqueKey = `${item.type}:${item.subtype}`;
                            }
                            
                            const existing = seen.get(uniqueKey);
                            if (!existing) {
                                seen.set(uniqueKey, item);
                                deduplicated.push(item);
                            } else {
                                // Manter o mais detalhado (com mais propriedades)
                                const currentScore = Object.keys(item).length + (item.explanation ? 10 : 0) + (item.impact ? 5 : 0);
                                const existingScore = Object.keys(existing).length + (existing.explanation ? 10 : 0) + (existing.impact ? 5 : 0);
                                if (currentScore > existingScore) {
                                    seen.set(uniqueKey, item);
                                    const index = deduplicated.findIndex(d => {
                                        if (d.type === 'band_adjust' && item.type === 'band_adjust') {
                                            return d.type === item.type && d.subtype === item.subtype;
                                        }
                                        return d.type === item.type;
                                    });
                                    if (index >= 0) deduplicated[index] = item;
                                }
                            }
                        }
                        return deduplicated;
                    };
                    
                    // Aplicar deduplicaÃ§Ã£o dos problemas na UI
                    const deduplicatedProblems = deduplicateByType(analysis.problems);
                    const list = deduplicatedProblems.map(p => {
                        const msg = typeof p.message === 'string' ? p.message.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.message;
                        const sol = typeof p.solution === 'string' ? p.solution.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.solution;
                        
                        // ğŸš¨ USAR FORMATO NATIVO DOS PROBLEMAS - Evitar duplicaÃ§Ã£o do SuggestionTextGenerator
                        // Os problemas jÃ¡ tÃªm explanation, impact, frequency_range, adjustment_db, details
                        let didacticText = null; // Desabilitado para evitar duplicaÃ§Ã£o
                        
                        // Se for problema crÃ­tico (clipping, etc), usar card crÃ­tico aprimorado
                        if (p.type === 'clipping' || p.severity === 'critical' || p.severity === 'high') {
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            
                            return `
                                <div class="enhanced-card critical-alert">
                                    <div class="card-header">
                                        <h4 class="card-title">ğŸš¨ Problema CrÃ­tico</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge severa">CRÃTICO</span>
                                        </div>
                                    </div>
                                    
                                    <div class="card-description" style="border-left-color: #f44336;">
                                        <strong>âš ï¸ Problema:</strong> ${msg}
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description" style="border-left-color: #f44336; background: rgba(244, 67, 54, 0.05);">
                                            <strong>ExplicaÃ§Ã£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                        <div class="card-action-title" style="color: #f44336;">
                                            ğŸš¨ AÃ§Ã£o Urgente
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || p.adjustment_db) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">FrequÃªncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${p.adjustment_db ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${p.adjustment_db} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                            <div class="card-impact-title" style="color: #f44336;">âš ï¸ Por que Ã© crÃ­tico</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        } else {
                            // Para problemas menos crÃ­ticos, usar card padrÃ£o melhorado
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            const dbMatch = sol.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                            const dbValue = dbMatch ? dbMatch[1] : null;
                            
                            // Determinar tipo de problema
                            const problemType = p.type || 'general';
                            let cardClass = 'enhanced-card problem';
                            let problemIcon = 'âš ï¸';
                            
                            if (problemType.includes('balance')) {
                                cardClass = 'enhanced-card balance';
                                problemIcon = 'âš–ï¸';
                            } else if (problemType.includes('dc_offset')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'ğŸ“Š';
                            } else if (problemType.includes('phase')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = 'ğŸŒŠ';
                            }
                            
                            return `
                                <div class="${cardClass}">
                                    <div class="card-header">
                                        <h4 class="card-title">${problemIcon} ${msg}</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge moderada">problema</span>
                                        </div>
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description">
                                            <strong>ExplicaÃ§Ã£o:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action">
                                        <div class="card-action-title">
                                            ğŸ”§ Como Resolver
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || dbValue) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">FrequÃªncias</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${dbValue ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${dbValue} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact">
                                            <div class="card-impact-title">âš ï¸ Impacto</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes TÃ©cnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        }
                    }).join('');
                    blocks.push(`<div class="diag-section"><div class="diag-heading">âš ï¸ Problemas Detectados:</div>${list}</div>`);
                }
                // ğŸ›‘ CARD DE SUGESTÃ•ES ANTIGAS DESATIVADO - Removido conforme solicitado
                // O card "SUGESTÃ•ES EDUCACIONAIS ULTRA-AVANÃ‡ADAS" foi desativado para limpar a UI
                // Apenas o novo sistema de sugestÃµes (que aparece no final do modal) deve ser usado
                /*
                if ((analysis.suggestions?.length || 0) > 0) {
                    // [CÃ“DIGO COMENTADO - Card de sugestÃµes antigas removido]
                }
                */
                // Subbloco opcional com diagnÃ³sticos do V2 PRO (quando disponÃ­veis)
                const v2Pro = analysis.v2Pro || analysis.v2Diagnostics; // Compatibilidade
                if (v2Pro && (typeof window === 'undefined' || window.SUGESTOES_AVANCADAS !== false)) {
                    const v2p = (v2Pro.problems || []).map(p => `
                        <div class="diag-item danger">
                            <div class="diag-title">${p.message}</div>
                            <div class="diag-tip">${p.solution || ''}</div>
                        </div>`).join('');
                    // V2 Pro removido - nÃ£o mostrar diagnÃ³sticos duplicados
                }
                log('[RENDER_SUGGESTIONS] âœ… Finalizada - Total de sugestÃµes:', enrichedSuggestions?.length || 0);
                return blocks.join('') || '<div class="diag-empty">Sem diagnÃ³sticos</div>';
            };

        // ğŸ¯ SUBSCORES: Corrigir mapeamento para backend Node.js
        const breakdown = analysis.scores || analysis.qualityBreakdown || {};
        
        // ğŸ¯ APLICAR CAPS EM ESTADO CLIPPED
        const precedenceData = analysis.technicalData?._singleStage;
        const isClippedState = precedenceData?.finalState === 'CLIPPED' && precedenceData?.scoreCapApplied === true;
        
        // Aplicar caps nos sub-scores se em estado CLIPPED
        const applyClippingCaps = (originalBreakdown) => {
            if (!isClippedState) return originalBreakdown;
            
            const capped = { ...originalBreakdown };
            
            // Caps especÃ­ficos para estado CLIPPED
            if (Number.isFinite(capped.loudness)) {
                capped.loudness = Math.min(capped.loudness, 70); // Loudness â‰¤ 70
            }
            if (Number.isFinite(capped.technical)) {
                capped.technical = Math.min(capped.technical, 60); // TÃ©cnico â‰¤ 60  
            }
            if (Number.isFinite(capped.dynamics)) {
                capped.dynamics = Math.min(capped.dynamics, 50); // DinÃ¢mica â‰¤ 50
            }
            
            // Frequency e Stereo podem manter valores originais (nÃ£o afetados diretamente pelo clipping)
            
            return capped;
        };
        
        const finalBreakdown = applyClippingCaps(breakdown);
        
        // ğŸ¯ HELPER: Detecta se True Peak estÃ¡ crÃ­tico (para tooltip de Loudness)
        const isTruePeakCritical = () => {
            const tp = analysis?.technicalData?.truePeakDbtp;
            const gates = analysis?.scores?._gatesTriggered || [];
            
            // Verificar se hÃ¡ gate crÃ­tico de True Peak
            const hasCriticalGate = gates.some(g => 
                g.type === 'TRUE_PEAK_CRITICAL' || 
                g.type === 'CLIPPING_SEVERE'
            );
            
            // Ou verificar se TP > 0 dBTP
            return hasCriticalGate || (Number.isFinite(tp) && tp > 0);
        };
        // FunÃ§Ã£o para renderizar score com barra de progresso + TOOLTIP + CORES DINÃ‚MICAS
        const renderScoreWithProgress = (label, value, defaultColor = '#00ffff', tooltipKey = null) => {
            const numValue = parseFloat(value) || 0;
            
            // Indicar se o valor foi capeado (comparar com breakdown original)
            const labelKey = label.toLowerCase().replace('faixa dinÃ¢mica', 'dynamics').replace('tÃ©cnico', 'technical').replace('loudness', 'loudness').replace('frequÃªncia', 'frequency').replace('stereo', 'stereo').replace('dinÃ¢mica', 'dynamics').replace('estÃ©reo', 'stereo');
            const wasCapped = isClippedState && breakdown[labelKey] && Number.isFinite(breakdown[labelKey]) && 
                             breakdown[labelKey] !== value;
            const cappedIndicator = wasCapped ? ' ğŸ”´' : '';
            
            // ğŸ¯ COR DINÃ‚MICA BASEADA NO VALOR (restaurando comportamento antigo)
            let scoreColor = defaultColor;
            if (Number.isFinite(numValue)) {
                if (numValue >= 80) scoreColor = '#00ff92'; // Verde para scores altos
                else if (numValue >= 60) scoreColor = '#ffd700'; // Amarelo para scores mÃ©dios
                else if (numValue >= 40) scoreColor = '#ff9500'; // Laranja para scores baixos
                else scoreColor = '#ff3366'; // Vermelho para scores muito baixos
            }
            
            // ğŸ¯ TOOLTIP: Buscar no TOOLTIP_REGISTRY usando tooltipKey
            const tooltipData = tooltipKey ? getTooltip(tooltipKey) : null;
            
            // ğŸ¯ Se nÃ£o houver tooltip vÃ¡lido, ESCONDER o Ã­cone (nÃ£o usar fallback TODO visÃ­vel)
            let tooltipIconHtml = '';
            if (tooltipData && tooltipData.body) {
                // LÃ³gica especial para Loudness: verificar se True Peak estÃ¡ crÃ­tico
                let finalTooltipBody = tooltipData.body;
                let finalTooltipVariant = tooltipData.variant || 'default';
                
                if (tooltipKey === 'loudness' && isTruePeakCritical()) {
                    finalTooltipVariant = 'warning';
                    finalTooltipBody = tooltipData.body + ' âš ï¸ ATENÃ‡ÃƒO: True Peak crÃ­tico detectado (> 0 dBTP ou gates ativos). Isso limita o score mesmo com LUFS correto.';
                }
                
                tooltipIconHtml = `<span class="metric-info-icon" 
                    data-tooltip-title="${tooltipData.title}" 
                    data-tooltip-body="${finalTooltipBody}" 
                    data-tooltip-variant="${finalTooltipVariant}"
                    style="margin-left: 4px; cursor: pointer;">â„¹ï¸</span>`;
            }
            
            // ğŸ¯ VALOR NÃƒO DISPONÃVEL
            if (value == null || !Number.isFinite(numValue)) {
                return `<div class="data-row metric-with-progress">
                    <span class="label">
                        <div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                            <span>${label}:</span>${tooltipIconHtml}
                        </div>
                    </span>
                    <div class="metric-value-progress">
                        <span class="value" style="color: #666; font-weight: normal;">â€”</span>
                        <div class="progress-bar-mini">
                            <div class="progress-fill-mini" style="width: 0%; background: transparent;"></div>
                        </div>
                    </div>
                </div>`;
            }
            
            // ğŸ¯ VALOR DISPONÃVEL: Renderizar com cor dinÃ¢mica + tooltip + barra (SEM /100)
            const displayValue = Math.round(numValue);
            
            return `<div class="data-row metric-with-progress">
                <span class="label">
                    <div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                        <span>${label}${cappedIndicator}:</span>${tooltipIconHtml}
                    </div>
                </span>
                <div class="metric-value-progress">
                    <span class="value" style="color: ${scoreColor}; font-weight: bold;">${displayValue}</span>
                    <div class="progress-bar-mini">
                        <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${scoreColor};"></div>
                    </div>
                </div>
            </div>`;
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ RENDERIZAR SCORE FINAL NO TOPO - VISUAL FUTURISTA
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Renderiza o score final no container dedicado no topo da anÃ¡lise
         * V3.4: Agora mostra "bruto vs penalizado" quando gates sÃ£o aplicados
         * @param {Object} scores - Objeto contendo todos os scores
         */
        function renderFinalScoreAtTop(scores) {
            log('[RENDER_FINAL_SCORE] âœ… Iniciada');
            log('[RENDER_FINAL_SCORE] scores:', scores);
            
            if (!scores || !Number.isFinite(scores.final)) {
                warn('[RENDER_FINAL_SCORE] âš ï¸ Retorno antecipado - Score final nÃ£o disponÃ­vel');
                warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: renderFinalScoreAtTop - !scores || !Number.isFinite(scores.final)');
                return;
            }
            
            const container = document.getElementById('final-score-display');
            if (!container) {
                error('[RENDER_FINAL_SCORE] âš ï¸ Retorno antecipado - Container #final-score-display nÃ£o encontrado');
                warn('[AUDITORIA_CONDICAO] âš ï¸ Retorno antecipado em: renderFinalScoreAtTop - !container');
                return;
            }
            
            log('[RENDER_FINAL_SCORE] âœ… Container encontrado, renderizando...');
            
            const finalScore = Math.round(scores.final);
            const finalRaw = scores.finalRaw ? Math.round(scores.finalRaw) : null;
            const wasGatePenalized = finalRaw && finalRaw > finalScore;
            const gatePenaltyAmount = wasGatePenalized ? finalRaw - finalScore : 0;
            const gatesTriggered = scores._gatesTriggered || [];
            
            const percent = Math.min(Math.max(finalScore, 0), 100);
            
            // Determinar mensagem de status baseada no score
            let statusMessage = '';
            let statusClass = '';
            
            if (finalScore >= 90) {
                statusMessage = 'âœ¨ Excelente! Pronto para lanÃ§amento';
                statusClass = 'status-excellent';
            } else if (finalScore >= 75) {
                statusMessage = 'âœ… Ã“timo! Qualidade profissional';
                statusClass = 'status-good';
            } else if (finalScore >= 60) {
                statusMessage = 'âš ï¸ Bom, mas pode melhorar';
                statusClass = 'status-warning';
            } else if (finalScore >= 40) {
                statusMessage = 'ğŸ”§ Precisa de ajustes';
                statusClass = 'status-warning';
            } else {
                statusMessage = 'ğŸš¨ Necessita correÃ§Ãµes importantes';
                statusClass = 'status-poor';
            }
            
            // V4.0: UI Limpa - Removidos textos tÃ©cnicos (gate/cap/penalty)
            // InformaÃ§Ãµes tÃ©cnicas agora ficam apenas no console para debug
            if (wasGatePenalized) {
                log('[RENDER_FINAL_SCORE] ğŸ”§ Gate aplicado (info tÃ©cnica):', {
                    bruto: finalRaw,
                    final: finalScore,
                    penalidade: gatePenaltyAmount,
                    gates: gatesTriggered.map(g => g.type)
                });
            }
            
            // ğŸ¯ BUSCAR TOOLTIP DO REGISTRY
            const scoreTooltipData = getTooltip('scoreFinal');
            const scoreTooltipTitle = scoreTooltipData?.title || 'Score Final';
            const scoreTooltipBody = scoreTooltipData?.body || 'MÃ©dia ponderada de todos os subscores. Reflete a qualidade tÃ©cnica geral do Ã¡udio.';
            
            // Renderizar HTML do score final - UI LIMPA (SEM TOOLTIP)
            container.innerHTML = `
                <div class="score-final-label">ğŸ† SCORE FINAL</div>
                <div class="score-final-value">0</div>
                <div class="score-final-bar-container">
                    <div class="score-final-bar">
                        <div class="score-final-bar-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-final-status ${statusClass}">${statusMessage}</div>
                <div id="diagnostic-container" class="diagnostic-container"></div>
            `;
            
            // Animar contagem do score (impacto visual) - inicia apÃ³s pequeno delay
            setTimeout(() => {
                animateFinalScore(finalScore);
            }, 100);
            
            log('[RENDER_FINAL_SCORE] âœ… Finalizada');
        }
        
        /**
         * Anima a contagem do score final de 0 atÃ© o valor final
         * @param {number} targetScore - Score final a ser exibido
         */
        function animateFinalScore(targetScore) {
            const el = document.querySelector('.score-final-value');
            const barFill = document.querySelector('.score-final-bar-fill');
            if (!el) return;
            
            let currentScore = 0;
            const duration = 2500; // 2.5 segundos (mais lento e dramÃ¡tico)
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out cubic - mais suave)
                const eased = 1 - Math.pow(1 - progress, 3);
                currentScore = targetScore * eased;
                
                // Atualizar nÃºmero
                el.textContent = Math.floor(currentScore);
                
                // Animar barra junto (se existir)
                if (barFill) {
                    const currentPercent = Math.min(Math.max(currentScore, 0), 100);
                    barFill.style.width = `${currentPercent}%`;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    el.textContent = targetScore; // Garantir valor final exato
                    if (barFill) {
                        const finalPercent = Math.min(Math.max(targetScore, 0), 100);
                        barFill.style.width = `${finalPercent}%`;
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ§  DIAGNÃ“STICO SONORO INTELIGENTE - RENDERIZAÃ‡ÃƒO UI
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Renderiza o diagnÃ³stico semÃ¢ntico abaixo do score final
         * @param {Object} scoreResult - Resultado de computeScoreV3
         * @param {Object} analysisMeta - Metadados da anÃ¡lise
         */
        function renderDiagnostic(scoreResult, analysisMeta = {}) {
            log('[RENDER_DIAGNOSTIC] ğŸ§  Iniciando renderizaÃ§Ã£o do diagnÃ³stico');
            
            const container = document.getElementById('diagnostic-container');
            if (!container) {
                warn('[RENDER_DIAGNOSTIC] âš ï¸ Container #diagnostic-container nÃ£o encontrado');
                return;
            }
            
            // Construir contexto semÃ¢ntico
            const diagnostic = window.buildDiagnosticContext(scoreResult, analysisMeta);
            
            if (!diagnostic || !diagnostic.context?.valid) {
                warn('[RENDER_DIAGNOSTIC] âš ï¸ DiagnÃ³stico invÃ¡lido');
                container.innerHTML = '';
                return;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // V5.0: VEREDITO SONORO - APENAS TEXTO ÃšNICO DA IA
            // Design premium, clean, sem listas ou badges
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let finalText = '';
            if (window.generateFinalDiagnosticText) {
                finalText = window.generateFinalDiagnosticText(diagnostic);
            }
            
            if (!finalText) {
                container.innerHTML = '';
                return;
            }
            
            // ğŸ¯ BUSCAR TOOLTIP DO REGISTRY
            const diagnosticTooltipData = getTooltip('diagnostico');
            const diagnosticTooltipTitle = diagnosticTooltipData?.title || 'DiagnÃ³stico';
            const diagnosticTooltipBody = diagnosticTooltipData?.body || 'ClassificaÃ§Ã£o qualitativa baseada no score final.';
            
            // Renderizar APENAS o texto Ãºnico - design minimalista premium (SEM TOOLTIP)
            container.innerHTML = `
                <div class="verdict-text">${finalText}</div>
            `;
            
            log('[RENDER_DIAGNOSTIC] âœ… Veredito sonoro renderizado');
        }
        
        // Expor funÃ§Ã£o para uso externo
        window.renderDiagnostic = renderDiagnostic;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // ğŸ¯ RENDERIZAR SCORES DO NOVO SISTEMA
        const renderNewScores = () => {
            // Verificar se temos scores calculados
            const scores = analysis.scores;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ” TAREFA 2: AUDITORIA DE LEITURA DE SCORES NA UI
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            console.group('ğŸ¨ [AUDIT-RENDER] LEITURA DE SCORES NA UI');
            log('[AUDIT-RENDER] analysis.scores recebido pela UI:', scores);
            log('[AUDIT-RENDER] scores existe?', !!scores);
            log('[AUDIT-RENDER] scores.loudness:', scores?.loudness);
            log('[AUDIT-RENDER] scores.dinamica:', scores?.dinamica);
            log('[AUDIT-RENDER] scores.estereo:', scores?.estereo);
            log('[AUDIT-RENDER] scores.frequencia:', scores?.frequencia);
            log('[AUDIT-RENDER] scores.tecnico:', scores?.tecnico);
            log('[AUDIT-RENDER] scores.subscores:', scores?.subscores);
            console.groupEnd();
            
            if (!scores) {
                warn('âš ï¸ [AUDIT-RENDER] SCORES AUSENTES - renderizando fallback');
                return `<div class="data-row">
                    <span class="label">Sistema de Scoring:</span>
                    <span class="value">NÃ£o disponÃ­vel</span>
                </div>`;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ”§ TAREFA 3: NORMALIZAÃ‡ÃƒO DE ESTRUTURA DE SCORES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Adaptar estrutura retornada por calculateAnalysisScores para UI
            const rawScores = scores || {};
            const subs = rawScores.subscores || rawScores;
            
            const normalizedScores = {
                loudness: subs.loudness ?? rawScores.loudness ?? subs.lufs ?? null,
                dinamica: subs.dinamica ?? subs.dynamics ?? rawScores.dinamica ?? rawScores.dynamics ?? null,
                estereo: subs.estereo ?? subs.stereo ?? rawScores.estereo ?? rawScores.stereo ?? null,
                frequencia: subs.frequencia ?? subs.frequency ?? rawScores.frequencia ?? rawScores.frequency ?? null,
                tecnico: subs.tecnico ?? subs.technical ?? rawScores.tecnico ?? rawScores.technical ?? null,
                final: rawScores.final ?? rawScores.composite ?? rawScores.score ?? null,
                breakdown: rawScores.breakdown ?? null
            };
            
            console.group('âœ… [AUDIT-RENDER] SCORES NORMALIZADOS');
            log('[AUDIT-RENDER] normalizedScores.loudness:', normalizedScores.loudness);
            log('[AUDIT-RENDER] normalizedScores.dinamica:', normalizedScores.dinamica);
            log('[AUDIT-RENDER] normalizedScores.estereo:', normalizedScores.estereo);
            log('[AUDIT-RENDER] normalizedScores.frequencia:', normalizedScores.frequencia);
            log('[AUDIT-RENDER] normalizedScores.tecnico:', normalizedScores.tecnico);
            log('[AUDIT-RENDER] normalizedScores.final:', normalizedScores.final);
            
            // ğŸ” TAREFA 4: VALIDAÃ‡ÃƒO FINAL - Contagem de valores null
            const nullCount = Object.values(normalizedScores).filter(v => v === null).length;
            const validCount = Object.values(normalizedScores).filter(v => Number.isFinite(v)).length;
            log('ğŸ“Š [AUDIT-RENDER] VALIDAÃ‡ÃƒO:', {
                total: Object.keys(normalizedScores).length,
                validos: validCount,
                nulos: nullCount,
                status: nullCount === 0 ? 'âœ… TODOS PREENCHIDOS' : `âš ï¸ ${nullCount} NULOS`
            });
            console.groupEnd();
            
            // ğŸ¯ Score final REMOVIDO daqui - serÃ¡ renderizado no topo
            // âŒ NÃƒO INCLUIR O SCORE FINAL AQUI - ele tem seu prÃ³prio container no topo
            
            // âœ… Sub-scores permanecem no mesmo lugar (dentro do card Scores & DiagnÃ³stico)
            // ğŸ¯ USANDO renderScoreWithProgress que jÃ¡ tem suporte a tooltips + CORES DINÃ‚MICAS
            const subScoresHtml = `
                ${renderScoreWithProgress('Loudness', normalizedScores.loudness, '#ff3366', 'loudness')}
                ${renderScoreWithProgress('FrequÃªncia', normalizedScores.frequencia, '#00ffff', 'frequency')}
                ${renderScoreWithProgress('EstÃ©reo', normalizedScores.estereo, '#ff6b6b', 'stereo')}
                ${renderScoreWithProgress('DinÃ¢mica', normalizedScores.dinamica, '#ffd700', 'dynamic')}
                ${renderScoreWithProgress('TÃ©cnico', normalizedScores.tecnico, '#00ff92', 'technical')}
            `;
            
            return subScoresHtml;
        };
        
        const scoreRows = renderNewScores();

        // ğŸ”¹ FunÃ§Ã£o utilitÃ¡ria: Remove nÃ³s de texto vazios (whitespace) dentro dos cards
        function normalizeCardWhitespace(root = document) {
            const cards = root.querySelectorAll('.cards-grid .card');
            cards.forEach((card) => {
                // Remove nÃ³s de texto que sejam apenas whitespace (espaÃ§os/linhas)
                const toRemove = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        toRemove.push(n);
                    }
                });
                toRemove.forEach((n) => n.parentNode.removeChild(n));
            });
        }

        // ğŸ”¹ Alias para compatibilidade com nomenclatura alternativa
        function stripEmptyTextNodesInCards(root = document) {
            root.querySelectorAll('.cards-grid .card').forEach((card) => {
                const garbage = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        garbage.push(n);
                    }
                });
                garbage.forEach((n) => n.remove());
            });
        }

        // =========================================================================
        // ğŸš¨ AUDITORIA CRÃTICA: PONTO DE RENDERIZAÃ‡ÃƒO DE CARDS
        // =========================================================================
        console.groupCollapsed('[AUDITORIA_RENDERIZACAO] ğŸ¨ RENDERIZAÃ‡ÃƒO DE CARDS');
        log('[RENDER_CARDS] âœ… INÃCIO - Prestes a renderizar cards');
        log('[RENDER_CARDS] Modo:', analysis?.mode);
        log('[RENDER_CARDS] ContÃ©m analysis.scores?', !!analysis?.scores);
        log('[RENDER_CARDS] ContÃ©m analysis.technicalData?', !!analysis?.technicalData);
        log('[RENDER_CARDS] technicalData disponÃ­vel no DOM?', !!document.getElementById('modalTechnicalData'));
        log('[RENDER_CARDS] scoreKpi length:', scoreKpi?.length || 0);
        log('[RENDER_CARDS] col1 length:', col1?.length || 0);
        log('[RENDER_CARDS] col2 length:', col2?.length || 0);
        console.groupEnd();
        
        // [AUDIT-FLOW-CHECK] Confirmar que chegou na renderizaÃ§Ã£o de cards
        log('[AUDIT-FLOW-CHECK] âœ… Renderizando cards - modo:', analysis?.mode);
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: RENDERIZAR SCORE FINAL NO TOPO
        // =========================================================================
        log('[RENDER_SCORE_TOP] âœ… Chamando renderFinalScoreAtTop');
        log('[RENDER_SCORE_TOP] analysis.scores:', analysis?.scores);
        
        // ğŸ¯ RENDERIZAR SCORE FINAL NO TOPO (ISOLADO)
        renderFinalScoreAtTop(analysis.scores);
        
        log('[RENDER_SCORE_TOP] âœ… renderFinalScoreAtTop FINALIZADO');
        
        // =========================================================================
        // ğŸ§  V4.0: RENDERIZAR DIAGNÃ“STICO SONORO INTELIGENTE
        // =========================================================================
        // O diagnÃ³stico Ã© renderizado apÃ³s a animaÃ§Ã£o do score comeÃ§ar
        setTimeout(() => {
            if (analysis.scores && window.buildDiagnosticContext) {
                log('[RENDER_DIAGNOSTIC] ğŸ§  Iniciando construÃ§Ã£o do diagnÃ³stico');
                
                // ğŸ” LOG TEMPORÃRIO - AUDITORIA TEXTO IA
                console.group('ğŸ” [AUDIT-AI-TEXT] VerificaÃ§Ã£o de dados para diagnÃ³stico');
                log('analysis.scores:', analysis.scores);
                log('analysis.scores.metricEvaluations existe?', !!analysis.scores.metricEvaluations);
                log('analysis.scores.subscores:', analysis.scores.subscores);
                log('analysis.scores._frequencyDetails:', analysis.scores._frequencyDetails);
                console.groupEnd();
                
                // Construir metadados da anÃ¡lise para contexto
                const analysisMeta = {
                    mode: analysis.mode || 'streaming',
                    genre: analysis.genre || analysis.genreName || null,
                    reference: analysis.referenceName || analysis.reference?.name || null
                };
                
                // Renderizar diagnÃ³stico
                renderDiagnostic(analysis.scores, analysisMeta);
            } else {
                warn('[RENDER_DIAGNOSTIC] âš ï¸ NÃ£o foi possÃ­vel renderizar diagnÃ³stico:', {
                    hasScores: !!analysis.scores,
                    hasBuildDiagnosticContext: !!window.buildDiagnosticContext
                });
            }
        }, 500); // Delay para sincronizar com animaÃ§Ã£o do score

        log('[RENDER_CARDS] âœ… Atribuindo HTML ao technicalData.innerHTML');
        technicalData.innerHTML = `
            <div class="kpi-row">${scoreKpi}${timeKpi}</div>
            ${renderSmartSummary(analysis)}
            <div class="cards-grid">
                <div class="card">
                    <div class="card-title">MÃ‰TRICAS PRINCIPAIS</div>
                    ${col1Html}
                </div>
                <div class="card">
                    <div class="card-title">ANÃLISE DE FREQUÃŠNCIAS</div>
                    ${col2}
                </div>
                <div class="card">
                    <div class="card-title">MÃ‰TRICAS AVANÃ‡ADAS</div>
                    ${advancedMetricsCard()}
                </div>
                <div class="card">
                    <div class="card-title">SCORES & DIAGNÃ“STICO</div>
                    ${scoreRows}
                    ${col3}
                </div>
                <!-- Card "Problemas TÃ©cnicos" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">âš ï¸ Problemas TÃ©cnicos</div>
                    ${techProblems()}
                </div>
                -->
            </div>`;
        
        // ğŸ” VALIDAÃ‡ÃƒO PÃ“S-RENDER: Detectar mÃ©tricas sem tooltip (DEV apenas)
        if (isDev) {
            setTimeout(() => {
                const allRows = technicalData.querySelectorAll('.data-row[data-metric-key]');
                const missingTooltips = [];
                
                allRows.forEach(row => {
                    const metricKey = row.getAttribute('data-metric-key');
                    const hasIcon = row.querySelector('.metric-info-icon[data-tooltip-body]');
                    
                    if (!hasIcon && metricKey) {
                        const label = row.querySelector('.label')?.textContent.trim() || 'Unknown';
                        missingTooltips.push({
                            metricKey,
                            label,
                            element: row
                        });
                    }
                });
                
                if (missingTooltips.length > 0) {
                    console.group('âš ï¸ [TOOLTIP-VALIDATION] MÃ©tricas sem tooltip detectadas');
                    warn(`${missingTooltips.length} mÃ©trica(s) renderizadas sem tooltip:`);
                    console.table(missingTooltips.map(m => ({
                        metricKey: m.metricKey,
                        label: m.label
                    })));
                    log('ğŸ“ Adicione essas keys no TOOLTIP_REGISTRY para 100% de cobertura.');
                    console.groupEnd();
                } else {
                    log('âœ… [TOOLTIP-VALIDATION] 100% de cobertura - todas as mÃ©tricas tÃªm tooltips!');
                }
            }, 100);
        }
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: CONFIRMAR RENDERIZAÃ‡ÃƒO NO DOM
        // =========================================================================
        log('[RENDER_CARDS] âœ… HTML atribuÃ­do ao technicalData.innerHTML');
        log('[RENDER_CARDS] Tamanho do HTML:', technicalData.innerHTML.length);
        log('[RENDER_CARDS] Primeiros 200 chars:', technicalData.innerHTML.substring(0, 200));
    
        // ğŸ”¹ Sanitizar DOM: Remove nÃ³s de texto vazios que criam espaÃ§o extra
        normalizeCardWhitespace(technicalData);
        stripEmptyTextNodesInCards(technicalData);
        
        // =========================================================================
        // ğŸš¨ AUDITORIA: VERIFICAR DOM APÃ“S SANITIZAÃ‡ÃƒO
        // =========================================================================
        setTimeout(() => {
            console.groupCollapsed('[AUDITORIA_DOM] ğŸ” VERIFICAÃ‡ÃƒO DO DOM');
            log('[AUDITORIA_DOM] Cards:', document.querySelectorAll('.cards-grid .card').length);
            log('[AUDITORIA_DOM] SugestÃµes:', document.querySelectorAll('.suggestion-card').length);
            log('[AUDITORIA_DOM] Score containers:', document.querySelectorAll('.score-card, .final-score-display').length);
            log('[AUDITORIA_DOM] technicalData.innerHTML length:', document.getElementById('modalTechnicalData')?.innerHTML?.length || 0);
            console.groupEnd();
        }, 1000);
    
        // ğŸ¯ CORRIGIDO: SÃ³ renderizar referÃªncias se NÃƒO estiver em modo comparaÃ§Ã£o de faixas
        // O displayModalResults() jÃ¡ trata comparaÃ§Ã£o via renderTrackComparisonTable()
        
        // ğŸ”¥ FLAG DE CONTROLE: Impedir dupla renderizaÃ§Ã£o em modo gÃªnero
        let genreRenderComplete = false;
        
        try { 
            // ========================================
            // ğŸ”¥ MODO GÃŠNERO: RENDERIZAÃ‡ÃƒO ISOLADA
            // ========================================
            // âœ… RESTAURADO: Fluxo original que sempre funcionou
            if (analysis?.mode === "genre") {
                log('%c[GENRE-MODE] ğŸ¯ MODO GÃŠNERO DETECTADO - RENDERIZAÃ‡ÃƒO DIRETA', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
                log('[GENRE-MODE] analysis.mode:', analysis.mode);
                log('[GENRE-MODE] analysis.genre:', analysis.genre || analysis.metadata?.genre);
                log('[GENRE-MODE] window.__activeRefData:', !!window.__activeRefData);
                log('[GENRE-MODE] window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
                log('[GENRE-MODE] analysis.bands:', analysis.bands ? Object.keys(analysis.bands).length + ' bandas' : 'N/A');
                log('[GENRE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // âœ… CHAMAR FUNÃ‡ÃƒO DE RENDERIZAÃ‡ÃƒO DE GÃŠNERO
                renderGenreView(analysis);
                
                // ğŸ”¥ MARCAR FLAG: GÃªnero foi renderizado, NÃƒO renderizar A/B depois
                genreRenderComplete = true;
                
                log('%c[GENRE-MODE] âœ… RENDERIZAÃ‡ÃƒO CONCLUÃDA', 'color:#00FF88;font-weight:bold;');
                return;
            }
            
            // ========================================
            // ğŸ¯ MODO REFERÃŠNCIA: PREPARAR DADOS PARA COMPARAÃ‡ÃƒO A/B
            // ========================================
            // âœ… RESTAURADO: Fluxo original de referÃªncia mantido intacto
            const isSecondTrack = (
                analysis.mode === 'reference' &&
                window.__REFERENCE_JOB_ID__ !== null &&
                window.__REFERENCE_JOB_ID__ !== undefined
            );
            
            const mode = analysis?.mode || currentAnalysisMode;
            const state = window.__soundyState || {};
            
            // ğŸ¯ CORREÃ‡ÃƒO: Declarar mustBeReference ANTES de usar (previne ReferenceError)
            const mustBeReference = (
                mode === 'reference' ||
                isSecondTrack ||
                hasActiveReferenceContext() ||
                SOUNDY_MODE_ENGINE?.isReferenceCompare?.()
            );
            
            log('ğŸ” [RENDER-FLOW] Verificando modo e decisÃ£o de renderizaÃ§Ã£o:', {
                'analysis.mode': analysis.mode,
                'analysis.isReferenceBase': analysis.isReferenceBase,
                'currentAnalysisMode': window.currentAnalysisMode,
                isSecondTrack,
                mustBeReference,
                hasReferenceAnalysisData: !!window.referenceAnalysisData,
                '__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
                stateRenderMode: state.render?.mode
            });
            
            log('[VERIFY_RENDER_MODE]', {
                mode: state.render?.mode || 'undefined',
                usingReferenceBands: !!(state.reference?.analysis?.bands || analysis?.referenceAnalysis?.bands),
                usingGenreTargets: !!window.__activeRefData?.bands,
                genreTargetsKeys: window.__activeRefData?.bands ? Object.keys(window.__activeRefData.bands) : [],
                referenceBandsKeys: state.reference?.analysis?.bands ? Object.keys(state.reference.analysis.bands) : []
            });
            
            log('ğŸµ [REFERENCE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('ğŸµ [REFERENCE-MODE] MODO REFERÃŠNCIA DETECTADO');
            log('ğŸµ [REFERENCE-MODE] analysis.mode:', analysis.mode);
            log('ğŸµ [REFERENCE-MODE] analysis.isReferenceBase:', analysis.isReferenceBase);
            log('ğŸµ [REFERENCE-MODE] isSecondTrack:', isSecondTrack);
            log('ğŸµ [REFERENCE-MODE] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ¯ Usar helper getCompareMode (NUNCA ctx.mode como fallback)
            const compareMode = getCompareMode(analysis);
            
            log(`ğŸ“Š [RENDER-FLOW] Preparando renderReferenceComparisons() - compareMode: ${compareMode}`);
            log('[RENDER-FLOW] mustBeReference:', mustBeReference);
            log('[RENDER-FLOW] __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            log('[RENDER-FLOW] referenceAnalysisData.bands:', !!window.referenceAnalysisData?.bands);
            
            // Preparar objeto ctx com clones profundos para evitar contaminaÃ§Ã£o
            const userClone = (typeof structuredClone === 'function') 
                ? structuredClone(analysis) 
                : JSON.parse(JSON.stringify(analysis));
            
            const refClone = window.referenceAnalysisData 
                ? ((typeof structuredClone === 'function') 
                    ? structuredClone(window.referenceAnalysisData) 
                    : JSON.parse(JSON.stringify(window.referenceAnalysisData)))
                : null;
            
            const renderOpts = {
                mode: compareMode,
                user: userClone,
                ref: refClone,
                // Compatibilidade com cÃ³digo legado
                analysis: analysis,
                userAnalysis: state.userAnalysis || state.reference?.userAnalysis || userClone,
                referenceAnalysis: state.referenceAnalysis || state.reference?.referenceAnalysis || refClone
            };
            
            log('[RENDER-OPTS] âœ… Dados preparados:', {
                mode: renderOpts.mode,
                hasUser: !!renderOpts.user,
                hasRef: !!renderOpts.ref,
                userBands: !!renderOpts.user?.bands,
                refBands: !!renderOpts.ref?.bands
            });
            
            // ğŸ” [AUDIT-BANDS-BEFORE] Log ANTES da chamada de renderReferenceComparisons
            try {
                const refBands = renderOpts.referenceAnalysis?.bands || renderOpts.referenceAnalysis?.technicalData?.spectral_balance;
                const userBands = renderOpts.userAnalysis?.bands || renderOpts.userAnalysis?.technicalData?.spectral_balance;
                log('[AUDIT-BANDS-BEFORE]', {
                    hasRefBands: !!refBands,
                    hasUserBands: !!userBands,
                    refBandsType: typeof refBands,
                    userBandsType: typeof userBands,
                    refBandsKeys: refBands ? Object.keys(refBands) : [],
                    userBandsKeys: userBands ? Object.keys(userBands) : [],
                    refBandsPreview: refBands ? Object.keys(refBands).slice(0, 3) : 'N/A',
                    userBandsPreview: userBands ? Object.keys(userBands).slice(0, 3) : 'N/A',
                    renderOptsKeys: Object.keys(renderOpts)
                });
            } catch (err) {
                warn('[AUDIT-ERROR]', 'AUDIT-BANDS-BEFORE', err);
            }
            
            // âœ… [BANDS-FIX] Nunca espera bandas no DOM - trabalha direto nos objetos
            // Se os objetos existem, seguimos â€” processamento Ã© nos dados, nÃ£o no DOM
            const ensureBandsReady = (userFull, refFull) => {
                return !!(userFull && refFull);
            };

            // ğŸ”¥ PROTEÃ‡ÃƒO: NÃƒO renderizar A/B se gÃªnero jÃ¡ foi renderizado
            if (genreRenderComplete) {
                log('[GENRE-PROTECTION] âœ… Modo gÃªnero jÃ¡ renderizado - BLOQUEANDO renderizaÃ§Ã£o A/B');
            } else if (ensureBandsReady(renderOpts?.userAnalysis, renderOpts?.referenceAnalysis)) {
                renderReferenceComparisons(renderOpts);
            } else {
                warn('[BANDS-FIX] âš ï¸ Objetos ausentes para comparaÃ§Ã£o A/B, pulando render de referÃªncia');
            }
        } catch(e){ 
            error('âŒ [RENDER-FLOW] ERRO em renderReferenceComparisons:', e);
            error('âŒ Stack trace:', e.stack);
        }    
        try { if (window.CAIAR_ENABLED) injectValidationControls(); } catch(e){ warn('validation controls fail', e); }
        
        // ğŸ” VerificaÃ§Ã£o de debug: Detecta whitespace restante
        if (window.DEBUG_ANALYZER) {
            document.querySelectorAll('.cards-grid .card').forEach((card, i) => {
                const ghosts = [...card.childNodes].filter(n => n.nodeType === 3 && !/\S/.test(n.nodeValue || ''));
                if (ghosts.length) warn(`Card #${i+1}: whitespace nodes restantes`, ghosts);
            });
        }
        
        __dbg('ğŸ“Š Resultados exibidos no modal');
        
        // âœ… LOG FINAL DE CONFIRMAÃ‡ÃƒO
        log('[DISPLAY_MODAL_RESULTS] âœ…âœ…âœ… FUNÃ‡ÃƒO FINALIZADA COM SUCESSO âœ…âœ…âœ…');
        log('[DISPLAY_MODAL_RESULTS] Modo:', analysis?.mode);
        log('[DISPLAY_MODAL_RESULTS] Self-compare?', state?.render?.isSelfCompare || false);
        log('[DISPLAY_MODAL_RESULTS] RenderizaÃ§Ã£o completa: cards, scores, tabela A/B, sugestÃµes');
    }

    // === Controles de ValidaÃ§Ã£o (Suite Objetiva + Subjetiva) ===
    function injectValidationControls(){
        if (document.getElementById('validationControlsBar')) return;
        const host = document.getElementById('modalTechnicalData');
        if (!host) return;
        const bar = document.createElement('div');
        bar.id='validationControlsBar';
        bar.style.cssText='margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:#0f1826;padding:10px 12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;font-size:12px;';
        bar.innerHTML = `
            <strong style="letter-spacing:.5px;color:#9fc9ff;font-weight:600;">ValidaÃ§Ã£o Auditiva</strong>
            <button id="runValidationSuiteBtn" style="background:#10365a;color:#fff;border:1px solid #1e4d7a;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;">Rodar Suite (10)</button>
            <button id="openSubjectiveFormBtn" style="background:#1c2c44;color:#d6e7ff;border:1px solid #284362;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Subjetivo 1â€“5</button>
            <button id="downloadValidationReportBtn" style="background:#224d37;color:#c5ffe9;border:1px solid #2f6e4e;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Baixar RelatÃ³rio</button>
            <span id="validationStatusMsg" style="margin-left:auto;font-size:11px;opacity:.75;">Pronto</span>
        `;
        host.prepend(bar);
        // Handlers
        const btnRun = bar.querySelector('#runValidationSuiteBtn');
        const btnForm = bar.querySelector('#openSubjectiveFormBtn');
        const btnDownload = bar.querySelector('#downloadValidationReportBtn');
        const statusEl = bar.querySelector('#validationStatusMsg');
        btnRun.onclick = async ()=>{
            btnRun.disabled = true; btnRun.textContent = 'Rodando...'; statusEl.textContent = 'Executando suite...';
            try {
                const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`);
                const summary = await mod.runValidationSuite({});
                statusEl.textContent = summary? `Cobertura mÃ©dia Î” ${(summary.avgDelta*100).toFixed(1)}%` : 'Sem dados';
                btnRun.textContent = 'Suite OK';
                btnForm.disabled = false; btnDownload.disabled = false;
                // Ãrea dinÃ¢mica para formulÃ¡rio
                ensureValidationPanel();
            } catch(err){ error('Erro suite validaÃ§Ã£o', err); statusEl.textContent='Erro'; btnRun.textContent='Erro'; btnRun.disabled=false; }
        };
        btnForm.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); ensureValidationPanel(); mod.renderSubjectiveForm('validationPanelInner'); statusEl.textContent='FormulÃ¡rio subjetivo aberto'; } catch(e){ warn(e); }
        };
        btnDownload.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); const rep = mod.generateValidationReport(); if(rep){ downloadObjectAsJson(rep, 'prodai_validation_report.json'); statusEl.textContent = rep?.subjective?.pctImproved!=null? `Subj ${(rep.subjective.pctImproved*100).toFixed(0)}%`:'RelatÃ³rio gerado'; } } catch(e){ warn(e); }
        };
    }

    function ensureValidationPanel(){
        if (document.getElementById('validationPanel')) return;
        const container = document.createElement('div');
        container.id='validationPanel';
        container.style.cssText='margin-top:12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:#0d141f;padding:10px 12px;';
        container.innerHTML = `<div style="font-size:12px;font-weight:600;letter-spacing:.5px;color:#9fc9ff;margin-bottom:6px;">Resultados da ValidaÃ§Ã£o</div><div id='validationPanelInner' style='font-size:11px;'></div>`;
        const host = document.getElementById('modalTechnicalData');
        if (host) host.appendChild(container);
        // estilos mÃ­nimos tabela subjetiva
        if (!document.getElementById('validationStyles')){
            const st=document.createElement('style'); st.id='validationStyles'; st.textContent=`
                .subjective-table{border-collapse:collapse;width:100%;margin-top:6px;font-size:11px;}
                .subjective-table th,.subjective-table td{border:1px solid rgba(255,255,255,.08);padding:4px 6px;text-align:center;}
                .subjective-table th{background:#132132;color:#c9e4ff;font-weight:500;letter-spacing:.4px;}
                .subjective-table select{min-width:42px;}
            `; document.head.appendChild(st);
        }
    }

    function downloadObjectAsJson(obj, filename){
        try { const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250); } catch(e){ warn('download json fail', e); }
    }

// ===== Painel Resumo Inteligente (top 3 problemas + top 3 aÃ§Ãµes) =====
function renderSmartSummary(analysis){
    try {
        if (!(typeof window !== 'undefined' && window.CAIAR_ENABLED) || !analysis) return '';
        // Garantir plano explain (caso ainda nÃ£o anexado)
        if (!analysis.caiarExplainPlan && window.audioAnalyzer && typeof analysis === 'object') {
            try {
                // se mÃ³dulo ainda nÃ£o carregado, importar dinamicamente
                if (!window.__CAIAR_EXPLAIN_LOADING__) {
                    window.__CAIAR_EXPLAIN_LOADING__ = import('/lib/audio/features/caiar-explain.js').then(mod=>{
                        if (mod && typeof mod.generateExplainPlan === 'function') mod.generateExplainPlan(analysis);
                    }).catch(()=>null);
                }
            } catch {}
        }
        const problems = Array.isArray(analysis.problems) ? analysis.problems.slice(0,3) : [];
        // Selecionar aÃ§Ãµes: usar passos do plano explain se existir, senÃ£o derivar das sugestÃµes
        let steps = (analysis.caiarExplainPlan && Array.isArray(analysis.caiarExplainPlan.passos)) ? analysis.caiarExplainPlan.passos.slice(0,6) : [];
        if (steps.length === 0) {
            const sugg = Array.isArray(analysis.suggestions) ? analysis.suggestions.slice() : [];
            // Ordenar por prioridade DECRESCENTE (maior prioridade = menor valor numÃ©rico = vem primeiro)
            sugg.sort((a,b)=> (b.priority||999)-(a.priority||999));
            steps = sugg.slice(0,6).map((s,i)=>({
                ordem:i+1,
                titulo:s.message||'AÃ§Ã£o',
                acao:s.action||'',
                porque:s.details||s.rationale? JSON.stringify(s.rationale):'OtimizaÃ§Ã£o recomendada',
                condicao:s.condition||s.condicao||'Aplicar quando perceptÃ­vel',
                origem:s.source||s.type,
                stem:s.targetStem||null,
                parametroPrincipal: s.freqHz? (Math.round(s.freqHz)+' Hz'): (s.band||null)
            }));
        }
        const topActions = steps.slice(0,3);
        const actionItems = topActions.map(a=>{
            const stem = a.stem ? `<span class="ss-stem">${a.stem}</span>` : '';
            const param = a.parametroPrincipal ? `<span class="ss-param">${a.parametroPrincipal}</span>` : '';
            const cond = a.condicao ? `<span class="ss-cond">${a.condicao}</span>` : '';
            const whyId = 'why_'+Math.random().toString(36).slice(2);
            return `<div class="ss-action-item">
                <div class="ss-line-main">
                    <span class="ss-title">${a.titulo}</span>
                    ${stem}
                    ${param}
                </div>
                <div class="ss-line-meta">
                    ${cond}
                    <button type="button" class="ss-why-btn" data-why-target="${whyId}">Por que?</button>
                </div>
                <div class="ss-why" id="${whyId}">${a.porque || 'Melhora coerÃªncia sonora.'}</div>
            </div>`;
        }).join('');
        const problemItems = problems.map(p=>`<div class="ss-prob-item"><span class="ss-prob-msg">${p.message||''}</span></div>`).join('');
        // Expand/Collapse container
        const html = `<div class="smart-summary-card" id="smartSummaryCard">
            <div class="ss-header">
                <div class="ss-title-block">âš¡ Resumo Inteligente</div>
                <button type="button" class="ss-toggle" data-expanded="true">Colapsar</button>
            </div>
            <div class="ss-content" data-collapsible="body">
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 Problemas</div>
                    ${problemItems || '<div class="ss-empty">Nenhum problema crÃ­tico</div>'}
                </div>
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 AÃ§Ãµes</div>
                    ${actionItems || '<div class="ss-empty">Nenhuma aÃ§Ã£o prioritÃ¡ria</div>'}
                </div>
                <div class="ss-hint">Execute as aÃ§Ãµes na ordem. Tempo de entendimento < 30s.</div>
            </div>
        </div>`;
        // Injetar estilos apenas uma vez
        if (!document.getElementById('smartSummaryStyles')) {
            const st = document.createElement('style');
            st.id = 'smartSummaryStyles';
            st.textContent = `
            .smart-summary-card{margin:12px 0 4px 0;padding:14px 16px;border:1px solid rgba(255,255,255,.08);border-radius:14px;background:linear-gradient(145deg,#0f1623,#101b2e);box-shadow:0 4px 14px -4px rgba(0,0,0,.55),0 0 0 1px rgba(255,255,255,0.03);font-size:13px;}
            .smart-summary-card .ss-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;}
            .smart-summary-card .ss-title-block{font-weight:600;letter-spacing:.5px;color:#e5f1ff;font-size:13px;}
            .smart-summary-card .ss-toggle{background:#18263a;color:#d2e6ff;border:1px solid #24364e;border-radius:8px;padding:4px 10px;font-size:11px;cursor:pointer;letter-spacing:.4px;transition:background .25s,border-color .25s;}
            .smart-summary-card .ss-toggle:hover{background:#203148;}
            .smart-summary-card .ss-section{margin-top:10px;}
            .smart-summary-card .ss-section-title{font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.7px;color:#86b4ff;margin-bottom:6px;}
            .smart-summary-card .ss-prob-item{background:rgba(255,90,90,.08);border:1px solid rgba(255,90,90,.25);padding:6px 8px;border-radius:8px;margin-bottom:6px;line-height:1.3;}
            .smart-summary-card .ss-prob-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-action-item{background:#152132;border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;margin-bottom:8px;}
            .smart-summary-card .ss-action-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-line-main{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:4px;}
            .smart-summary-card .ss-title{font-weight:600;color:#fff;font-size:13px;}
            .smart-summary-card .ss-stem{background:#24364e;color:#9ac9ff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-param{background:#1c2c44;color:#d6ecff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-cond{font-size:10px;background:#223347;color:#cfe8ff;padding:2px 6px;border-radius:6px;letter-spacing:.3px;}
            .smart-summary-card .ss-line-meta{display:flex;align-items:center;gap:10px;}
            .smart-summary-card .ss-why-btn{background:none;border:0;color:#53b4ff;font-size:11px;cursor:pointer;padding:0 2px;}
            .smart-summary-card .ss-why{display:none;margin-top:6px;font-size:11px;line-height:1.4;background:#101c2b;padding:6px 8px;border:1px solid rgba(255,255,255,.05);border-radius:8px;color:#c7d8eb;}
            .smart-summary-card .ss-why.open{display:block;}
            .smart-summary-card .ss-hint{margin-top:10px;font-size:10px;opacity:.55;letter-spacing:.4px;}
            .smart-summary-card .ss-empty{opacity:.6;font-size:12px;padding:4px 2px;}
            .smart-summary-card[data-collapsed='true'] .ss-content{display:none;}
            @media (max-width:560px){.smart-summary-card{padding:12px 12px;} .smart-summary-card .ss-title{font-size:12px;} }
            `;
            document.head.appendChild(st);
            // Delegated listeners
            document.addEventListener('click', (e)=>{
                const btn = e.target.closest('.ss-toggle');
                if (btn){
                    const card = btn.closest('.smart-summary-card');
                    const expanded = btn.getAttribute('data-expanded') === 'true';
                    btn.setAttribute('data-expanded', expanded? 'false':'true');
                    btn.textContent = expanded? 'Expandir':'Colapsar';
                    if (expanded) card.setAttribute('data-collapsed','true'); else card.removeAttribute('data-collapsed');
                }
                const why = e.target.closest('.ss-why-btn');
                if (why){
                    const id = why.getAttribute('data-why-target');
                    const block = document.getElementById(id);
                    if (block){ block.classList.toggle('open'); }
                }
            }, { passive:true });
        }
        return html;
    } catch (e) { warn('smart summary fail', e); return ''; }
}

// ğŸ¯ HELPER: Detectar se modo reference estÃ¡ ativo (correÃ§Ã£o definitiva)
function isReferenceCompareActive(analysis, state) {
    const hasRefJob = !!(state?.referenceJobId || analysis?.referenceComparison?.baseJobId);
    const hasRefBands = !!(
        analysis?.referenceComparison ||
        analysis?.spectralBands?.reference ||
        analysis?.bands // jÃ¡ normalizado com centralizaÃ§Ã£o
    );
    const isSecondTrack = analysis?.mode === 'reference' && state?.isSecondTrack === true;

    return (isSecondTrack && hasRefJob) || (analysis?.mode === 'reference' && hasRefBands);
}

// ğŸ¯ HELPER: Calcular centro de um range {min, max}
function centerOfRange(range) {
    if (!range || typeof range.min !== 'number' || typeof range.max !== 'number') return null;
    return (range.min + range.max) / 2;
}

// ğŸ¯ HELPER: Formatar target (range ou valor) para exibiÃ§Ã£o
function formatTarget(rangeOrValue) {
    if (typeof rangeOrValue === 'number') return `${rangeOrValue.toFixed(1)} dB`;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        return `${rangeOrValue.min.toFixed(1)} a ${rangeOrValue.max.toFixed(1)} dB`;
    }
    return 'â€”';
}

// ğŸ¯ HELPER: Derivar tolerÃ¢ncia de um range ou valor
function deriveTolerance(rangeOrValue, fallback = 2.0) {
    if (typeof rangeOrValue === 'number') return fallback;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        // 1/4 da largura do range, limitado entre 0.8 e 4.5
        const span = Math.abs(rangeOrValue.max - rangeOrValue.min);
        return Math.max(0.8, Math.min(4.5, span * 0.25));
    }
    return fallback;
}

// ğŸ¯ HELPER: Computar se tem dados necessÃ¡rios para referenceComparisonMetrics
/**
 * ğŸ¯ FUNÃ‡ÃƒO CRÃTICA: Obter mÃ©tricas de comparaÃ§Ã£o ativas (modo referÃªncia OU gÃªnero)
 * 
 * Esta funÃ§Ã£o resolve o bug onde modo gÃªnero nÃ£o detectava targets carregados.
 * 
 * REGRAS:
 * 1. Modo referÃªncia: usa analysis.referenceComparisonMetrics (vem do backend)
 * 2. Modo gÃªnero: usa window.__activeRefData / window.PROD_AI_REF_DATA[genre] (carregado no front)
 * 3. Nunca quebra comportamento de modo referÃªncia existente
 * 
 * @param {Object} normalizedResult - AnÃ¡lise normalizada
 * @returns {Object|null} - MÃ©tricas de comparaÃ§Ã£o ou null
 */
function getActiveReferenceComparisonMetrics(normalizedResult) {
    // ğŸ¯ DETECÃ‡ÃƒO CORRETA DE MODO: Verificar genreTargets VÃLIDOS, nÃ£o apenas mode='genre'
    const mode = normalizedResult?.mode || window.currentAnalysisMode || 'genre';
    const hasValidGenreTargets = normalizedResult?.data?.genreTargets && 
                                  Object.keys(normalizedResult.data.genreTargets).length > 0;
    const isRealGenreMode = mode === 'genre' && hasValidGenreTargets;
    const hasRefContext = hasActiveReferenceContext();
    
    console.group('ğŸ” [REF-METRICS] getActiveReferenceComparisonMetrics');
    log('mode:', mode);
    log('hasValidGenreTargets:', hasValidGenreTargets);
    log('isRealGenreMode:', isRealGenreMode);
    log('hasActiveReferenceContext():', hasRefContext);

    // 1ï¸âƒ£ MODO REFERÃŠNCIA: usa o que veio do backend OU constrÃ³i de FirstAnalysisStore
    if (mode === 'reference' || hasRefContext) {
        if (normalizedResult?.referenceComparisonMetrics) {
            log('âœ… [REF-METRICS] Usando referenceComparisonMetrics do backend');
            log('   - Fonte: backend');
            log('   - Tem bands:', !!normalizedResult.referenceComparisonMetrics.bands);
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        // ğŸ”¨ Construir a partir de FirstAnalysisStore se disponÃ­vel
        if (window.FirstAnalysisStore?.has?.()) {
            const firstAnalysis = window.FirstAnalysisStore.get();
            log('âœ… [REF-METRICS] Construindo a partir de FirstAnalysisStore');
            log('   - Fonte: FirstAnalysisStore');
            log('   - Tem technicalData:', !!firstAnalysis?.technicalData);
            console.groupEnd();
            return {
                bands: firstAnalysis?.technicalData?.spectral_balance || firstAnalysis?.bands,
                lufs: firstAnalysis?.technicalData?.lufsIntegrated,
                truePeak: firstAnalysis?.technicalData?.truePeakDbtp,
                dynamicRange: firstAnalysis?.technicalData?.dynamicRange,
                _isReferenceMode: true
            };
        }
    }

    // 2ï¸âƒ£ MODO GÃŠNERO REAL: ğŸ¯ Usar analysis.data.genreTargets
    if (isRealGenreMode) {
        log('ğŸ¯ [GENRE-TARGETS] Extraindo targets da anÃ¡lise (FONTE OFICIAL)');
        
        // ğŸ¯ PRIORIDADE 1: analysis.data.genreTargets (BACKEND OFICIAL)
        const genreTargets = extractGenreTargetsFromAnalysis(normalizedResult);
        if (genreTargets) {
            log('âœ… [GENRE-FIX] Usando analysis.data.genreTargets (modo genre - FONTE OFICIAL)');
            log('   - Fonte: analysis.data.genreTargets');
            log('   - Tem bands:', !!genreTargets.bands);
            log('   - Keys:', Object.keys(genreTargets));
            console.groupEnd();
            return genreTargets.referenceComparisonMetrics || genreTargets;
        }
        
        // ğŸ¯ PRIORIDADE 2 (FALLBACK): window.__activeRefData (global universal)
        if (window.__activeRefData) {
            warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando window.__activeRefData (analysis.data.genreTargets nÃ£o disponÃ­vel)');
            log('   - Fonte: window.__activeRefData (FALLBACK)');
            log('   - Tem bands:', !!window.__activeRefData.bands);
            log('   - Tem referenceComparisonMetrics:', !!window.__activeRefData.referenceComparisonMetrics);
            console.groupEnd();
            return window.__activeRefData.referenceComparisonMetrics || window.__activeRefData;
        }
        
        // ğŸ¯ PRIORIDADE 3 (FALLBACK): window.PROD_AI_REF_DATA[genre] (dicionÃ¡rio por gÃªnero)
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando PROD_AI_REF_DATA[genre] (analysis.data.genreTargets nÃ£o disponÃ­vel)');
            log('   - Fonte: window.PROD_AI_REF_DATA[' + genre + '] (FALLBACK)');
            log('   - Tem bands:', !!window.PROD_AI_REF_DATA[genre].bands);
            console.groupEnd();
            const genreData = window.PROD_AI_REF_DATA[genre];
            return genreData.referenceComparisonMetrics || genreData;
        }
        
        // ğŸ¯ PRIORIDADE 4 (FALLBACK): Fallback para analysis.referenceComparisonMetrics (se existir)
        if (normalizedResult?.referenceComparisonMetrics) {
            warn('âš ï¸ [GENRE-FIX] FALLBACK: Usando analysis.referenceComparisonMetrics (Ãºltimo recurso)');
            log('   - Fonte: analysis.referenceComparisonMetrics (FALLBACK)');
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        error('âŒ [GENRE-FIX] CRÃTICO: Nenhum target de gÃªnero encontrado!');
        error('   - analysis.data.genreTargets:', !!normalizedResult?.data?.genreTargets);
        error('   - window.__activeRefData:', !!window.__activeRefData);
        error('   - window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
        error('   - Genre:', genre);
        console.groupEnd();
        return null;
    }

    // 3ï¸âƒ£ FALLBACK: tentar analysis.referenceComparisonMetrics
    if (normalizedResult?.referenceComparisonMetrics) {
        log('âœ… [GENRE-FIX] Usando analysis.referenceComparisonMetrics (fallback genÃ©rico)');
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    warn('âŒ [GENRE-FIX] Nenhuma mÃ©trica de comparaÃ§Ã£o disponÃ­vel');
    console.groupEnd();
    return null;
}

function computeHasReferenceComparisonMetrics(analysis) {
    // ğŸ¯ DETECÃ‡ÃƒO CORRETA: Verificar se Ã© REALMENTE modo gÃªnero (com targets vÃ¡lidos)
    const hasValidGenreTargets = analysis?.data?.genreTargets && 
                                  Object.keys(analysis.data.genreTargets).length > 0;
    const isRealGenreMode = analysis?.mode === 'genre' && hasValidGenreTargets;
    const hasRefContext = hasActiveReferenceContext();
    
    // Se for modo gÃªnero REAL, nÃ£o tem referenceComparisonMetrics
    if (isRealGenreMode && !hasRefContext) {
        log('[REF-METRICS] Modo gÃªnero REAL (mode=genre + genreTargets vÃ¡lidos) - sem referenceComparisonMetrics');
        return false;
    }
    
    // ğŸ¯ VERIFICAR MÃšLTIPLAS FONTES
    const comparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasComparisonRows = window.__REFERENCE_COMPARISON_ROWS__?.length > 0;
    const hasFirstStore = window.FirstAnalysisStore?.has?.();
    
    const hasMetrics = !!(comparisonMetrics || (hasRefContext && (hasComparisonRows || hasFirstStore)));
    
    log('[REF-METRICS] computeHasReferenceComparisonMetrics:', {
        hasMetrics,
        mode: analysis?.mode,
        isRealGenreMode,
        hasRefContext,
        hasComparisonRows,
        hasFirstStore,
        hasComparisonMetrics: !!comparisonMetrics
    });
    
    return hasMetrics;
}

// --- BEGIN: band target resolver (mode-aware) ---
const BAND_NORMALIZATION_MAP = {
    // normaliza chaves heterogÃªneas para um vocabulÃ¡rio comum
    low_bass: 'bass',
    upper_bass: 'bass',
    low_mid: 'lowMid',
    high_mid: 'highMid',
    brilho: 'air',
    presenca: 'presence',
    // deixe iguais as que jÃ¡ batem:
    sub: 'sub',
    bass: 'bass',
    lowMid: 'lowMid',
    mid: 'mid',
    highMid: 'highMid',
    presence: 'presence',
    air: 'air'
};

const IGNORE_BANDS = new Set(['totalPercentage', '_status', 'total', 'metadata']);

// tenta extrair nÃºmero: aceita { value }, { db }, { rms_db }, { energy_db }, nÃºmero puro etc.
function pickNumeric(val) {
    if (val == null) return null;
    if (typeof val === 'number' && Number.isFinite(val)) return val;
    if (typeof val === 'object') {
        if (typeof val.value === 'number' && Number.isFinite(val.value)) return val.value;
        if (typeof val.db === 'number' && Number.isFinite(val.db)) return val.db;
        if (typeof val.rms_db === 'number' && Number.isFinite(val.rms_db)) return val.rms_db;
        if (typeof val.energy_db === 'number' && Number.isFinite(val.energy_db)) return val.energy_db;
    }
    return null;
}

function normalizeBandKey(k) {
    return BAND_NORMALIZATION_MAP[k] || k;
}

function getReferenceBandValue(refBands, bandKey) {
    const k = normalizeBandKey(bandKey);
    const v = refBands?.[k];
    return pickNumeric(v);
}

function getGenreTargetRange(genreTargets, bandKey) {
    const k = normalizeBandKey(bandKey);
    // Suporta {min,max} ou [min,max], e fallback para target/Â±tol
    const range = genreTargets?.[k];
    if (!range) return null;

    if (Array.isArray(range) && range.length === 2) {
        return { min: range[0], max: range[1], tol: Math.abs(range[1] - range[0]) / 4 || null };
    }
    if (typeof range === 'object') {
        if (typeof range.min === 'number' && typeof range.max === 'number') {
            return { min: range.min, max: range.max, tol: (range.tol ?? (Math.abs(range.max - range.min) / 4)) || null };
        }
        if (typeof range.target_db === 'number' && typeof range.tol_db === 'number') {
            return { min: range.target_db - range.tol_db, max: range.target_db + range.tol_db, tol: range.tol_db };
        }
        if (typeof range.target === 'number' && typeof range.tol === 'number') {
            return { min: range.target - range.tol, max: range.target + range.tol, tol: range.tol };
        }
    }
    return null;
}

function formatDb(n) {
    return (typeof n === 'number' && Number.isFinite(n)) ? `${n.toFixed(1)}dB` : 'â€”';
}
// --- END: band target resolver (mode-aware) ---

// ğŸ§  NOVA PROTEÃ‡ÃƒO UNIVERSAL â€” ReferÃªncia real > gÃªnero
function resolveTargetMetric(analysis, key, fallback) {
    // 1ï¸âƒ£ Busca no objeto da anÃ¡lise de referÃªncia (segunda faixa)
    if (analysis?.referenceAnalysis?.technicalData?.[key] !== undefined) {
        log(`ğŸ¯ [RESOLVE] ${key} encontrado em referenceAnalysis:`, analysis.referenceAnalysis.technicalData[key]);
        return analysis.referenceAnalysis.technicalData[key];
    }
    
    // 2ï¸âƒ£ Busca no objeto da prÃ³pria anÃ¡lise (se comparando com si mesma)
    if (analysis?.technicalData?.[key] !== undefined) {
        log(`ğŸ¯ [RESOLVE] ${key} encontrado em technicalData:`, analysis.technicalData[key]);
        return analysis.technicalData[key];
    }
    
    // 3ï¸âƒ£ Busca no gÃªnero (estrutura antiga)
    const targetKey = `${key}_target`;
    if (analysis?.referenceComparison?.[targetKey] !== undefined) {
        log(`ğŸ¯ [RESOLVE] ${key} encontrado em referenceComparison.${targetKey}:`, analysis.referenceComparison[targetKey]);
        return analysis.referenceComparison[targetKey];
    }
    
    // 4ï¸âƒ£ Fallback seguro
    log(`ğŸ›¡ï¸ [RESOLVE] ${key} usando fallback:`, fallback);
    return fallback ?? 0;
}

// ğŸ§® PARTE 3.1: FunÃ§Ã£o de normalizaÃ§Ã£o para estrutura de referÃªncia
function normalizeReferenceShape(a) {
  if (!a) return {};
  return {
    fileName: a.fileName || a.metadata?.fileName || "Faixa desconhecida",
    bands: a.bands || a.spectralBands,
    lufsIntegrated: a.loudness?.integrated ?? a.lufsIntegrated,
    truePeakDbtp: a.truePeak?.dbtp ?? a.truePeakDbtp,
    dynamicRange: a.dynamics?.dr ?? a.dynamicRange,
    lra: a.loudness?.range ?? a.lra,
    crestFactor: a.dynamics?.crest ?? a.crestFactor
  };
}

// ğŸ”’ Global render lock para evitar ReferenceError
if (typeof window.comparisonLock === "undefined") {
    window.comparisonLock = false;
    log("[LOCK-INIT] comparisonLock inicializado como false");
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ğŸ¯ BUILD COMPARISON ROWS - TABELA A/B COM DELTA
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
/**
 * ConstrÃ³i linhas de comparaÃ§Ã£o side-by-side entre duas mÃºsicas (A vs B)
 * @param {Object} metricsA - MÃ©tricas da primeira mÃºsica (base/referÃªncia)
 * @param {Object} metricsB - MÃ©tricas da segunda mÃºsica (comparaÃ§Ã£o)
 * @returns {Array} Array de objetos {key, label, aValue, bValue, delta, unit, status}
 */
/**
 * ğŸ¯ Helper: Extrai mÃ©tricas de analysis.metrics OU technicalData
 */
function pickFromTechnicalData(technicalData) {
    if (!technicalData) return {};
    return {
        lufsIntegrated: technicalData.lufsIntegrated,
        truePeakDbtp: technicalData.truePeakDbtp,
        dynamicRange: technicalData.dynamicRange,
        lra: technicalData.lra,
        rmsLeft: technicalData.rmsLeft,
        crestFactor: technicalData.crestFactor,
        stereoCorrelation: technicalData.stereoCorrelation
    };
}

function buildComparisonRows(metricsA, metricsB) {
    log('[AB-TABLE] ğŸ”¨ Construindo tabela de comparaÃ§Ã£o A vs B');
    
    if (!metricsA || !metricsB) {
        error('[AB-TABLE] âŒ MÃ©tricas ausentes:', { hasA: !!metricsA, hasB: !!metricsB });
        return [];
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO #2: Extrair de metrics OU technicalData
    const userMetrics = metricsA.metrics ?? pickFromTechnicalData(metricsA.technicalData ?? metricsA);
    const refMetrics = metricsB.metrics ?? pickFromTechnicalData(metricsB.technicalData ?? metricsB);
    
    log('[AB-TABLE] ğŸ“Š MÃ©tricas extraÃ­das:', {
        userKeys: Object.keys(userMetrics),
        refKeys: Object.keys(refMetrics),
        userLufs: userMetrics.lufsIntegrated,
        refLufs: refMetrics.lufsIntegrated
    });
    
    // Validar que temos pelo menos 1 mÃ©trica vÃ¡lida
    const userHasMetrics = Object.values(userMetrics).some(v => v != null);
    const refHasMetrics = Object.values(refMetrics).some(v => v != null);
    
    if (!userHasMetrics || !refHasMetrics) {
        error('[AB-TABLE] âŒ Nenhuma mÃ©trica vÃ¡lida encontrada:', { userHasMetrics, refHasMetrics });
        return [];
    }
    
    // Definir mapeamento de mÃ©tricas (key, label, unit, path)
    const metricsMappings = [
        {
            key: 'lufs',
            label: 'LUFS Integrado',
            unit: 'LUFS',
            pathA: ['lufsIntegrated'],
            pathB: ['lufsIntegrated'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false // menor Ã© pior (mais negativo)
        },
        {
            key: 'truePeak',
            label: 'True Peak',
            unit: 'dBTP',
            pathA: ['truePeakDbtp'],
            pathB: ['truePeakDbtp'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: true // maior Ã© pior (clipping)
        },
        {
            key: 'dynamicRange',
            label: 'Dynamic Range',
            unit: 'dB',
            pathA: ['dynamicRange'],
            pathB: ['dynamicRange'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false // maior Ã© melhor
        },
        {
            key: 'lra',
            label: 'LRA (Loudness Range)',
            unit: 'LU',
            pathA: ['lra'],
            pathB: ['lra'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false
        },
        {
            key: 'rms',
            label: 'RMS',
            unit: 'dBFS',
            pathA: ['technicalData', 'rmsLeft'], // Usar left como referÃªncia
            pathB: ['technicalData', 'rmsLeft'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: false
        },
        {
            key: 'crestFactor',
            label: 'Crest Factor',
            unit: 'dB',
            pathA: ['technicalData', 'crestFactor'],
            pathB: ['technicalData', 'crestFactor'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: false
        },
        {
            key: 'stereoCorrelation',
            label: 'CorrelaÃ§Ã£o EstÃ©reo',
            unit: '',
            pathA: ['technicalData', 'stereoCorrelation'],
            pathB: ['technicalData', 'stereoCorrelation'],
            format: (v) => v?.toFixed(3) || 'N/A',
            inverse: false // maior Ã© melhor (atÃ© 1.0)
        }
    ];
    
    const rows = [];
    
    for (const mapping of metricsMappings) {
        // Extrair valor de A percorrendo path (agora de userMetrics)
        let valueA = userMetrics;
        for (const key of mapping.pathA) {
            valueA = valueA?.[key];
        }
        
        // Extrair valor de B percorrendo path (agora de refMetrics)
        let valueB = refMetrics;
        for (const key of mapping.pathB) {
            valueB = valueB?.[key];
        }
        
        // Formatar valores
        const aFormatted = mapping.format(valueA);
        const bFormatted = mapping.format(valueB);
        
        // Calcular delta (B - A)
        let delta = null;
        let deltaFormatted = 'N/A';
        let status = 'neutral';
        
        if (typeof valueA === 'number' && typeof valueB === 'number') {
            delta = valueB - valueA;
            deltaFormatted = delta >= 0 ? `+${delta.toFixed(2)}` : delta.toFixed(2);
            
            // Determinar status (melhor/pior/neutro)
            const threshold = 0.5; // Threshold para considerar diferenÃ§a significativa
            if (Math.abs(delta) < threshold) {
                status = 'neutral';
            } else if (mapping.inverse) {
                // Para mÃ©tricas inversas (true peak), menor delta Ã© melhor
                status = delta < 0 ? 'better' : 'worse';
            } else {
                // Para mÃ©tricas normais (LUFS, DR), maior delta Ã© melhor
                status = delta > 0 ? 'better' : 'worse';
            }
        }
        
        rows.push({
            key: mapping.key,
            label: mapping.label,
            aValue: aFormatted,
            bValue: bFormatted,
            delta: deltaFormatted,
            unit: mapping.unit,
            status: status
        });
    }
    
    log('[AB-TABLE] âœ… Tabela construÃ­da com', rows.length, 'linhas');
    console.table(rows);
    
    return rows;
}

// --- BEGIN: deterministic mode gate ---
function renderReferenceComparisons(ctx) {
    // ========================================
    // ğŸ¯ PASSO 0A: DECLARAÃ‡ÃƒO LOCAL DE `analysis` (FIX: ReferenceError)
    // ========================================
    // âœ… Corrige crash "ReferenceError: analysis is not defined"
    // Extrai `analysis` do contexto recebido com mÃºltiplos fallbacks
    const analysis = ctx?.analysis || 
                     ctx?.analysisResult || 
                     ctx?.currentAnalysis || 
                     { 
                         userAnalysis: ctx?.userAnalysis, 
                         referenceAnalysis: ctx?.referenceAnalysis 
                     };
    
    log('[REF-RENDER-FIX] âœ… Variable analysis declarada:', {
        hasAnalysis: !!analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis,
        source: ctx?.analysis ? 'ctx.analysis' : 
                ctx?.analysisResult ? 'ctx.analysisResult' : 
                ctx?.currentAnalysis ? 'ctx.currentAnalysis' : 'constructed'
    });
    
    // ========================================
    // ğŸ›¡ï¸ TRY/CATCH WRAPPER: ProteÃ§Ã£o contra crashes na renderizaÃ§Ã£o
    // ========================================
    try {
        log('[REF-RENDER-SAFE] Iniciando renderizaÃ§Ã£o protegida');
    
    // ========================================
    // ğŸ¯ PASSO 0B: GUARD - DETECÃ‡ÃƒO ROBUSTA DE MODO REFERÃŠNCIA
    // ========================================
    const hasRefContext = hasActiveReferenceContext();
    const isModeEngineRef = SOUNDY_MODE_ENGINE.isReferenceCompare();
    const isCurrentModeRef = window.currentAnalysisMode === 'reference';
    
    // ğŸ¯ Extrair compareMode usando helper (NUNCA ctx.mode)
    const compareMode = getCompareMode(ctx);
    
    // ğŸ” LOG DE DEBUG: Estado completo do gate
    const refJobIdForLog = window.__REFERENCE_JOB_ID__ || window.__soundyState?.referenceJobId;
    const currJobIdForLog = window.__CURRENT_JOB_ID__ || ctx?.userAnalysis?.jobId;
    
    console.group('[REF-RENDER-GATE] ğŸ” ValidaÃ§Ã£o de Modo');
    log('hasActiveReferenceContext():', hasRefContext);
    log('SOUNDY_MODE_ENGINE.isReferenceCompare():', isModeEngineRef);
    log('window.currentAnalysisMode:', window.currentAnalysisMode, 'â†’ isRef:', isCurrentModeRef);
    log('compareMode:', compareMode, '(fonte: getCompareMode helper)');
    log('JobIds:', { refJobId: refJobIdForLog, currJobId: currJobIdForLog, areDifferent: refJobIdForLog !== currJobIdForLog });
    console.groupEnd();
    
    // âœ… Permitir renderizaÃ§Ã£o se QUALQUER condiÃ§Ã£o indicar modo reference
    if (!hasRefContext && !isModeEngineRef && !isCurrentModeRef) {
        log('[RENDER-REF] â­ï¸ Nenhum indicador de modo referÃªncia - abortando');
        return;
    }
    
    // ğŸ›¡ï¸ GUARD: Validar se Ã© realmente modo gÃªnero (nÃ£o apenas genre='default' falso positivo)
    const analysisCheck = ctx?.userAnalysis || ctx?.user;
    const hasValidGenreTargets = analysisCheck?.data?.genreTargets && 
                                  Object.keys(analysisCheck.data.genreTargets).length > 0;
    const isExplicitGenreMode = analysisCheck?.mode === 'genre' && hasValidGenreTargets;
    
    if (isExplicitGenreMode) {
        log('[RENDER-REF] ğŸ¯ Modo gÃªnero REAL detectado (mode=genre + genreTargets vÃ¡lidos) - abortando');
        return;
    }
    
    log('[RENDER-REF] âœ… Modo referÃªncia confirmado - prosseguindo com renderizaÃ§Ã£o');
    
    // ========================================
    // ğŸ¯ PASSO 1: VALIDAR DADOS DO STORE SE DISPONÃVEL (MODO REFERENCE)
    // ========================================
    console.group('ğŸ¯ [RENDER-REF] VALIDAÃ‡ÃƒO DE FONTE DE DADOS');
    
    if (ctx?._useStoreData) {
        log('âœ… [STORE-MODE] RenderizaÃ§Ã£o usando dados do store isolado');
        log('   - userAnalysis.jobId:', ctx.userAnalysis?.jobId);
        log('   - referenceAnalysis.jobId:', ctx.referenceAnalysis?.jobId);
        
        // ValidaÃ§Ã£o de integridade do store
        if (window.SoundyAI_Store?.first && window.SoundyAI_Store?.second) {
            console.table({
                refJobId: window.SoundyAI_Store.first?.jobId,
                currJobId: window.SoundyAI_Store.second?.jobId,
                refName: window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName,
                currName: window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName,
                sameJob: window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId,
                sameName: (window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName) === 
                          (window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName)
            });
            
            // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: Store NÃƒO pode ter jobIds iguais
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                error('ğŸš¨ [STORE-ERROR] STORE CONTAMINADO!');
                error('   - Store tem jobIds idÃªnticos');
                console.trace();
                console.groupEnd();
                alert('ERRO: Store contaminado detectado. Por favor, recarregue a pÃ¡gina.');
                return;
            }
            
            log('âœ… [STORE-VALIDATED] Store validado - dados isolados confirmados');
        } else {
            warn('âš ï¸ [STORE-WARN] Store nÃ£o estÃ¡ completo');
            log('   - Caindo para modo legado');
        }
    } else {
        log('âš ï¸ [LEGACY-MODE] RenderizaÃ§Ã£o usando sistema legado');
        log('   - Dados nÃ£o vÃªm do store isolado');
    }
    
    console.groupEnd();
    
    // ========================================
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA NO INÃCIO: Tentar recuperar jobIds corretos se necessÃ¡rio
    // ========================================
    let userJobId = ctx?.userAnalysis?.jobId || ctx?.user?.jobId;
    let refJobId = ctx?.referenceAnalysis?.jobId || ctx?.ref?.jobId;
    
    console.group('ğŸ¯ [RENDER-REF] Iniciando renderizaÃ§Ã£o com validaÃ§Ã£o');
    log('   userJobId recebido:', userJobId);
    log('   refJobId recebido:', refJobId);
    log('   SÃ£o iguais?', userJobId === refJobId);
    
    // Se recebeu jobIds iguais, TENTA RECUPERAR os corretos
    if (userJobId && refJobId && userJobId === refJobId) {
        error('âŒ [RENDER-REF] ERRO: Recebeu jobIds iguais!');
        error('   Tentando recuperar jobIds corretos com getCorrectJobId()...');
        
        // RECUPERA os jobIds corretos
        const recoveredCurrentJobId = getCorrectJobId('current');
        const recoveredReferenceJobId = getCorrectJobId('reference');
        
        log('ğŸ”„ [RENDER-REF] JobIds recuperados:');
        log('   Novo userJobId (current):', recoveredCurrentJobId);
        log('   Novo refJobId (reference):', recoveredReferenceJobId);
        log('   Recuperados sÃ£o diferentes?', recoveredCurrentJobId !== recoveredReferenceJobId);
        
        // Se AINDA forem iguais, ABORTA
        if (recoveredCurrentJobId === recoveredReferenceJobId) {
            error('âŒ [RENDER-REF] FALHA NA RECUPERAÃ‡ÃƒO!');
            error('   Mesmo apÃ³s getCorrectJobId(), os jobIds sÃ£o iguais');
            console.trace();
            console.groupEnd();
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o. Os jobIds sÃ£o iguais. Recarregue a pÃ¡gina.');
            return;
        }
        
        log('âœ… [RENDER-REF] JobIds recuperados com sucesso!');
        log('   Atualizando userJobId e refJobId no contexto...');
        
        // Atualizar jobIds no contexto
        userJobId = recoveredCurrentJobId;
        refJobId = recoveredReferenceJobId;
        
        // Atualizar tambÃ©m no ctx se possÃ­vel
        if (ctx?.userAnalysis) ctx.userAnalysis.jobId = userJobId;
        if (ctx?.referenceAnalysis) ctx.referenceAnalysis.jobId = refJobId;
        if (ctx?.user) ctx.user.jobId = userJobId;
        if (ctx?.ref) ctx.ref.jobId = refJobId;
    } else {
        log('âœ… [RENDER-REF] JobIds jÃ¡ sÃ£o diferentes - continuando normalmente');
    }
    
    console.groupEnd();
    
    // ========================================
    // ğŸš¨ VALIDAÃ‡ÃƒO CRÃTICA: NUNCA COMPARAR MESMA MÃšSICA (validaÃ§Ã£o original mantida)
    // ========================================
    console.group('ğŸš¨ [RENDER-VALIDATION] ValidaÃ§Ã£o crÃ­tica de jobIds');
    log('   - userJobId (apÃ³s possÃ­vel recuperaÃ§Ã£o):', userJobId);
    log('   - refJobId (apÃ³s possÃ­vel recuperaÃ§Ã£o):', refJobId);
    log('   - SÃ£o iguais?', userJobId === refJobId);
    
    // VALIDAÃ‡ÃƒO CRÃTICA: Se jobIds sÃ£o iguais, ABORTAR renderizaÃ§Ã£o
    if (userJobId && refJobId && userJobId === refJobId) {
        error('âŒ [RENDER] ERRO CRÃTICO: Tentando comparar mesma mÃºsica!');
        error('   userJobId:', userJobId);
        error('   refJobId:', refJobId);
        console.trace();
        
        // Tenta recuperar o jobId correto da segunda mÃºsica
        const recoveredJobId = getCorrectJobId('current'); // Segunda mÃºsica
        const firstJobId = getCorrectJobId('reference'); // Primeira mÃºsica
        
        log('ğŸ”„ [RENDER] Tentando recuperar jobIds corretos:');
        log('   - Recovered currentJobId:', recoveredJobId);
        log('   - Recovered referenceJobId:', firstJobId);
        
        if (recoveredJobId && firstJobId && recoveredJobId !== firstJobId) {
            warn('âš ï¸ [RENDER] JobIds recuperados - reconstruindo ctx');
            // Reconstruir ctx com jobIds corretos
            // Por ora, ABORTAR para evitar renderizaÃ§Ã£o incorreta
            alert('ERRO: NÃ£o foi possÃ­vel carregar a comparaÃ§Ã£o corretamente. Por favor, recarregue a pÃ¡gina e tente novamente.');
            console.groupEnd();
            return;
        } else {
            error('âŒ [RENDER] NÃ£o foi possÃ­vel recuperar jobIds corretos');
            alert('ERRO CRÃTICO: ComparaÃ§Ã£o invÃ¡lida detectada. Recarregue a pÃ¡gina.');
            console.groupEnd();
            return;
        }
    }
    
    log('âœ… [RENDER-VALIDATION] JobIds sÃ£o diferentes - continuando renderizaÃ§Ã£o');
    console.groupEnd();
    
    // ========================================
    // âœ… CORREÃ‡ÃƒO 3: PadronizaÃ§Ã£o de chamada e validaÃ§Ã£o de ctx
    // ========================================
    // Normalizar ctx para aceitar objeto { mode, user, ref }
    const mode = ctx?.mode || window.currentAnalysisMode || 'genre';
    const user = ctx?.user || ctx?.userAnalysis || window._lastUserAnalysis || {};
    const refData = ctx?.ref || ctx?.referenceAnalysis || window.referenceAnalysisData || {};

    // HARD-GUARD: sem bands? nÃ£o renderiza A/B para evitar self-compare
    if (mode === 'reference') {
        if (!refData?.bands || !user?.bands) {
            warn('[A/B-SKIP] bands ausentes (user/ref). Evitando self-compare.');
            warn('[SUG-AUDIT][REFERENCE] âš ï¸ Modo reference mas sem bandas - pode afetar suggestions');
            return;
        }
        
        // âœ… AUDITORIA: Verificar se suggestions estÃ£o presentes
        log('[SUG-AUDIT][REFERENCE] Dados recebidos:', {
            userHasSuggestions: Array.isArray(user?.suggestions),
            userSuggestionsLength: user?.suggestions?.length || 0,
            refHasSuggestions: Array.isArray(refData?.suggestions),
            refSuggestionsLength: refData?.suggestions?.length || 0
        });
    }

    // Atualizar opts para compatibilidade com cÃ³digo existente
    const opts = {
        mode: mode,
        userAnalysis: user,
        referenceAnalysis: refData,
        ...ctx // Mesclar propriedades adicionais de ctx
    };

    // ========================================
    // ğŸ›¡ï¸ BLOQUEIO DEFINITIVO DE SELF-COMPARE POR CONTEÃšDO
    // ========================================
    // Recuperar faixas do FirstAnalysisStore usando papÃ©is (USER/REF)
    const userFromStoreRaw = FirstAnalysisStore.getUser();
    const refFromStoreRaw = FirstAnalysisStore.getRef();
    
    // ğŸ¯ HIDRATAR E NORMALIZAR: Garantir shape consistente (dupla proteÃ§Ã£o)
    const userFromStore = normalizeAnalysis(userFromStoreRaw);
    const refFromStore = normalizeAnalysis(refFromStoreRaw);
    
    log('[HYDRATE] ğŸ”„ Dados normalizados do store:', {
        userHasBands: !!userFromStore?.bands,
        refHasBands: !!refFromStore?.bands,
        userHasMetrics: !!userFromStore?.metrics,
        refHasMetrics: !!refFromStore?.metrics
    });
    
    // ğŸ” NOVA VALIDAÃ‡ÃƒO: Verificar mÃ©tricas A/B ao invÃ©s de bands
    const userMetricsCheck = extractABMetrics(userFromStore);
    const refMetricsCheck = extractABMetrics(refFromStore);
    
    log('[AB-DATA] user metrics extraction ok?', userMetricsCheck.ok, userMetricsCheck.debugShape);
    log('[AB-DATA] ref metrics extraction ok?', refMetricsCheck.ok, refMetricsCheck.debugShape);
    
    if (!userMetricsCheck.ok || !refMetricsCheck.ok) {
        warn('[AB-BLOCK] âš ï¸ MÃ©tricas A/B ausentes no store - tentando hidratar...');
        
        // ğŸ¯ TENTATIVA DE HIDRATAÃ‡ÃƒO: Recuperar da anÃ¡lise atual se disponÃ­vel
        if (!refMetricsCheck.ok && window.referenceAnalysisData) {
            const refFromWindow = extractABMetrics(window.referenceAnalysisData);
            if (refFromWindow.ok) {
                log('[AB-HYDRATE] ğŸ”„ Hidratando refFromStore com window.referenceAnalysisData');
                const hydratedRef = {
                    ...refFromStore,
                    bands: extractBands(window.referenceAnalysisData),
                    metrics: refFromWindow.metrics,
                    technicalData: refFromWindow.technicalData,
                    jobId: window.referenceAnalysisData.jobId || window.__REFERENCE_JOB_ID__
                };
                FirstAnalysisStore.setRef(hydratedRef);
            }
        }
        
        if (!userMetricsCheck.ok && ctx?.userAnalysis) {
            const userFromCtx = extractABMetrics(ctx.userAnalysis);
            if (userFromCtx.ok) {
                log('[AB-HYDRATE] ğŸ”„ Hidratando userFromStore com ctx.userAnalysis');
                const hydratedUser = {
                    ...userFromStore,
                    bands: extractBands(ctx.userAnalysis),
                    metrics: userFromCtx.metrics,
                    technicalData: userFromCtx.technicalData,
                    jobId: ctx.userAnalysis.jobId
                };
                FirstAnalysisStore.setUser(hydratedUser);
            }
        }
        
        // Re-verificar apÃ³s hidrataÃ§Ã£o
        const reCheckUser = FirstAnalysisStore.getUser();
        const reCheckRef = FirstAnalysisStore.getRef();
        const reCheckUserMetrics = extractABMetrics(reCheckUser);
        const reCheckRefMetrics = extractABMetrics(reCheckRef);
        
        if (!reCheckUserMetrics.ok || !reCheckRefMetrics.ok) {
            error('[AB-BLOCK] âŒ HidrataÃ§Ã£o falhou - abortando A/B');
            error('[AB-DATA] user recheck:', reCheckUserMetrics.debugShape);
            error('[AB-DATA] ref recheck:', reCheckRefMetrics.debugShape);
            return;
        }
        
        log('[AB-HYDRATE] âœ… HidrataÃ§Ã£o bem-sucedida');
    }
    
    // Detectar self-compare por mÃºltiplos critÃ©rios de conteÃºdo
    const samePointer = userFromStore === refFromStore;
    const sameJobId = userFromStore?.jobId && refFromStore?.jobId && userFromStore.jobId === refFromStore.jobId;
    const sameFile = userFromStore?.metadata?.fileKey && refFromStore?.metadata?.fileKey && 
                     userFromStore.metadata.fileKey === refFromStore.metadata.fileKey;
    const sameHash = userFromStore?.objectId?.hash && refFromStore?.objectId?.hash && 
                     userFromStore.objectId.hash === refFromStore.objectId.hash;
    
    if (samePointer || sameJobId || sameFile || sameHash) {
        error('[AB-BLOCK] âŒ Self-compare detectado - abortando tabela A/B:', {
            samePointer,
            sameJobId: sameJobId ? `${userFromStore.jobId}` : false,
            sameFile: sameFile ? `${userFromStore.metadata.fileKey}` : false,
            sameHash: sameHash ? `${userFromStore.objectId.hash}` : false,
            userVid: window.CacheIndex.USER,
            refVid: window.CacheIndex.REF,
            userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
            refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName
        });
        return; // Aborta renderizaÃ§Ã£o A/B
    }
    
    // âœ… ValidaÃ§Ã£o passou - sÃ£o faixas diferentes
    log('[AB-SAFETY] âœ… Faixas validadas como diferentes:', {
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
        refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName,
        userJobId: userFromStore?.jobId,
        refJobId: refFromStore?.jobId
    });
    
    // ğŸ¯ [STORE-PRIORITY-FIX] PRIORIDADE ABSOLUTA: SoundyAI_Store > FirstAnalysisStore
    log('ğŸ¯ [STORE-PRIORITY-FIX] Verificando prioridade de fonte de dados...');
    
    // Verificar se SoundyAI_Store tem ambas anÃ¡lises
    const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
    
    let finalUserAnalysis, finalReferenceAnalysis;
    
    if (storeHasBoth) {
        log('âœ… [STORE-PRIORITY-FIX] Usando SoundyAI_Store (prioridade mÃ¡xima)');
        finalUserAnalysis = window.SoundyAI_Store.first;
        finalReferenceAnalysis = window.SoundyAI_Store.second;
        
        console.table({
            'Fonte': 'SoundyAI_Store',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId,
            'User LUFS': finalUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': finalReferenceAnalysis?.technicalData?.lufsIntegrated,
            'User DR': finalUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': finalReferenceAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': finalUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': finalReferenceAnalysis?.technicalData?.truePeakDbtp
        });
    } else {
        warn('âš ï¸ [STORE-PRIORITY-FIX] SoundyAI_Store incompleto, usando FirstAnalysisStore (fallback)');
        finalUserAnalysis = userFromStore;
        finalReferenceAnalysis = refFromStore;
        
        console.table({
            'Fonte': 'FirstAnalysisStore (fallback)',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId
        });
    }
    
    // Usar as faixas priorizadas (SoundyAI_Store > FirstAnalysisStore)
    opts.userAnalysis = finalUserAnalysis;
    opts.referenceAnalysis = finalReferenceAnalysis;
    
    // ========================================
    // ğŸ”§ DETECÃ‡ÃƒO SEGURA DE SELF-COMPARE (APÃ“S AB-SAFETY)
    // ========================================
    // Agora que temos os dados validados, detectar self-compare com critÃ©rios rigorosos
    const refAnalysis = opts.referenceAnalysis;
    const currAnalysis = opts.userAnalysis;
    
    const sameJob = !!(refAnalysis?.jobId && currAnalysis?.jobId && refAnalysis.jobId === currAnalysis.jobId);
    const sameVid = !!(refAnalysis?.vid && currAnalysis?.vid && refAnalysis.vid === currAnalysis.vid);
    const sameFileName = !!(refAnalysis?.fileName && currAnalysis?.fileName && refAnalysis.fileName === currAnalysis.fileName);
    const refVid = window.CacheIndex?.REF;
    const userVid = window.CacheIndex?.USER;
    
    // SÃ³ marca como selfCompare se TODAS as checagens coincidirem
    let selfCompare = false;
    if (sameJob && sameVid && sameFileName) {
        selfCompare = true;
        warn('[REF-GUARD] âš ï¸ Self-compare detectado (todos critÃ©rios):', { sameJob, sameVid, sameFileName });
    }
    
    // âœ… REVALIDAÃ‡ÃƒO: Limpar flag se for falso positivo
    // Se VIDs ou files sÃ£o diferentes, nÃ£o pode ser self-compare
    if (selfCompare && (userVid !== refVid || 
        (refAnalysis?.fileName || refAnalysis?.metadata?.fileName) !== (currAnalysis?.fileName || currAnalysis?.metadata?.fileName))) {
        warn('[REF-GUARD] â Corrigido selfCompare falso-positivo apÃ³s AB-SAFETY:', {
            userVid,
            refVid,
            userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
            refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
        });
        selfCompare = false;
    }
    
    // Marcar no opts para uso posterior
    opts.isSelfCompare = selfCompare;
    
    log('[SELF-COMPARE-FINAL] DecisÃ£o final:', {
        selfCompare,
        sameJob,
        sameVid,
        sameFileName,
        userVid,
        refVid,
        userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
        refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
    });
    
    // ==== STEP 3/6: refHardGuards() simplificado ====
    const guardResult = (function refHardGuards(){
        const s = window.__soundyState || {};
        
        if (!opts.userAnalysis || !opts.referenceAnalysis) {
            error("[REF-PATCH] Faltam dados pra A/B");
            return { abort: true, reason: 'missing-data' };
        }

        opts.usedReferenceAnalysis = true;

        if (window.__refRenderInProgress) {
            warn("[REF-PATCH] Render A/B em progresso â€” ignorando duplicado");
            return { abort: true, reason: 'render-in-progress' };
        }
        window.__refRenderInProgress = true;
        
        return { abort: false };
    })();
    
    // âœ… STEP 3/6: Tratar retorno de refHardGuards()
    if (guardResult && guardResult.abort) {
        warn(`[REF-GUARD] Abortando renderReferenceComparisons: ${guardResult.reason}`);
        return;
    }
    
    // ï¿½ [AUDIT-BANDS-IN-RENDER] Log NO INÃCIO da funÃ§Ã£o renderReferenceComparisons
    try {
        const refBandsInRender = opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance;
        const userBandsInRender = opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance;
        log('[AUDIT-BANDS-IN-RENDER]', {
            receivedRefBands: refBandsInRender,
            receivedUserBands: userBandsInRender,
            typeofRefBands: typeof refBandsInRender,
            typeofUserBands: typeof userBandsInRender,
            refBandsKeys: refBandsInRender ? Object.keys(refBandsInRender) : [],
            userBandsKeys: userBandsInRender ? Object.keys(userBandsInRender) : [],
            optsKeys: Object.keys(opts),
            hasUserAnalysis: !!opts.userAnalysis,
            hasReferenceAnalysis: !!opts.referenceAnalysis
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-RENDER', err);
    }
    
    // ï¿½ğŸ”’ PROTEÃ‡ÃƒO ANTI-DUPLICAÃ‡ÃƒO: Detectar se faixas sÃ£o idÃªnticas
    if (opts.userAnalysis?.fileName && opts.referenceAnalysis?.fileName &&
        opts.userAnalysis.fileName === opts.referenceAnalysis.fileName) {
        error("âŒ [REF-DUPE] DetecÃ§Ã£o de duplicaÃ§Ã£o â€” referÃªncia sobrescrita!");
        console.table({
            userTrack: opts.userAnalysis?.fileName,
            refTrack: opts.referenceAnalysis?.fileName,
        });
        return; // aborta renderizaÃ§Ã£o duplicada
    }
    
    // ğŸ§© Controle seguro de renderizaÃ§Ã£o
    if (window.comparisonLock) {
        warn("[LOCK] RenderizaÃ§Ã£o de comparaÃ§Ã£o ignorada (lock ativo)");
        return;
    }
    
    // [AUDIT-FLOW] Log ANTES do lock
    log("[AUDIT-FLOW] ğŸ” ANTES do lock:", {
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    window.comparisonLock = true;
    log("[LOCK] comparisonLock ativado");
    
    // [AUDIT-FLOW] Log DEPOIS do lock
    log("[AUDIT-FLOW] ğŸ” DEPOIS do lock:", {
        comparisonLock: window.comparisonLock,
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    // ğŸ”§ PARTE 2: ProteÃ§Ã£o em renderReferenceComparisons
    const globalState = window.__soundyState || {};
    const refStateCheck = globalState?.reference || {};
    const userCheck = refStateCheck.userAnalysis || opts.userAnalysis;
    const refCheck = refStateCheck.referenceAnalysis || opts.referenceAnalysis;

    if (!userCheck || !refCheck) {
        warn("[REF-COMP] Faltam dados de referÃªncia ou usuÃ¡rio, usando fallback seguro");
        window.comparisonLock = false;
        log("[LOCK] comparisonLock liberado (fallback)");
        return renderGenreComparisonSafe?.();
    }

    const userTrackCheck = userCheck.fileName || userCheck.metadata?.fileName || "Faixa 1 (usuÃ¡rio)";
    const refTrackCheck = refCheck.fileName || refCheck.metadata?.fileName || "Faixa 2 (referÃªncia)";
    const userBandsCheck = userCheck.bands || userCheck.technicalData?.spectral_balance || {};
    const refBandsCheck = refCheck.bands || refCheck.technicalData?.spectral_balance || {};

    const userBandsCountCheck = userBandsCheck ? Object.keys(userBandsCheck).length : 0;
    const refBandsCountCheck = refBandsCheck ? Object.keys(refBandsCheck).length : 0;
    
    if (refBandsCountCheck === 0) {
        warn("[REF-COMP] referenceBands ausentes - fallback para valores brutos");
    }

    log("[REF-COMP] Dados validados:", { 
        userTrackCheck, 
        refTrackCheck, 
        userBandsCount: userBandsCountCheck, 
        refBandsCount: refBandsCountCheck,
        userBandsKeys: userBandsCheck ? Object.keys(userBandsCheck) : [],
        refBandsKeys: refBandsCheck ? Object.keys(refBandsCheck) : []
    });
    
    // ğŸ¯ GARANTIR QUE CONTAINER EXISTE ANTES DE RENDERIZAR
    const container = ensureReferenceContainer();
    if (!container) {
        error('[RENDER-REF] âŒ NÃ£o foi possÃ­vel criar/localizar container #referenceComparisons');
        window.comparisonLock = false;
        log("[LOCK] comparisonLock liberado (container indisponÃ­vel)");
        
        // Tentar criar mensagem de erro em local alternativo
        const modalContent = document.getElementById('audioAnalysisResults');
        if (modalContent) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.cssText = 'padding: 20px; margin: 20px 0; background: #2a1a1a; border: 2px solid #ff4444; border-radius: 8px; color: #ff6666;';
            errorDiv.innerHTML = '<strong>âŒ Erro:</strong> NÃ£o foi possÃ­vel renderizar tabela de comparaÃ§Ã£o A/B (container ausente).';
            modalContent.insertBefore(errorDiv, modalContent.firstChild);
        }
        return;
    }
    
    // ğŸ”§ CORREÃ‡ÃƒO CRÃTICA: Removido __REF_RENDER_LOCK__ que bloqueava segunda chamada legÃ­tima
    // A validaÃ§Ã£o de dados abaixo Ã© suficiente para prevenir renders incompletos
    log("[LOCK-FIX] âœ… Permitindo render com validaÃ§Ã£o de dados (lock duplicado removido)");
    
    // Aceita opts ou analysis (backward compatibility)
    const finalAnalysis = opts.analysis || opts;
    let comparisonData = opts?.comparisonData || {};
    
    const refBandsReal =
        comparisonData?.refBands ||
        comparisonData?.referenceAnalysis?.bands ||
        comparisonData?.referenceAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.referenceAnalysis?.bands ||
        window.__soundyState?.reference?.referenceAnalysis?.technicalData?.spectral_balance;

    const userBandsReal =
        comparisonData?.userBands ||
        comparisonData?.userAnalysis?.bands ||
        comparisonData?.userAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.userAnalysis?.bands ||
        window.__soundyState?.reference?.userAnalysis?.technicalData?.spectral_balance;

    log('[VALIDATION-FIX] Verificando bandas:', {
        refBandsRealKeys: refBandsReal ? Object.keys(refBandsReal) : null,
        userBandsRealKeys: userBandsReal ? Object.keys(userBandsReal) : null,
    });

    if (!refBandsReal || !userBandsReal) {
        error('[VALIDATION-FIX] âŒ Falha crÃ­tica: bandas nÃ£o detectadas no momento do render.');
        error('comparisonData:', comparisonData);
        error('window.__soundyState:', window.__soundyState);
        window.comparisonLock = false;
        if (typeof displayModalResultsError === 'function') {
            return displayModalResultsError('Erro na anÃ¡lise por referÃªncia (bandas nÃ£o detectadas).');
        }
        return;
    }

    // âœ… Substitui o fallback antigo
    comparisonData.refBands = refBandsReal;
    comparisonData.userBands = userBandsReal;
    log('[VALIDATION-FIX] âœ… Bandas restauradas para renderizaÃ§Ã£o A/B');
    
    // ğŸ§  [SAFE_REF_V3] PATCH DEFINITIVO - Construir estrutura segura ANTES de qualquer acesso
    console.groupCollapsed("ğŸ§  [SAFE_REF_V3]");
    log("ğŸ“¦ opts recebido:", opts);
    
    // ğŸ” Obter state global
    const stateV3 = window.__soundyState || {};
    
    // ğŸ” Obter anÃ¡lises primeiro
    const ua = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
    const ra = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
    
    // ğŸ” Construir comparaÃ§Ã£o segura com mÃºltiplas fontes
    let comparisonBase = 
        opts?.comparisonData || 
        window?.comparisonData || 
        window?.lastComparisonData || 
        {};
    
    // ğŸ¯ SEMÃ‚NTICA CORRETA:
    // - userTrack = 1Âª faixa (SUA MÃšSICA/ATUAL) = userAnalysis
    // - referenceTrack = 2Âª faixa (REFERÃŠNCIA/ALVO) = referenceAnalysis
    let comparisonSafe;
    
    if (!comparisonBase.userTrack || !comparisonBase.referenceTrack) {
        warn("âš ï¸ [SAFE_REF_V3] comparisonData incompleto â€” tentando reconstruir via anÃ¡lises");
        
        comparisonSafe = {
            userTrack: ua?.metadata?.fileName || ua?.fileName || "1Âª Faixa (Sua MÃºsica/Atual)",
            referenceTrack: ra?.metadata?.fileName || ra?.fileName || "2Âª Faixa (ReferÃªncia/Alvo)",
            userBands: 
                ua?.technicalData?.spectral_balance || 
                ua?.bands || 
                ua?.spectralBands || 
                null,
            refBands: 
                ra?.technicalData?.spectral_balance || 
                ra?.bands || 
                ra?.spectralBands || 
                null,
        };
    } else {
        comparisonSafe = comparisonBase;
    }
    
    // ğŸ” [AUDIT-BANDS-SAFE-V3] Log APÃ“S construÃ§Ã£o de comparisonSafe
    try {
        log('[AUDIT-BANDS-SAFE-V3]', {
            comparisonSafeUserBands: comparisonSafe.userBands,
            comparisonSafeRefBands: comparisonSafe.refBands,
            typeofUserBands: typeof comparisonSafe.userBands,
            typeofRefBands: typeof comparisonSafe.refBands,
            userBandsKeys: comparisonSafe.userBands ? Object.keys(comparisonSafe.userBands) : [],
            refBandsKeys: comparisonSafe.refBands ? Object.keys(comparisonSafe.refBands) : [],
            sourceUA: ua ? 'opts.userAnalysis ou state.reference.userAnalysis' : 'N/A',
            sourceRA: ra ? 'opts.referenceAnalysis ou state.reference.referenceAnalysis' : 'N/A',
            uaBands: ua?.technicalData?.spectral_balance || ua?.bands || ua?.spectralBands,
            raBands: ra?.technicalData?.spectral_balance || ra?.bands || ra?.spectralBands
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'AUDIT-BANDS-SAFE-V3', err);
    }
    
    // Guardar globalmente (backup)
    window.lastComparisonData = comparisonSafe;
    
    // ğŸ§© Substituir opts.comparisonData quebrado
    opts.comparisonData = comparisonSafe;
    
    // ğŸ”’ Fallback hard caso ainda venha undefined
    if (!comparisonSafe.referenceTrack) {
        comparisonSafe.referenceTrack = 
            opts?.referenceAnalysis?.metadata?.fileName || 
            opts?.referenceAnalysis?.fileName ||
            stateV3?.reference?.referenceAnalysis?.metadata?.fileName || 
            "2Âª Faixa (ReferÃªncia/Alvo)";
    }
    if (!comparisonSafe.userTrack) {
        comparisonSafe.userTrack = 
            opts?.userAnalysis?.metadata?.fileName || 
            opts?.userAnalysis?.fileName ||
            stateV3?.reference?.userAnalysis?.metadata?.fileName || 
            "1Âª Faixa (Sua MÃºsica/Atual)";
    }
    
    log("âœ… [SAFE_REF_V3] Estrutura final reconstruÃ­da:", comparisonSafe);
    console.groupEnd();
    

    //  [PATCH V5] SCOPE GUARD DEFINITIVO - SincronizaÃ§Ã£o final antes de usar dados
    console.groupCollapsed(" [REF_FIX_V5]");
    let userTrack, referenceTrack;
    try {
        //  Verifica e sincroniza escopo de comparisonData
        // ğŸ¯ SEMÃ‚NTICA CORRETA:
        // - userTrack = 1Âª faixa (SUA MÃšSICA/ATUAL) = userAnalysis
        // - referenceTrack = 2Âª faixa (REFERÃŠNCIA/ALVO) = referenceAnalysis
        let comparisonData =
            opts?.comparisonData ||
            window?.comparisonData ||
            window?.lastComparisonData ||
            stateV3?.reference?.comparisonData ||
            comparisonSafe || // Usar comparisonSafe do Patch V3 como fallback
            {
                userTrack:
                    opts?.userAnalysis?.metadata?.fileName ||
                    opts?.userAnalysis?.fileName ||
                    stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                    "Sua MÃºsica (Atual)",
                referenceTrack:
                    opts?.referenceAnalysis?.metadata?.fileName ||
                    opts?.referenceAnalysis?.fileName ||
                    stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                    "Faixa de ReferÃªncia (Alvo)",
                userBands:
                    opts?.userAnalysis?.technicalData?.spectral_balance ||
                    opts?.userAnalysis?.bands ||
                    stateV3?.reference?.userAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.userAnalysis?.bands ||
                    {},
                refBands:
                    opts?.referenceAnalysis?.technicalData?.spectral_balance ||
                    opts?.referenceAnalysis?.bands ||
                    stateV3?.reference?.referenceAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.referenceAnalysis?.bands ||
                    {},
            };

        // ğŸ§© FIX: Preservar bandas vÃ¡lidas antes da redeclaraÃ§Ã£o
        if (comparisonData) {
            // Se jÃ¡ houver bandas vÃ¡lidas em comparisonSafe, preservar
            if (!comparisonData.refBands && comparisonSafe?.refBands) {
                comparisonData.refBands = comparisonSafe.refBands;
            }
            if (!comparisonData.userBands && comparisonSafe?.userBands) {
                comparisonData.userBands = comparisonSafe.userBands;
            }
            
            // Fallback adicional para opts se comparisonData ainda vazio
            if (!comparisonData.refBands && opts?.referenceAnalysis) {
                comparisonData.refBands =
                    opts.referenceAnalysis.bands ||
                    opts.referenceAnalysis.technicalData?.spectral_balance ||
                    window.__lastRefBands ||
                    {};
            }
            if (!comparisonData.userBands && opts?.userAnalysis) {
                comparisonData.userBands =
                    opts.userAnalysis.bands ||
                    opts.userAnalysis.technicalData?.spectral_balance ||
                    window.__lastUserBands ||
                    {};
            }
        }

        //  Atualiza referÃªncias globais
        window.comparisonData = comparisonData;
        window.lastComparisonData = comparisonData;
        opts.comparisonData = comparisonData;

        //  Cria variÃ¡veis locais seguras com fallback robusto
        // ğŸ¯ SEMÃ‚NTICA CORRETA DOS NOMES:
        userTrack = comparisonData?.userTrack || "Sua MÃºsica (Atual)";
        referenceTrack = comparisonData?.referenceTrack || "Faixa de ReferÃªncia (Alvo)";
        
        // âš¡ Fallback em cascata para garantir bandas vÃ¡lidas (incluindo persistÃªncia global)
        const localRefBands =
            window.__lastRefBands ||
            comparisonData?.refBands ||
            comparisonSafe?.refBands ||
            opts?.referenceAnalysis?.bands ||
            opts?.referenceAnalysis?.technicalData?.spectral_balance ||
            {};
        
        const localUserBands =
            window.__lastUserBands ||
            comparisonData?.userBands ||
            comparisonSafe?.userBands ||
            opts?.userAnalysis?.bands ||
            opts?.userAnalysis?.technicalData?.spectral_balance ||
            {};
        
        // [REF-COMP] âœ… Persistir bandas globalmente para uso posterior
        if (localRefBands && Object.keys(localRefBands).length > 0) window.__lastRefBands = localRefBands;
        if (localUserBands && Object.keys(localUserBands).length > 0) window.__lastUserBands = localUserBands;
        
        log('[REF-COMP][BANDS-FINAL-FIX] Estado de bandas apÃ³s fallback:', {
            hasRefBands: !!localRefBands && Object.keys(localRefBands).length > 0,
            hasUserBands: !!localUserBands && Object.keys(localUserBands).length > 0,
            refKeys: localRefBands ? Object.keys(localRefBands) : [],
            userKeys: localUserBands ? Object.keys(localUserBands) : []
        });

        // ğŸ” [AUDIT-REDECLARE] Log APÃ“S redeclaraÃ§Ã£o de variÃ¡veis
        try {
            log('[AUDIT-REDECLARE]', {
                refBandsCheck: localRefBands,
                userBandsCheck: localUserBands,
                typeofRefBands: typeof localRefBands,
                typeofUserBands: typeof localUserBands,
                refBandsKeys: localRefBands ? Object.keys(localRefBands) : [],
                userBandsKeys: localUserBands ? Object.keys(localUserBands) : [],
                refBandsIsEmpty: !localRefBands || Object.keys(localRefBands).length === 0,
                userBandsIsEmpty: !localUserBands || Object.keys(localUserBands).length === 0,
                comparisonDataRefBands: comparisonData?.refBands,
                comparisonDataUserBands: comparisonData?.userBands
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'AUDIT-REDECLARE', err);
        }

        log(" [REF_FIX_V5] Estrutura estabilizada:", {
            userTrack,
            referenceTrack,
            userBands: !!Object.keys(localUserBands || {}).length,
            refBands: !!Object.keys(localRefBands || {}).length,
        });

        //  Abortagem segura se algo vier undefined
        if (!referenceTrack || !userTrack) {
            error(" [REF_FIX_V5] referenceTrack ou userTrack ausentes!");
            window.comparisonLock = false;
            log("[LOCK] comparisonLock liberado (track ausente)");
            console.groupEnd();
            return;
        }

        //  Reatribui localmente para garantir escopo
        opts.referenceTrack = referenceTrack;
        opts.userTrack = userTrack;
        comparisonData.referenceTrack = referenceTrack;
        comparisonData.userTrack = userTrack;
    } catch (err) {
        error(" [REF_FIX_V5] Erro crÃ­tico de escopo:", err);
        window.comparisonLock = false;
        log("[LOCK] comparisonLock liberado (erro crÃ­tico)");
        console.groupEnd();
        return;
    }
    console.groupEnd();
    
    // ğŸ§® PARTE 3.2: ValidaÃ§Ã£o e normalizaÃ§Ã£o de anÃ¡lises
    const sRef = stateV3?.reference || {};
    const userAnalysis = opts.userAnalysis ?? sRef.userAnalysis;
    const referenceAnalysis = opts.referenceAnalysis ?? sRef.referenceAnalysis;

    if (!userAnalysis || !referenceAnalysis) {
        warn("[REF-COMP] Faltam anÃ¡lises; usando fallback controlado.");
        window.comparisonLock = false;
        log("[LOCK] comparisonLock liberado (anÃ¡lises ausentes)");
        return renderGenreComparisonSafe?.();
    }

    // ğŸ¯ SEMÃ‚NTICA CORRETA DOS NOMES:
    // - userAnalysis = 1Âª faixa = SUA MÃšSICA (atual)
    // - referenceAnalysis = 2Âª faixa = REFERÃŠNCIA (alvo a alcanÃ§ar)
    const userTrackNormalized = userAnalysis.fileName || userAnalysis.metadata?.fileName || sRef.userTrack || "Sua MÃºsica (Atual)";
    const refTrackNormalized = referenceAnalysis.fileName || referenceAnalysis.metadata?.fileName || sRef.referenceTrack || "Faixa de ReferÃªncia (Alvo)";
    
    // ğŸ” AUDITORIA ANTI-DUPLICAÃ‡ÃƒO: Verificar se as faixas sÃ£o distintas
    log('ğŸ” [AUDIT_REF_MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ” [AUDIT_REF_MODE âœ…] ValidaÃ§Ã£o de faixas distintas:');
    log('ğŸ” [AUDIT_REF_MODE âœ…]   userTrack (SUA MÃšSICA):', userTrackNormalized);
    log('ğŸ” [AUDIT_REF_MODE âœ…]   referenceTrack (REFERÃŠNCIA):', refTrackNormalized);
    log('ğŸ” [AUDIT_REF_MODE âœ…]   SÃ£o idÃªnticas?', userTrackNormalized === refTrackNormalized ? 'âš ï¸ SIM - VERIFICAR FLUXO!' : 'âœ… NÃƒO');
    log('ğŸ” [AUDIT_REF_MODE âœ…]   userAnalysis jobId:', userAnalysis?.jobId);
    log('ğŸ” [AUDIT_REF_MODE âœ…]   referenceAnalysis jobId:', referenceAnalysis?.jobId);
    log('ğŸ” [AUDIT_REF_MODE âœ…]   JobIds idÃªnticos?', userAnalysis?.jobId === referenceAnalysis?.jobId ? 'âš ï¸ SIM - VERIFICAR!' : 'âœ… NÃƒO');
    log('ğŸ” [AUDIT_REF_MODE âœ…] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    if (userTrackNormalized === refTrackNormalized) {
        warn("âš ï¸ [REF-COMP] As duas faixas tÃªm o mesmo nome â€” verifique o fluxo de atribuiÃ§Ã£o!");
        warn("âš ï¸ [REF-COMP] Dados recebidos:", {
            userAnalysis: userAnalysis,
            referenceAnalysis: referenceAnalysis
        });
    }
    
    // Evita leitura em escopos errados - ABORT se referenceTrack undefined
    if (!referenceTrack) {
        error("ğŸš¨ [SAFE_REF_V3] referenceTrack ainda undefined! Abortando render seguro.");
        window.comparisonLock = false;
        log("[LOCK] comparisonLock liberado (referenceTrack undefined)");
        return;
    }
    
    // âœ… LOG PARA CONFIRMAÃ‡ÃƒO FINAL
    log("[REF-COMPARE âœ…] DireÃ§Ã£o correta confirmada: PRIMEIRA = sua mÃºsica (atual), SEGUNDA = referÃªncia (alvo)");
    
    // [AUDIT-FLOW] Log de rastreamento PRÃ‰-EXTRAÃ‡ÃƒO
    log("[AUDIT-FLOW] ğŸ” PRÃ‰-EXTRAÃ‡ÃƒO de bandas:", {
        'analysis.userAnalysis?.bands': analysis.userAnalysis?.bands,
        'opts.userAnalysis?.bands': opts.userAnalysis?.bands,
        'opts.userAnalysis?.technicalData?.spectral_balance': opts.userAnalysis?.technicalData?.spectral_balance,
        'analysis.referenceAnalysis?.bands': analysis.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.bands': opts.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.technicalData?.spectral_balance': opts.referenceAnalysis?.technicalData?.spectral_balance
    });
    
    // âœ… CORREÃ‡ÃƒO V3: ExtraÃ§Ã£o unificada de bandas espectrais (aceita arrays e objetos)
    let userBandsLocal =
        analysis.userAnalysis?.bands ||
        opts.userAnalysis?.bands ||
        opts.userAnalysis?.technicalData?.spectral_balance ||
        analysis.bands ||
        analysis.referenceComparison?.userBands ||
        null;

    let refBandsLocal =
        analysis.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.technicalData?.spectral_balance ||
        analysis.referenceComparison?.refBands ||
        null;
    
    // [AUDIT-FLOW] Log PÃ“S-EXTRAÃ‡ÃƒO
    log("[AUDIT-FLOW] ğŸ” PÃ“S-EXTRAÃ‡ÃƒO de bandas:", {
        userBandsLocal,
        refBandsLocal,
        userBandsLocalType: userBandsLocal ? (Array.isArray(userBandsLocal) ? 'Array' : 'Object') : 'null',
        refBandsLocalType: refBandsLocal ? (Array.isArray(refBandsLocal) ? 'Array' : 'Object') : 'null'
    });
    
    // ï¿½ LOG DE DEBUG: Mostrar o que foi encontrado
    log("[REF-COMP] ğŸ” ExtraÃ§Ã£o inicial de bandas:", {
        userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? `Array(${userBandsLocal.length})` : `Object(${Object.keys(userBandsLocal).length})`) : 'null',
        refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? `Array(${refBandsLocal.length})` : `Object(${Object.keys(refBandsLocal).length})`) : 'null',
        sourceUser: userBandsLocal ? 'encontrado' : 'null',
        sourceRef: refBandsLocal ? 'encontrado' : 'null'
    });

    // âœ… ValidaÃ§Ã£o: Aceitar tanto arrays quanto objetos
    const hasUserBands = userBandsLocal && (
        (Array.isArray(userBandsLocal) && userBandsLocal.length > 0) ||
        (typeof userBandsLocal === 'object' && Object.keys(userBandsLocal).length > 0)
    );
    
    const hasRefBands = refBandsLocal && (
        (Array.isArray(refBandsLocal) && refBandsLocal.length > 0) ||
        (typeof refBandsLocal === 'object' && Object.keys(refBandsLocal).length > 0)
    );

    // ğŸš¨ ProteÃ§Ã£o aprimorada com fallback global
    if (!hasUserBands || !hasRefBands) {
        warn("[REF-COMP] âš ï¸ Bandas ausentes na estrutura principal - tentando fallback global");
        
        const globalUser = window.__soundyState?.previousAnalysis?.bands || 
                          window.__soundyState?.previousAnalysis?.technicalData?.spectral_balance ||
                          window.__soundyState?.userAnalysis?.bands || 
                          null;
        const globalRef = window.__soundyState?.referenceAnalysis?.bands || 
                         window.__soundyState?.referenceAnalysis?.technicalData?.spectral_balance ||
                         window.__soundyState?.reference?.analysis?.bands || 
                         null;
        
        const hasGlobalUser = globalUser && (
            (Array.isArray(globalUser) && globalUser.length > 0) ||
            (typeof globalUser === 'object' && Object.keys(globalUser).length > 0)
        );
        
        const hasGlobalRef = globalRef && (
            (Array.isArray(globalRef) && globalRef.length > 0) ||
            (typeof globalRef === 'object' && Object.keys(globalRef).length > 0)
        );
        
        log("[REF-COMP] ğŸ” Fallback global:", {
            globalUser: globalUser ? (Array.isArray(globalUser) ? `Array(${globalUser.length})` : `Object(${Object.keys(globalUser).length})`) : 'null',
            globalRef: globalRef ? (Array.isArray(globalRef) ? `Array(${globalRef.length})` : `Object(${Object.keys(globalRef).length})`) : 'null',
            hasGlobalUser,
            hasGlobalRef,
            hasPreviousAnalysis: !!window.__soundyState?.previousAnalysis,
            hasReferenceAnalysis: !!window.__soundyState?.referenceAnalysis
        });
        
        if (!hasGlobalUser || !hasGlobalRef) {
            error("[REF-COMP] âŒ Nenhum dado vÃ¡lido encontrado - abortando render");
            console.table({
                userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0,
                refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0,
                globalUser: globalUser ? (Array.isArray(globalUser) ? globalUser.length : Object.keys(globalUser).length) : 0,
                globalRef: globalRef ? (Array.isArray(globalRef) ? globalRef.length : Object.keys(globalRef).length) : 0,
                hasUserAnalysis: !!analysis.userAnalysis,
                hasReferenceAnalysis: !!analysis.referenceAnalysis,
                soundyStateKeys: Object.keys(window.__soundyState || {})
            });
            window.comparisonLock = false;
            log("[LOCK] comparisonLock liberado (sem dados vÃ¡lidos)");
            console.groupEnd();
            return;
        }
        
        // Aplicar fallback
        userBandsLocal = globalUser;
        refBandsLocal = globalRef;
        
        log("[REF-COMP] âœ… Fallback global aplicado com sucesso");
    }

    // Atualizar variÃ¡veis globais
    userBands = userBandsLocal;
    refBands = refBandsLocal;
    
    // ğŸ¯ HOTFIX: Declarar detectedRenderMode ANTES de usar (evitar TDZ)
    const detectedRenderMode = opts.mode || stateV3?.render?.mode || 
                                (stateV3.reference?.isSecondTrack === true ? 'reference' : 'genre');
    
    // ğŸ¯ PATCH CRÃTICO A: Persistir bandas em estrutura canÃ´nica para subscore
    if (detectedRenderMode === 'reference' && userBandsLocal && refBandsLocal) {
        stateV3.reference = stateV3.reference || {};
        stateV3.reference.bands = {
            userBands: userBandsLocal,
            refBands: refBandsLocal
        };
        
        // ğŸ¯ PATCH CRÃTICO C: Compatibilidade - preencher stateV3.reference.analysis.bands
        stateV3.reference.analysis = stateV3.reference.analysis || {};
        stateV3.reference.analysis.bands = refBandsLocal;
        
        window.__soundyState = stateV3;
        
        log('[FREQ-FIX] âœ… Bandas persistidas em stateV3.reference:', {
            userBandsKeys: Object.keys(userBandsLocal),
            refBandsKeys: Object.keys(refBandsLocal),
            stateV3RefBands: !!stateV3.reference.bands,
            stateV3RefAnalysisBands: !!stateV3.reference.analysis.bands
        });
    }
    
    // [AUDIT-FLOW] Log apÃ³s atribuiÃ§Ã£o final
    log("[AUDIT-FLOW] ğŸ” ApÃ³s atribuiÃ§Ã£o final:", {
        userBands,
        refBands,
        userBandsIsValid: !!(userBandsLocal && (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length)),
        refBandsIsValid: !!(refBandsLocal && (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length))
    });
    
    // âœ… LOG FINAL CONSOLIDADO
    const userBandsCount = userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0;
    const refBandsCount = refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0;
    
    log("[REF-COMP] âœ… Bandas detectadas:", {
        userBands: userBandsCount,
        refBands: refBandsCount,
        userBandsType: userBands ? (Array.isArray(userBands) ? 'Array' : 'Object') : 'null',
        refBandsType: refBands ? (Array.isArray(refBands) ? 'Array' : 'Object') : 'null',
        source: hasUserBands && hasRefBands ? 'analysis-principal' : 'fallback-global'
    });
    
    log("âœ… [SAFE_REF_V3] Tracks resolvidas:", { 
        userTrack, 
        referenceTrack, 
        userBands: !!userBands, 
        refBands: !!refBands,
        userBandsCount,
        refBandsCount
    });
    
    // ğŸ§  SAFEGUARD FINAL: VerificaÃ§Ã£o crÃ­tica antes de qualquer renderizaÃ§Ã£o
    if (opts?.mode === "reference") {
        // SAFEGUARD: garantir que spectral_balance exista na estrutura
        if (opts?.referenceAnalysis && !opts?.referenceAnalysis?.technicalData?.spectral_balance) {
            warn("âš ï¸ [SAFEGUARD] spectral_balance ausente em referenceAnalysis â€” aplicando patch.");
            if (!opts.referenceAnalysis.technicalData) opts.referenceAnalysis.technicalData = {};
            opts.referenceAnalysis.technicalData.spectral_balance = refBands;
        }
        
        if (opts?.userAnalysis && !opts?.userAnalysis?.technicalData?.spectral_balance) {
            warn("âš ï¸ [SAFEGUARD] spectral_balance ausente em userAnalysis â€” aplicando patch.");
            if (!opts.userAnalysis.technicalData) opts.userAnalysis.technicalData = {};
            opts.userAnalysis.technicalData.spectral_balance = userBands;
        }
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Fonte da verdade vem do caller - NÃƒO usar fallback 'genre'
    // Reusar stateV3 jÃ¡ declarado no patch V3 acima
    
    // ğŸš¨ PRIORIDADE DE DETECÃ‡ÃƒO DO MODO (sem fallback automÃ¡tico para genre):
    // 1. opts.mode (passado explicitamente pelo caller)
    // 2. stateV3.render.mode (jÃ¡ configurado anteriormente)
    // 3. stateV3.reference.isSecondTrack = true â†’ forÃ§ar 'reference'
    // 4. Ãšltimo recurso: 'genre'
    let explicitMode = opts.mode || stateV3?.render?.mode;
    
    // ğŸ¯ Se segunda faixa estÃ¡ ativa, FORÃ‡AR modo reference
    if (stateV3.reference?.isSecondTrack === true && !explicitMode) {
        explicitMode = 'reference';
        log('ğŸ”¥ [MODE-OVERRIDE] Segunda faixa detectada - forÃ§ando modo reference');
    }
    
    // Fallback final apenas se realmente necessÃ¡rio
    if (!explicitMode) {
        explicitMode = 'genre';
        warn('âš ï¸ [MODE-FALLBACK] Nenhum modo detectado - usando genre como fallback');
    }
    
    const isReferenceMode = (opts?.mode === 'reference') 
        || (stateV3?.render?.mode === 'reference') 
        || (stateV3?.reference?.isSecondTrack === true && !opts?.mode);
    
    if (isReferenceMode) log('[REF-FLOW] renderReferenceComparisons in reference mode');
    
    const isReference = explicitMode === 'reference';
    
    // Salvar modo no estado (NÃƒO sobrescrever se jÃ¡ for reference)
    stateV3.render = stateV3.render || {};
    if (stateV3.render.mode !== 'reference' || explicitMode === 'reference') {
        stateV3.render.mode = explicitMode;
    }
    window.__soundyState = stateV3;
    
    // (Opcional) Log assertivo
    log('[RENDER-REF] MODO SELECIONADO:', explicitMode.toUpperCase());
    log('[ASSERT] mode=', explicitMode, 'isSecondTrack=', stateV3?.reference?.isSecondTrack, 'refJobId=', stateV3?.reference?.jobId);
    log('[ASSERT] opts.mode=', opts.mode, 'stateV3.render.mode=', stateV3.render.mode);
    
    // ğŸš¨ CRÃTICO: NÃƒO reavaliar "se tem ref" para mudar o modo
    // O modo Ã© determinÃ­stico e vem do caller
    let renderMode = explicitMode;
    
    // ğŸ›¡ï¸ [AUDIT-FIX] VALIDAÃ‡ÃƒO CRÃTICA: garantir que renderMode seja vÃ¡lido
    if (renderMode !== 'reference' && renderMode !== 'genre') {
        error('ğŸš¨ [AUDIT-FIX] renderMode INVÃLIDO detectado:', renderMode);
        error('ğŸš¨ [AUDIT-FIX] explicitMode:', explicitMode);
        error('ğŸš¨ [AUDIT-FIX] opts.mode:', opts.mode);
        error('ğŸš¨ [AUDIT-FIX] stateV3.render.mode:', stateV3?.render?.mode);
        
        // Tentar recuperar modo correto
        if (opts.mode === 'reference' || stateV3?.render?.mode === 'reference' || stateV3?.reference?.isSecondTrack) {
            renderMode = 'reference';
            warn('âš ï¸ [AUDIT-FIX] ForÃ§ando renderMode = "reference"');
        } else {
            renderMode = 'genre';
            warn('âš ï¸ [AUDIT-FIX] ForÃ§ando renderMode = "genre" (fallback)');
        }
    }
    
    log('ğŸ“Š [AUDIT-FIX] renderMode VALIDADO:', renderMode, '(vÃ¡lido:', renderMode === 'reference' || renderMode === 'genre', ')');
    
    // ğŸ¯ PATCH 5: Asserts de validaÃ§Ã£o de modo (NÃƒO ABORTAM, apenas logam)
    if (renderMode === 'reference') {
        if (!stateV3?.reference?.analysis?.bands) {
            warn('âš ï¸ [ASSERT-MAIN] Modo reference sem stateV3.reference.analysis.bands - pode usar fallback');
        }
        if (!stateV3?.reference?.isSecondTrack) {
            warn('âš ï¸ [ASSERT-MAIN] Modo reference sem flag isSecondTrack');
        }
        if (!stateV3?.reference?.analysis) {
            warn('âš ï¸ [CRITICAL] Modo reference configurado mas sem dados de referÃªncia no stateV3!');
            warn('âš ï¸ stateV3.reference:', stateV3?.reference);
        }
    } else if (renderMode === 'genre') {
        if (!window.__activeRefData?.bands) {
            warn('âš ï¸ [ASSERT-MAIN] Modo genre sem __activeRefData.bands - tentando fallback');
            warn('âš ï¸ __activeRefData:', window.__activeRefData);
        }
    }
    log('âœ… [PATCH-5] Asserts de modo executados:', { renderMode, hasRefBands: !!(stateV3?.reference?.analysis?.bands), hasGenreBands: !!(window.__activeRefData?.bands) });
    
    // ğŸš¨ REMOVIDO: DetecÃ§Ã£o legacy automÃ¡tica (causava auto-switch indevido)
    // O modo agora Ã© determinÃ­stico e vem do caller via opts.mode
    // NÃƒO tentar "adivinhar" o modo baseado em analysis.mode ou estruturas
    
    // ğŸ¯ CORREÃ‡ÃƒO: Definir hasNewStructure e hasOldStructure ANTES de usar
    const hasNewStructure = !!(analysis?.referenceAnalysis?.technicalData || analysis?.metrics);
    const hasOldStructure = !!(analysis?.referenceComparison && !hasNewStructure);
    
    let ref, titleText, userMetrics;
    
    // ğŸ” [AUDITORIA_REF] Log de detecÃ§Ã£o crÃ­tica
    log('[AUDITORIA_REF] DetecÃ§Ã£o de modo:', {
        'analysis.mode': analysis.mode,
        'isReferenceMode': isReferenceMode,
        'hasNewStructure': hasNewStructure,
        'hasOldStructure': hasOldStructure,
        'window.__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
        'referenceAnalysisData': !!window.referenceAnalysisData
    });
    
    // ğŸ¯ USAR renderMode PARA DECIDIR O FLUXO (nÃ£o isReferenceMode)
    if (renderMode === 'reference') {
        log('[AUDITORIA_REF] Modo referÃªncia detectado â€“ exibindo comparaÃ§Ã£o A/B entre faixas');
        
        // ğŸ”¥ PRIORIDADE MÃXIMA: Usar nova estrutura corrigida (userAnalysis/referenceAnalysis)
        if (opts.userAnalysis && opts.referenceAnalysis) {
            log('ğŸ”¥ [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('ğŸ”¥ [REF-CORRECTED] Usando estrutura corrigida: opts.userAnalysis + opts.referenceAnalysis');
            log('ğŸ”¥ [REF-CORRECTED] userAnalysis existe:', !!opts.userAnalysis);
            log('ğŸ”¥ [REF-CORRECTED] referenceAnalysis existe:', !!opts.referenceAnalysis);
            log('ğŸ”¥ [REF-CORRECTED] userAnalysis.technicalData:', !!opts.userAnalysis.technicalData);
            log('ğŸ”¥ [REF-CORRECTED] referenceAnalysis.technicalData:', !!opts.referenceAnalysis.technicalData);
            log('ğŸ”¥ [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            const userTech = opts.userAnalysis.technicalData || {};
            const refTech = opts.referenceAnalysis.technicalData || {};
            
            // ğŸ” DIAGNÃ“STICO: Verificar estrutura das bandas
            log('ğŸ” [DIAGNÃ“STICO] userTech.spectral_balance:', userTech.spectral_balance);
            log('ğŸ” [DIAGNÃ“STICO] refTech.spectral_balance:', refTech.spectral_balance);
            log('ğŸ” [DIAGNÃ“STICO] userTech.bandEnergies:', userTech.bandEnergies);
            log('ğŸ” [DIAGNÃ“STICO] refTech.bandEnergies:', refTech.bandEnergies);
            log('ğŸ” [DIAGNÃ“STICO] userTech.bands:', userTech.bands);
            log('ğŸ” [DIAGNÃ“STICO] refTech.bands:', refTech.bands);
            
            userMetrics = userTech;
            ref = {
                // Valores BRUTOS da segunda faixa (referÃªncia/alvo)
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.spectral_balance ?? refTech.bandEnergies ?? refTech.bands ?? null
            };
            
            // ğŸ¯ SEMÃ‚NTICA CORRETA NO TÃTULO:
            // 1Âª faixa = sua mÃºsica (atual) | 2Âª faixa = referÃªncia (alvo)
            const userFileName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || 'Sua MÃºsica';
            const refFileName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || 'ReferÃªncia';
            titleText = `ï¿½ ComparaÃ§Ã£o da sua faixa com a referÃªncia:\nAtual: ${userFileName}\nReferÃªncia: ${refFileName}`;
            
            log('âœ… [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('âœ… [REF-CORRECTED] Dados A/B extraÃ­dos corretamente:');
            log('âœ… [REF-CORRECTED]   SUA MÃšSICA (1Âª):', opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName);
            log('âœ… [REF-CORRECTED]   Bandas:', Object.keys(userMetrics.spectral_balance || {}));
            log('âœ… [REF-CORRECTED]   LUFS:', userMetrics.lufsIntegrated);
            log('âœ… [REF-CORRECTED]   REFERÃŠNCIA (2Âª):', opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName);
            log('âœ… [REF-CORRECTED]   Bandas:', Object.keys(ref.bands || {}));
            log('âœ… [REF-CORRECTED]   LUFS:', ref.lufs_target);
            log('âœ… [REF-CORRECTED]   Tabela: ESQUERDA=sua mÃºsica, DIREITA=referÃªncia');
            log('âœ… [REF-CORRECTED] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // ğŸ¯ LOG ASSERT_REF_FLOW
            log("[ASSERT_REF_FLOW âœ…]", {
                mode: 'reference',
                userTrack: opts.userAnalysis?.fileName || opts.userAnalysis?.metadata?.fileName,
                referenceTrack: opts.referenceAnalysis?.fileName || opts.referenceAnalysis?.metadata?.fileName,
                userBands: Object.keys(userMetrics.spectral_balance || {}),
                refBands: Object.keys(ref.bands || {}),
                userLUFS: userMetrics.lufsIntegrated,
                refLUFS: ref.lufs_target
            });
        }
        // ğŸ¯ PRIORIDADE 0 (FALLBACK): analysis.referenceAnalysis (estrutura antiga)
        else if (analysis.referenceAnalysis && analysis.referenceAnalysis.technicalData) {
            log('âœ… [REF-COMP] Usando real reference analysis as target (primeira faixa)');
            
            const refTech = analysis.referenceAnalysis.technicalData;
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.bandEnergies ?? refTech.spectral_balance ?? refTech.bands ?? null
            };
            
            titleText = `ğŸµ ${analysis.referenceAnalysis.fileName || analysis.referenceAnalysis.metadata?.fileName || 'Faixa Base'}`;
            
            log('ğŸ“Š [REF-COMP] baseBands/refBands resolved from referenceAnalysis:', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                hasBands: !!ref.bands,
                bandsKeys: ref.bands ? Object.keys(ref.bands) : []
            });
            log('âœ… [REF-COMP] Using real reference analysis as target');
        }
        // ğŸ¯ PRIORIDADE 1 (FALLBACK): analysis.referenceBands (estrutura centralizada)
        else if (analysis.referenceBands && analysis.mode === 'reference') {
            log('âœ… [RENDER-REF] Usando analysis.referenceBands (estrutura centralizada)');
            
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: analysis.referenceBands.lufsIntegrated || analysis.referenceBands.lufs_integrated,
                true_peak_target: analysis.referenceBands.truePeakDbtp || analysis.referenceBands.true_peak_dbtp,
                dr_target: analysis.referenceBands.dynamicRange || analysis.referenceBands.dynamic_range,
                lra_target: analysis.referenceBands.lra,
                stereo_target: analysis.referenceBands.stereoCorrelation || analysis.referenceBands.stereo_correlation,
                stereo_width_target: analysis.referenceBands.stereoWidth || analysis.referenceBands.stereo_width,
                spectral_centroid_target: analysis.referenceBands.spectralCentroidHz || analysis.referenceBands.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: analysis.referenceBands.spectral_balance || analysis.referenceBands.bands || null
            };
            
            titleText = `ğŸµ Faixa de ReferÃªncia`;
            
            log('ğŸ“Š [RENDER-REF] ReferÃªncia (referenceBands):', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: ref.bands
            });
        }
        // ===== PRIORIDADE 2: NOVA ESTRUTURA (userTrack/referenceTrack) =====
        else if (hasNewStructure) {
            // ğŸ§  [PATCH V4] REFERENCE SCOPE LOCK FIX - Estabilizar escopo antes de render
            try {
                console.groupCollapsed("ğŸ§  [REF_SCOPE_LOCK]");
                log("ğŸ“¦ Contexto atual antes do render:", { opts, stateV3 });

                // ğŸ”’ Buscar dados de comparaÃ§Ã£o em todos os escopos possÃ­veis
                let comparisonLock =
                    opts?.comparisonData ||
                    window?.lastComparisonData ||
                    stateV3?.reference?.comparisonData ||
                    {
                        userTrack:
                            opts?.userAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                            "Faixa do UsuÃ¡rio",
                        referenceTrack:
                            opts?.referenceAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                            "Faixa de ReferÃªncia",
                        userBands:
                            opts?.userAnalysis?.bands ||
                            stateV3?.reference?.userAnalysis?.bands ||
                            {},
                        refBands:
                            opts?.referenceAnalysis?.bands ||
                            stateV3?.reference?.referenceAnalysis?.bands ||
                            {},
                    };

                // ğŸ” Corrigir se ainda estiver faltando algo
                if (!comparisonLock.referenceTrack) {
                    comparisonLock.referenceTrack =
                        opts?.referenceAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                        "Faixa de ReferÃªncia";
                }
                if (!comparisonLock.userTrack) {
                    comparisonLock.userTrack =
                        opts?.userAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                        "Faixa do UsuÃ¡rio";
                }

                // ğŸ”’ Salvar globalmente para persistir escopo
                window.lastComparisonData = comparisonLock;

                log("âœ… [REF_SCOPE_LOCK] Estrutura estabilizada:", comparisonLock);
                console.groupEnd();

                // ğŸ§© Reatribuir variÃ¡veis seguras locais
                const userTrackLock = comparisonLock.userTrack;
                const referenceTrackLock = comparisonLock.referenceTrack;
                const userBandsLock = comparisonLock.userBands;
                const refBandsLock = comparisonLock.refBands;

                // Se ainda nÃ£o tiver bandas, abortar render seguro
                if (!refBandsLock || Object.keys(refBandsLock).length === 0) {
                    error(
                        "ğŸš¨ [REF_SCOPE_LOCK] refBands ausente, abortando renderizaÃ§Ã£o segura."
                    );
                    window.__REF_RENDER_LOCK__ = false;
                    window.comparisonLock = false;
                    log("[LOCK] comparisonLock liberado (refBands ausente)");
                    return;
                }

                // âœ… Reaplicar no escopo principal
                opts.comparisonData = comparisonLock;
                window.comparisonData = comparisonLock;
            } catch (err) {
                error("ğŸ’¥ [REF_SCOPE_LOCK] Erro crÃ­tico ao reestabelecer escopo:", err);
                window.comparisonLock = false;
                log("[LOCK] comparisonLock liberado (erro escopo)");
                return;
            }
            
            log('âœ… [RENDER-REF] Usando NOVA estrutura (userTrack/referenceTrack)');
            
            // ğŸ§© Fix final do modal A/B - usar dados corretos de comparisonLock
            const refFile = 
                comparisonLock?.refFile ||
                comparisonLock?.referenceTrack ||
                opts?.referenceAnalysis?.fileName ||
                opts?.referenceAnalysis?.metadata?.fileName ||
                stateV3?.reference?.referenceAnalysis?.fileName ||
                "Faixa de referÃªncia";

            const userFile = 
                comparisonLock?.userFile ||
                comparisonLock?.userTrack ||
                opts?.userAnalysis?.fileName ||
                opts?.userAnalysis?.metadata?.fileName ||
                stateV3?.reference?.userAnalysis?.fileName ||
                "Faixa do usuÃ¡rio";

            log("[REF-FIX-FINAL] referenceTrackName resolvido:", refFile);
            log("[REF-FIX-FINAL] userTrackName resolvido:", userFile);
            
            // Extrair mÃ©tricas de opts ou stateV3
            const refAnalysis = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
            const userAnalysisData = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
            
            if (!refAnalysis || !userAnalysisData) {
                error("ğŸ’¥ [REF-FIX-FINAL] AnÃ¡lises nÃ£o encontradas, abortando");
                window.comparisonLock = false;
                log("[LOCK] comparisonLock liberado (anÃ¡lises nÃ£o encontradas)");
                return;
            }
            
            const refMetrics = refAnalysis.metrics || refAnalysis;
            userMetrics = userAnalysisData.metrics || userAnalysisData;
            
            ref = {
                lufs_target: refMetrics.lufs || refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.peak || refMetrics.truePeakDbtp,
                dr_target: refMetrics.dr || refMetrics.dynamicRange,
                lra_target: refMetrics.lra,
                stereo_target: refMetrics.stereoCorrelation,
                stereo_width_target: refMetrics.stereoWidth,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refAnalysis.bands || comparisonLock?.refBands || {}
            };
            
            titleText = `ğŸµ ${refFile}`;
            
            log('ğŸ“Š [RENDER-REF] ReferÃªncia:', {
                fileName: refFile,
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: Object.keys(ref.bands || {}).length
            });
            log('ğŸ“Š [RENDER-REF] UsuÃ¡rio:', {
                fileName: userFile,
                lufs: userMetrics.lufs || userMetrics.lufsIntegrated,
                dr: userMetrics.dr || userMetrics.dynamicRange
            });
        }
        // ===== ESTRUTURA ANTIGA (retrocompatibilidade) =====
        else if (hasOldStructure) {
            log('âš ï¸ [RENDER-REF] Usando estrutura ANTIGA (referenceMetrics) - considerar migraÃ§Ã£o');
            
            const refMetrics = analysis.referenceComparison.referenceMetrics;
            ref = {
                lufs_target: refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.truePeakDbtp,
                dr_target: refMetrics.dynamicRange,
                lra_target: refMetrics.lra || 6,
                stereo_target: refMetrics.stereoCorrelation,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: null
            };
            titleText = "ğŸµ Faixa de ReferÃªncia";
            
            log('ğŸ¯ [RENDER-REF] Usando mÃ©tricas de referÃªncia real:', refMetrics);
        }
    } else if (renderMode === 'genre') {
        // ===== MODO GÃŠNERO =====
        // ğŸ¯ SÃ“ LOGA "MODO GÃŠNERO" SE REALMENTE FOR GENRE
        log('ğŸµ [RENDER-REF] MODO GÃŠNERO');
        
        // ğŸ¯ LOG DE VERIFICAÃ‡ÃƒO: Garantir que targets de gÃªnero sejam usados
        log('[TARGET-RESOLVE] Modo GENRE confirmado - buscando targets de gÃªnero:', {
            hasWindowActiveRefData: !!window.__activeRefData,
            hasProdAiRefData: !!window.PROD_AI_REF_DATA,
            genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
        });
        
        // ğŸ¯ CORREÃ‡ÃƒO: Fallback seguro para __activeRefData com mÃºltiplas tentativas
        let __activeRefData = window.__activeRefData;
        
        // Tentativa 1: Usar dados globais
        if (!__activeRefData || !__activeRefData.bands) {
            warn('âš ï¸ [GENRE-MODE] __activeRefData nÃ£o disponÃ­vel, tentando PROD_AI_REF_DATA...');
            __activeRefData = window.PROD_AI_REF_DATA;
        }
        
        // Tentativa 2: Usar dados do analysis
        if (!__activeRefData || !__activeRefData.bands) {
            warn('âš ï¸ [GENRE-MODE] PROD_AI_REF_DATA nÃ£o disponÃ­vel, tentando analysis...');
            __activeRefData = analysis?.referenceComparison 
                || analysis?.genreTargets 
                || state?.genreTargets;
        }
        
        // Tentativa 3: Criar estrutura mÃ­nima
        if (!__activeRefData || !__activeRefData.bands) {
            error('âŒ [GENRE-MODE] NENHUMA FONTE DE DADOS DE GÃŠNERO ENCONTRADA!');
            error('âŒ Debug:', {
                hasWindowActiveRefData: !!window.__activeRefData,
                hasProdAiRefData: !!window.PROD_AI_REF_DATA,
                hasAnalysisRefComparison: !!analysis?.referenceComparison,
                genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
            });
            
            container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;opacity:.6">
                <strong style="color:#ff6b6b;">âš ï¸ ReferÃªncias de gÃªnero nÃ£o carregadas</strong><br>
                <span style="font-size:11px;">Tente recarregar a pÃ¡gina ou selecionar outro gÃªnero</span>
            </div>`; 
            return; 
        }
        
        // ğŸš¨ CORREÃ‡ÃƒO CRÃTICA: NÃƒO usar referenceComparisonMetrics no modo genre
        // Apenas usar targets de gÃªnero
        ref = __activeRefData;
        titleText = window.PROD_AI_REF_GENRE || window.__activeRefGenre || 'GÃªnero Musical';
        userMetrics = analysis.technicalData || {};
        
        log('âœ… [GENRE-MODE] Usando targets de gÃªnero:', {
            genre: titleText,
            hasBands: !!ref.bands,
            bandsCount: ref.bands ? Object.keys(ref.bands).length : 0,
            bandsList: ref.bands ? Object.keys(ref.bands) : [],
            source: window.__activeRefData ? 'window.__activeRefData' : (window.PROD_AI_REF_DATA ? 'PROD_AI_REF_DATA' : 'analysis')
        });
    } else {
        // ğŸ›¡ï¸ [AUDIT-FIX] FALLBACK SEGURO: nÃ£o destruir conteÃºdo vÃ¡lido existente
        error('ğŸš¨ [AUDIT-FIX] MODO INDETERMINADO - renderMode:', renderMode);
        error('ğŸš¨ [AUDIT-FIX] Dados de diagnÃ³stico:', {
            explicitMode,
            'opts.mode': opts.mode,
            'stateV3.render.mode': stateV3?.render?.mode,
            'stateV3.reference.isSecondTrack': stateV3?.reference?.isSecondTrack,
            'container.innerHTML.length': container.innerHTML.length,
            'containerHasTable': !!container.querySelector('table')
        });
        
        // NÃ£o sobrescrever se container jÃ¡ tem tabela vÃ¡lida
        const hasExistingTable = container.querySelector('table');
        if (hasExistingTable) {
            warn('âš ï¸ [AUDIT-FIX] Container jÃ¡ tem tabela vÃ¡lida - preservando conteÃºdo');
            return;
        }
        
        // Se nÃ£o tem tabela, mostrar erro mas sem quebrar modal
        container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;background:rgba(255,165,0,.1);border:1px solid rgba(255,165,0,.3);">
            <strong style="color:#ffa500;">âš ï¸ Erro de configuraÃ§Ã£o</strong><br>
            <span style="font-size:11px;color:#ffb366;">Modo de anÃ¡lise nÃ£o identificado (renderMode: ${renderMode})</span><br>
            <span style="font-size:10px;color:#888;margin-top:8px;display:block;">Por favor, recarregue a pÃ¡gina ou tente novamente.</span>
        </div>`;
        return;
    }
    
    // ğŸ¯ SOBRESCREVER com referenceComparisonMetrics APENAS se modo for 'reference'
    if (renderMode === 'reference' && referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        log('ğŸ¯ [RENDER-REF] MODO REFERÃŠNCIA â€” COMPARAÃ‡ÃƒO ENTRE FAIXAS ATIVADA');
        log('âœ… [RENDER-REF] Sobrescrevendo com referenceComparisonMetrics');
        
        const targetMetrics = referenceComparisonMetrics.reference;
        userMetrics = referenceComparisonMetrics.user;
        
        ref = {
            lufs_target: targetMetrics.lufsIntegrated || targetMetrics.lufs_integrated,
            true_peak_target: targetMetrics.truePeakDbtp || targetMetrics.true_peak_dbtp,
            dr_target: targetMetrics.dynamicRange || targetMetrics.dynamic_range,
            lra_target: targetMetrics.lra,
            stereo_target: targetMetrics.stereoCorrelation || targetMetrics.stereo_correlation,
            stereo_width_target: targetMetrics.stereoWidth || targetMetrics.stereo_width,
            spectral_centroid_target: targetMetrics.spectralCentroidHz || targetMetrics.spectral_centroid,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300,
            bands: targetMetrics.spectral_balance || null
        };
        
        // ğŸ¯ SEMÃ‚NTICA CORRETA: referenceFull = 2Âª faixa (referÃªncia/alvo)
        const userFileName = referenceComparisonMetrics.userFull?.metadata?.fileName || referenceComparisonMetrics.userFull?.fileName || 'Sua MÃºsica';
        const refFileName = referenceComparisonMetrics.referenceFull?.metadata?.fileName || referenceComparisonMetrics.referenceFull?.fileName || 'ReferÃªncia';
        titleText = `ğŸ§ ComparaÃ§Ã£o da sua faixa com a referÃªncia:\nAtual: ${userFileName}\nReferÃªncia: ${refFileName}`;
        
        // ğŸ¯ ASSERT CRÃTICO: Verificar se bands estÃ£o disponÃ­veis no modo reference
        log('[ASSERT_REF_DATA]', ref.bands ? 'âœ… Reference bands loaded' : 'âŒ Missing bands');
        if (!ref.bands) {
            error('ğŸš¨ [CRITICAL] Modo reference sem bandas! Bloqueando fallback de gÃªnero.');
            error('ğŸš¨ Debug:', {
                hasTargetMetrics: !!targetMetrics,
                targetMetricsKeys: targetMetrics ? Object.keys(targetMetrics) : [],
                hasSpectralBalance: !!targetMetrics?.spectral_balance,
                hasReferenceComparisonMetrics: !!referenceComparisonMetrics,
                referenceFullKeys: referenceComparisonMetrics.referenceFull ? Object.keys(referenceComparisonMetrics.referenceFull) : []
            });
        }
    } else if (renderMode === 'genre' && referenceComparisonMetrics) {
        // ğŸš¨ LOG DE SEGURANÃ‡A: Confirmar que modo genre NÃƒO usa referenceComparisonMetrics
        log('âœ… [GENRE-MODE] referenceComparisonMetrics IGNORADO no modo gÃªnero (correto)');
    }
    
    // ğŸ¯ Priorizar userMetrics (nova estrutura) sobre technicalData (legado)
    const tech = userMetrics || analysis.technicalData || {};
    
    log('ğŸ“Š [RENDER-REF] Fonte de mÃ©tricas do usuÃ¡rio:', userMetrics ? 'userMetrics (nova estrutura)' : 'technicalData (legado)');
    log('ğŸ“Š [RENDER-REF] Modo final confirmado:', renderMode);
    log('ğŸ“Š [RENDER-REF] ref.bands disponÃ­vel:', !!ref?.bands, 'keys:', ref?.bands ? Object.keys(ref.bands).length : 0);
    
    // Mapeamento de mÃ©tricas - RESTAURAR TABELA COMPLETA
    const rows = [];
    const addedLabels = new Set(); // ğŸ¯ Controle de duplicaÃ§Ã£o por nome
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
    const pushRow = (label, val, target, tol, unit='') => {
        // âœ… Epsilon para comparaÃ§Ãµes float precisas
        const EPS = 1e-6;
        
        // ğŸ¯ PREVENÃ‡ÃƒO DE DUPLICATAS: evitar bandas com mesmo nome
        if (addedLabels.has(label)) {
            warn(`âš ï¸ Duplicata evitada: ${label}`);
            return;
        }
        addedLabels.add(label);
        // Usar sistema de enhancement se disponÃ­vel
        const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
            ? window.enhanceRowLabel(label, label.toLowerCase().replace(/[^a-z]/g, '')) 
            : label;
            
        // Tratar target null ou NaN como N/A explicitamente
        const targetIsNA = (target == null || target === '' || (typeof target==='number' && !Number.isFinite(target)));
        if (!Number.isFinite(val) && targetIsNA) return; // nada Ãºtil
        if (targetIsNA) {
            rows.push(`<tr>
                <td>${enhancedLabel}</td>
                <td>${Number.isFinite(val)?nf(val)+unit:'â€”'}</td>
                <td colspan="2" style="opacity:.55">N/A</td>
            </tr>`);
            return;
        }
        // ğŸ¯ CORRIGIDO: CÃ¡lculo de diferenÃ§a usando centerOfRange para ranges
        let diff = null;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max) && Number.isFinite(val)) {
            // Target Ã© um range: usar centro do range para cÃ¡lculo de delta
            const targetForDelta = centerOfRange(target);
            if (typeof targetForDelta === 'number' && Number.isFinite(targetForDelta)) {
                diff = val - targetForDelta;
            } else {
                // Fallback: distÃ¢ncia para o range
                const minNorm = Math.min(target.min, target.max);
                const maxNorm = Math.max(target.min, target.max);
                
                if (val >= minNorm - EPS && val <= maxNorm + EPS) {
                    diff = 0; // Dentro do range
                } else if (val < minNorm) {
                    diff = val - minNorm;
                } else {
                    diff = val - maxNorm;
                }
            }
        } else if (Number.isFinite(val) && Number.isFinite(target)) {
            // Target fixo: diferenÃ§a tradicional
            diff = val - target;
        } else {
            // ğŸ¯ Sem crash se target nÃ£o for vÃ¡lido
            diff = null;
        }
        
        // âœ… Sistema de 3 cores com epsilon
        let diffCell;
        if (!Number.isFinite(diff)) {
            // Sem dados vÃ¡lidos â†’ vermelho
            diffCell = '<td class="warn" style="text-align: center; padding: 8px;"><div style="font-size: 12px; font-weight: 600;">Corrigir</div></td>';
        } else if (tol === 0) {
            // LÃ³gica para bandas espectrais (tol=0)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= EPS) {
                // âœ… DENTRO DO RANGE â†’ Verde
                cssClass = 'ok';
                statusText = 'Ideal';
            } else if (absDiff <= 1.0 + EPS) {
                // âš ï¸ Fora por atÃ© 1dB â†’ Amarelo
                cssClass = 'yellow';
                statusText = 'Ajuste leve';
            } else if (absDiff <= 3.0 + EPS) {
                // âš ï¸ Fora por atÃ© 3dB â†’ Amarelo (era laranja)
                cssClass = 'yellow';
                statusText = 'Ajustar';
            } else {
                // âŒ Fora por >3dB â†’ Vermelho
                cssClass = 'warn';
                statusText = 'Corrigir';
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else if (!Number.isFinite(tol) || tol < 0) {
            // Fallback: tolerÃ¢ncia padrÃ£o com epsilon
            const defaultTol = 1.0;
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            warn(`âš ï¸ [TOLERANCE_FALLBACK] MÃ©trica "${label}" sem tolerÃ¢ncia vÃ¡lida (tol=${tol}). Usando tolerÃ¢ncia padrÃ£o: ${defaultTol}`);
            
            if (absDiff <= defaultTol + EPS) {
                // âœ… ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / defaultTol;
                if (multiplicador <= 2 + EPS) {
                    // âš ï¸ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // âŒ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else {
            // LÃ³gica padrÃ£o com epsilon (LUFS, TP, DR, etc.)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= tol + EPS) {
                // âœ… ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / tol;
                if (multiplicador <= 2 + EPS) {
                    // âš ï¸ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // âŒ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        }
        
        // ğŸ¯ NOVO: RenderizaÃ§Ã£o hÃ­brida para targets fixos e ranges
        let targetDisplay;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max)) {
            // Target Ã© um range: exibir "min dB a max dB"
            targetDisplay = `${nf(target.min)}${unit} a ${nf(target.max)}${unit}`;
        } else if (Number.isFinite(target)) {
            // Target Ã© um valor fixo: exibir "valor dB"
            targetDisplay = `${nf(target)}${unit}`;
        } else {
            // Target nÃ£o definido
            targetDisplay = 'N/A';
        }
        
        // Adicionar tolerÃ¢ncia se disponÃ­vel (apenas para targets fixos)
        const tolDisplay = (typeof target !== 'object' && tol != null) ? 
            `<span class="tol">Â±${nf(tol,2)}</span>` : '';
        
        rows.push(`<tr>
            <td>${enhancedLabel}</td>
            <td>${Number.isFinite(val)?nf(val)+unit:'â€”'}</td>
            <td>${targetDisplay}${tolDisplay}</td>
            ${diffCell}
        </tr>`);
    };
    // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ã£o de acesso para comparaÃ§Ã£o por referÃªncia
    const getMetricForRef = (metricPath, fallbackPath = null) => {
        // Prioridade: analysis.metrics > tech (technicalData) > fallback
        const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
        if (Number.isFinite(centralizedValue)) {
            // Log temporÃ¡rio para validaÃ§Ã£o
            if (typeof window !== 'undefined' && window.METRICS_REF_VALIDATION !== false) {
                const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
                if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                    warn(`ğŸ¯ REF_METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                }
            }
            return centralizedValue;
        }
        
        // Fallback para technicalData legado
        const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
        return Number.isFinite(legacyValue) ? legacyValue : null;
    };
    
    const getNestedValue = (obj, path) => {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    };
    
    // ğŸ¯ CENTRALIZAÃ‡ÃƒO DAS MÃ‰TRICAS - FunÃ§Ã£o de acesso para comparaÃ§Ã£o por referÃªncia
    // Usar somente mÃ©tricas reais (sem fallback para RMS/Peak, que tÃªm unidades e conceitos distintos)
    // FunÃ§Ã£o para obter o valor LUFS integrado usando mÃ©tricas centralizadas
    const getLufsIntegratedValue = () => {
        return getMetricForRef('lufs_integrated', 'lufsIntegrated');
    };
    
    // ğŸ§  NOVA PROTEÃ‡ÃƒO UNIVERSAL â€” Usa resolveTargetMetric para buscar referÃªncia real > gÃªnero
    const lufsTarget = resolveTargetMetric(analysis, "lufsIntegrated", -14);
    const tpTarget = resolveTargetMetric(analysis, "truePeakDbtp", -1);
    const drTarget = resolveTargetMetric(analysis, "dynamicRange", 8);
    const lraTarget = resolveTargetMetric(analysis, "lra", 6);
    const stereoTarget = resolveTargetMetric(analysis, "stereoCorrelation", 0.1);
    const spectralTarget = resolveTargetMetric(analysis, "spectralCentroidHz", null);
    
    // TolerÃ¢ncias ainda vÃªm de ref (ou padrÃ£o)
    const tolLufs = (ref && ref.tol_lufs !== undefined) ? ref.tol_lufs : 0.5;
    const tolTp = (ref && ref.tol_true_peak !== undefined) ? ref.tol_true_peak : 0.3;
    const tolDr = (ref && ref.tol_dr !== undefined) ? ref.tol_dr : 1.0;
    const tolLra = (ref && ref.tol_lra !== undefined) ? ref.tol_lra : 1.0;
    const tolStereo = (ref && ref.tol_stereo !== undefined) ? ref.tol_stereo : 0.08;
    const tolSpectral = (ref && ref.tol_spectral !== undefined) ? ref.tol_spectral : 300;
    
    log('ğŸ§  [RESOLVE-TARGETS] Targets universais resolvidos:', { 
        lufsTarget, tpTarget, drTarget, lraTarget, stereoTarget, spectralTarget 
    });
    
    // ADICIONAR TODAS AS MÃ‰TRICAS PRINCIPAIS
    pushRow('Loudness Integrado (LUFS)', getLufsIntegratedValue(), lufsTarget, tolLufs, ' LUFS');
    pushRow('Pico Real (dBTP)', getMetricForRef('true_peak_dbtp', 'truePeakDbtp'), tpTarget, tolTp, ' dBTP');
    pushRow('DR', getMetricForRef('dynamic_range', 'dynamicRange'), drTarget, tolDr, '');
    pushRow('Faixa de Loudness â€“ LRA (LU)', getMetricForRef('lra'), lraTarget, tolLra, ' LU');
    pushRow('Stereo Corr.', getMetricForRef('stereo_correlation', 'stereoCorrelation'), stereoTarget, tolStereo, '');
    
    // ğŸ¯ ADICIONAR SPECTRAL CENTROID SE MODO REFERÃŠNCIA (usa resolveTargetMetric)
    if (isReferenceMode && spectralTarget !== null) {
        pushRow('Centro Espectral (Hz)', getMetricForRef('spectral_centroid', 'spectralCentroidHz'), 
                spectralTarget, tolSpectral, ' Hz');
    }
    
    // Bandas detalhadas Fase 2: usar mÃ©tricas centralizadas para bandas
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = tech.bandEnergies || null;
    
    // ğŸ” DEBUG: Verificar estado das bandas e mapeamento
    log('ğŸ” [DEBUG_BANDS] Verificando bandas espectrais:', {
        MODE: renderMode.toUpperCase(),
        MODE_SOURCE: renderMode === 'genre' ? 'GENRE TARGETS' : 'REFERENCE ANALYSIS',
        hasCentralizedBands: !!centralizedBands,
        centralizedBandsKeys: centralizedBands ? Object.keys(centralizedBands) : [],
        hasLegacyBands: !!legacyBandEnergies,
        legacyBandsKeys: legacyBandEnergies ? Object.keys(legacyBandEnergies) : [],
        hasRefBands: !!ref.bands,
        refBandsKeys: ref.bands ? Object.keys(ref.bands) : [],
        refBandsSource: renderMode === 'genre' ? 'FROM __activeRefData (genre)' : 'FROM referenceAnalysis or referenceComparisonMetrics'
    });
    
    // ğŸ¯ MAPEAMENTO CORRIGIDO: Bandas Calculadas â†’ Bandas de ReferÃªncia
    const bandMappingCalcToRef = {
        // Banda calculada: chave na referÃªncia
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid', 
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho',
        // VariaÃ§Ãµes adicionais
        'low_bass': 'low_bass',
        'low_mid': 'low_mid',
        'high_mid': 'high_mid',
        'presenca': 'presenca',
        'brilho': 'brilho'
    };
    
    // ğŸ¯ MAPEAMENTO REVERSO: Bandas de ReferÃªncia â†’ Bandas Calculadas
    const bandMappingRefToCalc = {
        'sub': 'sub',
        'low_bass': 'bass',
        'upper_bass': 'bass', // ğŸ¯ NOVO: upper_bass â†’ bass
        'low_mid': 'lowMid',
        'mid': 'mid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // ğŸ¯ ALIAS DE BANDAS: Nomes alternativos para busca
    const bandAliases = {
        'bass': ['low_bass', 'upper_bass'],
        'lowMid': ['low_mid'],
        'highMid': ['high_mid'],
        'presence': ['presenca'],
        'air': ['brilho']
    };
    
    // ğŸ¯ NOVA LÃ“GICA: Priorizar bandas da nova estrutura em modo reference
    let bandsToUse, referenceBands;
    
    if (isReferenceMode && hasNewStructure && ref.bands) {
        // Usar bandas da referenceTrack.metrics.spectral_balance
        log('âœ… [RENDER-BANDS] Usando bandas da NOVA estrutura (referenceTrack)');
        referenceBands = ref.bands;
        bandsToUse = tech.spectral_balance || centralizedBands || legacyBandEnergies;
    } else {
        // Modo legado ou gÃªnero
        bandsToUse = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
        referenceBands = isReferenceMode && analysis.referenceComparison?.comparison?.spectralBands;
    }
    
    // ğŸ¯ RENDERIZAÃ‡ÃƒO DE BANDAS EM MODO REFERENCE
    if (isReferenceMode && hasNewStructure && ref.bands && bandsToUse) {
        log('âœ… [RENDER-REF-BANDS] Renderizando bandas com NOVA estrutura');
        
        const bandNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)',
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)'
        };
        
        // Iterar pelas bandas padrÃ£o
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            // Pegar valores do usuÃ¡rio
            const userBand = bandsToUse[band];
            const userValue = userBand?.percentage || userBand?.energy_db;
            
            // Pegar valores da referÃªncia
            const refBand = ref.bands[band];
            const refValue = refBand?.percentage || refBand?.energy_db;
            
            if (Number.isFinite(userValue) && Number.isFinite(refValue)) {
                pushRow(
                    bandNames[band] || band,
                    userValue,
                    refValue,
                    3.0, // TolerÃ¢ncia de 3% para bandas
                    '%'
                );
                
                log(`ğŸ“Š [BAND-${band}] User: ${userValue.toFixed(1)}% | Ref: ${refValue.toFixed(1)}%`);
            }
        });
    }
    // ğŸ¯ RENDERIZAÃ‡ÃƒO DE BANDAS COM ESTRUTURA ANTIGA (referenceComparison.comparison.spectralBands)
    else if (referenceBands && typeof referenceBands === 'object') {
        log('âš ï¸ [RENDER-REF-BANDS] Usando bandas de referenceComparison (estrutura antiga)');
        
        const bandNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)',
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)'
        };
        
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            if (referenceBands[band]) {
                const data = referenceBands[band];
                pushRow(
                    bandNames[band] || band,
                    data.user,
                    data.reference,
                    3.0,
                    data.unit
                );
            }
        });
    } 
    // ğŸµ RENDERIZAÃ‡ÃƒO DE BANDAS EM MODO GÃŠNERO
    else if (bandsToUse && ref.bands) {
        const normMap = (analysis?.technicalData?.refBandTargetsNormalized?.mapping) || null;
        const showNorm = (typeof window !== 'undefined' && window.SHOW_NORMALIZED_REF_TARGETS === true && normMap);
        
        // Mapeamento de nomes amigÃ¡veis para as bandas com ranges de frequÃªncia
        const bandDisplayNames = {
            sub: 'Sub (20â€“60Hz)',
            bass: 'Bass (60â€“150Hz)', 
            lowMid: 'Low-Mid (150â€“500Hz)',
            mid: 'Mid (500â€“2kHz)',
            highMid: 'High-Mid (2â€“5kHz)',
            presence: 'Presence (5â€“10kHz)',
            air: 'Air (10â€“20kHz)',
            brilho: 'Air (10â€“20kHz)'
        };
        
        // ğŸ¯ PROCESSAMENTO CORRIGIDO: Iterar por bandas de referÃªncia e mapear para dados calculados
        log('ğŸ”„ Processando bandas com mapeamento corrigido...');
        
        // ğŸ›¡ï¸ FALLBACK: Verificar se ref.bands existe antes de iterar
        if (!ref.bands || typeof ref.bands !== 'object') {
            warn('âš ï¸ [REF-COMP] Fallback triggered (missing bands) - ref.bands nÃ£o existe');
            ref.bands = {}; // Criar objeto vazio para evitar erro
        }
        
        for (const [refBandKey, refBand] of Object.entries(ref.bands)) {
            // Encontrar a banda calculada correspondente
            const calcBandKey = bandMappingRefToCalc[refBandKey] || refBandKey;
            let bLocal = null;
            
            log(`ğŸ” [BANDS] Processando: ${refBandKey} â†’ ${calcBandKey}`);
            
            // ğŸ¯ NOVO: Busca melhorada com sistema de alias
            const searchBandData = (bandKey) => {
                // Buscar diretamente
                if (centralizedBands && centralizedBands[bandKey]) {
                    return { rms_db: centralizedBands[bandKey].energy_db, source: 'centralized' };
                }
                if (legacyBandEnergies && legacyBandEnergies[bandKey]) {
                    return { ...legacyBandEnergies[bandKey], source: 'legacy' };
                }
                
                // Buscar por alias
                if (bandAliases[bandKey]) {
                    for (const alias of bandAliases[bandKey]) {
                        if (centralizedBands && centralizedBands[alias]) {
                            log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias} (centralized)`);
                            return { rms_db: centralizedBands[alias].energy_db, source: 'centralized-alias' };
                        }
                        if (legacyBandEnergies && legacyBandEnergies[alias]) {
                            log(`ğŸ”„ [ALIAS] ${bandKey} â†’ ${alias} (legacy)`);
                            return { ...legacyBandEnergies[alias], source: 'legacy-alias' };
                        }
                    }
                }
                
                return null;
            };
            
            // Buscar dados da banda
            bLocal = searchBandData(calcBandKey);
            
            // Se nÃ£o encontrou, tentar busca direta pela chave de referÃªncia
            if (!bLocal) {
                bLocal = searchBandData(refBandKey);
                if (bLocal) {
                    log(`âš ï¸ [BANDS] Fallback para chave de referÃªncia: ${refBandKey}`);
                }
            }
            
            // ğŸ¯ TRATAMENTO SILENCIOSO: Ignorar bandas nÃ£o encontradas sem erro
            if (!bLocal || !Number.isFinite(bLocal.rms_db)) {
                log(`ğŸ”‡ [BANDS] Ignorando banda inexistente: ${refBandKey} / ${calcBandKey}`);
                continue; // Pular silenciosamente
            }
            
            // Banda encontrada - processar normalmente
            log(`âœ… [BANDS] Encontrado ${refBandKey}: ${bLocal.rms_db}dB (${bLocal.source})`);
            
            // Log de validaÃ§Ã£o entre sistemas
            if (typeof window !== 'undefined' && window.METRICS_BANDS_VALIDATION !== false && 
                bLocal.source === 'centralized' && legacyBandEnergies?.[calcBandKey]) {
                const legacyValue = legacyBandEnergies[calcBandKey].rms_db;
                if (Number.isFinite(legacyValue) && Math.abs(bLocal.rms_db - legacyValue) > 0.01) {
                    warn(`ğŸ¯ BAND_DIFF: ${calcBandKey} centralized=${bLocal.rms_db} vs legacy=${legacyValue}`);
                }
            }
            
            // ğŸ¯ NOVO: Determinar target e tolerÃ¢ncia com helpers
            let tgt = null;
            let tolerance = null;
            
            // Prioridade 1: target_range (usar helpers para formataÃ§Ã£o e tolerÃ¢ncia)
            if (refBand.target_range && typeof refBand.target_range === 'object' &&
                Number.isFinite(refBand.target_range.min) && Number.isFinite(refBand.target_range.max)) {
                tgt = refBand.target_range;
                // âœ… CORRIGIDO: Usar deriveTolerance() ao invÃ©s de 0
                tolerance = deriveTolerance(tgt, 2.0);
                log(`ğŸ¯ [BANDS-FORMAT] Usando target_range para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            // Prioridade 2: target_db fixo
            else if (!refBand._target_na && Number.isFinite(refBand.target_db)) {
                tgt = refBand.target_db;
                // âœ… CORRIGIDO: Usar deriveTolerance() com fallback
                tolerance = deriveTolerance(tgt, 2.0);
                log(`ğŸ¯ [BANDS-FORMAT] Usando target_db fixo para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            
            // Prioridade 3: Targets normalizados (se habilitado)
            if (showNorm && normMap && Number.isFinite(normMap[refBandKey])) {
                tgt = normMap[refBandKey];
                log(`ğŸ¯ [BANDS] Sobrescrevendo com target normalizado para ${refBandKey}: ${tgt}`);
            }
            
            // Nome para exibiÃ§Ã£o
            const displayName = bandDisplayNames[calcBandKey] || bandDisplayNames[refBandKey] || refBandKey;
            
            // âœ… CORRIGIDO: Usar centerOfRange para cÃ¡lculo de delta
            const targetCenter = centerOfRange(tgt) ?? tgt ?? null;
            log(`ğŸ“Š [BANDS] Adicionando: ${displayName}, valor: ${bLocal.rms_db}dB, target: ${formatTarget(tgt)}, tol: ${tolerance}`);
            
            // ğŸ¯ Passar targetCenter (nÃºmero) para cÃ¡lculo correto de delta em pushRow
            pushRow(displayName, bLocal.rms_db, tgt, tolerance, ' dB');
        }
        
        // ğŸ¯ PROCESSAMENTO DE BANDAS EXTRAS: Bandas calculadas que nÃ£o estÃ£o na referÃªncia
        log('ğŸ”„ Verificando bandas extras nÃ£o mapeadas...');
        
        if (bandsToUse) {
            Object.keys(bandsToUse).forEach(calcBandKey => {
                // Filtrar chaves invÃ¡lidas (totais, metadados etc.)
                if (calcBandKey === '_status' || 
                    calcBandKey === 'totalPercentage' || 
                    calcBandKey === 'totalpercentage' ||
                    calcBandKey === 'metadata' ||
                    calcBandKey === 'total' ||
                    calcBandKey.toLowerCase().includes('total')) {
                    return; // Pular esta banda
                }
                
                // Verificar se esta banda jÃ¡ foi processada
                const refBandKey = bandMappingCalcToRef[calcBandKey];
                const alreadyProcessed = refBandKey && ref.bands[refBandKey];
                
                if (!alreadyProcessed) {
                    log(`ğŸ” Processando banda extra: ${calcBandKey}`);
                    
                    const bandData = bandsToUse[calcBandKey];
                    let energyDb = null;
                    
                    if (typeof bandData === 'object' && Number.isFinite(bandData.energy_db)) {
                        energyDb = bandData.energy_db;
                    } else if (typeof bandData === 'object' && Number.isFinite(bandData.rms_db)) {
                        energyDb = bandData.rms_db;
                    } else if (Number.isFinite(bandData)) {
                        energyDb = bandData;
                    }
                    
                    if (Number.isFinite(energyDb)) {
                        const displayName = bandDisplayNames[calcBandKey] || 
                                          `${calcBandKey.charAt(0).toUpperCase() + calcBandKey.slice(1)} (Nova Banda)`;
                        
                        // Tentar buscar referÃªncia direta por chave
                        const directRefData = ref.bands?.[calcBandKey];
                        let target = null;
                        let tolerance = null;
                        
                        // [BANDS-TOL-0] Suporte hÃ­brido: target_range ou target_db (SEM TOLERÃ‚NCIA)
                        if (directRefData?.target_range && typeof directRefData.target_range === 'object' &&
                            Number.isFinite(directRefData.target_range.min) && Number.isFinite(directRefData.target_range.max)) {
                            target = directRefData.target_range;
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        } else if (Number.isFinite(directRefData?.target_db)) {
                            target = { min: directRefData.target_db, max: directRefData.target_db };
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        }
                        
                        log(`ğŸ“Š Adicionando banda extra: ${displayName}, valor: ${energyDb}dB, target: ${target || 'N/A'}`);
                        pushRow(displayName, energyDb, target, tolerance, ' dB');
                        
                        if (!target) {
                            warn(`âš ï¸ Banda sem referÃªncia: ${calcBandKey} (valor: ${energyDb}dB)`);
                        }
                    }
                }
            });
        }
    } else {
        // Fallback melhorado: buscar todas as bandas espectrais disponÃ­veis
        const spectralBands = tech.spectral_balance || 
                            tech.spectralBands || 
                            analysis.metrics?.bands || {};
        
        // ğŸ¯ MAPEAMENTO COMPLETO com correÃ§Ã£o de nomes
        const bandMap = {
            sub: { refKey: 'sub', name: 'Sub (20â€“60Hz)', range: '20â€“60Hz' },
            bass: { refKey: 'low_bass', name: 'Bass (60â€“150Hz)', range: '60â€“150Hz' },
            lowMid: { refKey: 'low_mid', name: 'Low-Mid (150â€“500Hz)', range: '150â€“500Hz' },
            mid: { refKey: 'mid', name: 'Mid (500â€“2kHz)', range: '500â€“2000Hz' },
            highMid: { refKey: 'high_mid', name: 'High-Mid (2â€“5kHz)', range: '2000â€“5000Hz' },
            presence: { refKey: 'presenca', name: 'Presence (5â€“10kHz)', range: '5000â€“10000Hz' },
            air: { refKey: 'brilho', name: 'Air (10â€“20kHz)', range: '10000â€“20000Hz' }
        };
        
        // ğŸ¯ NOVO PROCESSAMENTO MODE-AWARE com resolver
        log('ğŸ”„ Processando bandas espectrais (mode-aware resolver)...', {
            renderMode,
            hasRefBands: !!ref?.bands,
            refBandsKeys: ref?.bands ? Object.keys(ref.bands) : [],
            spectralBandsKeys: Object.keys(spectralBands),
            stateRefAnalysis: !!stateV3?.reference?.analysis?.bands
        });
        
        if (spectralBands && Object.keys(spectralBands).length > 0) {
            // ğŸ¯ PATCH B: ExtraÃ§Ã£o de bandas mode-aware com bloqueio de fallback
            // isReferenceMode jÃ¡ definido no escopo superior
            
            let refBands = null;
            let userBands = null;
            
            if (isReferenceMode) {
                // 2Âª faixa: referÃªncia/alvo
                const refTech = opts?.referenceAnalysis?.technicalData
                             || stateV3?.referenceAnalysis?.technicalData
                             || stateV3?.reference?.referenceAnalysis?.technicalData
                             || referenceComparisonMetrics?.target
                             || referenceComparisonMetrics?.userFull?.technicalData /* legado confuso */ 
                             || null;
                
                // 1Âª faixa: base/origem
                const userTech = opts?.userAnalysis?.technicalData
                              || stateV3?.userAnalysis?.technicalData
                              || stateV3?.reference?.userAnalysis?.technicalData
                              || referenceComparisonMetrics?.analyzed
                              || referenceComparisonMetrics?.referenceFull?.technicalData /* legado confuso */
                              || null;
                
                // ğŸ” EXTRAÃ‡ÃƒO DE refBands com fallback seguro (NUNCA usar ranges de gÃªnero)
                refBands = refTech?.spectral_balance ||
                          opts?.referenceAnalysis?.bands ||
                          opts?.referenceAnalysis?.frequencyBands ||
                          stateV3?.referenceAnalysis?.bands ||
                          stateV3?.referenceAnalysis?.frequencyBands ||
                          null;
                
                userBands = userTech?.spectral_balance || null;
                
                log('[REF-FLOW] bands sources', {
                    userBands: !!userBands, 
                    refBands: !!refBands,
                    userBandsKeys: userBands ? Object.keys(userBands).slice(0, 5) : [],
                    refBandsKeys: refBands ? Object.keys(refBands).slice(0, 5) : []
                });
                
                if (!refBands) {
                    error("ğŸš¨ [REF-ERROR] Nenhum dado de bandas encontrado na referÃªncia.");
                    error('[CRITICAL] Reference mode sem bandas da 2Âª faixa! Abortando render.');
                    error('[CRITICAL] Proibido fallback de gÃªnero no reference mode');
                    if (container) {
                        container.innerHTML = '<div style="color:red;">âŒ Erro: bandas de referÃªncia nÃ£o disponÃ­veis</div>';
                    }
                    return;
                }
                
                log("âœ… [AUDIT_REF_FIX] referenceAnalysis spectral_balance pronto:", refBands);
            } else {
                // GENRE: aqui SIM usa ranges de __activeRefData
                refBands  = (__activeRefData && __activeRefData.bands) || null;
                userBands = (analysis?.technicalData?.spectral_balance) || spectralBands || null;
            }
            
            // Conjunto para rastrear bandas jÃ¡ processadas
            const processedBandKeys = new Set();
            
            // ğŸ¯ Iterar por todas as bandas do usuÃ¡rio
            const bandsToIterate = userBands || spectralBands;
            for (const rawKey of Object.keys(bandsToIterate)) {
                if (IGNORE_BANDS.has(rawKey) || processedBandKeys.has(rawKey)) continue;
                
                const bandKey = normalizeBandKey(rawKey);
                const userVal = pickNumeric(bandsToIterate[rawKey]);
                
                if (userVal === null) continue; // Sem valor do usuÃ¡rio
                
                let targetDisplay = 'â€”';
                let valueDisplay = 'â€”';
                let deltaDisplay = 'â€”';
                let targetValue = null;
                let tolDisplay = null;
                
                if (isReferenceMode) {
                    const refVal = getReferenceBandValue(refBands, bandKey); // retorna nÃºmero (dB) ou null
                    const userValCalc = getReferenceBandValue(userBands, bandKey);
                    
                    if (refVal == null) {
                        warn('[REF-FLOW] Banda sem valor na 2Âª faixa:', bandKey);
                        targetDisplay = 'â€”';
                        targetValue = null;
                    } else {
                        targetDisplay = formatDb(refVal);
                        targetValue = refVal;
                    }
                    
                    valueDisplay = (userValCalc == null) ? 'â€”' : formatDb(userValCalc);
                    deltaDisplay = (userValCalc == null || refVal == null) ? 'â€”' : formatDb(userValCalc - refVal);
                    tolDisplay = 0; // Sem tolerÃ¢ncia em comparaÃ§Ã£o direta
                    
                } else {
                    // GENRE: range do JSON de gÃªnero
                    const r = getGenreTargetRange(refBands, bandKey);
                    if (r) {
                        targetDisplay = `${formatDb(r.min)} a ${formatDb(r.max)}`;
                        targetValue = { min: r.min, max: r.max };
                        tolDisplay = r.tol;
                    } else {
                        targetDisplay = 'â€”';
                        targetValue = null;
                    }
                    valueDisplay = formatDb(userVal);
                    deltaDisplay = 'â€”'; // (delta numÃ©rico nÃ£o se aplica a range)
                }
                
                // ğŸ¯ Adicionar linha na tabela
                const label = bandMap[bandKey]?.name || `${bandKey.toUpperCase()}`;
                pushRow(label, userVal, targetValue, tolDisplay, ' dB');
                processedBandKeys.add(rawKey);
                processedBandKeys.add(bandKey);
            }
            
            log(`âœ… [BANDS-PROCESSED] ${processedBandKeys.size} bandas processadas no modo ${renderMode}`);
        } else {
            // Fallback para tonalBalance simplificado (mantido para compatibilidade)
            const tb = tech.tonalBalance || {};
            const legacyBandMap = { sub:'sub', low:'low_bass', mid:'mid', high:'brilho' };
            Object.entries(legacyBandMap).forEach(([tbKey, refBand]) => {
                const bData = tb[tbKey];
                const refBandData = ref.bands?.[refBand];
                if (bData && refBandData && Number.isFinite(bData.rms_db)) {
                    log(`ğŸ“Š Banda legacy: ${tbKey.toUpperCase()}, valor: ${bData.rms_db}dB, target: ${refBandData.target_db}dB`);
                    pushRow(`${tbKey.toUpperCase()}`, bData.rms_db, refBandData.target_db, refBandData.tol_db, ' dB');
                }
            });
        }
    }
    
    // ğŸ¯ LOG DE RESUMO: Bandas processadas com sucesso
    const bandasDisponiveis = ref.bands ? Object.keys(ref.bands).length : 0;
    const bandasProcessadas = rows.length - 5; // Subtrair mÃ©tricas bÃ¡sicas (LUFS, Peak, DR, LRA, Stereo)
    
    log('ğŸ“Š [BANDS] Resumo do processamento de bandas:', {
        bandas_na_referencia: bandasDisponiveis,
        bandas_processadas: Math.max(0, bandasProcessadas),
        metricas_totais: rows.length,
        centralized_bands_ok: !!centralizedBands,
        legacy_bands_ok: !!legacyBandEnergies,
        modo_referencia: isReferenceMode
    });
    
    // ğŸ¯ [A/B-TABLE-FIX] CORREÃ‡ÃƒO CRÃTICA: Renderizar tabela A/B com 2 colunas independentes
    // Modo REFERENCE: Extrair mÃ©tricas de userAnalysis (1Âª faixa) e referenceAnalysis (2Âª faixa)
    
    let abTableHTML = '';
    
    if (isReferenceMode && opts.userAnalysis && opts.referenceAnalysis) {
        log('ğŸ¯ [A/B-TABLE-FIX] Renderizando tabela A/B com 2 colunas independentes');
        
        const userTech = opts.userAnalysis.technicalData || {};
        const refTech = opts.referenceAnalysis.technicalData || {};
        
        // ğŸ¯ ASSERT CRÃTICO: Garantir que mÃ©tricas sÃ£o DIFERENTES
        if (userTech.lufsIntegrated === refTech.lufsIntegrated &&
            userTech.dynamicRange === refTech.dynamicRange &&
            userTech.truePeakDbtp === refTech.truePeakDbtp) {
            error('âŒ [A/B-TABLE-FIX] ERRO CRÃTICO: user/ref metrics IDÃŠNTICAS - DOM duplicado ou fonte errada!');
            console.table({
                'User LUFS': userTech.lufsIntegrated,
                'Ref LUFS': refTech.lufsIntegrated,
                'User DR': userTech.dynamicRange,
                'Ref DR': refTech.dynamicRange,
                'User Peak': userTech.truePeakDbtp,
                'Ref Peak': refTech.truePeakDbtp
            });
            container.innerHTML = '<div class="card" style="margin-top:12px;"><div style="color:red;padding:20px;">âŒ ERRO: MÃ©tricas idÃªnticas detectadas. Recarregue a pÃ¡gina.</div></div>';
            return;
        }
        
        // Helper format
        const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
        
        // ğŸ¯ Helper para calcular status e cor baseado na diferenÃ§a
        const getStatusAndColor = (diff, tolerance = 0.5) => {
            if (!Number.isFinite(diff)) {
                return { class: '', text: 'N/A', color: 'rgba(255,255,255,0.3)' };
            }
            
            const absDiff = Math.abs(diff);
            
            // LÃ³gica adaptativa baseada no tipo de mÃ©trica
            if (absDiff <= tolerance) {
                // âœ… IDEAL
                return { 
                    class: 'ok', 
                    text: 'Ideal',
                    icon: 'âœ…'
                };
            } else if (absDiff <= tolerance * 6) {
                // âš ï¸ AJUSTE LEVE
                return { 
                    class: 'yellow', 
                    text: 'Ajuste leve',
                    icon: 'âš ï¸'
                };
            } else {
                // âŒ CORRIGIR
                return { 
                    class: 'warn', 
                    text: 'Corrigir',
                    icon: 'âŒ'
                };
            }
        };
        
        // Construir linhas A/B com Delta e Status
        const abRows = [];
        
        const addABRow = (label, userVal, refVal, unit = '', dataMetric = '', tolerance = 0.5) => {
            const dataAttr = dataMetric ? ` data-metric="${dataMetric}"` : '';
            
            // Calcular diferenÃ§a (Faixa 1 - Faixa 2)
            let delta = null;
            let deltaText = 'â€”';
            
            if (Number.isFinite(userVal) && Number.isFinite(refVal)) {
                delta = userVal - refVal;
                const sign = delta > 0 ? '+' : '';
                deltaText = `${sign}${nf(delta)}${unit}`;
            }
            
            // Obter status e classe CSS
            const status = getStatusAndColor(delta, tolerance);
            
            abRows.push(`<tr${dataAttr}>
                <td class="metric-name">${label}</td>
                <td class="ab-user"${dataAttr}>${Number.isFinite(userVal) ? nf(userVal) + unit : 'â€”'}</td>
                <td class="ab-ref"${dataAttr}>${Number.isFinite(refVal) ? nf(refVal) + unit : 'â€”'}</td>
                <td class="delta-col">${deltaText}</td>
                <td class="status-col ${status.class}">
                    <div class="diff-cell-content">
                        <span class="diff-value">${status.icon}</span>
                        <span class="diff-status">${status.text}</span>
                    </div>
                </td>
            </tr>`);
        };
        
        // ===== MÃ‰TRICAS PRINCIPAIS =====
        addABRow('Loudness (LUFS Integrado)', userTech.lufsIntegrated, refTech.lufsIntegrated, ' LUFS', 'lufs', 0.5);
        addABRow('True Peak (dBTP)', userTech.truePeakDbtp, refTech.truePeakDbtp, ' dBTP', 'truepeak', 0.3);
        addABRow('Dynamic Range (dB)', userTech.dynamicRange, refTech.dynamicRange, ' dB', 'dr', 1.0);
        addABRow('LRA (LU)', userTech.lra, refTech.lra, ' LU', 'lra', 1.0);
        addABRow('Stereo Corr.', userTech.stereoCorrelation, refTech.stereoCorrelation, '', 'stereo', 0.08);
        
        // ===== BANDAS ESPECTRAIS =====
        const userBands = userTech.spectral_balance || {};
        const refBands = refTech.spectral_balance || {};
        
        const bandNames = {
            sub: 'Sub (20-60Hz)',
            bass: 'Bass (60-150Hz)',
            lowMid: 'Low-Mid (150-500Hz)',
            mid: 'Mid (500-2kHz)',
            highMid: 'High-Mid (2-5kHz)',
            presence: 'Presence (5-10kHz)',
            air: 'Air (10-20kHz)'
        };
        
        Object.entries(bandNames).forEach(([key, name]) => {
            const userVal = userBands[key]?.energy_db ?? userBands[key]?.percentage ?? userBands[key];
            const refVal = refBands[key]?.energy_db ?? refBands[key]?.percentage ?? refBands[key];
            if (Number.isFinite(userVal) || Number.isFinite(refVal)) {
                addABRow(name, userVal, refVal, ' dB', `band-${key}`, 1.0);
            }
        });
        
        // Nomes das faixas
        const userName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || '1Âª Faixa';
        const refName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || '2Âª Faixa';
        
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title" style="
                background: linear-gradient(90deg, #7F00FF, #00FFFF);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                font-size: clamp(15px, 1.3vw, 18px);
                font-weight: 700;
                margin-bottom: 12px;
            ">ğŸµ COMPARAÃ‡ÃƒO A/B ENTRE FAIXAS</div>
            
            <!-- Header com nomes das faixas - Compacto e elegante -->
            <div class="ab-header" style="
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 10px; 
                padding: 10px; 
                background: linear-gradient(90deg, rgba(127, 0, 255, 0.08), rgba(0, 255, 255, 0.08));
                border-radius: 8px; 
                margin-bottom: 10px;
                border: 1px solid rgba(127, 0, 255, 0.12);
            ">
                <div class="track-name user-track" style="
                    padding: 8px 10px;
                    background: rgba(82, 247, 173, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #52f7ad;
                    box-shadow: 0 2px 6px rgba(82, 247, 173, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">ğŸ§</span>
                        <span>SUA FAIXA</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${userName}</div>
                </div>
                <div class="track-name ref-track" style="
                    padding: 8px 10px;
                    background: rgba(255, 206, 77, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #ffce4d;
                    box-shadow: 0 2px 6px rgba(255, 206, 77, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">ğŸšï¸</span>
                        <span>REFERÃŠNCIA</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${refName}</div>
                </div>
            </div>
            
            <!-- Tabela de comparaÃ§Ã£o - Refinada e compacta -->
            <table class="ref-compare-table ab-compare-table" style="width: 100%;">
                <thead>
                    <tr>
                        <th style="text-align: left; padding-left: 12px;">MÃ©trica</th>
                        <th class="ab-user-header">FAIXA 1</th>
                        <th class="ab-ref-header">FAIXA 2</th>
                        <th>Î”</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="ab-comparison-body">${abRows.join('')}</tbody>
            </table>
        </div>`;
        
        // ğŸ¯ LOG DE VALIDAÃ‡ÃƒO PÃ“S-RENDER
        console.group('ğŸ¯ [A/B-TABLE-VALIDATION] ValidaÃ§Ã£o pÃ³s-renderizaÃ§Ã£o');
        log('USER LUFS:', userTech.lufsIntegrated);
        log('REF LUFS:', refTech.lufsIntegrated);
        log('USER DR:', userTech.dynamicRange);
        log('REF DR:', refTech.dynamicRange);
        log('USER TruePeak:', userTech.truePeakDbtp);
        log('REF TruePeak:', refTech.truePeakDbtp);
        console.groupEnd();
        
    } else {
        // Modo GENRE ou fallback: usar tabela antiga
        warn('âš ï¸ [A/B-TABLE-FIX] Modo GENRE ou dados incompletos - usando tabela de referÃªncia padrÃ£o');
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title">COMPARAÃ‡ÃƒO DE REFERÃŠNCIA (${titleText})</div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>MÃ©trica</th><th>Valor</th><th>Alvo</th><th>Î”</th>
                </tr></thead>
                <tbody>${rows.join('') || '<tr><td colspan="4" style="opacity:.6">Sem mÃ©tricas disponÃ­veis</td></tr>'}</tbody>
            </table>
        </div>`;
    }
    
    // ğŸ¯ RENDERIZAR TABELA NO DOM COM PROTEÃ‡ÃƒO DE ERRO
    try {
        container.innerHTML = abTableHTML;
        
        // ğŸ” LOGS OBRIGATÃ“RIOS DE VERIFICAÃ‡ÃƒO
        log('[AB-RENDER] container exists?', !!container);
        log('[AB-RENDER] rows count:', rows.length);
        log('[AB-RENDER] inserted?', container.innerHTML.length > 0);
        log('[RENDER-REF] âœ… HTML da tabela A/B inserido no DOM:', {
            htmlLength: abTableHTML.length,
            containerHasContent: container.innerHTML.length > 0,
            containerId: container.id,
            rowsGenerated: rows.length
        });
    } catch (err) {
        error('[RENDER-REF] âŒ Erro ao inserir HTML da tabela A/B:', err);
        log('[AB-RENDER] inserted?', false);
        container.innerHTML = `<div class="error-message" style="padding: 20px; color: #ff4444; background: #1a1a1f; border-radius: 8px;">
            âŒ Erro ao renderizar tabela de comparaÃ§Ã£o A/B: ${err.message}
        </div>`;
    }
    
    // ğŸ¯ FORÃ‡AR VISIBILIDADE DA TABELA EM AMBOS OS MODOS
    log('[UI_RENDER] ForÃ§ando renderizaÃ§Ã£o da tabela comparativa');
    const tableEl = document.getElementById('referenceComparisons');
    if (tableEl) {
        tableEl.classList.remove('hidden');
        tableEl.style.display = ''; // Limpa inline display:none
        tableEl.style.visibility = 'visible';
        tableEl.style.opacity = '1';
        log('âœ… [RENDER-REF] Tabela forÃ§ada para visÃ­vel (mode:', renderMode, ')');
        
        // ğŸ¯ [DOM-VALIDATION] ASSERT CRÃTICO: Verificar que elementos A/B sÃ£o DISTINTOS
        if (isReferenceMode) {
            setTimeout(() => {
                const userLufsEl = document.querySelector('.ab-user[data-metric="lufs"]');
                const refLufsEl = document.querySelector('.ab-ref[data-metric="lufs"]');
                
                console.group('ğŸ¯ [DOM-VALIDATION] VerificaÃ§Ã£o de elementos A/B');
                log('User LUFS Element:', userLufsEl);
                log('Ref LUFS Element:', refLufsEl);
                log('SÃ£o o mesmo elemento?', userLufsEl === refLufsEl);
                log('User LUFS innerHTML:', userLufsEl?.innerHTML);
                log('Ref LUFS innerHTML:', refLufsEl?.innerHTML);
                
                if (userLufsEl === refLufsEl) {
                    error('âŒ [DOM-VALIDATION] ERRO CRÃTICO: Elementos .ab-user e .ab-ref sÃ£o o MESMO objeto!');
                } else if (!userLufsEl || !refLufsEl) {
                    error('âŒ [DOM-VALIDATION] ERRO: Elementos nÃ£o encontrados no DOM!');
                } else {
                    log('âœ… [DOM-VALIDATION] Elementos A/B sÃ£o DISTINTOS e independentes');
                }
                console.groupEnd();
            }, 100);
        }
        
        // ğŸ” VERIFICAÃ‡ÃƒO FINAL DE VISIBILIDADE (PATCH SENIOR)
        setTimeout(() => {
            const finalCheck = document.querySelector('#referenceComparisons');
            if (finalCheck) {
                const rect = finalCheck.getBoundingClientRect();
                const computed = window.getComputedStyle(finalCheck);
                
                log('[DOM-FINAL-CHECK] ğŸ” Estado do container #referenceComparisons:', {
                    exists: true,
                    hasContent: finalCheck.innerHTML.length > 0,
                    childrenCount: finalCheck.children.length,
                    display: computed.display,
                    visibility: computed.visibility,
                    opacity: computed.opacity,
                    width: rect.width,
                    height: rect.height,
                    isVisible: rect.width > 0 && rect.height > 0 && computed.display !== 'none'
                });
                
                // ğŸ›¡ï¸ FORÃ‡AR VISIBILIDADE se necessÃ¡rio
                if (computed.display === 'none' || computed.visibility === 'hidden' || computed.opacity === '0') {
                    warn('[DOM-FINAL-CHECK] âš ï¸ Container oculto - FORÃ‡ANDO VISIBILIDADE');
                    finalCheck.style.display = 'block';
                    finalCheck.style.visibility = 'visible';
                    finalCheck.style.opacity = '1';
                }
            } else {
                error('[DOM-FINAL-CHECK] âŒ #referenceComparisons NÃƒO EXISTE NO DOM!');
                
                // ğŸš¨ DIAGNÃ“STICO COMPLETO
                console.group('[DOM-DIAGNOSTIC] ğŸ”¬ DiagnÃ³stico completo do DOM');
                log('audioAnalysisResults existe?', !!document.getElementById('audioAnalysisResults'));
                log('modalTechnicalData existe?', !!document.getElementById('modalTechnicalData'));
                log('Todos os elementos do modal:', {
                    results: document.getElementById('audioAnalysisResults')?.innerHTML?.length || 0,
                    technical: document.getElementById('modalTechnicalData')?.innerHTML?.length || 0,
                    children: document.getElementById('audioAnalysisResults')?.children?.length || 0
                });
                console.groupEnd();
            }
        }, 500);

    } else {
        error('âŒ [RENDER-REF] Elemento #referenceComparisons NÃƒO encontrado no DOM!');
    }
    
    // ğŸ¯ Verificar se wrapper/parent tambÃ©m estÃ¡ visÃ­vel
    const wrapper = tableEl?.parentElement;
    if (wrapper) {
        wrapper.classList.remove('hidden');
        wrapper.classList.add('visible');
        wrapper.style.display = '';
    }
    
    // ğŸ›¡ï¸ PASSO 3: VERIFICAÃ‡ÃƒO FINAL
    log('ğŸ¯ [AUDITORIA_REF] ComparaÃ§Ã£o de referÃªncia renderizada com sucesso');
    log('ğŸ¯ [AUDITORIA_REF] Targets usados:', {
        lufs: lufsTarget,
        truePeak: tpTarget,
        dr: drTarget,
        lra: lraTarget,
        stereo: stereoTarget,
        totalRows: rows.length
    });
    
    // ğŸ¯ LOG FINAL DE SUCESSO COMPLETO
    log('âœ… [REF-COMP] renderReferenceComparisons SUCCESS', {
        mode: renderMode,
        usedReferenceAnalysis: !!analysis.referenceAnalysis,
        bandsResolved: ref.bands ? Object.keys(ref.bands).length : 0,
        rowsGenerated: rows.length,
        titleDisplayed: titleText,
        tableVisible: renderMode === 'reference'
    });
    
    // ğŸ¯ TRANSIÃ‡ÃƒO DE ESTADO FINAL: REF_B_DONE â†’ REF_AB_RENDERED
    log('%c[REF-FLOW] ğŸ¯ TRANSIÃ‡ÃƒO FINAL: REF_B_DONE â†’ REF_AB_RENDERED', 'color:#00FF88;font-weight:bold;font-size:16px;');
    log('[REF-FLOW] âœ… Fluxo A/B COMPLETADO COM SUCESSO!');
    log('[REF-FLOW] Estado final:', {
        stage: 'REF_AB_RENDERED',
        tableRendered: true,
        comparisonComplete: true,
        rowsDisplayed: rows.length,
        currentMode: window.currentAnalysisMode
    });
    
    // ğŸ¯ LOG FINAL DE VERIFICAÃ‡ÃƒO (conforme solicitado)
    log('[FINAL-CHECK] renderReferenceComparisons concluÃ­do com', {
        mode: renderMode,
        bands: Object.keys(ref?.bands || {}),
        bandsCount: Object.keys(ref?.bands || {}).length,
        tableVisible: !!document.querySelector('#referenceComparisons'),
        tableHasContent: rows.length > 0,
        userMetricsLoaded: !!userMetrics,
        refMetricsLoaded: !!ref,
        titleText: titleText
    });
    
    // âœ… DESBLOQUEIO DO MODAL - Finalizar loading e exibir resultados
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (loading) {
        loading.style.display = 'none';
        log('[MODAL-FIX] âœ… Loading ocultado');
    }
    
    if (results) {
        results.style.display = 'block';
        log('[MODAL-FIX] âœ… Resultados exibidos');
    }
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        log('[MODAL-FIX] âœ… Upload area ocultada');
    }
    
    log('[MODAL-FIX] âœ… Loading encerrado com sucesso - modal desbloqueado');
    
    // Estilos injetados uma vez com indicadores visuais melhorados
    if (!document.getElementById('refCompareStyles')) {
        const style = document.createElement('style');
        style.id = 'refCompareStyles';
        style.textContent = `
        .ref-compare-table{width:100%;border-collapse:collapse;font-size:11px;}
        .ref-compare-table th{font-weight:500;padding:4px 6px;border-bottom:1px solid rgba(255,255,255,.12);font-size:11px;color:#fff;letter-spacing:.3px;}
        .ref-compare-table th:first-child{text-align:left;}
        .ref-compare-table th:not(:first-child){text-align:center;}
        .ref-compare-table td{padding:5px 6px;border-bottom:1px solid rgba(255,255,255,.06);color:#f5f7fa;} 
        .ref-compare-table td:first-child{text-align:left;}
        .ref-compare-table td:not(:first-child){text-align:center;}
        .ref-compare-table tr:last-child td{border-bottom:0;} 
        .ref-compare-table td.ok{color:#52f7ad;font-weight:600;} 
        .ref-compare-table td.ok::before{content:'âœ… ';margin-right:2px;}
        .ref-compare-table td.yellow{color:#ffce4d;font-weight:600;} 
        .ref-compare-table td.yellow::before{content:'âš ï¸ ';margin-right:2px;}
        .ref-compare-table td.warn{color:#ff7b7b;font-weight:600;} 
        .ref-compare-table td.warn::before{content:'âŒ ';margin-right:2px;}
        .ref-compare-table .tol{opacity:.7;margin-left:4px;font-size:10px;color:#b8c2d6;} 
        .ref-compare-table tbody tr:hover td{background:rgba(255,255,255,.04);} 
        `;
        document.head.appendChild(style);
    }
    
    // ğŸ¯ ESTILOS DA TABELA CLÃSSICA DE GÃŠNERO
    if (!document.getElementById('classicGenreStyles')) {
        const genreStyle = document.createElement('style');
        genreStyle.id = 'classicGenreStyles';
        genreStyle.textContent = `
        .classic-genre-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .classic-genre-table th {
            font-weight: 600;
            padding: 6px 8px;
            border-bottom: 2px solid rgba(255,255,255,.15);
            font-size: 11px;
            color: #fff;
            text-align: left;
            letter-spacing: .5px;
            background: rgba(0,0,0,.2);
        }
        .classic-genre-table tbody tr {
            transition: background .2s ease;
        }
        .classic-genre-table tbody tr:hover {
            background: rgba(255,255,255,.05);
        }
        .classic-genre-table td {
            padding: 7px 8px;
            border-bottom: 1px solid rgba(255,255,255,.08);
            font-size: 11px;
        }
        .classic-genre-table tr:last-child td {
            border-bottom: 0;
        }
        
        /* ğŸ¯ CORES DE SEVERIDADE */
        .classic-genre-table .genre-row.ok {
            background: rgba(82, 247, 173, .05);
        }
        .classic-genre-table .genre-row.ok:hover {
            background: rgba(82, 247, 173, .12);
        }
        .classic-genre-table .genre-row.caution {
            background: rgba(255, 206, 77, .08);
        }
        .classic-genre-table .genre-row.caution:hover {
            background: rgba(255, 206, 77, .15);
        }
        .classic-genre-table .genre-row.warning {
            background: rgba(255, 165, 0, .1);
        }
        .classic-genre-table .genre-row.warning:hover {
            background: rgba(255, 165, 0, .18);
        }
        .classic-genre-table .genre-row.critical {
            background: rgba(255, 82, 82, .12);
        }
        .classic-genre-table .genre-row.critical:hover {
            background: rgba(255, 82, 82, .2);
        }
        
        /* ğŸ¯ COLUNAS ESPECÃFICAS */
        .classic-genre-table .metric-name {
            font-weight: 500;
            color: #e1e8f0;
        }
        .classic-genre-table .metric-value {
            font-weight: 600;
            color: #52f7ad;
            text-align: center;
        }
        .classic-genre-table .metric-target {
            color: #9ca9ba;
            text-align: center;
            font-size: 10px;
        }
        .classic-genre-table .metric-diff {
            text-align: center;
            font-weight: 600;
        }
        .classic-genre-table .metric-diff.positive {
            color: #ff8a80;
        }
        .classic-genre-table .metric-diff.negative {
            color: #80d8ff;
        }
        .classic-genre-table .metric-severity {
            text-align: center;
            font-weight: 700;
            font-size: 10px;
            letter-spacing: .8px;
        }
        .classic-genre-table .metric-severity.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-severity.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-severity.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-severity.critical {
            color: #ff5252;
        }
        .classic-genre-table .metric-action {
            text-align: center;
            font-size: 10px;
            font-weight: 500;
        }
        .classic-genre-table .metric-action.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-action.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-action.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-action.critical {
            color: #ff5252;
        }
        `;
        document.head.appendChild(genreStyle);
    }
    
    // Garantir que o CSS do priority-banner esteja disponÃ­vel no modal
    if (!document.getElementById('priorityBannerStyles')) {
        const priorityStyle = document.createElement('style');
        priorityStyle.id = 'priorityBannerStyles';
        priorityStyle.textContent = `
        .priority-banner {
            display: flex !important;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            font-weight: 700;
            background: linear-gradient(90deg, #ff006a, #ff9800) !important;
            color: #fff !important;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 106, 0.3);
            animation: pulsePriority 1.5s infinite alternate;
            position: relative;
            z-index: 10;
        }
        
        .priority-icon {
            font-size: 20px;
            line-height: 1;
        }
        
        @keyframes pulsePriority {
            from { opacity: 0.8; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1.02); }
        }
        `;
        document.head.appendChild(priorityStyle);
    }
    
    // ğŸ”“ CORREÃ‡ÃƒO CRÃTICA: Liberar comparisonLock ao final da renderizaÃ§Ã£o
    window.comparisonLock = false;
    log('[FIX-AUDIT] âœ… comparisonLock liberado apÃ³s renderizaÃ§Ã£o completa');
    log('[FIX-AUDIT] âœ… RenderReferenceComparisons auditado e restaurado com sucesso');
    log('[FIX-AUDIT] âœ… userBands e refBands preservadas');
    log('[FIX-AUDIT] âœ… Render completo no modo reference');
    log('[FIX-AUDIT] âœ… Cards e sugestÃµes renderizados apÃ³s comparaÃ§Ã£o');
    console.groupEnd(); // Fecha [SAFE_RENDER_REF]
    
    // ==== PATCH 2 FINAL: ValidaÃ§Ã£o e limpeza ====
    if (opts.usedReferenceAnalysis !== true) {
        error("[REF-PATCH] usedReferenceAnalysis caiu pra false â€” bug de wiring");
        throw new Error("Reference not used");
    }
    window.__refRenderInProgress = false;
    
    // ========================================
    // ğŸ›¡ï¸ FIM DO TRY/CATCH WRAPPER
    // ========================================
    } catch (error) {
        error('âŒ [REF-RENDER-ERROR] Erro durante renderizaÃ§Ã£o:', error);
        error('âŒ [REF-RENDER-ERROR] Stack:', error.stack);
        
        // Liberar locks para evitar travamento
        window.comparisonLock = false;
        window.__refRenderInProgress = false;
        
        // Exibir mensagem amigÃ¡vel ao usuÃ¡rio
        const container = document.getElementById('referenceComparisons');
        if (container) {
            container.innerHTML = `
                <div class="card" style="margin-top:12px;padding:16px;text-align:center;background:rgba(255,82,82,.1);border:1px solid rgba(255,82,82,.3);">
                    <strong style="color:#ff5252;">âš ï¸ Erro ao renderizar comparaÃ§Ã£o</strong><br>
                    <span style="font-size:11px;color:#ffb3b3;">Ocorreu um erro ao exibir os resultados. Por favor, tente novamente.</span><br>
                    <span style="font-size:10px;color:#888;margin-top:8px;display:block;">Erro: ${error.message}</span>
                </div>
            `;
        }
        
        // Liberar modal para evitar travamento
        const loading = document.getElementById('audioAnalysisLoading');
        const results = document.getElementById('audioAnalysisResults');
        if (loading) loading.style.display = 'none';
        if (results) results.style.display = 'block';
        
        log('[REF-RENDER-SAFE] âœ… Erro capturado e tratado com seguranÃ§a');
    }
}

// ğŸ”’ CÃ“PIA IMUTÃVEL DA FUNÃ‡ÃƒO ORIGINAL displayModalResults
// Esta cÃ³pia garante que interceptadores sempre tenham acesso Ã  funÃ§Ã£o original
if (!window.__displayModalResultsOriginal) {
    log('[FIX] ğŸ”’ Criando cÃ³pia imutÃ¡vel de displayModalResults');
    window.__displayModalResultsOriginal = displayModalResults;
    Object.freeze(window.__displayModalResultsOriginal);
    log('[FIX] âœ… CÃ³pia imutÃ¡vel criada: window.__displayModalResultsOriginal');
}

/**
 * ğŸ¯ RENDERIZAÃ‡ÃƒO DE COMPARAÃ‡ÃƒO ENTRE DUAS FAIXAS
 * Exibe tabela comparativa lado a lado: Faixa 1 (referÃªncia) vs Faixa 2 (usuÃ¡rio)
 * @param {Object} referenceAnalysis - Dados da primeira faixa (referÃªncia)
 * @param {Object} currentAnalysis - Dados da segunda faixa (usuÃ¡rio)
 */
function renderTrackComparisonTable(baseAnalysis, referenceAnalysis) {
    // ğŸ¯ PARÃ‚METROS CORRIGIDOS:
    // baseAnalysis = primeira faixa (alvo/base da comparaÃ§Ã£o)
    // referenceAnalysis = segunda faixa (atual/sendo comparada)
    
    log('ğŸ¯ [TRACK-COMPARE] Renderizando tabela comparativa entre faixas');
    log('ğŸ“Š [TRACK-COMPARE] Base (1Âª faixa - ALVO):', baseAnalysis);
    log('ğŸ“Š [TRACK-COMPARE] Atual (2Âª faixa - COMPARADA):', referenceAnalysis);
    
    // ğŸ¯ Definir modo reference no estado
    const state = window.__soundyState || {};
    state.render = state.render || {};
    state.render.mode = 'reference';
    log('âœ… [TRACK-COMPARE] Modo definido como reference no estado');
    
    // ğŸ¯ LOG AUDIT-MODE-FLOW (conforme solicitado)
    log('[AUDIT-MODE-FLOW]', {
        mode: state.render.mode,
        isSecondTrack: state.reference?.isSecondTrack,
        refJobId: state.reference?.jobId,
        hasRefAnalysis: !!state.reference?.analysis
    });
    
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        error('âŒ Container referenceComparisons nÃ£o encontrado');
        return;
    }
    
    // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS do backend (sem reconstruÃ§Ã£o)
    // ref = primeira faixa (BASE/ALVO)
    // curr = segunda faixa (ATUAL/COMPARADA)
    const ref = baseAnalysis; // âœ… LEITURA DIRETA
    const curr = referenceAnalysis; // âœ… LEITURA DIRETA
    
    const refTech = ref.technicalData || {};
    const currTech = curr.technicalData || {};
    
    // Helper para comparar valores e calcular status
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : 'â€”';
    const calcDiffPercent = (curr, ref) => {
        if (!Number.isFinite(curr) || !Number.isFinite(ref) || ref === 0) return null;
        return ((curr - ref) / Math.abs(ref)) * 100;
    };
    
    const getStatus = (diffPercent, tolerance = 10) => {
        if (diffPercent === null) return { class: '', text: 'N/A' };
        const absDiff = Math.abs(diffPercent);
        if (absDiff <= tolerance) return { class: 'ok', text: 'âœ… Ideal' };
        if (absDiff <= tolerance * 2) return { class: 'yellow', text: 'âš ï¸ Ajuste leve' };
        return { class: 'warn', text: 'âŒ Corrigir' };
    };
    
    // Construir linhas da tabela
    const rows = [];
    
    // FunÃ§Ã£o auxiliar para adicionar linha
    const addRow = (label, currVal, refVal, unit = '', tolerance = 10) => {
        const diffPercent = calcDiffPercent(currVal, refVal);
        const status = getStatus(diffPercent, tolerance);
        const diffText = diffPercent !== null ? `${diffPercent > 0 ? '+' : ''}${nf(diffPercent, 1)}%` : 'â€”';
        
        rows.push(`<tr>
            <td>${label}</td>
            <td>${Number.isFinite(currVal) ? nf(currVal) + unit : 'â€”'}</td>
            <td>${Number.isFinite(refVal) ? nf(refVal) + unit : 'â€”'}</td>
            <td>${diffText}</td>
            <td class="${status.class}">${status.text}</td>
        </tr>`);
    };
    
    // ===== MÃ‰TRICAS PRINCIPAIS =====
    addRow('Loudness (LUFS Integrado)', currTech.lufsIntegrated || currTech.lufs_integrated, 
           refTech.lufsIntegrated || refTech.lufs_integrated, ' LUFS', 5);
    
    addRow('True Peak (dBTP)', currTech.truePeakDbtp || currTech.true_peak_dbtp,
           refTech.truePeakDbtp || refTech.true_peak_dbtp, ' dBTP', 10);
    
    addRow('Dynamic Range (dB)', currTech.dynamicRange || currTech.dynamic_range,
           refTech.dynamicRange || refTech.dynamic_range, ' dB', 15);
    
    addRow('LRA (LU)', currTech.lra, refTech.lra, ' LU', 15);
    
    addRow('Stereo Correlation', currTech.stereoCorrelation || currTech.stereo_correlation,
           refTech.stereoCorrelation || refTech.stereo_correlation, '', 8);
    
    addRow('Spectral Centroid (Hz)', currTech.spectralCentroidHz || currTech.spectral_centroid,
           refTech.spectralCentroidHz || refTech.spectral_centroid, ' Hz', 10);
    
    // ===== BANDAS ESPECTRAIS =====
    const currBands = currTech.spectral_balance || {};
    const refBands = refTech.spectral_balance || {};
    
    const bandNames = {
        sub: 'Sub (20-60Hz)',
        bass: 'Bass (60-150Hz)',
        lowMid: 'Low-Mid (150-500Hz)',
        mid: 'Mid (500-2kHz)',
        highMid: 'High-Mid (2-5kHz)',
        presence: 'Presence (5-10kHz)',
        air: 'Air (10-20kHz)'
    };
    
    Object.entries(bandNames).forEach(([key, name]) => {
        const currVal = currBands[key]?.percentage;
        const refVal = refBands[key]?.percentage;
        if (Number.isFinite(currVal) && Number.isFinite(refVal)) {
            addRow(name, currVal, refVal, '%', 10);
        }
    });
    
    // Calcular scores comparativos
    const refScore = ref.score || 0;
    const currScore = curr.score || 0;
    const scoreDiff = currScore - refScore;
    
    // ğŸ¯ FIX: Extrair nomes reais das faixas COM fallback robusto
    // Helper para remover extensÃ£o de arquivo
    const removeExtension = (filename) => {
        if (!filename) return null;
        return filename.replace(/\.[^/.]+$/, '');
    };
    
    // Extrair nome da primeira faixa (BASE/ALVO) - mÃºltiplas fontes
    const refFileName = removeExtension(
        ref.metadata?.fileName || 
        ref.fileName || 
        window.SoundyAI_Store?.first?.fileName ||
        window.SoundyAI_Store?.first?.metadata?.fileName ||
        window.__soundyState?.reference?.userAnalysis?.fileName ||
        window.__soundyState?.reference?.userAnalysis?.metadata?.fileName
    ) || 'Faixa 1';
    
    // Extrair nome da segunda faixa (ATUAL/COMPARADA) - mÃºltiplas fontes
    const currFileName = removeExtension(
        curr.metadata?.fileName || 
        curr.fileName || 
        window.SoundyAI_Store?.second?.fileName ||
        window.SoundyAI_Store?.second?.metadata?.fileName ||
        window.__soundyState?.reference?.referenceAnalysis?.fileName ||
        window.__soundyState?.reference?.referenceAnalysis?.metadata?.fileName
    ) || 'Faixa 2';
    
    log('ğŸ¯ [TRACK-NAMES-FIX] Nomes extraÃ­dos:', { refFileName, currFileName });
    
    // Montar HTML da tabela
    // ğŸ¯ LABELS DINÃ‚MICOS: Primeira faixa = BASE/ALVO, Segunda faixa = ATUAL
    container.innerHTML = `
        <div class="card" style="margin-top:12px;">
            <div class="card-title">ğŸµ COMPARAÃ‡ÃƒO ENTRE FAIXAS (Modo Reference)</div>
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 12px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA BASE (1Âª - ALVO)</div>
                        <div style="font-weight: 600; font-size: 14px;" title="${refFileName}">
                            ${refFileName}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: #52f7ad;">${nf(refScore, 0)}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA DE REFERÃŠNCIA (2Âª - ATUAL)</div>
                        <div style="font-weight: 600; font-size: 14px;" title="${currFileName}">
                            ${currFileName}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: ${scoreDiff >= 0 ? '#52f7ad' : '#ff7b7b'};">${nf(currScore, 0)}</span>
                            <span style="opacity: 0.7; margin-left: 4px;">(${scoreDiff > 0 ? '+' : ''}${nf(scoreDiff, 0)})</span>
                        </div>
                    </div>
                </div>
            </div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>MÃ©trica</th>
                    <th>FAIXA 1</th>
                    <th>FAIXA 2</th>
                    <th>DiferenÃ§a (%)</th>
                    <th>Status</th>
                </tr></thead>
                <tbody>${rows.join('')}</tbody>
            </table>
        </div>
    `;
    
    // ğŸ¯ AUDIT_REF_FIX: Log final de confirmaÃ§Ã£o do fluxo A/B
    // ğŸ”’ GUARD: SÃ³ executar logs de referÃªncia se viewMode === "reference"
    if (getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        log('âœ… [TRACK-COMPARE] Tabela comparativa renderizada com sucesso');
        log('[REFERENCE-A/B FIXED âœ…] ComparaÃ§Ã£o A/B entre faixas concluÃ­da');
        log('[AUDIT_REF_FIX] Tabela exibindo valores brutos da segunda faixa (referÃªncia real)');
        log('[MODE LOCKED] reference - renderizaÃ§Ã£o completa sem alteraÃ§Ã£o de modo');
        
        // ğŸ‰ LOG FINAL DE AUDITORIA
        log("âœ… [REFERENCE-A/B FIXED] ComparaÃ§Ã£o renderizada sem erros.");
        log("âœ… [AUDITORIA_FINAL_RENDER_REF] Render concluÃ­do com sucesso.");
    } else {
        log('[REFERENCE-GUARD] ğŸš« Logs de referÃªncia bloqueados (viewMode:', getViewMode(), ')');
    }
    
    // ğŸ¯ VALIDAÃ‡ÃƒO FINAL PÃ“S-FIX
    const validationData = {
        userTrack: ref.metadata?.fileName || ref.fileName || 'Primeira Faixa',
        refTrack: curr.metadata?.fileName || curr.fileName || 'Segunda Faixa',
        userLUFS: ref.technicalData?.lufsIntegrated || ref.technicalData?.lufs_integrated || 'N/A',
        refLUFS: curr.technicalData?.lufsIntegrated || curr.technicalData?.lufs_integrated || 'N/A',
        userDR: ref.technicalData?.dynamicRange || ref.technicalData?.dynamic_range || 'N/A',
        refDR: curr.technicalData?.dynamicRange || curr.technicalData?.dynamic_range || 'N/A',
        userPeak: ref.technicalData?.truePeakDbtp || ref.technicalData?.true_peak_dbtp || 'N/A',
        refPeak: curr.technicalData?.truePeakDbtp || curr.technicalData?.true_peak_dbtp || 'N/A',
        render: 'concluÃ­do sem erros'
    };
    
    log('âœ… [VALIDAÃ‡ÃƒO-FINAL] Modal Reference OK:', validationData);
    
    // âœ… Libera lock apÃ³s renderizaÃ§Ã£o
    window.comparisonLock = false;
    log("[LOCK] comparisonLock liberado");
    
    // ğŸš« OCULTAR BOTÃƒO "PLANO DE CORREÃ‡ÃƒO" NO MODO REFERÃŠNCIA
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan) {
        btnCorrectionPlan.style.display = 'none';
        log('[REFERENCE-UI] ğŸ”’ BotÃ£o "Plano de CorreÃ§Ã£o" ocultado no modo referÃªncia');
    }
    
    console.groupEnd();
}

// ğŸ¯ ===== SISTEMA DE SCORING AVANÃ‡ADO =====
// Sistema completo de pontuaÃ§Ã£o por categorias com adaptaÃ§Ã£o por gÃªnero

// 1. PESOS POR GÃŠNERO (ATUALIZADOS CONFORME ESPECIFICAÃ‡ÃƒO)
const GENRE_SCORING_WEIGHTS = {
    // Funk Mandela - Foco em Loudness e DinÃ¢mica
    'funk_mandela': {
        loudness: 0.32,    // Loudness crÃ­tico no funk
        dinamica: 0.23,    // DinÃ¢mica importante
        frequencia: 0.20,  // FrequÃªncia equilibrada
        estereo: 0.15,     // EstÃ©reo moderado
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Funk Automotivo (similar ao Mandela)
    'funk_automotivo': {
        loudness: 0.32,
        dinamica: 0.23,
        frequencia: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Trap/Trance - Foco em Loudness e FrequÃªncia
    'trap': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.20,     // EstÃ©reo importante
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    'trance': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.20,     // EstÃ©reo importante
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // EletrÃ´nico - Foco em FrequÃªncia e EstÃ©reo
    'eletronico': {
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.25,     // EstÃ©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Funk Bruxaria - Similar ao EletrÃ´nico
    'funk_bruxaria': {
        frequencia: 0.30,  // FrequÃªncia crÃ­tica
        estereo: 0.25,     // EstÃ©reo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // DinÃ¢mica moderada
        tecnico: 0.10      // TÃ©cnico bÃ¡sico
    },
    
    // Hip Hop - Balanceado entre FrequÃªncia e DinÃ¢mica
    'hip_hop': {
        frequencia: 0.30,
        dinamica: 0.25,
        loudness: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Pesos padrÃ£o (fallback) - DistribuiÃ§Ã£o equilibrada
    'default': {
        loudness: 0.25,
        frequencia: 0.25,
        dinamica: 0.20,
        estereo: 0.15,
        tecnico: 0.15
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FONTE ÃšNICA DA VERDADE: Usar targets normalizados do backend
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸš¨ TRUE_PEAK_HARD_CAP jÃ¡ definida no inÃ­cio do arquivo (linha ~10)
// NÃƒO redefinir aqui para evitar erro de declaraÃ§Ã£o duplicada

/**
 * ğŸ¯ getNormalizedTargetsFromAnalysis - Extrai targets normalizados do resultado do backend
 * 
 * PRIORIDADE (FONTE ÃšNICA DA VERDADE):
 * 1. analysis.data.targetProfile (NOVO - estrutura completa com tp_min, tp_max, etc)
 * 2. analysis.data.referenceTargetsNormalized (formato anterior)
 * 3. Fallback: retornar null (frontend usarÃ¡ getMetricBounds como Ãºltimo recurso)
 * 
 * âŒ PROIBIDO: Fallbacks para PROD_AI_REF_DATA, __activeRefData, etc.
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise retornado pelo backend
 * @returns {Object|null} Targets normalizados { metrics: {...}, bands: {...}, preCalculatedSeverities: {...} }
 */
function getNormalizedTargetsFromAnalysis(analysis) {
    // ğŸ¯ PRIORIDADE 1: targetProfile (NOVO - estrutura completa)
    if (analysis?.data?.targetProfile) {
        log('[NORMALIZED-TARGETS] âœ… Usando targetProfile do backend (FONTE ÃšNICA)');
        log('[NORMALIZED-TARGETS] Genre:', analysis.data.targetProfile._genre);
        
        // Converter targetProfile para formato compatÃ­vel com cÃ³digo existente
        const tp = analysis.data.targetProfile;
        return {
            metrics: {
                lufs: tp.lufs ? { ...tp.lufs, target: tp.lufs.target } : null,
                truePeak: tp.truePeak ? { 
                    min: tp.truePeak.tp_min,
                    max: tp.truePeak.tp_max,
                    target: tp.truePeak.tp_target,
                    warnFrom: tp.truePeak.tp_warn_from,
                    hardCap: tp.truePeak.tp_max
                } : null,
                dr: tp.dr ? { ...tp.dr, target: tp.dr.target } : null,
                lra: tp.lra,
                stereo: tp.stereo
            },
            bands: tp.bands,
            preCalculatedSeverities: tp.preCalculatedSeverities,
            _source: 'targetProfile',
            _genre: tp._genre
        };
    }
    
    // ğŸ¯ PRIORIDADE 2: referenceTargetsNormalized (formato anterior)
    if (analysis?.data?.referenceTargetsNormalized) {
        log('[NORMALIZED-TARGETS] âœ… Usando referenceTargetsNormalized do backend');
        return {
            ...analysis.data.referenceTargetsNormalized,
            _source: 'referenceTargetsNormalized'
        };
    }
    
    // ğŸ”„ FALLBACK: Se backend nÃ£o enviou, retornar null (frontend usarÃ¡ getMetricBounds)
    // âŒ REMOVIDO: Fallbacks para PROD_AI_REF_DATA, __activeRefData, etc.
    log('[NORMALIZED-TARGETS] âš ï¸ Backend nÃ£o enviou targetProfile nem referenceTargetsNormalized');
    return null;
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ¯ evaluateMetricFromTargetProfile - FUNÃ‡ÃƒO CENTRALIZADA DE AVALIAÃ‡ÃƒO
 * 
 * Esta funÃ§Ã£o DEVE ser usada por:
 *   1) Tabela de comparaÃ§Ã£o (status, aÃ§Ã£o)
 *   2) Score (pontuaÃ§Ã£o)
 *   3) Builder de sugestÃµes (severidade, delta)
 * 
 * GARANTE: mesma avaliaÃ§Ã£o em todos os lugares, sem divergÃªncias.
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * @param {string} metricKey - 'truePeak', 'lufs', 'dr', 'stereo'
 * @param {number} value - Valor medido
 * @param {Object} targetProfile - Objeto targetProfile do backend
 * @returns {Object} { severity, severityClass, action, diff, isCritical, isWithinRange }
 */
function evaluateMetricFromTargetProfile(metricKey, value, targetProfile) {
    if (!Number.isFinite(value)) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    if (!targetProfile) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem targets', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // ğŸ¯ PRIORIDADE 1: Usar severidade prÃ©-calculada do backend
    const preCalc = targetProfile.preCalculatedSeverities?.[metricKey] 
                 || targetProfile.preCalculatedSeverities?.metrics?.[metricKey];
    if (preCalc) {
        return {
            severity: preCalc.severity,
            severityClass: preCalc.severity === 'CRÃTICA' ? 'critical' : 
                          preCalc.severity === 'ALTA' ? 'high' :
                          preCalc.severity === 'ATENÃ‡ÃƒO' ? 'caution' : 'ok',
            action: preCalc.action,
            diff: preCalc.delta || 0,
            isCritical: preCalc.isCritical || preCalc.severity === 'CRÃTICA',
            isWithinRange: preCalc.severity === 'OK'
        };
    }
    
    // ğŸ”„ FALLBACK: Calcular localmente usando targetProfile
    const metric = targetProfile[metricKey] || targetProfile.metrics?.[metricKey];
    if (!metric) {
        return { severity: 'N/A', severityClass: 'na', action: 'MÃ©trica nÃ£o encontrada', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // ğŸš¨ REGRA ESPECIAL TRUE PEAK: valor > 0 dBTP = SEMPRE CRÃTICA
    // ğŸ”§ FIX: AÃ§Ã£o usa deltaToTarget (nÃ£o hardCap) para consistÃªncia com coluna "DiferenÃ§a"
    if (metricKey === 'truePeak') {
        const tpMax = metric.tp_max ?? metric.max ?? TRUE_PEAK_HARD_CAP;
        const tpTarget = metric.tp_target ?? metric.target ?? -1.0;  // âœ… SSOT: target do gÃªnero
        
        if (value > tpMax) {
            const deltaToTarget = value - tpTarget;  // âœ… SSOT: sempre usa target do gÃªnero
            return {
                severity: 'CRÃTICA',
                severityClass: 'critical',
                action: `ğŸ”´ CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dBTP`,
                diff: deltaToTarget,
                isCritical: true,
                isWithinRange: false
            };
        }
        
        // Verificar warn_from
        // ğŸ”§ FIX: AÃ§Ã£o usa deltaToTarget (nÃ£o warnFrom) para consistÃªncia com coluna "DiferenÃ§a"
        const warnFrom = metric.tp_warn_from ?? metric.warnFrom;
        if (warnFrom != null && value > warnFrom) {
            const deltaToTarget = value - tpTarget;  // âœ… SSOT: sempre usa target do gÃªnero
            return {
                severity: 'ALTA',
                severityClass: 'high',
                action: `âš ï¸ PrÃ³ximo do limite. Reduzir ${deltaToTarget.toFixed(2)} dBTP`,
                diff: deltaToTarget,
                isCritical: false,
                isWithinRange: false
            };
        }
        
        // Verificar se estÃ¡ abaixo do mÃ­nimo
        const tpMin = metric.tp_min ?? metric.min ?? -3;
        if (value < tpMin) {
            return {
                severity: 'ATENÃ‡ÃƒO',
                severityClass: 'caution',
                action: `â„¹ï¸ Muito baixo. Pode aumentar atÃ© ${(tpMin - value).toFixed(1)} dBTP`,
                diff: value - tpMin,
                isCritical: false,
                isWithinRange: false
            };
        }
        
        // OK: Dentro do range
        return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff: 0, isCritical: false, isWithinRange: true };
    }
    
    // ğŸ¯ OUTRAS MÃ‰TRICAS: LÃ³gica padrÃ£o de range [min, max]
    const min = metric.min;
    const max = metric.max;
    const target = metric.target;
    
    if (min == null || max == null) {
        return { severity: 'N/A', severityClass: 'na', action: 'Range nÃ£o definido', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // OK: Dentro do range
    if (value >= min && value <= max) {
        return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff: 0, isCritical: false, isWithinRange: true };
    }
    
    // Fora do range: calcular distÃ¢ncia
    const tolerance = (max - min) / 2;
    let diff, absDelta;
    
    if (value < min) {
        diff = value - min; // negativo
        absDelta = min - value;
    } else {
        diff = value - max; // positivo
        absDelta = value - max;
    }
    
    const actionVerb = diff > 0 ? 'Reduzir' : 'Aumentar';
    const unit = metricKey === 'lufs' ? 'LUFS' : metricKey === 'dr' ? 'dB' : '';
    
    if (absDelta <= tolerance) {
        return {
            severity: 'ATENÃ‡ÃƒO',
            severityClass: 'caution',
            action: `âš ï¸ ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: false,
            isWithinRange: false
        };
    } else if (absDelta <= tolerance * 2) {
        return {
            severity: 'ALTA',
            severityClass: 'high',
            action: `ğŸŸ¡ ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: false,
            isWithinRange: false
        };
    } else {
        return {
            severity: 'CRÃTICA',
            severityClass: 'critical',
            action: `ğŸ”´ ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: true,
            isWithinRange: false
        };
    }
}

// Expor globalmente para uso em outros scripts
window.evaluateMetricFromTargetProfile = evaluateMetricFromTargetProfile;

/**
 * ğŸ¯ getSeverityFromNormalized - ObtÃ©m severidade prÃ©-calculada do backend
 * 
 * @param {Object} normalizedTargets - Targets normalizados do backend
 * @param {string} metricKey - Chave da mÃ©trica ('lufs', 'truePeak', 'dr', 'stereo')
 * @returns {Object|null} { severity, delta, action }
 */
function getSeverityFromNormalized(normalizedTargets, metricKey) {
    if (!normalizedTargets?.preCalculatedSeverities) {
        return null;
    }
    
    // ğŸ¯ NOVA ESTRUTURA: preCalculatedSeverities.metrics.{metricKey}
    if (normalizedTargets.preCalculatedSeverities.metrics?.[metricKey]) {
        return normalizedTargets.preCalculatedSeverities.metrics[metricKey];
    }
    
    // ğŸ”„ FALLBACK: Estrutura antiga (preCalculatedSeverities.{metricKey})
    return normalizedTargets.preCalculatedSeverities[metricKey] || null;
}

/**
 * ğŸ¯ getBandSeverityFromNormalized - ObtÃ©m severidade prÃ©-calculada de banda do backend
 * 
 * @param {Object} normalizedTargets - Targets normalizados do backend
 * @param {string} bandKey - Chave da banda ('sub', 'bass', 'lowMid', etc)
 * @returns {Object|null} { severity, delta, action }
 */
function getBandSeverityFromNormalized(normalizedTargets, bandKey) {
    if (!normalizedTargets?.preCalculatedSeverities?.bands) {
        return null;
    }
    return normalizedTargets.preCalculatedSeverities.bands[bandKey] || null;
}

/**
 * ğŸ¯ calculateTruePeakSeverityLocal - Calcula severidade de True Peak localmente
 * 
 * REGRA OBRIGATÃ“RIA: truePeak > 0 dBTP = SEMPRE CRÃTICA
 * 
 * @param {number} value - Valor de True Peak em dBTP
 * @param {Object} targets - Targets (normalizados ou legados)
 * @returns {Object} { severity, severityClass, action, diff, isCritical }
 */
function calculateTruePeakSeverityLocal(value, targets) {
    if (!Number.isFinite(value)) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
    }
    
    // âœ… SSOT: Extrair target do gÃªnero PRIMEIRO
    let tpTarget = -1.0; // fallback padrÃ£o
    if (targets?.metrics?.truePeak?.target != null) {
        tpTarget = targets.metrics.truePeak.target;
    } else if (targets?.truePeak?.target != null) {
        tpTarget = targets.truePeak.target;
    } else if (targets?.true_peak_target != null) {
        tpTarget = targets.true_peak_target;
    }
    
    // ğŸš¨ REGRA ABSOLUTA: True Peak > 0 dBTP = CRÃTICA
    // ğŸ”§ FIX: AÃ§Ã£o usa deltaToTarget (nÃ£o hardCap) para consistÃªncia com coluna "DiferenÃ§a"
    if (value > TRUE_PEAK_HARD_CAP) {
        const deltaToTarget = value - tpTarget;  // âœ… SSOT: sempre usa target do gÃªnero
        return {
            severity: 'CRÃTICA',
            severityClass: 'critical',
            action: `ğŸ”´ CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dB`,
            diff: deltaToTarget,
            isCritical: true
        };
    }
    
    // Extrair bounds dos targets
    let min, max, warnFrom;
    
    // Tentar extrair do formato normalizado (backend)
    if (targets?.metrics?.truePeak) {
        const tp = targets.metrics.truePeak;
        min = tp.min;
        max = Math.min(tp.max, TRUE_PEAK_HARD_CAP); // Garantir hard cap
        warnFrom = tp.warnFrom;
    } 
    // Fallback: formato legado
    else if (targets?.truePeak) {
        min = targets.truePeak.min ?? (targets.truePeak.target - targets.truePeak.tolerance);
        max = Math.min(targets.truePeak.max ?? 0, TRUE_PEAK_HARD_CAP);
        warnFrom = targets.truePeak.warnFrom;
    }
    // Fallback: campos flat (true_peak_min, etc)
    else {
        const tpTarget = targets?.true_peak_target ?? -1.0;
        const tpTol = targets?.tol_true_peak ?? 0.5;
        min = targets?.true_peak_min ?? (tpTarget - tpTol);
        max = Math.min(targets?.true_peak_max ?? 0, TRUE_PEAK_HARD_CAP);
        warnFrom = targets?.true_peak_warn_from;
    }
    
    // ATENÃ‡ÃƒO: Na zona de warning
    // ğŸ”§ FIX: AÃ§Ã£o usa deltaToTarget (nÃ£o warnFrom) para consistÃªncia com coluna "DiferenÃ§a"
    if (warnFrom !== null && warnFrom !== undefined && value > warnFrom) {
        const deltaToTarget = value - tpTarget;  // âœ… SSOT: sempre usa target do gÃªnero
        return {
            severity: 'ATENÃ‡ÃƒO',
            severityClass: 'caution',
            action: `âš ï¸ PrÃ³ximo do limite. Reduzir ${deltaToTarget.toFixed(2)} dB`,
            diff: deltaToTarget
        };
    }
    
    // ATENÃ‡ÃƒO: Abaixo do mÃ­nimo
    if (min !== undefined && value < min) {
        const delta = min - value;
        return {
            severity: 'ATENÃ‡ÃƒO',
            severityClass: 'caution',
            action: `âš ï¸ Muito baixo. Pode aumentar atÃ© ${delta.toFixed(1)} dB`,
            diff: -delta
        };
    }
    
    // OK: Dentro do range ou aceitÃ¡vel
    return { severity: 'OK', severityClass: 'ok', action: 'âœ… Dentro do padrÃ£o', diff: 0 };
}

// Expor funÃ§Ãµes globalmente
if (typeof window !== 'undefined') {
    window.getNormalizedTargetsFromAnalysis = getNormalizedTargetsFromAnalysis;
    window.getSeverityFromNormalized = getSeverityFromNormalized;
    window.getBandSeverityFromNormalized = getBandSeverityFromNormalized;
    window.calculateTruePeakSeverityLocal = calculateTruePeakSeverityLocal;
    window.TRUE_PEAK_HARD_CAP = TRUE_PEAK_HARD_CAP;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SISTEMA DE BOUNDS MIN/MAX PARA MÃ‰TRICAS (NOVO - SUPORTE A RANGE ASSIMÃ‰TRICO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ”§ getMetricBounds - ObtÃ©m os limites [min, max] de uma mÃ©trica
 * 
 * PRIORIDADE:
 * 1. Se existir ${metricKey}_min e ${metricKey}_max (ambos finitos) â†’ usar eles
 * 2. SenÃ£o, usar ${metricKey}_target Â± tol_${metricKey} (fallback legado)
 * 
 * @param {Object} refData - Dados de referÃªncia do gÃªnero
 * @param {string} metricKey - Chave da mÃ©trica (ex: 'lufs', 'true_peak', 'dr')
 * @returns {Object} { min, max, target, mode: 'minmax' | 'tolerance', warnFrom?: number }
 */
function getMetricBounds(refData, metricKey) {
    if (!refData) {
        warn(`[METRIC-BOUNDS] refData Ã© null/undefined para ${metricKey}`);
        return null;
    }
    
    // Construir nomes das propriedades
    const minKey = `${metricKey}_min`;
    const maxKey = `${metricKey}_max`;
    const targetKey = `${metricKey}_target`;
    const tolKey = `tol_${metricKey}`;
    const warnFromKey = `${metricKey}_warn_from`;
    
    const minValue = refData[minKey];
    const maxValue = refData[maxKey];
    const targetValue = refData[targetKey];
    const tolerance = refData[tolKey];
    const warnFrom = refData[warnFromKey];
    
    // PRIORIDADE 1: min/max explÃ­citos
    if (Number.isFinite(minValue) && Number.isFinite(maxValue)) {
        const bounds = {
            min: minValue,
            max: maxValue,
            target: Number.isFinite(targetValue) ? targetValue : (minValue + maxValue) / 2,
            mode: 'minmax'
        };
        
        // Adicionar warn_from se existir (Ãºtil para True Peak)
        if (Number.isFinite(warnFrom)) {
            bounds.warnFrom = warnFrom;
        }
        
        log(`[METRIC-BOUNDS] ${metricKey}: usando min/max explÃ­citos [${bounds.min}, ${bounds.max}]`, bounds);
        return bounds;
    }
    
    // PRIORIDADE 2: target Â± tolerance (fallback legado)
    if (Number.isFinite(targetValue) && Number.isFinite(tolerance) && tolerance > 0) {
        const bounds = {
            min: targetValue - tolerance,
            max: targetValue + tolerance,
            target: targetValue,
            mode: 'tolerance'
        };
        
        log(`[METRIC-BOUNDS] ${metricKey}: usando target Â± tolerance [${bounds.min}, ${bounds.max}]`, bounds);
        return bounds;
    }
    
    warn(`[METRIC-BOUNDS] ${metricKey}: nenhum bound vÃ¡lido encontrado`, {
        minKey, minValue,
        maxKey, maxValue,
        targetKey, targetValue,
        tolKey, tolerance
    });
    return null;
}

/**
 * ğŸ¯ calculateMetricScoreWithBounds - Calcula score usando min/max (range assimÃ©trico)
 * 
 * REGRAS:
 * - Valor dentro de [min, max] â†’ 100 pontos
 * - Valor fora do range â†’ penalizaÃ§Ã£o proporcional Ã  distÃ¢ncia
 * - Para True Peak: valor > max (0 dBTP) â†’ score muito baixo (CRÃTICO)
 * 
 * @param {number} actualValue - Valor medido
 * @param {Object} bounds - { min, max, target, mode, warnFrom? }
 * @param {Object} options - { isCriticalAboveMax?: boolean, metricKey?: string }
 * @returns {Object} { score: number, status: 'OK'|'WARNING'|'CRITICAL', delta: number }
 */
function calculateMetricScoreWithBounds(actualValue, bounds, options = {}) {
    if (!Number.isFinite(actualValue) || !bounds) {
        return { score: null, status: 'UNKNOWN', delta: 0 };
    }
    
    const { min, max, target, warnFrom } = bounds;
    const { isCriticalAboveMax = false, metricKey = 'unknown' } = options;
    
    // Calcular delta em relaÃ§Ã£o ao range
    let delta = 0;
    let status = 'OK';
    let score = 100;
    
    // Valor dentro do range â†’ OK (100 pontos)
    if (actualValue >= min && actualValue <= max) {
        // Verificar se estÃ¡ na zona de warning (para True Peak)
        if (Number.isFinite(warnFrom) && actualValue >= warnFrom) {
            status = 'WARNING';
            // Pequena penalizaÃ§Ã£o para valores na zona de aviso
            const warnRange = max - warnFrom;
            const distFromWarn = actualValue - warnFrom;
            const warnPenalty = Math.min(15, (distFromWarn / warnRange) * 15);
            score = Math.round(100 - warnPenalty);
        } else {
            status = 'OK';
            score = 100;
        }
        
        log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} estÃ¡ dentro de [${min}, ${max}] â†’ ${score}% (${status})`);
        return { score, status, delta: 0 };
    }
    
    // Valor ACIMA do mÃ¡ximo
    if (actualValue > max) {
        delta = actualValue - max;
        
        // True Peak acima de 0 dBTP Ã© CRÃTICO
        if (isCriticalAboveMax || metricKey === 'true_peak') {
            status = 'CRITICAL';
            // PenalizaÃ§Ã£o severa para True Peak acima do limite
            const criticalPenalty = Math.min(80, delta * 40); // -40 pontos por dB acima
            score = Math.max(0, Math.round(100 - criticalPenalty));
            log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} ACIMA de max=${max} â†’ CRÃTICO (${score}%)`);
        } else {
            // PenalizaÃ§Ã£o normal para outras mÃ©tricas
            const rangeWidth = max - min;
            const tolerance = rangeWidth > 0 ? rangeWidth / 2 : 1;
            const ratio = delta / tolerance;
            
            if (ratio <= 1) {
                status = 'WARNING';
                score = Math.round(100 - (ratio * 20));
            } else if (ratio <= 2) {
                status = 'WARNING';
                score = Math.round(80 - ((ratio - 1) * 30));
            } else {
                status = 'CRITICAL';
                score = Math.max(20, Math.round(50 - ((ratio - 2) * 15)));
            }
            log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} acima de max=${max} (delta=${delta.toFixed(2)}) â†’ ${score}% (${status})`);
        }
        
        return { score, status, delta };
    }
    
    // Valor ABAIXO do mÃ­nimo
    if (actualValue < min) {
        delta = min - actualValue;
        const rangeWidth = max - min;
        const tolerance = rangeWidth > 0 ? rangeWidth / 2 : 1;
        const ratio = delta / tolerance;
        
        if (ratio <= 1) {
            status = 'WARNING';
            score = Math.round(100 - (ratio * 20));
        } else if (ratio <= 2) {
            status = 'WARNING';
            score = Math.round(80 - ((ratio - 1) * 30));
        } else {
            status = 'CRITICAL';
            score = Math.max(20, Math.round(50 - ((ratio - 2) * 15)));
        }
        
        log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} abaixo de min=${min} (delta=${delta.toFixed(2)}) â†’ ${score}% (${status})`);
        return { score, status, delta: -delta };
    }
    
    return { score, status, delta };
}

/**
 * ğŸ¯ calculateMetricScoreAuto - Wrapper que escolhe automaticamente entre bounds e tolerance
 * 
 * @param {number} actualValue - Valor medido
 * @param {Object} refData - Dados de referÃªncia do gÃªnero
 * @param {string} metricKey - Chave da mÃ©trica (ex: 'lufs', 'true_peak', 'dr')
 * @param {Object} options - OpÃ§Ãµes adicionais
 * @returns {number|null} Score (0-100) ou null se invÃ¡lido
 */
function calculateMetricScoreAuto(actualValue, refData, metricKey, options = {}) {
    const bounds = getMetricBounds(refData, metricKey);
    
    if (bounds) {
        const result = calculateMetricScoreWithBounds(actualValue, bounds, { 
            ...options, 
            metricKey,
            isCriticalAboveMax: metricKey === 'true_peak'
        });
        return result.score;
    }
    
    // Fallback para cÃ¡lculo antigo se nÃ£o conseguir extrair bounds
    warn(`[SCORE-AUTO] ${metricKey}: usando fallback calculateMetricScore`);
    const targetKey = `${metricKey}_target`;
    const tolKey = `tol_${metricKey}`;
    return calculateMetricScore(actualValue, refData[targetKey], refData[tolKey]);
}

// Expor funÃ§Ãµes globalmente para uso em outros mÃ³dulos
if (typeof window !== 'undefined') {
    window.getMetricBounds = getMetricBounds;
    window.calculateMetricScoreWithBounds = calculateMetricScoreWithBounds;
    window.calculateMetricScoreAuto = calculateMetricScoreAuto;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 2. FUNÃ‡ÃƒO PARA CALCULAR SCORE DE UMA MÃ‰TRICA (VERSÃƒO MENOS PUNITIVA - LEGADO)
function calculateMetricScore(actualValue, targetValue, tolerance) {
    // Verificar se temos valores vÃ¡lidos
    if (!Number.isFinite(actualValue) || !Number.isFinite(targetValue) || !Number.isFinite(tolerance) || tolerance <= 0) {
        try {
            log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff: 'N/A (validaÃ§Ã£o falhou)',
                tolerance,
                result: null,
                condition: 'validaÃ§Ã£o falhou',
                reason: !Number.isFinite(actualValue) ? 'actualValue invÃ¡lido' : 
                        !Number.isFinite(targetValue) ? 'targetValue invÃ¡lido' : 
                        !Number.isFinite(tolerance) ? 'tolerance invÃ¡lido' : 
                        'tolerance <= 0'
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'calculateMetricScore (validaÃ§Ã£o)', err);
        }
        return null; // MÃ©trica invÃ¡lida
    }
    
    const diff = Math.abs(actualValue - targetValue);
    
    // ğŸ¯ DENTRO DA TOLERÃ‚NCIA = 100 pontos
    if (diff <= tolerance) {
        try {
            log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff,
                tolerance,
                result: 100,
                condition: 'diff <= tolerance',
                ratio: diff / tolerance
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'calculateMetricScore (dentro tolerÃ¢ncia)', err);
        }
        return 100;
    }
    
    // ğŸ¯ CURVA DE PENALIZAÃ‡ÃƒO MAIS JUSTA - GRADUAL E MENOS PUNITIVA
    // Î” atÃ© 1.5x tolerÃ¢ncia â†’ ~80
    // Î” atÃ© 2x tolerÃ¢ncia â†’ ~60  
    // Î” atÃ© 3x tolerÃ¢ncia â†’ ~40
    // Î” acima de 3x tolerÃ¢ncia â†’ ~20 (nunca zerar)
    
    const ratio = diff / tolerance;
    let result;
    
    if (ratio <= 1.5) {
        // Entre 1x e 1.5x tolerÃ¢ncia: decaimento suave de 100 para 80
        result = Math.round(100 - ((ratio - 1) * 40)); // 100 - (0.5 * 40) = 80 no mÃ¡ximo
    } else if (ratio <= 2.0) {
        // Entre 1.5x e 2x tolerÃ¢ncia: de 80 para 60
        result = Math.round(80 - ((ratio - 1.5) * 40)); // 80 - (0.5 * 40) = 60 no mÃ¡ximo
    } else if (ratio <= 3.0) {
        // Entre 2x e 3x tolerÃ¢ncia: de 60 para 40
        result = Math.round(60 - ((ratio - 2) * 20)); // 60 - (1 * 20) = 40 no mÃ¡ximo
    } else {
        // Acima de 3x tolerÃ¢ncia: 20 (nunca zerar totalmente)
        result = 20;
    }
    
    try {
        log('[AUDIT-SCORE]', {
            func: 'calculateMetricScore',
            value: actualValue,
            target: targetValue,
            diff,
            tolerance,
            result,
            condition: 'diff > tolerance',
            ratio,
            penaltyLevel: ratio <= 1.5 ? '1-1.5x' : ratio <= 2.0 ? '1.5-2x' : ratio <= 3.0 ? '2-3x' : '>3x'
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateMetricScore (penalizaÃ§Ã£o)', err);
    }
    
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ V3.7 UNIFIED SCORING ENGINE - SINGLE SOURCE OF TRUTH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ¯ TIPO DE MÃ‰TRICA: Define como avaliar cada mÃ©trica
 * 
 * CEILING: truePeak, samplePeak, clipping
 *   - target = valor ideal (ex: -1.0 dBTP)
 *   - max = hard cap absoluto (ex: 0 dBTP)
 *   - Qualquer value > target Ã© penalizado
 *   - value > max Ã© CRÃTICO SEVERO
 * 
 * BANDPASS: lufs, dr, lra, crest, correlation, width, bandas
 *   - target = valor ideal no centro
 *   - score 100 apenas no target, decai conforme distÃ¢ncia
 *   - range [min, max] define zona aceitÃ¡vel (score >= 85)
 */
const METRIC_TYPE = {
    truePeak: 'CEILING',
    samplePeak: 'CEILING',
    clipping: 'CEILING',
    dcOffset: 'CEILING',
    lufs: 'BANDPASS',
    rms: 'BANDPASS',
    dr: 'BANDPASS',
    lra: 'BANDPASS',
    crest: 'BANDPASS',
    correlation: 'BANDPASS',
    width: 'BANDPASS',
    // Bandas sÃ£o BANDPASS
    sub: 'BANDPASS',
    bass: 'BANDPASS',
    lowMid: 'BANDPASS',
    mid: 'BANDPASS',
    highMid: 'BANDPASS',
    air: 'BANDPASS',
    presence: 'BANDPASS'
};

/**
 * ğŸ“Š FUNÃ‡ÃƒO CANÃ”NICA: evaluateMetric V3.7
 * 
 * Esta Ã© a ÃšNICA funÃ§Ã£o que deve ser usada para avaliar mÃ©tricas em:
 * - Tabela (buildMetricRows)
 * - Subscores
 * - Gates
 * - SugestÃµes
 * 
 * REGRAS V3.7:
 * 1. CEILING (truePeak, clipping): target Ã© TETO. value > target = penalizado
 * 2. BANDPASS (lufs, dr, bandas): target Ã© CENTRO. distÃ¢ncia do target = penalizado
 * 3. Para CEILING: max Ã© hard cap (ex: 0 dBTP), mas target (-1 dBTP) Ã© o ideal
 * 4. Severidade baseada na distÃ¢ncia do TARGET (nÃ£o do range)
 * 
 * @param {string} metricKey - Chave da mÃ©trica (lufs, truePeak, sub, etc)
 * @param {number} measuredValue - Valor medido na anÃ¡lise
 * @param {Object} targetSpec - { target, min, max, tol, type? }
 * @returns {Object} { score, severity, diff, reason, deviationRatio, status }
 */
window.evaluateMetric = function evaluateMetric(metricKey, measuredValue, targetSpec) {
    // ğŸ›¡ï¸ Guard: valores invÃ¡lidos
    if (!Number.isFinite(measuredValue) || !targetSpec) {
        return { 
            score: null, 
            severity: 'N/A', 
            diff: 0, 
            reason: 'Dados insuficientes',
            deviationRatio: 0,
            status: 'N/A'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ STREAMING MODE â€” VALIDAÃ‡ÃƒO TÃ‰CNICA RÃGIDA (v2026-01-19 STRICT)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Verifica se estÃ¡ em MODO STREAMING (nÃ£o soundDestination)
    // Se sim, usa validaÃ§Ã£o tÃ©cnica RÃGIDA (nÃ£o progressiva)
    // AplicaÃ§Ã£o: SOMENTE analysis.mode === 'streaming'
    // NÃ£o afeta: genre, pista, club, mastering
    
    const currentAnalysis = window.latestAnalysisData || window.currentAnalysis || {};
    const analysisMode = currentAnalysis.mode || 
                        (currentAnalysis.data && currentAnalysis.data.mode);
    
    // âš ï¸ IMPORTANTE: usar analysis.mode, NÃƒO soundDestination
    // soundDestination Ã© metadado, mode Ã© tipo de anÃ¡lise
    if (analysisMode === 'streaming') {
        // LUFS em modo streaming â†’ usar validaÃ§Ã£o tÃ©cnica RÃGIDA
        if (metricKey === 'lufs' && window.calculateStreamingLufsScoreStrict) {
            const streamingResult = window.calculateStreamingLufsScoreStrict(measuredValue);
            // Converter para formato compatÃ­vel com evaluateMetric
            return {
                score: streamingResult.score,
                severity: streamingResult.severity,
                diff: streamingResult.measuredLufs - streamingResult.targetLufs,
                reason: streamingResult.reason,
                deviationRatio: Math.abs(streamingResult.measuredLufs - streamingResult.targetLufs) / 1.0, // 1.0 LU = tolerÃ¢ncia streaming RÃGIDA
                status: streamingResult.severity,
                metricKey: 'lufs',
                measuredValue: streamingResult.measuredLufs,
                metricType: 'BANDPASS_STREAMING_STRICT',
                targetSpec: { target: -14.0, min: -15.0, max: -13.0, tol: 1.0 },
                streamingZone: streamingResult.zone,
                conformance: streamingResult.conformance
            };
        }
        
        // True Peak em modo streaming â†’ usar validaÃ§Ã£o tÃ©cnica RÃGIDA
        if (metricKey === 'truePeak' && window.calculateStreamingTruePeakScoreStrict) {
            const streamingResult = window.calculateStreamingTruePeakScoreStrict(measuredValue);
            // Converter para formato compatÃ­vel com evaluateMetric
            return {
                score: streamingResult.score,
                severity: streamingResult.severity,
                diff: streamingResult.measuredTp - streamingResult.targetTp,
                reason: streamingResult.reason,
                deviationRatio: Math.abs(streamingResult.measuredTp - streamingResult.targetTp) / 1.0, // 1.0 dB = tolerÃ¢ncia streaming RÃGIDA
                status: streamingResult.severity,
                metricKey: 'truePeak',
                measuredValue: streamingResult.measuredTp,
                metricType: 'CEILING_STREAMING_STRICT',
                targetSpec: { target: -1.0, max: 0.0, tol: 1.0 },
                streamingZone: streamingResult.zone,
                conformance: streamingResult.conformance
            };
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ LÃ“GICA GENÃ‰RICA (para outros modos e mÃ©tricas)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Normalizar targetSpec
    const target = targetSpec.target ?? targetSpec.target_db ?? null;
    const min = targetSpec.min ?? targetSpec.min_db ?? targetSpec.target_range?.min ?? null;
    const max = targetSpec.max ?? targetSpec.max_db ?? targetSpec.target_range?.max ?? null;
    const tol = targetSpec.tol ?? targetSpec.tol_db ?? targetSpec.tolerance ?? 1.0;
    
    // Determinar tipo da mÃ©trica
    const metricType = targetSpec.type || METRIC_TYPE[metricKey] || 'BANDPASS';
    
    let diff = 0;
    let deviationRatio = 0;
    let score = 100;
    let severity = 'OK';
    let reason = 'âœ… Dentro do padrÃ£o';
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CEILING METRICS (truePeak, samplePeak, clipping)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (metricType === 'CEILING') {
        // Para CEILING: target Ã© o TETO IDEAL, max Ã© HARD CAP
        const effectiveTarget = target ?? max ?? 0;
        const hardCap = max ?? 0;
        
        // Calcular diferenÃ§a do TARGET (nÃ£o do hard cap)
        diff = measuredValue - effectiveTarget;
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ¯ CORREÃ‡ÃƒO V2026-01-19: JANELA BILATERAL PARA TRUE PEAK
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // PROBLEMA ANTERIOR: valores abaixo do target recebiam score 100
        // CORREÃ‡ÃƒO: definir janela aceitÃ¡vel bilateral
        //
        // Para True Peak (target -1.0 dBTP):
        // â€¢ ZONA IDEAL: [-2.0, -0.8] â†’ score alto (85-100)
        // â€¢ ACIMA (clipping): > -0.8 â†’ penalizar progressivamente
        // â€¢ ABAIXO (conservador): < -2.0 â†’ penalizar progressivamente
        //
        // Exemplos corrigidos:
        // - TP -1.0 â†’ score 100 âœ…
        // - TP -1.8 â†’ score 90 âœ…
        // - TP -2.2 â†’ score 75 âœ… (antes era 100 âŒ)
        // - TP -3.4 â†’ score 45 âœ… (antes era 100 âŒ)
        // - TP -5.0 â†’ score 25 âœ… (antes era 100 âŒ)
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        // Definir janela aceitÃ¡vel (zona ideal)
        const idealMin = effectiveTarget - 1.0; // Ex: -1.0 - 1.0 = -2.0 dBTP
        const idealMax = effectiveTarget + 0.2; // Ex: -1.0 + 0.2 = -0.8 dBTP
        
        // CASO 1: Valor na ZONA IDEAL [idealMin, idealMax]
        if (measuredValue >= idealMin && measuredValue <= idealMax) {
            // Score alto proporcional Ã  distÃ¢ncia do target
            const distFromTarget = Math.abs(measuredValue - effectiveTarget);
            const zoneSize = 1.2; // idealMax - idealMin = 1.2 dB
            const normalizedDist = distFromTarget / zoneSize;
            
            score = Math.round(100 - (normalizedDist * 15)); // 100 â†’ 85
            score = Math.max(85, Math.min(100, score));
            severity = 'OK';
            reason = 'âœ… Dentro do padrÃ£o';
            deviationRatio = normalizedDist;
            
        // CASO 2: Valor ACIMA da zona ideal (clipping / prÃ³ximo ao limite)
        } else if (measuredValue > idealMax) {
            // Penalizar progressivamente atÃ© o hardCap
            const excessAboveIdeal = measuredValue - idealMax;
            
            if (measuredValue > hardCap) {
                // Acima do hard cap = CRÃTICO SEVERO
                const excessFromCap = measuredValue - hardCap;
                deviationRatio = (excessFromCap / tol) + 3; // ForÃ§a ratio > 3
                score = Math.max(20, 35 - (excessFromCap * 15));
                severity = 'CRÃTICA';
                reason = `ğŸ”´ Reduzir ${diff.toFixed(2)} (ACIMA DO LIMITE!)`;
            } else if (excessAboveIdeal <= 0.3) {
                // Ligeiramente acima da zona ideal (atÃ© +0.3 dB)
                score = Math.round(85 - (excessAboveIdeal * 50)); // 85 â†’ 70
                severity = 'ATENÃ‡ÃƒO';
                reason = `âš ï¸ Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            } else if (excessAboveIdeal <= 0.8) {
                // Moderadamente acima (0.3 a 0.8 dB)
                score = Math.round(70 - ((excessAboveIdeal - 0.3) * 40)); // 70 â†’ 50
                severity = 'ALTA';
                reason = `ğŸŸ¡ Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            } else {
                // Muito acima (> 0.8 dB da zona ideal)
                score = Math.round(50 - ((excessAboveIdeal - 0.8) * 30)); // 50 â†’ 20
                severity = 'CRÃTICA';
                reason = `ğŸ”´ Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            }
            
        // CASO 3: Valor ABAIXO da zona ideal (headroom excessivo)
        } else { // measuredValue < idealMin
            // ğŸš¨ CORREÃ‡ÃƒO CRÃTICA: penalizar conservadorismo excessivo
            const excessBelowIdeal = idealMin - measuredValue; // Ex: -2.0 - (-3.4) = 1.4 dB
            
            if (excessBelowIdeal <= 0.3) {
                // Ligeiramente abaixo (atÃ© -0.3 dB)
                score = Math.round(85 - (excessBelowIdeal * 40)); // 85 â†’ 73
                severity = 'ATENÃ‡ÃƒO';
                reason = `âš ï¸ Master conservadora. Considere aumentar ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            } else if (excessBelowIdeal <= 1.0) {
                // Moderadamente abaixo (-0.3 a -1.0 dB)
                score = Math.round(73 - ((excessBelowIdeal - 0.3) * 30)); // 73 â†’ 52
                severity = 'ALTA';
                reason = `ğŸŸ¡ Headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB. Aumentar`;
                deviationRatio = excessBelowIdeal / tol;
            } else if (excessBelowIdeal <= 2.0) {
                // Muito abaixo (-1.0 a -2.0 dB)
                score = Math.round(52 - ((excessBelowIdeal - 1.0) * 20)); // 52 â†’ 32
                severity = 'CRÃTICA';
                reason = `ğŸ”´ ERRO TÃ‰CNICO: headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            } else {
                // Extremamente abaixo (> -2.0 dB)
                score = Math.max(20, Math.round(32 - ((excessBelowIdeal - 2.0) * 8))); // 32 â†’ 20
                severity = 'CRÃTICA';
                reason = `ğŸ”´ ERRO TÃ‰CNICO SEVERO: headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            }
        }
        
        return {
            score: Math.round(Math.max(20, Math.min(100, score))),
            severity,
            diff,
            reason,
            deviationRatio: Math.round(deviationRatio * 100) / 100,
            status: severity,
            metricKey,
            measuredValue,
            metricType,
            targetSpec: { target: effectiveTarget, max: hardCap, tol }
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BANDPASS METRICS (lufs, dr, lra, bandas, etc)
    // Score 100 no target, decai conforme distÃ¢ncia
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Determinar target efetivo
    const effectiveTarget = target ?? (min !== null && max !== null ? (min + max) / 2 : null);
    
    if (effectiveTarget === null) {
        return { 
            score: null, 
            severity: 'N/A', 
            diff: 0, 
            reason: 'Sem referÃªncia',
            deviationRatio: 0,
            status: 'N/A'
        };
    }
    
    // Calcular diferenÃ§a do target
    diff = measuredValue - effectiveTarget;
    const absDiff = Math.abs(diff);
    
    // Verificar se estÃ¡ dentro do range [min, max]
    const hasRange = min !== null && max !== null;
    const inRange = hasRange && measuredValue >= min && measuredValue <= max;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // V4.0: CURVA DE PENALIZAÃ‡ÃƒO BANDPASS REVISADA
    // - Score 100 APENAS se valor == target (nÃ£o mais 50% tolerÃ¢ncia)
    // - Considera range [min, max] como fator de severidade
    // - Severidade alinhada com tabela visual
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Calcular distÃ¢ncia normalizada pelo range (se disponÃ­vel)
    let rangeSize = tol * 2; // Default: 2x tolerÃ¢ncia = range total
    if (hasRange) {
        rangeSize = max - min;
    }
    
    // DistÃ¢ncia normalizada: 0 = no target, 1 = na borda do range, >1 = fora do range
    const normalizedDistance = rangeSize > 0 ? absDiff / (rangeSize / 2) : (absDiff / tol);
    
    // Fora do range = SEMPRE CRÃTICA
    if (hasRange && !inRange) {
        // Calcular quanto fora do range
        const distanceFromRange = measuredValue < min ? (min - measuredValue) : (measuredValue - max);
        const rangeExcess = distanceFromRange / tol;
        
        if (rangeExcess >= 1.5) {
            // Muito fora do range = CRÃTICA severa
            score = Math.max(20, Math.round(40 - (rangeExcess * 8)));
            severity = 'CRÃTICA';
        } else if (rangeExcess >= 0.5) {
            // Moderadamente fora = CRÃTICA
            score = Math.round(55 - (rangeExcess * 15));
            severity = 'CRÃTICA';
        } else {
            // Ligeiramente fora = ALTA
            score = Math.round(70 - (rangeExcess * 20));
            severity = 'ALTA';
        }
        
        
        // ğŸ¯ CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            const realisticAction = buildRealisticAction(absDiff, direction, 'ğŸ”´');
            reason = realisticAction + ' (fora do range)';
        } else {
            reason = diff > 0 
                ? `ğŸ”´ Reduzir ${absDiff.toFixed(1)} (fora do range)` 
                : `ğŸ”´ Aumentar ${absDiff.toFixed(1)} (fora do range)`;
        }
            
        return {
            score: Math.round(Math.max(20, Math.min(100, score))),
            severity,
            diff,
            reason,
            deviationRatio: Math.round(normalizedDistance * 100) / 100,
            status: severity,
            metricKey,
            measuredValue,
            metricType,
            targetSpec: { target: effectiveTarget, min, max, tol },
            value: measuredValue,
            target: effectiveTarget
        };
    }
    
    // Dentro do range - calcular score baseado na distÃ¢ncia do target
    // V4.0: Curva mais rigorosa que a anterior
    
    if (normalizedDistance <= 0.15) {
        // Muito prÃ³ximo do target (â‰¤15% do range) = OK perfeito
        score = 100;
        severity = 'OK';
        reason = 'âœ… Dentro do padrÃ£o';
    } else if (normalizedDistance <= 0.4) {
        // PrÃ³ximo do target (15-40% do range) = OK com pequena ressalva
        score = Math.round(100 - (normalizedDistance - 0.15) * 20); // 100 â†’ 95
        severity = 'OK';
        reason = 'âœ… Dentro do padrÃ£o';
    } else if (normalizedDistance <= 0.7) {
        // Moderado (40-70% do range) = ATENÃ‡ÃƒO
        score = Math.round(95 - ((normalizedDistance - 0.4) * 40)); // 95 â†’ 83
        severity = 'ATENÃ‡ÃƒO';
        // ğŸ¯ CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, 'âš ï¸');
        } else {
            reason = diff > 0 
                ? `âš ï¸ Reduzir ${absDiff.toFixed(1)}` 
                : `âš ï¸ Aumentar ${absDiff.toFixed(1)}`;
        }
    } else if (normalizedDistance <= 1.0) {
        // Perto da borda (70-100% do range) = ALTA
        score = Math.round(83 - ((normalizedDistance - 0.7) * 43)); // 83 â†’ 70
        severity = 'ALTA';
        // ğŸ¯ CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, 'ğŸŸ¡');
        } else {
            reason = diff > 0 
                ? `ğŸŸ¡ Reduzir ${absDiff.toFixed(1)}` 
                : `ğŸŸ¡ Aumentar ${absDiff.toFixed(1)}`;
        }
    } else {
        // Na borda ou ligeiramente fora = CRÃTICA (mas ainda "dentro" por arredondamento)
        score = Math.max(55, Math.round(70 - ((normalizedDistance - 1) * 25)));
        severity = 'CRÃTICA';
        // ğŸ¯ CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, 'ğŸ”´');
        } else {
            reason = diff > 0 
                ? `ğŸ”´ Reduzir ${absDiff.toFixed(1)}` 
                : `ğŸ”´ Aumentar ${absDiff.toFixed(1)}`;
        }
    }
    
    return {
        score: Math.round(Math.max(20, Math.min(100, score))),
        severity,
        diff,
        reason,
        deviationRatio: Math.round(normalizedDistance * 100) / 100,
        status: severity,
        metricKey,
        measuredValue,
        metricType,
        targetSpec: { target: effectiveTarget, min, max, tol },
        value: measuredValue,
        target: effectiveTarget
    };
};

// Alias global
window.SOUNDY_evaluateMetric = window.evaluateMetric;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ STREAMING SCORING â€” VALIDAÃ‡ÃƒO TÃ‰CNICA RÃGIDA (v2026-01-19 STRICT)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âš ï¸ ERRO CONCEITUAL CORRIGIDO:
// - Streaming NÃƒO Ã© "otimizaÃ§Ã£o progressiva"
// - Streaming Ã‰ "conformidade tÃ©cnica"
// - TolerÃ¢ncia: Â±1.0 dB (nÃ£o Â±1.5 ou Â±2.0)
// - Fora da tolerÃ¢ncia = score BAIXO (nÃ£o progressivo)
//
// APLICAÃ‡ÃƒO:
// - SOMENTE quando analysis.mode === 'streaming'
// - NÃƒO afeta genre, pista, club, mastering
//
// PADRÃ•ES TÃ‰CNICOS:
// - Spotify: -14 LUFS Â± 1 dB, True Peak < -1 dBTP
// - Apple Music: -16 LUFS, True Peak < -1 dBTP (mas aceita -14 Â±1)
// - YouTube: -14 LUFS Â± 1 dB, True Peak < -1 dBTP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ§ calculateStreamingLufsScoreStrict â€” ValidaÃ§Ã£o tÃ©cnica RÃGIDA para LUFS em streaming
 * 
 * REGRAS TÃ‰CNICAS (nÃ£o progressivas):
 * - Target fixo: -14.0 LUFS
 * - TolerÃ¢ncia mÃ¡xima: Â±1.0 dB
 * 
 * ZONA VERDE [-15.0, -13.0]:
 *   â†’ Score: 90-100
 *   â†’ Status: CONFORME PADRÃƒO STREAMING
 * 
 * ZONA AMARELA [-16.0, -15.0] ou [-13.0, -12.0]:
 *   â†’ Score: 60-80
 *   â†’ Status: FORA DO PADRÃƒO (margem de seguranÃ§a)
 * 
 * ZONA VERMELHA < -16.0 ou > -12.0:
 *   â†’ Score: â‰¤40
 *   â†’ Status: FORA DO PADRÃƒO STREAMING
 * 
 * @param {number} lufs - LUFS Integrado medido
 * @returns {{score: number, severity: string, reason: string, zone: string, conformance: string}}
 */
window.calculateStreamingLufsScoreStrict = function(lufs) {
    if (!Number.isFinite(lufs)) {
        return { 
            score: null, 
            severity: 'N/A', 
            reason: 'Valor invÃ¡lido', 
            zone: 'unknown',
            conformance: 'N/A'
        };
    }
    
    const TARGET = -14.0;
    let score, severity, reason, zone, conformance;
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA VERDE: -15.0 a -13.0 LUFS (Â±1.0 dB do target)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (lufs >= -15.0 && lufs <= -13.0) {
        zone = 'VERDE';
        conformance = 'CONFORME';
        
        // Score alto dentro da zona verde (90-100)
        const distFromTarget = Math.abs(lufs - TARGET);
        score = Math.round(100 - (distFromTarget * 10)); // -14.0 = 100, -15.0 ou -13.0 = 90
        score = Math.max(90, Math.min(100, score));
        
        severity = 'OK';
        
        if (score >= 98) {
            reason = 'âœ… Conformidade total para streaming';
        } else {
            reason = `âœ… Dentro do padrÃ£o streaming (${distFromTarget.toFixed(1)} LU do ideal)`;
        }
        
        return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA AMARELA: [-16.0, -15.0) ou (-13.0, -12.0]
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if ((lufs >= -16.0 && lufs < -15.0) || (lufs > -13.0 && lufs <= -12.0)) {
        zone = 'AMARELA';
        conformance = 'FORA DO PADRÃƒO';
        
        // Score mÃ©dio/baixo (60-80)
        const distFromEdge = lufs > -13.0 
            ? Math.abs(lufs - (-13.0))  // DistÃ¢ncia da borda superior
            : Math.abs(lufs - (-15.0)); // DistÃ¢ncia da borda inferior
        
        score = Math.round(80 - (distFromEdge * 20)); // 80 â†’ 60
        score = Math.max(60, Math.min(80, score));
        
        severity = 'ALTA';
        
        if (lufs > -13.0) {
            reason = `ğŸŸ¡ FORA DO PADRÃƒO STREAMING (${(lufs - TARGET).toFixed(1)} LU acima). Reduzir urgentemente`;
        } else {
            reason = `ğŸŸ¡ FORA DO PADRÃƒO STREAMING (${Math.abs(lufs - TARGET).toFixed(1)} LU abaixo). Aumentar urgentemente`;
        }
        
        return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA VERMELHA: < -16.0 ou > -12.0
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    zone = 'VERMELHA';
    conformance = 'NÃƒO CONFORME';
    
    const distFromLimit = lufs > -12.0 
        ? Math.abs(lufs - (-12.0))
        : Math.abs(lufs - (-16.0));
    
    // Score baixo (â‰¤40)
    score = Math.max(20, Math.round(40 - (distFromLimit * 10)));
    severity = 'CRÃTICA';
    
    if (lufs > -12.0) {
        reason = `ğŸ”´ NÃƒO CONFORME STREAMING (${(lufs - TARGET).toFixed(1)} LU acima). CORRIGIR`;
    } else {
        reason = `ğŸ”´ NÃƒO CONFORME STREAMING (${Math.abs(lufs - TARGET).toFixed(1)} LU abaixo). CORRIGIR`;
    }
    
    return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
};

/**
 * ğŸ”Š calculateStreamingTruePeakScoreStrict â€” ValidaÃ§Ã£o tÃ©cnica RÃGIDA para True Peak em streaming
 * 
 * REGRAS TÃ‰CNICAS (nÃ£o progressivas):
 * - Target fixo: -1.0 dBTP
 * - TolerÃ¢ncia mÃ¡xima: Â±1.0 dB
 * 
 * ZONA VERDE [-2.0, 0.0]:
 *   â†’ Score: 85-100
 *   â†’ Status: CONFORME PADRÃƒO STREAMING
 * 
 * ZONA AMARELA [-3.0, -2.0) ou (0.0, +1.0]:
 *   â†’ Score: 60-80
 *   â†’ Status: FORA DO PADRÃƒO (margem)
 * 
 * ZONA VERMELHA < -3.0 ou > +1.0:
 *   â†’ Score: â‰¤40
 *   â†’ Status: NÃƒO CONFORME (erro tÃ©cnico)
 * 
 * INTERPRETAÃ‡ÃƒO:
 * - TP muito baixo (< -3.0) = master conservadora demais (erro tÃ©cnico)
 * - TP alto (> 0.0) = risco de clipping
 * - Ambos penalizam score tÃ©cnico
 * 
 * @param {number} tp - True Peak em dBTP
 * @returns {{score: number, severity: string, reason: string, zone: string, conformance: string}}
 */
window.calculateStreamingTruePeakScoreStrict = function(tp) {
    if (!Number.isFinite(tp)) {
        return { 
            score: null, 
            severity: 'N/A', 
            reason: 'Valor invÃ¡lido', 
            zone: 'unknown',
            conformance: 'N/A'
        };
    }
    
    const TARGET = -1.0;
    let score, severity, reason, zone, conformance;
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // CLIPPING SEVERO: > +1.0 dBTP
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (tp > 1.0) {
        zone = 'VERMELHA';
        conformance = 'CLIPPING SEVERO';
        score = Math.max(20, Math.round(30 - (tp * 10)));
        severity = 'CRÃTICA';
        reason = `ğŸ”´ CLIPPING SEVERO! Reduzir ${(tp - TARGET).toFixed(2)} dB URGENTEMENTE`;
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA VERDE: -2.0 a -1.2 dBTP (headroom seguro)
    // CORREÃ‡ÃƒO V2: Zona verde mais rigorosa para evitar TP prÃ³ximo ao clipping
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (tp >= -2.0 && tp <= -1.2) {
        zone = 'VERDE';
        conformance = 'CONFORME';
        
        // Score alto dentro da zona verde (90-100)
        const distFromTarget = Math.abs(tp - TARGET);
        score = Math.round(100 - (distFromTarget * 10)); // -1.0 = 100, -1.2 = 98, -2.0 = 90
        score = Math.max(90, Math.min(100, score));
        
        severity = 'OK';
        if (score >= 98) {
            reason = 'âœ… True Peak ideal para streaming';
        } else {
            reason = `âœ… Dentro do padrÃ£o streaming (${distFromTarget.toFixed(2)} dB do ideal)`;
        }
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA AMARELA SUPERIOR: (-1.2, -0.5] (atenÃ§Ã£o â€” prÃ³ximo ao clipping)
    // CORREÃ‡ÃƒO V2: Nova zona para detectar TP perigosamente alto
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (tp > -1.2 && tp <= -0.5) {
        zone = 'AMARELA';
        conformance = 'ATENÃ‡ÃƒO';
        
        // Score 69-90 (proporcional Ã  distÃ¢ncia de -1.2)
        const distFromIdeal = Math.abs(tp - (-1.2));
        score = Math.round(90 - (distFromIdeal * 30)); // -1.2 â†’ 90, -0.5 â†’ 69
        score = Math.max(69, Math.min(90, score));
        
        severity = 'ATENÃ‡ÃƒO';
        reason = `âš ï¸ ATENÃ‡ÃƒO: PrÃ³ximo ao clipping. Reduzir ${(tp - TARGET).toFixed(1)} dB para seguranÃ§a`;
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA AMARELA INFERIOR: [-3.0, -2.0) (headroom excessivo)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (tp >= -3.0 && tp < -2.0) {
        zone = 'AMARELA';
        conformance = 'ATENÃ‡ÃƒO';
        
        // Score 65-90 (conservador demais)
        const distFromIdeal = Math.abs(tp - (-2.0));
        score = Math.round(90 - (distFromIdeal * 25)); // -2.0 â†’ 90, -3.0 â†’ 65
        score = Math.max(65, Math.min(90, score));
        
        severity = 'ATENÃ‡ÃƒO';
        reason = `âš ï¸ Master conservadora. Considere aumentar ${Math.abs(tp - TARGET).toFixed(1)} dB`;
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA VERMELHA SUPERIOR: (-0.5, +1.0] (clipping iminente)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    if (tp > -0.5 && tp <= 1.0) {
        zone = 'VERMELHA';
        conformance = 'CRÃTICO';
        
        // Score 30-65 (clipping iminente)
        const distFromLimit = Math.abs(tp - (-0.5));
        score = Math.max(30, Math.round(65 - (distFromLimit * 50))); // -0.5 â†’ 65, +1.0 â†’ 30
        
        severity = 'CRÃTICA';
        reason = `ğŸ”´ CLIPPING IMINENTE! Reduzir ${(tp - TARGET).toFixed(1)} dB URGENTEMENTE`;
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // ZONA VERMELHA: < -3.0 dBTP (erro tÃ©cnico - conservador demais)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    zone = 'VERMELHA';
    conformance = 'ERRO TÃ‰CNICO';
    
    const distFromLimit = Math.abs(tp - (-3.0));
    
    // Score baixo (â‰¤40)
    score = Math.max(20, Math.round(40 - (distFromLimit * 10)));
    severity = 'CRÃTICA';
    reason = `ğŸ”´ ERRO TÃ‰CNICO (headroom excessivo de ${Math.abs(tp - TARGET).toFixed(1)} dB). CORRIGIR`;
    
    return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
};

/**
 * ğŸ¯ Helper: Converte resultado de evaluateMetric para formato da tabela
 * Usado pelo buildMetricRows para garantir Single Source of Truth
 */
window.evaluateMetricForTable = function(metricKey, measuredValue, targetSpec) {
    const result = window.evaluateMetric(metricKey, measuredValue, targetSpec);
    
    // Mapear severity para severityClass (formato da tabela)
    const SEVERITY_CLASS_MAP = {
        'OK': 'ok',
        'ATENÃ‡ÃƒO': 'caution',
        'ALTA': 'warning',
        'CRÃTICA': 'critical',
        'N/A': 'na'
    };
    
    return {
        severity: result.severity,
        severityClass: SEVERITY_CLASS_MAP[result.severity] || 'na',
        action: result.reason,
        diff: result.diff,
        score: result.score,
        deviationRatio: result.deviationRatio
    };
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ V3.7 METRIC â†’ SUBSCORE MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const METRIC_TO_SUBSCORE_V37 = {
    // LOUDNESS
    lufs: 'loudness',
    rms: 'loudness',
    lufsIntegrated: 'loudness',
    
    // TECHNICAL
    truePeak: 'technical',
    samplePeak: 'technical',
    clipping: 'technical',
    dcOffset: 'technical',
    
    // DYNAMICS
    dr: 'dynamics',
    dynamicRange: 'dynamics',
    crest: 'dynamics',
    crestFactor: 'dynamics',
    lra: 'dynamics',
    
    // STEREO
    correlation: 'stereo',
    stereoCorrelation: 'stereo',
    width: 'stereo',
    stereoWidth: 'stereo',
    
    // FREQUENCY (bandas)
    sub: 'frequency',
    bass: 'frequency',
    lowMid: 'frequency',
    mid: 'frequency',
    highMid: 'frequency',
    air: 'frequency',
    presence: 'frequency'
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ V3.6 GATES CONFIG - Aplicados aos SUBSCORES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SUBSCORE_GATES = {
    technical: {
        // Gate: True Peak > limit â†’ cap subscore tÃ©cnico
        truePeak: {
            condition: (value, limit) => value > limit,
            calcCap: (value, limit) => {
                const excess = value - limit;
                // Cap proporcional: 1dB acima = cap 75%, 2dB = cap 55%, etc
                return Math.max(35, 95 - (excess * 20));
            },
            severity: (value, limit) => {
                const excess = value - limit;
                return excess > 1.0 ? 'CRÃTICA' : excess > 0.5 ? 'ALTA' : 'MODERADA';
            }
        },
        // Gate: Clipping > 0.5% â†’ cap subscore tÃ©cnico
        clipping: {
            condition: (value) => value > 0.5,
            calcCap: (value) => {
                return Math.max(30, 80 - (value - 0.5) * 10);
            },
            severity: (value) => value > 5 ? 'CRÃTICA' : value > 2 ? 'ALTA' : 'MODERADA'
        }
    },
    loudness: {
        // Gate: LUFS muito acima do max â†’ cap subscore loudness
        lufs: {
            condition: (value, limit) => value > limit,
            calcCap: (value, limit) => {
                const excess = value - limit;
                return Math.max(50, 95 - (excess * 7.5));
            },
            severity: (value, limit) => {
                const excess = value - limit;
                return excess > 4 ? 'CRÃTICA' : excess > 2 ? 'ALTA' : 'MODERADA';
            }
        }
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ V3.6 MAIN SCORING FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * MÃ³dulo unificado para cÃ¡lculo de scores V3.6.
 * 
 * PRINCÃPIOS:
 * 1. TODAS as mÃ©tricas passam por evaluateMetric (SINGLE SOURCE OF TRUTH)
 * 2. Subscores = mÃ©dia dos metricScores do grupo
 * 3. Gates aplicados aos SUBSCORES (nÃ£o ao final)
 * 4. Score final = mÃ©dia ponderada dos subscores (jÃ¡ com gates aplicados)
 * 
 * @param {Object} analysis - Objeto de anÃ¡lise completo (technicalData, metrics, etc)
 * @param {Object} targets - Targets do modo (streaming/pista/reference)
 * @param {string} mode - 'streaming', 'pista', ou 'reference'
 * @returns {Object} { raw, final, subscores, subScoresRaw, gatesTriggered, metricEvaluations, debug }
 */
window.computeScoreV3 = function computeScoreV3(analysis, targets, mode = 'streaming') {
    const DEBUG = true;
    
    if (DEBUG) {
        console.group('ğŸ¯ [computeScoreV3.6] SINGLE SOURCE OF TRUTH');
        log('ğŸ“Š mode:', mode);
        log('ğŸ“Š targets keys:', targets ? Object.keys(targets) : 'null');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. EXTRAIR VALORES MEDIDOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const tech = analysis?.technicalData || analysis?.metrics || {};
    const measured = {
        // Loudness
        lufs: tech.lufsIntegrated ?? tech.lufs_integrated ?? null,
        rms: tech.rms ?? tech.rms_db ?? null,
        
        // Technical
        truePeak: tech.truePeakDbtp ?? tech.true_peak_dbtp ?? null,
        samplePeak: tech.samplePeak ?? tech.sample_peak ?? tech.peak_dbfs ?? null,
        clipping: (tech.clippingPct ?? tech.clipping_pct ?? tech.clipping ?? 0) * 100,
        dcOffset: Math.abs(tech.dcOffset ?? tech.dc_offset ?? 0) * 100,
        
        // Dynamics
        dr: tech.dynamicRange ?? tech.dynamic_range ?? null,
        crest: tech.crestFactor ?? tech.crest_factor ?? null,
        lra: tech.lra ?? null,
        
        // Stereo
        correlation: tech.stereoCorrelation ?? tech.stereo_correlation ?? null,
        width: tech.stereoWidth ?? tech.stereo_width ?? null,
        
        // Frequency bands
        bands: tech.bands ?? tech.spectral_balance ?? {}
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. DEFINIR TARGETS (MODE + PASSADOS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const MODE_TARGETS = {
        streaming: {
            lufs: { target: -14, min: -16, max: -12, tol: 1.0 },
            truePeak: { target: -1.0, min: -3.0, max: -1.0, tol: 0.25 },
            rms: { target: -18, min: -24, max: -12, tol: 2.0 },
            dr: { target: 8, min: 6, max: 12, tol: 1.5 },
            lra: { target: 7, min: 5, max: 10, tol: 2.0 },
            crest: { target: 12, min: 8, max: 16, tol: 2.0 },
            correlation: { target: 0.9, min: 0.5, max: 1.0, tol: 0.1 },
            width: { target: 0.7, min: 0.3, max: 1.0, tol: 0.15 },
            clipping: { target: 0, min: 0, max: 0.1, tol: 0.05 },
            dcOffset: { target: 0, min: 0, max: 1.0, tol: 0.5 },
            samplePeak: { target: -1.0, min: -6.0, max: 0.0, tol: 0.5 }
        },
        pista: {
            lufs: { target: -9, min: -12, max: -6, tol: 1.5 },
            truePeak: { target: -0.3, min: -1.5, max: 0.0, tol: 0.3 },
            rms: { target: -14, min: -20, max: -8, tol: 2.0 },
            dr: { target: 6, min: 4, max: 10, tol: 1.5 },
            lra: { target: 5, min: 3, max: 8, tol: 2.0 },
            crest: { target: 10, min: 6, max: 14, tol: 2.0 },
            correlation: { target: 0.85, min: 0.4, max: 1.0, tol: 0.15 },
            width: { target: 0.8, min: 0.4, max: 1.0, tol: 0.15 },
            clipping: { target: 0, min: 0, max: 0.5, tol: 0.2 },
            dcOffset: { target: 0, min: 0, max: 2.0, tol: 1.0 },
            samplePeak: { target: -0.5, min: -4.0, max: 0.0, tol: 0.5 }
        }
    };
    
    const modeTargets = MODE_TARGETS[mode] || MODE_TARGETS.streaming;
    const finalTargets = { ...modeTargets };
    
    // Sobrescrever com targets passados (prioridade para dados do gÃªnero/referÃªncia)
    if (targets) {
        // LUFS
        if (targets.lufs_target !== undefined) {
            finalTargets.lufs = {
                target: targets.lufs_target,
                min: targets.lufs_min ?? (targets.lufs_target - (targets.tol_lufs || 1.0)),
                max: targets.lufs_max ?? (targets.lufs_target + (targets.tol_lufs || 1.0)),
                tol: targets.tol_lufs || 1.0
            };
        }
        
        // True Peak - CEILING metric
        if (targets.true_peak_target !== undefined) {
            finalTargets.truePeak = {
                target: targets.true_peak_target, // ESTE Ã© o valor ideal
                min: targets.true_peak_min ?? -3.0,
                max: Math.min(0.0, targets.true_peak_max ?? 0.0), // Hard cap 0 dBTP
                tol: targets.tol_true_peak || 0.5,
                type: 'CEILING'
            };
        }
        
        // DR
        if (targets.dr_target !== undefined) {
            finalTargets.dr = {
                target: targets.dr_target,
                min: targets.dr_min ?? (targets.dr_target - (targets.tol_dr || 1.5)),
                max: targets.dr_max ?? (targets.dr_target + (targets.tol_dr || 1.5)),
                tol: targets.tol_dr || 1.5
            };
        }
        
        // LRA - CORRIGIDO: incluir lra_target
        if (targets.lra_target !== undefined) {
            finalTargets.lra = {
                target: targets.lra_target,
                min: targets.lra_min ?? (targets.lra_target - (targets.tol_lra || 2.0)),
                max: targets.lra_max ?? (targets.lra_target + (targets.tol_lra || 2.0)),
                tol: targets.tol_lra || 2.0
            };
        }
        
        // Stereo Correlation
        if (targets.stereo_target !== undefined || targets.correlation_target !== undefined) {
            const stereoTarget = targets.stereo_target ?? targets.correlation_target;
            finalTargets.correlation = {
                target: stereoTarget,
                min: targets.stereo_min ?? 0.5,
                max: 1.0,
                tol: targets.tol_stereo || 0.1
            };
        }
        
        // Bandas
        if (targets.bands) {
            finalTargets.bands = targets.bands;
        }
    }
    
    // ï¿½ CRÃTICO: OVERRIDE DE STREAMING - APLICAR DEPOIS DOS TARGETS DE GÃŠNERO
    // Este override DEVE acontecer DEPOIS que targets do gÃªnero foram aplicados
    // e ANTES de avaliar as mÃ©tricas, garantindo que o subscore use o target correto
    const soundDest = analysis?.soundDestination || 'pista';
    
    if (soundDest === 'streaming') {
        error('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  ğŸ“¡ FRONTEND: APLICANDO OVERRIDE STREAMING FINAL         â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('[STREAMING-OVERRIDE] ANTES: lufs.target =', finalTargets.lufs?.target);
        
        // Override LUFS para padrÃ£o de streaming
        finalTargets.lufs = {
            target: -14,
            min: -16,
            max: -12,
            tol: 1.0
        };
        
        // Override True Peak para padrÃ£o de streaming
        finalTargets.truePeak = {
            target: -1.0,
            min: -3.0,
            max: -1.0,
            tol: 0.25,
            type: 'CEILING'
        };
        
        error('[STREAMING-OVERRIDE] DEPOIS: lufs.target =', finalTargets.lufs.target);
        error('[STREAMING-OVERRIDE] soundDestination:', soundDest);
        error('\n');
    }
    
    // ğŸ” DEBUG: Log para verificar targets usados vs tabela
    if (DEBUG) {
        log('ğŸ“Š finalTargets (usados no score):', {
            truePeak: finalTargets.truePeak,
            lufs: finalTargets.lufs,
            lra: finalTargets.lra,
            dr: finalTargets.dr
        });
        log('ğŸ“Š targets passados:', {
            true_peak_target: targets?.true_peak_target,
            lufs_target: targets?.lufs_target,
            lra_target: targets?.lra_target,
            dr_target: targets?.dr_target
        });
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. AVALIAR TODAS AS MÃ‰TRICAS COM evaluateMetric (SINGLE SOURCE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const metricEvaluations = {};
    
    // ğŸ¯ LOG CRÃTICO: Verificar target usado na avaliaÃ§Ã£o de LUFS
    error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    error('â•‘  ğŸ¯ AVALIANDO LUFS PARA SUBSCORE                         â•‘');
    error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    error('[LUFS-EVAL] LUFS medido:', measured.lufs);
    error('[LUFS-EVAL] Target usado:', finalTargets.lufs.target);
    error('[LUFS-EVAL] Diff (LU):', Math.abs(measured.lufs - finalTargets.lufs.target).toFixed(2));
    error('[LUFS-EVAL] soundDestination:', soundDest);
    error('\n');
    
    // Loudness
    metricEvaluations.lufs = window.evaluateMetric('lufs', measured.lufs, finalTargets.lufs);
    metricEvaluations.rms = window.evaluateMetric('rms', measured.rms, finalTargets.rms);
    
    // Technical
    metricEvaluations.truePeak = window.evaluateMetric('truePeak', measured.truePeak, finalTargets.truePeak);
    metricEvaluations.samplePeak = window.evaluateMetric('samplePeak', measured.samplePeak, finalTargets.samplePeak);
    metricEvaluations.clipping = window.evaluateMetric('clipping', measured.clipping, finalTargets.clipping);
    metricEvaluations.dcOffset = window.evaluateMetric('dcOffset', measured.dcOffset, finalTargets.dcOffset);
    
    // Dynamics
    metricEvaluations.dr = window.evaluateMetric('dr', measured.dr, finalTargets.dr);
    metricEvaluations.crest = window.evaluateMetric('crest', measured.crest, finalTargets.crest);
    metricEvaluations.lra = window.evaluateMetric('lra', measured.lra, finalTargets.lra);
    
    // Stereo
    metricEvaluations.correlation = window.evaluateMetric('correlation', measured.correlation, finalTargets.correlation);
    metricEvaluations.width = window.evaluateMetric('width', measured.width, finalTargets.width);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // V4.1: MAPEAMENTO COMPLETO DE BANDAS - CORRIGE BUG CRÃTICO
    // JSON de gÃªnero usa: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
    // Backend envia: sub, bass, lowMid, mid, highMid, presence, air
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Mapeamento: chave canÃ´nica â†’ possÃ­veis chaves no JSON
    const BAND_MAPPING = {
        sub: ['sub'],
        bass: ['bass', 'low_bass', 'upper_bass'],
        lowMid: ['lowMid', 'low_mid'],
        mid: ['mid'],
        highMid: ['highMid', 'high_mid'],
        presence: ['presence', 'presenca'],
        air: ['air', 'brilho', 'brilliance']
    };
    
    // TODAS as bandas do JSON que precisam ser processadas
    const ALL_JSON_BANDS = ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca'];
    
    const bandTargets = finalTargets.bands || {};
    
    // Processar TODAS as bandas do JSON de targets, nÃ£o apenas as canonizadas
    for (const jsonBandKey of ALL_JSON_BANDS) {
        const targetDef = bandTargets[jsonBandKey];
        
        if (!targetDef) {
            if (DEBUG) {
                log(`ğŸ“Š [BANDS] Banda ${jsonBandKey} nÃ£o encontrada nos targets`);
            }
            continue;
        }
        
        // Mapear chave do JSON para chave canÃ´nica para buscar valor medido
        let canonicalKey = jsonBandKey;
        let userValue = null;
        
        // Mapeamento reverso: JSON key â†’ canonical key
        const REVERSE_MAP = {
            'low_bass': 'bass',
            'upper_bass': 'bass', // Combina com bass
            'low_mid': 'lowMid',
            'high_mid': 'highMid',
            'brilho': 'air',
            'presenca': 'presence'
        };
        
        canonicalKey = REVERSE_MAP[jsonBandKey] || jsonBandKey;
        
        // Buscar valor medido
        userValue = measured.bands?.[jsonBandKey]?.energy_db 
                 ?? measured.bands?.[jsonBandKey]
                 ?? measured.bands?.[canonicalKey]?.energy_db 
                 ?? measured.bands?.[canonicalKey];
        
        if (userValue === null || userValue === undefined) {
            if (DEBUG) {
                log(`ğŸ“Š [BANDS] Valor nÃ£o encontrado para ${jsonBandKey} (canonical: ${canonicalKey})`);
            }
            continue;
        }
        
        // Construir target normalizado
        const normalizedTarget = {
            target: targetDef.target_db ?? targetDef.target,
            min: targetDef.target_range?.min ?? targetDef.min_db,
            max: targetDef.target_range?.max ?? targetDef.max_db,
            tol: targetDef.tol_db || 2.5 // Usar tolerÃ¢ncia do JSON
        };
        
        // Se nÃ£o tem min/max explÃ­cito, calcular do target
        if (normalizedTarget.min === undefined) {
            normalizedTarget.min = (normalizedTarget.target ?? 0) - normalizedTarget.tol;
        }
        if (normalizedTarget.max === undefined) {
            normalizedTarget.max = (normalizedTarget.target ?? 0) + normalizedTarget.tol;
        }
        
        // Avaliar a banda
        const evaluation = window.evaluateMetric(jsonBandKey, userValue, normalizedTarget);
        
        // Armazenar com chave canÃ´nica para o resto do sistema
        // Se jÃ¡ existe (ex: low_bass e upper_bass â†’ bass), usar o PIOR score
        const existingEval = metricEvaluations[canonicalKey];
        if (existingEval && existingEval.score !== null) {
            // Manter o pior score entre as bandas combinadas
            if (evaluation.score !== null && evaluation.score < existingEval.score) {
                metricEvaluations[canonicalKey] = evaluation;
                if (DEBUG) {
                    log(`ğŸ“Š [BANDS] ${canonicalKey} atualizado: ${existingEval.score} â†’ ${evaluation.score} (${jsonBandKey} Ã© pior)`);
                }
            }
        } else {
            metricEvaluations[canonicalKey] = evaluation;
        }
        
        // TambÃ©m armazenar com a chave original do JSON para referÃªncia
        metricEvaluations[`_json_${jsonBandKey}`] = evaluation;
        
        if (DEBUG) {
            log(`ğŸ“Š [BANDS] ${jsonBandKey} â†’ ${canonicalKey}: valor=${userValue?.toFixed(1)}, target=${normalizedTarget.target?.toFixed(1)}, score=${evaluation.score}, severity=${evaluation.severity}`);
        }
    }
    
    // Garantir que temos as chaves canÃ´nicas para o cÃ¡lculo de frequÃªncia
    const BAND_KEYS = ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'];
    
    if (DEBUG) {
        log('ğŸ“Š Metric Evaluations (evaluateMetric):', metricEvaluations);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. CALCULAR SUBSCORES RAW (mÃ©dias por grupo)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function avgValidScores(keys) {
        const valid = keys
            .map(k => metricEvaluations[k]?.score)
            .filter(s => s !== null && s !== undefined);
        if (valid.length === 0) return null;
        return Math.round(valid.reduce((sum, s) => sum + s, 0) / valid.length);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸµ V4.0: CÃLCULO DE SUBSCORE DE FREQUÃŠNCIA - COERENTE COM TABELA
    // PrincÃ­pios:
    // 1. Score individual por banda baseado em evaluateMetric (SINGLE SOURCE)
    // 2. Pesos PERCEPTIVOS (High Mid/PresenÃ§a = fadiga auditiva)
    // 3. NUNCA permitir score alto se qualquer banda estÃ¡ CRÃTICA
    // 4. Score final = f(pior banda, mÃ©dia ponderada)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function calculateFrequencySubscore() {
        // ğŸ¯ V4.0: PESOS PERCEPTIVOS (baseado em impacto auditivo real)
        // - High Mid (2-4kHz): onde ouvimos fadiga, estridÃªncia = MAIOR PESO
        // - PresenÃ§a (4-8kHz): clareza, sibilÃ¢ncia = PESO ALTO
        // - Sub/Bass: importante, mas menos sensÃ­vel perceptivamente
        const BAND_WEIGHTS = {
            sub: 0.12,      // 12% - fundaÃ§Ã£o, menos sensÃ­vel
            bass: 0.14,     // 14% - corpo, moderado  
            lowMid: 0.12,   // 12% - "muddiness"
            mid: 0.16,      // 16% - presenÃ§a vocal/instrumental
            highMid: 0.20,  // 20% - FADIGA AUDITIVA (maior peso)
            presence: 0.14, // 14% - clareza/sibilÃ¢ncia
            air: 0.12       // 12% - brilho/ar
        };
        
        // Coletar avaliaÃ§Ãµes vÃ¡lidas
        const bandEvals = {};
        let totalWeight = 0;
        let weightedSum = 0;
        let bandsWithScore = 0;
        
        // Contadores de severidade para gates
        let criticalCount = 0;
        let highCount = 0;
        let attentionCount = 0;
        
        // ğŸ¯ V4.0: Rastrear pior banda (para gate baseado no mÃ­nimo)
        let worstScore = 100;
        let worstBand = null;
        let worstSeverity = 'OK';
        
        // Log detalhado
        const bandDetails = [];
        
        for (const bandKey of BAND_KEYS) {
            const eval_ = metricEvaluations[bandKey];
            const weight = BAND_WEIGHTS[bandKey] || (1 / BAND_KEYS.length);
            
            if (eval_ && eval_.score !== null && eval_.score !== undefined) {
                bandEvals[bandKey] = eval_;
                weightedSum += eval_.score * weight;
                totalWeight += weight;
                bandsWithScore++;
                
                // Contar severidades
                if (eval_.severity === 'CRÃTICA') criticalCount++;
                else if (eval_.severity === 'ALTA') highCount++;
                else if (eval_.severity === 'ATENÃ‡ÃƒO') attentionCount++;
                
                // Rastrear pior banda
                if (eval_.score < worstScore) {
                    worstScore = eval_.score;
                    worstBand = bandKey;
                    worstSeverity = eval_.severity;
                }
                
                bandDetails.push({
                    band: bandKey,
                    score: eval_.score,
                    severity: eval_.severity,
                    weight: weight,
                    contribution: (eval_.score * weight).toFixed(2)
                });
            }
        }
        
        if (totalWeight === 0 || bandsWithScore === 0) {
            if (DEBUG) {
                log('ğŸ“Š [FREQ-SUBSCORE] Nenhuma banda vÃ¡lida');
            }
            return null;
        }
        
        // Score base ponderado
        const weightedAvg = Math.round(weightedSum / totalWeight);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸš¨ V4.0: CÃLCULO DO SCORE FINAL - NUNCA IGNORAR ERROS CRÃTICOS
        // FÃ³rmula: score = 0.6 * mÃ©dia_ponderada + 0.4 * pior_banda
        // Isso garante que erros crÃ­ticos SEMPRE puxem o score para baixo
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let rawScore = Math.round(0.6 * weightedAvg + 0.4 * worstScore);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸš¨ V4.0: GATES DE SANIDADE MAIS AGRESSIVOS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let appliedCap = null;
        let capReason = null;
        
        // Regra 0: QUALQUER banda CRÃTICA â†’ cap no mÃ¡ximo score dessa banda + 10
        if (criticalCount >= 1 && worstSeverity === 'CRÃTICA') {
            const criticalCap = Math.min(worstScore + 10, 65);
            if (appliedCap === null || criticalCap < appliedCap) {
                appliedCap = criticalCap;
                capReason = `1+ banda CRÃTICA (${worstBand}: ${worstScore})`;
            }
        }
        
        // Regra 1: 3+ bandas CRÃTICAS â†’ cap 45 (muito grave)
        if (criticalCount >= 3) {
            const cap = 45;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${criticalCount} bandas CRÃTICAS`;
            }
        }
        // Regra 2: 2 bandas CRÃTICAS â†’ cap 55
        else if (criticalCount >= 2) {
            const cap = 55;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${criticalCount} bandas CRÃTICAS`;
            }
        }
        
        // Regra 3: 3+ bandas ALTA â†’ cap 70
        if (highCount >= 3) {
            const cap = 70;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} bandas ALTA`;
            }
        }
        // Regra 4: 2 bandas ALTA â†’ cap 78
        else if (highCount >= 2) {
            const cap = 78;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} bandas ALTA`;
            }
        }
        // Regra 5: 1 banda ALTA â†’ cap 85
        else if (highCount >= 1) {
            const cap = 85;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} banda ALTA`;
            }
        }
        
        // Regra 6: 3+ bandas ATENÃ‡ÃƒO â†’ cap 88
        if (attentionCount >= 3) {
            const cap = 88;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${attentionCount} bandas ATENÃ‡ÃƒO`;
            }
        }
        // Regra 7: 2 bandas ATENÃ‡ÃƒO â†’ cap 92
        else if (attentionCount >= 2) {
            const cap = 92;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${attentionCount} bandas ATENÃ‡ÃƒO`;
            }
        }
        
        // Aplicar cap se necessÃ¡rio
        const finalScore = appliedCap !== null ? Math.min(rawScore, appliedCap) : rawScore;
        
        // Log detalhado
        if (DEBUG) {
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            log('ğŸ“Š [FREQ-SUBSCORE V4.0] CÃ¡lculo Detalhado');
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.table(bandDetails);
            log('ğŸ“Š Contagem de severidades:', {
                CRÃTICA: criticalCount,
                ALTA: highCount,
                ATENÃ‡ÃƒO: attentionCount,
                OK: bandsWithScore - criticalCount - highCount - attentionCount
            });
            log('ğŸ“Š Pior banda:', worstBand, 'â†’', worstScore, `(${worstSeverity})`);
            log('ğŸ“Š MÃ©dia ponderada:', weightedAvg);
            log('ğŸ“Š Score RAW (0.6*avg + 0.4*worst):', rawScore);
            if (appliedCap !== null) {
                log(`ğŸš¨ GATE APLICADO: Cap ${appliedCap} (${capReason})`);
            }
            log('ğŸ“Š Score FINAL:', finalScore);
            log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        }
        
        return {
            score: finalScore,
            rawScore,
            weightedAvg,
            worstScore,
            worstBand,
            worstSeverity,
            appliedCap,
            capReason,
            criticalCount,
            highCount,
            attentionCount,
            bandDetails
        };
    }
    
    // Calcular subscore de frequÃªncia com o novo sistema
    const freqResult = calculateFrequencySubscore();
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ STREAMING MODE â€” SUBSCORES DIRETOS (NÃƒO usar mÃ©dia)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORREÃ‡ÃƒO CRÃTICA: Em modo streaming, LUFS e TRUE PEAK jÃ¡ passaram
    // pelas funÃ§Ãµes Strict que retornam o score FINAL correto.
    // NÃƒO devemos fazer mÃ©dia com RMS, nem normalizar depois!
    
    const analysisMode = analysis?.mode || 'genre';
    let loudnessSubscore = null;
    let technicalSubscore = null;
    
    if (analysisMode === 'streaming') {
        error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  ğŸ¯ STREAMING MODE â€” SUBSCORES DIRETOS                   â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // LOUDNESS: usar SOMENTE LUFS score (sem mÃ©dia com RMS)
        loudnessSubscore = metricEvaluations.lufs?.score ?? null;
        
        error('[STREAMING-SUBSCORE] Loudness subscore DIRETO:', loudnessSubscore);
        error('[STREAMING-SUBSCORE] LUFS score usado:', metricEvaluations.lufs?.score);
        error('[STREAMING-SUBSCORE] LUFS severity:', metricEvaluations.lufs?.severity);
        error('[STREAMING-SUBSCORE] LUFS zone:', metricEvaluations.lufs?.streamingZone);
        error('[STREAMING-SUBSCORE] LUFS conformance:', metricEvaluations.lufs?.conformance);
        error('\n');
        
        // TECHNICAL: usar SOMENTE TRUE PEAK score (sem mÃ©dia com outras mÃ©tricas)
        technicalSubscore = metricEvaluations.truePeak?.score ?? null;
        
        error('[STREAMING-SUBSCORE] Technical subscore DIRETO:', technicalSubscore);
        error('[STREAMING-SUBSCORE] True Peak score usado:', metricEvaluations.truePeak?.score);
        error('[STREAMING-SUBSCORE] True Peak severity:', metricEvaluations.truePeak?.severity);
        error('[STREAMING-SUBSCORE] True Peak zone:', metricEvaluations.truePeak?.streamingZone);
        error('[STREAMING-SUBSCORE] True Peak conformance:', metricEvaluations.truePeak?.conformance);
        error('\n');
    } else {
        // OUTROS MODOS: usar mÃ©dia como sempre foi
        loudnessSubscore = avgValidScores(['lufs', 'rms']);
        technicalSubscore = avgValidScores(['truePeak', 'samplePeak', 'clipping', 'dcOffset']);
    }
    
    const subScoresRaw = {
        loudness: loudnessSubscore,
        technical: technicalSubscore,
        dynamics: avgValidScores(['dr', 'crest', 'lra']),
        stereo: avgValidScores(['correlation', 'width']),
        frequency: freqResult?.score ?? null,
        // Metadados extras do frequency para debug
        _frequencyDetails: freqResult
    };
    
    // ğŸš¨ LOG CRÃTICO: Subscore RAW de loudness ANTES dos gates
    error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    error('â•‘  ğŸ“Š SUBSCORE RAW DE LOUDNESS CALCULADO                   â•‘');
    error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    error('[LOUDNESS-SUBSCORE] Analysis mode:', analysisMode);
    error('[LOUDNESS-SUBSCORE] Subscore RAW:', subScoresRaw.loudness);
    error('[LOUDNESS-SUBSCORE] LUFS score:', metricEvaluations.lufs?.score);
    error('[LOUDNESS-SUBSCORE] RMS score:', metricEvaluations.rms?.score);
    error('[LOUDNESS-SUBSCORE] LUFS medido:', measured.lufs);
    error('[LOUDNESS-SUBSCORE] LUFS target:', finalTargets.lufs.target);
    error('[LOUDNESS-SUBSCORE] Diff (LU):', Math.abs(measured.lufs - finalTargets.lufs.target).toFixed(2));
    error('[LOUDNESS-SUBSCORE] soundDestination:', soundDest);
    error('\n');
    
    if (DEBUG) {
        log('ğŸ“Š SubScores RAW:', subScoresRaw);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 5. APLICAR GATES AOS SUBSCORES (baseado na severidade de evaluateMetric)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const gatesTriggered = [];
    const subscores = { ...subScoresRaw };
    
    // ğŸ¯ Gate #1: True Peak - Se evaluateMetric retornou CRÃTICA ou ALTA
    // CORREÃ‡ÃƒO V2: NÃƒO aplicar em streaming (score jÃ¡ vem direto, gate Ã© redundante)
    const tpEval = metricEvaluations.truePeak;
    if (analysisMode !== 'streaming' && 
        tpEval && (tpEval.severity === 'CRÃTICA' || tpEval.severity === 'ALTA')) {
        // Cap baseado no score da avaliaÃ§Ã£o
        const cap = Math.min(tpEval.score + 5, 65); // Cap mÃ¡ximo 65 para True Peak problemÃ¡tico
        
        if (subscores.technical !== null && subscores.technical > cap) {
            const oldValue = subscores.technical;
            subscores.technical = Math.round(cap);
            gatesTriggered.push({
                type: 'TRUE_PEAK_GATE',
                subscore: 'technical',
                value: measured.truePeak,
                target: finalTargets.truePeak.target,
                evalScore: tpEval.score,
                evalSeverity: tpEval.severity,
                cap,
                oldValue,
                newValue: subscores.technical,
                reason: tpEval.reason
            });
        }
    }
    
    // ğŸ¯ Gate #2: Clipping > 0.5% â†’ cap Technical subscore
    if (measured.clipping > 0.5) {
        const cap = Math.max(30, 80 - (measured.clipping - 0.5) * 10);
        const severity = measured.clipping > 5 ? 'CRÃTICA' : measured.clipping > 2 ? 'ALTA' : 'MODERADA';
        
        if (subscores.technical !== null && subscores.technical > cap) {
            const oldValue = subscores.technical;
            subscores.technical = Math.round(cap);
            gatesTriggered.push({
                type: 'CLIPPING_GATE',
                subscore: 'technical',
                value: measured.clipping,
                limit: 0.5,
                cap,
                oldValue,
                newValue: subscores.technical,
                severity
            });
        }
    }
    
    // ğŸ¯ Gate #3: LUFS excessivo - Se evaluateMetric retornou CRÃTICA
    // ğŸš¨ EXCEÃ‡ÃƒO CRÃTICA: NÃƒO aplicar em STREAMING
    // Em streaming, o target jÃ¡ Ã© -14 LUFS (mais baixo) e o range de tolerÃ¢ncia resolve o problema
    // Aplicar gate em streaming causaria penalizaÃ§Ã£o dupla e incorreta
    // CORREÃ‡ÃƒO V2: Usar analysisMode (nÃ£o soundDest) para consistÃªncia
    const lufsEval = metricEvaluations.lufs;
    
    if (lufsEval && lufsEval.severity === 'CRÃTICA' && analysisMode !== 'streaming') {
        error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  ğŸš« LUFS_GATE: Aplicando penalizaÃ§Ã£o (modo pista)        â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('[LUFS_GATE] Analysis mode:', analysisMode);
        error('[LUFS_GATE] LUFS medido:', measured.lufs);
        error('[LUFS_GATE] Target:', finalTargets.lufs.target);
        error('[LUFS_GATE] Severidade:', lufsEval.severity);
        error('\n');
        
        const cap = Math.min(lufsEval.score + 5, 67);
        
        if (subscores.loudness !== null && subscores.loudness > cap) {
            const oldValue = subscores.loudness;
            subscores.loudness = Math.round(cap);
            gatesTriggered.push({
                type: 'LUFS_GATE',
                subscore: 'loudness',
                value: measured.lufs,
                target: finalTargets.lufs.target,
                evalScore: lufsEval.score,
                evalSeverity: lufsEval.severity,
                cap,
                oldValue,
                newValue: subscores.loudness,
                reason: lufsEval.reason
            });
        }
    } else if (lufsEval && lufsEval.severity === 'CRÃTICA' && analysisMode === 'streaming') {
        // ğŸ¯ Log quando gate Ã© BLOQUEADO em streaming
        error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        error('â•‘  âœ… LUFS_GATE: BLOQUEADO (modo streaming)                â•‘');
        error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        error('[LUFS_GATE] Analysis mode:', analysisMode);
        error('[LUFS_GATE] LUFS medido:', measured.lufs);
        error('[LUFS_GATE] Target streaming:', finalTargets.lufs.target);
        error('[LUFS_GATE] Subscore mantido:', subscores.loudness);
        error('[LUFS_GATE] Gate NÃƒO aplicado - target streaming jÃ¡ Ã© adequado');
        error('\n');
    }
    
    // ğŸ¯ Gate #4: FREQUENCY - Bandas com severidade alta
    // Este gate aplica cap adicional se os gates internos do calculateFrequencySubscore nÃ£o foram suficientes
    if (freqResult && (freqResult.criticalCount > 0 || freqResult.highCount >= 2)) {
        const oldValue = subscores.frequency;
        // Se jÃ¡ aplicamos cap interno, o gate externo sÃ³ registra
        // Se nÃ£o, aplicamos um cap de seguranÃ§a
        const internalCap = freqResult.appliedCap;
        
        // Gate externo: garantir coerÃªncia com subscores.frequency
        if (internalCap !== null && oldValue !== freqResult.score) {
            // Houve alguma inconsistÃªncia - forÃ§ar o valor correto
            subscores.frequency = freqResult.score;
        }
        
        gatesTriggered.push({
            type: 'FREQUENCY_GATE',
            subscore: 'frequency',
            criticalCount: freqResult.criticalCount,
            highCount: freqResult.highCount,
            attentionCount: freqResult.attentionCount,
            rawScore: freqResult.rawScore,
            appliedCap: freqResult.appliedCap,
            capReason: freqResult.capReason,
            oldValue: freqResult.rawScore,
            newValue: freqResult.score,
            bandDetails: freqResult.bandDetails
        });
    }
    
    if (DEBUG) {
        log('ğŸ“Š Gates Triggered:', gatesTriggered);
        log('ğŸ“Š SubScores AFTER GATES:', subscores);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 6. CALCULAR SCORE FINAL (mÃ©dia ponderada dos subscores COM GATES)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const WEIGHTS = {
        loudness: 0.25,
        technical: 0.25,
        dynamics: 0.20,
        stereo: 0.15,
        frequency: 0.15
    };
    
    let weightedSum = 0;
    let totalWeight = 0;
    
    for (const [key, weight] of Object.entries(WEIGHTS)) {
        if (subscores[key] !== null) {
            weightedSum += subscores[key] * weight;
            totalWeight += weight;
        }
    }
    
    // Raw = mÃ©dia dos subscores SEM gates
    let rawSum = 0;
    let rawWeight = 0;
    for (const [key, weight] of Object.entries(WEIGHTS)) {
        if (subScoresRaw[key] !== null) {
            rawSum += subScoresRaw[key] * weight;
            rawWeight += weight;
        }
    }
    const raw = rawWeight > 0 ? Math.round(rawSum / rawWeight) : 50;
    
    // Final = mÃ©dia dos subscores COM gates aplicados
    const final = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 50;
    
    if (DEBUG) {
        log('ğŸ“Š Score RAW (sem gates):', raw);
        log('ğŸ“Š Score FINAL (com gates nos subscores):', final);
        console.groupEnd();
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 7. RETORNAR DEBUG ESTRUTURADO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    return {
        raw,
        final,
        subscores,           // Com gates aplicados
        subScoresRaw,        // Sem gates (para debug)
        gatesTriggered,      // Detalhes de cada gate
        metricEvaluations,   // Cada mÃ©trica avaliada por evaluateMetric
        _frequencyDetails: freqResult, // Detalhes do cÃ¡lculo de frequÃªncia V3.7.1
        // Compatibilidade com formato antigo
        gatePenalty: raw - final,
        gateReasons: gatesTriggered,
        metricScores: metricEvaluations, // Alias
        debug: {
            mode,
            measured,
            targets: finalTargets,
            weights: WEIGHTS,
            totalWeight,
            version: 'V3.7.1-FREQ-WEIGHTED'
        }
    };
};

// Alias para compatibilidade
window.calculateScoreV3 = window.computeScoreV3;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  DIAGNÃ“STICO SONORO INTELIGENTE V1.0
// FunÃ§Ã£o que transforma mÃ©tricas tÃ©cnicas em contexto semÃ¢ntico para IA/UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * ConstrÃ³i contexto diagnÃ³stico semÃ¢ntico a partir dos resultados de computeScoreV3
 * @param {Object} scoreResult - Resultado de computeScoreV3 (metricEvaluations, subscores, etc)
 * @param {Object} analysisMeta - Metadados da anÃ¡lise (modo, gÃªnero, referÃªncia, etc)
 * @returns {Object} { problems: [], strengths: [], context: {} }
 */
window.buildDiagnosticContext = function(scoreResult, analysisMeta = {}) {
    const DEBUG = true;
    
    if (DEBUG) {
        console.group('ğŸ§  [buildDiagnosticContext V1.0] Construindo contexto semÃ¢ntico');
        log('ğŸ“Š scoreResult keys:', Object.keys(scoreResult || {}));
        log('ğŸ“Š analysisMeta:', analysisMeta);
    }
    
    if (!scoreResult || !scoreResult.metricEvaluations) {
        warn('âš ï¸ [buildDiagnosticContext] Dados insuficientes');
        if (DEBUG) console.groupEnd();
        return { problems: [], strengths: [], context: { valid: false } };
    }
    
    const evals = scoreResult.metricEvaluations;
    const subscores = scoreResult.subscores || {};
    const gatesTriggered = scoreResult.gatesTriggered || [];
    const freqDetails = scoreResult._frequencyDetails || {};
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAPEAMENTO SEMÃ‚NTICO DE MÃ‰TRICAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const METRIC_SEMANTICS = {
        // Loudness
        lufs: {
            name: 'Volume Integrado (LUFS)',
            category: 'loudness',
            problemTemplates: {
                high: 'Ãudio estÃ¡ muito alto ({value} LUFS vs target {target} LUFS). Pode sofrer limitaÃ§Ã£o em plataformas de streaming.',
                low: 'Ãudio estÃ¡ muito baixo ({value} LUFS vs target {target} LUFS). Pode parecer fraco comparado a outras faixas.',
                critical: 'Volume estÃ¡ extremamente fora do padrÃ£o ({value} LUFS vs target {target} LUFS). Requer ajuste urgente de loudness.'
            },
            strengthTemplate: 'Volume integrado adequado ({value} LUFS), otimizado para {mode}.'
        },
        rms: {
            name: 'RMS MÃ©dio',
            category: 'loudness',
            problemTemplates: {
                high: 'RMS muito alto ({value} dB), indicando possÃ­vel over-compression.',
                low: 'RMS baixo demais ({value} dB), Ã¡udio pode parecer muito quieto.',
                critical: 'RMS drasticamente fora do esperado ({value} dB).'
            },
            strengthTemplate: 'NÃ­vel RMS balanceado ({value} dB).'
        },
        
        // Technical
        truePeak: {
            name: 'True Peak',
            category: 'technical',
            highReliability: true,
            problemTemplates: {
                high: 'True Peak excede o limite seguro ({value} dBTP). CausarÃ¡ distorÃ§Ã£o apÃ³s codec lossy.',
                critical: 'True Peak CRÃTICO ({value} dBTP). Ãudio vai distorcer em qualquer plataforma.'
            },
            strengthTemplate: 'True Peak dentro do limite seguro ({value} dBTP).'
        },
        clipping: {
            name: 'Clipping Digital',
            category: 'technical',
            highReliability: true,
            problemTemplates: {
                high: 'Detectado clipping ({value}%). Pode causar distorÃ§Ã£o audÃ­vel.',
                critical: 'Clipping excessivo ({value}%). DistorÃ§Ã£o severa no Ã¡udio.'
            },
            strengthTemplate: 'Sem clipping digital detectado.'
        },
        dcOffset: {
            name: 'DC Offset',
            category: 'technical',
            problemTemplates: {
                high: 'DC Offset detectado ({value}%). Pode reduzir headroom disponÃ­vel.',
                critical: 'DC Offset significativo ({value}%). Requer correÃ§Ã£o.'
            },
            strengthTemplate: 'DC Offset negligÃ­vel.'
        },
        
        // Dynamics
        dr: {
            name: 'Dynamic Range',
            category: 'dynamics',
            problemTemplates: {
                high: 'Dynamic Range muito alto ({value} dB). Pode soar inconsistente em volumes diferentes.',
                low: 'Dynamic Range muito baixo ({value} dB). Ãudio pode soar comprimido/sem vida.',
                critical: 'Dynamic Range extremo ({value} dB vs esperado {target} dB). Verificar compressÃ£o/limiting.'
            },
            strengthTemplate: 'Dynamic Range adequado para {mode} ({value} dB).'
        },
        lra: {
            name: 'Loudness Range (LRA)',
            category: 'dynamics',
            problemTemplates: {
                high: 'LRA muito amplo ({value} LU). Partes podem parecer muito mais altas/baixas.',
                low: 'LRA muito estreito ({value} LU). Pode indicar over-limiting.',
                critical: 'LRA fora dos padrÃµes ({value} LU).'
            },
            strengthTemplate: 'Loudness Range equilibrado ({value} LU).'
        },
        crest: {
            name: 'Crest Factor',
            category: 'dynamics',
            problemTemplates: {
                high: 'Crest Factor alto ({value} dB). Transients podem nÃ£o estar bem controlados.',
                low: 'Crest Factor baixo ({value} dB). PossÃ­vel over-compression.',
                critical: 'Crest Factor extremo ({value} dB).'
            },
            strengthTemplate: 'Crest Factor adequado ({value} dB).'
        },
        
        // Stereo
        correlation: {
            name: 'CorrelaÃ§Ã£o EstÃ©reo',
            category: 'stereo',
            highReliability: true,
            problemTemplates: {
                low: 'CorrelaÃ§Ã£o estÃ©reo baixa ({value}). Pode haver problemas de fase ou cancelamento em mono.',
                critical: 'CorrelaÃ§Ã£o muito baixa ({value}). PossÃ­vel inversÃ£o de fase ou problemas graves de compatibilidade mono.'
            },
            strengthTemplate: 'CorrelaÃ§Ã£o estÃ©reo saudÃ¡vel ({value}).'
        },
        width: {
            name: 'Largura EstÃ©reo',
            category: 'stereo',
            problemTemplates: {
                high: 'EstÃ©reo muito largo ({value}). Pode parecer "falso" ou ter problemas em mono.',
                low: 'EstÃ©reo estreito demais ({value}). Mix pode parecer "fechado".',
                critical: 'Largura estÃ©reo extrema ({value}).'
            },
            strengthTemplate: 'Largura estÃ©reo apropriada ({value}).'
        },
        
        // Frequency Bands
        sub: { name: 'Sub-graves (20-60Hz)', category: 'frequency' },
        bass: { name: 'Graves (60-250Hz)', category: 'frequency' },
        lowMid: { name: 'MÃ©dio-graves (250-500Hz)', category: 'frequency' },
        mid: { name: 'MÃ©dios (500-2kHz)', category: 'frequency' },
        highMid: { name: 'MÃ©dio-agudos (2-4kHz)', category: 'frequency' },
        presence: { name: 'PresenÃ§a (4-8kHz)', category: 'frequency' },
        air: { name: 'Air (8-20kHz)', category: 'frequency' }
    };
    
    const BAND_PROBLEM_TEMPLATE = {
        high: '{name} com excesso ({value} dB vs target {target} dB). Pode causar {effect}.',
        low: '{name} com dÃ©ficit ({value} dB vs target {target} dB). Pode causar {effect}.',
        critical: '{name} criticamente fora do range ({value} dB). Requer EQ corretiva urgente.'
    };
    
    const BAND_EFFECTS = {
        sub: { high: 'peso excessivo ou rumble', low: 'falta de peso/fundaÃ§Ã£o' },
        bass: { high: 'mixagem "muddy" ou embolada', low: 'mix fina/sem corpo' },
        lowMid: { high: 'mixagem "boxy" ou abafada', low: 'falta de corpo nos instrumentos' },
        mid: { high: 'som "nasal" ou fatigante', low: 'falta de presenÃ§a e clareza' },
        highMid: { high: 'som agressivo/estridente', low: 'falta de definiÃ§Ã£o/corte' },
        presence: { high: 'sibilÃ¢ncia excessiva', low: 'som apagado/distante' },
        air: { high: 'ruÃ­do/aspereza no high-end', low: 'falta de brilho/abertura' }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTRUIR ARRAYS DE PROBLEMAS E PONTOS FORTES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const problems = [];
    const strengths = [];
    
    // Processar cada mÃ©trica avaliada
    for (const [metricKey, evaluation] of Object.entries(evals)) {
        if (!evaluation || evaluation.score === null) continue;
        
        const semantic = METRIC_SEMANTICS[metricKey];
        if (!semantic) continue;
        
        const { severity, score, deviation, value, target } = evaluation;
        const mode = analysisMeta.mode || 'streaming';
        
        // Determinar se Ã© PROBLEMA ou PONTO FORTE
        if (severity === 'CRÃTICA' || severity === 'ALTA' || severity === 'ATENÃ‡ÃƒO') {
            // Ã‰ um problema
            let problemText = '';
            const direction = deviation > 0 ? 'high' : 'low';
            
            // Para bandas de frequÃªncia
            if (semantic.category === 'frequency') {
                const template = severity === 'CRÃTICA' 
                    ? BAND_PROBLEM_TEMPLATE.critical 
                    : BAND_PROBLEM_TEMPLATE[direction];
                const effect = BAND_EFFECTS[metricKey]?.[direction] || 'problemas de balanÃ§o';
                
                problemText = template
                    .replace('{name}', semantic.name)
                    .replace('{value}', value?.toFixed?.(1) ?? '?')
                    .replace('{target}', target?.toFixed?.(1) ?? '?')
                    .replace('{effect}', effect);
            } else {
                // Para outras mÃ©tricas
                const templates = semantic.problemTemplates || {};
                const templateKey = severity === 'CRÃTICA' ? 'critical' : direction;
                const template = templates[templateKey] || templates.high || templates.low || `${semantic.name} fora do ideal ({value}).`;
                
                problemText = template
                    .replace('{value}', typeof value === 'number' ? value.toFixed(1) : String(value))
                    .replace('{target}', typeof target === 'number' ? target.toFixed(1) : String(target))
                    .replace('{mode}', mode);
            }
            
            problems.push({
                metric: metricKey,
                name: semantic.name,
                category: semantic.category,
                severity,
                score,
                deviation,
                text: problemText,
                value,
                target,
                isHighReliability: semantic.highReliability === true
            });
        } else if (severity === 'OK' && score >= 90) {
            // Ã‰ um ponto forte
            const template = semantic.strengthTemplate || `${semantic.name} estÃ¡ bom.`;
            const strengthText = template
                .replace('{value}', typeof value === 'number' ? value.toFixed(1) : String(value))
                .replace('{target}', typeof target === 'number' ? target.toFixed(1) : String(target))
                .replace('{mode}', mode);
            
            strengths.push({
                metric: metricKey,
                name: semantic.name,
                category: semantic.category,
                score,
                text: strengthText,
                value,
                isHighReliability: semantic.highReliability === true
            });
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ORDENAR PROBLEMAS POR PRIORIDADE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const SEVERITY_ORDER = { 'CRÃTICA': 0, 'ALTA': 1, 'ATENÃ‡ÃƒO': 2 };
    const CATEGORY_ORDER = { 'technical': 0, 'loudness': 1, 'dynamics': 2, 'stereo': 3, 'frequency': 4 };
    
    problems.sort((a, b) => {
        // 1. Priorizar alta confiabilidade
        if (a.isHighReliability && !b.isHighReliability) return -1;
        if (!a.isHighReliability && b.isHighReliability) return 1;
        
        // 2. Por severidade
        const sevA = SEVERITY_ORDER[a.severity] ?? 99;
        const sevB = SEVERITY_ORDER[b.severity] ?? 99;
        if (sevA !== sevB) return sevA - sevB;
        
        // 3. Por categoria
        const catA = CATEGORY_ORDER[a.category] ?? 99;
        const catB = CATEGORY_ORDER[b.category] ?? 99;
        return catA - catB;
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONSTRUIR CONTEXTO GERAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const context = {
        valid: true,
        finalScore: scoreResult.final,
        rawScore: scoreResult.raw,
        mode: analysisMeta.mode || 'streaming',
        genre: analysisMeta.genre || null,
        reference: analysisMeta.reference || null,
        
        // Resumos por categoria
        subscoresSummary: {
            loudness: { score: subscores.loudness, status: getStatusFromScore(subscores.loudness) },
            technical: { score: subscores.technical, status: getStatusFromScore(subscores.technical) },
            dynamics: { score: subscores.dynamics, status: getStatusFromScore(subscores.dynamics) },
            stereo: { score: subscores.stereo, status: getStatusFromScore(subscores.stereo) },
            frequency: { score: subscores.frequency, status: getStatusFromScore(subscores.frequency) }
        },
        
        // EstatÃ­sticas
        stats: {
            totalProblems: problems.length,
            criticalProblems: problems.filter(p => p.severity === 'CRÃTICA').length,
            highProblems: problems.filter(p => p.severity === 'ALTA').length,
            attentionProblems: problems.filter(p => p.severity === 'ATENÃ‡ÃƒO').length,
            totalStrengths: strengths.length,
            gatesApplied: gatesTriggered.length
        },
        
        // Gates em linguagem humana
        gatesSummary: gatesTriggered.map(g => {
            if (g.type === 'TRUE_PEAK_GATE') return `True Peak excessivo limitou o score tÃ©cnico`;
            if (g.type === 'CLIPPING_GATE') return `Clipping detectado limitou o score tÃ©cnico`;
            if (g.type === 'LUFS_GATE') return `Volume extremo limitou o score de loudness`;
            if (g.type === 'FREQUENCY_GATE') return `Bandas crÃ­ticas limitaram o score de frequÃªncia`;
            return `Gate ${g.type} aplicado`;
        })
    };
    
    // FunÃ§Ã£o helper para status
    function getStatusFromScore(score) {
        if (score === null) return 'indisponÃ­vel';
        if (score >= 90) return 'excelente';
        if (score >= 75) return 'bom';
        if (score >= 60) return 'regular';
        if (score >= 40) return 'precisa melhorar';
        return 'crÃ­tico';
    }
    
    if (DEBUG) {
        log('ğŸ“Š Problems encontrados:', problems.length);
        log('ğŸ“Š Strengths encontrados:', strengths.length);
        log('ğŸ“Š Context:', context);
        console.groupEnd();
    }
    
    return { problems, strengths, context };
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  V7.0: VEREDITO SONORO INTELIGENTE - ULTRA PREMIUM
// Engenharia de Ã¡udio + FÃ­sica do som + PsicoacÃºstica + NeurociÃªncia
// Estrutura: 1) TÃ©cnico+FÃ­sico | 2) PsicoacÃºstico/Neural | 3) CorreÃ§Ã£o+BenefÃ­cio
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Gera veredito sonoro inteligente - 3 frases combinando engenharia, fÃ­sica e neurociÃªncia
 * @param {Object} diagnostic - Resultado de buildDiagnosticContext
 * @returns {string} Texto de 3 frases em linguagem tÃ©cnica + perceptiva
 */
window.generateFinalDiagnosticText = function(diagnostic) {
    if (!diagnostic || !diagnostic.context?.valid) {
        return null;
    }
    
    const { problems, strengths, context } = diagnostic;
    const { finalScore, stats, subscoresSummary } = context;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // V7.0: VEREDITO SONORO INTELIGENTE
    // Estrutura obrigatÃ³ria de 3 frases:
    // 1. DiagnÃ³stico tÃ©cnico + consequÃªncia fÃ­sica no sistema de som
    // 2. Impacto psicoacÃºstico no ouvido e cÃ©rebro humano
    // 3. Direcionamento de correÃ§Ã£o + benefÃ­cio perceptivo
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Identificar problemas principais
    const criticalProblems = problems.filter(p => p.severity === 'CRÃTICA');
    const highProblems = problems.filter(p => p.severity === 'ALTA');
    const topProblems = [...criticalProblems, ...highProblems].slice(0, 3);
    
    // Mapear categorias para impactos fÃ­sicos + neurais
    const AUDIO_SCIENCE = {
        technical: {
            techPhysical: 'clipping ou saturaÃ§Ã£o que gera harmÃ´nicos indesejados, forÃ§ando falantes a reproduzir frequÃªncias distorcidas',
            psychoacoustic: 'o ouvido humano percebe aspereza e o cÃ©rebro interpreta como agressÃ£o sonora, ativando fadiga e desconforto imediatos',
            correction: 'controle de picos e limitaÃ§Ã£o restaurarÃ£o a integridade do sinal e permitirÃ£o escuta prolongada sem irritaÃ§Ã£o'
        },
        loudness: {
            techPhysical: 'intensidade fora do padrÃ£o de distribuiÃ§Ã£o que causa excursÃ£o irregular nos transdutores e inconsistÃªncia em sistemas PA',
            psychoacoustic: 'o sistema auditivo Ã© forÃ§ado a recalibrar ganho constantemente, gerando fadiga subliminar e perda de atenÃ§Ã£o',
            correction: 'calibraÃ§Ã£o de loudness garantirÃ¡ consistÃªncia entre plataformas e uma experiÃªncia de escuta equilibrada e confortÃ¡vel'
        },
        dynamics: {
            techPhysical: 'compressÃ£o excessiva que achata transientes e remove a micro-dinÃ¢mica essencial para definiÃ§Ã£o em caixas de som',
            psychoacoustic: 'o cÃ©rebro perde referÃªncias de profundidade e espacialidade, reduzindo o engajamento emocional com a mÃºsica',
            correction: 'preservaÃ§Ã£o de dinÃ¢mica devolverÃ¡ impacto aos transientes e reconectarÃ¡ o ouvinte Ã  energia natural da faixa'
        },
        stereo: {
            techPhysical: 'problemas de correlaÃ§Ã£o estÃ©reo que causam cancelamento de fase em sistemas mono e imagem instÃ¡vel em PA',
            psychoacoustic: 'o processamento binaural do cÃ©rebro nÃ£o consegue posicionar fontes no espaÃ§o, gerando confusÃ£o e desconforto espacial',
            correction: 'correÃ§Ã£o de coerÃªncia estÃ©reo restaurarÃ¡ a espacialidade natural e garantirÃ¡ compatibilidade em qualquer sistema'
        },
        frequency: {
            techPhysical: 'desequilÃ­brio espectral que sobrecarrega regiÃµes especÃ­ficas dos falantes, causando perda de definiÃ§Ã£o e traduÃ§Ã£o inconsistente',
            psychoacoustic: 'o cÃ³rtex auditivo recebe informaÃ§Ã£o incompleta, induzindo fadiga neural acelerada e tendÃªncia Ã  rejeiÃ§Ã£o da mÃºsica',
            correction: 'balanÃ§o tonal adequado permitirÃ¡ traduÃ§Ã£o fiel em qualquer sistema e uma experiÃªncia de escuta fluida e agradÃ¡vel'
        }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCORE EXCELENTE (90+) - Conforto mÃ¡ximo
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (finalScore >= 90 && stats.criticalProblems === 0) {
        return 'Sua faixa apresenta balanÃ§o espectral e dinÃ¢mica que garantem reproduÃ§Ã£o fiel em qualquer sistema de som, de fones a PA profissional. O ouvido humano processa o material sem esforÃ§o, e o cÃ©rebro mantÃ©m engajamento atencional elevado durante toda a escuta. A masterizaÃ§Ã£o estÃ¡ pronta para distribuiÃ§Ã£o com excelÃªncia tÃ©cnica e perceptiva.';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCORE BOM (75-89) - Refinamentos pontuais
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (finalScore >= 75 && stats.criticalProblems === 0) {
        const worstCategory = Object.entries(subscoresSummary)
            .filter(([_, v]) => v.score !== null && v.score < 85)
            .sort((a, b) => a[1].score - b[1].score)[0];
        
        if (worstCategory) {
            const science = AUDIO_SCIENCE[worstCategory[0]];
            if (science) {
                return `Sua faixa estÃ¡ prÃ³xima do ideal, mas apresenta ${science.techPhysical}. Em escutas prolongadas, ${science.psychoacoustic}. ${science.correction.charAt(0).toUpperCase() + science.correction.slice(1)}.`;
            }
        }
        return 'Sua faixa apresenta qualidade sÃ³lida com pequenas irregularidades que podem causar leve inconsistÃªncia em sistemas de alta fidelidade. O cÃ©rebro processa bem o material, mas escutas repetidas podem induzir fadiga sutil. Refinamentos pontuais elevarÃ£o o conforto auditivo ao padrÃ£o profissional.';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCORE MÃ‰DIO (60-74) - Ajustes necessÃ¡rios
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (finalScore >= 60) {
        const problemCategories = [...new Set(topProblems.map(p => p.category))].slice(0, 2);
        
        if (problemCategories.length >= 1) {
            const science = AUDIO_SCIENCE[problemCategories[0]];
            if (science) {
                return `Sua faixa apresenta ${science.techPhysical}. Isso faz com que ${science.psychoacoustic}. ${science.correction.charAt(0).toUpperCase() + science.correction.slice(1)}.`;
            }
        }
        
        return 'Sua faixa apresenta desequilÃ­brios que comprometem a traduÃ§Ã£o entre sistemas de som e causam fadiga em escutas prolongadas. O cÃ©rebro tende a desviar atenÃ§Ã£o de fontes sonoras que exigem esforÃ§o cognitivo excessivo. Ajustes no balanÃ§o espectral e dinÃ¢mica reduzirÃ£o a fadiga e aumentarÃ£o o engajamento do ouvinte.';
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCORE BAIXO (<60) - IntervenÃ§Ã£o necessÃ¡ria
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const criticalCategories = [...new Set(criticalProblems.map(p => p.category))];
    
    if (criticalCategories.includes('technical')) {
        return 'Sua faixa apresenta distorÃ§Ã£o severa que gera harmÃ´nicos nocivos, forÃ§ando falantes a operar fora de sua linearidade e causando artefatos audÃ­veis em qualquer sistema. O ouvido humano identifica isso como ruÃ­do agressivo, e o cÃ©rebro ativa mecanismos de proteÃ§Ã£o que impossibilitam escuta confortÃ¡vel. RevisÃ£o completa do controle de picos Ã© imprescindÃ­vel para viabilizar a distribuiÃ§Ã£o.';
    }
    
    if (criticalCategories.includes('frequency')) {
        return 'Sua faixa apresenta desequilÃ­brio espectral severo que sobrecarrega regiÃµes dos falantes, causando perda de definiÃ§Ã£o e traduÃ§Ã£o inconsistente entre sistemas. O cÃ³rtex auditivo recebe informaÃ§Ã£o assimÃ©trica, gerando fadiga neural acelerada e tendÃªncia instintiva Ã  rejeiÃ§Ã£o da mÃºsica. CorreÃ§Ã£o profunda no balanÃ§o tonal Ã© necessÃ¡ria para viabilizar uma experiÃªncia de escuta aceitÃ¡vel.';
    }
    
    if (criticalCategories.includes('loudness')) {
        return 'Sua faixa apresenta intensidade drasticamente fora do padrÃ£o, causando excursÃ£o excessiva em falantes e normalizaÃ§Ã£o agressiva nas plataformas de streaming. O sistema auditivo Ã© forÃ§ado a operar em zona de desconforto, ativando fadiga defensiva que reduz drasticamente o tempo de escuta tolerÃ¡vel. CalibraÃ§Ã£o de loudness Ã© essencial antes de qualquer distribuiÃ§Ã£o.';
    }
    
    return 'Sua faixa apresenta mÃºltiplos problemas tÃ©cnicos que comprometem a reproduÃ§Ã£o em sistemas de som e causam fadiga auditiva significativa. O cÃ©rebro nÃ£o consegue processar o material de forma relaxada, induzindo desengajamento e rejeiÃ§Ã£o perceptiva precoces. RevisÃ£o integral de mixagem e masterizaÃ§Ã£o Ã© necessÃ¡ria para garantir uma experiÃªncia de escuta profissional.';
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§ª TEST FUNCTION V3.6: Testa cenÃ¡rios com novo sistema de gates nos subscores
// Execute no console: window.__testScoreV3Scenarios()
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.__testScoreV3Scenarios = function() {
    log('\n');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ§ª TESTE V3.6: SINGLE SOURCE OF TRUTH - GATES NOS SUBSCORES');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    // CENÃRIO A: True Peak CRÃTICO (+2.0 dBTP)
    log('\nğŸ“‹ CENÃRIO A: True Peak CRÃTICO (+2.0 dBTP)');
    log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    log('Esperado: Gate capeia Technical subscore, nÃ£o o final');
    const scenarioA = {
        technicalData: {
            lufsIntegrated: -14.0,    // OK
            truePeakDbtp: 2.0,        // CRÃTICO! > 0 dBTP (+3 dB acima do max)
            dynamicRange: 8.0,        // OK
            crestFactor: 12.0,        // OK
            lra: 7.0,                 // OK
            stereoCorrelation: 0.9,   // OK
            stereoWidth: 0.7,         // OK
            clippingPct: 0.001,       // OK
            dcOffset: 0.0,            // OK
            bands: {
                sub: { energy_db: -28.0 },   // OK
                bass: { energy_db: -22.0 },  // OK
                mid: { energy_db: -18.0 },   // OK
            }
        }
    };
    
    const resultA = window.computeScoreV3(scenarioA, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0 },
            bass: { target_db: -22.0, tol_db: 3.0 },
            mid: { target_db: -18.0, tol_db: 3.0 }
        }
    }, 'streaming');
    
    log('ğŸ“Š RESULTADO CENÃRIO A:');
    log('   Valores medidos:', { truePeak: 2.0, lufs: -14.0, dr: 8.0 });
    log('   Raw Score (sem gates):', resultA.raw);
    log('   Final Score (com gates):', resultA.final);
    log('   SubScores RAW:', resultA.subScoresRaw);
    log('   SubScores APÃ“S GATES:', resultA.subscores);
    log('   Gates Triggered:', resultA.gatesTriggered);
    log('   evaluateMetric(truePeak):', resultA.metricEvaluations?.truePeak);
    
    // VerificaÃ§Ã£o: Technical subscore deve ter sido capeado
    const passA1 = resultA.subscores.technical < resultA.subScoresRaw.technical;
    const passA2 = resultA.gatesTriggered.some(g => g.type === 'TRUE_PEAK_GATE');
    const passA3 = resultA.metricEvaluations?.truePeak?.severity === 'CRÃTICA';
    log(passA1 ? 'âœ… Technical foi capeado' : 'âŒ Technical NÃƒO foi capeado');
    log(passA2 ? 'âœ… TRUE_PEAK_GATE foi triggered' : 'âŒ TRUE_PEAK_GATE NÃƒO foi triggered');
    log(passA3 ? 'âœ… Severidade truePeak = CRÃTICA' : 'âŒ Severidade truePeak != CRÃTICA');
    const passA = passA1 && passA2 && passA3;
    
    // CENÃRIO B: Sub/Bass CRÃTICOS (muito fora do range)
    log('\nğŸ“‹ CENÃRIO B: Sub/Bass CRÃTICOS (muito fora do range)');
    log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    log('Esperado: Frequency subscore baixo, sem gates (problema nas mÃ©tricas)');
    const scenarioB = {
        technicalData: {
            lufsIntegrated: -14.0,    // OK
            truePeakDbtp: -1.0,       // OK
            dynamicRange: 8.0,        // OK
            crestFactor: 12.0,        // OK
            lra: 7.0,                 // OK
            stereoCorrelation: 0.9,   // OK
            stereoWidth: 0.7,         // OK
            clippingPct: 0.001,       // OK
            dcOffset: 0.0,            // OK
            bands: {
                sub: { energy_db: -15.0 },   // CRÃTICO! +10 dB acima do max (-25)
                bass: { energy_db: -10.0 },  // CRÃTICO! +9 dB acima do max (-19)
                mid: { energy_db: -18.0 },   // OK
            }
        }
    };
    
    const resultB = window.computeScoreV3(scenarioB, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0, target_range: { min: -31.0, max: -25.0 } },
            bass: { target_db: -22.0, tol_db: 3.0, target_range: { min: -25.0, max: -19.0 } },
            mid: { target_db: -18.0, tol_db: 3.0, target_range: { min: -21.0, max: -15.0 } }
        }
    }, 'streaming');
    
    log('ğŸ“Š RESULTADO CENÃRIO B:');
    log('   Valores medidos (bands):', { sub: -15.0, bass: -10.0, mid: -18.0 });
    log('   Raw Score:', resultB.raw);
    log('   Final Score:', resultB.final);
    log('   SubScores:', resultB.subscores);
    log('   Frequency Score:', resultB.subscores.frequency);
    log('   evaluateMetric(sub):', resultB.metricEvaluations?.sub);
    log('   evaluateMetric(bass):', resultB.metricEvaluations?.bass);
    log('   Gates Triggered:', resultB.gatesTriggered?.length || 0);
    
    // VerificaÃ§Ã£o: Frequency subscore deve refletir a severidade das bandas
    const passB1 = resultB.subscores.frequency !== null && resultB.subscores.frequency <= 40;
    const passB2 = resultB.metricEvaluations?.sub?.severity === 'CRÃTICA';
    const passB3 = resultB.metricEvaluations?.bass?.severity === 'CRÃTICA';
    log(passB1 ? 'âœ… Frequency â‰¤ 40 (bandas crÃ­ticas)' : 'âŒ Frequency > 40');
    log(passB2 ? 'âœ… Sub severidade = CRÃTICA' : 'âŒ Sub severidade != CRÃTICA');
    log(passB3 ? 'âœ… Bass severidade = CRÃTICA' : 'âŒ Bass severidade != CRÃTICA');
    const passB = passB1 && passB2 && passB3;
    
    // CENÃRIO C: Tudo OK
    log('\nğŸ“‹ CENÃRIO C: Todas mÃ©tricas OK');
    log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    const scenarioC = {
        technicalData: {
            lufsIntegrated: -14.0,
            truePeakDbtp: -1.5,
            dynamicRange: 8.0,
            crestFactor: 12.0,
            lra: 7.0,
            stereoCorrelation: 0.9,
            stereoWidth: 0.7,
            clippingPct: 0.0,
            dcOffset: 0.0,
            bands: {
                sub: { energy_db: -28.0 },
                bass: { energy_db: -22.0 },
                mid: { energy_db: -18.0 }
            }
        }
    };
    
    const resultC = window.computeScoreV3(scenarioC, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0 },
            bass: { target_db: -22.0, tol_db: 3.0 },
            mid: { target_db: -18.0, tol_db: 3.0 }
        }
    }, 'streaming');
    
    log('ğŸ“Š RESULTADO CENÃRIO C:');
    log('   Raw Score:', resultC.raw);
    log('   Final Score:', resultC.final);
    log('   SubScores:', resultC.subscores);
    log('   Gates:', resultC.gatesTriggered?.length || 0);
    
    const passC = resultC.final >= 85 && resultC.gatesTriggered?.length === 0;
    log(passC ? 'âœ… Score alto sem gates' : 'âŒ Score baixo ou com gates');
    
    // RESUMO FINAL
    log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    const allPassed = passA && passB && passC;
    log(allPassed ? 'ğŸ‰ TODOS OS TESTES PASSARAM!' : 'âš ï¸ ALGUNS TESTES FALHARAM');
    log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    log('  CenÃ¡rio A (True Peak crÃ­tico):', passA ? 'âœ…' : 'âŒ');
    log('  CenÃ¡rio B (Sub/Bass crÃ­ticos):', passB ? 'âœ…' : 'âŒ');
    log('  CenÃ¡rio C (Tudo OK):', passC ? 'âœ…' : 'âŒ');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    return { 
        scenarioA: { result: resultA, passed: passA },
        scenarioB: { result: resultB, passed: passB },
        scenarioC: { result: resultC, passed: passC },
        allPassed
    };
};

log('ğŸ§ª [V3.6] FunÃ§Ã£o de teste disponÃ­vel: window.__testScoreV3Scenarios()');
log('ğŸ“Š [V3.6] FunÃ§Ã£o canÃ´nica disponÃ­vel: window.evaluateMetric(metricKey, value, targetSpec)');

// 3. CALCULAR SCORE DE LOUDNESS (LUFS, True Peak, Crest Factor)
// ğŸ”„ ATUALIZADO: Agora usa getMetricBounds para suportar min/max assimÃ©trico
function calculateLoudnessScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š LUFS Integrado (mÃ©trica principal de loudness) - AGORA COM MIN/MAX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const lufsValue = metrics.lufs_integrated || tech.lufsIntegrated;
    if (Number.isFinite(lufsValue)) {
        const lufsBounds = getMetricBounds(refData, 'lufs');
        
        if (lufsBounds) {
            // Usar novo sistema de bounds (min/max)
            const result = calculateMetricScoreWithBounds(lufsValue, lufsBounds, { metricKey: 'lufs' });
            if (result.score !== null) {
                scores.push(result.score);
                log(`ğŸ“Š LUFS: ${lufsValue.toFixed(1)} dB dentro de [${lufsBounds.min.toFixed(1)}, ${lufsBounds.max.toFixed(1)}] = ${result.score}% (${result.status})`);
            }
        } else if (Number.isFinite(refData.lufs_target) && Number.isFinite(refData.tol_lufs)) {
            // Fallback para sistema legado (target Â± tol)
            const score = calculateMetricScore(lufsValue, refData.lufs_target, refData.tol_lufs);
            if (score !== null) {
                scores.push(score);
                log(`ğŸ“Š LUFS: ${lufsValue} vs ${refData.lufs_target} (Â±${refData.tol_lufs}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š TRUE PEAK - CRÃTICO: NUNCA > 0 dBTP - AGORA COM MIN/MAX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const truePeakValue = metrics.true_peak_dbtp || tech.truePeakDbtp;
    if (Number.isFinite(truePeakValue)) {
        const tpBounds = getMetricBounds(refData, 'true_peak');
        
        if (tpBounds) {
            // ğŸš¨ REGRA CRÃTICA: True Peak > 0 dBTP = SEMPRE CRÃTICO
            // ForÃ§ar max = 0 mesmo que o JSON tenha outro valor
            const safeBounds = {
                ...tpBounds,
                max: Math.min(tpBounds.max, 0.0) // NUNCA > 0
            };
            
            const result = calculateMetricScoreWithBounds(truePeakValue, safeBounds, { 
                metricKey: 'true_peak',
                isCriticalAboveMax: true // True Peak acima do max Ã© sempre crÃ­tico
            });
            
            if (result.score !== null) {
                scores.push(result.score);
                const statusEmoji = result.status === 'CRITICAL' ? 'ğŸš¨' : result.status === 'WARNING' ? 'âš ï¸' : 'âœ…';
                log(`ğŸ“Š True Peak: ${truePeakValue.toFixed(1)} dBTP dentro de [${safeBounds.min.toFixed(1)}, ${safeBounds.max.toFixed(1)}] = ${result.score}% ${statusEmoji} (${result.status})`);
            }
        } else if (Number.isFinite(refData.true_peak_target) && Number.isFinite(refData.tol_true_peak)) {
            // Fallback para sistema legado
            const score = calculateMetricScore(truePeakValue, refData.true_peak_target, refData.tol_true_peak);
            if (score !== null) {
                scores.push(score);
                log(`ğŸ“Š True Peak: ${truePeakValue} vs ${refData.true_peak_target} (Â±${refData.tol_true_peak}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š Crest Factor (dinÃ¢mica de picos) - MantÃ©m sistema legado
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š Crest Factor: ${crestValue} vs ${refData.crest_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            log('[AUDIT-SCORE]', {
                func: 'calculateLoudnessScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'calculateLoudnessScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    log(`ğŸ”Š Score Loudness Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        log('[AUDIT-SCORE]', {
            func: 'calculateLoudnessScore',
            value: { lufs: metrics.lufs_integrated || tech.lufsIntegrated, truePeak: metrics.true_peak_dbtp || tech.truePeakDbtp, crest: tech.crestFactor || metrics.crest_factor },
            target: { lufs: refData.lufs_target, truePeak: refData.true_peak_target, crest: refData.crest_target },
            diff: 'ver logs individuais',
            tolerance: { lufs: refData.tol_lufs, truePeak: refData.tol_true_peak, crest: refData.tol_crest },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateLoudnessScore (final)', err);
    }
    
    return result;
}

// 4. CALCULAR SCORE DE DINÃ‚MICA (LRA, DR, Crest Consistency, Fator de Crista)
// ğŸ”„ ATUALIZADO: Agora usa getMetricBounds para suportar min/max assimÃ©trico
function calculateDynamicsScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š Dynamic Range (DR) - mÃ©trica principal de dinÃ¢mica - AGORA COM MIN/MAX
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const drValue = metrics.dynamic_range || tech.dynamicRange;
    if (Number.isFinite(drValue)) {
        const drBounds = getMetricBounds(refData, 'dr');
        
        if (drBounds) {
            // Usar novo sistema de bounds (min/max)
            const result = calculateMetricScoreWithBounds(drValue, drBounds, { metricKey: 'dr' });
            if (result.score !== null) {
                scores.push(result.score);
                log(`ğŸ“Š Dynamic Range: ${drValue.toFixed(1)} dB dentro de [${drBounds.min.toFixed(1)}, ${drBounds.max.toFixed(1)}] = ${result.score}% (${result.status})`);
            }
        } else if (Number.isFinite(refData.dr_target) && Number.isFinite(refData.tol_dr)) {
            // Fallback para sistema legado
            const score = calculateMetricScore(drValue, refData.dr_target, refData.tol_dr);
            if (score !== null) {
                scores.push(score);
                log(`ğŸ“Š Dynamic Range: ${drValue} vs ${refData.dr_target} (Â±${refData.tol_dr}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š LRA (Loudness Range) - variaÃ§Ã£o de loudness
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const lraValue = metrics.lra || tech.lra;
    if (Number.isFinite(lraValue) && Number.isFinite(refData.lra_target) && Number.isFinite(refData.tol_lra)) {
        const score = calculateMetricScore(lraValue, refData.lra_target, refData.tol_lra);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š LRA: ${lraValue} vs ${refData.lra_target} (Â±${refData.tol_lra}) = ${score}%`);
        }
    }
    
    // Crest Factor (jÃ¡ incluÃ­do em Loudness, mas importante para dinÃ¢mica tambÃ©m)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š Crest Factor (DinÃ¢mica): ${crestValue} vs ${refData.crest_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // CompressÃ£o detectada (se disponÃ­vel)
    const compressionRatio = tech.compressionRatio;
    if (Number.isFinite(compressionRatio) && refData.compression_target && Number.isFinite(refData.compression_target)) {
        const tolerance = refData.tol_compression || 1.0;
        const score = calculateMetricScore(compressionRatio, refData.compression_target, tolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š CompressÃ£o: ${compressionRatio} vs ${refData.compression_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            log('[AUDIT-SCORE]', {
                func: 'calculateDynamicsScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'calculateDynamicsScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    log(`ğŸ“Š Score DinÃ¢mica Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        log('[AUDIT-SCORE]', {
            func: 'calculateDynamicsScore',
            value: { dr: metrics.dynamic_range || tech.dynamicRange, lra: metrics.lra || tech.lra, crest: tech.crestFactor || metrics.crest_factor, compression: tech.compressionRatio },
            target: { dr: refData.dr_target, lra: refData.lra_target, crest: refData.crest_target, compression: refData.compression_target },
            diff: 'ver logs individuais',
            tolerance: { dr: refData.tol_dr, lra: refData.tol_lra, crest: refData.tol_crest, compression: refData.tol_compression },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateDynamicsScore (final)', err);
    }
    
    return result;
}

// 5. CALCULAR SCORE DE ESTÃ‰REO (Largura, CorrelaÃ§Ã£o, BalanÃ§o L/R)
function calculateStereoScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // CorrelaÃ§Ã£o EstÃ©reo (principal mÃ©trica de estÃ©reo)
    const stereoValue = metrics.stereo_correlation || tech.stereoCorrelation;
    if (Number.isFinite(stereoValue) && Number.isFinite(refData.stereo_target) && Number.isFinite(refData.tol_stereo)) {
        const score = calculateMetricScore(stereoValue, refData.stereo_target, refData.tol_stereo);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š CorrelaÃ§Ã£o EstÃ©reo: ${stereoValue} vs ${refData.stereo_target} (Â±${refData.tol_stereo}) = ${score}%`);
        }
    }
    
    // Largura EstÃ©reo (Width)
    const widthValue = tech.stereoWidth || metrics.stereo_width;
    if (Number.isFinite(widthValue) && refData.width_target && Number.isFinite(refData.width_target)) {
        const tolerance = refData.tol_width || 0.2;
        const score = calculateMetricScore(widthValue, refData.width_target, tolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š Largura EstÃ©reo: ${widthValue} vs ${refData.width_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // BalanÃ§o L/R (se disponÃ­vel)
    const balanceValue = tech.stereoBalance || metrics.stereo_balance;
    if (Number.isFinite(balanceValue)) {
        // BalanÃ§o ideal Ã© 0 (perfeitamente centrado)
        const balanceTarget = refData.balance_target || 0.0;
        const balanceTolerance = refData.tol_balance || 0.1; // 10% de tolerÃ¢ncia
        const score = calculateMetricScore(balanceValue, balanceTarget, balanceTolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š BalanÃ§o L/R: ${balanceValue} vs ${balanceTarget} (Â±${balanceTolerance}) = ${score}%`);
        }
    }
    
    // SeparaÃ§Ã£o de canais (se disponÃ­vel)
    const separationValue = tech.channelSeparation || metrics.channel_separation;
    if (Number.isFinite(separationValue) && refData.separation_target && Number.isFinite(refData.separation_target)) {
        const tolerance = refData.tol_separation || 5.0;
        const score = calculateMetricScore(separationValue, refData.separation_target, tolerance);
        if (score !== null) {
            scores.push(score);
            log(`ğŸ“Š SeparaÃ§Ã£o de Canais: ${separationValue} vs ${refData.separation_target} (Â±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar mÃ©dia dos scores vÃ¡lidos
    if (scores.length === 0) {
        try {
            log('[AUDIT-SCORE]', {
                func: 'calculateStereoScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            warn('[AUDIT-ERROR]', 'calculateStereoScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    log(`ğŸ§ Score EstÃ©reo Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas)`);
    
    try {
        log('[AUDIT-SCORE]', {
            func: 'calculateStereoScore',
            value: { correlation: metrics.stereo_correlation || tech.stereoCorrelation, width: tech.stereoWidth || metrics.stereo_width, balance: tech.stereoBalance || metrics.stereo_balance, separation: tech.channelSeparation || metrics.channel_separation },
            target: { correlation: refData.stereo_target, width: refData.width_target, balance: refData.balance_target, separation: refData.separation_target },
            diff: 'ver logs individuais',
            tolerance: { correlation: refData.tol_stereo, width: refData.tol_width, balance: refData.tol_balance, separation: refData.tol_separation },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateStereoScore (final)', err);
    }
    
    return result;
}

// 6A. CALCULAR SCORE DE FREQUÃŠNCIA EM MODO REFERENCE (COMPARAÃ‡ÃƒO DIRETA A vs B)
// ğŸ¯ HELPER: Extrair bandas de qualquer analysis object (normaliza estruturas variadas)
function extractBandsFromAnalysis(analysis) {
    if (!analysis) return { bands: null, source: 'null-analysis' };
    
    // Prioridade de leitura:
    // 1) analysis.bands (formato direto)
    // 2) analysis.technicalData.bands (caminho principal)
    // 3) analysis.technicalData.spectralBands (array)
    // 4) analysis.technicalData.spectral_balance (legado)
    // 5) analysis.metrics.bands (centralizado)
    
    let rawBands = null;
    let source = 'unknown';
    
    if (analysis.bands && Object.keys(analysis.bands).length > 0) {
        rawBands = analysis.bands;
        source = 'analysis.bands';
    } else if (analysis.technicalData?.bands && Object.keys(analysis.technicalData.bands).length > 0) {
        rawBands = analysis.technicalData.bands;
        source = 'technicalData.bands';
    } else if (analysis.technicalData?.spectralBands) {
        rawBands = analysis.technicalData.spectralBands;
        source = 'technicalData.spectralBands';
    } else if (analysis.technicalData?.spectral_balance && Object.keys(analysis.technicalData.spectral_balance).length > 0) {
        rawBands = analysis.technicalData.spectral_balance;
        source = 'technicalData.spectral_balance';
    } else if (analysis.metrics?.bands && Object.keys(analysis.metrics.bands).length > 0) {
        rawBands = analysis.metrics.bands;
        source = 'metrics.bands';
    }
    
    if (!rawBands) {
        return { bands: null, source: 'not-found' };
    }
    
    // ğŸ¯ NORMALIZAR: Se for array, converter para map {sub:{energy_db}, bass:{}, ...}
    if (Array.isArray(rawBands)) {
        const normalized = {};
        for (const band of rawBands) {
            if (!band || !band.name) continue;
            
            // Normalizar nome da banda (remover espaÃ§os, lowercasing)
            const key = band.name.toLowerCase().replace(/\s+/g, '');
            
            // Extrair energia (aceitar energy_db, energyDb, db, energy)
            const energy = band.energy_db ?? band.energyDb ?? band.db ?? band.energy;
            
            if (Number.isFinite(energy)) {
                normalized[key] = { energy_db: energy };
            }
        }
        
        log('[EXTRACT-BANDS] ğŸ”„ Normalizado array â†’ map:', {
            source,
            originalLength: rawBands.length,
            normalizedKeys: Object.keys(normalized)
        });
        
        return { bands: normalized, source: source + ' (normalized-from-array)' };
    }
    
    // ğŸ¯ JÃ¡ Ã© objeto: garantir que tem energy_db em cada banda
    const normalized = {};
    for (const [key, value] of Object.entries(rawBands)) {
        if (typeof value === 'object' && value !== null) {
            // JÃ¡ tem estrutura {energy_db: number} ou similar
            const energy = value.energy_db ?? value.energyDb ?? value.db ?? value.energy ?? value.rms_db ?? value.value;
            if (Number.isFinite(energy)) {
                normalized[key] = { energy_db: energy };
            }
        } else if (Number.isFinite(value)) {
            // Ã‰ um nÃºmero direto: banda: -24.5
            normalized[key] = { energy_db: value };
        }
    }
    
    log('[EXTRACT-BANDS] âœ… ExtraÃ­do:', {
        source,
        keysFound: Object.keys(normalized),
        sampleValues: Object.keys(normalized).slice(0, 3).map(k => `${k}:${normalized[k].energy_db.toFixed(1)}dB`)
    });
    
    return { bands: normalized, source };
}

function calculateFrequencyScoreReference(bandsA, bandsB) {
    log('[FREQ-SCORE-REF] ğŸµ Calculando score de frequÃªncia em modo reference (A vs B) - VERSÃƒO CORRIGIDA');
    
    if (!bandsA || !bandsB) {
        warn('[FREQ-SCORE-REF] âš ï¸ Bandas ausentes:', { hasA: !!bandsA, hasB: !!bandsB });
        return null;
    }
    
    // 8 bandas principais + aliases (incluindo low_bass, upper_bass)
    const bandKeys = ['sub', 'low_bass', 'upper_bass', 'bass', 'low_mid', 'lowMid', 'mid', 'high_mid', 'highMid', 'presence', 'presenca', 'air', 'brilho'];
    const aliases = {
        'low_bass': 'bass',
        'upper_bass': 'bass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'brilho': 'air',
        'presenca': 'presence'
    };
    
    const bandsData = [];
    const processedKeys = new Set();
    
    for (const key of bandKeys) {
        // Pular se jÃ¡ processamos essa banda (evitar duplicatas com aliases)
        const canonicalKey = aliases[key] || key;
        if (processedKeys.has(canonicalKey)) continue;
        
        // Buscar banda em A
        let valueA = null;
        if (bandsA[key] !== undefined) {
            valueA = typeof bandsA[key] === 'object' ? 
                     (bandsA[key].energy_db ?? bandsA[key].rms_db ?? bandsA[key].value) : 
                     bandsA[key];
        }
        
        // Buscar banda em B (com aliases)
        let valueB = null;
        if (bandsB[key] !== undefined) {
            valueB = typeof bandsB[key] === 'object' ? 
                     (bandsB[key].energy_db ?? bandsB[key].rms_db ?? bandsB[key].value) : 
                     bandsB[key];
        }
        
        if (Number.isFinite(valueA) && Number.isFinite(valueB)) {
            const absDelta = Math.abs(valueA - valueB);
            
            // ğŸ¯ CALCULAR SEVERIDADE (mesma lÃ³gica de buildComparativeAISuggestions)
            let severity = 'OK';
            if (absDelta >= 4.0) {
                severity = 'CRÃTICA';
            } else if (absDelta >= 2.5) {
                severity = 'ALTA';
            } else if (absDelta >= 1.5) {
                severity = 'ATENÃ‡ÃƒO';
            }
            
            bandsData.push({
                key: canonicalKey,
                valueA,
                valueB,
                delta: absDelta,
                severity
            });
            
            processedKeys.add(canonicalKey);
            
            log(`[FREQ-SCORE-REF] ${key}: A=${valueA.toFixed(2)}dB, B=${valueB.toFixed(2)}dB, Î”=${absDelta.toFixed(2)}dB â†’ ${severity}`);
        }
    }
    
    if (bandsData.length === 0) {
        warn('[FREQ-SCORE-REF] âš ï¸ Nenhuma banda vÃ¡lida encontrada');
        return null;
    }
    
    // ğŸ¯ NOVO CÃLCULO BASEADO EM SEVERIDADES
    // Penalidades proporcionais:
    // CRÃTICA â†’ -20 pontos
    // ALTA â†’ -10 pontos
    // ATENÃ‡ÃƒO â†’ -5 pontos
    // OK â†’ 0 pontos
    
    const baseScore = 100;
    const penaltyMap = {
        'CRÃTICA': 20,
        'ALTA': 10,
        'ATENÃ‡ÃƒO': 5,
        'OK': 0
    };
    
    const severityCounts = {
        'CRÃTICA': 0,
        'ALTA': 0,
        'ATENÃ‡ÃƒO': 0,
        'OK': 0
    };
    
    let totalPenalty = 0;
    
    for (const band of bandsData) {
        const penalty = penaltyMap[band.severity] || 0;
        totalPenalty += penalty;
        severityCounts[band.severity]++;
    }
    
    // Normalizar penalidade: cada banda pode contribuir no mÃ¡ximo 20 pontos de penalidade
    // Score = 100 - (totalPenalty * (100 / (bandsCount * 20)))
    // Isso garante que:
    // - Todas OK â†’ 100
    // - Todas CRÃTICA â†’ ~0
    // - Mix de severidades â†’ intermediÃ¡rio
    const maxPossiblePenalty = bandsData.length * 20;
    const normalizedPenalty = (totalPenalty / maxPossiblePenalty) * 100;
    const rawScore = baseScore - normalizedPenalty;
    const score = Math.max(0, Math.min(100, Math.round(rawScore)));
    
    log(`[FREQ-SCORE-REF] ğŸ“Š EstatÃ­sticas:`, {
        totalBandas: bandsData.length,
        criticas: severityCounts['CRÃTICA'],
        altas: severityCounts['ALTA'],
        atencoes: severityCounts['ATENÃ‡ÃƒO'],
        ok: severityCounts['OK'],
        totalPenalty,
        maxPossiblePenalty,
        normalizedPenalty: normalizedPenalty.toFixed(2),
        scoreFinal: score
    });
    
    log(`[FREQ-SCORE-REF] âœ… Score corrigido: ${score}% (anterior seria ~${Math.round(100 - (bandsData.reduce((sum, b) => sum + b.delta, 0) / bandsData.length * 10))}% com cÃ¡lculo antigo)`);
    
    return score;
}

// 6B. CALCULAR SCORE DE FREQUÃŠNCIA (BANDAS ESPECTRAIS)
function calculateFrequencyScore(analysis, refData) {
    if (!analysis || !refData || !refData.bands) return null;
    
    // ğŸ¯ CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode nÃ£o existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const bandsToUse = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    log('[FREQ-SCORE] ğŸµ Fonte de bandas:', 
        technicalBands ? 'âœ… technicalData.bands (prioridade 1)' : 
        centralizedBands ? 'âš ï¸ metrics.bands (fallback 2)' : 
        spectralBalance ? 'âš ï¸ spectral_balance (fallback 3)' : 
        'âš ï¸ bandEnergies (fallback 4 - legado)');
    
    log('[FREQ-SCORE] ğŸµ Bandas disponÃ­veis:', bandsToUse ? Object.keys(bandsToUse) : 'NENHUMA');
    
    if (!bandsToUse) return null;
    
    const scores = [];
    const isReferenceMode = refData._isReferenceMode === true;
    const hasRefContext = hasActiveReferenceContext();
    
    log('ğŸµ Calculando Score de FrequÃªncia...', {
        mode: isReferenceMode ? 'REFERENCE (valores diretos)' : 'GENRE (target_range)',
        bandsAvailable: Object.keys(refData.bands),
        hasRefContext
    });
    
    // ğŸ¯ MODO REFERENCE: Usar comparaÃ§Ã£o direta A vs B
    if (isReferenceMode && hasRefContext) {
        log('[FREQ-SCORE] ğŸ”„ Modo reference detectado - extraindo bandas de anÃ¡lises');
        
        // ğŸ¯ HOTFIX B: Helper local para extrair bandas (aceita technicalData.bands e spectralBands)
        const extractBandsLocal = (analysis, label) => {
            if (!analysis) return { bandsMap: null, source: 'null-analysis' };
            
            // Prioridades:
            // 1. technicalData.bands (objeto com {sub:{energy_db}, bass:{}, ...})
            // 2. technicalData.spectralBands (array com [{name, energy_db}, ...])
            // 3. bands direto (fallback)
            const techBands = analysis.technicalData?.bands;
            const spectralBands = analysis.technicalData?.spectralBands;
            const directBands = analysis.bands;
            
            let rawBands = null;
            let source = 'unknown';
            
            if (techBands && typeof techBands === 'object' && Object.keys(techBands).length > 0) {
                rawBands = techBands;
                source = 'technicalData.bands';
            } else if (spectralBands && Array.isArray(spectralBands) && spectralBands.length > 0) {
                // Converter array [{name, energy_db}] para map {sub: {energy_db}}
                rawBands = {};
                for (const band of spectralBands) {
                    if (band && band.name) {
                        const key = band.name.toLowerCase().replace(/\s+/g, '');
                        const energy = band.energy_db ?? band.energyDb ?? band.db ?? band.energy;
                        if (Number.isFinite(energy)) {
                            rawBands[key] = { energy_db: energy };
                        }
                    }
                }
                source = 'technicalData.spectralBands (arrayâ†’map)';
            } else if (directBands && typeof directBands === 'object' && Object.keys(directBands).length > 0) {
                rawBands = directBands;
                source = 'analysis.bands';
            }
            
            if (!rawBands) {
                warn(`[FREQ-SCORE] âš ï¸ ${label}: Nenhuma banda encontrada`);
                return { bandsMap: null, source: 'not-found' };
            }
            
            // Normalizar para garantir energy_db
            const normalized = {};
            for (const [key, value] of Object.entries(rawBands)) {
                if (typeof value === 'object' && value !== null) {
                    const energy = value.energy_db ?? value.energyDb ?? value.db ?? value.energy ?? value.rms_db;
                    if (Number.isFinite(energy)) {
                        normalized[key] = { energy_db: energy };
                    }
                } else if (Number.isFinite(value)) {
                    normalized[key] = { energy_db: value };
                }
            }
            
            log(`[FREQ-SCORE] âœ… ${label}: ${Object.keys(normalized).length} bandas de ${source}`);
            return { bandsMap: normalized, source };
        };
        
        // ğŸ¯ HOTFIX B: Tentar usar stateV3.reference.bands primeiro (cache), senÃ£o extrair
        const stateV3 = window.__soundyState || {};
        let userBandsA = null;
        let refBandsB = null;
        
        if (stateV3?.reference?.bands?.userBands && stateV3?.reference?.bands?.refBands) {
            log('[FREQ-SCORE] âœ… Usando bandas CACHEADAS de stateV3.reference.bands');
            userBandsA = stateV3.reference.bands.userBands;
            refBandsB = stateV3.reference.bands.refBands;
        } else {
            log('[FREQ-SCORE] âš ï¸ Cache ausente - extraindo bandas diretamente de anÃ¡lises');
            
            const userAnalysisRef = stateV3?.reference?.userAnalysis || analysis;
            const refAnalysisRef = stateV3?.reference?.referenceAnalysis || refData._referenceAnalysisFull;
            
            const extractedA = extractBandsLocal(userAnalysisRef, 'userAnalysis');
            const extractedB = extractBandsLocal(refAnalysisRef, 'referenceAnalysis');
            
            userBandsA = extractedA.bandsMap;
            refBandsB = extractedB.bandsMap;
            
            // ğŸ¯ CACHEAR para prÃ³ximas chamadas
            if (userBandsA && refBandsB) {
                stateV3.reference = stateV3.reference || {};
                stateV3.reference.bands = {
                    userBands: userBandsA,
                    refBands: refBandsB
                };
                stateV3.reference.analysis = stateV3.reference.analysis || {};
                stateV3.reference.analysis.bands = refBandsB;
                window.__soundyState = stateV3;
                log('[FREQ-SCORE] âœ… Bandas cacheadas em stateV3.reference.bands');
            }
        }
        
        // ğŸ›¡ï¸ GUARDRAILS
        if (!userBandsA || !refBandsB) {
            error('[FREQ-SCORE] âŒ ERRO: Bandas ausentes apÃ³s extraÃ§Ã£o!');
            error('[FREQ-SCORE] userBandsA:', !!userBandsA, 'refBandsB:', !!refBandsB);
            return null;
        }
        
        // ğŸ›¡ï¸ GUARDRAIL: Validar Ã¢ncoras B
        const anchorKeysB = ['sub', 'bass', 'mid'].filter(k => {
            const val = refBandsB[k]?.energy_db ?? refBandsB[k];
            return Number.isFinite(val);
        });
        
        if (anchorKeysB.length === 0) {
            error('[FREQ-SCORE] âŒ ERRO: refBands B sem Ã¢ncoras vÃ¡lidas (sub/bass/mid)!');
            error('[FREQ-SCORE] refBands B keys:', Object.keys(refBandsB));
            return null;
        }
        
        // ğŸ›¡ï¸ GUARDRAIL: Detectar same reference
        if (userBandsA === refBandsB) {
            error('[FREQ-SCORE] âŒ ERRO: userBands === refBands (same object reference)!');
            return null;
        }
        
        // ğŸ›¡ï¸ GUARDRAIL: Detectar valores idÃªnticos (warning apenas)
        let identicalCount = 0;
        for (const key of ['sub', 'bass', 'mid']) {
            const valA = userBandsA[key]?.energy_db ?? userBandsA[key];
            const valB = refBandsB[key]?.energy_db ?? refBandsB[key];
            if (Number.isFinite(valA) && Number.isFinite(valB) && Math.abs(valA - valB) < 0.001) {
                identicalCount++;
            }
        }
        
        if (identicalCount === 3) {
            warn('[FREQ-SCORE] âš ï¸ SUSPEITO: sub/bass/mid idÃªnticas entre A e B!');
        }
        
        log('[FREQ-SCORE-AUDIT] ğŸ” Ã‚ncoras validadas:', {
            subA: userBandsA.sub?.energy_db ?? userBandsA.sub,
            subB: refBandsB.sub?.energy_db ?? refBandsB.sub,
            bassA: userBandsA.bass?.energy_db ?? userBandsA.bass,
            bassB: refBandsB.bass?.energy_db ?? refBandsB.bass
        });
        
        return calculateFrequencyScoreReference(userBandsA, refBandsB);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ V3.3: USO DO SISTEMA DE ALIASES CENTRALIZADO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const BKA = window.BandKeyAliases || {
        // Fallback inline caso o mÃ³dulo nÃ£o carregue
        CANONICAL_KEYS: ['sub', 'bass', 'low_mid', 'mid', 'high_mid', 'presence', 'brilho'],
        META_KEYS: ['totalPercentage', '_status', 'status', 'timestamp'],
        normalizeBandKey: (key) => {
            if (!key) return null;
            const aliases = {
                'sub': ['sub', 'sub_bass', 'subBass'],
                'bass': ['bass', 'low_bass', 'lowBass'],
                'low_mid': ['low_mid', 'lowMid', 'low-mid'],
                'mid': ['mid', 'mids'],
                'high_mid': ['high_mid', 'highMid', 'high-mid'],
                'presence': ['presence', 'presenca'],
                'brilho': ['brilho', 'air', 'brilliance', 'highs']
            };
            const lk = key.toLowerCase();
            for (const [canon, arr] of Object.entries(aliases)) {
                if (arr.some(a => a.toLowerCase() === lk)) return canon;
            }
            return null;
        },
        extractEnergyDb: (val) => {
            if (typeof val === 'number') return val;
            if (val?.energy_db !== undefined) return val.energy_db;
            if (val?.energyDb !== undefined) return val.energyDb;
            if (val?.db !== undefined) return val.db;
            if (val?.rms_db !== undefined) return val.rms_db;
            return null;
        },
        isMetaKey: (key) => ['totalPercentage', '_status', 'status', 'timestamp', '_source'].includes(key)
    };
    
    // DiagnÃ³stico inicial
    const userBandsRaw = bandsToUse || {};
    const refBandsRaw = refData.bands || {};
    
    console.group('ğŸµ [FREQ-SCORE-V3.3] Calculando Score de FrequÃªncia');
    log('ğŸ“Š Bandas do usuÃ¡rio (raw):', Object.keys(userBandsRaw));
    log('ğŸ“Š Bandas de referÃªncia (raw):', Object.keys(refBandsRaw));
    
    // Mapear bandas com diagnÃ³stico
    const bandsUsedForScore = [];
    const bandsIgnoredNoTarget = [];
    const bandsIgnoredNoUserValue = [];
    const targetsFoundPerBand = {};
    
    // Processar cada banda canÃ´nica
    BKA.CANONICAL_KEYS.forEach(canonical => {
        // Tentar encontrar valor do usuÃ¡rio
        let userValue = null;
        let userSource = null;
        
        // Buscar com aliases
        for (const key of Object.keys(userBandsRaw)) {
            if (BKA.normalizeBandKey(key) === canonical) {
                userValue = BKA.extractEnergyDb(userBandsRaw[key]);
                userSource = key;
                break;
            }
        }
        
        // Buscar target de referÃªncia
        let targetDb = null;
        let tolDb = null;
        let refSource = null;
        
        for (const key of Object.keys(refBandsRaw)) {
            if (BKA.normalizeBandKey(key) === canonical) {
                const refVal = refBandsRaw[key];
                refSource = key;
                
                if (typeof refVal === 'number') {
                    targetDb = refVal;
                    tolDb = 3.0;
                } else if (refVal?.target_range?.min !== undefined && refVal?.target_range?.max !== undefined) {
                    targetDb = (refVal.target_range.min + refVal.target_range.max) / 2;
                    tolDb = (refVal.target_range.max - refVal.target_range.min) / 2;
                } else if (refVal?.target_db !== undefined) {
                    targetDb = refVal.target_db;
                    tolDb = refVal.tol_db ?? 3.0;
                } else {
                    targetDb = BKA.extractEnergyDb(refVal);
                    tolDb = 3.0;
                }
                break;
            }
        }
        
        targetsFoundPerBand[canonical] = {
            userValue,
            userSource,
            targetDb,
            tolDb,
            refSource,
            hasMatch: userValue !== null && targetDb !== null
        };
        
        // Calcular score se temos ambos valores
        if (userValue !== null && targetDb !== null) {
            const score = calculateMetricScore(userValue, targetDb, tolDb);
            if (score !== null) {
                scores.push(score);
                bandsUsedForScore.push(canonical);
                log(`âœ… ${canonical.toUpperCase()}: ${userValue.toFixed(1)}dB vs ${targetDb.toFixed(1)}dB (Â±${tolDb.toFixed(1)}) = ${score}%`);
            }
        } else if (userValue === null) {
            bandsIgnoredNoUserValue.push(canonical);
            log(`ğŸ”‡ ${canonical.toUpperCase()}: SEM VALOR DO USUÃRIO (source tentada: ${userSource || 'nenhuma'})`);
        } else if (targetDb === null) {
            bandsIgnoredNoTarget.push(canonical);
            log(`âš ï¸ ${canonical.toUpperCase()}: SEM TARGET DE REFERÃŠNCIA (userValue=${userValue?.toFixed(1)}dB)`);
        }
    });
    
    // Log de diagnÃ³stico completo
    log('ğŸ“‹ RESUMO:', {
        bandsUsedForScore,
        bandsUsedCount: bandsUsedForScore.length,
        bandsIgnoredNoTarget,
        bandsIgnoredNoUserValue,
        targetsFoundPerBand
    });
    console.groupEnd();
    
    // Se nÃ£o encontrou scores vÃ¡lidos, retornar null
    if (scores.length === 0) {
        warn('[FREQ-SCORE-V3.3] âš ï¸ Nenhuma banda vÃ¡lida para calcular score');
        return null;
    }
    
    // MÃ©dia aritmÃ©tica simples das bandas vÃ¡lidas
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    
    log(`ğŸµ Score FrequÃªncia Final: ${result}% (mÃ©dia de ${scores.length} bandas)`);
    log(`ğŸµ Scores individuais: [${scores.join(', ')}]`);
    log(`ğŸµ Bandas usadas: [${bandsUsedForScore.join(', ')}]`);
    
    return result;
}

// 7. CALCULAR SCORE TÃ‰CNICO
// 7. CALCULAR SCORE TÃ‰CNICO (Clipping, DC Offset, THD)
function calculateTechnicalScore(analysis, refData) {
    if (!analysis) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    log('ğŸ”§ Calculando Score TÃ©cnico...');
    
    // 1. CLIPPING - Deve ser prÃ³ximo de 0% (PENALIZAÃ‡ÃƒO FORTE PARA PROBLEMAS CRÃTICOS)
    const clippingValue = tech.clipping || metrics.clipping || 0;
    if (Number.isFinite(clippingValue)) {
        let clippingScore = 100;
        
        if (clippingValue <= 0.001) { // â‰¤ 0.1% = perfeito
            clippingScore = 100;
        } else if (clippingValue <= 0.005) { // â‰¤ 0.5% = bom
            clippingScore = 80;
        } else if (clippingValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            clippingScore = 60;
        } else if (clippingValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            clippingScore = 40;
        } else { // > 2% = crÃ­tico
            clippingScore = 20;
        }
        
        scores.push(clippingScore);
        log(`ğŸ”§ Clipping: ${(clippingValue * 100).toFixed(3)}% = ${clippingScore}%`);
    }
    
    // 2. DC OFFSET - Deve ser prÃ³ximo de 0
    const dcOffsetValue = Math.abs(tech.dcOffset || metrics.dc_offset || 0);
    if (Number.isFinite(dcOffsetValue)) {
        let dcScore = 100;
        
        if (dcOffsetValue <= 0.001) { // â‰¤ 0.1% = perfeito
            dcScore = 100;
        } else if (dcOffsetValue <= 0.005) { // â‰¤ 0.5% = bom
            dcScore = 80;
        } else if (dcOffsetValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            dcScore = 60;
        } else if (dcOffsetValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            dcScore = 40;
        } else { // > 2% = crÃ­tico
            dcScore = 20;
        }
        
        scores.push(dcScore);
        log(`ğŸ”§ DC Offset: ${dcOffsetValue.toFixed(4)} = ${dcScore}%`);
    }
    
    // 3. THD (Total Harmonic Distortion) - Deve ser baixo
    const thdValue = tech.thd || metrics.thd || 0;
    if (Number.isFinite(thdValue)) {
        let thdScore = 100;
        
        if (thdValue <= 0.001) { // â‰¤ 0.1% = perfeito
            thdScore = 100;
        } else if (thdValue <= 0.005) { // â‰¤ 0.5% = bom
            thdScore = 80;
        } else if (thdValue <= 0.01) { // â‰¤ 1% = aceitÃ¡vel
            thdScore = 60;
        } else if (thdValue <= 0.02) { // â‰¤ 2% = problemÃ¡tico
            thdScore = 40;
        } else { // > 2% = crÃ­tico
            thdScore = 20;
        }
        
        scores.push(thdScore);
        log(`ğŸ”§ THD: ${(thdValue * 100).toFixed(3)}% = ${thdScore}%`);
    }
    
    // 4. PROBLEMAS DETECTADOS (Issues) - PENALIZAÃ‡ÃƒO GRADUAL
    const issues = analysis.issues || [];
    let issuesScore = 100;
    
    issues.forEach(issue => {
        switch (issue.severity) {
            case 'critical':
                issuesScore = Math.max(20, issuesScore - 30); // NÃ£o zerar, mÃ­nimo 20
                log(`ğŸ”§ Issue CRÃTICO: ${issue.description} (-30%)`);
                break;
            case 'high':
                issuesScore = Math.max(40, issuesScore - 20); // MÃ­nimo 40
                log(`ğŸ”§ Issue ALTO: ${issue.description} (-20%)`);
                break;
            case 'medium':
                issuesScore = Math.max(60, issuesScore - 10); // MÃ­nimo 60
                log(`ğŸ”§ Issue MÃ‰DIO: ${issue.description} (-10%)`);
                break;
            case 'low':
                issuesScore = Math.max(80, issuesScore - 5); // MÃ­nimo 80
                log(`ğŸ”§ Issue BAIXO: ${issue.description} (-5%)`);
                break;
        }
    });
    
    if (issues.length > 0) {
        scores.push(issuesScore);
        log(`ğŸ”§ Issues Gerais: ${issuesScore}% (${issues.length} problemas)`);
    }
    
    // ğŸ¯ NOVA VALIDAÃ‡ÃƒO TRUE PEAK (CORREÃ‡ÃƒO CRÃTICA)
    const truePeak = tech.truePeakDbtp || metrics.truePeakDbtp;
    let truePeakScore = 100; // Score padrÃ£o se nÃ£o houver dados
    let hasTruePeakData = false;
    
    if (Number.isFinite(truePeak)) {
        hasTruePeakData = true;
        log(`ğŸ”§ True Peak: ${truePeak.toFixed(2)} dBTP`);
        
        if (truePeak <= -1.5) { // Excelente
            truePeakScore = 100;
            log(`ğŸ”§ True Peak EXCELENTE: ${truePeakScore}%`);
        } else if (truePeak <= -1.0) { // Ideal
            truePeakScore = 90;
            log(`ğŸ”§ True Peak IDEAL: ${truePeakScore}%`);
        } else if (truePeak <= -0.5) { // Bom
            truePeakScore = 80;
            log(`ğŸ”§ True Peak BOM: ${truePeakScore}%`);
        } else if (truePeak <= 0.0) { // AceitÃ¡vel
            truePeakScore = 70;
            log(`ğŸ”§ True Peak ACEITÃVEL: ${truePeakScore}%`);
        } else if (truePeak <= 0.5) { // ProblemÃ¡tico
            truePeakScore = 40;
            log(`ğŸ”§ True Peak PROBLEMÃTICO: ${truePeakScore}%`);
        } else { // CrÃ­tico
            truePeakScore = 20;
            log(`ğŸ”§ True Peak CRÃTICO: ${truePeakScore}%`);
        }
        
        scores.push(truePeakScore);
    }
    
    // Se nÃ£o temos mÃ©tricas tÃ©cnicas especÃ­ficas, usar apenas issues
    if (scores.length === 0) {
        const result = Math.max(20, Math.round(issuesScore)); // Nunca zerar
        log(`ğŸ”§ Score TÃ©cnico Final (apenas issues): ${result}%`);
        return result;
    }
    
    // MÃ©dia normalizada de todas as mÃ©tricas tÃ©cnicas (0-100)
    let average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    let result = Math.max(20, Math.round(average)); // Nunca zerar completamente
    
    // ğŸ¯ V3.4: REMOVIDO HARD CAP DUPLICADO - O gate proporcional no V3-GATE jÃ¡ cuida disso
    // Antes havia dupla puniÃ§Ã£o: score tÃ©cnico baixo + gate final capando novamente
    // Agora: score tÃ©cnico reflete a qualidade, gate final aplica cap proporcional se necessÃ¡rio
    
    log(`ğŸ”§ Score TÃ©cnico Final: ${result}% (mÃ©dia de ${scores.length} mÃ©tricas${hasTruePeakData ? ', True Peak incluÃ­do' : ''})`);
    
    try {
        log('[AUDIT-SCORE]', {
            func: 'calculateTechnicalScore',
            value: { clipping: tech.clipping || metrics.clipping, dcOffset: tech.dcOffset || metrics.dc_offset, thd: tech.thd || metrics.thd, truePeak: truePeak, issues: issues.length },
            target: 'valores ideais (0 para clipping/dc/thd, <0 para truePeak)',
            diff: 'N/A (avaliaÃ§Ã£o por faixas)',
            tolerance: 'N/A',
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average,
            hasTruePeakData
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateTechnicalScore (final)', err);
    }
    
    return result;
}

// 8. FUNÃ‡ÃƒO PRINCIPAL: CALCULAR TODOS OS SCORES
function calculateAnalysisScores(analysis, refData, genre = null) {
    log('ğŸ¯ Calculando scores da anÃ¡lise...', { genre });
    
    // ğŸ¯ [FLOW-FIX] MÃ©tricas recebidas dentro de calculateAnalysisScores
    log("[FLOW-FIX] MÃ©tricas recebidas dentro de calculateAnalysisScores:", {
        loudness: analysis.loudness,
        metrics: analysis.metrics,
        technicalData: analysis.technicalData
    });
    
    // ğŸ¯ [GENRE-FIX] Targets finais entregues ao score
    log("[GENRE-FIX] Targets finais entregues ao score:", {
        lufs_target: refData?.lufs_target,
        true_peak_target: refData?.true_peak_target,
        dr_target: refData?.dr_target,
        stereo_target: refData?.stereo_target,
        lra_target: refData?.lra_target,
        bands: refData?.bands ? Object.keys(refData.bands) : null,
        bandsCount: refData?.bands ? Object.keys(refData.bands).length : 0
    });
    
    // ğŸ¯ MODO GÃŠNERO: Detectar se Ã© modo gÃªnero e se hÃ¡ targets carregados
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    // ğŸ¯ MODO GÃŠNERO: Extrair targets de gÃªnero de referenceComparison
    let genreTargetBands = null;
    let genreTargetMetrics = null;
    
    if (isGenreMode && analysis?.referenceComparison) {
        const refComp = analysis.referenceComparison;
        
        // Buscar em mÃºltiplos locais possÃ­veis (estrutura varia entre JSONs)
        const genreKeyLookup = genre || analysis.genre || analysis.genreId;
        const genreData = genreKeyLookup ? refComp[genreKeyLookup] : null;
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair bandas do ROOT primeiro
        if (genreData?.bands) {
            genreTargetBands = genreData.bands;
            log('âœ… [GENRE-TARGETS] Usando bands do ROOT (correto):', Object.keys(genreTargetBands));
        } else if (genreData?.legacy_compatibility?.bands) {
            genreTargetBands = genreData.legacy_compatibility.bands;
            log('âš ï¸ [GENRE-TARGETS] Usando legacy_compatibility.bands (fallback):', Object.keys(genreTargetBands));
        } else if (genreData?.hybrid_processing?.spectral_bands) {
            genreTargetBands = genreData.hybrid_processing.spectral_bands;
            log('âš ï¸ [GENRE-TARGETS] Usando hybrid_processing.spectral_bands (fallback):', Object.keys(genreTargetBands));
        } else if (refComp.bands) {
            genreTargetBands = refComp.bands;
            log('âš ï¸ [GENRE-TARGETS] Usando bands direto do refComp (fallback):', Object.keys(genreTargetBands));
        }
        
        // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Extrair mÃ©tricas escalares do ROOT primeiro
        if (genreData && genreData.lufs_target !== undefined) {
            // ROOT tem targets vÃ¡lidos (estrutura correta V2)
            genreTargetMetrics = {
                lufs_target: genreData.lufs_target,
                true_peak_target: genreData.true_peak_target,
                dr_target: genreData.dr_target,
                lra_target: genreData.lra_target,
                stereo_target: genreData.stereo_target,
                tol_lufs: genreData.tol_lufs || 1.0,
                tol_true_peak: genreData.tol_true_peak || 0.25,
                tol_dr: genreData.tol_dr || 1.25,
                tol_lra: genreData.tol_lra || 2.5,
                tol_stereo: genreData.tol_stereo || 0.065
            };
            log('âœ… [GENRE-TARGETS] MÃ©tricas extraÃ­das do ROOT (correto):', {
                lufs: genreTargetMetrics.lufs_target,
                peak: genreTargetMetrics.true_peak_target,
                dr: genreTargetMetrics.dr_target,
                stereo: genreTargetMetrics.stereo_target
            });
        } else if (genreData?.legacy_compatibility) {
            // Fallback: legacy_compatibility (estrutura antiga)
            const lc = genreData.legacy_compatibility;
            genreTargetMetrics = {
                lufs_target: lc.lufs_target,
                true_peak_target: lc.true_peak_target,
                dr_target: lc.dr_target,
                lra_target: lc.lra_target,
                stereo_target: lc.stereo_target,
                tol_lufs: lc.tol_lufs || 1.0,
                tol_true_peak: lc.tol_true_peak || 0.25,
                tol_dr: lc.tol_dr || 1.25,
                tol_lra: lc.tol_lra || 2.5,
                tol_stereo: lc.tol_stereo || 0.065
            };
            log('âš ï¸ [GENRE-TARGETS] MÃ©tricas extraÃ­das de legacy_compatibility (fallback)');
        } else if (genreData?.hybrid_processing?.original_metrics) {
            // Fallback 2: hybrid_processing (estrutura hÃ­brida)
            const om = genreData.hybrid_processing.original_metrics;
            genreTargetMetrics = {
                lufs_target: om.lufs_integrated,
                true_peak_target: om.true_peak_dbtp,
                dr_target: om.dynamic_range,
                lra_target: om.lra,
                stereo_target: om.stereo_correlation,
                tol_lufs: 1.0,
                tol_true_peak: 0.25,
                tol_dr: 1.25,
                tol_lra: 2.5,
                tol_stereo: 0.065
            };
            log('âš ï¸ [GENRE-TARGETS] MÃ©tricas extraÃ­das de hybrid_processing.original_metrics (fallback)');
        }
        
        // ğŸ¯ INJETAR targets de gÃªnero em refData se disponÃ­veis
        if (genreTargetBands && Object.keys(genreTargetBands).length > 0) {
            log('âœ… [GENRE-TARGETS] Injetando bandas de gÃªnero em refData');
            refData = {
                ...refData,
                bands: genreTargetBands,
                _isReferenceMode: false, // NÃƒO Ã© modo A/B
                _isGenreMode: true,
                _genreTargetsLoaded: true
            };
            
            // Mesclar mÃ©tricas se disponÃ­veis
            if (genreTargetMetrics) {
                refData = { ...refData, ...genreTargetMetrics };
            }
        } else {
            warn('âš ï¸ [GENRE-TARGETS] Targets de gÃªnero nÃ£o encontrados em referenceComparison');
        }
    }
    
    // ğŸ” [AUDIT-BANDS-IN-CALC] Log NO INÃCIO do cÃ¡lculo de scores
    try {
        const refBandsInCalc = refData?.bands || refData?._referenceBands;
        const userBandsInCalc = analysis?.bands || analysis?.technicalData?.spectral_balance || analysis?.metrics?.bands;
        log('[AUDIT-BANDS-IN-CALC]', {
            calcHasRefBands: !!refBandsInCalc,
            calcHasUserBands: !!userBandsInCalc,
            refBandsType: typeof refBandsInCalc,
            userBandsType: typeof userBandsInCalc,
            refBandsKeys: refBandsInCalc ? Object.keys(refBandsInCalc) : [],
            userBandsKeys: userBandsInCalc ? Object.keys(userBandsInCalc) : [],
            refBandsSample: refBandsInCalc ? Object.keys(refBandsInCalc).slice(0, 3) : 'undefined',
            userBandsSample: userBandsInCalc ? Object.keys(userBandsInCalc).slice(0, 3) : 'undefined',
            refDataKeys: refData ? Object.keys(refData) : [],
            isReferenceMode: refData?._isReferenceMode,
            isGenreMode: isGenreMode,
            genreTargetsLoaded: refData?._genreTargetsLoaded
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-CALC', err);
    }
    
    if (!analysis || !refData) {
        warn('âš ï¸ Dados insuficientes para calcular scores');
        return null;
    }
    
    // Determinar genreKey
    const genreKey = genre ? genre.toLowerCase().replace(/\s+/g, '_') : null;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ V3.5: USAR NOVO SISTEMA UNIFICADO computeScoreV3
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const mode = window.__soundyState?.render?.mode || 'streaming';
    
    // ğŸš¨ CRÃTICO: soundDestination Ã‰ A FONTE ÃšNICA DA VERDADE PARA TARGETS DE LUFS
    // Deve ser pego de: analysis.soundDestination > window.__SOUNDY_ANALYSIS_MODE__ > 'pista'
    const effectiveSoundDestination = analysis?.soundDestination 
        || window.__SOUNDY_ANALYSIS_MODE__ 
        || getSoundDestinationMode?.() 
        || 'pista';
    
    error('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    error('â•‘  ğŸ¯ CALCULANDO SCORES - soundDestination                  â•‘');
    error('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    error('[SCORE-CALC] analysis.soundDestination:', analysis?.soundDestination);
    error('[SCORE-CALC] window.__SOUNDY_ANALYSIS_MODE__:', window.__SOUNDY_ANALYSIS_MODE__);
    error('[SCORE-CALC] effectiveSoundDestination:', effectiveSoundDestination);
    error('\n');
    
    // ğŸš¨ INJETAR soundDestination NO ANALYSIS ANTES DE PASSAR PARA computeScoreV3
    // Isso garante que a funÃ§Ã£o de scoring use o valor correto
    const analysisWithSoundDest = {
        ...analysis,
        soundDestination: effectiveSoundDestination
    };
    
    // Preparar targets no formato esperado pelo computeScoreV3
    const targetsForV3 = {
        lufs_target: refData.lufs_target,
        lufs_min: refData.lufs_min,
        lufs_max: refData.lufs_max,
        tol_lufs: refData.tol_lufs,
        true_peak_target: refData.true_peak_target,
        true_peak_min: refData.true_peak_min,
        true_peak_max: refData.true_peak_max,
        tol_true_peak: refData.tol_true_peak,
        dr_target: refData.dr_target,
        dr_min: refData.dr_min,
        dr_max: refData.dr_max,
        tol_dr: refData.tol_dr,
        bands: refData.bands
    };
    
    // Usar novo sistema unificado - PASSAR analysisWithSoundDest em vez de analysis
    const v3Result = window.computeScoreV3(analysisWithSoundDest, targetsForV3, mode);
    
    if (v3Result) {
        log('âœ… [V3.5] Score calculado pelo sistema unificado:', v3Result);
        
        // Mapear resultado V3 para formato esperado pelo sistema antigo
        // ğŸ¯ V4.1: INCLUIR metricEvaluations PARA buildDiagnosticContext
        const result = {
            final: v3Result.final,
            finalRaw: v3Result.raw,
            loudness: v3Result.subscores.loudness,
            dinamica: v3Result.subscores.dynamics,
            frequencia: v3Result.subscores.frequency,
            estereo: v3Result.subscores.stereo,
            tecnico: v3Result.subscores.technical,
            weights: v3Result.debug.weights,
            genre: genreKey,
            _v3Result: v3Result, // Resultado completo para debug
            _gatesTriggered: v3Result.gateReasons,
            _gatePenalty: v3Result.gatePenalty,
            metricScores: v3Result.metricScores,
            // ğŸ¯ V4.1: Dados necessÃ¡rios para buildDiagnosticContext
            metricEvaluations: v3Result.metricEvaluations,
            subscores: v3Result.subscores,
            gatesTriggered: v3Result.gatesTriggered,
            _frequencyDetails: v3Result._frequencyDetails
        };
        
        // ğŸ¯ LOG DE AUDITORIA: Verificar subscores apÃ³s correÃ§Ã£o
        log('[AUDIT-SCORES-V3.5] Subscores unificados:', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            estereo: result.estereo,
            frequencia: result.frequencia,
            tecnico: result.tecnico,
            raw: v3Result.raw,
            final: result.final,
            gatePenalty: v3Result.gatePenalty,
            gateReasons: v3Result.gateReasons.map(g => g.type)
        });
        
        return result;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FALLBACK: Sistema antigo se V3 falhar
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    warn('[V3.5] âš ï¸ computeScoreV3 retornou null, usando sistema antigo');
    
    // Calcular sub-scores (sistema antigo)
    const loudnessScore = calculateLoudnessScore(analysis, refData);
    const dynamicsScore = calculateDynamicsScore(analysis, refData);
    const stereoScore = calculateStereoScore(analysis, refData);
    const frequencyScore = calculateFrequencyScore(analysis, refData);
    const technicalScore = calculateTechnicalScore(analysis, refData);
    
    log('ğŸ“Š Sub-scores calculados (sistema antigo):', {
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        estereo: stereoScore,
        frequencia: frequencyScore,
        tecnico: technicalScore
    });
    
    // Determinar pesos por gÃªnero (genreKey jÃ¡ definido anteriormente)
    if (!genreKey) {
        warn('[GET-BAND-LABEL] GÃªnero nÃ£o fornecido, usando label genÃ©rico');
    }
    const weights = GENRE_SCORING_WEIGHTS[genreKey] || GENRE_SCORING_WEIGHTS['default'];
    
    log('âš–ï¸ Pesos aplicados:', weights);
    
    // CORREÃ‡ÃƒO: Calcular score final com valores contÃ­nuos
    let weightedSum = 0;
    let totalWeight = 0;
    
    // Somar apenas os scores que existem, ajustando os pesos dinamicamente
    if (loudnessScore !== null) {
        weightedSum += loudnessScore * weights.loudness;
        totalWeight += weights.loudness;
    }
    
    if (dynamicsScore !== null) {
        weightedSum += dynamicsScore * weights.dinamica;
        totalWeight += weights.dinamica;
    }
    
    if (stereoScore !== null) {
        weightedSum += stereoScore * weights.estereo;
        totalWeight += weights.estereo;
    }
    
    if (frequencyScore !== null) {
        weightedSum += frequencyScore * weights.frequencia;
        totalWeight += weights.frequencia;
    }
    
    if (technicalScore !== null) {
        weightedSum += technicalScore * weights.tecnico;
        totalWeight += weights.tecnico;
    }
    
    // Calcular score final normalizado (permite valores contÃ­nuos como 67.3, depois arredonda)
    let finalScore = null;
    if (totalWeight > 0) {
        const rawFinalScore = weightedSum / totalWeight;
        finalScore = Math.round(rawFinalScore); // SÃ³ arredondar no final
    }
    
    const result = {
        final: finalScore,
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        frequencia: frequencyScore,
        estereo: stereoScore,
        tecnico: technicalScore,
        weights: weights,
        genre: genreKey
    };
    
    // ğŸ¯ LOG DE AUDITORIA: Verificar subscores apÃ³s correÃ§Ã£o
    log('[AUDIT-SCORES-FIX] Subscores depois da correÃ§Ã£o:', {
        loudness: result.loudness,
        dinamica: result.dinamica,
        estereo: result.estereo,
        frequencia: result.frequencia,
        tecnico: result.tecnico,
        final: result.final
    });
    
    log('ğŸ¯ Score final calculado:', result);
    
    // ğŸ¯ AUDIT_REF_FIX: Log final de confirmaÃ§Ã£o do fluxo A/B
    // ğŸ”’ GUARD: SÃ³ executar logs de referÃªncia se viewMode === "reference"
    if (refData._isReferenceMode === true && getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        log('[REFERENCE-A/B FIXED âœ…] ComparaÃ§Ã£o A/B concluÃ­da com sucesso');
        log('[AUDIT_REF_FIX] Bands carregadas da segunda mÃºsica (referÃªncia real)');
        log('[AUDIT_REF_FIX] ReferenceComparison gerado com dados A/B corretos');
    }
    
    // ğŸ¯ AUDIT LOG FINAL
    try {
        log('[AUDIT-FINAL-SCORES]', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            frequencia: result.frequencia,
            estereo: result.estereo,
            tecnico: result.tecnico,
            finalScore: result.final,
            weights: result.weights,
            genre: result.genre,
            weightedCalculation: {
                loudness: result.loudness !== null ? (result.loudness * result.weights.loudness) : 'N/A',
                dinamica: result.dinamica !== null ? (result.dinamica * result.weights.dinamica) : 'N/A',
                frequencia: result.frequencia !== null ? (result.frequencia * result.weights.frequencia) : 'N/A',
                estereo: result.estereo !== null ? (result.estereo * result.weights.estereo) : 'N/A',
                tecnico: result.tecnico !== null ? (result.tecnico * result.weights.tecnico) : 'N/A'
            },
            isReferenceMode: refData._isReferenceMode === true
        });
    } catch (err) {
        warn('[AUDIT-ERROR]', 'calculateAnalysisScores (final)', err);
    }
    
    return result;
}

// Recalcular apenas as sugestÃµes baseadas em referÃªncia (sem reprocessar o Ã¡udio)
function updateReferenceSuggestions(analysis) {
    // ğŸ¯ CORREÃ‡ÃƒO CRÃTICA: Usar getActiveReferenceComparisonMetrics() para detectar targets corretamente
    const activeComparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasActiveComparisonMetrics = !!activeComparisonMetrics;
    
    log('ğŸ” [DEBUG-REF] updateReferenceSuggestions chamado:', {
        hasAnalysis: !!analysis,
        hasTechnicalData: !!analysis?.technicalData,
        hasActiveRefData: !!__activeRefData,
        hasReferenceComparisonMetrics: hasActiveComparisonMetrics, // âœ… CORRIGIDO: usa funÃ§Ã£o nova
        hasReferenceComparisonMetricsOLD: !!referenceComparisonMetrics, // âŒ ANTIGO (para comparaÃ§Ã£o)
        activeRefGenre: __activeRefGenre,
        activeRefDataKeys: __activeRefData ? Object.keys(__activeRefData) : null,
        currentGenre: window.PROD_AI_REF_GENRE,
        mode: analysis?.mode,
        activeComparisonMetricsSource: activeComparisonMetrics ? 'detected' : 'none'
    });
    
    if (!analysis || !analysis.technicalData) {
        warn('ğŸš¨ [DEBUG-REF] analysis ou technicalData ausentes');
        return;
    }
    
    // ğŸ¯ PRIORIDADE: Se temos comparaÃ§Ã£o entre faixas, usar referenceComparisonMetrics
    let targetMetrics = null;
    
    if (referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        log('âœ… [SUGGESTIONS] Usando referenceComparisonMetrics para sugestÃµes (comparaÃ§Ã£o entre faixas)');
        
        // Construir targetMetrics no formato esperado
        const refMetrics = referenceComparisonMetrics.reference;
        targetMetrics = {
            lufs_target: refMetrics.lufsIntegrated || refMetrics.lufs_integrated,
            true_peak_target: refMetrics.truePeakDbtp || refMetrics.true_peak_dbtp,
            dr_target: refMetrics.dynamicRange || refMetrics.dynamic_range,
            lra_target: refMetrics.lra,
            stereo_target: refMetrics.stereoCorrelation || refMetrics.stereo_correlation,
            spectral_centroid_target: refMetrics.spectralCentroidHz || refMetrics.spectral_centroid,
            bands: refMetrics.spectral_balance || null,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300
        };
        
        log('ğŸ“Š [SUGGESTIONS] Target metrics (2Âª faixa):', {
            lufs: targetMetrics.lufs_target,
            peak: targetMetrics.true_peak_target,
            dr: targetMetrics.dr_target
        });
        
        // Usar targetMetrics como __activeRefData temporariamente para compatibilidade
        __activeRefData = targetMetrics;
    }
    
    if (!__activeRefData) {
        warn('ğŸš¨ [DEBUG-REF] __activeRefData estÃ¡ null - tentando carregar gÃªnero atual');
        
        // Tentar carregar dados de referÃªncia do gÃªnero atual
        if (window.PROD_AI_REF_GENRE) {
            log('ğŸ”„ [DEBUG-REF] Tentando carregar dados para gÃªnero:', window.PROD_AI_REF_GENRE);
            loadReferenceData(window.PROD_AI_REF_GENRE).then(() => {
                log('âœ… [DEBUG-REF] Dados carregados, reprocessando sugestÃµes');
                updateReferenceSuggestions(analysis);
            }).catch(err => {
                error('âŒ [DEBUG-REF] Erro ao carregar dados:', err);
            });
        } else {
            // Tentar com dados de referÃªncia padrÃ£o embutidos
            log('ğŸ”„ [DEBUG-REF] Usando dados de referÃªncia embutidos');
            
            // Verificar se existem dados embutidos para o gÃªnero detectado nos scores
            if (analysis.scores && analysis.scores.genre) {
                const detectedGenre = analysis.scores.genre;
                log('ğŸ¯ [DEBUG-REF] GÃªnero detectado nos scores:', detectedGenre);
                
                // Usar dados embutidos se disponÃ­veis
                const embeddedRefs = {
                    eletrofunk: {
                        lufs_target: -8.3,
                        true_peak_target: -1,
                        dr_target: 10.1,
                        lra_target: 8.4,
                        stereo_target: 0.12,
                        bands: {
                            low_bass: { target_db: 13.3, tol_db: 2.36 },
                            low_mid: { target_db: 8.8, tol_db: 2.07 },
                            mid: { target_db: 2.5, tol_db: 1.81 },
                            high_mid: { target_db: -6.7, tol_db: 1.52 },
                            presenca: { target_db: -22.7, tol_db: 3.47 },
                            brilho: { target_db: -13.1, tol_db: 2.38 }
                        }
                    }
                };
                
                if (embeddedRefs[detectedGenre]) {
                    log('âœ… [DEBUG-REF] Usando dados embutidos para', detectedGenre);
                    __activeRefData = embeddedRefs[detectedGenre];
                    __activeRefGenre = detectedGenre;
                    // Continuar com o processamento
                } else {
                    warn('âŒ [DEBUG-REF] GÃªnero nÃ£o suportado nos dados embutidos:', detectedGenre);
                    return;
                }
            } else {
                warn('âŒ [DEBUG-REF] Nenhuma estratÃ©gia de recuperaÃ§Ã£o disponÃ­vel');
                return;
            }
        }
        
        // Se chegou atÃ© aqui sem return, __activeRefData foi definido pelos dados embutidos
        if (!__activeRefData) {
            return;
        }
    }
    
    // ğŸ›¡ï¸ PROTEÃ‡ÃƒO: Evitar duplicaÃ§Ã£o - resetar flag se chamado via applyGenreSelection
    if (analysis._suggestionsGenerated) {
        log('ğŸ¯ [SUGGESTIONS] Recalculando sugestÃµes para novo gÃªnero (resetando flag)');
        analysis._suggestionsGenerated = false;
    }
    
    // ğŸ¯ SISTEMA MELHORADO: Usar Enhanced Suggestion Engine quando disponÃ­vel
    if (typeof window !== 'undefined' && window.enhancedSuggestionEngine && window.USE_ENHANCED_SUGGESTIONS !== false) {
        try {
            log('ğŸ¯ Usando Enhanced Suggestion Engine...');
            
            // ğŸ¯ INTERCEPT CRÃTICO: Usar reference targets se modo for reference
            const state = window.__soundyState || {};
            let targetDataForEngine = __activeRefData;
            
            if (state.render?.mode === 'reference') {
                // Buscar dados da primeira faixa (referÃªncia) para usar como target
                const referenceBands = state.reference?.analysis?.technicalData?.spectral_balance
                    || state.reference?.analysis?.bands
                    || referenceComparisonMetrics?.referenceFull?.technicalData?.spectral_balance
                    || null;
                
                if (referenceBands) {
                    log('ï¿½ [ENGINE-INTERCEPT] Modo reference detectado - usando bandas da primeira faixa como target');
                    targetDataForEngine = {
                        ...(__activeRefData || {}),
                        bands: referenceBands,
                        _isReferenceMode: true,
                        _referenceSource: 'first_track'
                    };
                } else {
                    warn('âš ï¸ [ENGINE-INTERCEPT] Modo reference mas sem bandas - usando genreTargets (fallback)');
                }
            }
            
            log('ï¿½ğŸ” [DEBUG-ENGINE] Dados sendo passados para Enhanced Engine:', {
                mode: state.render?.mode,
                isReferenceMode: state.render?.mode === 'reference',
                analysis: {
                    hasTechnicalData: !!analysis.technicalData,
                    technicalDataKeys: analysis.technicalData ? Object.keys(analysis.technicalData) : null,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsCount: analysis.suggestions?.length || 0
                },
                targetDataForEngine: {
                    isNull: targetDataForEngine === null,
                    isUndefined: targetDataForEngine === undefined,
                    type: typeof targetDataForEngine,
                    keys: targetDataForEngine ? Object.keys(targetDataForEngine) : null,
                    structure: targetDataForEngine ? 'present' : 'missing',
                    hasBands: !!targetDataForEngine?.bands,
                    isReferenceMode: targetDataForEngine?._isReferenceMode
                }
            });
            
            // ğŸ”¥ PROTEÃ‡ÃƒO: Preservar technicalData e genreTargets ANTES do enhancedSuggestionEngine
            const __engineProtected = {
                technicalData: structuredClone(analysis.technicalData || {}),
                genreTargets: structuredClone(analysis.data?.genreTargets || null),
                metadata: structuredClone(analysis.metadata || {}),
                score: analysis.score,
                classification: analysis.classification
            };
            log('[ENGINE-PROTECT] ğŸ›¡ï¸ Dados protegidos antes de processAnalysis:', {
                techKeys: Object.keys(__engineProtected.technicalData).length,
                hasGT: !!__engineProtected.genreTargets
            });
            
            const enhancedAnalysis = window.enhancedSuggestionEngine.processAnalysis(analysis, targetDataForEngine);
            
            // ğŸ”¥ RESTAURAÃ‡ÃƒO: Restaurar dados protegidos DEPOIS do enhancedSuggestionEngine
            if (__engineProtected.technicalData && Object.keys(__engineProtected.technicalData).length > 0) {
                enhancedAnalysis.technicalData = structuredClone(__engineProtected.technicalData);
                log('[ENGINE-PROTECT] âœ… technicalData restaurado apÃ³s processAnalysis');
            }
            if (__engineProtected.genreTargets) {
                if (!enhancedAnalysis.data) enhancedAnalysis.data = {};
                enhancedAnalysis.data.genreTargets = structuredClone(__engineProtected.genreTargets);
                log('[ENGINE-PROTECT] âœ… genreTargets restaurado apÃ³s processAnalysis');
            }
            if (Object.keys(__engineProtected.metadata).length > 0) {
                enhancedAnalysis.metadata = structuredClone(__engineProtected.metadata);
            }
            if (__engineProtected.score !== null && __engineProtected.score !== undefined) {
                enhancedAnalysis.score = __engineProtected.score;
            }
            if (__engineProtected.classification) {
                enhancedAnalysis.classification = __engineProtected.classification;
            }
            
            // Substituir analysis pelo resultado protegido
            analysis = enhancedAnalysis;
            
            // ğŸ¯ PATCH 1: PRESERVAR sugestÃµes backend SEM sobrescrever
            // Guardar sugestÃµes originais (backend) separadamente
            const backendOriginalSuggestions = Array.isArray(analysis.suggestions) ? analysis.suggestions : [];
            analysis.backendSuggestions = backendOriginalSuggestions; // SugestÃµes originais do backend
            
            // Enhanced Engine cria campo SEPARADO - NÃƒO sobrescreve analysis.suggestions
            analysis.enhancedSuggestions = enhancedAnalysis.suggestions; // SugestÃµes recalculadas
            
            // âœ… analysis.suggestions permanece com valores BACKEND (nÃ£o sobrescrever)
            // Cards agora podem escolher qual usar verificando genreTargets
            
            // Adicionar mÃ©tricas melhoradas Ã  anÃ¡lise
            if (enhancedAnalysis.enhancedMetrics) {
                analysis.enhancedMetrics = enhancedAnalysis.enhancedMetrics;
            }
            
            // Adicionar log de auditoria
            if (enhancedAnalysis.auditLog) {
                analysis.auditLog = enhancedAnalysis.auditLog;
            }
            
            log(`ğŸ¯ [SUGGESTIONS] Backend suggestions (antigas): ${existingSuggestions.length} guardadas em backendSuggestions`);
            log(`ğŸ¯ [SUGGESTIONS] Enhanced Engine (NOVAS): ${enhancedAnalysis.suggestions.length} sugestÃµes`);
            log(`ğŸ¯ [SUGGESTIONS] Total final (SEM MIXING): ${analysis.suggestions.length} sugestÃµes`);
            log(`âœ… [FIX-CONSISTENCY] Cards e tabela agora usarÃ£o OS MESMOS targets/deltas`);
            
            // ğŸ¤– NOVA CAMADA DE IA: PÃ³s-processamento inteligente de sugestÃµes (Enhanced Engine)
            if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
                try {
                    log('ğŸ¤– [AI-LAYER] Enriquecendo sugestÃµes do Enhanced Engine...');
                    
                    // Preparar contexto para IA
                    const aiContext = {
                        technicalData: analysis.technicalData,
                        genre: __activeRefGenre || analysis.genre,
                        referenceData: __activeRefData,
                        problems: analysis.problems,
                        enhancedMetrics: enhancedAnalysis.enhancedMetrics
                    };
                    
                    // Chamar IA de forma assÃ­ncrona
                    window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                        .then(enhancedSuggestions => {
                            if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                                // âœ… aplicar ordem garantida apÃ³s IA
                                enhancedSuggestions = window.enhancedSuggestionEngine
                                    .enforceOrderedSuggestions(enhancedSuggestions);

                                analysis.suggestions = enhancedSuggestions;
                                analysis._aiEnhanced = true;
                                analysis._aiTimestamp = new Date().toISOString();
                                analysis._aiSource = 'enhanced_engine';
                                
                                log(`ğŸ¤– [AI-LAYER] âœ… Enhanced Engine + IA: ${enhancedSuggestions.length} sugestÃµes`);
                                
                                // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Sempre mostrar interface IA
                                if (window.aiUIController) {
                                    log(`ğŸš€ [FORCE-AI-UI] ForÃ§ando exibiÃ§Ã£o da interface IA com ${enhancedSuggestions.length} sugestÃµes`);
                                    window.aiUIController.checkForAISuggestions(analysis);
                                }
                                
                                // Re-renderizar se modal visÃ­vel
                                if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                                    displayModalResults(analysis);
                                }
                            }
                        })
                        .catch(error => {
                            warn('ğŸ¤– [AI-LAYER] âŒ Erro na IA do Enhanced Engine:', error);
                            
                            // ğŸš€ FORÃ‡A EXIBIÃ‡ÃƒO: Mostrar interface IA mesmo em caso de erro
                            setTimeout(() => {
                                if (window.aiUIController && analysis.suggestions) {
                                    log(`ğŸš€ [AI-UI-FORCE-ERROR] ForÃ§ando interface IA aparecer apÃ³s erro com ${analysis.suggestions.length} sugestÃµes`);
                                    window.aiUIController.checkForAISuggestions(analysis, true); // force = true
                                } else {
                                    warn('âš ï¸ [AI-UI-FORCE-ERROR] aiUIController nÃ£o encontrado ou sem sugestÃµes');
                                }
                            }, 100);
                        });
                } catch (error) {
                    warn('ğŸ¤– [AI-LAYER] âŒ Erro na integraÃ§Ã£o IA Enhanced Engine:', error);
                }
            }
            
            return;
            
        } catch (error) {
            warn('ğŸš¨ Erro no Enhanced Suggestion Engine, usando fallback:', error);
            // Continuar com sistema legado em caso de erro
        }
    }
    
    // ğŸ”„ SISTEMA LEGADO (fallback) - APENAS PARA SCORES, NÃƒO DEVE ALTERAR SUGESTÃ•ES
    log('ğŸ”„ [FALLBACK] Sistema legado ativado - usando apenas para calcular scores');
    
    // IMPORTANTE: NÃƒO modificar analysis.suggestions aqui para nÃ£o interferir com Enhanced Engine
    // Apenas calcular scores se necessÃ¡rio
    if (!analysis.scores && __activeRefData && analysis.technicalData) {
        try {
            analysis.scores = this.calculateFallbackScores(analysis.technicalData, __activeRefData);
            log('âœ… [FALLBACK] Scores calculados pelo sistema legado');
        } catch (error) {
            warn('âš ï¸ [FALLBACK] Erro ao calcular scores legados:', error);
        }
    }
    
    log('ğŸ¯ [FALLBACK] Sistema legado concluÃ­do sem alterar sugestÃµes');
    
    return; // âŒ SISTEMA LEGADO DESATIVADO - Enhanced Engine deve ser usado para sugestÃµes
    
    // ğŸ¤– NOVA CAMADA DE IA: PÃ³s-processamento inteligente de sugestÃµes
    // PONTO DE INTEGRAÃ‡ÃƒO SEGURO: ApÃ³s geraÃ§Ã£o de todas as sugestÃµes
    if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
        try {
            log('ğŸ¤– [AI-LAYER] Iniciando enriquecimento inteligente das sugestÃµes...');
            
            // Preparar contexto para IA
            const aiContext = {
                technicalData: analysis.technicalData,
                genre: __activeRefGenre || analysis.genre,
                referenceData: __activeRefData,
                problems: analysis.problems
            };
            
            // Chamar IA de forma assÃ­ncrona com fallback
            window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                .then(enhancedSuggestions => {
                    if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                        // âœ… aplicar ordem garantida apÃ³s IA
                        enhancedSuggestions = window.enhancedSuggestionEngine
                            .enforceOrderedSuggestions(enhancedSuggestions);

                        analysis.suggestions = enhancedSuggestions;
                        log(`ğŸ¤– [AI-LAYER] âœ… ${enhancedSuggestions.length} sugestÃµes enriquecidas com IA`);
                        
                        // Marcar que IA foi aplicada
                        analysis._aiEnhanced = true;
                        analysis._aiTimestamp = new Date().toISOString();
                        
                        // Re-renderizar modal se estiver visÃ­vel
                        if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                            log('ğŸ¨ [AI-LAYER] Re-renderizando modal com sugestÃµes IA');
                            displayModalResults(analysis);
                        }
                    } else {
                        warn('ğŸ¤– [AI-LAYER] âš ï¸ IA retornou resultado vazio, mantendo sugestÃµes originais');
                    }
                })
                .catch(error => {
                    warn('ğŸ¤– [AI-LAYER] âŒ Erro na camada de IA, mantendo sugestÃµes originais:', error);
                    // Sistema continua funcionando normalmente com sugestÃµes originais
                });
                
        } catch (error) {
            warn('ğŸ¤– [AI-LAYER] âŒ Erro na inicializaÃ§Ã£o da IA, sistema continua normal:', error);
        }
    } else {
        log('ğŸ¤– [AI-LAYER] Sistema de IA desabilitado ou nÃ£o disponÃ­vel');
    }
    
    // ğŸ›¡ï¸ Marcar que sugestÃµes foram geradas (proteÃ§Ã£o contra duplicaÃ§Ã£o)
    analysis._suggestionsGenerated = true;
}

/**
 * ğŸ”¢ Calcular scores bÃ¡sicos quando Enhanced Engine nÃ£o estÃ¡ disponÃ­vel
 * @param {Object} technicalData - Dados tÃ©cnicos da anÃ¡lise
 * @param {Object} referenceData - Dados de referÃªncia
 * @returns {Object} Scores calculados
 */
function calculateFallbackScores(technicalData, referenceData) {
    const scores = {};
    
    try {
        // Score LUFS
        if (Number.isFinite(technicalData.lufsIntegrated) && Number.isFinite(referenceData.lufs_target)) {
            const delta = Math.abs(technicalData.lufsIntegrated - referenceData.lufs_target);
            const tolerance = referenceData.tol_lufs || 2.0;
            scores.lufs = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score True Peak
        if (Number.isFinite(technicalData.truePeakDbtp)) {
            if (technicalData.truePeakDbtp > 0) {
                scores.truePeak = 0; // CrÃ­tico
            } else if (technicalData.truePeakDbtp > -1.0) {
                scores.truePeak = 5; // AceitÃ¡vel mas nÃ£o ideal
            } else {
                scores.truePeak = 10; // Ideal
            }
        }
        
        // Score DR
        if (Number.isFinite(technicalData.dynamicRange) && Number.isFinite(referenceData.dr_target)) {
            const delta = Math.abs(technicalData.dynamicRange - referenceData.dr_target);
            const tolerance = referenceData.tol_dr || 2.0;
            scores.dr = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score geral (mÃ©dia dos scores disponÃ­veis)
        const availableScores = Object.values(scores).filter(s => Number.isFinite(s));
        if (availableScores.length > 0) {
            scores.overall = availableScores.reduce((sum, score) => sum + score, 0) / availableScores.length;
        }
        
        log('ğŸ“Š [FALLBACK] Scores calculados:', scores);
        return scores;
        
    } catch (error) {
        error('âŒ [FALLBACK] Erro ao calcular scores:', error);
        return {};
    }
}

// ğŸ¨ Estilos do seletor de gÃªnero (injeÃ§Ã£o Ãºnica, nÃ£o quebra CSS existente)
function injectRefGenreStyles() {
    if (document.getElementById('refGenreEnhancedStyles')) return; // jÃ¡ injetado
    const style = document.createElement('style');
    style.id = 'refGenreEnhancedStyles';
    style.textContent = `
    #audioRefGenreContainer{position:relative;gap:10px;padding:6px 10px 4px 10px;border:1px solid rgba(255,255,255,.06);background:linear-gradient(145deg,#0c111b,#0d1321);border-radius:10px;box-shadow:0 2px 6px -2px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,0.02);}
    #audioRefGenreContainer label{font-weight:500;letter-spacing:.3px;color:#9fb3d9;margin-right:4px;}
    #audioRefGenreSelect{appearance:none;-webkit-appearance:none;-moz-appearance:none;position:relative;padding:6px 32px 6px 12px;font-size:12px;line-height:1.2;background:rgba(20,32,54,.7);color:#f4f7fb;border:1px solid #1e2b40;border-radius:8px;cursor:pointer;font-family:inherit;transition:border .25s, background .25s, box-shadow .25s;min-width:140px;}
    #audioRefGenreSelect:hover{background:rgba(28,44,76,.85);}
    #audioRefGenreSelect:focus{outline:none;border-color:#249dff;box-shadow:0 0 0 2px rgba(36,157,255,.3);}
    #audioRefGenreSelect:active{transform:translateY(1px);} 
    #audioRefGenreContainer::after{content:"";position:absolute;top:13px;left: calc(10px + 140px);pointer-events:none;}
    #audioRefGenreContainer .select-wrap{position:relative;}
    /* Seta custom */
    #audioRefGenreContainer .select-wrap:after{content:"";position:absolute;right:12px;top:50%;width:7px;height:7px;border-right:2px solid #9fb3d9;border-bottom:2px solid #9fb3d9;transform:translateY(-60%) rotate(45deg);pointer-events:none;transition:transform .25s,border-color .25s;}
    #audioRefGenreSelect:focus + .arrow, #audioRefGenreContainer .select-wrap:focus-within:after{border-color:#53c2ff;}
    #audioRefStatus{font-size:11px;font-weight:500;letter-spacing:.4px;padding:4px 10px;border-radius:7px;background:#0d6efd;color:#fff;display:inline-flex;align-items:center;gap:6px;box-shadow:0 0 0 1px rgba(255,255,255,.06),0 2px 4px -1px rgba(0,0,0,.7);}
    #audioRefStatus::before{content:"";width:7px;height:7px;border-radius:50%;background:#3df29b;box-shadow:0 0 0 3px rgba(61,242,155,.25);} 
    #audioRefGenreContainer.dark #audioRefStatus{background:#14324f;}
    @media (max-width:600px){#audioRefGenreContainer{padding:6px 8px 4px 8px;gap:6px;}#audioRefGenreSelect{min-width:120px;padding:6px 28px 6px 10px;}}
    `;
    // Wrap opcional para setinha sem mexer HTML: inserir span ao redor do select
    const select = document.getElementById('audioRefGenreSelect');
    if (select && !select.parentElement.classList.contains('select-wrap')) {
        const wrap = document.createElement('div');
        wrap.className = 'select-wrap';
        wrap.style.position = 'relative';
        select.parentNode.insertBefore(wrap, select);
        wrap.appendChild(select);
    }
    document.head.appendChild(style);
}

// ğŸ¨ Estilos do Modal de GÃªnero Musical - Glassmorphism + Glitch
function injectGenreModalStyles() {
    if (document.getElementById('genreModalStyles')) return; // jÃ¡ injetado
    const style = document.createElement('style');
    style.id = 'genreModalStyles';
    style.textContent = `
    /* ğŸµ Novo Modal de GÃªnero Musical - Glassmorphism */
    .genre-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        z-index: 10000;
        opacity: 1;
        transition: opacity 0.3s ease;
    }

    .genre-modal.hidden {
        display: none;
        opacity: 0;
    }

    .genre-modal-container {
        max-width: 720px;
        width: 90%;
        max-height: 90vh;
        background: radial-gradient(
    circle at 20% 20%, 
    rgba(93, 21, 134, 0.85) 0%,       /* Roxo vibrante no canto */
    rgba(0, 0, 0, 0.95) 60%,          /* Preto no centro */
    rgba(0, 102, 255, 0.4) 100%       /* Azul elÃ©trico nas bordas */
);
backdrop-filter: blur(8px);
box-shadow: 0 0 30px rgba(93, 21, 134, 0.4),
            0 0 60px rgba(0, 102, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        padding: 40px 32px 32px 32px;
        text-align: center;
        position: relative;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        box-shadow: 
            0 20px 40px rgba(91, 11, 156, 0.49),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: scale(1);
        transition: transform 0.2s ease;
        overflow: hidden;
    }

    /* LINHAS NEURAIS VANTA - FUNDO TECH */
    .genre-modal-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 40px,
                rgba(106, 154, 255, 0.03) 40px,
                rgba(106, 154, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 40px,
                rgba(106, 0, 255, 0.03) 40px,
                rgba(106, 0, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 60px,
                rgba(0, 212, 255, 0.02) 60px,
                rgba(0, 212, 255, 0.02) 61px
            );
        opacity: 0.6;
        animation: neural-grid-genre 15s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    /* PartÃ­culas flutuantes */
    .genre-modal-container::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background-image: 
            radial-gradient(circle, rgba(106, 0, 255, 0.15) 1px, transparent 1px),
            radial-gradient(circle, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
        background-size: 50px 50px, 80px 80px;
        background-position: 0 0, 25px 25px;
        animation: particles-float-genre 20s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    @keyframes neural-grid-genre {
        0% {
            transform: translate(0, 0);
            opacity: 0.6;
        }
        50% {
            opacity: 0.4;
        }
        100% {
            transform: translate(40px, 40px);
            opacity: 0.6;
        }
    }

    @keyframes particles-float-genre {
        0% {
            transform: translate(0, 0) rotate(0deg);
        }
        100% {
            transform: translate(50px, 50px) rotate(360deg);
        }
    }

    /* Garante que conteÃºdo fica acima do fundo neural */
    .genre-modal-container > * {
        position: relative;
        z-index: 5;
    }

    /* TÃ­tulo com efeito glitch - Paleta roxo escuro + azul ciano */
    .genre-modal-title {
        font-family: 'Orbitron', 'Rajdhani', 'Montserrat Alternates', sans-serif;
        font-size: 2.2rem;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        margin-bottom: 12px;
        position: relative;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 
            0 0 12px rgba(0, 212, 255, 0.4),
            0 0 24px rgba(108, 0, 162, 0.2),
            0 0 40px rgba(0, 212, 255, 0.15);
    }

    .genre-modal-title.glitch::before,
    .genre-modal-title.glitch::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.85;
        pointer-events: none;
    }

    /* PARTE SUPERIOR â€” Roxo escuro */
    .genre-modal-title.glitch::before {
        color: #6c00a2;
        animation: glitch-1 2s infinite alternate-reverse;
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }

    /* PARTE INFERIOR â€” Azul ciano */
    .genre-modal-title.glitch::after {
        color: #00d4ff;
        animation: glitch-2 3s infinite alternate-reverse;
        clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }

    @keyframes glitch-1 {
        0% { transform: translateX(-2px); }
        100% { transform: translateX(2px); }
    }

    @keyframes glitch-2 {
        0% { transform: translateX(2px); }
        100% { transform: translateX(-2px); }
    }

    .genre-modal-subtitle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 1rem;
        margin-bottom: 32px;
        font-weight: 400;
    }

    /* Grid de gÃªneros */
    .genre-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 32px;
    }

    /* ğŸ”§ CORREÃ‡ÃƒO FLASH BRANCO: Estado inicial explÃ­cito */
    .genre-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px 16px;
        
        /* Estado base: exatamente o visual glass atual */
        background: rgba(255, 255, 255, 0.05);
        background-color: transparent; /* Evita herdar branco do user-agent */
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        color: #ffffff;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        
        /* âŒ NÃƒO animar background - sÃ³ transform, box-shadow, border-color, opacity */
        transition: 
            transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            opacity 0.25s ease;
        
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        
        /* Zera estilos nativos se for <button> */
        -webkit-appearance: none;
        appearance: none;
    }

    /* Prepaint: cards invisÃ­veis enquanto CSS assenta */
    .genre-modal.prepaint .genre-card {
        opacity: 0;
    }

    .genre-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.1), 
            transparent);
        transition: left 0.6s ease;
    }

    .genre-card:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(36, 157, 255, 0.4);
        transform: scale(1.05) translateY(-2px);
        box-shadow: 
            0 10px 25px rgba(0, 0, 0, 0.4),
            0 0 0 1px rgba(36, 157, 255, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .genre-card:hover::before {
        left: 100%;
    }

    .genre-card:active {
        transform: scale(0.98) translateY(1px);
    }

    .genre-icon {
        font-size: 2rem;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
    }

    .genre-name {
        font-weight: 700;
        letter-spacing: 0.5px;
    }

    /* BotÃ£o fechar */
    .genre-modal-close {
        background: rgba(255, 255, 255, 0.08);
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 0.9rem;
        cursor: pointer;
        /* âŒ NÃƒO animar background */
        transition: 
            border-color 0.2s ease,
            color 0.2s ease,
            opacity 0.2s ease;
        font-weight: 500;
        -webkit-appearance: none;
        appearance: none;
    }

    .genre-modal-close:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.4);
    }

    /* Responsividade */
    @media (max-width: 768px) {
        .genre-modal-container {
            width: 95%;
            padding: 32px 20px 24px 20px;
        }

        .genre-modal-title {
            font-size: 1.8rem;
        }

        .genre-grid {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .genre-card {
            padding: 16px 12px;
            gap: 8px;
        }

        .genre-icon {
            font-size: 1.5rem;
        }

        .genre-name {
            font-size: 0.85rem;
        }
    }

    @media (max-width: 480px) {
        .genre-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .genre-card {
            padding: 14px 10px;
        }
    }
    `;
    document.head.appendChild(style);
}

// ğŸ¤– Enviar anÃ¡lise para chat
window.sendModalAnalysisToChat = async function sendModalAnalysisToChat() {
    // ğŸ”’ GUARD: Bloquear funcionalidade premium em modo reduced
    // âœ… Prioridade 1: Sistema centralizado de capabilities
    if (window.PlanCapabilities && window.PlanCapabilities.shouldBlockAiHelp()) {
        log('ğŸ”’ [PREMIUM-GUARD] Funcionalidade "Pedir Ajuda Ã  IA" bloqueada');
        log('ğŸ“Š [PREMIUM-GUARD] Contexto:', window.PlanCapabilities.getCurrentContext());
        
        // âœ… Abrir modal de upgrade (com classe visible para CSS)
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            log('âœ… [PREMIUM-GUARD] Modal de upgrade aberto (AI)');
        } else {
            error('âŒ [PREMIUM-GUARD] Modal upgradeModal nÃ£o encontrado no DOM');
        }
        return; // âœ… BLOQUEIO: NÃ£o executa funÃ§Ã£o real
    }
    
    // âœ… Prioridade 2: Fallback para APP_MODE (compatibilidade)
    if (window.APP_MODE === 'reduced') {
        log('ğŸ”’ [PREMIUM-GUARD] Funcionalidade "Pedir Ajuda Ã  IA" bloqueada (fallback APP_MODE)');
        
        // âœ… Abrir modal de upgrade
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            log('âœ… [PREMIUM-GUARD] Modal de upgrade aberto (AI - fallback)');
        } else {
            error('âŒ [PREMIUM-GUARD] Modal upgradeModal nÃ£o encontrado no DOM');
        }
        return; // âœ… BLOQUEIO: NÃ£o executa funÃ§Ã£o real
    }
    
    __dbg('ğŸ¯ BOTÃƒO CLICADO: Pedir Ajuda Ã  IA');
    
    if (!currentModalAnalysis) {
        alert('Nenhuma anÃ¡lise disponÃ­vel');
        __dbg('âŒ Erro: currentModalAnalysis nÃ£o existe');
        return;
    }
    
    __dbg('ğŸ¤– Enviando anÃ¡lise para chat...', currentModalAnalysis);
    
    try {
        // Gerar prompt personalizado baseado nos problemas encontrados
        const prompt = window.audioAnalyzer.generateAIPrompt(currentModalAnalysis);
        const message = `ğŸµ Analisei meu Ã¡udio e preciso de ajuda para melhorar. Aqui estÃ£o os dados tÃ©cnicos:\n\n${prompt}`;
        
        __dbg('ğŸ“ Prompt gerado:', message.substring(0, 200) + '...');
        
        // Tentar diferentes formas de integrar com o chat
        let messageSent = false;
        
        // MÃ©todo 1: Usar diretamente o ProdAI Chatbot quando disponÃ­vel
        if (window.prodAIChatbot) {
            __dbg('ğŸ¯ Tentando enviar via ProdAI Chatbot...');
            try {
                // Se o chat ainda nÃ£o estÃ¡ ativo, ativar com a mensagem
                if (!window.prodAIChatbot.isActive && typeof window.prodAIChatbot.activateChat === 'function') {
                    __dbg('ğŸš€ Chat inativo. Ativando com a primeira mensagem...');
                    await window.prodAIChatbot.activateChat(message);
                    showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                    closeAudioModal();
                    messageSent = true;
                } else if (typeof window.prodAIChatbot.sendMessage === 'function') {
                    // Chat jÃ¡ ativo: preencher input ativo e enviar
                    const activeInput = document.getElementById('chatbotActiveInput');
                    if (activeInput) {
                        activeInput.value = message;
                        activeInput.focus();
                        activeInput.dispatchEvent(new Event('input', { bubbles: true }));
                        await window.prodAIChatbot.sendMessage();
                        showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                        closeAudioModal();
                        messageSent = true;
                    }
                }
            } catch (err) {
                __dwrn('âš ï¸ Falha ao usar ProdAIChatbot direto, tentando fallback...', err);
            }
        }
        // MÃ©todo 2: Inserir diretamente no input e simular envio
        else {
            __dbg('ğŸ¯ Tentando mÃ©todo alternativo...');
            
            const input = document.getElementById('chatbotActiveInput') || document.getElementById('chatbotMainInput');
            const sendBtn = document.getElementById('chatbotActiveSendBtn') || document.getElementById('chatbotSendButton');
            
            __dbg('ğŸ” Elementos encontrados:', { input: !!input, sendBtn: !!sendBtn });
            
            if (input && sendBtn) {
                input.value = message;
                input.focus();
                
                // Disparar eventos para simular interaÃ§Ã£o do usuÃ¡rio
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                
                // Aguardar um pouco e clicar no botÃ£o
                setTimeout(() => {
                    sendBtn.click();
                    __dbg('âœ… BotÃ£o clicado');
                    showTemporaryFeedback('ğŸµ AnÃ¡lise enviada para o chat!');
                    closeAudioModal();
                }, 500);
                
                messageSent = true;
            }
        }
        
        if (!messageSent) {
            __dbg('âŒ NÃ£o foi possÃ­vel enviar automaticamente, copiando para clipboard...');
            
            // Fallback: copiar para clipboard
            await navigator.clipboard.writeText(message);
            showTemporaryFeedback('ğŸ“‹ AnÃ¡lise copiada! Cole no chat manualmente.');
            __dbg('ğŸ“‹ Mensagem copiada para clipboard como fallback');
        }
        
    } catch (error) {
        error('âŒ Erro ao enviar anÃ¡lise para chat:', error);
        showTemporaryFeedback('âŒ Erro ao enviar anÃ¡lise. Tente novamente.');
    }
}

// ğŸ“„ GERAR RELATÃ“RIO PDF PREMIUM PARA MODO REFERÃŠNCIA (2 PÃGINAS FIXAS)
async function generateReferenceReportPDF() {
    log('[REF-PDF] ğŸš€ Iniciando geraÃ§Ã£o de PDF Premium (2 pÃ¡ginas fixas)...');
    
    // Verificar dependÃªncias
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('âš™ï¸ Carregando bibliotecas...');
        warn('[REF-PDF] âš ï¸ Aguardando carregamento de jsPDF/html2canvas...');
        setTimeout(() => generateReferenceReportPDF(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('âš™ï¸ Gerando relatÃ³rio premium...');
        
        // ğŸ¯ OBTER DADOS DAS DUAS FAIXAS
        const store = window.SoundyAI_Store || {};
        const firstAnalysis = store.first || window.__soundyState?.reference?.userAnalysis || FirstAnalysisStore?.getUser();
        const secondAnalysis = store.second || window.__soundyState?.reference?.referenceAnalysis || FirstAnalysisStore?.getRef();
        
        if (!firstAnalysis || !secondAnalysis) {
            alert('âŒ Dados de comparaÃ§Ã£o nÃ£o encontrados.\n\nAs duas faixas precisam estar analisadas.');
            error('[REF-PDF] Dados insuficientes:', { 
                hasFirst: !!firstAnalysis, 
                hasSecond: !!secondAnalysis 
            });
            return;
        }
        
        // ğŸ¯ OBTER SUGESTÃ•ES DO REFERENCE MODE
        const abSuggestions = window.PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA || [];
        log('[REF-PDF] ğŸ“Š SugestÃµes carregadas:', abSuggestions.length);
        
        // Helper para remover extensÃ£o
        const removeExtension = (filename) => {
            if (!filename) return 'Faixa';
            return filename.replace(/\.[^/.]+$/, '');
        };
        
        // Extrair nomes das faixas
        const trackAName = removeExtension(
            firstAnalysis.metadata?.fileName || 
            firstAnalysis.fileName || 
            'Faixa Analisada'
        );
        const trackBName = removeExtension(
            secondAnalysis.metadata?.fileName || 
            secondAnalysis.fileName || 
            'Faixa ReferÃªncia'
        );
        
        log('[REF-PDF] ğŸ“Š Faixas:', { trackAName, trackBName });
        
        // Extrair mÃ©tricas tÃ©cnicas
        const techA = firstAnalysis.technicalData || {};
        const techB = secondAnalysis.technicalData || {};
        
        // FunÃ§Ã£o helper para formatar valores
        const nf = (v, d = 2) => {
            if (v === null || v === undefined || isNaN(v)) return 'â€”';
            return Number(v).toFixed(d);
        };
        
        // Calcular diferenÃ§as
        const calcDelta = (a, b) => {
            if (!Number.isFinite(a) || !Number.isFinite(b)) return { diff: 'â€”', severity: 'OK' };
            const diff = a - b;
            const absDiff = Math.abs(diff);
            let severity = 'OK';
            if (absDiff >= 3) severity = 'CRÃTICA';
            else if (absDiff >= 2) severity = 'ALTA';
            else if (absDiff >= 1) severity = 'ATENÃ‡ÃƒO';
            return { diff: (diff > 0 ? '+' : '') + diff.toFixed(1), severity };
        };
        
        const getSeverityColor = (sev) => {
            if (sev === 'CRÃTICA') return '#ff4444';
            if (sev === 'ALTA') return '#ff9800';
            if (sev === 'ATENÃ‡ÃƒO') return '#ffc107';
            return '#52f7ad';
        };
        
        // MÃ©tricas principais com severidade
        const metrics = [
            { 
                label: 'LUFS Integrado', 
                valueA: techA.lufsIntegrated || techA.lufs_integrated, 
                valueB: techB.lufsIntegrated || techB.lufs_integrated, 
                unit: ' LUFS',
                action: 'Ajustar loudness'
            },
            { 
                label: 'True Peak', 
                valueA: techA.truePeakDbtp || techA.true_peak_dbtp, 
                valueB: techB.truePeakDbtp || techB.true_peak_dbtp, 
                unit: ' dBTP',
                action: 'Ajustar limitaÃ§Ã£o'
            },
            { 
                label: 'Dynamic Range', 
                valueA: techA.dynamicRange || techA.dynamic_range, 
                valueB: techB.dynamicRange || techB.dynamic_range, 
                unit: ' dB',
                action: 'Ajustar compressÃ£o'
            },
            { 
                label: 'LRA', 
                valueA: techA.lra, 
                valueB: techB.lra, 
                unit: ' LU',
                action: 'Controlar dinÃ¢mica'
            },
            { 
                label: 'Stereo Correlation', 
                valueA: techA.stereoCorrelation || techA.stereo_correlation, 
                valueB: techB.stereoCorrelation || techB.stereo_correlation, 
                unit: '',
                action: 'Ajustar imagem estÃ©reo'
            }
        ].map(m => {
            const delta = calcDelta(m.valueA, m.valueB);
            return { ...m, delta: delta.diff, severity: delta.severity };
        });
        
        // Bandas espectrais com severidade
        const bandsA = techA.spectral_balance || {};
        const bandsB = techB.spectral_balance || {};
        const bandsList = [
            { key: 'sub', label: 'Sub Bass', range: '20-60Hz', icon: 'ğŸ”Š' },
            { key: 'low_bass', label: 'Bass', range: '60-120Hz', icon: 'ğŸ¸' },
            { key: 'upper_bass', label: 'Upper Bass', range: '120-250Hz', icon: 'ğŸ¸' },
            { key: 'low_mid', label: 'Low-Mid', range: '250-500Hz', icon: 'ğŸ¹' },
            { key: 'mid', label: 'Mid', range: '500-2kHz', icon: 'ğŸ¤' },
            { key: 'high_mid', label: 'High-Mid', range: '2-5kHz', icon: 'âœ¨' },
            { key: 'presence', label: 'Presence', range: '5-10kHz', icon: 'ğŸ””' },
            { key: 'air', label: 'Air/Brilho', range: '10-20kHz', icon: 'ğŸ’«' }
        ].map(b => {
            const valA = bandsA[b.key]?.energy_db ?? bandsA[b.key]?.rms_db ?? bandsA[b.key];
            const valB = bandsB[b.key]?.energy_db ?? bandsB[b.key]?.rms_db ?? bandsB[b.key];
            const delta = calcDelta(valA, valB);
            return { 
                ...b, 
                valueA: valA, 
                valueB: valB, 
                delta: delta.diff, 
                severity: delta.severity,
                action: delta.severity === 'OK' ? 'Dentro do padrÃ£o' : `Ajustar ${delta.diff} dB`
            };
        });
        
        // Calcular score geral (simplificado)
        const allItems = [...metrics, ...bandsList];
        const okCount = allItems.filter(i => i.severity === 'OK').length;
        const score = Math.round((okCount / allItems.length) * 100);
        let scoreLabel = 'ğŸ”§ Necessita Ajustes';
        if (score >= 90) scoreLabel = 'ğŸ† Excelente';
        else if (score >= 75) scoreLabel = 'â­ Ã“timo';
        else if (score >= 60) scoreLabel = 'ğŸ‘ Bom';
        
        // Top 3 problemas e top 3 ok
        const problems = allItems.filter(i => i.severity !== 'OK').sort((a, b) => {
            const order = { 'CRÃTICA': 0, 'ALTA': 1, 'ATENÃ‡ÃƒO': 2 };
            return order[a.severity] - order[b.severity];
        });
        const topProblems = problems.slice(0, 3);
        const okItems = allItems.filter(i => i.severity === 'OK').slice(0, 3);
        
        // Data e hora
        const date = new Date().toLocaleDateString('pt-BR');
        const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        
        // ğŸ¨ GERAR HTML PÃGINA 1: RESUMO & COMPARAÃ‡ÃƒO
        const page1HTML = `
<div class="pdf-page-1" style="width: 794px; height: 1123px; background: #0a0f1a; color: #e0e6f0; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">
    
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 2px solid rgba(139, 92, 246, 0.3);">
        <div>
            <h1 style="margin: 0; font-size: 32px; font-weight: 700; background: linear-gradient(135deg, #8B5CF6, #3B82F6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">SoundyAI</h1>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #9ca3af;">RelatÃ³rio â€¢ Modo ReferÃªncia</p>
        </div>
        <div style="text-align: right;">
            <p style="margin: 0; font-size: 14px; color: #e0e6f0;">${date}</p>
            <p style="margin: 3px 0 0 0; font-size: 12px; color: #9ca3af;">${time}</p>
        </div>
    </div>
    
    <!-- Score Hero -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border-radius: 16px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h2 style="margin: 0; font-size: 56px; font-weight: 700; color: white;">${score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h2>
                <p style="margin: 8px 0 0 0; font-size: 18px; color: rgba(255,255,255,0.95);">${scoreLabel}</p>
            </div>
            <div style="font-size: 64px;">ğŸµ</div>
        </div>
    </div>
    
    <!-- Principais Problemas & Pontos OK -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
        <div style="background: rgba(255, 68, 68, 0.1); border: 1px solid rgba(255, 68, 68, 0.3); border-radius: 10px; padding: 15px;">
            <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff4444;">âš ï¸ Principais Problemas</h3>
            <ul style="margin: 0; padding-left: 18px; font-size: 11px; line-height: 1.6; color: #e0e6f0;">
                ${topProblems.map(p => `<li>${p.label}: ${p.delta}</li>`).join('') || '<li>Nenhum problema crÃ­tico</li>'}
            </ul>
        </div>
        <div style="background: rgba(82, 247, 173, 0.1); border: 1px solid rgba(82, 247, 173, 0.3); border-radius: 10px; padding: 15px;">
            <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #52f7ad;">âœ… Pontos OK</h3>
            <ul style="margin: 0; padding-left: 18px; font-size: 11px; line-height: 1.6; color: #e0e6f0;">
                ${okItems.map(i => `<li>${i.label}</li>`).join('') || '<li>â€”</li>'}
            </ul>
        </div>
    </div>
    
    <!-- ComparaÃ§Ã£o -->
    <div style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 15px; margin-bottom: 20px;">
        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #8B5CF6;">ğŸ§ ComparaÃ§Ã£o</h3>
        <div style="display: flex; gap: 15px; font-size: 12px;">
            <div style="flex: 1; background: rgba(82, 247, 173, 0.05); border-radius: 8px; padding: 10px;">
                <p style="margin: 0; font-size: 10px; color: #52f7ad; text-transform: uppercase;">Faixa A (Analisada)</p>
                <p style="margin: 5px 0 0 0; font-weight: 600; color: #fff;">${trackAName}</p>
            </div>
            <div style="flex: 1; background: rgba(111, 235, 239, 0.05); border-radius: 8px; padding: 10px;">
                <p style="margin: 0; font-size: 10px; color: #6FEBEF; text-transform: uppercase;">Faixa B (ReferÃªncia)</p>
                <p style="margin: 5px 0 0 0; font-weight: 600; color: #fff;">${trackBName}</p>
            </div>
        </div>
    </div>
    
    <!-- Tabela Completa: MÃ©tricas + Bandas -->
    <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #8B5CF6;">ğŸ“Š MÃ©tricas & Bandas</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 10px;">
            <thead>
                <tr style="background: rgba(139, 92, 246, 0.1);">
                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">MÃ©trica</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Valor</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Alvo</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">DiferenÃ§a</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Severidade</th>
                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">AÃ§Ã£o</th>
                </tr>
            </thead>
            <tbody>
                <!-- MÃ©tricas -->
                ${metrics.map(m => `
                <tr>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #e0e6f0;">${m.label}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(m.valueA)}${m.unit}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(m.valueB)}${m.unit}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #ffc107;">${m.delta}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center;">
                        <span style="padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(m.severity)}22; color: ${getSeverityColor(m.severity)};">${m.severity}</span>
                    </td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #9ca3af; font-size: 9px;">${m.action}</td>
                </tr>
                `).join('')}
                <!-- Bandas -->
                ${bandsList.map(b => `
                <tr>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #e0e6f0;">${b.icon} ${b.label} <span style="font-size: 8px; color: #6b7280;">${b.range}</span></td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(b.valueA, 1)} dB</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(b.valueB, 1)} dB</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #ffc107;">${b.delta}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center;">
                        <span style="padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(b.severity)}22; color: ${getSeverityColor(b.severity)};">${b.severity}</span>
                    </td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #9ca3af; font-size: 9px;">${b.action}</td>
                </tr>
                `).join('')}
            </tbody>
        </table>
    </div>
    
    <!-- RodapÃ© PÃ¡gina 1 -->
    <div style="position: absolute; bottom: 25px; left: 40px; right: 40px; text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 11px; color: #8B5CF6; font-weight: 600;">SoundyAI</p>
        <p style="margin: 3px 0 0 0; font-size: 9px; color: #6b7280;">PÃ¡gina 1/2 | Gerado automaticamente em ${date}</p>
    </div>
    
</div>
        `;
        
        // ğŸ¨ GERAR HTML PÃGINA 2: PLANO DE CORREÃ‡ÃƒO
        const criticalItems = allItems.filter(i => i.severity === 'CRÃTICA');
        const highItems = allItems.filter(i => i.severity === 'ALTA');
        const warningItems = allItems.filter(i => i.severity === 'ATENÃ‡ÃƒO');
        const okItemsAll = allItems.filter(i => i.severity === 'OK');
        
        const renderSuggestionCard = (item, index) => `
        <div style="background: rgba(255,255,255,0.03); border-left: 3px solid ${getSeverityColor(item.severity)}; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <h4 style="margin: 0; font-size: 12px; font-weight: 600; color: #fff;">${item.label}${item.range ? ` (${item.range})` : ''}</h4>
                <span style="padding: 2px 8px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(item.severity)}22; color: ${getSeverityColor(item.severity)};">${item.severity}</span>
            </div>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #9ca3af;"><strong>Problema:</strong> DiferenÃ§a de ${item.delta} detectada</p>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #9ca3af;"><strong>Meta:</strong> ${nf(item.valueB)}${item.unit || ' dB'}</p>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #52f7ad;"><strong>AÃ§Ã£o:</strong> ${item.action}</p>
            <p style="margin: 0; font-size: 9px; color: #6b7280;"><strong>Impacto:</strong> ${item.severity === 'CRÃTICA' ? 'Essencial para qualidade profissional' : item.severity === 'ALTA' ? 'Melhora significativa esperada' : 'Refinamento para maior proximidade'}</p>
        </div>
        `;
        
        const page2HTML = `
<div class="pdf-page-2" style="width: 794px; height: 1123px; background: #0a0f1a; color: #e0e6f0; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">
    
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(139, 92, 246, 0.3);">
        <div>
            <h1 style="margin: 0; font-size: 28px; font-weight: 700; background: linear-gradient(135deg, #8B5CF6, #3B82F6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">SoundyAI</h1>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #9ca3af;">Plano de CorreÃ§Ã£o</p>
        </div>
        <div style="text-align: right;">
            <p style="margin: 0; font-size: 12px; color: #e0e6f0;">${trackAName}</p>
            <p style="margin: 3px 0 0 0; font-size: 10px; color: #6b7280;">PÃ¡gina 2/2</p>
        </div>
    </div>
    
    <!-- TÃ­tulo -->
    <h2 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600; color: #8B5CF6;">ğŸ› ï¸ Plano de CorreÃ§Ã£o (Passo a Passo)</h2>
    
    <!-- SeÃ§Ã£o CRÃTICAS -->
    ${criticalItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff4444;">ğŸš¨ CRÃTICAS (Corrigir Primeiro)</h3>
        ${criticalItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- SeÃ§Ã£o ALTAS -->
    ${highItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff9800;">âš ï¸ ALTAS</h3>
        ${highItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- SeÃ§Ã£o ATENÃ‡ÃƒO -->
    ${warningItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ffc107;">âš¡ ATENÃ‡ÃƒO</h3>
        ${warningItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- SeÃ§Ã£o OK (resumida) -->
    ${okItemsAll.length > 0 ? `
    <div style="background: rgba(82, 247, 173, 0.05); border: 1px solid rgba(82, 247, 173, 0.2); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
        <h3 style="margin: 0 0 8px 0; font-size: 13px; font-weight: 600; color: #52f7ad;">âœ… Itens Dentro do PadrÃ£o</h3>
        <p style="margin: 0; font-size: 10px; color: #9ca3af; line-height: 1.5;">${okItemsAll.map(i => i.label).join(' â€¢ ')}</p>
    </div>
    ` : ''}
    
    <!-- RodapÃ© PÃ¡gina 2 -->
    <div style="position: absolute; bottom: 25px; left: 40px; right: 40px; text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 11px; color: #8B5CF6; font-weight: 600;">SoundyAI Â© 2025</p>
        <p style="margin: 3px 0 0 0; font-size: 9px; color: #6b7280;">InteligÃªncia Artificial para Produtores Musicais | soundy.ai</p>
    </div>
    
</div>
        `;
        
        // ğŸ¯ RENDERIZAR E CAPTURAR PÃGINAS SEPARADAMENTE
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template nÃ£o encontrado');
        }
        
        // FunÃ§Ã£o helper para capturar uma pÃ¡gina
        async function capturePage(html, pageName) {
            container.innerHTML = html;
            const elemento = container.firstElementChild;
            
            // ForÃ§ar visibilidade temporÃ¡ria
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.style.zIndex = '-1';
            
            await new Promise(r => setTimeout(r, 300));
            
            log(`[REF-PDF] ğŸ“¸ Capturando ${pageName}...`);
            
            // Capturar com html2canvas
            const canvas = await html2canvas(elemento, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                backgroundColor: '#0a0f1a',
                useCORS: true,
                scale: 2
            });
            
            log(`[REF-PDF] âœ… ${pageName} capturada:`, canvas.width, 'x', canvas.height);
            
            return canvas;
        }
        
        // Capturar PÃ¡gina 1
        const canvas1 = await capturePage(page1HTML, 'PÃ¡gina 1');
        
        // Capturar PÃ¡gina 2
        const canvas2 = await capturePage(page2HTML, 'PÃ¡gina 2');
        
        // Gerar PDF com 2 pÃ¡ginas
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        // Adicionar PÃ¡gina 1
        const imgData1 = canvas1.toDataURL('image/png');
        pdf.addImage(imgData1, 'PNG', 0, 0, pageWidth, pageHeight);
        
        // Adicionar PÃ¡gina 2
        pdf.addPage();
        const imgData2 = canvas2.toDataURL('image/png');
        pdf.addImage(imgData2, 'PNG', 0, 0, pageWidth, pageHeight);
        
        // Sanitizar nomes para o arquivo
        const sanitize = (str) => (str || 'faixa').replace(/[^a-z0-9]/gi, '_').substring(0, 30);
        const fileName = `SoundyAI_Referencia_${sanitize(trackAName)}_vs_${sanitize(trackBName)}.pdf`;
        
        pdf.save(fileName);
        
        // Limpar container
        container.style.display = 'none';
        container.innerHTML = '';
        
        log('[REF-PDF] âœ… RelatÃ³rio Premium gerado (2 pÃ¡ginas):', fileName);
        log('[REF-PDF] ğŸ“Š EstatÃ­sticas:', {
            totalItems: allItems.length,
            criticas: criticalItems.length,
            altas: highItems.length,
            atenÃ§Ã£o: warningItems.length,
            ok: okItemsAll.length,
            score: score
        });
        
        showTemporaryFeedback('âœ… RelatÃ³rio Premium (2 pÃ¡ginas) baixado!');
        
    } catch (error) {
        error('[REF-PDF] âŒ Erro ao gerar relatÃ³rio:', error);
        showTemporaryFeedback('âŒ Erro ao gerar PDF');
        alert(`Erro ao gerar relatÃ³rio:\n\n${error.message}`);
    }
}

// ï¿½ Mostrar feedback temporÃ¡rio
// (definiÃ§Ã£o duplicada de showTemporaryFeedback removida â€” mantida a versÃ£o consolidada abaixo)

// ğŸ“„ Baixar relatÃ³rio do modal (IMPLEMENTAÃ‡ÃƒO ROBUSTA COM VALIDAÃ‡ÃƒO)
async function downloadModalAnalysis() {
    // ğŸ”’ GUARD: Bloquear funcionalidade premium em modo reduced
    // âœ… Prioridade 1: Sistema centralizado de capabilities
    if (window.PlanCapabilities && window.PlanCapabilities.shouldBlockPdf()) {
        log('ğŸ”’ [PREMIUM-GUARD] Funcionalidade "Baixar RelatÃ³rio" bloqueada');
        log('ğŸ“Š [PREMIUM-GUARD] Contexto:', window.PlanCapabilities.getCurrentContext());
        
        // âœ… Abrir modal de upgrade (com classe visible para CSS)
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            log('âœ… [PREMIUM-GUARD] Modal de upgrade aberto (PDF)');
        } else {
            error('âŒ [PREMIUM-GUARD] Modal upgradeModal nÃ£o encontrado no DOM');
        }
        return; // âœ… BLOQUEIO: NÃ£o executa funÃ§Ã£o real
    }
    
    // âœ… Prioridade 2: Fallback para APP_MODE (compatibilidade)
    if (window.APP_MODE === 'reduced') {
        log('ğŸ”’ [PREMIUM-GUARD] Funcionalidade "Baixar RelatÃ³rio" bloqueada (fallback APP_MODE)');
        
        // âœ… Abrir modal de upgrade
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            log('âœ… [PREMIUM-GUARD] Modal de upgrade aberto (PDF - fallback)');
        } else {
            error('âŒ [PREMIUM-GUARD] Modal upgradeModal nÃ£o encontrado no DOM');
        }
        return; // âœ… BLOQUEIO: NÃ£o executa funÃ§Ã£o real
    }
    
    // ğŸ¯ FIX CRÃTICO: Verificar modo REFERENCE primeiro (antes de validar analysis)
    // No modo reference, os dados estÃ£o em SoundyAI_Store, nÃ£o em analysis
    const currentPdfMode = window.currentAnalysisMode || 'genre';
    if (currentPdfMode === 'reference') {
        log('[PDF-ROUTER] ğŸ”€ Modo referÃªncia detectado - redirecionando para generateReferenceReportPDF()');
        return generateReferenceReportPDF();
    }
    
    // 1ï¸âƒ£ VALIDAÃ‡ÃƒO: Verificar se anÃ¡lise estÃ¡ disponÃ­vel no alias global (sÃ³ para modo gÃªnero)
    const analysis = window.__soundyAI?.analysis || currentModalAnalysis;
    
    if (!analysis) {
        alert('âŒ Nenhuma anÃ¡lise disponÃ­vel.\n\nFaÃ§a uma anÃ¡lise antes de gerar o relatÃ³rio.');
        error('[PDF-ERROR] AnÃ¡lise nÃ£o encontrada em window.__soundyAI.analysis ou currentModalAnalysis');
        return;
    }
    
    // ğŸ” AUDITORIA: Mapear estrutura completa do objeto analysis
    log('ğŸ” [AUDIT-PDF] ============ INÃCIO DA AUDITORIA ============');
    log('ğŸ” [AUDIT-PDF] Analysis root keys:', Object.keys(analysis));
    log('ğŸ” [AUDIT-PDF] Fontes detectadas:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        userBands: analysis.user?.bands,
        diagnostics: analysis.diagnostics,
        problems: analysis.problems,
        _diagnostic: analysis._diagnostic,
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        score: analysis.score,
        userScore: analysis.user?.score
    });
    
    // ğŸ” AUDITORIA: Comparar com valores da UI (modal Paperline)
    log('ğŸ” [AUDIT-UI] Valores exibidos na UI:', {
        score: document.querySelector('.score-final-value')?.dataset?.value || document.querySelector('.score-final-value')?.textContent,
        bandSub: document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent,
        bandBass: document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent,
        bandMid: document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent,
        bandHigh: document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent
    });
    
    log('ğŸ“„ [PDF-START] Iniciando geraÃ§Ã£o de relatÃ³rio PDF...');
    log('ğŸ“„ [PDF-SOURCE] Fonte de dados:', {
        usingGlobalAlias: !!window.__soundyAI?.analysis,
        usingCurrentModal: !!currentModalAnalysis,
        fileName: analysis.fileName || analysis.metadata?.fileName,
        hasLoudness: !!(analysis.loudness || analysis.lufsIntegrated),
        hasTruePeak: !!(analysis.truePeak || analysis.truePeakDbtp)
    });
    
    // 2ï¸âƒ£ VALIDAÃ‡ÃƒO: Verificar dependÃªncias
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('âš™ï¸ Carregando bibliotecas...');
        warn('âš ï¸ [PDF-WAIT] Aguardando carregamento de jsPDF/html2canvas...');
        
        // Retry apÃ³s 1s
        setTimeout(() => downloadModalAnalysis(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('âš™ï¸ Gerando relatÃ³rio PDF...');
        
        // 3ï¸âƒ£ VALIDAÃ‡ÃƒO CONTRA UI: Comparar dados do relatÃ³rio com a UI
        validateAnalysisDataAgainstUI(analysis);
        
        // 4ï¸âƒ£ NORMALIZAR: Extrair e formatar dados
        const normalizedData = normalizeAnalysisDataForPDF(analysis);
        
        // 5ï¸âƒ£ GERAR HTML: Template profissional
        const reportHTML = generateReportHTML(normalizedData);
        
        // 6ï¸âƒ£ PREPARAR CONTAINER: Inserir e tornar visÃ­vel
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template nÃ£o encontrado no DOM');
        }
        
        container.innerHTML = reportHTML;
        const elemento = container.firstElementChild;
        if (!elemento) {
            throw new Error('Template HTML nÃ£o foi renderizado corretamente');
        }
        
        // Salvar estilos originais
        const originalStyles = {
            display: container.style.display,
            visibility: container.style.visibility,
            position: container.style.position,
            left: container.style.left,
            top: container.style.top,
            zIndex: container.style.zIndex
        };
        
        // âœ… PROPORÃ‡ÃƒO FIXA A4: 794x1123 px (resoluÃ§Ã£o base vertical)
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const A4_RATIO = A4_HEIGHT / A4_WIDTH; // 1.414 (proporÃ§Ã£o A4)
        
        // ForÃ§ar visibilidade temporÃ¡ria com proporÃ§Ã£o A4 fixa
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.position = 'fixed';
        container.style.left = '50%';
        container.style.top = '0';
        container.style.transform = 'translateX(-50%)'; // Centralizar horizontalmente
        container.style.zIndex = '9999';
        container.style.width = `${A4_WIDTH}px`; // Largura fixa A4
        container.style.height = 'auto';
        container.style.margin = '0 auto';
        
        log('ğŸ“Š [PDF-RENDER] Container preparado com proporÃ§Ã£o A4:', {
            baseWidth: A4_WIDTH,
            baseHeight: A4_HEIGHT,
            ratio: A4_RATIO,
            containerWidth: elemento.offsetWidth,
            containerHeight: elemento.offsetHeight,
            isVisible: elemento.offsetWidth > 0 && elemento.offsetHeight > 0
        });
        
        // 7ï¸âƒ£ AGUARDAR RENDERIZAÃ‡ÃƒO: 250ms base + scroll + 150ms
        await new Promise(r => setTimeout(r, 250));
        elemento.scrollIntoView({ behavior: 'instant', block: 'start' });
        await new Promise(r => setTimeout(r, 150));
        
        // âœ… 8ï¸âƒ£ CAPTURAR PÃGINAS SEPARADAMENTE com proporÃ§Ã£o fixa A4
        log('ğŸ“¸ [PDF-CAPTURE] Iniciando captura em 2 pÃ¡ginas lÃ³gicas com proporÃ§Ã£o A4 fixa...');
        
        // âœ… PROPORÃ‡ÃƒO FIXA: Sempre usar 794px (A4) com scale 2 (alta qualidade)
        // NÃƒO depende de viewport - garante consistÃªncia desktop/mobile
        const CAPTURE_WIDTH = A4_WIDTH; // 794px
        const CAPTURE_SCALE = 2; // Alta qualidade (1588px efetivos)
        const CAPTURE_BG = '#0a0a0f'; // Fundo escuro profissional
        
        log('ï¿½ [PDF-A4-FIXED]', {
            captureWidth: CAPTURE_WIDTH,
            captureScale: CAPTURE_SCALE,
            backgroundColor: CAPTURE_BG,
            effectiveWidth: CAPTURE_WIDTH * CAPTURE_SCALE,
            note: 'ProporÃ§Ã£o A4 fixa (nÃ£o depende de viewport)'
        });
        
        const section1 = elemento.querySelector('.pdf-section-metrics');
        const section2 = elemento.querySelector('.pdf-section-diagnostics');
        
        if (!section1 || !section2) {
            throw new Error('âŒ SeÃ§Ãµes PDF nÃ£o encontradas. Verifique as classes .pdf-section-metrics e .pdf-section-diagnostics');
        }
        
        log('ï¿½ [PDF-CAPTURE] Capturando PÃ¡gina 1 (MÃ©tricas)...');
        // âœ… FunÃ§Ã£o genÃ©rica e segura de captura A4 com wrapper virtual
        async function renderSectionToPDF(element, sectionName) {
            const wrapper = document.createElement('div');
            const isMobile = window.innerWidth < 768;
            wrapper.style.width = '794px';
            wrapper.style.height = '1123px';
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'flex-start';
            wrapper.style.justifyContent = 'center';
            wrapper.style.background = '#0a0a0f';
            wrapper.style.padding = '0';  // âœ… Zero padding no wrapper
            wrapper.style.position = 'fixed';
            wrapper.style.left = '-9999px';
            wrapper.style.top = '0';
            wrapper.style.zIndex = '-1';
            wrapper.style.overflow = 'hidden';
            
            // Clona o conteÃºdo e aplica padding no clone (nÃ£o no wrapper)
            const clone = element.cloneNode(true);
            clone.style.padding = isMobile ? '10px' : '20px';  // âœ… Padding no conteÃºdo
            clone.style.boxSizing = 'border-box';
            clone.style.width = '100%';
            clone.style.height = '100%';
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);
            
            // Aguarda renderizaÃ§Ã£o
            await new Promise(r => setTimeout(r, 150));
            
            log(`ğŸ“ [PDF-WRAPPER] ${sectionName}:`, {
                declared: { width: '794px', height: '1123px' },
                computed: {
                    offsetWidth: wrapper.offsetWidth,
                    offsetHeight: wrapper.offsetHeight,
                    clientWidth: wrapper.clientWidth,
                    clientHeight: wrapper.clientHeight
                },
                usableArea: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    lostHeight: 1123 - wrapper.clientHeight
                },
                padding: isMobile ? '10px (clone)' : '20px (clone)',
                note: 'Padding aplicado no clone, nÃ£o no wrapper'
            });
            
            // Captura com parÃ¢metros fixos A4
            const canvas = await html2canvas(wrapper, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: '#0a0a0f',
                useCORS: true,
                allowTaint: true,
                logging: false,
                scale: 2
            });
            
            document.body.removeChild(wrapper);
            
            const ratio = (canvas.height / canvas.width).toFixed(3);
            const expectedRatio = (1123 / 794).toFixed(3);
            log(`ğŸ–¼ï¸ [PDF-CANVAS] ${sectionName}:`, {
                canvasSize: { width: canvas.width, height: canvas.height },
                ratio,
                expectedRatio,
                match: ratio === expectedRatio ? 'âœ…' : 'âš ï¸'
            });
            
            return canvas;
        }
        
        const canvas1 = await renderSectionToPDF(section1, 'MÃ©tricas');
        
        const canvas2 = await renderSectionToPDF(section2, 'DiagnÃ³stico');
        
        log('âœ… [PDF-CANVAS] PÃ¡ginas capturadas:', {
            page1: { width: canvas1.width, height: canvas1.height },
            page2: { width: canvas2.width, height: canvas2.height }
        });
        
        if (canvas1.width === 0 || canvas1.height === 0 || canvas2.width === 0 || canvas2.height === 0) {
            throw new Error('Canvas vazio - verifique se as seÃ§Ãµes estÃ£o visÃ­veis');
        }
        
        // âœ… ValidaÃ§Ã£o final de proporÃ§Ã£o A4
        const ratio1 = (canvas1.height / canvas1.width).toFixed(3);
        const ratio2 = (canvas2.height / canvas2.width).toFixed(3);
        const expectedRatio = (1123 / 794).toFixed(3);
        
        log('[PDF] ProporÃ§Ã£o A4 preservada com sucesso (' + expectedRatio + ')');
        log('[PDF] Canvas1: ' + canvas1.width + 'x' + canvas1.height + ' | Canvas2: ' + canvas2.width + 'x' + canvas2.height);
        log('[PDF] ExportaÃ§Ã£o concluÃ­da sem achatamento âœ”ï¸');
        
        // âœ… 9ï¸âƒ£ GERAR PDF COM PROPORÃ‡ÃƒO A4 E MARGENS (centralizaÃ§Ã£o perfeita mobile)
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth(); // 210mm
        const pageHeight = pdf.internal.pageSize.getHeight(); // 297mm
        
        // âœ… Zero margens para ambos dispositivos (100% fill A4)
        const SIDE_MARGIN_MM = 0;
        const TOP_MARGIN_MM = 0;
        const BOTTOM_MARGIN_MM = 0;
        
        log('ï¿½ [PDF-A4-FORMAT]', {
            pageWidth,
            pageHeight,
            margins: 'ZERO (100% fill)',
            format: 'A4 Portrait (210x297mm)'
        });
        
        // âœ… FunÃ§Ã£o unificada: preencher 100% A4 (desktop e mobile)
        function addCanvasAsA4PageCentered(cnv, sectionName) {
            // ComeÃ§ar pela altura (preencher verticalmente)
            let imgHeight = pageHeight; // 297mm
            let imgWidth = (cnv.width * imgHeight) / cnv.height;
            
            // Se largura ultrapassar, reajustar por largura
            if (imgWidth > pageWidth) {
                imgWidth = pageWidth; // 210mm
                imgHeight = (cnv.height * imgWidth) / cnv.width;
            }
            
            // PosiÃ§Ã£o absoluta no canto (sem margens)
            const x = 0;
            const y = 0;
            
            const fillPercentage = ((imgHeight / pageHeight) * 100).toFixed(1);
            
            log(`ğŸ“„ [PDF-BUILD] ${sectionName}:`, {
                canvasSize: { width: cnv.width, height: cnv.height },
                pageSize: { width: pageWidth, height: pageHeight },
                imgWidth: imgWidth.toFixed(2),
                imgHeight: imgHeight.toFixed(2),
                position: { x, y },
                fillPercentage: `${fillPercentage}%`,
                margins: 'ZERO (100% fill)'
            });
            
            const imgData = cnv.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
        }
        
        // PÃ¡gina 1 (MÃ©tricas)
        addCanvasAsA4PageCentered(canvas1, 'PÃ¡gina 1 (MÃ©tricas)');
        
        // PÃ¡gina 2 (DiagnÃ³stico/RecomendaÃ§Ãµes)
        pdf.addPage();
        addCanvasAsA4PageCentered(canvas2, 'PÃ¡gina 2 (DiagnÃ³stico)');
        
        // ğŸ”Ÿ DOWNLOAD: Nome descritivo com data
        const cleanFileName = (normalizedData.fileName || 'audio')
            .replace(/\.[^/.]+$/, '')
            .replace(/[^a-z0-9_-]/gi, '_');
        const dateStr = new Date().toISOString().split('T')[0];
        const fileName = `Relatorio_SoundyAI_${cleanFileName}_${dateStr}.pdf`;
        
        pdf.save(fileName);
        
        log('âœ… [PDF-SUCCESS] RelatÃ³rio gerado:', fileName);
        showTemporaryFeedback('âœ… RelatÃ³rio PDF baixado com sucesso!');
        
        // RESTAURAR: Estilos originais
        Object.assign(container.style, originalStyles);
        
        // ğŸ”’ GUARD: NÃ£o limpar container se estiver em modo reference (apagaria tabela A/B!)
        const currentMode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
        if (currentMode !== 'reference') {
            setTimeout(() => container.innerHTML = '', 100);
            log('[PDF-CLEANUP] Container limpo (modo nÃ£o-reference)');
        } else {
            log('[PDF-CLEANUP] âš ï¸ Container PRESERVADO (modo reference ativo)');
        }
        
    } catch (error) {
        error('âŒ [PDF-ERROR] Erro ao gerar relatÃ³rio:', error);
        error('âŒ [PDF-ERROR] Stack:', error.stack);
        showTemporaryFeedback('âŒ Erro ao gerar PDF');
        alert(`Erro ao gerar relatÃ³rio PDF:\n\n${error.message}\n\nVerifique o console para mais detalhes.`);
    }
}


// ğŸ” VALIDAÃ‡ÃƒO: Comparar dados do relatÃ³rio com a UI
function validateAnalysisDataAgainstUI(analysis) {
    log('ğŸ” [PDF-VALIDATE] Iniciando validaÃ§Ã£o contra UI...');
    log('ğŸ§  [PDF-AUDIT] AnÃ¡lise Global:', analysis);
    
    const assertEqual = (label, pdfValue, uiSelector, tolerance = 0.01) => {
        const uiElement = document.querySelector(uiSelector);
        if (!uiElement) {
            warn(`âš ï¸ [PDF-VALIDATE] Elemento UI nÃ£o encontrado: ${uiSelector}`);
            return;
        }
        
        let uiValue = uiElement.dataset?.value || 
                     uiElement.getAttribute('data-value') ||
                     parseFloat(uiElement.textContent.replace(/[^0-9.-]/g, ''));
        
        if (isNaN(uiValue)) {
            warn(`âš ï¸ [PDF-VALIDATE] Valor UI nÃ£o numÃ©rico em ${uiSelector}`);
            return;
        }
        
        if (pdfValue == null || isNaN(pdfValue)) {
            warn(`âš ï¸ [PDF-VALIDATE] Valor PDF ausente para ${label}`);
            return;
        }
        
        const diff = Math.abs(Number(pdfValue) - Number(uiValue));
        const ok = diff < tolerance;
        
        if (!ok) {
            warn(`ğŸš¨ [PDF-VALIDATE] DIVERGÃŠNCIA em ${label}:`, {
                pdf: pdfValue,
                ui: uiValue,
                diferenca: diff.toFixed(3)
            });
        } else {
            log(`âœ… [PDF-VALIDATE] ${label}: OK (diff=${diff.toFixed(4)})`);
        }
    };
    
    try {
        const lufsValue = analysis.lufsIntegrated || analysis.loudness?.integrated || analysis.technicalData?.lufsIntegrated;
        if (lufsValue) assertEqual('LUFS Integrado', lufsValue, '[data-metric="lufs-integrated"]', 0.1);
        
        const truePeakValue = analysis.truePeakDbtp || analysis.truePeak?.maxDbtp || analysis.technicalData?.truePeakDbtp;
        if (truePeakValue) assertEqual('True Peak', truePeakValue, '[data-metric="true-peak"]', 0.1);
        
        const drValue = analysis.dynamicRange || analysis.dynamics?.range || analysis.technicalData?.dynamicRange;
        if (drValue) assertEqual('Dynamic Range', drValue, '[data-metric="dynamic-range"]', 0.5);
        
        // ğŸ¯ VALIDAÃ‡ÃƒO CRÃTICA DE SCORE: Comparar TODAS as fontes
        log('ğŸ¯ [PDF-VALIDATE-SCORE] ============ VALIDAÃ‡ÃƒO CRÃTICA DE SCORE ============');
        log('ğŸ¯ [PDF-VALIDATE-SCORE] Fontes disponÃ­veis no objeto analysis:', {
            'analysis.score': analysis.score,
            'analysis.scores.final': analysis.scores?.final,
            'analysis.scoring.final': analysis.scoring?.final,
            'analysis.user.score': analysis.user?.score
        });
        
        // Extrair score da UI
        const uiScoreElement = document.querySelector('.score-final-value');
        let scoreUI = null;
        if (uiScoreElement) {
            const rawValue = uiScoreElement.dataset?.value || uiScoreElement.textContent || '';
            scoreUI = parseFloat(rawValue.replace(/[^0-9.-]/g, ''));
            if (isNaN(scoreUI)) scoreUI = null;
        }
        
        log('ğŸ¯ [PDF-VALIDATE-SCORE] Score na UI:', scoreUI);
        
        // Validar se todas as fontes estÃ£o alinhadas
        const scoreSources = [
            { name: 'analysis.score', value: analysis.score },
            { name: 'analysis.scores.final', value: analysis.scores?.final },
            { name: 'analysis.scoring.final', value: analysis.scoring?.final },
            { name: 'UI (.score-final-value)', value: scoreUI }
        ];
        
        const validScores = scoreSources.filter(s => Number.isFinite(s.value) && s.value >= 0 && s.value <= 100);
        
        if (validScores.length === 0) {
            error('âŒ [PDF-VALIDATE-SCORE] NENHUM score vÃ¡lido encontrado!');
        } else if (validScores.length === 1) {
            log('âœ… [PDF-VALIDATE-SCORE] Apenas 1 fonte de score disponÃ­vel:', validScores[0].name, '=', validScores[0].value);
        } else {
            // Verificar divergÃªncias entre fontes
            const scoreValues = validScores.map(s => Math.round(s.value));
            const uniqueScores = [...new Set(scoreValues)];
            
            if (uniqueScores.length === 1) {
                log('âœ… [PDF-VALIDATE-SCORE] TODAS as fontes estÃ£o SINCRONIZADAS:', uniqueScores[0]);
                validScores.forEach(s => {
                    log(`  âœ… ${s.name}: ${s.value}`);
                });
            } else {
                error('ğŸš¨ [PDF-VALIDATE-SCORE] DIVERGÃŠNCIA DETECTADA ENTRE FONTES:');
                validScores.forEach(s => {
                    error(`  âš ï¸ ${s.name}: ${s.value}`);
                });
                error('ğŸš¨ [PDF-VALIDATE-SCORE] Scores Ãºnicos encontrados:', uniqueScores);
                error('ğŸš¨ [PDF-VALIDATE-SCORE] ATENÃ‡ÃƒO: Esta divergÃªncia pode causar relatÃ³rios incorretos!');
            }
        }
        
        log('ğŸ¯ [PDF-VALIDATE-SCORE] ============ FIM DA VALIDAÃ‡ÃƒO ============');
        
        log('âœ… [PDF-VALIDATE] ValidaÃ§Ã£o concluÃ­da');
    } catch (error) {
        error('âŒ [PDF-VALIDATE] Erro na validaÃ§Ã£o:', error);
    }
}

// ğŸ¯ Normalizar dados da anÃ¡lise para formato compatÃ­vel com PDF (NOVA VERSÃƒO ROBUSTA)
function normalizeAnalysisDataForPDF(analysis) {
    log('ğŸ“Š [PDF-NORMALIZE] ============ INÃCIO DA NORMALIZAÃ‡ÃƒO ============');
    log('ğŸ“Š [PDF-NORMALIZE] Estrutura recebida:', {
        keys: Object.keys(analysis),
        fileName: analysis.fileName || analysis.metadata?.fileName,
        score: analysis.score,
        hasLufsRoot: !!analysis.lufsIntegrated,
        hasTruePeakRoot: !!analysis.truePeakDbtp,
        hasDRRoot: !!analysis.dynamicRange,
        hasBands: !!(analysis.bands || analysis.spectralBands)
    });
    
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'â€”';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    const extract = (...paths) => {
        for (const path of paths) {
            if (typeof path === 'function') {
                const val = path();
                if (Number.isFinite(val)) return val;
            } else if (Number.isFinite(path)) {
                return path;
            }
        }
        return null;
    };
    
    const lufsIntegrated = extract(analysis.lufsIntegrated, analysis.loudness?.integrated, analysis.technicalData?.lufsIntegrated);
    const lufsShortTerm = extract(analysis.avgLoudness, analysis.loudness?.shortTerm, analysis.technicalData?.avgLoudness);
    const lufsMomentary = extract(lufsShortTerm, analysis.loudness?.momentary);
    const lra = extract(analysis.lra, analysis.loudness?.lra, analysis.technicalData?.lra);
    
    log('ğŸ§ [PDF-NORMALIZE] Loudness extraÃ­do:', { integrated: lufsIntegrated, shortTerm: lufsShortTerm, momentary: lufsMomentary, lra });
    
    const truePeakDbtp = extract(analysis.truePeakDbtp, analysis.truePeak?.maxDbtp, analysis.technicalData?.truePeakDbtp);
    const clippingSamples = extract(analysis.truePeak?.clipping?.samples, analysis.clipping?.samples, 0);
    const clippingPercentage = extract(analysis.truePeak?.clipping?.percentage, analysis.clipping?.percentage, 0);
    
    log('âš™ï¸ [PDF-NORMALIZE] True Peak extraÃ­do:', { maxDbtp: truePeakDbtp, clipping: { samples: clippingSamples, percentage: clippingPercentage }});
    
    const dynamicRange = extract(analysis.dynamicRange, analysis.dynamics?.range, analysis.technicalData?.dynamicRange);
    const crestFactor = extract(analysis.crestFactor, analysis.dynamics?.crest, analysis.technicalData?.crestFactor);
    
    log('ğŸšï¸ [PDF-NORMALIZE] DinÃ¢mica extraÃ­da:', { range: dynamicRange, crest: crestFactor });
    
    const stereoWidth = extract(analysis.stereo?.width, analysis.stereoWidth, analysis.technicalData?.stereoWidth);
    const stereoCorrelation = extract(analysis.stereoCorrelation, analysis.stereo?.correlation, analysis.technicalData?.stereoCorrelation);
    const monoCompatibility = extract(analysis.stereo?.monoCompatibility, analysis.monoCompatibility);
    
    log('ğŸ›ï¸ [PDF-NORMALIZE] Stereo extraÃ­do:', { width: stereoWidth, correlation: stereoCorrelation, monoCompatibility });
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de bandas espectrais
    log('ğŸ“ˆ [AUDIT-FREQ] Bandas disponÃ­veis em analysis:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        spectralBands_nested: analysis.spectral?.bands,
        userBands: analysis.user?.bands,
        userSpectralBands: analysis.user?.spectralBands,
        userSpectral: analysis.user?.spectral
    });
    
    // âœ… FREQUÃŠNCIAS â€” corrigindo campos energy_db, percentage e range
    const bandsSrc = analysis.bands || analysis.spectralBands || analysis.spectral?.bands || {};
    const extractBand = (band) => {
      if (!band) return { db: 'â€”', pct: 'â€”', range: '' };
      if (typeof band === 'number') return { db: band.toFixed(1), pct: 'â€”', range: '' };
      const db = band.energy_db ?? band.rms_db ?? band.value ?? null;
      const pct = band.percentage ?? band.percent ?? null;
      const range = band.range ?? '';
      return {
        db: db !== null ? db.toFixed(1) : 'â€”',
        pct: pct !== null ? pct.toFixed(1) + '%' : 'â€”',
        range
      };
    };

    // Formata todas as bandas principais
    const spectral = {
      sub:  extractBand(bandsSrc.sub),
      bass: extractBand(bandsSrc.bass),
      lowMid: extractBand(bandsSrc.lowMid),
      mid:  extractBand(bandsSrc.mid),
      highMid: extractBand(bandsSrc.highMid),
      presence: extractBand(bandsSrc.presence),
      air: extractBand(bandsSrc.air)
    };

    log('ï¿½ [PDF-FIX] Bandas espectrais resolvidas:', spectral);
    
    // âœ… SCORE SINCRONIZADO COM A UI
    let score = analysis.scoring?.final 
             ?? analysis.user?.score 
             ?? analysis.scores?.final 
             ?? analysis.score 
             ?? 0;

    const uiScoreEl = document.querySelector('.score-final-value');
    if (uiScoreEl) {
      const scoreUI = parseFloat(uiScoreEl.dataset?.value || uiScoreEl.textContent || '0');
      if (!isNaN(scoreUI) && scoreUI > 0 && Math.abs(score - scoreUI) > 1) {
        warn('âš™ï¸ [PDF-FIX] Score ajustado com base na UI:', { old: score, new: scoreUI });
        score = scoreUI;
      }
    } else {
      warn('âš ï¸ [PDF-FIX] Elemento de score na UI nÃ£o encontrado, mantendo score:', score);
    }
    
    score = Math.round(score);
    const classification = analysis.classification || analysis.scoring?.classification || getClassificationFromScore(score);
    const fileName = analysis.fileName || analysis.metadata?.fileName || analysis.fileKey?.split('/').pop() || 'audio_sem_nome.wav';
    const duration = extract(analysis.duration, analysis.metadata?.duration, 0);
    const sampleRate = extract(analysis.sampleRate, analysis.metadata?.sampleRate, 44100);
    const channels = extract(analysis.channels, analysis.metadata?.channels, 2);
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de diagnÃ³sticos
    log('ğŸ©º [AUDIT-DIAG] DiagnÃ³stico disponÃ­vel em analysis:', {
        problems: analysis.problems,
        diagnostics: analysis.diagnostics,
        _diagnostic: analysis._diagnostic,
        userProblems: analysis.user?.problems,
        userDiagnostics: analysis.user?.diagnostics,
        problemsType: Array.isArray(analysis.problems) ? 'array' : typeof analysis.problems,
        diagnosticsType: Array.isArray(analysis.diagnostics) ? 'array' : typeof analysis.diagnostics
    });
    
    // âœ… DIAGNÃ“STICO AUTOMÃTICO
    let diagnostics = [];

    if (analysis.diagnostics?.problems?.length > 0) {
      diagnostics = analysis.diagnostics.problems.map(p => p.message || p);
    } 
    else if (analysis.diagnostics?.suggestions?.length > 0) {
      diagnostics = analysis.diagnostics.suggestions.map(s => 
        `âš ï¸ ${s.message || s.type || 'SugestÃ£o'} â€” ${s.why || s.action || ''}`
      );
    } 
    else {
      diagnostics = ['âœ… Nenhum problema detectado'];
    }

    log('ğŸ©º [PDF-FIX] DiagnÃ³stico enriquecido:', diagnostics);
    
    // ğŸ” AUDITORIA: Mapear todas as fontes possÃ­veis de sugestÃµes
    log('ğŸ’¡ [AUDIT-SUG] SugestÃµes detectadas em analysis:', {
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        recommendations: analysis.recommendations,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        userSuggestions: analysis.user?.suggestions,
        userSuggestionsAdvanced: analysis.user?.suggestionsAdvanced,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        suggestionsType: Array.isArray(analysis.suggestions) ? `array[${analysis.suggestions?.length}]` : typeof analysis.suggestions,
        advancedType: Array.isArray(analysis.suggestionsAdvanced) ? `array[${analysis.suggestionsAdvanced?.length}]` : typeof analysis.suggestionsAdvanced
    });
    
    // âœ… SUGESTÃ•ES ENRIQUECIDAS
    let suggestions = [];

    if (analysis.diagnostics?.suggestions?.length > 0) {
      suggestions = analysis.diagnostics.suggestions.map(s => {
        const title = s.message || s.type || 'Ajuste recomendado';
        const action = s.action ? ` â†’ ${s.action}` : '';
        const why = s.why ? ` (${s.why})` : '';
        return `${title}${action}${why}`;
      });
    } else if (Array.isArray(analysis.suggestions)) {
      suggestions = analysis.suggestions.map(s => 
        typeof s === 'string' ? s : s.message || s.type || 'SugestÃ£o'
      );
    }

    log('ğŸ’¡ [PDF-FIX] SugestÃµes enriquecidas:', suggestions);
    
    // Normalizar para 'recommendations' (compatibilidade com retorno)
    const recommendations = suggestions.length > 0 ? suggestions : ['âœ… AnÃ¡lise completa'];
    
    const normalizedResult = {
        score,
        classification,
        fileName,
        duration,
        sampleRate,
        channels,
        bitDepth: analysis.bitDepth || analysis.metadata?.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(lufsIntegrated, 1),
            shortTerm: formatValue(lufsShortTerm, 1),
            momentary: formatValue(lufsMomentary, 1),
            lra: formatValue(lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeakDbtp, 2),
            clipping: { samples: clippingSamples || 0, percentage: formatValue(clippingPercentage, 2) }
        },
        dynamics: {
            range: formatValue(dynamicRange, 1),
            crest: formatValue(crestFactor, 1)
        },
        spectral: spectral,
        stereo: {
            width: formatValue(stereoWidth * 100, 1),
            correlation: formatValue(stereoCorrelation, 2),
            monoCompatibility: formatValue(monoCompatibility * 100, 1)
        },
        diagnostics: diagnostics.length > 0 ? diagnostics : ['âœ… Nenhum problema detectado'],
        recommendations: recommendations.length > 0 ? recommendations : ['âœ… AnÃ¡lise completa']
    };
    
    // ğŸ” AUDITORIA: Resumo final comparativo
    log('ğŸ“Š [AUDIT-PDF-SUMMARY] Resumo da Auditoria:', {
        hasFrequencies: !!(spectral.sub !== 'â€”' || spectral.bass !== 'â€”' || spectral.mid !== 'â€”' || spectral.high !== 'â€”'),
        frequenciesValues: spectral,
        hasDiagnostics: diagnostics.length > 0 && diagnostics[0] !== 'âœ… Nenhum problema detectado',
        diagnosticsCount: diagnostics.length,
        hasSuggestions: recommendations.length > 0 && recommendations[0] !== 'âœ… AnÃ¡lise completa',
        suggestionsCount: recommendations.length,
        suggestionsEnriched: analysis._suggestionsGenerated === true,
        score: score,
        scoreSource: analysis.score ? 'analysis.score' : (analysis.user?.score ? 'analysis.user.score' : 'scoreUI')
    });
    
    // ğŸ” AUDITORIA: Comparar dados normalizados com valores da UI
    const uiSub = document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiBass = document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiMid = document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiHigh = document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent?.replace(/[^0-9.-]/g, '');
    
    log('ğŸš [AUDIT-FREQ-COMPARE] ComparaÃ§Ã£o UI vs PDF:', {
        sub: { ui: uiSub, pdf: spectral.sub, match: parseFloat(uiSub) === parseFloat(spectral.sub) },
        bass: { ui: uiBass, pdf: spectral.bass, match: parseFloat(uiBass) === parseFloat(spectral.bass) },
        mid: { ui: uiMid, pdf: spectral.mid, match: parseFloat(uiMid) === parseFloat(spectral.mid) },
        high: { ui: uiHigh, pdf: spectral.high, match: parseFloat(uiHigh) === parseFloat(spectral.high) }
    });
    
    log('âœ… [PDF-NORMALIZE] Resultado normalizado:', normalizedResult);
    log('ğŸ“Š [PDF-NORMALIZE] ============ FIM DA NORMALIZAÃ‡ÃƒO ============');
    
    return normalizedResult;
}

// ï¿½ Normalizar dados da anÃ¡lise para formato compatÃ­vel com PDF
function normalizeAnalysisData(analysis) {
    // ğŸ” DIAGNÃ“STICO: Log completo da estrutura recebida
    log('ğŸ“Š [PDF-NORMALIZE] ============ INÃCIO DA NORMALIZAÃ‡ÃƒO ============');
    log('ğŸ“Š [PDF-NORMALIZE] AnÃ¡lise completa recebida:', analysis);
    log('ğŸ“Š [PDF-NORMALIZE] Chaves disponÃ­veis:', Object.keys(analysis));
    
    // ğŸ”§ CORREÃ‡ÃƒO: Dados podem estar na raiz, em metrics, ou em tech
    const metrics = analysis.metrics || {};
    const tech = analysis.tech || analysis.technicalData || {};
    
    log('ğŸ” [PDF-NORMALIZE] Origem dos dados:', {
        hasMetrics: !!analysis.metrics,
        hasTech: !!analysis.tech,
        hasTechnicalData: !!analysis.technicalData,
        hasRootData: !!(analysis.loudness || analysis.truePeak || analysis.lufsIntegrated),
        metricsKeys: Object.keys(metrics),
        techKeys: Object.keys(tech)
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Loudness pode estar em mÃºltiplos lugares
    const loudness = metrics.loudness || tech.loudness || analysis.loudness || {
        // Fallback para propriedades na raiz
        integrated: analysis.lufsIntegrated,
        shortTerm: analysis.avgLoudness,
        momentary: analysis.avgLoudness,
        lra: analysis.lra
    };
    log('ğŸ§ [PDF-NORMALIZE] Loudness extraÃ­do:', {
        source: metrics.loudness ? 'metrics' : (tech.loudness ? 'tech' : (analysis.loudness ? 'analysis.loudness' : 'raiz')),
        data: loudness,
        integrated: loudness.integrated,
        shortTerm: loudness.shortTerm,
        momentary: loudness.momentary,
        lra: loudness.lra
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: True Peak pode estar em mÃºltiplos lugares
    const truePeak = metrics.truePeak || tech.truePeak || analysis.truePeak || {
        // Fallback para propriedades na raiz
        maxDbtp: analysis.truePeakDbtp,
        clipping: { samples: 0, percentage: 0 }
    };
    log('âš™ï¸ [PDF-NORMALIZE] True Peak extraÃ­do:', {
        source: metrics.truePeak ? 'metrics' : (tech.truePeak ? 'tech' : (analysis.truePeak ? 'analysis.truePeak' : 'raiz')),
        data: truePeak,
        maxDbtp: truePeak.maxDbtp,
        clipping: truePeak.clipping
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: DinÃ¢mica pode estar em mÃºltiplos lugares
    const dynamics = metrics.dynamics || tech.dynamics || analysis.dynamics || {
        // Fallback para propriedades na raiz
        range: analysis.dynamicRange,
        crest: analysis.crestFactor
    };
    log('ğŸšï¸ [PDF-NORMALIZE] Dynamics extraÃ­do:', {
        source: metrics.dynamics ? 'metrics' : (tech.dynamics ? 'tech' : (analysis.dynamics ? 'analysis.dynamics' : 'raiz')),
        data: dynamics,
        range: dynamics.range,
        crest: dynamics.crest
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Espectro pode estar em mÃºltiplos lugares
    const spectral = metrics.spectral || tech.spectral || analysis.spectral || {};
    const bands = spectral.bands || analysis.spectralBands || analysis.bands || {};
    log('ğŸ“ˆ [PDF-NORMALIZE] Spectral extraÃ­do:', {
        source: metrics.spectral ? 'metrics' : (tech.spectral ? 'tech' : (analysis.spectral ? 'analysis.spectral' : (analysis.bands ? 'analysis.bands' : 'vazio'))),
        spectral: spectral,
        bands: bands,
        bandsKeys: Object.keys(bands)
    });
    
    // ğŸ”§ CORREÃ‡ÃƒO: Stereo pode estar em mÃºltiplos lugares
    const stereo = metrics.stereo || tech.stereo || analysis.stereo || {};
    log('ğŸ›ï¸ [PDF-NORMALIZE] Stereo extraÃ­do:', {
        source: metrics.stereo ? 'metrics' : (tech.stereo ? 'tech' : (analysis.stereo ? 'analysis.stereo' : 'vazio')),
        data: stereo,
        width: stereo.width,
        correlation: stereo.correlation,
        monoCompatibility: stereo.monoCompatibility
    });
    
    // Score e classificaÃ§Ã£o
    const score = analysis.qualityOverall || analysis.score || 0;
    const classification = analysis.classification || getClassificationFromScore(score);
    
    // DiagnÃ³sticos e recomendaÃ§Ãµes
    const problems = analysis.problems || [];
    const suggestions = analysis.suggestions || [];
    const diagnostics = problems.length > 0 
        ? problems.map(p => p.message || p) 
        : ['âœ… Nenhum problema crÃ­tico detectado'];
    const recommendations = suggestions.length > 0 
        ? suggestions.map(s => s.message || s.action || s) 
        : ['âœ… AnÃ¡lise completa realizada com sucesso'];
    
    // FormataÃ§Ã£o segura de valores
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'N/A';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    // Log do resultado final normalizado
    const normalizedResult = {
        score: Math.round(score),
        classification,
        fileName: analysis.fileName || 'audio_sem_nome.wav',
        duration: analysis.duration || 0,
        sampleRate: analysis.sampleRate || 44100,
        channels: analysis.channels || 2,
        bitDepth: analysis.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(loudness.integrated, 1),
            shortTerm: formatValue(loudness.shortTerm, 1),
            momentary: formatValue(loudness.momentary, 1),
            lra: formatValue(loudness.lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeak.maxDbtp, 2),
            clipping: {
                samples: truePeak.clipping?.samples || 0,
                percentage: formatValue(truePeak.clipping?.percentage, 2)
            }
        },
        dynamics: {
            range: formatValue(dynamics.range, 1),
            crest: formatValue(dynamics.crest, 1)
        },
        spectral: {
            sub: formatValue(bands.sub || bands.subBass, 1),
            bass: formatValue(bands.bass, 1),
            mid: formatValue(bands.mid || bands.midrange, 1),
            high: formatValue(bands.presence || bands.high || bands.treble, 1)
        },
        stereo: {
            width: formatValue(stereo.width, 1),
            correlation: formatValue(stereo.correlation, 2),
            monoCompatibility: formatValue(stereo.monoCompatibility, 1)
        },
        diagnostics,
        recommendations
    };
    
    log('âœ… [PDF-NORMALIZE] Resultado final normalizado:', normalizedResult);
    log('ğŸ“Š [PDF-NORMALIZE] ============ FIM DA NORMALIZAÃ‡ÃƒO ============');
    
    return normalizedResult;
}

// ğŸ† ClassificaÃ§Ã£o baseada em score
function getClassificationFromScore(score) {
    // ğŸ¯ USAR EXATAMENTE OS MESMOS TEXTOS DO MODAL DA PÃGINA PRINCIPAL
    // (renderFinalScoreAtTop - linha 19055)
    if (score >= 90) {
        return 'âœ¨ Excelente! Pronto para lanÃ§amento';
    }
    if (score >= 75) {
        return 'âœ… Ã“timo! Qualidade profissional';
    }
    if (score >= 60) {
        return 'âš ï¸ Bom, mas pode melhorar';
    }
    if (score >= 40) {
        return 'ğŸ”§ Precisa de ajustes';
    }
    return 'ğŸš¨ Necessita correÃ§Ãµes importantes';
}

// ğŸ¨ Gerar HTML profissional do relatÃ³rio para PDF
function generateReportHTML(data) {
    // ğŸ” AUDITORIA: Verificar dados recebidos para geraÃ§Ã£o do HTML
    log('ğŸ“ [AUDIT-HTML] ============ INÃCIO DA GERAÃ‡ÃƒO DO HTML ============');
    log('ğŸ“ [AUDIT-HTML] Dados recebidos:', {
        score: data.score,
        classification: data.classification,
        spectral: data.spectral,
        diagnostics: data.diagnostics,
        recommendations: data.recommendations,
        hasSpectralData: !!(data.spectral && (data.spectral.sub !== 'â€”' || data.spectral.bass !== 'â€”')),
        hasDiagnostics: data.diagnostics?.length > 0,
        hasRecommendations: data.recommendations?.length > 0
    });
    
    const date = new Date().toLocaleDateString('pt-BR');
    const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    
    // Formatar duraÃ§Ã£o
    const minutes = Math.floor(data.duration / 60);
    const seconds = Math.floor(data.duration % 60);
    const durationStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
    
    return `
<div id="report-pdf-container" style="background: #0B0C14;">
    
    <!-- Estilos para otimizaÃ§Ã£o desktop do PDF -->
    <style>
        /* Ajustes apenas para desktop (viewport >= 768px) */
        @media (min-width: 768px) {
            .frequency-spectrum-container {
                margin-top: -10px !important;
                margin-bottom: 20px !important;
            }
            
            .frequency-spectrum-cards {
                transform: scale(0.95);
                transform-origin: top center;
                margin-bottom: -10px;
            }
            
            .freq-card {
                height: 75px !important;
                padding: 10px !important;
            }
            
            /* Ajustes de rodapÃ© e recomendaÃ§Ãµes (pÃ¡gina 2) */
            .pdf-section-diagnostics .pdf-footer {
                margin-top: 25px !important;
                padding-bottom: 10px;
                position: relative;
                bottom: 0;
            }
            
            .pdf-section-recommendations {
                transform: scale(0.97);
                transform-origin: top center;
            }
        }
        
        /* Mobile mantÃ©m estilos originais (< 768px) */
        @media (max-width: 767px) {
            .frequency-spectrum-container {
                margin-top: 0 !important;
            }
            
            .frequency-spectrum-cards {
                transform: none;
            }
            
            .freq-card {
                height: auto !important;
            }
        }
    </style>
    
    <!-- âœ… PÃGINA 1: MÃ‰TRICAS PRINCIPAIS -->
    <div class="pdf-section-metrics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 32px; font-weight: 700; letter-spacing: -0.5px;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: #AAA;">InteligÃªncia Artificial para Produtores Musicais</p>
            </div>
            <div style="text-align: right;">
                <h2 style="color: #8B5CF6; margin: 0; font-size: 24px; font-weight: 600;">RelatÃ³rio de AnÃ¡lise</h2>
                <p style="font-size: 12px; color: #AAA; margin: 5px 0 0 0;">${date} Ã s ${time}</p>
            </div>
        </div>

        <!-- Score Card -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); padding: 20px 30px; border-radius: 12px; color: white; margin-bottom: 30px; box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="margin: 0; font-size: 48px; font-weight: 700;">${data.score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h1>
                <p style="margin: 8px 0 0 0; font-size: 18px; opacity: 0.95; font-weight: 500;">SCORE FINAL</p>
            </div>
            <div style="font-size: 64px; opacity: 0.9;">ğŸµ</div>
        </div>
    </div>

    <!-- InformaÃ§Ãµes do Arquivo -->
    <div style="background: rgba(255,255,255,0.05); padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #8B5CF6;">
        <p style="margin: 0; font-size: 12px; color: #AAA; text-transform: uppercase; letter-spacing: 0.5px;">ARQUIVO ANALISADO</p>
        <p style="margin: 8px 0 0 0; font-size: 16px; font-weight: 600; color: #FFF;">${data.fileName}</p>
        <p style="margin: 5px 0 0 0; font-size: 13px; color: #999;">
            â±ï¸ ${durationStr} min &nbsp;|&nbsp; ğŸšï¸ ${data.sampleRate}Hz &nbsp;|&nbsp; ğŸ”Š ${data.channels === 2 ? 'Stereo' : data.channels + ' canais'}
        </p>
    </div>

    <!-- Grid de MÃ©tricas -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
        
        <!-- Loudness Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ§</span> Loudness
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Integrado:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.integrated} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Curto Prazo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.shortTerm} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">MomentÃ¢neo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.momentary} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">LRA:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.lra} LU</span>
                </div>
            </div>
        </div>

        <!-- True Peak Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">âš™ï¸</span> True Peak
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Pico Real:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.truePeak.maxDbtp} dBTP</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Clipping (samples):</span>
                    <span style="font-weight: 600; color: ${data.truePeak.clipping.samples > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.samples}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Clipping (%):</span>
                    <span style="font-weight: 600; color: ${parseFloat(data.truePeak.clipping.percentage) > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.percentage}%</span>
                </div>
            </div>
        </div>

        <!-- DinÃ¢mica Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸšï¸</span> DinÃ¢mica
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Dynamic Range:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.range} dB</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Crest Factor:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.crest}</span>
                </div>
            </div>
        </div>

        <!-- Stereo Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ›ï¸</span> Stereo
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Largura Stereo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.width}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">CorrelaÃ§Ã£o:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.correlation}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Compat. Mono:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.monoCompatibility}%</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Espectro de FrequÃªncias -->
    <div class="frequency-spectrum-container" style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid rgba(139, 92, 246, 0.2);">
        <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
            <span style="margin-right: 10px; font-size: 22px;">ğŸ“ˆ</span> Espectro de FrequÃªncias
        </h3>
        <div class="frequency-spectrum-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; font-size: 13px;">
            ${(() => {
                const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 768;
                const cardPadding = isDesktop ? '10px' : '12px';
                const fontSizeLarge = isDesktop ? '14px' : '18px';
                const marginTop = isDesktop ? '5px' : '8px';
                
                const renderBand = (label, band, range) => {
                    if (!band || !band.db) return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #AAA; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">â€”</p>
                        </div>
                    `;
                    return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #8B5CF6; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">${band.db} dB</p>
                        </div>
                    `;
                };
                
                return [
                    renderBand('SUB', data.spectral.sub, '20-60Hz'),
                    renderBand('GRAVE', data.spectral.bass, '60-150Hz'),
                    renderBand('LOW MID', data.spectral.lowMid, '150-500Hz'),
                    renderBand('MÃ‰DIO', data.spectral.mid, '500-2kHz'),
                    renderBand('HIGH MID', data.spectral.highMid, '2-5kHz'),
                    renderBand('PRESENCE', data.spectral.presence, '5-10kHz'),
                    renderBand('AR', data.spectral.air, '10-20kHz')
                ].join('');
            })()}
        </div>
    </div>

    <!-- RodapÃ© da PÃ¡gina 1 -->
    <div style="text-align: center; padding-top: 40px; margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">SoundyAI Â© 2025</p>
        <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">PÃ¡gina 1/2 | MÃ©tricas Principais</p>
    </div>

    </div>
    <!-- FIM DA PÃGINA 1 -->

    <!-- âœ… PÃGINA 2: DIAGNÃ“STICO E RECOMENDAÃ‡Ã•ES -->
    <div class="pdf-section-diagnostics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header Simplificado (PÃ¡gina 2) -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 28px; font-weight: 700;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 13px; color: #AAA;">DiagnÃ³stico e RecomendaÃ§Ãµes da IA</p>
            </div>
            <div style="text-align: right;">
                <p style="font-size: 14px; color: #AAA; margin: 0;">${data.fileName}</p>
                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">PÃ¡gina 2/2</p>
            </div>
        </div>

        <!-- DiagnÃ³stico -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ§ </span> DiagnÃ³stico AutomÃ¡tico
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.diagnostics.map(d => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">â€¢</span> ${d}
                </li>`).join('')}
            </ul>
        </div>

        <!-- RecomendaÃ§Ãµes -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 50px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">ğŸ’¡</span> RecomendaÃ§Ãµes da IA
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.recommendations.map(r => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">â€¢</span> ${r}
                </li>`).join('')}
            </ul>
        </div>

        <!-- RodapÃ© Final -->
        <div style="position: absolute; bottom: 30px; left: 40px; right: 40px; text-align: center; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">
                SoundyAI Â© 2025
            </p>
            <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">
                InteligÃªncia Artificial para Produtores Musicais | RelatÃ³rio gerado automaticamente
            </p>
        </div>

    </div>
    <!-- FIM DA PÃGINA 2 -->

</div>
    `;
}

// ï¿½ğŸ“‹ Gerar relatÃ³rio detalhado (LEGACY - mantido para compatibilidade)
function generateDetailedReport(analysis) {
    const now = new Date();
    let report = `ğŸµ PROD.AI - RELATÃ“RIO DE ANÃLISE DE ÃUDIO\n`;
    report += `${'='.repeat(50)}\n\n`;
    report += `ğŸ“… Data: ${now.toLocaleString('pt-BR')}\n`;
    report += `ğŸ”¬ AnÃ¡lise realizada com tecnologia Web Audio API\n\n`;
    
    report += `ğŸ“Š DADOS TÃ‰CNICOS PRINCIPAIS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `Peak Level: ${analysis.technicalData.peak.toFixed(2)} dB\n`;
    report += `RMS Level: ${analysis.technicalData.rms.toFixed(2)} dB\n`;
    report += `Dynamic Range: ${analysis.technicalData.dynamicRange.toFixed(2)} dB\n`;
    report += `Duration: ${analysis.duration.toFixed(2)} seconds\n`;
    report += `Sample Rate: ${analysis.sampleRate || 'N/A'} Hz\n`;
    report += `Channels: ${analysis.channels || 'N/A'}\n\n`;
    
    if (analysis.technicalData?.dominantFrequencies?.length > 0) {
        report += `ğŸ¯ FREQUÃŠNCIAS DOMINANTES:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.technicalData.dominantFrequencies.slice(0, 10).forEach((freq, i) => {
            report += `${i + 1}. ${Math.round(freq.frequency)} Hz (${freq.occurrences} ocorrÃªncias)\n`;
        });
        report += `\n`;
    }
    
    if (analysis.problems.length > 0) {
        report += `ğŸš¨ PROBLEMAS DETECTADOS:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.problems.forEach((problem, i) => {
            report += `${i + 1}. PROBLEMA: ${problem.message}\n`;
            report += `   SOLUÃ‡ÃƒO: ${problem.solution}\n`;
            report += `   SEVERIDADE: ${problem.severity}\n\n`;
        });
    }
    
    if (analysis.suggestions.length > 0) {
        report += `ğŸ’¡ SUGESTÃ•ES DE MELHORIA:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.suggestions.forEach((suggestion, i) => {
            report += `${i + 1}. ${suggestion.message}\n`;
            report += `   AÃ‡ÃƒO: ${suggestion.action}\n`;
            report += `   TIPO: ${suggestion.type}\n\n`;
        });
    }
    
    report += `ğŸ“ OBSERVAÃ‡Ã•ES TÃ‰CNICAS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `â€¢ Esta anÃ¡lise foi realizada usando Web Audio API\n`;
    report += `â€¢ Para anÃ¡lises mais avanÃ§adas, considere usar ferramentas profissionais\n`;
    report += `â€¢ Valores de referÃªncia: RMS ideal para streaming: -14 LUFS\n`;
    report += `â€¢ Peak ideal: mÃ¡ximo -1 dB para evitar clipping\n`;
    report += `â€¢ Dynamic range ideal: entre 8-15 dB para mÃºsica popular\n\n`;
    
    report += `ğŸµ Gerado por PROD.AI - Seu mentor de produÃ§Ã£o musical\n`;
    report += `ğŸ“± Para mais anÃ¡lises: prod-ai-teste.vercel.app\n`;
    
    return report;
}

// ğŸ’¬ Mostrar feedback temporÃ¡rio
function showTemporaryFeedback(message) {
    // Criar elemento de feedback
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #00d4ff, #0096cc);
        color: #000;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10001;
        animation: slideInRight 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    `;
    feedback.textContent = message;
    
    // Adicionar animaÃ§Ã£o CSS
    if (!document.getElementById('feedbackStyles')) {
        const style = document.createElement('style');
        style.id = 'feedbackStyles';
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(feedback);
    
    // Remover apÃ³s 3 segundos
    setTimeout(() => {
        feedback.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.parentNode.removeChild(feedback);
            }
        }, 300);
    }, 3000);
}

__dbg('ğŸµ Audio Analyzer Integration Script carregado!');

// Inicializar quando a pÃ¡gina carregar
document.addEventListener('DOMContentLoaded', function() {
    __dbg('ğŸµ DOM carregado, inicializando Audio Analyzer...');
    initializeAudioAnalyzerIntegration();
});

// Fallback: se o DOM jÃ¡ estiver carregado
if (document.readyState !== 'loading') {
    // se DOM jÃ¡ pronto, inicializar uma vez
    initializeAudioAnalyzerIntegration();
}

// UtilitÃ¡rio opcional: testar consistÃªncia das mÃ©tricas com reanÃ¡lises repetidas do mesmo arquivo
// Uso (dev): window.__testConsistency(file, 3).then(console.log)
if (typeof window !== 'undefined' && !window.__testConsistency) {
    window.__testConsistency = async function(file, runs = 3) {
        const out = { runs: [], deltas: {} };
        for (let i = 0; i < runs; i++) {
            const t0 = performance.now();
            // ğŸ†” CORREÃ‡ÃƒO: Adicionar runId para funÃ§Ãµes de teste de consistÃªncia
            const testOptions = prepareAnalysisOptions({}, `consistency_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, testOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufs: res?.technicalData?.lufsIntegrated ?? res?.metrics?.lufs ?? null,
                truePeakDbtp: res?.technicalData?.truePeakDbtp ?? res?.metrics?.truePeakDbtp ?? null,
                dr: res?.technicalData?.dynamicRange ?? res?.metrics?.dynamicRange ?? null,
                lra: res?.technicalData?.lra ?? null,
                processingMs: res?.processingMs ?? (t1 - t0)
            });
        }
        // calcular deltas
        const vals = (key) => out.runs.map(r => r[key]).filter(v => Number.isFinite(v));
        const stats = (arr) => arr.length ? { min: Math.min(...arr), max: Math.max(...arr), spread: Math.max(...arr)-Math.min(...arr) } : null;
        out.deltas.lufs = stats(vals('lufs'));
        out.deltas.truePeakDbtp = stats(vals('truePeakDbtp'));
        out.deltas.dr = stats(vals('dr'));
        out.deltas.lra = stats(vals('lra'));
        return out;
    };
}

// ğŸ¯ FINAL: Display Reference Results
window.displayReferenceResults = function(referenceResults) {
    window.logReferenceEvent('displaying_reference_results', {
        baseline_source: referenceResults.baseline_source,
        has_suggestions: referenceResults.referenceSuggestions?.length > 0
    });
    
    try {
        const { comparisonData, referenceSuggestions, baseline_source } = referenceResults;
        
        if (baseline_source !== 'reference') {
            throw new Error(`Invalid baseline source: ${baseline_source}. Expected 'reference'`);
        }
        
        if (!comparisonData) {
            throw new Error('Missing comparison data in reference results');
        }

        const results = document.getElementById('results');
        if (!results) {
            throw new Error('Results container not found');
        }

        // Exibir seÃ§Ã£o de comparaÃ§Ã£o
        displayComparisonSection(comparisonData, referenceSuggestions || []);
        
        // Se hÃ¡ sugestÃµes, exibir
        if (referenceSuggestions && referenceSuggestions.length > 0) {
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = referenceSuggestions.map(suggestion => 
                    `<div class="suggestion-item">
                        <h4>${suggestion.category}</h4>
                        <p>${suggestion.text}</p>
                        <div class="suggestion-details">
                            <small>DiferenÃ§a: ${suggestion.difference} | Threshold: ${suggestion.threshold}</small>
                        </div>
                    </div>`
                ).join('');
            }
        } else {
            // Audio idÃªntico - mostrar mensagem de sucesso
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = `
                    <div class="no-suggestions">
                        <h3>âœ… AnÃ¡lise de ReferÃªncia ConcluÃ­da</h3>
                        <p>Os Ã¡udios sÃ£o altamente similares. DiferenÃ§as dentro da tolerÃ¢ncia aceitÃ¡vel.</p>
                    </div>
                `;
            }
        }
        
        window.logReferenceEvent('reference_results_displayed_successfully');
        
    } catch (error) {
        error('Error displaying reference results:', error);
        window.logReferenceEvent('reference_display_error', { 
            error: error.message,
            baseline_source: referenceResults.baseline_source 
        });
        
        // Fallback display
        const results = document.getElementById('results');
        if (results) {
            // ğŸ›¡ï¸ PRESERVAR #referenceComparisons antes de limpar
            const refContainer = document.getElementById('referenceComparisons');
            const refHTML = refContainer ? refContainer.outerHTML : '';
            
            results.innerHTML = `
                <div class="error-display">
                    <h3>âŒ Erro na ExibiÃ§Ã£o dos Resultados</h3>
                    <p>Erro: ${error.message}</p>
                    <p>Baseline Source: ${referenceResults.baseline_source}</p>
                </div>
            `;
            
            // ğŸ›¡ï¸ RESTAURAR #referenceComparisons apÃ³s limpar
            if (refHTML) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = refHTML;
                results.appendChild(tempDiv.firstElementChild);
                log('[FALLBACK-ERROR] âœ… #referenceComparisons preservado durante erro');
            }
        }
    }
};

// =============== FUNÃ‡Ã•ES DE NORMALIZAÃ‡ÃƒO DE DADOS ===============

/**
 * ğŸ¯ GERADOR DE SUGESTÃ•ES BÃSICAS
 * Gera sugestÃµes baseadas nas mÃ©tricas tÃ©cnicas (fallback se backend nÃ£o enviar)
 * 
 * @param {Object} data - Dados normalizados da anÃ¡lise
 * @returns {Array} - Array de sugestÃµes estruturadas
 */
function generateBasicSuggestions(data) {
    const suggestions = [];
    const technicalData = data.technicalData || {};
    
    log('[SUG-AUDIT] ğŸ” generateBasicSuggestions INÃCIO:', {
        hasTechnicalData: !!technicalData,
        hasLufs: technicalData.lufsIntegrated != null,
        hasTruePeak: technicalData.truePeakDbtp != null,
        hasDR: technicalData.dynamicRange != null,
        hasLRA: technicalData.lra != null,
        hasBands: !!(technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands)
    });
    
    // Regra 1: LUFS Integrado
    if (technicalData.lufsIntegrated != null) {
        const lufs = technicalData.lufsIntegrated;
        const ideal = -10.5; // PadrÃ£o para streaming
        const delta = Math.abs(lufs - ideal);
        
        if (delta > 1.0) {
            suggestions.push({
                type: 'loudness',
                category: 'loudness',
                message: `LUFS Integrado estÃ¡ em ${lufs.toFixed(1)} dB quando deveria estar prÃ³ximo de ${ideal.toFixed(1)} dB`,
                action: delta > 3 ? `Ajustar loudness em ${(ideal - lufs).toFixed(1)} dB via limitador` : `Refinar loudness final`,
                priority: delta > 3 ? 'crÃ­tica' : 'alta',
                band: 'full_spectrum',
                delta: (ideal - lufs).toFixed(1)
            });
        }
    }
    
    // Regra 2: True Peak
    if (technicalData.truePeakDbtp != null) {
        const tp = technicalData.truePeakDbtp;
        if (tp > -1.0) {
            suggestions.push({
                type: 'clipping',
                category: 'mastering',
                message: `True Peak em ${tp.toFixed(2)} dBTP estÃ¡ acima do limite seguro de -1.0 dBTP (risco de clipping em conversÃ£o)`,
                action: `Aplicar limitador com ceiling em -1.0 dBTP ou reduzir gain em ${(tp + 1.0).toFixed(2)} dB`,
                priority: 'crÃ­tica',
                band: 'full_spectrum',
                delta: (tp + 1.0).toFixed(2)
            });
        }
    }
    
    // Regra 3: Dynamic Range
    if (technicalData.dynamicRange != null) {
        const dr = technicalData.dynamicRange;
        const minDR = 6.0;
        
        if (dr < minDR) {
            suggestions.push({
                type: 'dynamics',
                category: 'mastering',
                message: `Dynamic Range estÃ¡ em ${dr.toFixed(1)} dB quando deveria estar acima de ${minDR.toFixed(1)} dB (mix muito comprimido)`,
                action: `Reduzir compressÃ£o/limitaÃ§Ã£o para recuperar ${(minDR - dr).toFixed(1)} dB de dinÃ¢mica`,
                priority: 'alta',
                band: 'full_spectrum',
                delta: (minDR - dr).toFixed(1)
            });
        }
    }
    
    // Regra 4: LRA (Loudness Range)
    if (technicalData.lra != null) {
        const lra = technicalData.lra;
        const minLRA = 3.0; // MÃ­nimo recomendado para evitar fadiga auditiva
        const maxLRA = 15.0; // MÃ¡ximo para manter consistÃªncia
        
        if (lra < minLRA) {
            suggestions.push({
                type: 'lra_low',
                category: 'dynamics',
                message: `LRA (Loudness Range) estÃ¡ em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (mix sem variaÃ§Ã£o dinÃ¢mica)`,
                action: `Aumentar variaÃ§Ã£o dinÃ¢mica em ${(minLRA - lra).toFixed(1)} LU via automaÃ§Ã£o ou compressÃ£o seletiva`,
                priority: 'mÃ©dia',
                band: 'full_spectrum',
                delta: (minLRA - lra).toFixed(1)
            });
        } else if (lra > maxLRA) {
            suggestions.push({
                type: 'lra_high',
                category: 'dynamics',
                message: `LRA (Loudness Range) estÃ¡ em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (variaÃ§Ã£o dinÃ¢mica excessiva)`,
                action: `Reduzir variaÃ§Ã£o dinÃ¢mica em ${(lra - maxLRA).toFixed(1)} LU via compressÃ£o multibanda`,
                priority: 'mÃ©dia',
                band: 'full_spectrum',
                delta: (lra - maxLRA).toFixed(1)
            });
        }
    }
    
    // Regras 5-11: Bandas Espectrais (7 bandas)
    const bands = technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands || {};
    
    if (Object.keys(bands).length > 0) {
        const idealRanges = {
            sub: { min: -38, max: -28, name: 'Sub (20-60Hz)' },
            bass: { min: -31, max: -25, name: 'Bass (60-150Hz)' },
            lowMid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' },
            low_mid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' }, // Alias
            mid: { min: -23, max: -17, name: 'Mid (500Hz-2kHz)' },
            highMid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' },
            high_mid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' }, // Alias
            presence: { min: -23, max: -17, name: 'Presence (5-10kHz)' },
            air: { min: -30, max: -24, name: 'Air (10-20kHz)' }
        };
        
        for (const [band, ideal] of Object.entries(idealRanges)) {
            const bandData = bands[band];
            if (bandData && typeof bandData.energy_db === 'number') {
                const value = bandData.energy_db;
                
                if (value < ideal.min) {
                    const delta = ideal.min - value;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} estÃ¡ em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB abaixo do mÃ­nimo)`,
                        action: `Aumentar ${ideal.name} em +${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'mÃ©dia',
                        band: band,
                        delta: `+${delta.toFixed(1)}`
                    });
                } else if (value > ideal.max) {
                    const delta = value - ideal.max;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} estÃ¡ em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB acima do mÃ¡ximo)`,
                        action: `Reduzir ${ideal.name} em -${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'mÃ©dia',
                        band: band,
                        delta: `-${delta.toFixed(1)}`
                    });
                }
            }
        }
    }
    
    log(`[SUG-AUDIT] âœ… generateBasicSuggestions FIM: ${suggestions.length} sugestÃµes geradas`);
    suggestions.forEach((sug, i) => {
        log(`[SUG-AUDIT] SugestÃ£o ${i + 1}/${suggestions.length}:`, {
            type: sug.type,
            category: sug.category,
            message: sug.message.substring(0, 60) + '...',
            priority: sug.priority
        });
    });
    
    return suggestions;
}

/**
 * ğŸ”§ FUNÃ‡ÃƒO CORRIGIDA: Normalizar dados do backend (compatÃ­vel com JSON antigo e novo)
 * Mapeia a resposta do backend para o formato que o front-end espera
 * âœ… CompatÃ­vel com JSON antigo e novo (prÃ©/pÃ³s Redis)
 */
function normalizeBackendAnalysisData(result) {
    // ğŸ”¥ PROTEÃ‡ÃƒO CRÃTICA: Preservar technicalData e genreTargets ANTES de qualquer manipulaÃ§Ã£o
    const __protected = {
        technicalData: structuredClone(result?.technicalData || result?.data?.technicalData || {}),
        genreTargets: structuredClone(result?.data?.genreTargets || result?.genreTargets || null),
        metadata: structuredClone(result?.metadata || {}),
        score: result?.score ?? null,
        classification: result?.classification ?? null
    };
    
    log('[NORMALIZE] ğŸ›¡ï¸ PROTEÃ‡ÃƒO ATIVADA - Dados preservados:', {
        technicalDataKeys: Object.keys(__protected.technicalData).length,
        hasGenreTargets: !!__protected.genreTargets,
        genreTargetsKeys: __protected.genreTargets ? Object.keys(__protected.genreTargets) : null,
        hasMetadata: Object.keys(__protected.metadata).length > 0,
        score: __protected.score,
        classification: __protected.classification
    });
    
    // âœ… STEP 5/6: Blindagem total â€” clonar entrada para evitar mutaÃ§Ã£o de objetos compartilhados
    if (result && typeof result === 'object') {
        log('[NORMALIZE] ğŸ›¡ï¸ Clonando entrada para evitar contaminaÃ§Ã£o');
        result = JSON.parse(JSON.stringify(result));
    }
    // ï¿½ï¸ PROTEÃ‡ÃƒO: Detectar normalizaÃ§Ã£o duplicada
    if (result?.__normalized === true) {
        warn('[NORMALIZE] âš ï¸ Objeto jÃ¡ foi normalizado anteriormente - retornando clone');
        warn('[NORMALIZE] jobId:', result?.jobId, 'fileName:', result?.metadata?.fileName);
        // Retornar clone profundo para evitar mutaÃ§Ã£o
        return deepCloneSafe(result);
    }
    
    // ï¿½ğŸ” AUDITORIA: Capturar estado ANTES de normalizaÃ§Ã£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âš™ï¸ normalizeBackendAnalysisData - ENTRADA');
    log('ğŸ“Š result (antes de normalizar):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result,
        hasMetadata: !!result?.metadata,
        hasTechnicalData: !!result?.technicalData,
        alreadyNormalized: result?.__normalized === true
    });
    console.groupEnd();
    
    log("[BACKEND RESULT] Received analysis with data:", result);
    
    // ğŸ¯ PROTEÃ‡ÃƒO CRÃTICA: Preservar modo reference se segunda faixa estÃ¡ ativa
    const state = window.__soundyState || {};
    if (state.reference?.isSecondTrack && state.render?.mode !== 'reference') {
        warn('[FIX] Corrigindo mode: reference forÃ§ado (segunda faixa ativa)');
        state.render = state.render || {};
        state.render.mode = 'reference';
        window.__soundyState = state;
    }
    
    // âœ… CompatÃ­vel com JSON antigo e novo (prÃ©/pÃ³s Redis)
    const data = result?.data ?? result;
    const src = data.metrics || data.technicalData || data.loudness || data.spectral || data;

    if (!src) {
        error("[NORMALIZE] âŒ Nenhuma fonte de dados encontrada:", result);
        throw new Error("source is not defined");
    }

    log("[NORMALIZE] Source data extracted:", src);
    log("[NORMALIZE] Full data structure:", data);
    
    // ğŸ¯ CRÃTICO: Preservar data.genre e data.genreTargets (FONTE OFICIAL DO BACKEND)
    log("[NORMALIZE] ğŸµ Preservando genre do backend:", {
        'data.genre': data.genre,
        'result.data.genre': result?.data?.genre,
        'hasGenreTargets': !!(data.genreTargets || result?.data?.genreTargets)
    });
    
    // ğŸ¯ CORREÃ‡ÃƒO #3: targets em reference mode
    // Se mode=reference e targets=null, normalizar para [] (nÃ£o bloquear pipeline)
    if (backendMode === 'reference' && !data.genreTargets && !result?.data?.genreTargets) {
        log('[NORMALIZE] ğŸ”§ Modo reference sem targets - normalizando para []');
        data.genreTargets = [];
    }

    const loudness = src.loudness || data.loudness || data.technicalData?.loudness || {};
    const dynamics = src.dynamics || data.dynamics || data.technicalData?.dynamics || {};
    const truePeak = src.truePeak || data.truePeak || data.technicalData?.truePeak || {};
    const energy = src.energy || data.energy || data.technicalData?.energy || {};
    const bands = src.bands || src.spectralBands || data.technicalData?.bands || data.technicalData?.spectralBands || data.spectralBands || {};

    // ğŸ¯ CRÃTICO: Genre e mode no nÃ­vel RAIZ (prioridade mÃ¡xima para leitura)
    const backendGenre = result?.genre || 
                         data.genre || 
                         result?.data?.genre || 
                         result?.metadata?.genre ||
                         null;
    
    const backendMode = result?.mode || 
                        data.mode || 
                        'genre';
    
    // ğŸš¨ RESTAURAÃ‡ÃƒO DE GÃŠNERO: Se backend retornou null E modo Ã© genre, restaurar preservado
    const preservedGenre = window.__CURRENT_SELECTED_GENRE || window.__PRESERVED_GENRE__;
    const finalGenre = (backendMode === 'genre' && (!backendGenre || backendGenre === null))
                        ? preservedGenre
                        : backendGenre;
    
    if (backendMode === 'genre' && (!backendGenre || backendGenre === null) && preservedGenre) {
        warn('[NORMALIZE] âš ï¸ Backend retornou genre NULL em modo genre!');
        warn('[NORMALIZE] ğŸ”„ RESTAURANDO genre preservado:', preservedGenre);
        log('[GENRE-BEFORE-RESTORE]', { backendGenre, preservedGenre, finalGenre });
    }
    
    // ğŸ¯ CORREÃ‡ÃƒO #1: Criar metrics NO TOP-LEVEL a partir de technicalData
    const metricsFromTechnicalData = {
        lufs: src.lufsIntegrated ?? loudness.integrated ?? null,
        truePeak: src.truePeakDbtp ?? truePeak.maxDbtp ?? null,
        dynamicRange: src.dynamicRange ?? dynamics.range ?? null,
        lra: src.lra ?? loudness.range ?? null,
        rms: src.avgLoudness ?? src.rmsLeft ?? null,
        crestFactor: src.crestFactor ?? dynamics.crest ?? null,
        stereoCorrelation: src.stereoCorrelation ?? null
    };
    
    log('[NORMALIZE] ğŸ“Š Metrics extraÃ­das de technicalData:', metricsFromTechnicalData);

    const normalized = {
        // Preservar estrutura original
        ...data,
        
        genre: finalGenre,
        mode: backendMode,
        
        // ğŸ¯ NOVO: Garantir metrics no top-level (FONTE ÃšNICA)
        metrics: metricsFromTechnicalData,
        
        // ğŸ¯ CRÃTICO: Garantir que data.genre venha da FONTE CORRETA
        // ğŸ”¥ CORREÃ‡ÃƒO DEFINITIVA: SPREAD PRIMEIRO, DEPOIS SOBRESCREVER com valores corretos
        data: {
            // PRIMEIRO: Spread para preservar outros dados
            ...(data.data || {}),
            
            // DEPOIS: FORÃ‡AR genre e genreTargets (NUNCA podem ser sobrescritos!)
            genre: result?.genre || 
                   data.genre || 
                   result?.data?.genre || 
                   null,
            
            // ğŸ”¥ CORREÃ‡ÃƒO FASE 2: Priorizar data.data.genreTargets (onde backend realmente envia)
            // Backend monta: { data: { genreTargets: {...} } }
            // Ordem correta: data.data > result.data > __protected > null
            genreTargets: data.data?.genreTargets ||     // âœ… PRIORIDADE 1: Onde backend envia
                         result?.data?.genreTargets ||   // âœ… PRIORIDADE 2: Fallback estrutura alternativa
                         __protected.genreTargets ||     // âœ… PRIORIDADE 3: Backup protegido no inÃ­cio
                         null
        },
        
        // ğŸ” AUDITORIA CRÃTICA: Verificar se spread contaminou genre
        __genreAudit: {
            preSpreadGenre: result?.genre || data.genre || null,
            dataDataGenre: data.data?.genre || null,
            spreadContamination: !!(data.data?.genre === null && (result?.genre || data.genre)),
            timestamp: new Date().toISOString()
        },
        
        // ğŸ¯ MÃ©tricas normalizadas (RMS e LUFS separados)
        avgLoudness: energy.rms ?? 
                    src.avgLoudness ?? 
                    src.rms ??
                    data.technicalData?.avgLoudness ?? 
                    data.technicalData?.rms ??
                    data.energy?.rms ??
                    null,
        
        lufsIntegrated: loudness.integratedLUFS ?? 
                       loudness.integrated ?? 
                       src.lufsIntegrated ?? 
                       data.technicalData?.lufsIntegrated ?? 
                       data.loudness?.integrated ?? 
                       null,
                       
        lra: loudness.lra ?? 
             src.lra ?? 
             data.technicalData?.lra ?? 
             data.loudness?.lra ?? 
             null,
             
        truePeakDbtp: truePeak.maxDbtp ?? 
                     src.truePeakDbtp ?? 
                     data.technicalData?.truePeakDbtp ?? 
                     null,
                     
        dynamicRange: dynamics.range ?? 
                     src.dynamicRange ?? 
                     data.technicalData?.dynamicRange ?? 
                     null,
                     
        crestFactor: dynamics.crest ?? 
                    src.crestFactor ?? 
                    src.crest_factor ??
                    data.technicalData?.crestFactor ?? 
                    null,
                     
        bands: bands,
        
        // ğŸ¯ Preservar estruturas aninhadas originais para fallback
        loudness: data.loudness || loudness,
        dynamics: data.dynamics || dynamics,
        truePeak: data.truePeak || truePeak,
        energy: data.energy || energy,
        
        // Estruturas tÃ©cnicas
        technicalData: {
            // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: NÃƒO reconstruir technicalData - usar APENAS o que veio do backend
            // O backend JÃ envia technicalData completo com todas as mÃ©tricas
            // Qualquer reconstruÃ§Ã£o aqui DESTRÃ“I os dados originais
            ...(data.technicalData || {}),
            
            // âš ï¸ FALLBACK MÃNIMO: Apenas se technicalData vier vazio (nÃ£o deveria acontecer)
            // Estes fallbacks SÃ“ serÃ£o usados se o campo nÃ£o existir no technicalData original
        },
        
        // ğŸ¯ CRITICAL FIX: Adicionar objeto metrics com nomenclatura snake_case
        // Isso garante compatibilidade com calculateLoudnessScore/Dynamics/Stereo
        metrics: {
            lufs_integrated: loudness.integratedLUFS ?? 
                            loudness.integrated ?? 
                            src.lufsIntegrated ?? 
                            data.technicalData?.lufsIntegrated ?? 
                            data.loudness?.integrated ?? 
                            null,
            
            true_peak_dbtp: truePeak.maxDbtp ?? 
                           src.truePeakDbtp ?? 
                           data.technicalData?.truePeakDbtp ?? 
                           null,
            
            dynamic_range: dynamics.range ?? 
                          src.dynamicRange ?? 
                          data.technicalData?.dynamicRange ?? 
                          null,
            
            lra: loudness.lra ?? 
                src.lra ?? 
                data.technicalData?.lra ?? 
                data.loudness?.lra ?? 
                null,
            
            stereo_correlation: src.stereoCorrelation ?? 
                               data.technicalData?.stereoCorrelation ??
                               data.stereoCorrelation ??
                               null,
            
            stereo_width: src.stereoWidth ??
                         data.technicalData?.stereoWidth ??
                         data.stereoWidth ??
                         null,
            
            crest_factor: dynamics.crest ?? 
                         src.crestFactor ?? 
                         src.crest_factor ??
                         data.technicalData?.crestFactor ?? 
                         null
        },
        
        metadata: data.metadata ?? {},
        
        // Preservar outros campos importantes
        problems: data.problems || [],
        // âœ… PATCH CRÃTICO: Preservar suggestions do backend SEMPRE
        // NÃ£o usar || [] pois isso sobrescreve array vazio vindo do backend
        suggestions: Array.isArray(data.suggestions) ? data.suggestions : [],
        duration: data.duration || null,
        sampleRate: data.sampleRate || null,
        channels: data.channels || null,
        score: data.score || null,
        classification: data.classification || null
    };

    // âœ… AUDITORIA CRÃTICA PRÃ‰-GERAÃ‡ÃƒO: Verificar se suggestions vieram do backend
    log('[SUG-AUDIT][CRITICAL] PRÃ‰-NORMALIZAÃ‡ÃƒO data.suggestions:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        willPreserve: Array.isArray(data.suggestions) && data.suggestions.length > 0
    });

    // âœ… GARANTIR SUGESTÃ•ES BÃSICAS SE BACKEND NÃƒO ENVIOU
    log(`[SUG-AUDIT] normalizeBackendAnalysisData > Entrada:`, {
        hasSuggestions: Array.isArray(normalized.suggestions),
        suggestionsLength: normalized.suggestions?.length || 0,
        source: 'backend'
    });
    
    if (!normalized.suggestions || normalized.suggestions.length === 0) {
        log(`[SUG-AUDIT] normalizeBackendAnalysisData > Gerando sugestÃµes bÃ¡sicas no frontend...`);
        normalized.suggestions = generateBasicSuggestions(normalized);
        log(`[SUG-AUDIT] normalizeBackendAnalysisData > âœ… ${normalized.suggestions.length} sugestÃµes bÃ¡sicas geradas no frontend`);
    } else {
        log(`[SUG-AUDIT] normalizeBackendAnalysisData > âœ… ${normalized.suggestions.length} sugestÃµes vindas do backend (preservadas)`);
    }
    
    log(`[SUG-AUDIT] normalizeBackendAnalysisData > SaÃ­da:`, {
        suggestionsLength: normalized.suggestions.length,
        sampleFirst: normalized.suggestions[0]?.message?.substring(0, 50) + '...'
    });

    log("âœ… [NORMALIZE] Parsed data:", normalized);
    log("âœ… [NORMALIZE] Normalized metrics:", {
        avgLoudness: normalized.technicalData.avgLoudness,
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        crestFactor: normalized.technicalData.crestFactor,
        bands: normalized.technicalData.bandEnergies || normalized.technicalData.spectral_balance
    });
    
    // âœ… PATCH: garantir estrutura spectral_balance
    if (!normalized.technicalData.spectral_balance) {
        const sourceBands = result?.analysis?.bands || 
                           data?.bands || 
                           data?.frequencyBands || 
                           result?.bands ||
                           src?.spectral_balance ||
                           null;
        
        if (sourceBands) {
            normalized.technicalData.spectral_balance = sourceBands;
            log("âœ… [NORMALIZER] spectral_balance restaurado automaticamente");
        } else {
            warn("âš ï¸ [NORMALIZER] Nenhum dado de bandas detectado â€” criando estrutura vazia");
            normalized.technicalData.spectral_balance = {
                sub: 0,
                bass: 0,
                low_mid: 0,
                mid: 0,
                high_mid: 0,
                presence: 0,
                air: 0
            };
        }
    }
    
    // ï¿½ï¿½ LOGS ESPECÃFICOS DAS MÃ‰TRICAS PRINCIPAIS (AUDITORIA COMPLETA RMS + LUFS)
    log('[AUDITORIA-RMS-LUFS] RMS:', normalized.technicalData.avgLoudness, 'LUFS:', normalized.technicalData.lufsIntegrated);
    
    // âœ… AUDITORIA CRÃTICA: Verificar se suggestions vieram do backend
    log('[SUG-AUDIT][CRITICAL] data.suggestions FROM BACKEND:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        type: typeof data.suggestions,
        sample: data.suggestions?.[0]
    });
    
    log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > RMS=', normalized.technicalData.avgLoudness, {
        'energy.rms': energy.rms,
        'src.avgLoudness': src.avgLoudness,
        'src.rms': src.rms,
        'technicalData.avgLoudness': data.technicalData?.avgLoudness,
        'technicalData.rms': data.technicalData?.rms
    });
    
    log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > LUFS=', normalized.technicalData.lufsIntegrated, {
        'loudness.integrated': loudness.integrated,
        'loudness.integratedLUFS': loudness.integratedLUFS,
        'src.lufsIntegrated': src.lufsIntegrated,
        'technicalData.lufsIntegrated': data.technicalData?.lufsIntegrated
    });
    
    // ğŸ”¥ FASE 2 - LOG DE VALIDAÃ‡ÃƒO: Confirmar que genreTargets foi preservado
    log('[FASE2-VALIDATION] ğŸ¯ genreTargets apÃ³s normalizaÃ§Ã£o:', {
        exists: !!normalized.data?.genreTargets,
        keys: normalized.data?.genreTargets ? Object.keys(normalized.data.genreTargets) : null,
        hasBands: !!normalized.data?.genreTargets?.bands,
        bandKeys: normalized.data?.genreTargets?.bands ? Object.keys(normalized.data.genreTargets.bands) : null,
        source: data.data?.genreTargets ? 'data.data' : 
                result?.data?.genreTargets ? 'result.data' : 
                __protected.genreTargets ? '__protected' : 'none'
    });
    
    log('[METRICS-FIX] normalizeBackendAnalysisData > CREST=', normalized.technicalData.crestFactor, {
        'dynamics.crest': dynamics.crest,
        'src.crestFactor': src.crestFactor,
        'src.crest_factor': src.crest_factor,
        'technicalData.crestFactor': data.technicalData?.crestFactor
    });

    // ğŸ¯ CRÃTICO: Injetar genreReference no formato EXATO que o frontend espera
    const activeRef = window.__activeRefData;
    if (activeRef) {
        // Formato para o frontend (tabela de comparaÃ§Ã£o)
        normalized.genreReference = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        // Compatibilidade com o Suggestion Engine
        normalized.data = normalized.data || {};
        normalized.data.genreTargets = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        log('[GENRE-REFERENCE-INJECT] âœ… genreReference injetado para frontend:', {
            hasSpectralBands: !!normalized.genreReference.spectral_bands,
            hasLufs: !!normalized.genreReference.lufs,
            hasTruePeak: !!normalized.genreReference.true_peak,
            bandCount: normalized.genreReference.spectral_bands ? Object.keys(normalized.genreReference.spectral_bands).length : 0
        });
    } else {
        warn('[GENRE-REFERENCE-INJECT] âš ï¸ window.__activeRefData nÃ£o disponÃ­vel - tabela de comparaÃ§Ã£o pode nÃ£o renderizar');
    }

    // ï¿½ï¸ MARCAR: Flag para prevenir normalizaÃ§Ã£o duplicada
    normalized.__normalized = true;
    normalized.__normalizedAt = Date.now();
    log('[NORMALIZE] âœ… Objeto marcado como normalizado:', normalized.jobId);

    // ï¿½ğŸ” AUDITORIA: Estado APÃ“S normalizaÃ§Ã£o
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] âœ… normalizeBackendAnalysisData - SAÃDA');
    log('ğŸ“Š normalized (resultado):', {
        jobId: normalized?.jobId,
        fileName: normalized?.metadata?.fileName || normalized?.fileName,
        lufs: normalized?.technicalData?.lufsIntegrated,
        objectId: normalized,
        sameAsInput: normalized === result
    });
    log('ğŸ“Š result (input original - VERIFICAR SE MUDOU):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result
    });
    log('âš ï¸ VERIFICAÃ‡ÃƒO DE MUTAÃ‡ÃƒO:');
    log('  normalized === result?', normalized === result);
    log('  normalized.technicalData === result.technicalData?', normalized.technicalData === result.technicalData);
    log('  normalized.metadata === result.metadata?', normalized.metadata === result.metadata);
    if (normalized.technicalData === result.technicalData) {
        warn('ğŸš¨ MUTAÃ‡ÃƒO DETECTADA: technicalData compartilha referÃªncia!');
    }
    if (normalized.metadata === result.metadata) {
        warn('ğŸš¨ MUTAÃ‡ÃƒO DETECTADA: metadata compartilha referÃªncia!');
    }
    console.groupEnd();

    // ========================================
    // ğŸ”’ BLINDAGEM CRÃTICA: Quebrar compartilhamento de ponteiros
    // ========================================
    if (normalized && normalized.metadata) {
      // quebra compartilhamento de ponteiro
      normalized.metadata = { ...normalized.metadata };
    }
    if (normalized && normalized.technicalData) {
      normalized.technicalData = { ...normalized.technicalData };
    }
    if (normalized && normalized.bands) {
      normalized.bands = cloneDeepSafe(normalized.bands);
    }

    // ğŸ”¥ RESTAURAÃ‡ÃƒO CRÃTICA: Restaurar dados protegidos do backend
    log('[NORMALIZE] ğŸ›¡ï¸ RESTAURANDO dados protegidos do backend');
    
    if (__protected.technicalData && Object.keys(__protected.technicalData).length > 0) {
        log('[NORMALIZE] âœ… Restaurando technicalData original:', Object.keys(__protected.technicalData).length, 'campos');
        normalized.technicalData = structuredClone(__protected.technicalData);
    } else {
        warn('[NORMALIZE] âš ï¸ technicalData estava vazio na entrada - mantendo reconstruÃ­do');
    }
    
    if (__protected.genreTargets) {
        if (!normalized.data) normalized.data = {};
        log('[NORMALIZE] âœ… Restaurando genreTargets original:', Object.keys(__protected.genreTargets));
        normalized.data.genreTargets = structuredClone(__protected.genreTargets);
    } else {
        warn('[NORMALIZE] âš ï¸ genreTargets estava ausente na entrada');
    }
    
    if (Object.keys(__protected.metadata).length > 0) {
        log('[NORMALIZE] âœ… Restaurando metadata original');
        normalized.metadata = structuredClone(__protected.metadata);
    }
    
    if (__protected.score !== null) {
        log('[NORMALIZE] âœ… Restaurando score original:', __protected.score);
        normalized.score = __protected.score;
    }
    
    if (__protected.classification !== null) {
        log('[NORMALIZE] âœ… Restaurando classification original:', __protected.classification);
        normalized.classification = __protected.classification;
    }

    // ========================================
    // ğŸ”’ RETORNO FINAL: Clone profundo para garantir isolamento total
    // ========================================
    const normalizedOut = cloneDeepSafe(normalized);
    Object.defineProperty(normalizedOut, 'sameAsInput', { value: false, enumerable: false });
    return normalizedOut;
}

// =============== FUNÃ‡Ã•ES AUXILIARES ===============

// ================================================================
// ğŸ§ª TESTE DE PARIDADE V3.7: Validar CEILING vs BANDPASS
// Garante que evaluateMetric() retorna severidades corretas
// ================================================================
function testScoreV37Parity() {
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ§ª [V3.7 PARITY TEST] Iniciando testes de paridade CEILING/BANDPASS');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    const results = [];
    
    // ============================================================
    // CASO A: True Peak DENTRO do target (-1.2 < -1.0) => OK
    // ============================================================
    const caseA = {
        name: 'True Peak OK (abaixo do target)',
        metricKey: 'truePeak',
        measuredValue: -1.2,
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'OK',
        expectedScoreMin: 90 // Score deve ser alto
    };
    
    // ============================================================
    // CASO B: True Peak ACIMA do target (0.5 > -1.0) => CRÃTICA
    // ESTE Ã‰ O BUG CRÃTICO QUE ESTAVA ACONTECENDO
    // ============================================================
    const caseB = {
        name: 'True Peak CRÃTICA (acima do target, abaixo de max)',
        metricKey: 'truePeak',
        measuredValue: 0.5, // +1.5 dB acima do target
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'CRÃTICA',
        expectedScoreMax: 50 // Score deve ser baixo
    };
    
    // ============================================================
    // CASO C: True Peak MUITO ACIMA (2.0 > 0.0 max) => CRÃTICA HARD
    // ============================================================
    const caseC = {
        name: 'True Peak CRÃTICA HARD (acima do max)',
        metricKey: 'truePeak',
        measuredValue: 2.0, // +2 dB acima do max!
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'CRÃTICA',
        expectedScoreMax: 20 // Score deve ser muito baixo
    };
    
    // ============================================================
    // CASO D: LUFS BANDPASS no target exato => OK
    // ============================================================
    const caseD = {
        name: 'LUFS OK (no target)',
        metricKey: 'lufs',
        measuredValue: -14.0,
        targetSpec: { target: -14.0, min: -16.0, max: -12.0, tol: 1.0 },
        expectedSeverity: 'OK',
        expectedScoreMin: 95
    };
    
    // ============================================================
    // CASO E: LUFS BANDPASS fora do range => CRÃTICA
    // ============================================================
    const caseE = {
        name: 'LUFS CRÃTICA (fora do range)',
        metricKey: 'lufs',
        measuredValue: -8.0, // +6 dB acima do target
        targetSpec: { target: -14.0, min: -16.0, max: -12.0, tol: 1.0 },
        expectedSeverity: 'CRÃTICA',
        expectedScoreMax: 40
    };
    
    // ============================================================
    // CASO F: LRA BANDPASS moderadamente fora => ATENÃ‡ÃƒO
    // ============================================================
    const caseF = {
        name: 'LRA ATENÃ‡ÃƒO (moderadamente fora)',
        metricKey: 'lra',
        measuredValue: 6.5, // +2.5 dB acima do target
        targetSpec: { target: 4.0, min: 2.0, max: 6.0, tol: 1.0 },
        expectedSeverity: 'ATENÃ‡ÃƒO',
        expectedScoreMin: 50,
        expectedScoreMax: 85
    };
    
    const testCases = [caseA, caseB, caseC, caseD, caseE, caseF];
    
    let passed = 0;
    let failed = 0;
    
    for (const tc of testCases) {
        const result = evaluateMetric(tc.metricKey, tc.measuredValue, tc.targetSpec);
        
        const severityOK = result.severity === tc.expectedSeverity;
        const scoreOK = (tc.expectedScoreMin === undefined || result.score >= tc.expectedScoreMin) &&
                       (tc.expectedScoreMax === undefined || result.score <= tc.expectedScoreMax);
        
        const testPassed = severityOK && scoreOK;
        
        if (testPassed) {
            passed++;
            log(`âœ… ${tc.name}`);
            log(`   value=${tc.measuredValue}, target=${tc.targetSpec.target}`);
            log(`   score=${result.score.toFixed(1)}, severity=${result.severity}`);
        } else {
            failed++;
            error(`âŒ ${tc.name} FALHOU!`);
            error(`   value=${tc.measuredValue}, target=${tc.targetSpec.target}`);
            error(`   score=${result.score.toFixed(1)} (esperado: ${tc.expectedScoreMin ?? '?'}-${tc.expectedScoreMax ?? '?'})`);
            error(`   severity=${result.severity} (esperado: ${tc.expectedSeverity})`);
        }
        
        results.push({
            ...tc,
            actualScore: result.score,
            actualSeverity: result.severity,
            passed: testPassed
        });
    }
    
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log(`ğŸ§ª RESULTADO: ${passed}/${testCases.length} testes passaram`);
    if (failed > 0) {
        error(`âŒ ${failed} testes FALHARAM - VERIFICAR evaluateMetric V3.7!`);
    } else {
        log('âœ… Todos os testes passaram - CEILING/BANDPASS funcionando!');
    }
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    return { passed, failed, results };
}

// Expor para console
if (typeof window !== 'undefined') {
    window.testScoreV37Parity = testScoreV37Parity;
}

// ================================================================
// ğŸ§ª TESTE DE SUBSCORE DE FREQUÃŠNCIA V3.7.1
// Valida cÃ¡lculo ponderado e gates de sanidade
// ================================================================
function testFrequencySubscoreV371() {
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ§ª [FREQ-TEST V3.7.1] Testando Subscore de FrequÃªncia');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    const testCases = [
        // CASO A: Todas as bandas OK
        {
            name: 'Todas bandas OK',
            bands: {
                sub: { energy_db: -22.0 },   // target -22, diff=0
                bass: { energy_db: -18.0 },  // target -18, diff=0
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 95,
            expectedScoreMax: 100,
            expectedCap: null
        },
        // CASO B: 1 banda CRÃTICA (sub +10dB)
        {
            name: '1 banda CRÃTICA (sub)',
            bands: {
                sub: { energy_db: -12.0 },   // target -22, diff=+10 â†’ CRÃTICA!
                bass: { energy_db: -18.0 },
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 50,
            expectedScoreMax: 85, // Cap por 1 CRÃTICA
            expectedCap: 85
        },
        // CASO C: 2 bandas CRÃTICAS (sub e bass)
        {
            name: '2 bandas CRÃTICAS (sub + bass)',
            bands: {
                sub: { energy_db: -12.0 },   // +10dB â†’ CRÃTICA
                bass: { energy_db: -8.0 },   // +10dB â†’ CRÃTICA
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 40,
            expectedScoreMax: 70, // Cap por 2 CRÃTICAS
            expectedCap: 70
        },
        // CASO D: 3 bandas CRÃTICAS
        {
            name: '3 bandas CRÃTICAS',
            bands: {
                sub: { energy_db: -12.0 },   // +10dB â†’ CRÃTICA
                bass: { energy_db: -8.0 },   // +10dB â†’ CRÃTICA
                lowMid: { energy_db: -6.0 }, // +10dB â†’ CRÃTICA
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 30,
            expectedScoreMax: 55, // Cap por 3+ CRÃTICAS
            expectedCap: 55
        }
    ];
    
    let passed = 0;
    let failed = 0;
    const results = [];
    
    for (const tc of testCases) {
        // Construir anÃ¡lise fake
        const analysis = {
            technicalData: {
                lufsIntegrated: -14.0,
                truePeakDbtp: -1.0,
                dynamicRange: 8.0,
                crestFactor: 12.0,
                lra: 7.0,
                stereoCorrelation: 0.9,
                stereoWidth: 0.7,
                clippingPct: 0.001,
                dcOffset: 0.0,
                bands: tc.bands
            }
        };
        
        const targets = {
            lufs_target: -14.0, tol_lufs: 1.0,
            true_peak_target: -1.0, tol_true_peak: 0.25,
            dr_target: 8.0, tol_dr: 1.5,
            ...tc.targets
        };
        
        const result = window.computeScoreV3(analysis, targets, 'streaming');
        const freqScore = result.subscores?.frequency;
        const freqDetails = result._frequencyDetails || result.subScoresRaw?._frequencyDetails;
        
        // Verificar score
        const scoreOK = (freqScore !== null) &&
                       (freqScore >= tc.expectedScoreMin) &&
                       (freqScore <= tc.expectedScoreMax);
        
        // Verificar cap (se esperado)
        const capOK = tc.expectedCap === null || 
                     (freqDetails?.appliedCap === tc.expectedCap);
        
        const testPassed = scoreOK && capOK;
        
        if (testPassed) {
            passed++;
            log(`âœ… ${tc.name}`);
            log(`   Score: ${freqScore} (esperado: ${tc.expectedScoreMin}-${tc.expectedScoreMax})`);
            if (tc.expectedCap) log(`   Cap: ${freqDetails?.appliedCap} (esperado: ${tc.expectedCap})`);
        } else {
            failed++;
            error(`âŒ ${tc.name} FALHOU!`);
            error(`   Score: ${freqScore} (esperado: ${tc.expectedScoreMin}-${tc.expectedScoreMax})`);
            error(`   Cap: ${freqDetails?.appliedCap} (esperado: ${tc.expectedCap})`);
            error(`   Details:`, freqDetails);
        }
        
        results.push({
            ...tc,
            actualScore: freqScore,
            actualCap: freqDetails?.appliedCap,
            passed: testPassed
        });
    }
    
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log(`ğŸ§ª RESULTADO FREQ V3.7.1: ${passed}/${testCases.length} testes passaram`);
    if (failed > 0) {
        error(`âŒ ${failed} testes FALHARAM!`);
    } else {
        log('âœ… Todos os testes passaram - Sistema de frequÃªncia validado!');
    }
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    return { passed, failed, results };
}

// Expor para console
if (typeof window !== 'undefined') {
    window.testFrequencySubscoreV371 = testFrequencySubscoreV371;
}

// ğŸ§ª TESTE AUTOMÃTICO: Validar normalizaÃ§Ã£o com JSON real
function testNormalizationCompatibility() {
    log("ğŸ§ª [TEST] Iniciando teste automÃ¡tico de compatibilidade...");
    
    // Teste 1: Formato antigo (prÃ©-Redis)
    const oldFormat = {
        data: {
            metrics: {
                lufsIntegrated: -11.15,
                lra: 0.8,
                dynamicRange: 10.28
            },
            technicalData: {
                truePeakDbtp: -0.2,
                bands: {
                    bass: -12.5,
                    mid: -10.8,
                    treble: -15.2
                }
            }
        }
    };
    
    // Teste 2: Formato novo (pÃ³s-Redis)
    const newFormat = {
        score: 100,
        classification: "ReferÃªncia Mundial",
        loudness: { integrated: -11.15, lra: 0.8 },
        truePeak: { maxDbtp: -0.2 },
        dynamics: { range: 10.28 },
        spectralBands: {
            bass: -12.5,
            mid: -10.8,
            treble: -15.2
        },
        metadata: { duration: 180 }
    };
    
    // Teste 3: Formato hÃ­brido
    const hybridFormat = {
        metrics: { lufsIntegrated: -11.15 },
        loudness: { integrated: -12.0 },
        technicalData: { lra: 0.8, truePeakDbtp: -0.2 }
    };
    
    try {
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS (testes sem reconstruÃ§Ã£o)
        const normalized1 = oldFormat; // âœ… LEITURA DIRETA
        log("âœ… [TEST] Formato antigo DIRETO:", {
            lufs: normalized1.technicalData?.lufsIntegrated,
            lra: normalized1.technicalData?.lra,
            truePeak: normalized1.technicalData?.truePeakDbtp,
            dr: normalized1.technicalData?.dynamicRange
        });
        
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS (testes sem reconstruÃ§Ã£o)
        const normalized2 = newFormat; // âœ… LEITURA DIRETA
        log("âœ… [TEST] Formato novo DIRETO:", {
            lufs: normalized2.technicalData?.lufsIntegrated,
            lra: normalized2.technicalData?.lra,
            truePeak: normalized2.technicalData?.truePeakDbtp,
            dr: normalized2.technicalData?.dynamicRange
        });
        
        // ğŸ”¥ CORREÃ‡ÃƒO: Usar dados DIRETOS (testes sem reconstruÃ§Ã£o)
        const normalized3 = hybridFormat; // âœ… LEITURA DIRETA
        log("âœ… [TEST] Formato hÃ­brido normalizado:", {
            lufs: normalized3.technicalData.lufsIntegrated,
            lra: normalized3.technicalData.lra,
            truePeak: normalized3.technicalData.truePeakDbtp,
            dr: normalized3.technicalData.dynamicRange
        });
        
        // âœ… ValidaÃ§Ã£o de estrutura
        const isValidStructure = (norm) => {
            return norm.technicalData && 
                   typeof norm.technicalData.lufsIntegrated !== 'undefined' &&
                   typeof norm.technicalData.lra !== 'undefined' &&
                   typeof norm.technicalData.truePeakDbtp !== 'undefined';
        };
        
        if (isValidStructure(normalized1) && isValidStructure(normalized2) && isValidStructure(normalized3)) {
            log("âœ… [TEST] Todos os formatos passaram na validaÃ§Ã£o!");
            log("âœ… [TEST] Sistema de normalizaÃ§Ã£o estÃ¡ funcionando corretamente");
            return true;
        } else {
            error("âŒ [TEST] Falha na validaÃ§Ã£o de estrutura");
            return false;
        }
        
    } catch (error) {
        error("âŒ [TEST] Erro no teste de normalizaÃ§Ã£o:", error);
        return false;
    }
}

// ğŸš€ Executar teste automÃ¡tico quando o arquivo carregar
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        setTimeout(() => {
            testNormalizationCompatibility();
        }, 1000);
    });
}

// ğŸ¯ FUNÃ‡ÃƒO: Aplicar correÃ§Ã£o de fallback ao score
    
    tech.lufsShortTerm = getRealValue('lufsShortTerm', 'lufs_short_term') ||
                        (backendData.loudness?.shortTerm && Number.isFinite(backendData.loudness.shortTerm) ? backendData.loudness.shortTerm : null);
    
    tech.lufsMomentary = getRealValue('lufsMomentary', 'lufs_momentary') ||
                        (backendData.loudness?.momentary && Number.isFinite(backendData.loudness.momentary) ? backendData.loudness.momentary : null);
    
    // LRA - CORRIGIR MAPEAMENTO PARA ESTRUTURA REAL: loudness.lra + technicalData.lra
    tech.lra = getRealValue('lra', 'loudnessRange', 'lra_tolerance', 'loudness_range') ||
              (backendData.loudness?.lra && Number.isFinite(backendData.loudness.lra) ? backendData.loudness.lra : null) ||
              (backendData.technicalData?.lra && Number.isFinite(backendData.technicalData.lra) ? backendData.technicalData.lra : null);
    
    log('ğŸ“Š [NORMALIZE] MÃ©tricas mapeadas (apenas reais):', {
        peak: tech.peak,
        rms: tech.rms,
        dynamicRange: tech.dynamicRange,
        crestFactor: tech.crestFactor,
        truePeakDbtp: tech.truePeakDbtp,
        lufsIntegrated: tech.lufsIntegrated,
        lufsShortTerm: tech.lufsShortTerm,
        lufsMomentary: tech.lufsMomentary,
        lra: tech.lra
    });
    
    // ğŸ¯ LOG ESPECÃFICO PARA AUDITORIA: LRA com estrutura real
    if (tech.lra !== null) {
        log('âœ… [LRA] SUCESSO: LRA mapeado corretamente =', tech.lra);
    } else {
        warn('âŒ [LRA] PROBLEMA: LRA nÃ£o foi encontrado no backend data');
        log('ğŸ” [LRA] Debug - possÃ­veis caminhos verificados:', {
            'backendData.loudness.lra': backendData.loudness?.lra,
            'backendData.technicalData.lra': backendData.technicalData?.lra,
            'source (technicalData)': source.lra || source.loudnessRange,
            'loudnessObject': backendData.loudness,
            'technicalDataObject': backendData.technicalData
        });
    }
    
    // Headroom - APENAS VALORES REAIS
    tech.headroomDb = getRealValue('headroomDb', 'headroom_db');
    tech.headroomTruePeakDb = getRealValue('headroomTruePeakDb');
    
    // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
    tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                            (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
    
    tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                      (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);
    
    tech.balanceLR = getRealValue('balanceLR', 'balance_lr') ||
                    (backendData.stereo?.balance && Number.isFinite(backendData.stereo.balance) ? backendData.stereo.balance : null);
    
    // Spectral - APENAS VALORES REAIS
    tech.spectralCentroid = getRealValue('spectralCentroid', 'spectral_centroid');
    tech.spectralRolloff = getRealValue('spectralRolloff', 'spectral_rolloff');
    tech.zeroCrossingRate = getRealValue('zeroCrossingRate', 'zero_crossing_rate');
    tech.spectralFlux = getRealValue('spectralFlux', 'spectral_flux');
    tech.spectralFlatness = getRealValue('spectralFlatness', 'spectral_flatness');
    
    // Problemas tÃ©cnicos - APENAS VALORES REAIS
    tech.clippingSamples = getRealValue('clippingSamples', 'clipping_samples');
    tech.clippingPct = getRealValue('clippingPct', 'clipping_pct');
    tech.dcOffset = getRealValue('dcOffset', 'dc_offset');
    tech.thdPercent = getRealValue('thdPercent', 'thd_percent');
    
    // Sample peaks por canal - APENAS VALORES REAIS
    tech.samplePeakLeftDb = getRealValue('samplePeakLeftDb', 'sample_peak_left_db');
    tech.samplePeakRightDb = getRealValue('samplePeakRightDb', 'sample_peak_right_db');
    
    // ===== NOVAS MÃ‰TRICAS IMPLEMENTADAS =====
    
    // Spectral Bandwidth e outras mÃ©tricas espectrais
    tech.spectralBandwidth = getRealValue('spectralBandwidth', 'spectral_bandwidth');
    tech.spectralBandwidthHz = tech.spectralBandwidth; // Alias
    tech.spectralSpread = getRealValue('spectralSpread', 'spectral_spread');
    tech.spectralCrest = getRealValue('spectralCrest', 'spectral_crest');
    tech.spectralSkewness = getRealValue('spectralSkewness', 'spectral_skewness');
    tech.spectralKurtosis = getRealValue('spectralKurtosis', 'spectral_kurtosis');
    
    // ğŸµ SPECTRAL BALANCE - Mapear dados espectrais REAIS do backend
    if (source.spectral_balance || source.spectralBalance || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        
        const spectralSource = source.spectral_balance || source.spectralBalance || source.bands || 
                              backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        
        log('ğŸ” [SPECTRAL] Fonte espectral detectada:', spectralSource);
        
        // FunÃ§Ã£o especÃ­fica para dados espectrais
        const getSpectralValue = (...paths) => {
            for (const path of paths) {
                const value = path.split('.').reduce((obj, key) => obj?.[key], spectralSource);
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            return null;
        };
        
        // Se spectral_balance Ã© string (ex: "balanced"), mapear para objeto
        if (typeof spectralSource === 'string') {
            tech.spectral_balance = {
                description: spectralSource,
                status: spectralSource
            };
            log('ğŸ“Š [NORMALIZE] Spectral balance (string):', tech.spectral_balance);
        } else {
            tech.spectral_balance = {
                sub: getSpectralValue('sub', 'subBass', 'sub_bass'),
                bass: getSpectralValue('bass', 'low_bass', 'lowBass'),  // Normalizar para 'bass'
                lowMid: getSpectralValue('lowMid', 'low_mid', 'lowmid'),
                mid: getSpectralValue('mid', 'mids', 'middle'),
                highMid: getSpectralValue('highMid', 'high_mid', 'highmid'),
                presence: getSpectralValue('presence', 'presenca'),
                air: getSpectralValue('air', 'brilho', 'treble', 'high')
            };
            log('ğŸ“Š [NORMALIZE] Spectral balance mapeado:', tech.spectral_balance);
        }
        
        // ğŸ¯ LOG ESPECÃFICO PARA AUDITORIA: BANDAS ESPECTRAIS
        const bandasDetectadas = typeof tech.spectral_balance === 'object' && tech.spectral_balance.description ? 
            [`description: ${tech.spectral_balance.description}`] :
            Object.entries(tech.spectral_balance)
                .filter(([key, value]) => value !== null && key !== 'description' && key !== 'status')
                .map(([key, value]) => `${key}: ${value}`);
        
        if (bandasDetectadas.length > 0) {
            log(`âœ… [BANDAS] SUCESSO: ${bandasDetectadas.length} bandas mapeadas:`, bandasDetectadas.join(', '));
        } else {
            warn('âŒ [BANDAS] PROBLEMA: Nenhuma banda espectral foi mapeada');
            log('ğŸ” [BANDAS] Debug - caminhos verificados:', {
                'source.spectral_balance': source.spectral_balance,
                'source.spectralBalance': source.spectralBalance, 
                'source.bands': source.bands,
                'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
                'backendData.technicalData.bands': backendData.technicalData?.bands,
                'spectralSource': spectralSource
            });
        }
    } else {
        // NÃ£o definir se nÃ£o hÃ¡ dados reais
        tech.spectral_balance = null;
        log('âš ï¸ [NORMALIZE] Nenhum dado espectral real encontrado');
        log('ğŸ” [NORMALIZE] Debug espectral - caminhos verificados:', {
            'source.spectral_balance': source.spectral_balance,
            'source.spectralBalance': source.spectralBalance,
            'source.bands': source.bands,
            'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
            'backendData.technicalData.bands': backendData.technicalData?.bands
        });
    }
    
    // ğŸ¶ BAND ENERGIES - Mapear energias das bandas de frequÃªncia REAIS do backend
    if (source.bandEnergies || source.band_energies || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        const bandsSource = source.bandEnergies || source.band_energies || source.bands || 
                          backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        tech.bandEnergies = {};
        
        // Mapear bandas conhecidas - APENAS VALORES REAIS
        const bandMapping = {
            'sub': 'sub',
            'subBass': 'sub', 
            'sub_bass': 'sub',
            'low_bass': 'bass',  // Normalizar para 'bass'
            'lowBass': 'bass',
            'bass': 'bass',
            'upper_bass': 'bass',
            'upperBass': 'bass',
            'low_mid': 'lowMid',  // Normalizar para 'lowMid'
            'lowMid': 'lowMid',
            'lowmid': 'lowMid',
            'mid': 'mid',
            'mids': 'mid',
            'middle': 'mid',
            'high_mid': 'highMid',  // Normalizar para 'highMid'
            'highMid': 'highMid',
            'highmid': 'highMid',
            'upper_mid': 'highMid',
            'upperMid': 'highMid',
            'brilho': 'air',  // Normalizar para 'air'
            'brilliance': 'air',
            'air': 'air',
            'treble': 'air',
            'high': 'air',
            'presenca': 'presence',  // Normalizar para 'presence'
            'presence': 'presence'
        };
        
        Object.entries(bandMapping).forEach(([sourceKey, targetKey]) => {
            const bandData = bandsSource[sourceKey];
            if (bandData && typeof bandData === 'object') {
                // Pegar apenas valores reais, sem fallbacks
                const rms_db = Number.isFinite(bandData.rms_db) ? bandData.rms_db : 
                              Number.isFinite(bandData.energy_db) ? bandData.energy_db :
                              Number.isFinite(bandData.level) ? bandData.level : null;
                              
                const peak_db = Number.isFinite(bandData.peak_db) ? bandData.peak_db : null;
                const frequency_range = bandData.frequency_range || bandData.range || null;
                
                // SÃ³ adicionar se tiver pelo menos um valor real
                if (rms_db !== null || peak_db !== null) {
                    tech.bandEnergies[targetKey] = {
                        rms_db: rms_db,
                        peak_db: peak_db,
                        frequency_range: frequency_range
                    };
                }
            }
        });
        
        log('ğŸ“Š [NORMALIZE] Band energies mapeadas (apenas reais):', tech.bandEnergies);
        
        // Se nÃ£o conseguiu mapear nenhuma banda real, deixar null
        if (Object.keys(tech.bandEnergies).length === 0) {
            tech.bandEnergies = null;
            log('âš ï¸ [NORMALIZE] Nenhuma banda real encontrada - bandEnergies = null');
        }
    } else {
        tech.bandEnergies = null;
        log('âš ï¸ [NORMALIZE] Dados de bandas nÃ£o encontrados - bandEnergies = null');
    }
    
    // ğŸ¼ TONAL BALANCE - Estrutura simplificada para compatibilidade APENAS COM VALORES REAIS
    if (tech.bandEnergies && Object.keys(tech.bandEnergies).length > 0) {
        tech.tonalBalance = {
            sub: tech.bandEnergies.sub || null,
            low: tech.bandEnergies.low_bass || null,
            mid: tech.bandEnergies.mid || null,
            high: tech.bandEnergies.brilho || null
        };
        log('ğŸ“Š [NORMALIZE] Tonal balance baseado em bandEnergies reais:', tech.tonalBalance);
    } else {
        tech.tonalBalance = null;
        log('âš ï¸ [NORMALIZE] Nenhuma banda real para tonal balance - tonalBalance = null');
    }
    
    // ğŸ¯ FREQUÃŠNCIAS DOMINANTES - Estrutura completa com detailed
    if (source.dominantFrequencies || source.dominant_frequencies) {
        const rawData = source.dominantFrequencies || source.dominant_frequencies;
        
        // Se for string/nÃºmero simples, converter para structured format
        if (typeof rawData === 'string' || typeof rawData === 'number') {
            tech.dominantFrequencies = {
                value: rawData,
                unit: 'Hz'
            };
        } else if (rawData && typeof rawData === 'object') {
            // Se for object com detailed
            tech.dominantFrequencies = {
                value: rawData.value || rawData.primary || null,
                unit: rawData.unit || 'Hz',
                detailed: rawData.detailed || {
                    primary: rawData.primary || rawData.value || null,
                    secondary: rawData.secondary || null,
                    peaks: rawData.peaks || []
                }
            };
        } else {
            tech.dominantFrequencies = null;
        }
        log('ğŸ“Š [NORMALIZE] FrequÃªncias dominantes estruturadas:', tech.dominantFrequencies);
    } else {
        tech.dominantFrequencies = null;
        log('âš ï¸ [NORMALIZE] FrequÃªncias dominantes nÃ£o encontradas - dominantFrequencies = null');
    }
    
    // ğŸ”„ DC OFFSET - Estrutura completa com canais L/R
    if (source.dcOffset || source.dc_offset) {
        const rawDcData = source.dcOffset || source.dc_offset;
        
        // Se for nÃºmero simples, converter para structured format
        if (typeof rawDcData === 'number') {
            tech.dcOffset = {
                value: rawDcData,
                unit: 'dB',
                detailed: {
                    L: rawDcData,
                    R: rawDcData,
                    severity: Math.abs(rawDcData) > 0.1 ? 'High' : Math.abs(rawDcData) > 0.01 ? 'Medium' : 'Low'
                }
            };
        } else if (rawDcData && typeof rawDcData === 'object') {
            // Se for object com detailed
            tech.dcOffset = {
                value: rawDcData.value || (rawDcData.detailed ? Math.max(Math.abs(rawDcData.detailed.L || 0), Math.abs(rawDcData.detailed.R || 0)) : null),
                unit: rawDcData.unit || 'dB',
                detailed: rawDcData.detailed || {
                    L: rawDcData.L || rawDcData.left || rawDcData.value || 0,
                    R: rawDcData.R || rawDcData.right || rawDcData.value || 0,
                    severity: rawDcData.severity || 'Low'
                }
            };
        } else {
            tech.dcOffset = null;
        }
        log('ğŸ“Š [NORMALIZE] DC Offset estruturado:', tech.dcOffset);
    } else {
        tech.dcOffset = null;
        log('âš ï¸ [NORMALIZE] DC Offset nÃ£o encontrado - dcOffset = null');
    }
    
    // ğŸ“Š SPECTRAL UNIFORMITY - Estrutura detalhada
    if (source.spectralUniformity || source.spectral_uniformity) {
        const rawSpectralData = source.spectralUniformity || source.spectral_uniformity;
        
        // Se for nÃºmero simples, converter para structured format
        if (typeof rawSpectralData === 'number') {
            tech.spectralUniformity = {
                value: rawSpectralData,
                unit: 'ratio',
                detailed: {
                    variance: rawSpectralData,
                    distribution: rawSpectralData > 0.8 ? 'Uniform' : rawSpectralData > 0.5 ? 'Moderate' : 'Irregular',
                    analysis: rawSpectralData > 0.7 ? 'Well-balanced frequency distribution' : 'Uneven spectral content'
                }
            };
        } else if (rawSpectralData && typeof rawSpectralData === 'object') {
            // Se for object com detailed
            tech.spectralUniformity = {
                value: rawSpectralData.value || rawSpectralData.variance || null,
                unit: rawSpectralData.unit || 'ratio',
                detailed: rawSpectralData.detailed || {
                    variance: rawSpectralData.variance || rawSpectralData.value || null,
                    distribution: rawSpectralData.distribution || 'Unknown',
                    analysis: rawSpectralData.analysis || 'Spectral analysis pending'
                }
            };
        } else {
            tech.spectralUniformity = null;
        }
        log('ğŸ“Š [NORMALIZE] Spectral Uniformity estruturado:', tech.spectralUniformity);
    } else {
        tech.spectralUniformity = null;
        log('âš ï¸ [NORMALIZE] Spectral Uniformity nÃ£o encontrado - spectralUniformity = null');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¢ SCORES E QUALIDADE - PRIORIZAÃ‡ÃƒO: comparisonResult.score > backendData.score
    // 
    // comparisonResult.score Ã© calculado pelo pipeline Ãºnico (compareWithTargets)
    // e garante consistÃªncia com tabela e sugestÃµes
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const comparisonScore = backendData.comparisonResult?.score;
    if (comparisonScore && Number.isFinite(comparisonScore.total)) {
        normalized.qualityOverall = comparisonScore.total;
        normalized.classification = comparisonScore.classification;
        normalized.qualityBreakdown = comparisonScore.breakdown || null;
        log('ğŸ¯ [NORMALIZE] Score do comparisonResult (FONTE ÃšNICA):', {
            total: comparisonScore.total,
            classification: comparisonScore.classification,
            breakdown: comparisonScore.breakdown
        });
    } else if (backendData.score && Number.isFinite(backendData.score)) {
        normalized.qualityOverall = backendData.score;
        log('âš ï¸ [NORMALIZE] Score legado (backendData.score):', backendData.score);
        
        if (backendData.qualityBreakdown && typeof backendData.qualityBreakdown === 'object') {
            normalized.qualityBreakdown = backendData.qualityBreakdown;
            log('ğŸ“Š [NORMALIZE] Quality breakdown real encontrado:', normalized.qualityBreakdown);
        } else {
            normalized.qualityBreakdown = null;
            log('âš ï¸ [NORMALIZE] Quality breakdown nÃ£o encontrado - qualityBreakdown = null');
        }
    } else {
        normalized.qualityOverall = null;
        normalized.qualityBreakdown = null;
        warn('âš ï¸ [NORMALIZE] Nenhum score disponÃ­vel');
    }
    
    // ğŸ“Š DADOS AUXILIARES DO NOVO FORMATO
    if (backendData.metadata) {
        normalized.processingMs = backendData.metadata.processingTime || backendData.performance?.workerTotalTimeMs || null;
        normalized.fileName = backendData.metadata.fileName || null;
        normalized.fileSize = backendData.metadata.fileSize || null;
        normalized.buildVersion = backendData.metadata.buildVersion || null;
        normalized.pipelineVersion = backendData.metadata.pipelineVersion || null;
    }
    
    if (backendData.classification) {
        normalized.classification = backendData.classification;
    }
    
    // ğŸ¯ DADOS DE SCORING DETALHADOS
    if (backendData.scoring) {
        normalized.scoring = backendData.scoring;
        log('ğŸ“Š [NORMALIZE] Dados de scoring encontrados:', backendData.scoring);
    }
    
    // ğŸš¨ PROBLEMAS/SUGESTÃ•ES DO NOVO ANALYZER - Integrar com structure completa
    if (source.problemsAnalysis || source.problems_analysis) {
        const problemsData = source.problemsAnalysis || source.problems_analysis;
        
        // Adicionar problemas do analyzer
        if (problemsData.problems && Array.isArray(problemsData.problems)) {
            problemsData.problems.forEach(problem => {
                normalized.problems.push({
                    type: problem.type || 'analysis',
                    message: problem.message || problem.description || 'Problema detectado',
                    solution: problem.solution || problem.recommendation || 'Verificar configuraÃ§Ãµes',
                    severity: problem.severity || 'medium',
                    source: 'problems_analyzer'
                });
            });
        }
        
        // Adicionar sugestÃµes do analyzer
        if (problemsData.suggestions && Array.isArray(problemsData.suggestions)) {
            problemsData.suggestions.forEach(suggestion => {
                normalized.suggestions.push({
                    type: suggestion.type || 'optimization',
                    message: suggestion.message || suggestion.description || 'SugestÃ£o de melhoria',
                    action: suggestion.action || suggestion.recommendation || 'Aplicar otimizaÃ§Ã£o',
                    details: suggestion.details || suggestion.context || 'Detalhes nÃ£o disponÃ­veis',
                    source: 'problems_analyzer'
                });
            });
        }
        
        log('ğŸ“Š [NORMALIZE] Problems/Suggestions do analyzer integrados:', {
            problemsAdded: problemsData.problems?.length || 0,
            suggestionsAdded: problemsData.suggestions?.length || 0
        });
    }
    
    // ğŸš¨ PROBLEMAS - Garantir que existam alguns problemas/sugestÃµes para exibir
    if (normalized.problems.length === 0) {
        // Detectar problemas bÃ¡sicos baseados nas mÃ©tricas - APENAS SE VALORES EXISTEM
        if (Number.isFinite(tech.clippingSamples) && tech.clippingSamples > 0) {
            normalized.problems.push({
                type: 'clipping',
                message: `Clipping detectado (${tech.clippingSamples} samples)`,
                solution: 'Reduzir o ganho geral ou usar limitador',
                severity: 'high'
            });
        }
        
        if (tech.dcOffset && tech.dcOffset.detailed) {
            const maxDcOffset = Math.max(Math.abs(tech.dcOffset.detailed.L || 0), Math.abs(tech.dcOffset.detailed.R || 0));
            if (maxDcOffset > 0.01) {
                normalized.problems.push({
                    type: 'dc_offset', 
                    message: `DC Offset detectado (L: ${tech.dcOffset.detailed.L?.toFixed(4) || 'N/A'}, R: ${tech.dcOffset.detailed.R?.toFixed(4) || 'N/A'})`,
                    solution: 'Aplicar filtro DC remove',
                    severity: tech.dcOffset.detailed.severity === 'High' ? 'high' : 'medium'
                });
            }
        } else if (Number.isFinite(tech.dcOffset) && Math.abs(tech.dcOffset) > 0.01) {
            normalized.problems.push({
                type: 'dc_offset', 
                message: `DC Offset detectado (${tech.dcOffset.toFixed(4)})`,
                solution: 'Aplicar filtro DC remove',
                severity: 'medium'
            });
        }
        
        if (Number.isFinite(tech.thdPercent) && tech.thdPercent > 1) {
            normalized.problems.push({
                type: 'thd',
                message: `THD elevado (${tech.thdPercent.toFixed(2)}%)`,
                solution: 'Verificar saturaÃ§Ã£o e distorÃ§Ã£o',
                severity: 'medium'
            });
        }
    }
    
    // ğŸ’¡ SUGESTÃ•ES - Garantir algumas sugestÃµes bÃ¡sicas - APENAS SE VALORES EXISTEM
    log('[SUGGESTIONS-GEN] ğŸ” Verificando geraÃ§Ã£o de sugestÃµes bÃ¡sicas...');
    log('[SUGGESTIONS-GEN] normalized.suggestions.length =', normalized.suggestions.length);
    log('[SUGGESTIONS-GEN] MÃ©tricas disponÃ­veis:', {
        dynamicRange: tech.dynamicRange,
        stereoCorrelation: tech.stereoCorrelation,
        lufsIntegrated: tech.lufsIntegrated,
        truePeakDbtp: tech.truePeakDbtp
    });
    
    if (normalized.suggestions.length === 0) {
        log('[SUGGESTIONS-GEN] âš ï¸ Nenhuma sugestÃ£o do backend - gerando sugestÃµes bÃ¡sicas...');
        
        if (Number.isFinite(tech.dynamicRange) && tech.dynamicRange < 8) {
            normalized.suggestions.push({
                type: 'dynamics',
                message: 'Faixa dinÃ¢mica baixa detectada',
                action: 'Considerar reduzir compressÃ£o/limitaÃ§Ã£o',
                details: `DR atual: ${tech.dynamicRange.toFixed(1)}dB`
            });
            log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de DR adicionada');
        }
        
        if (Number.isFinite(tech.stereoCorrelation) && tech.stereoCorrelation > 0.9) {
            normalized.suggestions.push({
                type: 'stereo',
                message: 'Imagem estÃ©reo muito estreita',
                action: 'Aumentar espacializaÃ§Ã£o estÃ©reo',
                details: `CorrelaÃ§Ã£o: ${tech.stereoCorrelation.toFixed(3)}`
            });
            log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de correlaÃ§Ã£o estÃ©reo adicionada');
        }
        
        if (Number.isFinite(tech.lufsIntegrated) && tech.lufsIntegrated < -30) {
            normalized.suggestions.push({
                type: 'loudness',
                message: 'Loudness muito baixo',
                action: 'Aumentar volume geral',
                details: `LUFS atual: ${tech.lufsIntegrated.toFixed(1)}`
            });
            log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de loudness baixo adicionada');
        }
        
        // ğŸ†• NOVAS SUGESTÃ•ES BASEADAS EM MÃ‰TRICAS COMUNS
        if (Number.isFinite(tech.truePeakDbtp) && tech.truePeakDbtp > -1.0) {
            normalized.suggestions.push({
                type: 'true_peak',
                message: 'True Peak muito prÃ³ximo de 0 dBFS',
                action: 'Reduzir True Peak para -1.0 dBTP para evitar clipping em conversÃµes',
                details: `True Peak atual: ${tech.truePeakDbtp.toFixed(2)} dBTP`
            });
            log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de True Peak adicionada');
        }
        
        if (Number.isFinite(tech.lra) && tech.lra < 3) {
            normalized.suggestions.push({
                type: 'lra',
                message: 'Loudness Range (LRA) muito baixo',
                action: 'Mix muito comprimido - considerar reduzir compressÃ£o para mais dinÃ¢mica',
                details: `LRA atual: ${tech.lra.toFixed(1)} LU`
            });
            log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de LRA adicionada');
        }
        
        // SugestÃµes baseadas em bandas de frequÃªncia (se disponÃ­veis)
        if (tech.spectral_balance || tech.bandEnergies) {
            const bands = tech.spectral_balance || tech.bandEnergies;
            if (bands.bass != null && bands.bass < -6) {
                normalized.suggestions.push({
                    type: 'frequency_bass',
                    message: 'Pouca energia em graves (bass)',
                    action: 'Considerar aumentar frequÃªncias baixas (60-250 Hz)',
                    details: `Bass: ${bands.bass.toFixed(1)} dB`
                });
                log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de bass baixo adicionada');
            }
            
            if (bands.presence != null && bands.presence < -8) {
                normalized.suggestions.push({
                    type: 'frequency_presence',
                    message: 'Pouca energia em presenÃ§a (presence)',
                    action: 'Aumentar clareza vocal e definiÃ§Ã£o (2-6 kHz)',
                    details: `Presence: ${bands.presence.toFixed(1)} dB`
                });
                log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de presence baixo adicionada');
            }
        }
        
        // SugestÃµes baseadas nas novas mÃ©tricas
        if (tech.spectralUniformity && tech.spectralUniformity.detailed) {
            const uniformity = tech.spectralUniformity.value || tech.spectralUniformity.detailed.variance;
            if (Number.isFinite(uniformity) && uniformity < 0.5) {
                normalized.suggestions.push({
                    type: 'spectral_balance',
                    message: 'DistribuiÃ§Ã£o espectral irregular detectada',
                    action: 'Considerar equalizaÃ§Ã£o para melhor balanceamento',
                    details: `Uniformidade: ${uniformity.toFixed(3)}, ${tech.spectralUniformity.detailed.distribution || 'AnÃ¡lise pendente'}`
                });
                log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de uniformidade espectral adicionada');
            }
        }
        
        if (tech.dominantFrequencies && tech.dominantFrequencies.detailed) {
            const primary = tech.dominantFrequencies.detailed.primary;
            if (Number.isFinite(primary)) {
                if (primary < 80) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'FrequÃªncia dominante muito baixa',
                        action: 'Verificar filtro high-pass ou conteÃºdo sub-bass excessivo',
                        details: `Freq. primÃ¡ria: ${primary.toFixed(1)} Hz`
                    });
                    log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de frequÃªncia baixa adicionada');
                } else if (primary > 8000) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'FrequÃªncia dominante muito alta',
                        action: 'Verificar conteÃºdo excessivo de agudos',
                        details: `Freq. primÃ¡ria: ${primary.toFixed(1)} Hz`
                    });
                    log('[SUGGESTIONS-GEN] âœ… SugestÃ£o de frequÃªncia alta adicionada');
                }
            }
        }
        
        // ğŸš¨ FALLBACK CRÃTICO: Sempre ter pelo menos uma sugestÃ£o
        if (normalized.suggestions.length === 0) {
            warn('[SUGGESTIONS-GEN] âš ï¸ Nenhuma sugestÃ£o gerada - criando fallback genÃ©rico');
            normalized.suggestions.push({
                type: 'general',
                message: 'AnÃ¡lise completa realizada',
                action: 'Suas mÃ©tricas de Ã¡udio foram analisadas com sucesso',
                details: 'Revise os cards de mÃ©tricas acima para mais detalhes'
            });
        }
        
        log('[SUGGESTIONS-GEN] âœ… Total de sugestÃµes geradas:', normalized.suggestions.length);
    } else {
        log('[SUGGESTIONS-GEN] âœ… Backend enviou', normalized.suggestions.length, 'sugestÃµes');
    }
    
    log('âœ… [NORMALIZE] NormalizaÃ§Ã£o concluÃ­da:', {
        hasTechnicalData: !!normalized.technicalData,
        hasSpectralBalance: !!normalized.technicalData.spectral_balance,
        hasBandEnergies: !!normalized.technicalData.bandEnergies,
        // Novas mÃ©tricas detalhadas
        hasDominantFreqs: !!normalized.technicalData.dominantFrequencies,
        hasDcOffset: !!normalized.technicalData.dcOffset,
        hasSpectralUniformity: !!normalized.technicalData.spectralUniformity,
        dominantFreqsStructure: normalized.technicalData.dominantFrequencies ? 'structured' : 'missing',
        dcOffsetStructure: normalized.technicalData.dcOffset ? 'structured' : 'missing',
        spectralUniformityStructure: normalized.technicalData.spectralUniformity ? 'structured' : 'missing',
        problemsCount: normalized.problems.length,
        suggestionsCount: normalized.suggestions.length,
        qualityScore: normalized.qualityOverall
    });
    
    // ğŸ¯ LOG DE RESUMO: MÃ©tricas normalizadas com sucesso
    const normalizedMetrics = Object.keys(normalized.technicalData).filter(key => 
        Number.isFinite(normalized.technicalData[key])
    );
    
    log('ğŸ“Š [NORMALIZE] Resumo da normalizaÃ§Ã£o:', {
        metricas_normalizadas: normalizedMetrics.length,
        metricas_disponiveis: normalizedMetrics,
        spectral_balance_ok: !!normalized.technicalData.spectral_balance,
        bandas_disponiveis: normalized.technicalData.bandEnergies ? 
            Object.keys(normalized.technicalData.bandEnergies).length : 0,
        problemas_detectados: normalized.problems.length,
        sugestoes_iniciais: normalized.suggestions.length
    });
    
    // ğŸ¯ LOG FINAL PARA DEBUG UI
    log("âœ… [UI_FIX] Normalized metrics:", {
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        spectral_balance: normalized.technicalData.spectral_balance,
        bandEnergies: normalized.technicalData.bandEnergies ? Object.keys(normalized.technicalData.bandEnergies) : null
    });
    
// =============== FUNÃ‡Ã•ES UTILITÃRIAS DO MODAL ===============

// ğŸ“ Ocultar Ã¡rea de upload do modal
function hideUploadArea() {
    __dbg('ğŸ“ Ocultando Ã¡rea de upload...');
    const uploadArea = document.getElementById('audioUploadArea');
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    } else {
        __dbg('âŒ Elemento audioUploadArea nÃ£o encontrado!');
    }
}

// ğŸ”„ Mostrar loading de anÃ¡lise
function showAnalysisLoading() {
    __dbg('ğŸ”„ Exibindo loading de anÃ¡lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const connectionHint = document.getElementById('audioConnectionHint');
    
    if (results) {
        results.style.display = 'none';
        __dbg('âœ… Results area ocultada');
    }
    
    // ğŸ¯ Garantir que a dica de conexÃ£o inicia oculta
    if (connectionHint) {
        connectionHint.style.display = 'none';
    }
    
    if (loading) {
        loading.style.display = 'block';
        __dbg('âœ… Loading area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
}

// â¹ï¸ Ocultar loading de anÃ¡lise
function hideAnalysisLoading() {
    __dbg('â¹ï¸ Ocultando loading de anÃ¡lise...');
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) {
        loading.style.display = 'none';
        __dbg('âœ… Loading area ocultada');
    } else {
        __dbg('âŒ Elemento audioAnalysisLoading nÃ£o encontrado!');
    }
}

// ğŸ“Š Mostrar resultados da anÃ¡lise
function showAnalysisResults() {
    __dbg('ğŸ“Š Exibindo resultados da anÃ¡lise...');
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('âœ… Upload area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'none';
        __dbg('âœ… Loading area ocultada');
    }
    
    if (results) {
        results.style.display = 'block';
        __dbg('âœ… Results area exibida');
    } else {
        __dbg('âŒ Elemento audioAnalysisResults nÃ£o encontrado!');
    }
}

// ğŸ¨ INJETAR ESTILOS CSS PARA STATUS DE TRUE PEAK
function injectTruePeakStatusStyles() {
    if (document.getElementById('truePeakStatusStyles')) return; // jÃ¡ injetado
    
    const style = document.createElement('style');
    style.id = 'truePeakStatusStyles';
    style.textContent = `
        /* Status do True Peak */
        .status-excellent {
            color: #00ff88 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(0, 255, 136, 0.3);
        }
        
        .status-ideal {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .status-good {
            color: #17a2b8 !important;
            font-weight: 600;
        }
        
        .status-warning {
            color: #ffc107 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(255, 193, 7, 0.3);
        }
        
        .status-critical {
            color: #dc3545 !important;
            font-weight: 700;
            text-shadow: 0 0 3px rgba(220, 53, 69, 0.4);
            animation: criticalPulse 2s infinite;
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Responsive para mobile */
        @media (max-width: 600px) {
            .status-excellent,
            .status-ideal,
            .status-good,
            .status-warning,
            .status-critical {
                font-size: 11px;
                font-weight: 600;
            }
        }
    `;
    
    document.head.appendChild(style);
    log('ğŸ¨ Estilos CSS do True Peak injetados');
}

// Injetar estilos automaticamente quando o DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', injectTruePeakStatusStyles);
} else {
    injectTruePeakStatusStyles();
}

// ğŸ¯ SISTEMA DE TOOLTIPS REMOVIDO - Agora usa tooltip-manager.js global
// O sistema antigo com showMetricTooltip/hideMetricTooltip foi substituÃ­do por event delegation
// Tooltips agora funcionam via data-tooltip-title e data-tooltip-body em qualquer elemento

// ğŸ§© CORREÃ‡ÃƒO #7: Logs de debug automÃ¡ticos para validaÃ§Ã£o
log("%c[SYSTEM CHECK] ğŸ” Debug ativo para validaÃ§Ã£o de fluxos genre/reference", "color:#7f00ff;font-weight:bold;");

// ========================================
// ğŸš¨ SISTEMA DE MONITORAMENTO CONTÃNUO DE JOBID
// ========================================
/**
 * Monitora se os jobIds permanecem diferentes em modo reference
 * Detecta e corrige contaminaÃ§Ã£o automaticamente
 */
(function startJobIdMonitor() {
    let monitorInterval = null;
    
    function checkJobIdIntegrity() {
        const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
        
        if (mode === 'reference') {
            const current = window.__CURRENT_JOB_ID__;
            const reference = window.__REFERENCE_JOB_ID__;
            
            // ValidaÃ§Ã£o crÃ­tica
            if (current && reference && current === reference) {
                error('ğŸš¨ [MONITOR] CONTAMINAÃ‡ÃƒO DETECTADA!');
                error('   currentJobId:', current);
                error('   referenceJobId:', reference);
                error('   Ambos sÃ£o IGUAIS - isso NÃƒO deveria acontecer!');
                console.trace();
                
                // Tenta recuperar do sessionStorage
                const recoveredJobId = sessionStorage.getItem('currentJobId');
                if (recoveredJobId && recoveredJobId !== reference) {
                    window.__CURRENT_JOB_ID__ = recoveredJobId;
                    log('âœ… [MONITOR] JobId recuperado do sessionStorage:', recoveredJobId);
                    log('âœ… [MONITOR] ContaminaÃ§Ã£o corrigida automaticamente');
                } else {
                    error('âŒ [MONITOR] NÃ£o foi possÃ­vel recuperar currentJobId do sessionStorage');
                    error('âŒ [MONITOR] Sistema pode estar em estado inconsistente');
                }
            }
        }
    }
    
    // Inicia monitoramento quando entrar em modo reference
    window.addEventListener('analysisMode', (e) => {
        if (e.detail?.mode === 'reference' && !monitorInterval) {
            log('ğŸ” [MONITOR] Iniciando monitoramento de jobIds (intervalo: 1s)');
            monitorInterval = setInterval(checkJobIdIntegrity, 1000);
        } else if (e.detail?.mode !== 'reference' && monitorInterval) {
            log('ğŸ” [MONITOR] Parando monitoramento de jobIds');
            clearInterval(monitorInterval);
            monitorInterval = null;
        }
    });
    
    // Inicia imediatamente se jÃ¡ estiver em modo reference
    if (window.currentAnalysisMode === 'reference') {
        log('ğŸ” [MONITOR] Modo reference detectado - iniciando monitoramento');
        monitorInterval = setInterval(checkJobIdIntegrity, 1000);
    }
    
    log('âœ… [MONITOR] Sistema de monitoramento de jobIds ativado');
})();

window.addEventListener("beforeunload", () => {
    log("ğŸ§¹ [CLEANUP] Encerrando sessÃ£o de anÃ¡lise e limpando estado.");
});

// ğŸ¯ PATCH DEFINITIVO: Carregar correÃ§Ã£o da tabela de referÃªncia
(function loadReferenceTablePatch() {
    log('ğŸ“¦ [INTEGRATION] Carregando patch definitivo da tabela de referÃªncia...');
    
    // Tentar carregar o patch definitivo
    const script = document.createElement('script');
    script.src = 'patch-tabela-referencia-final.js';
    script.onload = function() {
        log('âœ… [INTEGRATION] Patch definitivo carregado com sucesso');
    };
    script.onerror = function() {
        warn('âš ï¸ [INTEGRATION] NÃ£o foi possÃ­vel carregar patch-tabela-referencia-final.js');
        log('ğŸ’¡ [INTEGRATION] A correÃ§Ã£o jÃ¡ foi aplicada diretamente no cÃ³digo');
    };
    
    document.head.appendChild(script);
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§ª V3.4 TEST BLOCK: TESTES DO SCORE ENGINE COM CAPS PROPORCIONAIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/**
 * Testes para validar o sistema de gates proporcionais V3.4
 * Execute no console: window.__testV34GatesProportional()
 */
window.__testV34GatesProportional = function() {
    log('\n');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('ğŸ§ª V3.4 TEST BLOCK: GATES PROPORCIONAIS');
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    // FunÃ§Ãµes de cap (cÃ³pia local para teste)
    function calculateTruePeakCap(tp, max) {
        if (tp === null || tp <= max) return 100;
        const excess = tp - max;
        return Math.max(35, Math.round(95 - (excess * 20)));
    }
    
    function calculateLufsCap(lufsValue, max) {
        if (lufsValue === null || lufsValue <= max) return 100;
        const excess = lufsValue - max;
        return Math.max(50, Math.round(95 - (excess * 7.5)));
    }
    
    const tests = [
        // CenÃ¡rio 1: TP OK (-2.0 dBTP, limite -1.0)
        {
            name: 'TP OK',
            tp: -2.0,
            tpMax: -1.0,
            expectedCap: 100,
            description: 'True Peak abaixo do limite'
        },
        // CenÃ¡rio 2: TP levemente acima (-0.5 dBTP, limite -1.0)
        {
            name: 'TP Leve',
            tp: -0.5,
            tpMax: -1.0,
            expectedCapRange: [83, 87], // 95 - 0.5*20 = 85 (Â±2)
            description: 'True Peak +0.5 dB acima'
        },
        // CenÃ¡rio 3: TP positivo pequeno (+0.3 dBTP)
        {
            name: 'TP Positivo Pequeno',
            tp: 0.3,
            tpMax: -1.0,
            expectedCapRange: [65, 75], // 95 - 1.3*20 = 69 (Â±5)
            description: 'True Peak +1.3 dB acima (leve clipping)'
        },
        // CenÃ¡rio 4: TP positivo alto (+2.0 dBTP)
        {
            name: 'TP Positivo Alto',
            tp: 2.0,
            tpMax: -1.0,
            expectedCapRange: [35, 45], // 95 - 3*20 = 35 (mÃ­nimo)
            description: 'True Peak +3 dB acima (clipping severo)'
        },
        // CenÃ¡rio 5: LUFS OK (-14 LUFS, limite -12)
        {
            name: 'LUFS OK',
            lufs: -14,
            lufsMax: -12,
            expectedCap: 100,
            description: 'LUFS abaixo do limite'
        },
        // CenÃ¡rio 6: LUFS +2 LU acima
        {
            name: 'LUFS +2 LU',
            lufs: -10,
            lufsMax: -12,
            expectedCapRange: [78, 82], // 95 - 2*7.5 = 80 (Â±2)
            description: 'LUFS +2 LU acima'
        },
        // CenÃ¡rio 7: LUFS +6 LU acima (loudness war)
        {
            name: 'LUFS +6 LU',
            lufs: -6,
            lufsMax: -12,
            expectedCap: 50, // MÃ­nimo
            description: 'LUFS +6 LU acima (loudness war)'
        }
    ];
    
    let passed = 0;
    let failed = 0;
    
    tests.forEach((test, i) => {
        let actualCap;
        let isPass = false;
        
        if (test.tp !== undefined) {
            actualCap = calculateTruePeakCap(test.tp, test.tpMax);
        } else if (test.lufs !== undefined) {
            actualCap = calculateLufsCap(test.lufs, test.lufsMax);
        }
        
        if (test.expectedCap !== undefined) {
            isPass = actualCap === test.expectedCap;
        } else if (test.expectedCapRange) {
            isPass = actualCap >= test.expectedCapRange[0] && actualCap <= test.expectedCapRange[1];
        }
        
        const icon = isPass ? 'âœ…' : 'âŒ';
        const expected = test.expectedCap ?? `${test.expectedCapRange[0]}-${test.expectedCapRange[1]}`;
        
        log(`${icon} ${i+1}. ${test.name}: Cap=${actualCap}% (esperado: ${expected}%)`);
        log(`   â””â”€ ${test.description}`);
        
        if (isPass) passed++; else failed++;
    });
    
    log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    log(`ğŸ“Š RESULTADO: ${passed}/${tests.length} testes passaram`);
    
    if (failed === 0) {
        log('ğŸ‰ TODOS OS TESTES PASSARAM! V3.4 funcionando corretamente.');
    } else {
        error(`âš ï¸ ${failed} teste(s) falharam. Verifique a implementaÃ§Ã£o.`);
    }
    
    log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    log('\n');
    
    return { passed, failed, total: tests.length };
};

// Auto-log para confirmar disponibilidade
log('ğŸ§ª [V3.4] FunÃ§Ã£o de teste disponÃ­vel: window.__testV34GatesProportional()');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ PLANO DE CORREÃ‡ÃƒO COMPLETO - FunÃ§Ã£o Global de InjeÃ§Ã£o
// Posiciona o botÃ£o FORA da seÃ§Ã£o de sugestÃµes, apÃ³s o aiHelperText
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ”§ Detecta a categoria de uma mÃ©trica pelo nome
 * Usa METRIC_CATEGORY_MAP definido no topo do arquivo
 */
function detectMetricCategory(metricName) {
    if (!metricName) return 'other';
    
    const normalized = metricName.toLowerCase();
    
    // Tentar match exato primeiro
    for (const [key, category] of Object.entries(METRIC_CATEGORY_MAP)) {
        if (normalized.includes(key.toLowerCase())) {
            return category;
        }
    }
    
    // DetecÃ§Ã£o por padrÃ£o de frequÃªncia (Hz, kHz)
    if (normalized.includes('hz') || normalized.includes('khz')) {
        return 'frequency';
    }
    
    // DetecÃ§Ã£o por padrÃ£o de loudness
    if (normalized.includes('db') || normalized.includes('lufs')) {
        return 'loudness';
    }
    
    return 'other';
}

/**
 * ğŸ“‹ PLANO DE CORREÃ‡ÃƒO - Apenas registra event listener
 * O botÃ£o jÃ¡ existe no HTML do modal (index.html)
 */
window.injectCorrectionPlanButtonOutside = function() {
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    if (!btn) {
        warn('[CORRECTION-PLAN] âš ï¸ BotÃ£o #btnGenerateCorrectionPlan nÃ£o encontrado no DOM');
        return;
    }
    
    // Verificar se jÃ¡ tem listener registrado
    if (btn.dataset.listenerAttached === 'true') {
        log('[CORRECTION-PLAN] âœ… Listener jÃ¡ registrado - skip');
        return;
    }
    
    // Registrar event listener
    btn.addEventListener('click', handleGenerateCorrectionPlan);
    btn.dataset.listenerAttached = 'true';
    
    log('[CORRECTION-PLAN] âœ… Event listener registrado no botÃ£o');
};

/**
 * ğŸ¨ Estilos do botÃ£o - jÃ¡ definidos no index.html <style>
 * Mantido apenas para compatibilidade com chamadas externas
 */
function injectCorrectionPlanStyles() {
    // Estilos jÃ¡ estÃ£o no index.html - nada a fazer
    log('[CORRECTION-PLAN] â„¹ï¸ Estilos jÃ¡ carregados via HTML');
}

/**
 * ğŸ†• Extrai problemas diretamente da tabela de mÃ©tricas no DOM
 * VERSÃƒO REFATORADA com categorizaÃ§Ã£o e validaÃ§Ã£o robusta
 */
function extractProblemsFromTableDOM() {
    log('[CORRECTION-PLAN] ğŸ” Extraindo problemas da tabela DOM...');
    
    const problems = [];
    const categorizedProblems = {
        loudness: [],
        frequency: [],
        dynamics: [],
        stereo: [],
        other: []
    };
    
    // Buscar a tabela de comparaÃ§Ã£o de gÃªnero
    const table = document.querySelector('.classic-genre-table');
    
    if (!table) {
        warn('[CORRECTION-PLAN] âš ï¸ Tabela .classic-genre-table nÃ£o encontrada');
        return problems;
    }
    
    // Iterar sobre as linhas do tbody
    const rows = table.querySelectorAll('tbody tr');
    
    log('[CORRECTION-PLAN] ğŸ“‹ Linhas encontradas na tabela:', rows.length);
    
    rows.forEach((row, index) => {
        const cells = row.querySelectorAll('td');
        
        if (cells.length < 6) {
            warn(`[CORRECTION-PLAN] âš ï¸ Linha ${index} tem menos de 6 cÃ©lulas, ignorando`);
            return;
        }
        
        // Extrair dados das cÃ©lulas
        // Estrutura: MÃ©trica | Valor | Alvo | DiferenÃ§a | Severidade | AÃ§Ã£o
        const metric = cells[0]?.textContent?.trim() || '';
        const value = cells[1]?.textContent?.trim() || '';
        const target = cells[2]?.textContent?.trim() || '';
        const diff = cells[3]?.textContent?.trim() || '';
        const severityEl = cells[4];
        const action = cells[5]?.textContent?.trim() || '';
        
        // Validar dados essenciais - NUNCA aceitar undefined
        if (!metric || metric === 'undefined' || !value || value === 'undefined') {
            warn(`[CORRECTION-PLAN] âš ï¸ Linha ${index} tem dados invÃ¡lidos (metric: ${metric}, value: ${value})`);
            return;
        }
        
        // Extrair severidade (pode estar em span ou texto direto)
        let severity = severityEl?.textContent?.trim() || '';
        const severitySpan = severityEl?.querySelector('.metric-severity');
        if (severitySpan) {
            severity = severitySpan.textContent?.trim() || severity;
        }
        
        // Verificar se a linha tem classe de status
        const rowClass = row.className || '';
        if (!severity || severity === '') {
            if (rowClass.includes('critical')) severity = 'CRÃTICA';
            else if (rowClass.includes('warning')) severity = 'ATENÃ‡ÃƒO';
            else if (rowClass.includes('caution')) severity = 'ATENÃ‡ÃƒO';
            else if (rowClass.includes('ok')) severity = 'OK';
        }
        
        // ğŸ›¡ï¸ USAR NORMALIZESEVERITY - NUNCA .toUpperCase() direto
        const normalizedSeverity = normalizeSeverity(severity);
        
        // ğŸ›¡ï¸ USAR ISPROBLEMATICSEVERITY - LÃ³gica centralizada
        const isProblematic = isProblematicSeverity(severity);
        
        // Detectar categoria da mÃ©trica
        const category = detectMetricCategory(metric);
        
        // Criar objeto de problema
        const problem = {
            id: metric.toLowerCase().replace(/[^a-z0-9]/g, '_'),
            metric: metric,
            value: value,
            target: target,
            difference: diff,
            severity: normalizedSeverity, // JÃ¡ normalizado
            action: action,
            category: category,
            isProblematic: isProblematic,
            description: action || `${metric} estÃ¡ fora do padrÃ£o: ${value} (alvo: ${target})`
        };
        
        // Adicionar a lista geral (incluindo OKs para debug)
        problems.push(problem);
        
        // Categorizar apenas problemas reais
        if (isProblematic && categorizedProblems[category]) {
            categorizedProblems[category].push(problem);
        }
    });
    
    // Log de diagnÃ³stico detalhado
    log('[CORRECTION-PLAN] ğŸ“Š Problemas por categoria:', {
        loudness: categorizedProblems.loudness.length,
        frequency: categorizedProblems.frequency.length,
        dynamics: categorizedProblems.dynamics.length,
        stereo: categorizedProblems.stereo.length,
        total: problems.filter(p => p.isProblematic).length
    });
    
    // Retornar apenas problemas reais (CRÃTICA ou ATENÃ‡ÃƒO)
    const realProblems = problems.filter(p => p.isProblematic);
    
    // Salvar categorizaÃ§Ã£o para uso posterior
    window.__CORRECTION_PLAN_CATEGORIES__ = categorizedProblems;
    
    log('[CORRECTION-PLAN] âœ… Total de problemas reais extraÃ­dos:', realProblems.length);
    
    return realProblems;
}

/**
 * ğŸ†• Gera um resumo estruturado dos problemas para enviar Ã  API
 * Agrupa por categoria e formata para o prompt da IA
 */
function buildProblemsSummary(problems) {
    const categories = window.__CORRECTION_PLAN_CATEGORIES__ || {
        loudness: [],
        frequency: [],
        dynamics: [],
        stereo: [],
        other: []
    };
    
    const summary = {
        hasLoudnessProblems: categories.loudness.length > 0,
        hasFrequencyProblems: categories.frequency.length > 0,
        hasDynamicsProblems: categories.dynamics.length > 0,
        hasStereoProblems: categories.stereo.length > 0,
        
        loudnessProblems: categories.loudness.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        frequencyProblems: categories.frequency.map(p => ({
            band: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        dynamicsProblems: categories.dynamics.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        stereoProblems: categories.stereo.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        totalProblems: problems.length,
        // ğŸ›¡ï¸ USAR NORMALIZESEVERITY - Blindagem contra undefined/objeto
        criticalCount: problems.filter(p => p && normalizeSeverity(p.severity).includes('CRÃT')).length,
        attentionCount: problems.filter(p => p && normalizeSeverity(p.severity).includes('ATEN')).length
    };
    
    return summary;
}

/**
 * ğŸ”¥ Handler para gerar o Plano de CorreÃ§Ã£o (funÃ§Ã£o global)
 */
async function handleGenerateCorrectionPlan() {
    log('[CORRECTION-PLAN] ğŸš€ handleGenerateCorrectionPlan() INICIADO!');
    
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    if (!btn) {
        error('[CORRECTION-PLAN] âŒ BotÃ£o nÃ£o encontrado');
        return;
    }
    
    log('[CORRECTION-PLAN] âœ… BotÃ£o encontrado:', btn);
    
    // Obter anÃ¡lise atual
    const analysis = window.__CURRENT_ANALYSIS__ || 
                     window.currentModalAnalysis || 
                     window.__soundyAI?.analysis;
    
    log('[CORRECTION-PLAN] ğŸ“Š AnÃ¡lise encontrada:', !!analysis, {
        __CURRENT_ANALYSIS__: !!window.__CURRENT_ANALYSIS__,
        currentModalAnalysis: !!window.currentModalAnalysis,
        __soundyAI_analysis: !!window.__soundyAI?.analysis
    });
    
    if (!analysis) {
        showCorrectionPlanError('Nenhuma anÃ¡lise encontrada. Analise uma mÃºsica primeiro.');
        return;
    }
    
    // Verificar autenticaÃ§Ã£o Firebase (mÃºltiplos caminhos)
    const firebaseAuth = window.firebase?.auth?.() || window.auth;
    const user = firebaseAuth?.currentUser;
    
    log('[CORRECTION-PLAN] ğŸ” Auth check:', {
        hasFirebaseAuth: !!firebaseAuth,
        hasUser: !!user,
        userEmail: user?.email
    });
    
    if (!user) {
        showCorrectionPlanError('VocÃª precisa estar logado para gerar um plano.');
        return;
    }
    
    // Estado de loading
    const originalContent = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = `
        <span class="cta-loading">
            <span class="cta-spinner"></span>
            <span>Gerando...</span>
        </span>
    `;
    
    // Limpar erro anterior
    const existingError = document.querySelector('.correction-plan-error');
    if (existingError) existingError.remove();
    
    try {
        // Obter token
        const token = typeof user.getIdToken === 'function' 
            ? await user.getIdToken() 
            : user.accessToken;
        
        if (!token) {
            throw new Error('NÃ£o foi possÃ­vel obter token de autenticaÃ§Ã£o');
        }
        
        // Preparar payload
        // ğŸ”§ FIX v5: PARIDADE TOTAL - Usar EXATAMENTE os mesmos problemas da anÃ¡lise
        // NUNCA extrair do DOM - isso pode descartar problemas
        let problemsToSend = [];
        let problemSource = '';
        
        // ğŸ¯ FONTE 1: analysis.problems (fonte primÃ¡ria)
        if (analysis.problems && analysis.problems.length > 0) {
            problemsToSend = analysis.problems;
            problemSource = 'analysis.problems';
            log('[CORRECTION-PLAN] âœ… Usando analysis.problems:', problemsToSend.length);
        }
        // ğŸ¯ FONTE 2: analysis.suggestions (fallback)
        else if (analysis.suggestions && analysis.suggestions.length > 0) {
            const suggestions = analysis.suggestions;
            problemsToSend = suggestions
                .filter(s => s.severity !== 'ok' && s.severity !== 'info') // Apenas problemas reais
                .map(s => ({
                    id: s.metric || s.metricName || s.name || 'unknown',
                    metric: s.metric || s.metricName || s.name || 'unknown',
                    value: s.currentValue || s.value || s.measured || 'N/A',
                    target: s.targetValue || s.target || s.ideal || 'N/A',
                    severity: s.severity || s.priority || 'medium',
                    category: detectMetricCategory(s.metric || s.metricName || s.name || ''),
                    description: s.problem || s.description || s.title || '',
                    action: s.action || s.recommendation || ''
                }));
            problemSource = 'analysis.suggestions (filtrado)';
            log('[CORRECTION-PLAN] âœ… Usando analysis.suggestions filtrado:', problemsToSend.length);
        }
        // ğŸ¯ FONTE 3: Extrair da tabela DOM (Ãºltimo recurso)
        else {
            problemsToSend = extractProblemsFromTableDOM();
            problemSource = 'table-dom (fallback)';
            log('[CORRECTION-PLAN] âš ï¸ Usando table-dom como fallback:', problemsToSend.length);
        }
        
        // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO CRÃTICA: Verificar se True Peak estÃ¡ presente quando deveria
        const hasTruePeakIssue = analysis.technicalData?.truePeakDbtp != null && 
                                 analysis.technicalData.truePeakDbtp > -1.0; // Threshold de problema
        
        const hasTruePeakInProblems = problemsToSend.some(p => 
            p.metric && (
                p.metric.toLowerCase().includes('true peak') ||
                p.metric.toLowerCase().includes('truepeak') ||
                p.metric.toLowerCase().includes('pico real') ||
                p.id?.toLowerCase().includes('truepeak')
            )
        );
        
        if (hasTruePeakIssue && !hasTruePeakInProblems) {
            warn('[CORRECTION-PLAN] âš ï¸ TRUE PEAK DETECTADO MAS AUSENTE! Injetando manualmente...');
            
            // Injetar True Peak manualmente
            const truePeakProblem = {
                id: 'truepeak_missing',
                metric: 'True Peak',
                value: `${analysis.technicalData.truePeakDbtp.toFixed(2)} dBTP`,
                target: '-1.0 dBTP',
                severity: analysis.technicalData.truePeakDbtp > 0 ? 'CRÃTICA' : 'ATENÃ‡ÃƒO',
                category: 'dynamics',
                description: analysis.technicalData.truePeakDbtp > 0 
                    ? 'Pico real acima de 0 dBTP - risco de clipping digital'
                    : 'Pico real acima do ideal - pode causar distorÃ§Ã£o em conversÃµes',
                action: 'Aplicar limiting com True Peak Detection ativado'
            };
            
            problemsToSend.push(truePeakProblem);
            log('[CORRECTION-PLAN] âœ… True Peak injetado:', truePeakProblem);
        }
        
        // ğŸ›¡ï¸ VALIDAÃ‡ÃƒO ADICIONAL: Garantir outros problemas tÃ©cnicos crÃ­ticos
        const tech = analysis.technicalData || {};
        
        // Verificar LUFS Integrado
        const hasLufsIssue = tech.lufsIntegrated != null && 
                            (tech.lufsIntegrated < -20 || tech.lufsIntegrated > -8);
        const hasLufsInProblems = problemsToSend.some(p => 
            p.metric?.toLowerCase().includes('lufs') || p.id?.toLowerCase().includes('lufs')
        );
        
        if (hasLufsIssue && !hasLufsInProblems) {
            warn('[CORRECTION-PLAN] âš ï¸ LUFS fora do padrÃ£o mas ausente! Injetando...');
            problemsToSend.push({
                id: 'lufs_missing',
                metric: 'LUFS Integrado',
                value: `${tech.lufsIntegrated.toFixed(2)} LUFS`,
                target: '-14 LUFS (streaming)',
                severity: tech.lufsIntegrated < -20 ? 'CRÃTICA' : 'ATENÃ‡ÃƒO',
                category: 'loudness',
                description: tech.lufsIntegrated < -20 
                    ? 'Loudness muito baixo - Ã¡udio serÃ¡ rejeitado em plataformas'
                    : 'Loudness acima do ideal - causarÃ¡ normalizaÃ§Ã£o',
                action: 'Ajustar gain para atingir -14 LUFS integrado'
            });
        }
        
        // Verificar Dynamic Range
        const hasDRIssue = tech.dynamicRange != null && 
                          (tech.dynamicRange < 4 || tech.dynamicRange > 20);
        const hasDRInProblems = problemsToSend.some(p => 
            p.metric?.toLowerCase().includes('dynamic range') || 
            p.metric?.toLowerCase().includes('dr ') ||
            p.id?.toLowerCase().includes('dynamicrange')
        );
        
        if (hasDRIssue && !hasDRInProblems) {
            warn('[CORRECTION-PLAN] âš ï¸ Dynamic Range problemÃ¡tico mas ausente! Injetando...');
            problemsToSend.push({
                id: 'dr_missing',
                metric: 'Dynamic Range',
                value: `${tech.dynamicRange.toFixed(1)} dB`,
                target: '8-12 dB (ideal)',
                severity: tech.dynamicRange < 4 ? 'CRÃTICA' : 'ATENÃ‡ÃƒO',
                category: 'dynamics',
                description: tech.dynamicRange < 4
                    ? 'DinÃ¢mica muito comprimida - som "achatado"'
                    : 'DinÃ¢mica excessiva - pode soar inconsistente',
                action: tech.dynamicRange < 4
                    ? 'Reduzir compressÃ£o/limiting excessivo'
                    : 'Aplicar compressÃ£o para controlar dinÃ¢mica'
            });
        }
        
        log('[CORRECTION-PLAN] ğŸ“Š Total apÃ³s validaÃ§Ãµes:', problemsToSend.length, 'problemas');
        
        // ğŸ†• Construir resumo categorizado para melhor processamento pela IA
        const problemsSummary = buildProblemsSummary(problemsToSend);
        
        log('[CORRECTION-PLAN] ğŸ“Š Problemas extraÃ­dos:', problemsToSend.length, 'fonte:', problemSource);
        log('[CORRECTION-PLAN] ğŸ“Š Resumo por categoria:', {
            loudness: problemsSummary.loudnessProblems.length,
            frequency: problemsSummary.frequencyProblems.length,
            dynamics: problemsSummary.dynamicsProblems.length,
            stereo: problemsSummary.stereoProblems.length
        });
        
        // ğŸ” LOG DETALHADO: Listar TODOS os problemas encontrados
        console.group('[CORRECTION-PLAN] ğŸ“‹ LISTA COMPLETA DE PROBLEMAS');
        problemsToSend.forEach((p, i) => {
            log(`${i + 1}. ${p.metric || p.id}`, {
                value: p.value,
                target: p.target,
                severity: p.severity,
                category: p.category
            });
        });
        console.groupEnd();
        
        // ğŸ¯ ASSERT FINAL: Confirmar que temos problemas suficientes
        if (problemsToSend.length === 0) {
            error('[CORRECTION-PLAN] âŒ ERRO CRÃTICO: Nenhum problema encontrado!');
            error('[CORRECTION-PLAN] analysis.problems:', analysis.problems?.length || 0);
            error('[CORRECTION-PLAN] analysis.suggestions:', analysis.suggestions?.length || 0);
            error('[CORRECTION-PLAN] technicalData:', !!analysis.technicalData);
            
            showCorrectionPlanError('Nenhum problema detectado na anÃ¡lise. Analise novamente.');
            btn.disabled = false;
            btn.innerHTML = originalContent;
            return;
        }
        
        const payload = {
            analysisId: analysis.jobId || analysis.id,
            technicalData: analysis.technicalData || {},
            suggestions: analysis.suggestions || analysis.aiSuggestions || [],
            problems: problemsToSend,
            problemsSummary: problemsSummary, // ğŸ†• Resumo categorizado
            metadata: {
                fileName: analysis.metadata?.fileName || analysis.fileName || 'Sem nome',
                genre: analysis.genre || analysis.metadata?.genre || 'generic',
                daw: getUserDAWForPlan(),
                level: getUserLevelForPlan()
            },
            scores: analysis.scores || { final: analysis.score }
        };
        
        log('[CORRECTION-PLAN] ğŸ“¤ Enviando para API:', {
            analysisId: payload.analysisId,
            genre: payload.metadata.genre,
            daw: payload.metadata.daw,
            level: payload.metadata.level,
            suggestionsCount: payload.suggestions.length,
            problemsCount: payload.problems.length
        });
        
        // URL da API - mesmo domÃ­nio (rota no server.js principal)
        const apiUrl = '/api/correction-plan';
        log('[CORRECTION-PLAN] ğŸ¯ URL:', apiUrl);
        
        // Chamar API
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(payload)
        });
        
        // ğŸ” DEBUG: Capturar resposta bruta ANTES de parsear
        const responseText = await response.text();
        log('[CORRECTION-PLAN] ğŸ“¥ Status:', response.status);
        log('[CORRECTION-PLAN] ğŸ“¥ Headers:', Object.fromEntries(response.headers.entries()));
        log('[CORRECTION-PLAN] ğŸ“¥ Resposta bruta (primeiros 500 chars):', responseText.substring(0, 500));
        
        // Verificar se Ã© HTML (erro do servidor)
        if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {
            error('[CORRECTION-PLAN] âŒ Servidor retornou HTML em vez de JSON!');
            throw new Error('Servidor retornou pÃ¡gina de erro. A rota /api/correction-plan pode nÃ£o existir.');
        }
        
        // Parsear JSON manualmente
        let result;
        try {
            result = JSON.parse(responseText);
        } catch (parseError) {
            error('[CORRECTION-PLAN] âŒ Erro ao parsear JSON:', parseError);
            error('[CORRECTION-PLAN] Resposta completa:', responseText);
            throw new Error('Resposta invÃ¡lida do servidor (nÃ£o Ã© JSON vÃ¡lido)');
        }
        
        if (!response.ok) {
            throw new Error(result.error || result.message || 'Erro ao gerar plano');
        }
        
        if (!result.success || !result.planId) {
            throw new Error('Resposta invÃ¡lida da API');
        }
        
        log('[CORRECTION-PLAN] âœ… Plano gerado com sucesso:', {
            planId: result.planId,
            stepsCount: result.stepsCount,
            cached: result.cached
        });
        
        // ğŸ”§ FIX: Abrir em NOVA ABA de forma que nÃ£o seja bloqueado
        const planUrl = `/plano.html?id=${result.planId}`;
        
        // Tentar abrir nova aba
        const newWindow = window.open(planUrl, '_blank');
        
        // Se foi bloqueado, mostrar link clicÃ¡vel
        if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
            log('[CORRECTION-PLAN] âš ï¸ Popup bloqueado, mostrando link');
            
            // Restaurar botÃ£o
            btn.disabled = false;
            btn.innerHTML = originalContent;
            
            // Mostrar link clicÃ¡vel
            const linkContainer = document.createElement('div');
            linkContainer.className = 'correction-plan-success';
            linkContainer.innerHTML = `
                <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 16px 20px; border-radius: 12px; margin-top: 12px; text-align: center;">
                    <p style="color: white; margin: 0 0 10px 0; font-weight: 600;">âœ… Plano gerado com sucesso!</p>
                    <a href="${planUrl}" target="_blank" style="display: inline-block; background: white; color: #059669; padding: 10px 24px; border-radius: 8px; text-decoration: none; font-weight: 600;">
                        ğŸš€ Abrir Plano de CorreÃ§Ã£o
                    </a>
                </div>
            `;
            btn.parentElement.appendChild(linkContainer);
            
            // Remover apÃ³s 30 segundos
            setTimeout(() => linkContainer.remove(), 30000);
        } else {
            // Restaurar botÃ£o
            btn.disabled = false;
            btn.innerHTML = originalContent;
        }
        
    } catch (error) {
        error('[CORRECTION-PLAN] âŒ Erro:', error);
        
        // Restaurar botÃ£o
        btn.disabled = false;
        btn.innerHTML = originalContent;
        
        // Mostrar erro apropriado
        let errorMessage = error.message;
        
        if (error.message.includes('rate limit') || error.message.includes('limite')) {
            errorMessage = 'VocÃª atingiu o limite de requisiÃ§Ãµes. Aguarde alguns minutos.';
        } else if (error.message.includes('monthly limit') || error.message.includes('mensal')) {
            errorMessage = 'Limite mensal atingido. FaÃ§a upgrade do seu plano para mais planos.';
        } else if (error.message.includes('401') || error.message.includes('auth')) {
            errorMessage = 'SessÃ£o expirada. FaÃ§a login novamente.';
        }
        
        showCorrectionPlanError(errorMessage);
    }
}

/**
 * ğŸ› ï¸ ObtÃ©m a DAW do usuÃ¡rio
 */
function getUserDAWForPlan() {
    const profile = window.__USER_PROFILE__ || 
                    JSON.parse(localStorage.getItem('soundy_user_profile') || '{}');
    if (profile.daw) return profile.daw;
    
    const interview = JSON.parse(localStorage.getItem('soundy_interview') || '{}');
    if (interview.daw) return interview.daw;
    
    return 'generic';
}

/**
 * ğŸ› ï¸ ObtÃ©m o nÃ­vel do usuÃ¡rio
 */
function getUserLevelForPlan() {
    const profile = window.__USER_PROFILE__ || 
                    JSON.parse(localStorage.getItem('soundy_user_profile') || '{}');
    if (profile.level) return profile.level;
    
    const interview = JSON.parse(localStorage.getItem('soundy_interview') || '{}');
    if (interview.level) return interview.level;
    
    return 'intermediario';
}

/**
 * âŒ Exibe erro no container de aÃ§Ãµes
 */
function showCorrectionPlanError(message) {
    const actionsContainer = document.querySelector('.analysis-actions');
    if (!actionsContainer) return;
    
    // Remover erro anterior se existir
    const existing = actionsContainer.querySelector('.correction-plan-error');
    if (existing) existing.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'correction-plan-error';
    errorDiv.textContent = `âŒ ${message}`;
    
    // Inserir erro no final do container
    actionsContainer.appendChild(errorDiv);
    
    // Auto-remover apÃ³s 5 segundos
    setTimeout(() => errorDiv.remove(), 5000);
}

// Expor funÃ§Ãµes globalmente para serem chamadas por outros scripts
window.injectCorrectionPlanStyles = injectCorrectionPlanStyles;
window.handleGenerateCorrectionPlan = handleGenerateCorrectionPlan;
window.getUserDAWForPlan = getUserDAWForPlan;
window.getUserLevelForPlan = getUserLevelForPlan;
window.showCorrectionPlanError = showCorrectionPlanError;

// ğŸ“‹ AUTO-REGISTRO: Observer para registrar event listener quando modal fica visÃ­vel
(function setupCorrectionPlanAutoAttach() {
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    // Se o botÃ£o existir, registrar listener imediatamente
    if (btn && btn.dataset.listenerAttached !== 'true') {
        btn.addEventListener('click', handleGenerateCorrectionPlan);
        btn.dataset.listenerAttached = 'true';
        log('[CORRECTION-PLAN] âœ… Event listener registrado na inicializaÃ§Ã£o');
    }
    
    // Observer para detectar quando o modal de resultados fica visÃ­vel
    const audioResults = document.getElementById('audioAnalysisResults');
    if (audioResults) {
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                    const isVisible = audioResults.style.display !== 'none';
                    if (isVisible) {
                        // Modal ficou visÃ­vel - registrar listener se necessÃ¡rio
                        const planBtn = document.getElementById('btnGenerateCorrectionPlan');
                        if (planBtn && planBtn.dataset.listenerAttached !== 'true') {
                            planBtn.addEventListener('click', handleGenerateCorrectionPlan);
                            planBtn.dataset.listenerAttached = 'true';
                            log('[CORRECTION-PLAN] âœ… Event listener registrado via MutationObserver');
                        }
                    }
                }
            }
        });
        
        observer.observe(audioResults, { attributes: true, attributeFilter: ['style'] });
        log('[CORRECTION-PLAN] ğŸ‘€ MutationObserver ativo em #audioAnalysisResults');
    }
})();

log('ğŸš€ [CORRECTION-PLAN] Sistema de Plano de CorreÃ§Ã£o Completo carregado');
