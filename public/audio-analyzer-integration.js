// 🎵 AUDIO ANALYZER INTEGRATION - VERSÃO REFATORADA
// Sistema de análise 100% baseado em processamento no back-end (Railway + Bucket)
// ⚠️ REMOÇÃO COMPLETA: Web Audio API, AudioContext, processamento local
// ✅ NOVO FLUXO: Presigned URL → Upload → Job Creation → Status Polling

// ═══════════════════════════════════════════════════════════════════════════════
// 🚨 CONSTANTE FÍSICA ABSOLUTA - True Peak NUNCA pode ser > 0 dBTP
// Esta constante é usada em TODO o sistema para garantir paridade tabela/cards
// ═══════════════════════════════════════════════════════════════════════════════
const TRUE_PEAK_HARD_CAP = 0.0; // dBTP - Limite absoluto para True Peak

// ═══════════════════════════════════════════════════════════════════════════════
// 🆕 MAPEAMENTO DE MÉTRICAS PARA CATEGORIAS - TOPO DO ARQUIVO
// Usado para agrupar problemas no plano de correção
// DEVE estar no topo para evitar ReferenceError antes da inicialização
// ═══════════════════════════════════════════════════════════════════════════════
const METRIC_CATEGORY_MAP = {
    // LOUDNESS
    'LUFS': 'loudness',
    'Loudness': 'loudness',
    'Integrated': 'loudness',
    'True Peak': 'loudness',
    'TP': 'loudness',
    // FREQUÊNCIAS (BANDAS ESPECTRAIS)
    'Sub': 'frequency',
    'Subgrave': 'frequency',
    'Bass': 'frequency',
    'Grave': 'frequency',
    'Low Mid': 'frequency',
    'Low-Mid': 'frequency',
    'Médio-Grave': 'frequency',
    'Mid': 'frequency',
    'Médios': 'frequency',
    'High Mid': 'frequency',
    'High-Mid': 'frequency',
    'Médio-Alto': 'frequency',
    'Brilho': 'frequency',
    'Brightness': 'frequency',
    'Presença': 'frequency',
    'Presence': 'frequency',
    'Air': 'frequency',
    // DINÂMICA
    'DR': 'dynamics',
    'Dynamic Range': 'dynamics',
    'LRA': 'dynamics',
    'Loudness Range': 'dynamics',
    'Crest': 'dynamics',
    'Crest Factor': 'dynamics',
    // ESTÉREO
    'Stereo': 'stereo',
    'Imagem Estéreo': 'stereo',
    'Correlation': 'stereo',
    'Width': 'stereo',
    'Balance': 'stereo'
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ NORMALIZADOR DE SEVERIDADE - ANTI-CRASH
// Garante que severity seja SEMPRE string, nunca causa erro de .toUpperCase()
// ═══════════════════════════════════════════════════════════════════════════════
function normalizeSeverity(severity) {
    if (!severity) return 'DESCONHECIDO';
    
    if (typeof severity === 'string') {
        return severity.toUpperCase().trim();
    }
    
    if (typeof severity === 'number') {
        const numMap = { 1: 'FINO', 2: 'ATENÇÃO', 3: 'CRÍTICA' };
        return numMap[severity] || 'DESCONHECIDO';
    }
    
    if (typeof severity === 'object') {
        if (severity.label) return String(severity.label).toUpperCase().trim();
        if (severity.level) {
            const levelMap = { 1: 'FINO', 2: 'ATENÇÃO', 3: 'CRÍTICA' };
            return levelMap[severity.level] || 'DESCONHECIDO';
        }
        if (severity.name) return String(severity.name).toUpperCase().trim();
    }
    
    return 'DESCONHECIDO';
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🛡️ VERIFICADOR DE PROBLEMA - Retorna true se severidade indica problema real
// ═══════════════════════════════════════════════════════════════════════════════
function isProblematicSeverity(severity) {
    const normalized = normalizeSeverity(severity);
    return normalized.includes('CRÍT') || 
           normalized.includes('ATEN') || 
           normalized.includes('WARN') ||
           normalized.includes('ALTA') ||
           normalized.includes('MODERADA');
}

// ═══════════════════════════════════════════════════════════════════════════════
// 🕐 HISTÓRICO DE ANÁLISES - Salvamento automático para usuários PRO
// ═══════════════════════════════════════════════════════════════════════════════
/**
 * 🕐 Salva análise no histórico (APENAS para usuários PRO)
 * Processo assíncrono que NÃO bloqueia a exibição do modal
 * 
 * @param {Object} analysisResult - JSON completo da análise
 * @returns {Promise<void>}
 */
async function saveAnalysisToHistory(analysisResult) {
    console.log('🕐 [HISTORY-SAVE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('🕐 [HISTORY-SAVE] Iniciando verificação para salvar...');
    
    try {
        // 1. Verificar se usuário está autenticado
        const userId = window.auth?.currentUser?.uid;
        console.log('🕐 [HISTORY-SAVE] userId:', userId ? userId.slice(0, 8) + '...' : 'NÃO AUTENTICADO');
        
        if (!userId) {
            console.log('🕐 [HISTORY-SAVE] ❌ Usuário não autenticado - pulando');
            return;
        }
        
        // 2. Detectar plano do usuário de MÚLTIPLAS FONTES
        let userPlan = 'free';
        const planSources = {
            planCapabilities: window.PlanCapabilities?.detectUserPlan?.(),
            windowUserPlan: window.userPlan,
            analysisResultPlan: analysisResult?.plan,
            currentModalPlan: window.currentModalAnalysis?.plan,
            cachedPlan: window.__soundyUserPlan
        };
        
        console.log('🕐 [HISTORY-SAVE] 🔍 Fontes de plano:', planSources);
        
        // Prioridade: PlanCapabilities > window.userPlan > analysisResult.plan > currentModal > cache
        userPlan = planSources.planCapabilities || 
                   planSources.windowUserPlan || 
                   planSources.analysisResultPlan ||
                   planSources.currentModalPlan ||
                   planSources.cachedPlan ||
                   'free';
        
        console.log('🕐 [HISTORY-SAVE] Plano detectado:', userPlan);
        
        // 3. Verificar se é PRO/DJ/STUDIO
        // ✅ ATUALIZADO 2026-01-06: STUDIO adicionado
        const isPro = userPlan === 'pro' || userPlan === 'dj' || userPlan === 'studio';
        if (!isPro) {
            console.log(`🕐 [HISTORY-SAVE] ⏭️ Plano "${userPlan}" não tem histórico - pulando`);
            return;
        }
        
        // 4. Verificar se análise tem dados válidos (MAIS TOLERANTE)
        const hasValidData = (
            analysisResult && 
            (
                analysisResult.technicalData ||
                analysisResult.loudness ||
                analysisResult.lufs ||
                analysisResult.score !== undefined ||
                analysisResult.data?.technicalData
            )
        );
        
        console.log('🕐 [HISTORY-SAVE] Validação de dados:', {
            hasAnalysisResult: !!analysisResult,
            hasTechnicalData: !!analysisResult?.technicalData,
            hasLoudness: !!analysisResult?.loudness,
            hasLufs: !!analysisResult?.lufs,
            hasScore: analysisResult?.score !== undefined,
            hasDataTechnical: !!analysisResult?.data?.technicalData,
            RESULTADO: hasValidData ? '✅ VÁLIDO' : '❌ INVÁLIDO'
        });
        
        if (!hasValidData) {
            console.warn('🕐 [HISTORY-SAVE] ❌ Análise sem dados válidos - pulando');
            return;
        }
        
        // 5. Extrair nome do arquivo e tipo de análise
        const analysisMode = analysisResult.mode || analysisResult.analysisMode || 'genre';
        
        let trackName = 'Análise sem nome';
        let genreOrReferenceName = 'N/A';
        
        if (analysisMode === 'reference') {
            // Análise de referência
            trackName = analysisResult.metadata?.fileName || 
                       analysisResult.fileName || 
                       'Música Original';
            genreOrReferenceName = analysisResult.metadata?.referenceName || 
                                  analysisResult.referenceName || 
                                  'Referência';
        } else {
            // Análise de gênero
            trackName = analysisResult.metadata?.fileName || 
                       analysisResult.fileName || 
                       analysisResult.trackName ||
                       'Análise sem nome';
            genreOrReferenceName = analysisResult.data?.genre || 
                                  analysisResult.genre || 
                                  window.__CURRENT_SELECTED_GENRE || 
                                  'Unknown';
        }
        
        console.log('🕐 [HISTORY-SAVE] 💾 Preparando para salvar:', {
            userId: userId.slice(0, 8) + '...',
            plan: userPlan,
            trackName: trackName,
            analysisType: analysisMode,
            genreOrReferenceName: genreOrReferenceName
        });
        
        // 6. Enviar para API
        const response = await fetch('/api/history', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-user-id': userId,
                'x-user-plan': userPlan
            },
            body: JSON.stringify({
                analysisResult: analysisResult
            })
        });
        
        console.log('🕐 [HISTORY-SAVE] Response status:', response.status);
        
        const data = await response.json();
        
        if (data.success) {
            console.log('🕐 [HISTORY-SAVE] ✅ Análise salva no histórico:', data.historyId);
        } else {
            console.warn('🕐 [HISTORY-SAVE] ⚠️ Falha ao salvar:', data.error || data.message);
        }
        
    } catch (error) {
        // Erro não-crítico - apenas loga, não interrompe fluxo
        console.error('🕐 [HISTORY-SAVE] ❌ ERRO:', error.message);
        console.error('🕐 [HISTORY-SAVE] Stack:', error.stack);
    }
    
    console.log('🕐 [HISTORY-SAVE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🔐 VERIFICADOR CENTRALIZADO DE ENTITLEMENT - MODO REFERÊNCIA
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/**
 * 🔐 Verifica se o usuário pode usar o modo de referência
 * REGRA: Apenas plano PRO tem acesso ao modo referência
 * 
 * @returns {Promise<{allowed: boolean, plan: string}>}
 */
async function checkReferenceEntitlement() {
    try {
        // 1. Tentar detectar plano via PlanCapabilities (cache local)
        let currentPlan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
        
        // 2. Se plano é 'free' mas usuário está autenticado, forçar refresh do Firestore
        if (currentPlan === 'free' && window.auth?.currentUser) {
            console.log('🔐 [ENTITLEMENT] Plano cache é free, verificando Firestore...');
            try {
                const freshPlan = await window.PlanCapabilities?.fetchUserPlan?.();
                if (freshPlan) {
                    currentPlan = freshPlan;
                    console.log(`🔐 [ENTITLEMENT] Plano atualizado: ${currentPlan}`);
                }
            } catch (err) {
                console.warn('🔐 [ENTITLEMENT] Erro ao buscar plano:', err);
            }
        }
        
        // 3. REGRA: PRO, DJ ou STUDIO = permitido, qualquer outro = bloqueado
        // ✅ ATUALIZADO 2026-01-06: STUDIO agora tem acesso ao Modo Referência
        const allowed = currentPlan === 'pro' || currentPlan === 'dj' || currentPlan === 'studio';
        
        console.log(`🔐 [ENTITLEMENT] checkReferenceEntitlement: plan=${currentPlan}, allowed=${allowed}`);
        
        return { allowed, plan: currentPlan };
    } catch (err) {
        console.error('🔐 [ENTITLEMENT] Erro crítico:', err);
        return { allowed: false, plan: 'free' };
    }
}

/**
 * 🔐 Versão síncrona para fail-safes (usa cache, menos precisa)
 * @returns {{shouldBlock: boolean, plan: string}}
 */
function checkReferenceEntitlementSync() {
    const plan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
    // ✅ ATUALIZADO 2026-01-06: STUDIO agora tem acesso ao Modo Referência
    const shouldBlock = plan !== 'pro' && plan !== 'dj' && plan !== 'studio';
    
    console.log(`🔐 [ENTITLEMENT-SYNC] plan=${plan}, shouldBlock=${shouldBlock}`);
    
    return { shouldBlock, plan };
}

// Exportar globalmente
window.checkReferenceEntitlement = checkReferenceEntitlement;
window.checkReferenceEntitlementSync = checkReferenceEntitlementSync;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎯 MAPEAMENTO CENTRALIZADO: IDs LEGADOS → IDs OFICIAIS
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/**
 * 🎯 MAPEAMENTO CENTRALIZADO: IDs LEGADOS → IDs OFICIAIS
 * 
 * Esta função é o ÚNICO ponto de conversão de gêneros legados.
 * Todo o sistema usa os novos IDs após esta normalização.
 * 
 * MAPEAMENTO:
 * - trance → progressive_trance
 * - phonk → rap_drill
 * - funk_automotivo → edm
 * - techno → fullon
 * 
 * @param {string} genreId - ID do gênero (pode ser legado ou novo)
 * @returns {string} - ID oficial normalizado
 */
function normalizeGenreId(genreId) {
  if (!genreId || typeof genreId !== 'string') {
    return genreId;
  }
  
  // Mapeamento de IDs legados para IDs oficiais
  const LEGACY_TO_OFFICIAL = {
    'trance': 'progressive_trance',
    'phonk': 'rap_drill',
    'funk_automotivo': 'edm',
    'techno': 'fullon'
  };
  
  const normalized = genreId.toLowerCase().trim();
  
  // Se é um ID legado, converter para oficial
  if (LEGACY_TO_OFFICIAL[normalized]) {
    console.log(`[GENRE-NORMALIZE] 🔄 Convertendo legado: "${normalized}" → "${LEGACY_TO_OFFICIAL[normalized]}"`);
    return LEGACY_TO_OFFICIAL[normalized];
  }
  
  // Já é um ID oficial ou outro gênero válido
  return normalized;
}

// Exportar globalmente para uso em outros módulos
window.normalizeGenreId = normalizeGenreId;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🛡️ SAFE STATE MACHINE ACCESSOR
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function getSafeStateMachine() {
  if (window.AnalysisStateMachine) {
    return window.AnalysisStateMachine;
  }
  
  // ✅ Retornar stub funcional completo ao invés de null
  console.warn('[SAFE-SM] StateMachine não disponível - usando stub funcional');
  return {
    getState: () => ({
      mode: window.currentAnalysisMode || 'genre',
      userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
      referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null,
      awaitingSecondTrack: !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has()),
      timestamp: new Date().toISOString()
    }),
    getMode: () => window.currentAnalysisMode || 'genre',
    setMode: (mode, opts = {}) => {
      console.log('[SAFE-SM-STUB] setMode:', mode, opts);
      window.currentAnalysisMode = mode;
      if (opts.userExplicitlySelected && typeof persistReferenceFlag === 'function') {
        persistReferenceFlag(mode === 'reference');
      }
    },
    isAwaitingSecondTrack: () => !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has()),
    isUserExplicitlySelected: () => window.userExplicitlySelectedReferenceMode || false,
    assertInvariants: () => true
  };
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎯 MODE ENGINE: Fonte única de verdade para modo de análise
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/**
 * 🎯 Helper: Extrai compareMode de forma deterministica
 * @param {Object} input - Objeto de análise ou contexto
 * @returns {string} 'A_B' ou 'B_A' (fallback: 'A_B')
 */
function getCompareMode(input) {
    const mode = input?.compareMode || input?.analysis?.compareMode;
    if (mode === 'B_A' || mode === 'b_a') return 'B_A';
    return 'A_B'; // default seguro
}

/**
 * 🎯 Helper: Extrai métricas de análise de forma robusta
 * Tenta múltiplas localizações no payload para garantir compatibilidade
 * @param {Object} analysisOrResult - Objeto de análise ou resultado
 * @returns {Object} Objeto de métricas (mesmo que vazio)
 */
function extractMetrics(analysisOrResult) {
    if (!analysisOrResult) return {};
    
    // Tentar múltiplas localizações (ordem de prioridade)
    const metrics = 
        analysisOrResult.data?.metrics ||
        analysisOrResult.metrics ||
        analysisOrResult.results?.metrics ||
        analysisOrResult.normalizedResult?.metrics ||
        analysisOrResult.referenceAnalysis?.data?.metrics ||
        {};
    
    return metrics;
}

/**
 * 🎯 Helper: Extrai bands de análise de forma robusta
 * @param {Object} analysisOrResult - Objeto de análise ou resultado
 * @returns {Object} Objeto de bands (mesmo que vazio)
 */
function extractBands(analysisOrResult) {
    if (!analysisOrResult) return {};
    
    const bands = 
        analysisOrResult.bands ||
        analysisOrResult.technicalData?.spectral_balance ||
        analysisOrResult.data?.bands ||
        analysisOrResult.spectralBands ||
        {};
    
    return bands;
}

/**
 * 🎯 Helper: Extrai métricas A/B de forma tolerante (não requer bands)
 * Valida existência de métricas mínimas necessárias para comparação A/B
 * @param {Object} analysisOrResult - Objeto de análise ou resultado
 * @returns {Object} { ok: boolean, metrics: {...}, technicalData: {...}, debugShape: {...} }
 */
function extractABMetrics(analysisOrResult) {
    if (!analysisOrResult) {
        return { ok: false, metrics: {}, technicalData: {}, debugShape: { error: 'payload null' } };
    }
    
    // Tentar extrair technicalData de múltiplas localizações
    const technicalData = 
        analysisOrResult.technicalData ||
        analysisOrResult.data?.technicalData ||
        analysisOrResult.results?.technicalData ||
        {};
    
    // Extrair métricas via helper existente
    const metrics = extractMetrics(analysisOrResult);
    
    // Validar se tem métricas mínimas necessárias para A/B
    const hasMinimalMetrics = (
        technicalData.lufsIntegrated != null ||
        technicalData.truePeakDbtp != null ||
        technicalData.dynamicRange != null ||
        metrics.lufsIntegrated != null ||
        metrics.truePeakDbtp != null ||
        metrics.dynamicRange != null
    );
    
    return {
        ok: hasMinimalMetrics,
        metrics: metrics,
        technicalData: technicalData,
        debugShape: {
            hasTechnicalData: !!technicalData,
            hasMetrics: !!metrics && Object.keys(metrics).length > 0,
            hasLufs: technicalData.lufsIntegrated != null || metrics.lufsIntegrated != null,
            hasTruePeak: technicalData.truePeakDbtp != null || metrics.truePeakDbtp != null,
            hasDR: technicalData.dynamicRange != null || metrics.dynamicRange != null,
            topLevelKeys: Object.keys(analysisOrResult)
        }
    };
}

/**
 * 🎯 Helper: Recupera referenceJobId de forma robusta
 * Prioridade: window > sessionStorage > localStorage
 * @returns {string|null} jobId da referência ou null
 */
function getReferenceJobId() {
    // Prioridade 1: Memória (mais rápido e confiável)
    if (window.__REFERENCE_JOB_ID__) {
        return window.__REFERENCE_JOB_ID__;
    }
    
    // Prioridade 2: sessionStorage (dura sessão do navegador)
    try {
        const fromSession = sessionStorage.getItem('referenceJobId');
        if (fromSession) {
            console.log('[REF-FIX] Recuperado de sessionStorage:', fromSession);
            window.__REFERENCE_JOB_ID__ = fromSession; // Sincronizar
            return fromSession;
        }
    } catch (e) {
        console.warn('[REF-FIX] Erro ao ler sessionStorage:', e);
    }
    
    // Prioridade 3: localStorage (persiste entre sessões)
    try {
        const fromLocal = localStorage.getItem('referenceJobId');
        if (fromLocal) {
            console.log('[REF-FIX] Recuperado de localStorage:', fromLocal);
            window.__REFERENCE_JOB_ID__ = fromLocal; // Sincronizar
            return fromLocal;
        }
    } catch (e) {
        console.warn('[REF-FIX] Erro ao ler localStorage:', e);
    }
    
    console.warn('[REF-FIX] Nenhum referenceJobId encontrado');
    return null;
}

/**
 * 🎯 Helper: Salva referenceJobId em todos os locais
 * @param {string} jobId - ID do job da referência
 */
function saveReferenceJobId(jobId) {
    if (!jobId) {
        console.warn('[REF-FIX] Tentativa de salvar jobId vazio');
        return;
    }
    
    // Salvar em memória
    window.__REFERENCE_JOB_ID__ = jobId;
    console.log('[REF-FIX] ✅ Salvo em window.__REFERENCE_JOB_ID__:', jobId);
    
    // Salvar em sessionStorage
    try {
        sessionStorage.setItem('referenceJobId', jobId);
        console.log('[REF-FIX] ✅ Salvo em sessionStorage');
    } catch (e) {
        console.error('[REF-FIX] ❌ Erro ao salvar em sessionStorage:', e);
    }
    
    // Salvar em localStorage
    try {
        localStorage.setItem('referenceJobId', jobId);
        console.log('[REF-FIX] ✅ Salvo em localStorage');
    } catch (e) {
        console.error('[REF-FIX] ❌ Erro ao salvar em localStorage:', e);
    }
}

/**
 * � RENDERIZAR BLOCO DE IDENTIFICAÇÃO DA MÚSICA
 * Exibe nome do arquivo, duração, sample rate, bit depth, canais, gênero e timestamp
 * @param {Object} analysis - Objeto de análise completo
 * @returns {string} HTML do bloco de identificação
 */
function renderMusicIdentificationBlock(analysis) {
    // Validação de entrada
    if (!analysis || typeof analysis !== 'object') {
        console.warn('[MUSIC-ID] ⚠️ analysis inválido ou ausente');
        return '';
    }
    
    // Extrair metadados
    const metadata = analysis.metadata || {};
    const fileName = metadata.fileName || analysis.fileName || 'Arquivo de áudio';
    
    // Duração (converter segundos para mm:ss)
    const durationSeconds = metadata.duration || 0;
    const minutes = Math.floor(durationSeconds / 60);
    const seconds = Math.floor(durationSeconds % 60);
    const durationFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Sample Rate (converter Hz para kHz)
    const sampleRate = metadata.sampleRate || 48000;
    const sampleRateKHz = (sampleRate / 1000).toFixed(0);
    
    // Bit Depth
    const bitDepth = metadata.bitDepth || 32;
    
    // Canais (1=Mono, 2=Estéreo, >2=Multicanal)
    const channels = metadata.channels || 2;
    const channelLabel = channels === 1 ? 'Mono' : channels === 2 ? 'Estéreo' : `${channels} canais`;
    
    // Gênero (se modo gênero)
    const mode = analysis.mode || 'genre';
    const genre = analysis.genre || analysis.genreName || null;
    
    // Timestamp da análise
    const timestamp = analysis.timestamp || Date.now();
    const now = new Date();
    const analysisDate = new Date(timestamp);
    const isToday = now.toDateString() === analysisDate.toDateString();
    const timestampLabel = isToday 
        ? `Analisado agora` 
        : `Analisado em ${analysisDate.toLocaleDateString('pt-BR')}`;
    
    // Logs de debug
    console.log('[MUSIC-ID] 🎵 Renderizando bloco de identificação:', {
        fileName,
        duration: durationFormatted,
        sampleRate: `${sampleRateKHz} kHz`,
        bitDepth: `${bitDepth}-bit`,
        channels: channelLabel,
        genre,
        mode,
        timestamp: timestampLabel
    });
    
    // Construir HTML
    const html = `
        <div class="music-identification-block">
            <div class="music-id-content">
                <!-- Título: Nome do arquivo com container -->
                <div class="music-id-title-container">
                    <h3 class="music-id-title">${escapeHtml(fileName)}</h3>
                </div>
                
                <!-- Linha separadora -->
                <div class="music-id-divider"></div>
                
                <!-- Especificações técnicas -->
                <div class="music-id-specs">
                    ${durationSeconds > 0 ? `
                        <div class="music-id-spec-item">
                            <span class="music-id-spec-icon">⏱️</span>
                            <span class="music-id-spec-value">${durationFormatted}</span>
                        </div>
                    ` : ''}
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">📊</span>
                        <span class="music-id-spec-value">${sampleRateKHz} kHz</span>
                    </div>
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">🎚️</span>
                        <span class="music-id-spec-value">${bitDepth}-bit</span>
                    </div>
                    
                    <div class="music-id-spec-item">
                        <span class="music-id-spec-icon">🔊</span>
                        <span class="music-id-spec-value">${channelLabel}</span>
                    </div>
                </div>
                
                <!-- Contexto: Gênero + Timestamp -->
                <div class="music-id-context">
                    ${mode === 'genre' && genre ? `
                        <span class="music-id-genre-badge">
                            <span>🎵</span>
                            <span>${formatGenreName(genre)}</span>
                        </span>
                    ` : ''}
                    
                    <span class="music-id-timestamp">${timestampLabel}</span>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

/**
 * 🛡️ Helper: Escapa HTML para prevenir XSS
 * @param {string} text - Texto a ser escapado
 * @returns {string} Texto escapado
 */
function escapeHtml(text) {
    if (!text || typeof text !== 'string') return '';
    
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    
    return text.replace(/[&<>"']/g, m => map[m]);
}

/**
 * 🎨 Helper: Formata nome de gênero para exibição
 * @param {string} genre - Nome do gênero (snake_case)
 * @returns {string} Nome formatado (Title Case)
 */
function formatGenreName(genre) {
    if (!genre || typeof genre !== 'string') return '';
    
    // Mapa de nomes customizados
    const customNames = {
        'progressive_trance': 'Progressive Trance',
        'funk_mandela': 'Funk Mandela',
        'funk_bruxaria': 'Funk Bruxaria',
        'funk_bh': 'Funk BH',
        'edm': 'EDM',
        'eletronico': 'Eletrônico'
    };
    
    // Se tiver nome customizado, usar
    if (customNames[genre]) {
        return customNames[genre];
    }
    
    // Caso contrário, converter snake_case para Title Case
    return genre
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
}

/**
 * �🎯 [AUDIT-FIX] Helper: Garante que container de referência A/B existe NO LOCAL CORRETO
 * Posição: ABAIXO dos cards, ACIMA das sugestões
 * @returns {HTMLElement|null} Container ou null se falhar
 */
function ensureReferenceContainer() {
    let container = document.getElementById('referenceComparisons');
    
    // Se já existe, verificar se está no lugar certo
    if (container) {
        const modalResults = document.getElementById('audioAnalysisResults');
        if (modalResults && !modalResults.contains(container)) {
            console.warn('[CONTAINER] ⚠️ #referenceComparisons existe mas está FORA do modal ativo - removendo');
            container.remove();
            container = null;
        } else {
            console.log('[CONTAINER] ✅ #referenceComparisons já existe e está no modal correto');
            return container;
        }
    }
    
    // 🎯 [AUDIT-FIX] Localizar ponto de inserção correto
    // Ordem desejada: Cards → Tabela Comparação → Sugestões
    const modalResults = document.getElementById('audioAnalysisResults');
    const modalTechnical = document.getElementById('modalTechnicalData');
    
    // Buscar elemento de sugestões (deve aparecer DEPOIS da tabela)
    const suggestionsContainer = modalResults?.querySelector('.ai-suggestions-container, #aiSuggestionsContainer, [class*="suggestion"]');
    
    let insertionPoint = null;
    let parentContainer = null;
    
    if (modalResults) {
        parentContainer = modalResults;
        
        // Se encontrou container de sugestões, inserir ANTES dele
        if (suggestionsContainer) {
            insertionPoint = suggestionsContainer;
            console.log('[CONTAINER] 📍 Inserção: ANTES do container de sugestões');
        } 
        // Se não, inserir após modalTechnicalData (onde ficam os cards)
        else if (modalTechnical && modalResults.contains(modalTechnical)) {
            insertionPoint = modalTechnical.nextSibling;
            console.log('[CONTAINER] 📍 Inserção: APÓS modalTechnicalData (cards)');
        }
        // Último recurso: inserir no final de modalResults
        else {
            insertionPoint = null; // appendChild
            console.log('[CONTAINER] 📍 Inserção: FINAL de audioAnalysisResults');
        }
    } else {
        console.error('[CONTAINER] ❌ audioAnalysisResults não encontrado - não é possível criar container');
        return null;
    }
    
    // Criar container
    container = document.createElement('div');
    container.id = 'referenceComparisons';
    container.className = 'reference-comparisons-container';
    container.style.marginTop = '20px';
    container.style.marginBottom = '20px';
    
    // Inserir no local correto
    if (insertionPoint) {
        parentContainer.insertBefore(container, insertionPoint);
    } else {
        parentContainer.appendChild(container);
    }
    
    console.log('[CONTAINER] ✅ #referenceComparisons criado dinamicamente no local correto');
    console.log('[CONTAINER] 📊 Posição relativa:', {
        'está em modalResults': modalResults.contains(container),
        'antes de sugestões': suggestionsContainer ? container.nextSibling === suggestionsContainer : 'N/A',
        'depois de cards': modalTechnical ? modalTechnical.compareDocumentPosition(container) & Node.DOCUMENT_POSITION_FOLLOWING : 'N/A'
    });
    
    return container;
}

/**
 * 🎯 HELPER PRINCIPAL: Normaliza análise para shape consistente
 * Garante que TODOS os dados tenham bands e metrics no top-level
 * @param {Object} raw - Análise bruta do backend ou store
 * @returns {Object} Análise normalizada com shape consistente
 */
function normalizeAnalysis(raw) {
    if (!raw) return null;
    
    console.log('[NORMALIZE] 🔄 Normalizando análise:', { jobId: raw.jobId, hasData: !!raw.data, hasTechnicalData: !!raw.technicalData });
    
    // Base: clonar para não mutar original
    const normalized = { ...raw };
    
    // 1. Extrair technicalData de todas as fontes possíveis
    const technicalData = 
        raw.technicalData ||
        raw.data?.technicalData ||
        raw.results?.technicalData ||
        {};
    
    // 2. Extrair bands de todas as fontes
    const bands = 
        raw.bands ||
        raw.spectralBands ||
        technicalData.spectral_balance ||
        raw.data?.bands ||
        raw.results?.bands ||
        {};
    
    // 3. Extrair metrics usando helper existente
    const metrics = extractMetrics(raw);
    
    // 4. Garantir estrutura unificada no TOP-LEVEL
    normalized.bands = bands;
    normalized.metrics = metrics;
    normalized.technicalData = technicalData;
    
    // 5. Se technicalData tem spectral_balance mas bands não foi copiado, garantir
    if (!normalized.bands || Object.keys(normalized.bands).length === 0) {
        if (technicalData.spectral_balance) {
            normalized.bands = technicalData.spectral_balance;
            console.log('[NORMALIZE] ✅ Copiado spectral_balance → bands');
        }
    }
    
    // 6. Se metrics vazio mas technicalData tem valores, copiar
    if (!normalized.metrics || Object.keys(normalized.metrics).length === 0) {
        normalized.metrics = {
            lufsIntegrated: technicalData.lufsIntegrated,
            truePeakDbtp: technicalData.truePeakDbtp,
            dynamicRange: technicalData.dynamicRange,
            lra: technicalData.lra,
            rmsLeft: technicalData.rmsLeft,
            rmsRight: technicalData.rmsRight,
            crestFactor: technicalData.crestFactor,
            stereoCorrelation: technicalData.stereoCorrelation
        };
        console.log('[NORMALIZE] ✅ Copiado technicalData → metrics');
    }
    
    console.log('[NORMALIZE] ✅ Normalização completa:', {
        hasBands: !!normalized.bands && Object.keys(normalized.bands).length > 0,
        hasMetrics: !!normalized.metrics && Object.keys(normalized.metrics).length > 0,
        bandsKeys: Object.keys(normalized.bands || {}),
        metricsKeys: Object.keys(normalized.metrics || {})
    });
    
    return normalized;
}

/**
 * 🎯 HELPER: Retorna state machine seguro (nunca undefined)
 * @returns {Object} State machine real ou stub funcional
 */
function getSafeStateMachine() {
    if (window.AnalysisStateMachine) {
        return window.AnalysisStateMachine;
    }
    
    console.warn('[STATE-MACHINE] ⚠️ AnalysisStateMachine não carregado - usando stub');
    
    // Stub funcional que preserva estado
    return {
        getMode: () => window.currentAnalysisMode || 'genre',
        setMode: (mode, opts) => {
            console.log('[STATE-MACHINE-STUB] setMode:', mode, opts);
            window.currentAnalysisMode = mode;
            if (opts?.userExplicitlySelected) {
                window.userExplicitlySelectedReferenceMode = (mode === 'reference');
            }
        },
        getState: () => ({
            mode: window.currentAnalysisMode || 'genre',
            userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
            referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null,
            awaitingSecondTrack: !!window.__REFERENCE_JOB_ID__
        }),
        isReferenceCompare: () => window.currentAnalysisMode === 'reference'
    };
}

/**
 * 🎯 Helper: Extrai identidade de track para validação de duplicação
 * @param {Object} track - Objeto de análise
 * @returns {Object} { jobId, fileKey, fileName }
 */
function getTrackIdentity(track) {
    const jobId = track?.jobId || null;
    const fileKey = track?.fileKey || track?.storageKey || track?.s3Key || null;
    const rawFileName = track?.fileName || track?.metadata?.fileName || null;
    const fileName = (typeof rawFileName === 'string' && rawFileName.trim().length > 0) 
                     ? rawFileName 
                     : null;
    return { jobId, fileKey, fileName };
}

/**
 * 🎯 FONTE-DE-VERDADE: Detecta se há contexto de referência ativo
 * Verifica múltiplas fontes para garantir detecção robusta
 */
function hasActiveReferenceContext() {
    const hasRefJobId = !!(window.__REFERENCE_JOB_ID__ || window.__soundyState?.referenceJobId);
    const hasFirstStore = !!(window.FirstAnalysisStore?.has?.());
    const hasRefData = !!(window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__);
    
    return hasRefJobId && (hasFirstStore || hasRefData);
}

/**
 * 🧹 ISOLAMENTO DO MODO REFERENCE: Limpa contaminação de estado de gênero
 * Garante que o modo reference não seja influenciado por selectedGenre/genreTargets
 */
function resetGenreContextForReference() {
    console.log('[REFERENCE-ISOLATION] 🧹 Resetando contexto de gênero para modo reference');
    
    // 🎯 PATCH CRÍTICO D: Zerar TODAS variáveis de gênero
    if (window.__soundyState) {
        window.__soundyState.selectedGenre = null;
        window.__soundyState.hasGenreTargets = false;
        window.__soundyState.currentAnalysisMode = 'reference';
        window.__soundyState.genreTargets = null;
    }
    
    // Zerar variáveis globais de gênero
    window.__CURRENT_SELECTED_GENRE = null;
    window.PROD_AI_REF_GENRE = null;
    
    // Garantir que currentAnalysisMode está correto
    window.currentAnalysisMode = 'reference';
    
    // Não tocar em variáveis de UI (usuário pode ter selecionado gênero no menu)
    // Apenas garantir que não influenciam a análise de referência
    
    console.log('[REFERENCE-ISOLATION] ✅ Contexto isolado:', {
        selectedGenre: window.__soundyState?.selectedGenre,
        hasGenreTargets: window.__soundyState?.hasGenreTargets,
        currentAnalysisMode: window.currentAnalysisMode,
        CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE
    });
}

window.SOUNDY_MODE_ENGINE = {
    mode: "genre",          // "genre" | "reference_base" | "reference_compare"
    referenceBase: null,    // análise completa da primeira música
    referenceJobId: null,   // jobId da primeira música

    setGenre() {
        this.mode = "genre";
        this.referenceBase = null;
        this.referenceJobId = null;
        setViewMode("genre");
    },

    startReferenceBase(firstAnalysis) {
        this.mode = "reference_base";
        this.referenceBase = firstAnalysis;
        this.referenceJobId = firstAnalysis.jobId;
        setViewMode("genre"); // ainda se comporta visualmente como gênero
    },

    startReferenceCompare() {
        this.mode = "reference_compare";
        setViewMode("reference");
    },

    isGenre() {
        return this.mode === "genre";
    },

    isReferenceBase() {
        return this.mode === "reference_base";
    },

    isReferenceCompare() {
        return this.mode === "reference_compare";
    },

    clear() {
        this.setGenre();
    }
};

// ═══════════════════════════════════════════════════════════════════
// 🎯 GENRE TARGETS UTILS - FONTE ÚNICA DE VERDADE
// ═══════════════════════════════════════════════════════════════════
/**
 * 🎯 EXTRAI GENRE TARGETS DE UMA ANÁLISE (ALIAS COMPATÍVEL)
 * 
 * Esta é uma função alias que chama extractGenreTargets() principal.
 * Mantida para compatibilidade com código legado.
 * 
 * @param {Object} analysis - Objeto de análise normalizado
 * @returns {Object|null} Targets do gênero ou null
 */
function extractGenreTargetsFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-ALIAS] Redirecionando para extractGenreTargets()');
    return extractGenreTargets(analysis);
}

/**
 * Extrai gênero de uma análise
 * ÚNICA FONTE OFICIAL: analysis.data.genre
 * @param {Object} analysis - Objeto de análise normalizado
 * @returns {string|null} Nome do gênero ou null
 */
function extractGenreFromAnalysis(analysis) {
    console.log('[GENRE-TARGETS-UTILS] 🎵 Extraindo gênero da análise');
    
    // 🎯 PRIORIDADE 1: analysis.data.genre (BACKEND OFICIAL)
    if (analysis?.data?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ✅ Gênero encontrado em analysis.data.genre:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // 🎯 PRIORIDADE 2: analysis.genre (fallback direto)
    if (analysis?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ⚠️ Gênero encontrado em analysis.genre (fallback):', analysis.genre);
        return analysis.genre;
    }
    
    // 🎯 PRIORIDADE 3: analysis.metadata.genre
    if (analysis?.metadata?.genre) {
        console.log('[GENRE-TARGETS-UTILS] ⚠️ Gênero encontrado em analysis.metadata.genre (fallback):', analysis.metadata.genre);
        return analysis.metadata.genre;
    }
    
    console.warn('[GENRE-TARGETS-UTILS] ❌ Nenhum gênero encontrado na análise');
    return null;
}

console.log('✅ Genre Targets Utils carregado');

// ═══════════════════════════════════════════════════════════════════
// 🎯 GENRE-ONLY EXTRACTION UTILS - NUNCA AFETAM REFERENCE
// ═══════════════════════════════════════════════════════════════════

/**
 * 🎯 FUNÇÃO UTILITÁRIA GLOBAL - OBTER TARGETS CORRETOS
 * 
 * CAMPO REAL DO POSTGRES: analysis.data.genreTargets
 * 
 * ❌ NÃO USAR:
 *    - analysis.targets
 *    - analysis.results.data.genreTargets
 *    - analysis.results.genreTargets
 * 
 * @param {Object} analysis - Objeto de análise do backend
 * @returns {Object|null} Targets ou null
 */
function getCorrectTargets(analysis) {
    console.log('[TARGETS] 🔍 Buscando targets corretos...');
    
    let targets = null;
    
    // 🚨 PRIORIDADE MÁXIMA: analysis.data.targets (FLAT FORMAT COM OVERRIDE APLICADO!)
    // Este campo vem do pipeline com override de streaming já aplicado (-14 LUFS)
    if (analysis?.data?.targets && typeof analysis.data.targets === 'object') {
        console.error('╔═══════════════════════════════════════════════════════════╗');
        console.error('║  🎯 USANDO analysis.data.targets (FLAT + OVERRIDE)       ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        console.error('[TARGETS] lufs_target:', analysis.data.targets.lufs_target);
        console.error('[TARGETS] true_peak_target:', analysis.data.targets.true_peak_target);
        console.error('[TARGETS] soundDestination:', analysis.soundDestination);
        console.error('\n');
        return JSON.parse(JSON.stringify(analysis.data.targets)); // Deep copy
    }
    
    // 🎯 PRIORIDADE 2: analysis.data.genreTargets
    if (analysis?.data?.genreTargets && typeof analysis.data.genreTargets === 'object') {
        console.log('[TARGETS] ✅ Usando analysis.data.genreTargets (CAMPO REAL DO POSTGRES)');
        targets = JSON.parse(JSON.stringify(analysis.data.genreTargets)); // Deep copy
    }
    
    // 🎯 PRIORIDADE 3: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
    if (!targets) {
        const genre = analysis?.genre || analysis?.data?.genre;
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            console.log('[TARGETS] 📦 Usando PROD_AI_REF_DATA[genre] como fallback');
            targets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
        }
    }
    
    if (!targets) {
        console.warn('[TARGETS] ⚠️ Nenhum target encontrado');
        return null;
    }
    
    // 📡 STREAMING MODE: Aplicar override de LUFS e TP (APENAS se não veio de analysis.data.targets)
    // 🚨 CORREÇÃO: Usar analysis.soundDestination (do backend) prioritariamente
    const soundDest = analysis?.soundDestination || getSoundDestinationMode();
    
    if (soundDest === 'streaming') {
        console.error('╔═══════════════════════════════════════════════════════════╗');
        console.error('║  📡 FRONTEND: APLICANDO OVERRIDE STREAMING               ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        console.error('[TARGETS] soundDestination:', soundDest);
        console.error('[TARGETS] ANTES: lufs_target =', targets.lufs_target);
        
        targets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
        targets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
        
        console.error('[TARGETS] DEPOIS: lufs_target =', targets.lufs_target);
        console.error('\n');
    }
    
    console.log('[TARGETS] Keys:', Object.keys(targets));
    return targets;
}

/**
 * 🎯 EXTRAI TARGETS DO GÊNERO - FUNÇÃO DEFINITIVA E ROBUSTA
 * 
 * Esta função NUNCA retorna undefined ou null.
 * Sempre retorna targets válidos usando fallbacks se necessário.
 * 
 * ESTRUTURA ACEITA:
 * - results.data.genreTargets (backend/worker/postgres)
 * - analysis.data.genreTargets (frontend)
 * 
 * FALLBACKS AUTOMÁTICOS:
 * - window.__activeRefData
 * - window.PROD_AI_REF_DATA[genre]
 * 
 * @param {Object} source - Objeto results (backend) ou analysis (frontend)
 * @returns {Object} Targets do gênero (nunca null)
 */
function extractGenreTargets(source) {
    console.log('[EXTRACT-TARGETS] 🔍 Iniciando extração de targets');
    console.log('[EXTRACT-TARGETS] Tipo de objeto:', source?.constructor?.name || typeof source);
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 1: IDENTIFICAR SE É MODO GENRE
    // ═══════════════════════════════════════════════════════════════
    const mode = source?.mode || source?.data?.mode || 'unknown';
    console.log('[EXTRACT-TARGETS] Modo detectado:', mode);
    
    if (mode !== "genre") {
        console.log('[EXTRACT-TARGETS] ⚠️ Não é modo genre, retornando null');
        return null;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 2: EXTRAIR GÊNERO
    // ═══════════════════════════════════════════════════════════════
    const genre = source?.data?.genre || 
                  source?.genre || 
                  source?.metadata?.genre || 
                  'unknown';
    
    console.log('[EXTRACT-TARGETS] Gênero identificado:', genre);
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 3: BUSCAR TARGETS NA ORDEM DE PRIORIDADE
    // ═══════════════════════════════════════════════════════════════
    console.log('[EXTRACT-TARGETS] 📦 Testando fontes de targets:');
    console.log('[EXTRACT-TARGETS]   source.data.genreTargets:', !!source?.data?.genreTargets);
    console.log('[EXTRACT-TARGETS]   source.genreTargets:', !!source?.genreTargets);
    console.log('[EXTRACT-TARGETS]   source.targets:', !!source?.targets);
    console.log('[EXTRACT-TARGETS]   source.data.targets:', !!source?.data?.targets);
    
    let targets = null;
    let targetSource = null;
    
    // 🎯 PRIORIDADE 1: source.data.genreTargets (BACKEND/FRONTEND OFICIAL)
    if (source?.data?.genreTargets && typeof source.data.genreTargets === 'object') {
        targets = source.data.genreTargets;
        targetSource = 'source.data.genreTargets (OFICIAL)';
        
        // 🆕 LOG STREAMING MODE: Verificar se targets foram overriden
        console.log('[EXTRACT-TARGETS] 📡 STREAMING CHECK:', {
            soundDestination: source?.soundDestination,
            lufs_target: targets.lufs_target,
            true_peak_target: targets.true_peak_target,
            isStreamingOverride: targets.lufs_target === -14 && targets.true_peak_target === -1.0
        });
    }
    // 🎯 PRIORIDADE 2: source.genreTargets (fallback direto)
    else if (source?.genreTargets && typeof source.genreTargets === 'object') {
        targets = source.genreTargets;
        targetSource = 'source.genreTargets';
    }
    // 🎯 PRIORIDADE 3: source.targets (nomenclatura alternativa)
    else if (source?.targets && typeof source.targets === 'object') {
        targets = source.targets;
        targetSource = 'source.targets';
    }
    // 🎯 PRIORIDADE 4: source.data.targets
    else if (source?.data?.targets && typeof source.data.targets === 'object') {
        targets = source.data.targets;
        targetSource = 'source.data.targets';
    }
    // 🎯 PRIORIDADE 5: source.result.genreTargets
    else if (source?.result?.genreTargets && typeof source.result.genreTargets === 'object') {
        targets = source.result.genreTargets;
        targetSource = 'source.result.genreTargets';
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 4: VALIDAR E RETORNAR SE ENCONTRADO
    // ═══════════════════════════════════════════════════════════════
    if (targets && isValidTargetsStructure(targets)) {
        console.log('[EXTRACT-TARGETS] ✅ Targets encontrados em:', targetSource);
        console.log('[EXTRACT-TARGETS] 📊 Estrutura:', {
            hasLufs: !!targets.lufs,
            hasTruePeak: !!targets.truePeak,
            hasDr: !!targets.dr,
            hasBands: !!targets.bands,
            keys: Object.keys(targets)
        });
        return targets;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 5: FALLBACK 1 - window.__activeRefData
    // ═══════════════════════════════════════════════════════════════
    console.warn('[EXTRACT-TARGETS] ⚠️ Targets não encontrados no objeto principal');
    console.log('[EXTRACT-TARGETS] 🔄 Tentando fallback: window.__activeRefData');
    
    if (typeof window !== 'undefined' && window.__activeRefData) {
        const activeData = window.__activeRefData;
        
        // Validar se gênero bate
        const activeGenre = activeData.genre || activeData.data?.genre;
        if (activeGenre === genre || !activeGenre) {
            console.log('[EXTRACT-TARGETS] ✅ Usando window.__activeRefData');
            const fallbackTargets = activeData.targets || activeData.data?.genreTargets || activeData;
            
            if (isValidTargetsStructure(fallbackTargets)) {
                return fallbackTargets;
            }
        } else {
            console.warn('[EXTRACT-TARGETS] ⚠️ window.__activeRefData ignorado - gênero diferente:', activeGenre, '≠', genre);
        }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 6: FALLBACK 2 - window.PROD_AI_REF_DATA[genre]
    // ═══════════════════════════════════════════════════════════════
    console.log('[EXTRACT-TARGETS] 🔄 Tentando fallback: window.PROD_AI_REF_DATA[' + genre + ']');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        window.PROD_AI_REF_DATA[genre]) {
        
        console.log('[EXTRACT-TARGETS] ✅ Usando window.PROD_AI_REF_DATA[' + genre + ']');
        const fallbackTargets = window.PROD_AI_REF_DATA[genre];
        
        if (isValidTargetsStructure(fallbackTargets)) {
            return fallbackTargets;
        }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 7: FALLBACK 3 - window.PROD_AI_REF_DATA (objeto único)
    // ═══════════════════════════════════════════════════════════════
    console.log('[EXTRACT-TARGETS] 🔄 Tentando fallback: window.PROD_AI_REF_DATA (objeto único)');
    
    if (typeof window !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA !== 'undefined' && 
        typeof window.PROD_AI_REF_DATA === 'object') {
        
        // Verificar se é um objeto único (não um dicionário de gêneros)
        if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
            console.log('[EXTRACT-TARGETS] ✅ Usando window.PROD_AI_REF_DATA (objeto único)');
            return window.PROD_AI_REF_DATA;
        }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ETAPA 8: ERRO CRÍTICO - NENHUM TARGET ENCONTRADO
    // ═══════════════════════════════════════════════════════════════
    console.error('╔═══════════════════════════════════════════════════════════╗');
    console.error('║  ❌ ERRO CRÍTICO: NENHUM TARGET ENCONTRADO               ║');
    console.error('╚═══════════════════════════════════════════════════════════╝');
    console.error('[EXTRACT-TARGETS] Modo:', mode);
    console.error('[EXTRACT-TARGETS] Gênero:', genre);
    console.error('[EXTRACT-TARGETS] source.data:', source?.data);
    console.error('[EXTRACT-TARGETS] source.genreTargets:', source?.genreTargets);
    console.error('[EXTRACT-TARGETS] window.__activeRefData:', typeof window !== 'undefined' ? !!window.__activeRefData : 'N/A');
    console.error('[EXTRACT-TARGETS] window.PROD_AI_REF_DATA:', typeof window !== 'undefined' ? !!window.PROD_AI_REF_DATA : 'N/A');
    
    // Retornar estrutura vazia válida ao invés de null
    console.warn('[EXTRACT-TARGETS] ⚠️ Retornando estrutura vazia válida');
    return {
        lufs: { target: -14, tolerance: 1 },
        truePeak: { target: -1, tolerance: 0.5 },
        dr: { target: 8, tolerance: 2 },
        stereo: { target: 100, tolerance: 10 },
        bands: {}
    };
}

/**
 * Valida se a estrutura de targets é válida
 * @param {Object} targets - Objeto de targets
 * @returns {boolean} True se válido
 */
function isValidTargetsStructure(targets) {
    if (!targets || typeof targets !== 'object') {
        return false;
    }
    
    // Verificar se tem pelo menos uma das propriedades essenciais
    // 🔧 CORREÇÃO: Aceitar tanto camelCase (lufs) quanto snake_case (lufs_target)
    const hasEssentials = targets.lufs || 
                         targets.truePeak || 
                         targets.dr || 
                         targets.bands ||
                         targets.legacy_compatibility ||
                         targets.lufs_target !== undefined ||  // 🆕 snake_case do backend
                         targets.true_peak_target !== undefined ||  // 🆕 snake_case do backend
                         targets.dr_target !== undefined;  // 🆕 snake_case do backend
    
    return hasEssentials;
}

/**
 * Extrai nome do gênero SOMENTE no modo genre
 * ⚠️ IMPORTANTE: Retorna genre normal se não for modo genre
 * @param {Object} analysis - Objeto de análise
 * @returns {string} Nome do gênero
 */
function extractGenreName(analysis) {
    // 🛡️ BARREIRA: Se não for modo genre, retorna genre normal
    if (analysis?.mode !== "genre") {
        return analysis?.genre || null;
    }
    
    console.log('[GENRE-ONLY-UTILS] 🎵 Extraindo nome do gênero no modo GENRE');
    
    // 🎯 FONTE OFICIAL: analysis.data.genre
    if (analysis?.data?.genre) {
        console.log('[GENRE-ONLY-UTILS] ✅ Gênero encontrado:', analysis.data.genre);
        return analysis.data.genre;
    }
    
    // Fallback para analysis.genre
    if (analysis?.genre) {
        console.log('[GENRE-ONLY-UTILS] ⚠️ Usando fallback analysis.genre:', analysis.genre);
        return analysis.genre;
    }
    
    console.warn('[GENRE-ONLY-UTILS] ❌ Gênero não encontrado, usando "default"');
    return "default";
}

/**
 * Carrega targets padrão para um gênero
 * @param {string} genreName - Nome do gênero
 * @returns {Object} Targets padrão
 */
function loadDefaultGenreTargets(genreName = "default") {
    console.log('[GENRE-ONLY-UTILS] 📦 Carregando targets padrão para:', genreName);
    
    // Tentar carregar de window.GENRE_TARGETS_DB
    if (window.GENRE_TARGETS_DB && window.GENRE_TARGETS_DB[genreName]) {
        console.log('[GENRE-ONLY-UTILS] ✅ Targets carregados de GENRE_TARGETS_DB');
        return window.GENRE_TARGETS_DB[genreName];
    }
    
    // Fallback: targets genéricos
    console.warn('[GENRE-ONLY-UTILS] ⚠️ Usando targets genéricos');
    return {
        lufs_target: -14,
        true_peak_target: -1,
        dr_target: 8,
        lra_target: 6,
        stereo_target: 0.85,
        bands: {}
    };
}

console.log('✅ Genre-Only Extraction Utils carregado');

// 🔍 AUDITORIA DE STORAGE - Sistema de detecção de inconsistências
(function initStorageAudit() {
    console.group('%c[AUDITORIA-STORAGE] 🧠 Inicializando sistema de auditoria de storage', 'color:#A974FF;font-weight:bold;font-size:14px;');
    
    // 1️⃣ Verificar localStorage atual
    const localRefJobId = localStorage.getItem('referenceJobId');
    const localRefAnalysis = localStorage.getItem('referenceAnalysis');
    
    console.log('%c[AUDITORIA-STORAGE] 📦 localStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', localRefJobId || '❌ vazio');
    console.log('   referenceAnalysis:', localRefAnalysis ? `✅ ${localRefAnalysis.length} bytes` : '❌ vazio');
    
    // 2️⃣ Verificar sessionStorage atual
    const sessionRefJobId = sessionStorage.getItem('referenceJobId');
    const sessionRefAnalysis = sessionStorage.getItem('referenceAnalysis');
    const sessionCurrentJobId = sessionStorage.getItem('currentJobId');
    
    console.log('%c[AUDITORIA-STORAGE] 📦 sessionStorage:', 'color:#FFD700;font-weight:bold;');
    console.log('   referenceJobId:', sessionRefJobId || '❌ vazio');
    console.log('   referenceAnalysis:', sessionRefAnalysis ? `✅ ${sessionRefAnalysis.length} bytes` : '❌ vazio');
    console.log('   currentJobId:', sessionCurrentJobId || '❌ vazio');
    
    // 3️⃣ Verificar variáveis globais
    console.log('%c[AUDITORIA-STORAGE] 🌐 Variáveis globais:', 'color:#FFD700;font-weight:bold;');
    console.log('   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || '❌ undefined');
    console.log('   window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__ || '❌ undefined');
    
    // 4️⃣ Detectar inconsistências
    console.log('%c[AUDITORIA-STORAGE] 🔍 Análise de consistência:', 'color:#A974FF;font-weight:bold;');
    
    if (localRefJobId && !sessionRefJobId) {
        console.log('%c   ⚠️ PROBLEMA: referenceJobId apenas em localStorage', 'color:#FF5555;font-weight:bold;');
        console.log('   ⚠️ Risco: Compartilhamento entre abas (localStorage é global)');
        console.log('   ✅ Solução: Migrar para sessionStorage (isolamento por aba)');
    }
    
    if (localRefJobId && sessionRefJobId && localRefJobId !== sessionRefJobId) {
        console.log('%c   ❌ INCONSISTÊNCIA CRÍTICA: JobIds diferentes!', 'color:#FF5555;font-weight:bold;');
        console.log('   localStorage.referenceJobId:', localRefJobId);
        console.log('   sessionStorage.referenceJobId:', sessionRefJobId);
    }
    
    if (!localRefJobId && !sessionRefJobId && !window.__REFERENCE_JOB_ID__) {
        console.log('%c   ✅ Estado limpo - sem referência ativa', 'color:#00FF88;');
    }
    
    if (localRefJobId || sessionRefJobId || window.__REFERENCE_JOB_ID__) {
        console.log('%c   📊 Referência ativa detectada:', 'color:#00C9FF;');
        console.log('   Prioridade: sessionStorage > window > localStorage');
    }
    
    console.groupEnd();
    
    // 5️⃣ Criar utilitário global de storage com fallback
    window.StorageManager = {
        // Salvar referenceJobId
        setReferenceJobId(jobId) {
            console.log('%c[STORAGE-MANAGER] 💾 Salvando referenceJobId:', 'color:#00FF88;font-weight:bold;', jobId);
            try {
                sessionStorage.setItem('referenceJobId', jobId);
                console.log('   ✅ Salvo em sessionStorage (isolado por aba)');
            } catch (e) {
                console.warn('   ⚠️ Falha no sessionStorage, usando localStorage como fallback:', e.message);
                localStorage.setItem('referenceJobId', jobId);
            }
        },
        
        // Ler referenceJobId (prioridade: sessionStorage > window > localStorage)
        getReferenceJobId() {
            const sessionId = sessionStorage.getItem('referenceJobId');
            const windowId = window.__REFERENCE_JOB_ID__;
            const localId = localStorage.getItem('referenceJobId');
            
            const result = sessionId || windowId || localId;
            
            console.log('%c[STORAGE-MANAGER] 📖 Lendo referenceJobId:', 'color:#FFD700;', result || '❌ não encontrado');
            console.log('   sessionStorage:', sessionId || '❌');
            console.log('   window.__REFERENCE_JOB_ID__:', windowId || '❌');
            console.log('   localStorage:', localId || '❌');
            
            return result;
        },
        
        // Salvar referenceAnalysis
        setReferenceAnalysis(analysis) {
            const json = JSON.stringify(analysis);
            console.log('%c[STORAGE-MANAGER] 💾 Salvando referenceAnalysis:', 'color:#00FF88;font-weight:bold;', `${json.length} bytes`);
            try {
                sessionStorage.setItem('referenceAnalysis', json);
                console.log('   ✅ Salvo em sessionStorage');
            } catch (e) {
                console.warn('   ⚠️ Falha no sessionStorage (quota?), usando localStorage:', e.message);
                try {
                    localStorage.setItem('referenceAnalysis', json);
                } catch (e2) {
                    console.error('   ❌ Falha em ambos storages:', e2.message);
                }
            }
        },
        
        // Ler referenceAnalysis
        getReferenceAnalysis() {
            const sessionData = sessionStorage.getItem('referenceAnalysis');
            const localData = localStorage.getItem('referenceAnalysis');
            
            const result = sessionData || localData;
            
            if (result) {
                try {
                    const parsed = JSON.parse(result);
                    console.log('%c[STORAGE-MANAGER] 📖 referenceAnalysis recuperado:', 'color:#FFD700;', 
                        `${result.length} bytes`, 
                        sessionData ? '(sessionStorage)' : '(localStorage fallback)');
                    return parsed;
                } catch (e) {
                    console.error('%c[STORAGE-MANAGER] ❌ Erro ao parsear referenceAnalysis:', 'color:#FF5555;', e.message);
                    return null;
                }
            }
            
            console.log('%c[STORAGE-MANAGER] 📖 referenceAnalysis:', 'color:#FFD700;', '❌ não encontrado');
            return null;
        },
        
        // Limpar referência
        clearReference() {
            // 🚨 BLINDAGEM ABSOLUTA: NUNCA limpar em modo genre
            if (window.__CURRENT_MODE__ === 'genre') {
                console.warn('[GENRE-PROTECT] ⚠️ StorageManager.clearReference() BLOQUEADO em modo genre');
                console.warn('[GENRE-PROTECT]   - Preservando:', {
                    selectedGenre: window.__CURRENT_SELECTED_GENRE,
                    mode: window.__CURRENT_MODE__
                });
                return; // NÃO executar limpeza
            }

            console.log('%c[STORAGE-MANAGER] 🗑️ Limpando referência...', 'color:#FF9500;font-weight:bold;');
            try {
                sessionStorage.removeItem('referenceJobId');
                sessionStorage.removeItem('referenceAnalysis');
                console.log('   ✅ sessionStorage limpo');
            } catch (e) {
                console.warn('   ⚠️ Erro ao limpar sessionStorage:', e.message);
            }
            
            try {
                localStorage.removeItem('referenceJobId');
                localStorage.removeItem('referenceAnalysis');
                console.log('   ✅ localStorage limpo');
            } catch (e) {
                console.warn('   ⚠️ Erro ao limpar localStorage:', e.message);
            }
            
            delete window.__REFERENCE_JOB_ID__;
            console.log('   ✅ window.__REFERENCE_JOB_ID__ removido');
        }
    };
    
    console.log('%c[AUDITORIA-STORAGE] ✅ Sistema de storage auditado e StorageManager criado', 'color:#00FF88;font-weight:bold;');
})();

// ========================================
// 🆔 VIRTUAL IDS E ÍNDICE DE PAPÉIS (ANTI-SELF-COMPARE)
// ========================================
// Solução definitiva: Virtual ID composto por jobId + role (USER ou REF)
// Mesmo que backend reutilize jobId, o VID mantém separação por papel
window.CacheIndex ??= { USER: null, REF: null };

// ========================================
// 🧠 SISTEMA DE ARMAZENAMENTO ISOLADO FINAL
// ========================================
/**
 * Sistema simplificado e definitivo para armazenamento de análises.
 * Duas variáveis isoladas: primeira e segunda música.
 * NUNCA mais usar window.__FIRST_ANALYSIS_FROZEN__ ou stateV3.reference.
 */
window.SoundyAI_Store = {
    first: null,   // primeira música
    second: null,  // segunda música
};

/**
 * Salva primeira análise (referência)
 * @param {object} data - Dados da análise
 */
function saveFirstAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.first = JSON.parse(JSON.stringify(data));
    
    console.log('✅ [STORE] Primeira análise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.first?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.first?.technicalData?.lufsIntegrated);
}

/**
 * Salva segunda análise (comparação)
 * @param {object} data - Dados da análise
 */
function saveSecondAnalysis(data) {
    // Deep clone para isolamento total
    window.SoundyAI_Store.second = JSON.parse(JSON.stringify(data));
    
    console.log('✅ [STORE] Segunda análise salva isolada');
    console.log('   - FileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
    console.log('   - JobId:', window.SoundyAI_Store.second?.jobId);
    console.log('   - LUFS:', window.SoundyAI_Store.second?.technicalData?.lufsIntegrated);
}

// ========================================
// 🔬 GERADOR DE SUGESTÕES COMPARATIVAS A vs B
// ========================================

/**
 * Gera sugestões de IA baseadas no delta entre duas análises (A vs B)
 * @param {object} userAnalysis - Análise da faixa atual (B)
 * @param {object} refAnalysis - Análise da referência (A)
 * @returns {array} - Array de sugestões comparativas enriquecidas
 */
function buildComparativeAISuggestions(userAnalysis, refAnalysis) {
    console.log('[A/B-SUGGESTIONS] 🔬 Gerando sugestões comparativas...');
    
    if (!userAnalysis || !refAnalysis) {
        console.warn('[A/B-SUGGESTIONS] ⚠️ Análises incompletas - abortando geração');
        return [];
    }

    // 🔍 Leitura segura de métricas (múltiplos caminhos possíveis)
    const extractMetric = (analysis, metric) => {
        const paths = {
            lufs: [
                analysis?.lufsIntegrated,
                analysis?.avgLoudness,
                analysis?.loudness?.integrated,
                analysis?.technicalData?.lufsIntegrated,
                analysis?.metrics?.loudness?.integrated
            ],
            lra: [
                analysis?.lra,
                analysis?.loudness?.lra,
                analysis?.technicalData?.lra,
                analysis?.metrics?.loudness?.lra
            ],
            tp: [
                analysis?.truePeakDbtp,
                analysis?.truePeak,
                analysis?.loudness?.truePeak,
                analysis?.truePeak?.maxDbtp,
                analysis?.technicalData?.truePeakDbtp,
                analysis?.metrics?.truePeak?.maxDbtp
            ],
            dr: [
                analysis?.dynamicRange,
                analysis?.dynamics?.dynamicRange,
                analysis?.dynamics?.range,
                analysis?.technicalData?.dynamicRange,
                analysis?.metrics?.dynamics?.range
            ],
            cf: [
                analysis?.crestFactor,
                analysis?.dynamics?.crestFactor,
                analysis?.dynamics?.crest,
                analysis?.technicalData?.crestFactor,
                analysis?.metrics?.dynamics?.crest
            ]
        };

        const values = paths[metric] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) {
                return val;
            }
        }
        return null;
    };

    // 📊 Extrair métricas de ambas análises
    const U = {
        lufs: extractMetric(userAnalysis, 'lufs'),
        lra: extractMetric(userAnalysis, 'lra'),
        tp: extractMetric(userAnalysis, 'tp'),
        dr: extractMetric(userAnalysis, 'dr'),
        cf: extractMetric(userAnalysis, 'cf')
    };

    const R = {
        lufs: extractMetric(refAnalysis, 'lufs'),
        lra: extractMetric(refAnalysis, 'lra'),
        tp: extractMetric(refAnalysis, 'tp'),
        dr: extractMetric(refAnalysis, 'dr'),
        cf: extractMetric(refAnalysis, 'cf')
    };

    console.log('[A/B-SUGGESTIONS] 📊 Métricas extraídas:', {
        user: U,
        reference: R
    });

    // 🔢 Calcular deltas (B - A)
    const Δ = {
        lufs: (U.lufs !== null && R.lufs !== null) ? (U.lufs - R.lufs) : null,
        lra: (U.lra !== null && R.lra !== null) ? (U.lra - R.lra) : null,
        tp: (U.tp !== null && R.tp !== null) ? (U.tp - R.tp) : null,
        dr: (U.dr !== null && R.dr !== null) ? (U.dr - R.dr) : null,
        cf: (U.cf !== null && R.cf !== null) ? (U.cf - R.cf) : null
    };

    console.log('[A/B-SUGGESTIONS] 🔢 Deltas calculados:', Δ);

    // 🎚️ Thresholds de relevância
    const TH = {
        lufs: 1.0,    // 1 LUFS = diferença percebível
        lra: 0.5,     // 0.5 LU = mudança na dinâmica
        tp: 0.3,      // 0.3 dBTP = diferença em headroom
        dr: 0.7,      // 0.7 dB = mudança no range dinâmico
        cf: 0.7       // 0.7 = mudança em transientes
    };

    const suggestions = [];

    // ==========================================
    // 1️⃣ LOUDNESS (LUFS Integrado)
    // ==========================================
    if (Δ.lufs !== null && Math.abs(Δ.lufs) >= TH.lufs) {
        const maisBaixo = Δ.lufs < 0;
        const severidade = Math.abs(Δ.lufs) >= 3 ? "CRÍTICA" : (Math.abs(Δ.lufs) >= 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "Loudness (A vs B)",
            severidade: severidade,
            problema: `Sua faixa está ${maisBaixo ? "mais baixa" : "mais alta"} que a referência em ${Math.abs(Δ.lufs).toFixed(2)} LUFS. Faixa atual: ${U.lufs?.toFixed(2)} LUFS vs Referência: ${R.lufs?.toFixed(2)} LUFS.`,
            causaProvavel: maisBaixo
                ? "Gain staging conservador na masterização ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo ou ganho de entrada muito alto.",
            solucao: maisBaixo
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Δ.lufs).toFixed(1)} dB. Use um limiter com ceiling adequado (-0.3 dBTP) e ajuste o input gain até atingir ${R.lufs?.toFixed(1)} LUFS.`
                : `Reduza o input gain do limiter em ${Math.abs(Δ.lufs).toFixed(1)} dB. Reequilibre os buses para evitar compressão excessiva e mantenha o ceiling em -1.0 dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer, Waves L2",
            dicaExtra: "Compare trechos equivalentes (drop/refrão) entre as faixas. Use medidores de loudness (Youlean, LUFS Meter) para monitoramento em tempo real.",
            parametros: {
                alvoLUFS: R.lufs,
                diferenca: Δ.lufs,
                ajusteSugerido: maisBaixo ? `+${Math.abs(Δ.lufs).toFixed(1)} dB` : `-${Math.abs(Δ.lufs).toFixed(1)} dB`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 2️⃣ TRUE PEAK
    // ==========================================
    if (Δ.tp !== null && Math.abs(Δ.tp) >= TH.tp) {
        const maisAlto = Δ.tp > 0;
        const severidade = Math.abs(Δ.tp) >= 1.0 ? "CRÍTICA" : (Math.abs(Δ.tp) >= 0.5 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: "True Peak (A vs B)",
            severidade: severidade,
            problema: `True Peak ${maisAlto ? "maior" : "menor"} que a referência em ${Math.abs(Δ.tp).toFixed(2)} dBTP. Faixa atual: ${U.tp?.toFixed(2)} dBTP vs Referência: ${R.tp?.toFixed(2)} dBTP.`,
            causaProvavel: maisAlto 
                ? "Inter-sample peaks causados por limiter sem oversampling adequado ou clipping digital." 
                : "Headroom excessivo não aproveitado - potencial de ganho adicional.",
            solucao: maisAlto
                ? `Ajuste o ceiling do limiter para máximo de -1.0 dBTP. Habilite oversampling 4x ou superior e revise o release time para evitar distorção intersample.`
                : `Você pode aumentar o ceiling em até ${Math.abs(Δ.tp).toFixed(1)} dB mantendo margem segura. Ajuste para aproximadamente ${R.tp?.toFixed(1)} dBTP.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x-32x), iZotope Ozone Maximizer, Waves L2 Ultramaximizer",
            dicaExtra: "Use medidores de true peak (TT Dynamic Range Meter) e sempre mantenha -0.5 a -1.0 dBTP para distribuição em streaming (Spotify, Apple Music).",
            parametros: {
                alvoTP: R.tp,
                diferenca: Δ.tp,
                ceilingRecomendado: maisAlto ? "-1.0 dBTP" : `${R.tp?.toFixed(1)} dBTP`
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 3️⃣ LRA (Loudness Range - Macro Dinâmica)
    // ==========================================
    if (Δ.lra !== null && Math.abs(Δ.lra) >= TH.lra) {
        const maisEstatica = Δ.lra < 0;
        const severidade = Math.abs(Δ.lra) >= 2.0 ? "ALTA" : (Math.abs(Δ.lra) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "LRA / Dinâmica Macro (A vs B)",
            severidade: severidade,
            problema: `Sua LRA está ${maisEstatica ? "mais baixa" : "mais alta"} que a referência em ${Math.abs(Δ.lra).toFixed(2)} LU. Faixa atual: ${U.lra?.toFixed(2)} LU vs Referência: ${R.lra?.toFixed(2)} LU.`,
            causaProvavel: maisEstatica 
                ? "Compressão e limiting excessivos reduzindo contraste dinâmico entre seções." 
                : "Diferenças de arranjo, automação de volume ou menos processamento dinâmico.",
            solucao: maisEstatica
                ? `Reduza ratio/threshold dos compressores de bus em 2-3 dB. Use automação de volume para criar contrastes entre intro/verso/refrão/drop. Alivie o limiter para preservar dinâmica.`
                : `Ajuste levemente o bus compressor (ratio 2:1-3:1, attack 30ms, release auto) para apertar a macro dinâmica. Considere sidechain compression em elementos rítmicos.`,
            pluginRecomendado: "SSL Bus Compressor, Glue Compressor (Ableton), API 2500, VCA compressor",
            dicaExtra: "LRA ideal para música eletrônica: 3-6 LU. Para rock/pop: 6-10 LU. Use automação de ganho antes de processar para moldar a dinâmica desejada.",
            parametros: {
                alvoLRA: R.lra,
                diferenca: Δ.lra,
                tipoProcessamento: maisEstatica ? "Aliviar compressão" : "Apertar dinâmica"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 4️⃣ DYNAMIC RANGE (DR)
    // ==========================================
    if (Δ.dr !== null && Math.abs(Δ.dr) >= TH.dr) {
        const severidade = Math.abs(Δ.dr) >= 2.0 ? "ALTA" : (Math.abs(Δ.dr) >= 1.0 ? "MODERADA" : "LEVE");
        
        suggestions.push({
            categoria: "Dynamic Range (A vs B)",
            severidade: severidade,
            problema: `Dynamic Range difere em ${Math.abs(Δ.dr).toFixed(2)} dB da referência. Faixa atual: ${U.dr?.toFixed(2)} dB vs Referência: ${R.dr?.toFixed(2)} dB.`,
            causaProvavel: "Relação entre picos e RMS (média de energia) diferente da referência devido a processamento dinâmico distinto.",
            solucao: `Ajuste compressão nos subgrupos (drums, bass, synths) para aproximar DR de ${R.dr?.toFixed(1)} dB. Use clippers transparentes antes do limiter para controlar transientes sem perder corpo.`,
            pluginRecomendado: "Clipper transparente (StandardCLIP, K-Clip), bus compressor multi-banda",
            dicaExtra: "DR típico por gênero: EDM (4-6 dB), Pop (6-8 dB), Rock (8-12 dB). Valores muito baixos (<4 dB) indicam overprocessing.",
            parametros: {
                alvoDR: R.dr,
                diferenca: Δ.dr,
                drIdeal: R.dr?.toFixed(1) + " dB"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 5️⃣ CREST FACTOR (Relação Pico/RMS)
    // ==========================================
    if (Δ.cf !== null && Math.abs(Δ.cf) >= TH.cf) {
        const severidade = Math.abs(Δ.cf) >= 1.5 ? "MODERADA" : "LEVE";
        
        suggestions.push({
            categoria: "Crest Factor (A vs B)",
            severidade: severidade,
            problema: `Crest Factor difere em ${Math.abs(Δ.cf).toFixed(2)} dB da referência. Faixa atual: ${U.cf?.toFixed(2)} vs Referência: ${R.cf?.toFixed(2)}.`,
            causaProvavel: "Transientes (kicks, snares, attacks) com intensidades diferentes entre as faixas.",
            solucao: `Ajuste attack/release de compressores para aproximar punch da referência. Use transient shapers para moldar ataques de percussão. CF alvo: ${R.cf?.toFixed(1)}.`,
            pluginRecomendado: "SPL Transient Designer, Oxford Transmod, Waves Trans-X, saturação sutil (decapitator)",
            dicaExtra: "CF alto = mais transientes (>10 dB). CF baixo = som mais constante (<6 dB). Use saturação para adicionar harmônicos e corpo sem aumentar picos.",
            parametros: {
                alvoCF: R.cf,
                diferenca: Δ.cf,
                ajusteTransientes: Δ.cf < 0 ? "Aumentar ataques" : "Suavizar transientes"
            },
            aiEnhanced: true
        });
    }

    // ==========================================
    // 6️⃣ BANDAS ESPECTRAIS (A vs B) - MODO REFERENCE
    // 🎯 CORREÇÃO: Adicionar sugestões de bandas no modo referência
    // ==========================================
    const extractBandsFromAnalysis = (analysis) => {
        return analysis?.bands ||
               analysis?.technicalData?.spectral_balance ||
               analysis?.technicalData?.bands ||
               analysis?.metrics?.bands ||
               analysis?.metrics?.spectral_balance ||
               null;
    };

    const userBands = extractBandsFromAnalysis(userAnalysis);
    const refBands = extractBandsFromAnalysis(refAnalysis);

    console.log('[A/B-SUGGESTIONS] 🎵 Bandas extraídas:', {
        userHasBands: !!userBands,
        refHasBands: !!refBands,
        userBandKeys: userBands ? Object.keys(userBands) : null,
        refBandKeys: refBands ? Object.keys(refBands) : null
    });

    if (userBands && refBands) {
        // Mapeamento de nomes de bandas (snake_case → display name)
        const bandNameMap = {
            'sub': { name: 'Sub Bass (20-60 Hz)', icon: '🔊' },
            'sub_bass': { name: 'Sub Bass (20-60 Hz)', icon: '🔊' },
            'low_bass': { name: 'Low Bass (60-120 Hz)', icon: '🎸' },
            'upper_bass': { name: 'Upper Bass (120-250 Hz)', icon: '🎸' },
            'bass': { name: 'Bass (60-250 Hz)', icon: '🎸' },
            'low_mid': { name: 'Low Mids (250-500 Hz)', icon: '🎹' },
            'lowMid': { name: 'Low Mids (250-500 Hz)', icon: '🎹' },
            'mid': { name: 'Mids (500-2000 Hz)', icon: '🎤' },
            'mids': { name: 'Mids (500-2000 Hz)', icon: '🎤' },
            'high_mid': { name: 'High Mids (2-5 kHz)', icon: '✨' },
            'highMid': { name: 'High Mids (2-5 kHz)', icon: '✨' },
            'presence': { name: 'Presence (5-10 kHz)', icon: '🔔' },
            'presenca': { name: 'Presence (5-10 kHz)', icon: '🔔' },
            'air': { name: 'Air/Brilho (10-20 kHz)', icon: '💫' },
            'brilho': { name: 'Air/Brilho (10-20 kHz)', icon: '💫' },
            'brilliance': { name: 'Air/Brilho (10-20 kHz)', icon: '💫' }
        };

        // Threshold para considerar diferença significativa em bandas (dB)
        const BAND_THRESHOLD_DB = 1.5; // 1.5 dB de diferença

        // Iterar sobre todas as bandas disponíveis na referência
        const allBandKeys = new Set([
            ...Object.keys(userBands),
            ...Object.keys(refBands)
        ]);

        let bandSuggestionsGenerated = 0;

        for (const bandKey of allBandKeys) {
            const userBand = userBands[bandKey];
            const refBand = refBands[bandKey];

            if (!userBand || !refBand) continue;

            // Extrair valores de energia (dB)
            const userValue = typeof userBand === 'object' 
                ? (userBand.energy_db ?? userBand.rms_db ?? userBand.percentage ?? userBand.value)
                : userBand;
            
            const refValue = typeof refBand === 'object'
                ? (refBand.energy_db ?? refBand.rms_db ?? refBand.percentage ?? refBand.value)
                : refBand;

            if (typeof userValue !== 'number' || typeof refValue !== 'number') continue;
            if (isNaN(userValue) || isNaN(refValue)) continue;

            const delta = userValue - refValue;
            const absDelta = Math.abs(delta);

            // Apenas gerar sugestão se diferença for significativa
            if (absDelta < BAND_THRESHOLD_DB) continue;

            const bandInfo = bandNameMap[bandKey] || { name: bandKey, icon: '🎵' };
            const severidade = absDelta >= 4.0 ? "ALTA" : (absDelta >= 2.5 ? "MODERADA" : "LEVE");
            const direcao = delta > 0 ? "acima" : "abaixo";
            const acao = delta > 0 ? "Reduza" : "Aumente";

            suggestions.push({
                categoria: `${bandInfo.icon} ${bandInfo.name} (A vs B)`,
                severidade: severidade,
                metric: `band_${bandKey}`,
                type: 'band_adjust',
                subtype: bandKey,
                problema: `Banda ${bandInfo.name} está ${direcao} da referência em ${absDelta.toFixed(1)} dB. Sua faixa: ${userValue.toFixed(1)} dB vs Referência: ${refValue.toFixed(1)} dB.`,
                causaProvavel: delta > 0
                    ? `Excesso de energia em ${bandInfo.name} pode causar turbidez ou mascaramento de outras frequências.`
                    : `Déficit de energia em ${bandInfo.name} pode resultar em mix thin ou falta de corpo nessa região.`,
                solucao: `${acao} a banda ${bandInfo.name} em aproximadamente ${absDelta.toFixed(1)} dB usando EQ paramétrico ou shelving.`,
                pluginRecomendado: "FabFilter Pro-Q 3, Waves SSL G-EQ, iZotope Ozone EQ",
                dicaExtra: `Compare A/B para garantir que o ajuste aproxima sua faixa da referência. Use analisador de espectro para monitorar.`,
                parametros: {
                    banda: bandKey,
                    bandaNome: bandInfo.name,
                    valorAtual: userValue,
                    valorReferencia: refValue,
                    diferenca: delta,
                    ajusteSugerido: `${acao} ${absDelta.toFixed(1)} dB`
                },
                technical: {
                    delta: delta,
                    currentValue: userValue,
                    targetValue: refValue,
                    tolerance: BAND_THRESHOLD_DB
                },
                aiEnhanced: true,
                referenceMode: true
            });

            bandSuggestionsGenerated++;
        }

        console.log(`[A/B-SUGGESTIONS] 🎵 Bandas espectrais: ${bandSuggestionsGenerated} sugestões geradas`);
    } else {
        console.warn('[A/B-SUGGESTIONS] ⚠️ Bandas não disponíveis para comparação A/B');
    }

    // ==========================================
    // 📊 RESULTADO FINAL
    // ==========================================
    console.log(`[A/B-SUGGESTIONS] ✅ Geradas ${suggestions.length} sugestões comparativas (métricas + bandas)`);
    
    if (suggestions.length > 0) {
        console.log('[A/B-SUGGESTIONS] 📋 Resumo das sugestões:', 
            suggestions.map(s => `${s.categoria} (${s.severidade})`).join(', ')
        );
    }

    // 🎯 CORREÇÃO: Aumentar limite para incluir métricas E bandas (até 12 sugestões)
    // Separar por tipo para garantir representação de ambos
    const metricSuggestions = suggestions.filter(s => !s.referenceMode);
    const bandSuggestions = suggestions.filter(s => s.referenceMode === true);
    
    console.log(`[A/B-SUGGESTIONS] 📊 Distribuição: ${metricSuggestions.length} métricas + ${bandSuggestions.length} bandas`);

    // Ordenar por severidade
    const severityOrder = { "CRÍTICA": 0, "ALTA": 1, "MODERADA": 2, "IMPORTANTE": 3, "LEVE": 4 };
    const sortBySeverity = (a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5);

    // Garantir até 5 métricas + até 7 bandas = 12 total
    const selectedMetrics = metricSuggestions.sort(sortBySeverity).slice(0, 5);
    const selectedBands = bandSuggestions.sort(sortBySeverity).slice(0, 7);
    
    const finalSuggestions = [...selectedMetrics, ...selectedBands]
        .sort(sortBySeverity);
    
    console.log(`[A/B-SUGGESTIONS] 🎯 Final: ${finalSuggestions.length} sugestões (${selectedMetrics.length} métricas + ${selectedBands.length} bandas)`);
    
    return finalSuggestions;
}

// ========================================
// 🎯 PATCH 2: SUGESTÕES BASEADAS EM GÊNERO
// ========================================

/**
 * 🎯 GERAR SUGESTÕES BASEADAS EM TARGETS DE GÊNERO
 * @param {Object} analysis - Análise do usuário
 * @param {Object} genreTargets - Targets do gênero (de analysis.data.genreTargets)
 * @returns {Array} - Array de sugestões formatadas
 */
function buildGenreBasedAISuggestions(analysis, genreTargets) {
    console.log('[GENRE-SUGGESTIONS] 🎯 Gerando sugestões baseadas em gênero...');
    
    if (!analysis || !genreTargets) {
        console.warn('[GENRE-SUGGESTIONS] ⚠️ Dados incompletos - abortando geração');
        return [];
    }

    // 🔍 Extrair métricas do usuário
    const extractMetric = (path) => {
        const paths = {
            lufs: [
                analysis.lufsIntegrated,
                analysis.avgLoudness,
                analysis.loudness?.integrated,
                analysis.technicalData?.lufsIntegrated
            ],
            lra: [
                analysis.lra,
                analysis.loudness?.lra,
                analysis.technicalData?.lra
            ],
            tp: [
                analysis.truePeakDbtp,
                analysis.truePeak?.maxDbtp,
                analysis.technicalData?.truePeakDbtp
            ],
            dr: [
                analysis.dynamicRange,
                analysis.dynamics?.range,
                analysis.technicalData?.dynamicRange
            ],
            stereo: [
                analysis.stereoCorrelation,
                analysis.stereo?.correlation,
                analysis.technicalData?.stereoCorrelation
            ]
        };

        const values = paths[path] || [];
        for (const val of values) {
            if (typeof val === 'number' && !isNaN(val)) return val;
        }
        return null;
    };

    // 📊 Métricas do usuário
    const U = {
        lufs: extractMetric('lufs'),
        lra: extractMetric('lra'),
        tp: extractMetric('tp'),
        dr: extractMetric('dr'),
        stereo: extractMetric('stereo')
    };

    // 🎯 Targets do gênero (estrutura flat do backend normalizado)
    const T = {
        lufs: genreTargets.lufs_target,
        lra: genreTargets.lra_target,
        tp: genreTargets.true_peak_target,
        dr: genreTargets.dr_target,
        stereo: genreTargets.stereo_target
    };

    // 🔢 Tolerâncias
    const TOL = {
        lufs: genreTargets.lufs_tolerance || 1.0,
        lra: genreTargets.lra_tolerance || 0.5,
        tp: genreTargets.true_peak_tolerance || 0.3,
        dr: genreTargets.dr_tolerance || 0.7,
        stereo: genreTargets.stereo_tolerance || 0.05
    };

    console.log('[GENRE-SUGGESTIONS] 📊 Dados:', { user: U, targets: T, tolerances: TOL });

    // 🔢 Calcular deltas
    const Δ = {
        lufs: (U.lufs !== null && T.lufs !== null) ? (U.lufs - T.lufs) : null,
        lra: (U.lra !== null && T.lra !== null) ? (U.lra - T.lra) : null,
        tp: (U.tp !== null && T.tp !== null) ? (U.tp - T.tp) : null,
        dr: (U.dr !== null && T.dr !== null) ? (U.dr - T.dr) : null,
        stereo: (U.stereo !== null && T.stereo !== null) ? (U.stereo - T.stereo) : null
    };

    const suggestions = [];
    const genreName = analysis.genre || analysis.data?.genre || 'este gênero';

    // 1️⃣ LUFS
    if (Δ.lufs !== null && Math.abs(Δ.lufs) > TOL.lufs) {
        const dentroDoAlvo = Math.abs(Δ.lufs) <= TOL.lufs;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Δ.lufs) > TOL.lufs * 2 ? "CRÍTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `Loudness (Padrão ${genreName})`,
            severidade,
            problema: `Sua faixa está ${Δ.lufs < 0 ? 'mais baixa' : 'mais alta'} que o padrão ${genreName} em ${Math.abs(Δ.lufs).toFixed(2)} LUFS. Atual: ${U.lufs?.toFixed(2)} LUFS | Alvo: ${T.lufs?.toFixed(1)} LUFS.`,
            causaProvavel: Δ.lufs < 0
                ? "Gain staging conservador ou limiter com threshold muito baixo."
                : "Limiter excessivamente agressivo.",
            solucao: Δ.lufs < 0
                ? `Aumente o ganho no bus master em aproximadamente ${Math.abs(Δ.lufs).toFixed(1)} dB.`
                : `Reduza o input gain do limiter em ${Math.abs(Δ.lufs).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2, iZotope Ozone Maximizer",
            parametros: {
                alvoLUFS: T.lufs,
                diferenca: Δ.lufs,
                tolerancia: TOL.lufs
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 2️⃣ TRUE PEAK
    if (Δ.tp !== null && Math.abs(Δ.tp) > TOL.tp) {
        const dentroDoAlvo = Math.abs(Δ.tp) <= TOL.tp;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Δ.tp) > TOL.tp * 2 ? "CRÍTICA" : "MODERADA");
        
        suggestions.push({
            categoria: `True Peak (Padrão ${genreName})`,
            severidade,
            problema: `True Peak ${Δ.tp > 0 ? 'maior' : 'menor'} que o padrão em ${Math.abs(Δ.tp).toFixed(2)} dBTP. Atual: ${U.tp?.toFixed(2)} dBTP | Alvo: ${T.tp?.toFixed(1)} dBTP.`,
            causaProvavel: Δ.tp > 0
                ? "Inter-sample peaks causados por limiter sem oversampling adequado."
                : "Headroom excessivo não aproveitado.",
            solucao: Δ.tp > 0
                ? `Ajuste o ceiling do limiter para máximo de -1.0 dBTP com oversampling 4x.`
                : `Você pode aumentar o ceiling em até ${Math.abs(Δ.tp).toFixed(1)} dB.`,
            pluginRecomendado: "FabFilter Pro-L 2 (oversampling 4x)",
            parametros: {
                alvoTP: T.tp,
                diferenca: Δ.tp,
                tolerancia: TOL.tp
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 3️⃣ DYNAMIC RANGE
    if (Δ.dr !== null && Math.abs(Δ.dr) > TOL.dr) {
        const dentroDoAlvo = Math.abs(Δ.dr) <= TOL.dr;
        const severidade = dentroDoAlvo ? "OK" : (Math.abs(Δ.dr) > TOL.dr * 2 ? "ALTA" : "MODERADA");
        
        suggestions.push({
            categoria: `Dynamic Range (Padrão ${genreName})`,
            severidade,
            problema: `DR difere do padrão ${genreName} em ${Math.abs(Δ.dr).toFixed(2)} dB. Atual: ${U.dr?.toFixed(2)} dB | Alvo: ${T.dr?.toFixed(1)} dB.`,
            solucao: `Ajuste compressão nos subgrupos para aproximar DR de ${T.dr?.toFixed(1)} dB.`,
            parametros: {
                alvoDR: T.dr,
                diferenca: Δ.dr,
                tolerancia: TOL.dr
            },
            aiEnhanced: true,
            genreBased: true
        });
    }

    // 🎵 BANDAS ESPECTRAIS V4.1 - CORRIGIDO PARA USAR MESMA FONTE QUE TABELA
    // O JSON de gênero usa: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
    const targetBands = genreTargets.bands || genreTargets.spectralBands;
    
    if (targetBands && Object.keys(targetBands).length > 0) {
        const userBands = analysis.metrics?.bands || analysis.technicalData?.spectral_balance;
        
        if (userBands) {
            // V4.1: Iterar sobre TODAS as bandas do JSON de targets
            const ALL_JSON_BANDS = ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca'];
            
            // Mapeamento reverso: JSON key → canonical key (para buscar valores do usuário)
            const REVERSE_MAP = {
                'low_bass': 'bass',
                'upper_bass': 'bass',
                'low_mid': 'lowMid',
                'high_mid': 'highMid',
                'brilho': 'air',
                'presenca': 'presence'
            };
            
            // Nomes legíveis para cada banda
            const BAND_NAMES = {
                'sub': 'Sub Bass (20-60Hz)',
                'low_bass': 'Low Bass (60-120Hz)',
                'upper_bass': 'Upper Bass (120-250Hz)',
                'low_mid': 'Low Mids (250-500Hz)',
                'mid': 'Mids (500Hz-2kHz)',
                'high_mid': 'High Mids (2-5kHz)',
                'brilho': 'Air/Brilho (10-20kHz)',
                'presenca': 'Presence (5-10kHz)'
            };
            
            ALL_JSON_BANDS.forEach(jsonBand => {
                const targetDef = targetBands[jsonBand];
                if (!targetDef) return;
                
                // Buscar valor do usuário (tentar chave JSON e chave canônica)
                const canonicalKey = REVERSE_MAP[jsonBand] || jsonBand;
                const userValue = userBands[jsonBand]?.energy_db 
                               ?? userBands[jsonBand]?.percentage 
                               ?? userBands[canonicalKey]?.energy_db 
                               ?? userBands[canonicalKey]?.percentage;
                
                // Extrair target do JSON
                const targetValue = targetDef.target_db ?? targetDef.target ?? targetDef.percentage;
                const tolerance = targetDef.tol_db || targetDef.tolerance || 2.5;
                const bandName = BAND_NAMES[jsonBand] || jsonBand;
                
                if (userValue !== null && userValue !== undefined && targetValue !== null && targetValue !== undefined) {
                    const delta = userValue - targetValue;
                    
                    // V4.1: Só gerar sugestão se fora da tolerância (COERENTE COM TABELA)
                    if (Math.abs(delta) > tolerance) {
                        // Determinar severidade baseada na severity do JSON ou no delta
                        const severity = targetDef.severity || (Math.abs(delta) > tolerance * 2 ? "ALTA" : "MODERADA");
                        
                        suggestions.push({
                            categoria: `Banda ${bandName} (Padrão ${genreName})`,
                            severidade: severity,
                            problema: `Banda ${bandName} ${delta > 0 ? 'acima' : 'abaixo'} do padrão em ${Math.abs(delta).toFixed(1)} dB. Atual: ${userValue.toFixed(1)} dB | Alvo: ${targetValue.toFixed(1)} dB.`,
                            solucao: delta > 0
                                ? `Reduza frequências ${bandName} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`
                                : `Aumente frequências ${bandName} com EQ em ~${Math.abs(delta).toFixed(1)} dB.`,
                            parametros: {
                                banda: jsonBand,
                                bandaNome: bandName,
                                alvo: targetValue,
                                diferenca: delta,
                                tolerancia: tolerance
                            },
                            aiEnhanced: true,
                            genreBased: true
                        });
                    }
                }
            });
        }
    }

    console.log(`[GENRE-SUGGESTIONS] ✅ Geradas ${suggestions.length} sugestões baseadas em gênero`);
    
    // Limitar a 8 sugestões mais relevantes (5 métricas + top 3 bandas)
    const severityOrder = { "CRÍTICA": 0, "ALTA": 1, "MODERADA": 2, "OK": 3 };
    return suggestions
        .sort((a, b) => (severityOrder[a.severidade] || 5) - (severityOrder[b.severidade] || 5))
        .slice(0, 8);
}

// ========================================
// 🤖 SISTEMA DE ESPERA POR ENRIQUECIMENTO IA
// ========================================

/**
 * Aguarda o enriquecimento IA (aiSuggestions) estar disponível
 * @param {string} jobId - ID do job para consultar
 * @param {number} timeout - Tempo máximo de espera em ms (padrão: 10000ms = 10s)
 * @param {number} pollInterval - Intervalo entre consultas em ms (padrão: 1000ms = 1s)
 * @returns {Promise<object|null>} - Dados enriquecidos ou null se timeout
 */
async function waitForAIEnrichment(jobId, timeout = 10000, pollInterval = 1000) {
    // PATCH JOB-ID: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== 'string' || jobId === 'undefined') {
        console.error('[AI-SYNC] ❌ jobId inválido ou undefined:', jobId);
        console.error('[AI-SYNC] ❌ Abortando waitForAIEnrichment - não é possível consultar job inválido');
        return null;
    }
    
    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('[AI-SYNC] ⏳ Aguardando enriquecimento IA...');
    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('[AI-SYNC] 🆔 Job ID:', jobId);
    console.log('[AI-SYNC] ⏱️ Timeout:', timeout, 'ms');
    console.log('[AI-SYNC] 🔄 Poll interval:', pollInterval, 'ms');
    
    const startTime = Date.now();
    let attempt = 0;
    
    while (Date.now() - startTime < timeout) {
        attempt++;
        const elapsed = Date.now() - startTime;
        
        console.log(`[AI-SYNC] 🔍 Tentativa ${attempt} (${elapsed}ms/${timeout}ms)...`);
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`);
            
            if (!response.ok) {
                console.warn(`[AI-SYNC] ⚠️ HTTP ${response.status} - Tentando novamente...`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
            }
            
            const data = await response.json();
            
            console.log(`[AI-SYNC] 📦 Resposta recebida (tentativa ${attempt}):`, {
                hasAiSuggestions: Array.isArray(data.aiSuggestions),
                aiSuggestionsLength: data.aiSuggestions?.length || 0,
                hasSuggestions: Array.isArray(data.suggestions),
                suggestionsLength: data.suggestions?.length || 0,
                status: data.status
            });
            
            // 🎯 CORREÇÃO #5: Se status=completed E aiSuggestions>0, renderizar (não esperar aiEnhanced)
            if (data.status === 'completed' && Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log('[AI-SYNC] ✅ Status COMPLETED + aiSuggestions disponíveis');
                console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log('[AI-SYNC] 📊 Total:', data.aiSuggestions.length, 'sugestões');
                console.log('[AI-SYNC] ⏱️ Tempo decorrido:', Date.now() - startTime, 'ms');
                console.log('[AI-SYNC] 🔓 Renderizando SEM esperar aiEnhanced (evitar loop)');
                return data;
            }
            
            // ✅ VERIFICAÇÃO SECUNDÁRIA: aiSuggestions existe E tem conteúdo com aiEnhanced
            if (Array.isArray(data.aiSuggestions) && data.aiSuggestions.length > 0) {
                // Verificar se pelo menos 1 tem aiEnhanced: true
                const aiEnhancedCount = data.aiSuggestions.filter(s => s.aiEnhanced === true).length;
                
                console.log(`[AI-SYNC] 🎯 aiSuggestions encontrado:`, {
                    total: data.aiSuggestions.length,
                    aiEnhanced: aiEnhancedCount
                });
                
                if (aiEnhancedCount > 0) {
                    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('[AI-SYNC] ✅✅✅ ENRIQUECIMENTO IA CONCLUÍDO! ✅✅✅');
                    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('[AI-SYNC] 📊 Total:', data.aiSuggestions.length, 'sugestões');
                    console.log('[AI-SYNC] 🤖 Marcadas como aiEnhanced:', aiEnhancedCount);
                    console.log('[AI-SYNC] ⏱️ Tempo decorrido:', Date.now() - startTime, 'ms');
                    console.log('[AI-SYNC] 📋 Sample da primeira:', {
                        aiEnhanced: data.aiSuggestions[0]?.aiEnhanced,
                        categoria: data.aiSuggestions[0]?.categoria,
                        nivel: data.aiSuggestions[0]?.nivel,
                        hasProblema: !!data.aiSuggestions[0]?.problema,
                        hasSolucao: !!data.aiSuggestions[0]?.solucao
                    });
                    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    
                    return data;
                }
            }
            
            // Se chegou aqui, ainda aguardando
            console.log(`[AI-SYNC] ⏳ Aguardando aiSuggestions... (status: ${data.status})`);
            
        } catch (error) {
            console.error(`[AI-SYNC] ❌ Erro na tentativa ${attempt}:`, error.message);
        }
        
        // Aguardar antes da próxima tentativa
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    
    // Timeout atingido
    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('[AI-SYNC] ⏱️ TIMEOUT ATINGIDO');
    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.warn('[AI-SYNC] ⚠️ Enriquecimento IA não completou dentro do tempo limite');
    console.warn('[AI-SYNC] ⚠️ Total de tentativas:', attempt);
    console.warn('[AI-SYNC] ⚠️ Tempo decorrido:', Date.now() - startTime, 'ms');
    console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    
    return null;
}

/**
 * Mostra spinner visual de carregamento IA
 * @param {string} message - Mensagem a exibir
 */
function showAILoadingSpinner(message = 'Conectando à IA...') {
    console.log('[AI-UI][SPINNER] 🔄 Mostrando spinner:', message);
    
    // Tentar inserir no elemento de status do modal se existir
    const statusElement = document.querySelector('#ai-enrichment-status') || 
                         document.querySelector('.modal-status') ||
                         document.querySelector('.analysis-status');
    
    if (statusElement) {
        statusElement.innerHTML = `
            <div class="ai-loading-spinner" id="aiEnrichmentSpinner">
                <div class="spinner-icon">🔄</div>
                <div class="spinner-message">${message}</div>
                <div class="spinner-dots">
                    <span class="dot">●</span>
                    <span class="dot">●</span>
                    <span class="dot">●</span>
                </div>
            </div>
        `;
        
        // Adicionar animação via CSS inline
        const style = document.createElement('style');
        style.textContent = `
            .ai-loading-spinner {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background: rgba(0, 0, 0, 0.05);
                border-radius: 8px;
                margin: 10px 0;
            }
            .spinner-icon {
                font-size: 32px;
                animation: spin 2s linear infinite;
            }
            .spinner-message {
                font-size: 14px;
                color: #666;
                margin: 10px 0 5px 0;
                font-weight: 500;
            }
            .spinner-dots {
                display: flex;
                gap: 4px;
            }
            .spinner-dots .dot {
                font-size: 8px;
                animation: pulse 1.5s ease-in-out infinite;
            }
            .spinner-dots .dot:nth-child(2) {
                animation-delay: 0.2s;
            }
            .spinner-dots .dot:nth-child(3) {
                animation-delay: 0.4s;
            }
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
        `;
        
        if (!document.getElementById('aiSpinnerStyles')) {
            style.id = 'aiSpinnerStyles';
            document.head.appendChild(style);
        }
    } else {
        console.warn('[AI-UI][SPINNER] ⚠️ Elemento de status não encontrado');
    }
}

/**
 * Remove spinner visual de carregamento IA
 */
function hideAILoadingSpinner() {
    console.log('[AI-UI][SPINNER] ✅ Removendo spinner');
    
    const spinner = document.getElementById('aiEnrichmentSpinner');
    if (spinner) {
        spinner.remove();
    }
}

/**
 * Obtém par de análises para comparação
 * @returns {object|null} { ref, curr } ou null se alguma análise estiver faltando
 */
function getComparisonPair() {
    const ref = window.SoundyAI_Store.first;
    const curr = window.SoundyAI_Store.second;
    
    if (!ref || !curr) {
        console.warn('⚠️ [STORE] Ainda falta uma das análises para comparar');
        console.warn('   - first:', !!ref);
        console.warn('   - second:', !!curr);
        return null;
    }
    
    console.log('📦 [STORE] Par de análises obtido');
    console.log('   - ref.jobId:', ref?.jobId);
    console.log('   - curr.jobId:', curr?.jobId);
    console.log('   - ref.fileName:', ref?.fileName || ref?.metadata?.fileName);
    console.log('   - curr.fileName:', curr?.fileName || curr?.metadata?.fileName);
    
    // 🔒 AUDITORIA AUTOMÁTICA
    console.table({
        refJob: ref?.jobId,
        currJob: curr?.jobId,
        refName: ref?.fileName || ref?.metadata?.fileName,
        currName: curr?.fileName || curr?.metadata?.fileName,
        sameJob: ref?.jobId === curr?.jobId,
        sameName: (ref?.fileName || ref?.metadata?.fileName) === (curr?.fileName || curr?.metadata?.fileName)
    });
    
    // 🚨 VALIDAÇÃO CRÍTICA: Usar identidade de track (jobId > fileKey > fileName)
    const refIdentity = getTrackIdentity(ref);
    const currIdentity = getTrackIdentity(curr);
    
    // Prioridade 1: jobId (chave primária)
    if (refIdentity.jobId && currIdentity.jobId && refIdentity.jobId === currIdentity.jobId) {
        console.error('🚨 [STORE-ERROR] CONTAMINAÇÃO DETECTADA!');
        console.error('   JobIds são IGUAIS:', refIdentity.jobId);
        console.error('   Isso NÃO DEVERIA ACONTECER com sistema isolado');
        console.trace();
        return null; // Bloquear renderização se jobIds iguais
    }
    
    // Prioridade 2: fileKey (chave secundária)
    if (refIdentity.fileKey && currIdentity.fileKey && refIdentity.fileKey === currIdentity.fileKey) {
        console.warn('⚠️ [STORE-WARNING] FileKeys iguais (porém jobIds diferentes):', refIdentity.fileKey);
        console.warn('   Isso pode indicar re-upload do mesmo arquivo');
        // Não bloqueia reference BASE, apenas avisa
    }
    
    // Prioridade 3: fileName (terciária - apenas se ambos strings válidas)
    // ✅ CORREÇÃO: Só comparar fileName se AMBOS são strings não vazias
    const refHasValidFileName = refIdentity.fileName && typeof refIdentity.fileName === 'string' && refIdentity.fileName.trim().length > 0;
    const currHasValidFileName = currIdentity.fileName && typeof currIdentity.fileName === 'string' && currIdentity.fileName.trim().length > 0;
    
    if (refHasValidFileName && currHasValidFileName && refIdentity.fileName === currIdentity.fileName) {
        console.info('ℹ️ [STORE-INFO] Nomes de arquivo iguais:', refIdentity.fileName);
        console.info('   Isso é OK se jobIds/fileKeys forem diferentes');
    } else if (!refHasValidFileName || !currHasValidFileName) {
        console.info('ℹ️ [STORE-INFO] fileName ausente/inválido (normal no reference BASE)');
    }
    
    return { ref, curr };
}

// ========================================
// 🔧 UTILIDADES DE CLONAGEM PROFUNDA
// ========================================
/**
 * Clone profundo seguro - tenta structuredClone, fallback para JSON
 * @param {*} obj - Objeto a ser clonado
 * @returns {*} Clone independente ou objeto original (último recurso)
 */
function cloneDeepSafe(obj) {
  if (!obj) return obj;
  try { return structuredClone(obj); } catch {}
  try { return JSON.parse(JSON.stringify(obj)); } catch {}
  return obj; // último recurso (não deve acontecer)
}

// ========================================
// 🔒 PASSO 2: PROTEÇÃO DE JOBID (ANTI-CONTAMINAÇÃO)
// ========================================
/**
 * Protege window.__CURRENT_JOB_ID__ contra sobrescrita acidental
 * Bloqueia tentativas de contaminar com __REFERENCE_JOB_ID__
 */
function protectCurrentJobId(initialValue) {
    // Armazena valor privado
    let _currentJobId = initialValue;
    
    // Redefine a propriedade com getter/setter protegido
    Object.defineProperty(window, '__CURRENT_JOB_ID__', {
        configurable: true,
        enumerable: true,
        set: function(value) {
            console.group('⚠️ [PROTECTION] Tentativa de alterar currentJobId');
            console.log('   - Valor antigo:', _currentJobId);
            console.log('   - Valor novo:', value);
            console.trace('   - Stack trace:');
            console.groupEnd();
            
            // BLOQUEIO: Se tentar contaminar com referenceJobId
            if (value && value === window.__REFERENCE_JOB_ID__) {
                console.error('❌ [PROTECTION] BLOQUEADO! Tentativa de contaminar currentJobId com referenceJobId!');
                console.error('❌ [PROTECTION] Mantendo valor original:', _currentJobId);
                return; // BLOQUEIA a alteração
            }
            
            // BLOQUEIO: Se já tiver valor e tentar alterar sem justificativa
            if (_currentJobId && value && _currentJobId !== value) {
                console.warn('⚠️ [PROTECTION] Sobrescrita de currentJobId detectada!');
                console.warn('   Antigo:', _currentJobId);
                console.warn('   Novo:', value);
            }
            
            _currentJobId = value;
            console.log('✅ [PROTECTION] currentJobId atualizado:', _currentJobId);
        },
        get: function() {
            return _currentJobId;
        }
    });
    
    console.log('🔒 [PROTECTION] Proteção de currentJobId ativada com valor inicial:', initialValue);
}

// ========================================
// 🛡️ PASSO 3: FUNÇÃO SEGURA PARA OBTER JOBID
// ========================================
/**
 * Retorna o jobId correto baseado no modo, com proteção contra contaminação
 * @param {string} mode - 'reference' ou 'genre'
 * @returns {string|null} jobId seguro
 */
/**
 * ⚠️ DEPRECATED - USE getCorrectJobId() INSTEAD
 * Esta função está DEPRECADA e será removida em versões futuras.
 * MOTIVO: Acessa localStorage diretamente sem validação, causando bug de comparação com mesma música.
 * @deprecated Use getCorrectJobId(context) em vez disso
 */
function getJobIdSafely(mode) {
    console.error('⚠️ [DEPRECATED] getJobIdSafely() está DEPRECADA! Use getCorrectJobId() em vez disso.');
    console.trace('🔍 [DEPRECATED] Stack trace de quem chamou a função deprecada:');
    
    // Redirecionar para a função correta
    if (mode === 'reference') {
        return getCorrectJobId('reference');
    } else if (mode === 'storage') {
        return getCorrectJobId('storage');
    } else {
        return getCorrectJobId('current');
    }
}

// ========================================
// 🎯 FUNÇÃO UTILITÁRIA CRÍTICA: getCorrectJobId
// ========================================
/**
 * Retorna o jobId correto baseado no contexto
 * NUNCA use localStorage.getItem('referenceJobId') diretamente!
 * SEMPRE use esta função!
 * 
 * @param {string} context - 'user'|'second'|'current' = segunda música
 *                          'reference'|'first' = primeira música
 *                          'storage' = fallback para localStorage
 * @returns {string|null} jobId correto para o contexto
 */
function getCorrectJobId(context) {
    const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
    
    console.group(`🎯 [GET-CORRECT-JOBID] Contexto: ${context}`);
    console.log('   - Modo atual:', mode);
    console.log('   - window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - sessionStorage.currentJobId:', sessionStorage.getItem('currentJobId'));
    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    
    if (mode === 'reference') {
        // Em modo reference, temos dois jobIds diferentes
        const currentJobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId');
        
        // 🔧 CORREÇÃO: Usar StorageManager para ler referenceJobId
        const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
        
        // 🚨 VALIDAÇÃO CRÍTICA: NUNCA retornar jobIds iguais
        if (currentJobId && referenceJobId && currentJobId === referenceJobId) {
            console.error('❌ [CRITICAL] JobIds são iguais! Isso NÃO deveria acontecer!');
            console.error('   currentJobId:', currentJobId);
            console.error('   referenceJobId:', referenceJobId);
            console.error('   context:', context);
            console.trace();
            
            // Tenta recuperar do sessionStorage
            const recoveredJobId = sessionStorage.getItem('currentJobId');
            if (recoveredJobId && recoveredJobId !== referenceJobId) {
                console.warn('⚠️ [RECOVERY] JobId recuperado do sessionStorage:', recoveredJobId);
                window.__CURRENT_JOB_ID__ = recoveredJobId;
                console.groupEnd();
                return recoveredJobId;
            }
            
            throw new Error('FATAL: JobIds iguais em modo reference - contaminação detectada!');
        }
        
        // Decide qual jobId usar baseado no contexto
        let selectedJobId;
        if (context === 'user' || context === 'second' || context === 'current') {
            selectedJobId = currentJobId;
            console.log('✅ [JOB-ID] Retornando currentJobId (segunda música):', selectedJobId);
        } else if (context === 'reference' || context === 'first') {
            selectedJobId = referenceJobId;
            console.log('✅ [JOB-ID] Retornando referenceJobId (primeira música):', selectedJobId);
        } else if (context === 'storage') {
            // Fallback para localStorage (compatibilidade)
            selectedJobId = referenceJobId;
            console.warn('⚠️ [JOB-ID] Contexto "storage" - retornando referenceJobId:', selectedJobId);
        } else {
            console.warn('⚠️ [JOB-ID] Contexto não especificado:', context);
            selectedJobId = currentJobId; // Default: segunda música
            console.log('   - Default: retornando currentJobId:', selectedJobId);
        }
        
        console.groupEnd();
        return selectedJobId;
    } else {
        // Modo normal: só existe um jobId
        const jobId = window.__CURRENT_JOB_ID__ || sessionStorage.getItem('currentJobId') || localStorage.getItem('currentJobId');
        console.log('✅ [JOB-ID] Modo normal - retornando:', jobId);
        console.groupEnd();
        return jobId;
    }
}

// ========================================
// 🔄 HIDRATAÇÃO DE REFERÊNCIA (Correção 1)
// ========================================
/**
 * Garante que a referência esteja hidratada e disponível para comparação A/B.
 * Fonte de verdade: AnalysisCache ➜ FirstAnalysisStore ➜ __FIRST_ANALYSIS_FROZEN__
 * @returns {Object} { ok: boolean, reason?: string, refId?: string, hasBands?: boolean, file?: string }
 */
function ensureReferenceHydrated() {
  try {
    const mode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
    // 🎯 CORREÇÃO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');

    if (mode !== 'reference' || !refId) {
      return { ok: false, reason: 'no-ref-mode-or-id' };
    }

    // Fonte de verdade: AnalysisCache ➜ FirstAnalysisStore ➜ __FIRST_ANALYSIS_FROZEN__
    const cache = window.AnalysisCache;
    let ref = cache?.get?.(refId) || window.FirstAnalysisStore?.get?.() || window.__FIRST_ANALYSIS_FROZEN__;

    if (!ref) {
      return { ok: false, reason: 'no-ref-object' };
    }

    // deep clone SEM compartilhar metadata/bands
    const refClone = (typeof structuredClone === 'function') 
      ? structuredClone(ref) 
      : JSON.parse(JSON.stringify(ref));

    // Normalizar shape esperado (bands/technicalData/metadata)
    if (!refClone.bands && refClone.spectralBands) {
      refClone.bands = refClone.spectralBands;
    }

    // Publicar referência consistente no escopo global
    window.referenceAnalysisData = refClone;
    window.__FIRST_ANALYSIS_FROZEN__ = (typeof structuredClone === 'function') 
      ? structuredClone(refClone) 
      : JSON.parse(JSON.stringify(refClone));

    // Sinalização
    console.log('[ensureReferenceHydrated] ✅ Referência hidratada:', {
      refId,
      hasBands: !!refClone?.bands,
      file: refClone?.metadata?.fileName || refClone?.fileName
    });

    return { 
      ok: true, 
      refId, 
      hasBands: !!refClone?.bands, 
      file: refClone?.metadata?.fileName || refClone?.fileName 
    };
  } catch (e) {
    console.warn('[ensureReferenceHydrated] ❌ erro', e);
    return { ok: false, reason: 'exception', error: String(e) };
  }
}

// ========================================
// 🛡️ GUARDIÃO GLOBAL: aiUIController Stub
// ========================================
/**
 * Garante que aiUIController sempre existe, mesmo antes do carregamento completo.
 * Cria stub temporário que é substituído quando o controller real é carregado.
 */
(function ensureAIUIController() {
  if (!window.aiUIController) {
    console.warn('[SAFE-BOOT] aiUIController ausente - criando stub temporario.');

    window.aiUIController = {
      renderMetricCards: () => console.warn('[STUB] renderMetricCards chamado antes da carga real.'),
      renderScoreSection: () => console.warn('[STUB] renderScoreSection chamado antes da carga real.'),
      renderSuggestions: () => console.warn('[STUB] renderSuggestions chamado antes da carga real.'),
      renderFinalScoreAtTop: () => console.warn('[STUB] renderFinalScoreAtTop chamado antes da carga real.'),
      checkForAISuggestions: () => console.warn('[STUB] checkForAISuggestions chamado antes da carga real.')
    };
  }

  // Espera ate o real ser carregado (quando o modulo UI inicializa)
  const observer = new MutationObserver(() => {
    if (window.aiUIController?.__ready) {
      console.log('[SAFE-BOOT] ✅ aiUIController real detectado, removendo stub.');
      
      // ========================================
      // ✅ AUDITORIA DE COMPATIBILIDADE
      // ========================================
      const requiredFunctions = [
        'renderMetricCards',
        'renderScoreSection',
        'renderSuggestions',
        'renderFinalScoreAtTop',
        'checkForAISuggestions'
      ];
      
      const missingFunctions = requiredFunctions.filter(
        fn => typeof window.aiUIController[fn] !== 'function'
      );
      
      if (missingFunctions.length === 0) {
        console.log('[COMPAT] ✅ aiUIController detectado com todas as funções esperadas');
        console.log('[COMPAT] Funções disponíveis:', requiredFunctions);
      } else {
        console.error('[COMPAT-FAIL] ❌ Funções ausentes:', missingFunctions);
        console.error('[COMPAT-FAIL] Tipo de aiUIController:', typeof window.aiUIController);
        console.error('[COMPAT-FAIL] Protótipo:', Object.getPrototypeOf(window.aiUIController));
      }
      
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
})();

// ========================================
// ✅ CORREÇÃO 4: Alias Seguro para aiUIController
// ========================================
// Garantir que funções legadas estejam disponíveis como fallback
(function createAIUIControllerAliases() {
  if (!window.aiUIController) window.aiUIController = {};
  
  // Se renderMetricCards não existe mas existe função global, criar alias
  if (typeof window.aiUIController.renderMetricCards !== 'function' && 
      typeof window.renderMetricCards === 'function') {
    window.aiUIController.renderMetricCards = (...args) => window.renderMetricCards(...args);
    console.log('[ALIAS] ✅ Criado alias: aiUIController.renderMetricCards → renderMetricCards');
  }
  
  if (typeof window.aiUIController.renderScoreSection !== 'function' && 
      typeof window.renderScoreSection === 'function') {
    window.aiUIController.renderScoreSection = (...args) => window.renderScoreSection(...args);
    console.log('[ALIAS] ✅ Criado alias: aiUIController.renderScoreSection → renderScoreSection');
  }
  
  if (typeof window.aiUIController.renderSuggestions !== 'function' && 
      typeof window.renderSuggestions === 'function') {
    window.aiUIController.renderSuggestions = (...args) => window.renderSuggestions(...args);
    console.log('[ALIAS] ✅ Criado alias: aiUIController.renderSuggestions → renderSuggestions');
  }
  
  if (typeof window.aiUIController.renderFinalScoreAtTop !== 'function' && 
      typeof window.renderFinalScoreAtTop === 'function') {
    window.aiUIController.renderFinalScoreAtTop = (...args) => window.renderFinalScoreAtTop(...args);
    console.log('[ALIAS] ✅ Criado alias: aiUIController.renderFinalScoreAtTop → renderFinalScoreAtTop');
  }
})();

// 📝 Carregar gerador de texto didático
if (typeof window !== 'undefined' && !window.SuggestionTextGenerator) {
    const script = document.createElement('script');
    script.src = 'suggestion-text-generator.js';
    script.async = true;
    script.onload = () => {
        console.log('[AudioIntegration] Gerador de texto didático carregado');
    };
    script.onerror = () => {
        console.warn('[AudioIntegration] Falha ao carregar gerador de texto didático');
    };
    document.head.appendChild(script);
}

// Debug flag (silencia logs em produção; defina window.DEBUG_ANALYZER = true para habilitar)
const __DEBUG_ANALYZER__ = true; // 🔧 TEMPORÁRIO: Ativado para debug do problema
const __dbg = (...a) => { if (__DEBUG_ANALYZER__) console.log('[AUDIO-DEBUG]', ...a); };
const __dwrn = (...a) => { if (__DEBUG_ANALYZER__) console.warn('[AUDIO-WARN]', ...a); };

// ========================================
// 🗂️ STORES GLOBAIS: AnalysisCache + FirstAnalysisStore
// ========================================
(function initGlobalStores() {
  if (!window.AnalysisCache) {
    // 🔧 Implementação segura sem recursão infinita
    const _data = new Map();
    
    window.AnalysisCache = {
      _data: _data,
      
      get(key) {
        if (!key) return null;
        const value = this._data.get(key);
        return value ? cloneDeepSafe(value) : null;
      },
      
      set(key, value) {
        if (!key || !value) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(value)));
      },
      
      has(key) {
        return key ? this._data.has(key) : false;
      },
      
      delete(key) {
        return this._data.delete(key);
      },
      
      clear() {
        this._data.clear();
        console.log('[CACHE] 🗑️ clear');
      },
      
      // 🔧 API ESTENDIDA: Suporta Virtual IDs (vid) ou jobId simples
      put(keyOrAnalysis, analysis) {
        // Suporta: put(vid, analysis) ou put(analysis)
        let key, data;
        if (typeof keyOrAnalysis === 'string' && analysis) {
          key = keyOrAnalysis; // Virtual ID explícito
          data = analysis;
        } else {
          data = keyOrAnalysis;
          key = data?.jobId || data?.id; // Backward compatibility
        }
        
        if (!key || !data) return;
        this._data.set(key, Object.freeze(cloneDeepSafe(data)));
        console.log('[CACHE] ✅ put', { 
          vid: key, 
          file: data?.fileName || data?.metadata?.fileName,
          isVirtualId: key.includes('::')
        });
      },
      
      ids() {
        return Array.from(this._data.keys());
      }
    };
    
    console.log('[BOOT] AnalysisCache ✅ (Virtual ID support, no recursion)');
  }

  if (!window.FirstAnalysisStore) {
    const _state = {
      user: null,      // Primeira faixa (USER)
      userVid: null,   // Virtual ID do user
      userJobId: null, // jobId original do user
      ref: null,       // Segunda faixa (REF)
      refVid: null,    // Virtual ID da ref
      refJobId: null   // jobId original da ref
    };

    window.FirstAnalysisStore = {
      // ========================================
      // 🎯 API POR PAPEL (USER/REF)
      // ========================================
      setUser(analysis, vid, jobId) {
        if (_state.user) {
          console.warn('[FIRST-STORE] ⚠️ USER já existe - não sobrescrever');
          return; // set-once para user
        }
        _state.user = analysis;
        _state.userVid = vid;
        _state.userJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] ✅ setUser', { 
          vid, 
          jobId: _state.userJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      setRef(analysis, vid, jobId) {
        // REF pode ser sobrescrito (usuário pode trocar segunda faixa)
        _state.ref = analysis;
        _state.refVid = vid;
        _state.refJobId = jobId || analysis?.jobId;
        console.log('[FIRST-STORE] ✅ setRef', { 
          vid, 
          jobId: _state.refJobId, 
          file: analysis?.fileName || analysis?.metadata?.fileName 
        });
      },
      
      getUser() {
        if (_state.user) return _state.user;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.USER);
          console.log('[FIRST-STORE] ♻️ RESTORE USER from cache', { vid: window.CacheIndex.USER });
          return restored;
        }
        return null;
      },
      
      getRef() {
        if (_state.ref) return _state.ref;
        // Fallback: recuperar do cache usando VID
        if (window.CacheIndex.REF && window.AnalysisCache?.has(window.CacheIndex.REF)) {
          const restored = window.AnalysisCache.get(window.CacheIndex.REF);
          console.log('[FIRST-STORE] ♻️ RESTORE REF from cache', { vid: window.CacheIndex.REF });
          return restored;
        }
        return null;
      },
      
      has() { 
        return !!_state.user || !!(window.CacheIndex.USER && window.AnalysisCache?.has(window.CacheIndex.USER));
      },
      
      // ========================================
      // 🔧 COMPATIBILIDADE COM API ANTIGA
      // ========================================
      set(analysis) {
        // Backward compatibility: se não tem user, assume que é o primeiro
        if (!_state.user) {
          const jobId = analysis?.jobId || analysis?.id;
          const vid = `${jobId}::USER`;
          this.setUser(analysis, vid, jobId);
          window.CacheIndex.USER = vid;
          
          // 🔧 CORREÇÃO: Usar StorageManager ao invés de localStorage direto
          try { 
            window.StorageManager.setReferenceJobId(jobId || '');
          } catch (e) {
            console.warn('[FIRST-STORE] ⚠️ Falha ao salvar referenceJobId:', e);
          }
        } else {
          console.warn('[FIRST-STORE] ⚠️ set() chamado mas USER já existe - use setRef()');
        }
      },
      
      get() {
        // Backward compatibility: retorna user (primeira faixa)
        return this.getUser();
      },
      
      id() { return _state.userJobId; },
      jobId() { return _state.userJobId; },
      
      clear() { 
        _state.user = null;
        _state.userVid = null;
        _state.userJobId = null;
        _state.ref = null;
        _state.refVid = null;
        _state.refJobId = null;
        window.CacheIndex.USER = null;
        window.CacheIndex.REF = null;
        
        // 🔧 CORREÇÃO: Usar StorageManager
        try { 
          window.StorageManager.clearReference();
        } catch (e) {
          console.warn('[FIRST-STORE] ⚠️ Falha ao limpar referência:', e);
        }
        
        console.log('[FIRST-STORE] 🗑️ clear (USER + REF)');
      },
      
      // ========================================
      // 📊 DEBUG
      // ========================================
      _debug() {
        return {
          hasUser: !!_state.user,
          hasRef: !!_state.ref,
          userVid: _state.userVid,
          refVid: _state.refVid,
          userJobId: _state.userJobId,
          refJobId: _state.refJobId,
          cacheIndexUser: window.CacheIndex.USER,
          cacheIndexRef: window.CacheIndex.REF
        };
      }
    };
    console.log('[BOOT] FirstAnalysisStore ✅ (Role-based: USER/REF)');
  }
})();

// Alias global para compatibilidade com código existente
const FirstAnalysisStore = window.FirstAnalysisStore;

// ========================================
// 🔧 FUNÇÃO AUXILIAR: Cache por Papel (Role)
// ========================================
/**
 * Salva resultado de análise com Virtual ID baseado no papel (USER ou REF)
 * @param {Object} result - Resultado da análise do backend
 * @param {Object} options - { isSecondTrack: boolean }
 * @returns {Object} { vid: string, clone: Object }
 */
function cacheResultByRole(result, { isSecondTrack }) {
  // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
  const base = result; // ✅ LEITURA DIRETA
  
  // Clone profundo para evitar mutações
  const clone = (typeof structuredClone === 'function') 
    ? structuredClone(base) 
    : JSON.parse(JSON.stringify(base));
  
  // Criar Virtual ID: jobId + papel (USER ou REF)
  const jobId = result.jobId || result.id;
  const role = isSecondTrack ? 'REF' : 'USER';
  const vid = `${jobId}::${role}`;
  
  // Salvar no cache com VID
  window.AnalysisCache.put(vid, clone);
  
  // Atualizar índice de papéis
  if (isSecondTrack) {
    window.CacheIndex.REF = vid;
  } else {
    window.CacheIndex.USER = vid;
  }
  
  console.log('[VID] ✅ Cached by role', { 
    vid, 
    role, 
    jobId, 
    file: clone?.fileName || clone?.metadata?.fileName,
    isSecondTrack
  });
  
  return { vid, clone };
}

// �️ GUARDS: Isolamento de jobIds para evitar self-compare
// Recebe objetos já clonados e garante que refFull tenha jobId único se necessário
function refHardGuards({ userFull, refFull, secondAnalysis }) {
    // ========================================
    // ✅ CORREÇÃO 4: Validação de entrada
    // ========================================
    if (!userFull) {
        console.warn('[refHardGuards] ⚠️ userFull inválido');
        return { ok: false, reason: 'invalid-user' };
    }
    if (!refFull) {
        console.warn('[refHardGuards] ⚠️ refFull inválido');
        return { ok: false, reason: 'invalid-ref' };
    }

    const userId = userFull?.jobId || userFull?.id;
    const refId = refFull?.jobId || refFull?.id;
    const secondId = secondAnalysis?.jobId || secondAnalysis?.id;

    // Se jobIds são iguais, força isolamento adicionando sufixo __ref
    if (userId && refId && userId === refId) {
        console.warn('[GUARD] ⚠️ jobIds iguais, isolando referência com sufixo __ref');
        // Clone para evitar mutação do original
        refFull = (typeof structuredClone === 'function')
            ? structuredClone(refFull)
            : JSON.parse(JSON.stringify(refFull));
        refFull.jobId = `${refId}__ref`; // força ID diferente
    }

    console.log('[GUARD] ✅ userJobId:', userId, '| refJobId:', refFull?.jobId || refFull?.id);
    return { ok: true, userFull, refFull };
}

// �🔒 CLONE PROFUNDO SEGURO (sem loops circulares)
// Substitui JSON.parse(JSON.stringify()) com proteção contra referências circulares
function deepCloneSafe(obj, seen = new WeakMap()) {
    // Primitivos e null retornam direto
    if (obj === null || typeof obj !== 'object') return obj;
    
    // Se já visitamos este objeto, retornar clone existente (evita loop infinito)
    if (seen.has(obj)) return seen.get(obj);
    
    // Criar estrutura base (array ou objeto)
    const clone = Array.isArray(obj) ? [] : {};
    
    // Registrar no mapa ANTES de clonar propriedades (previne recursão infinita)
    seen.set(obj, clone);
    
    // Clonar cada propriedade recursivamente
    for (const key in obj) {
        // Ignorar propriedades específicas que causam loops circulares
        if (key === '_referenceAnalysis') {
            console.log('[DEEP-CLONE] ⚠️ Propriedade circular ignorada:', key);
            continue;
        }
        
        // Verificar se propriedade é própria (não herdada)
        if (Object.hasOwn(obj, key)) {
            clone[key] = deepCloneSafe(obj[key], seen);
        }
    }
    
    return clone;
}

// � STRINGIFY SEGURO (sem loops circulares)
// Substitui JSON.stringify() com proteção contra referências circulares
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (key, value) => {
        // Detectar e marcar referências circulares
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
        }
        
        // Omitir propriedades específicas que causam loops
        if (key === "_referenceAnalysis" || key === "referenceAnalysis") {
            return "[OmittedRef]";
        }
        
        // Omitir propriedades privadas (começam com _)
        if (key && key.startsWith("_")) {
            return undefined;
        }
        
        return value;
    }, 2); // Indentação de 2 espaços para legibilidade
}

// �🛡️ HELPER: Comparador robusto de faixas (evita falso self-compare)
function areSameTrack(a, b) {
    if (!a || !b) return false;

    // Prioridade 1: jobId
    const aj = a.jobId || a.id;
    const bj = b.jobId || b.id;
    if (aj && bj) return aj === bj;

    // Prioridade 2: fileKey
    if (a.fileKey && b.fileKey) return a.fileKey === b.fileKey;

    // Prioridade 3: fileName + sampleRate + duração aproximada
    const nameEqual = a.fileName && b.fileName && a.fileName === b.fileName;
    const srA = a.sampleRate || a.metadata?.sampleRate;
    const srB = b.sampleRate || b.metadata?.sampleRate;
    const durA = a.duration || a.metadata?.duration;
    const durB = b.duration || b.metadata?.duration;
    if (nameEqual && srA && srB && srA === srB) {
        const diff = Math.abs((durA || 0) - (durB || 0));
        return diff < 0.2;
    }

    return false;
}

// =============== CLONE & SANITIZE (SEM CICLOS) ===============
function safeDeepClone(obj, cache = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (cache.has(obj)) return cache.get(obj);

    if (Array.isArray(obj)) {
        const arr = [];
        cache.set(obj, arr);
        obj.forEach(v => arr.push(safeDeepClone(v, cache)));
        return arr;
    }

    const clone = {};
    cache.set(obj, clone);

    for (const key of Object.keys(obj)) {
        // Remove referências internas e funções
        if (key.startsWith('_') || typeof obj[key] === 'function' || typeof obj[key] === 'symbol') continue;
        clone[key] = safeDeepClone(obj[key], cache);
    }

    return clone;
}

// Reduz o objeto de análise para apenas o necessário
function pickAnalysisFields(a) {
    if (!a) return a;
    const s = safeDeepClone(a);
    return {
        id: s.id ?? s.jobId,
        jobId: s.jobId ?? s.id,
        fileKey: s.fileKey,
        fileName: s.fileName,
        loudness: s.loudness,
        dynamics: s.dynamics,
        spectral: s.spectral,
        metrics: s.metrics,
        technicalData: s.technicalData,
        bands: s.bands,
        spectralBands: s.spectralBands,
        metadata: s.metadata,
    };
}

// Normalização segura (copia antes de processar)
function normalizeSafe(raw) {
    // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
    return pickAnalysisFields(raw); // ✅ LEITURA DIRETA
}

// 🆔 SISTEMA runId - Função utilitária centralizada
function generateAnalysisRunId(context = 'ui') {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${context}_${timestamp}_${random}`;
}

// 🛡️ HELPER: Preparar options com runId de forma segura
function prepareAnalysisOptions(baseOptions = {}, context = 'analysis') {
    // Gerar runId se não fornecido
    if (!baseOptions.runId) {
        baseOptions.runId = generateAnalysisRunId(context);
    }
    
    // Configurar variável global para UI_GATE
    window.__CURRENT_ANALYSIS_RUN_ID__ = baseOptions.runId;
    
    __dbg(`🆔 [runId] Preparado para análise: ${baseOptions.runId} (contexto: ${context})`);
    
    return { ...baseOptions };
}

// 🔍 FUNÇÃO DE DIAGNÓSTICO DO FLUXO DE REFERÊNCIA
window.diagnosticReferenceFlow = function() {
    console.log('%c═══════════════════════════════════════════════', 'color:#00FFFF;font-weight:bold;');
    console.log('%c🔍 DIAGNÓSTICO COMPLETO DO FLUXO DE REFERÊNCIA', 'color:#00FFFF;font-weight:bold;');
    console.log('%c═══════════════════════════════════════════════', 'color:#00FFFF;font-weight:bold;');
    
    console.log('%c📊 Estado Atual:', 'color:#FFD700;font-weight:bold;');
    console.log('  Mode:', currentAnalysisMode);
    console.log('  window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__ || 'null');
    console.log('  localStorage.referenceJobId:', localStorage.getItem('referenceJobId') || 'null');
    
    console.log('%c🗂️ Estado Global:', 'color:#FFD700;font-weight:bold;');
    console.log('  window.__soundyState:', window.__soundyState);
    console.log('  previousAnalysis:', window.__soundyState?.previousAnalysis?.jobId || 'null');
    console.log('  userAnalysis:', window.__soundyState?.userAnalysis?.jobId || 'null');
    console.log('  referenceAnalysis:', window.__soundyState?.referenceAnalysis?.jobId || 'null');
    
    console.log('%c💾 Dados de Referência:', 'color:#FFD700;font-weight:bold;');
    console.log('  FirstAnalysisStore:', FirstAnalysisStore.has() ? 'PRESENTE' : 'null');
    console.log('  window.referenceComparisonMetrics:', window.referenceComparisonMetrics ? 'PRESENTE' : 'null');
    
    console.log('%c🎯 Diagnóstico:', 'color:#00FF00;font-weight:bold;');
    // 🎯 CORREÇÃO: Usar getCorrectJobId em vez de acesso direto
    const refId = getCorrectJobId('reference');
    if (currentAnalysisMode === 'reference') {
        if (!refId) {
            console.log('  ✅ Primeira música - pronto para receber segunda');
        } else {
            console.log('  ✅ Aguardando segunda música');
            console.log(`  📌 Job ID da primeira: ${refId}`);
        }
    } else {
        console.log('  ℹ️ Modo atual não é "reference"');
    }
    
    console.log('%c═══════════════════════════════════════════════', 'color:#00FFFF;font-weight:bold;');
    console.log('%c💡 Para testar:', 'color:#FFFF00;');
    console.log('  1. Faça upload da primeira música');
    console.log('  2. Verifique se [REF-SAVE ✅] aparece');
    console.log('  3. Faça upload da segunda música');
    console.log('  4. Verifique se [REF-LOAD ✅] e [REF-FIX-PAYLOAD] aparecem');
    console.log('%c═══════════════════════════════════════════════', 'color:#00FFFF;font-weight:bold;');
};

let currentModalAnalysis = null;
let __audioIntegrationInitialized = false; // evita listeners duplicados
let __refDataCache = {}; // cache por gênero
let __activeRefData = null; // dados do gênero atual
let __genreManifest = null; // manifesto de gêneros (opcional)
let __activeRefGenre = null; // chave do gênero atualmente carregado em __activeRefData
let __refDerivedStats = {}; // estatísticas agregadas (ex: média stereo) por gênero

// 🎯 MODO REFERÊNCIA - Variáveis globais
let currentAnalysisMode = 'genre'; // 'genre' | 'reference'
let referenceStepState = {
    currentStep: 'userAudio', // 'userAudio' | 'referenceAudio' | 'analysis'
    userAudioFile: null,
    referenceAudioFile: null,
    userAnalysis: null,
    referenceAnalysis: null
};

// 🛡️ PROTEÇÃO CRÍTICA: Flag para rastrear se usuário EXPLICITAMENTE selecionou modo reference
// Impede que o sistema ative modo A/B automaticamente quando usuário está em modo genre
let userExplicitlySelectedReferenceMode = false;

// ═══════════════════════════════════════════════════════════════════
// 🔍 FUNÇÃO UTILITÁRIA: Verificar se existe contexto de referência ativo
// ═══════════════════════════════════════════════════════════════════
function hasActiveReferenceContext() {
  const refFlow = window.referenceFlow;
  const refState = refFlow?.state;
  
  // Verificar múltiplas fontes de contexto
  const checks = {
    awaitingSecond: refState?.stage === 'awaiting_second',
    hasBaseJobId: !!refState?.baseJobId,
    hasWindowRefJobId: !!window.__REFERENCE_JOB_ID__,
    hasSessionRefJobId: !!sessionStorage.getItem('__REFERENCE_JOB_ID__'),
    hasFirstAnalysisStore: window.FirstAnalysisStore?.has() === true,
    hasStorageManager: !!window.StorageManager?.getReferenceJobId()
  };
  
  const hasContext = Object.values(checks).some(v => v === true);
  
  console.log('[REF-GUARD] Verificando contexto ativo:', checks, '→', hasContext);
  return hasContext;
}

// ═══════════════════════════════════════════════════════════════════
// 🔐 PERSISTÊNCIA DA FLAG userExplicitlySelectedReferenceMode
// ═══════════════════════════════════════════════════════════════════
function persistReferenceFlag(value) {
  const boolValue = value === true; // Garantir boolean
  userExplicitlySelectedReferenceMode = boolValue;
  sessionStorage.setItem('userExplicitlySelectedReferenceMode', String(boolValue));
  console.log('[REF-GUARD] Flag persistida:', boolValue);
}

function restoreReferenceFlag() {
  const stored = sessionStorage.getItem('userExplicitlySelectedReferenceMode');
  if (stored !== null) {
    // Parse correto: "true" → true, "false" → false
    userExplicitlySelectedReferenceMode = stored === 'true';
    console.log('[REF-GUARD] Flag restaurada:', userExplicitlySelectedReferenceMode);
  }
}

// Restaurar flag ao carregar
restoreReferenceFlag();

// ========================================
// 🔥 STATE MACHINE - VIEW MODE CONTROLLER
// ========================================
// Controla qual UI deve ser renderizada (gênero vs referência)
// Impede contaminação entre modos
window.__soundyViewMode = window.__soundyViewMode || "genre";

function setViewMode(mode) {
    const validModes = ["genre", "reference"];
    if (!validModes.includes(mode)) {
        console.error("[VIEW-MODE] ❌ Modo inválido:", mode);
        return;
    }
    
    const oldMode = window.__soundyViewMode;
    window.__soundyViewMode = mode;
    
    console.log(`%c[VIEW-MODE] 🔄 Alterado: ${oldMode} → ${mode}`, 'color:#00D9FF;font-weight:bold;font-size:13px;');
    
    // Limpar estado do modo anterior
    if (mode === "genre" && oldMode === "reference") {
        console.log("[VIEW-MODE] 🧹 Limpando estado de referência ao mudar para gênero");
        resetReferenceStateFully();
        
        // ✅ Resetar referenceFlow também
        if (window.referenceFlow) {
            window.referenceFlow.reset();
            console.log("[VIEW-MODE] ✅ ReferenceFlow resetado");
        }
    }
    
    // ✅ Iniciar novo fluxo de referência ao mudar para reference
    if (mode === "reference" && oldMode === "genre") {
        console.log("[VIEW-MODE] 🎯 Iniciando novo fluxo de referência");
        if (window.referenceFlow) {
            window.referenceFlow.startNewReferenceFlow();
            console.log("[VIEW-MODE] ✅ ReferenceFlow iniciado");
        }
    }
}

function getViewMode() {
    return window.__soundyViewMode || "genre";
}

// 🔒 GUARD: Bloqueia execução de UI de referência no modo gênero
function canRunReferenceUI(analysis) {
    // UI de referência só pode renderizar na segunda track
    if (!SOUNDY_MODE_ENGINE.isReferenceCompare()) {
        return false;
    }

    if (!analysis) {
        return false;
    }

    const hasRefComparison = !!analysis.referenceComparison;
    const hasRefJobId = !!analysis.referenceJobId || !!analysis.metadata?.referenceJobId;

    if (!hasRefComparison && !hasRefJobId) {
        return false;
    }

    return true;
}

// 🎯 COMPARAÇÃO ENTRE FAIXAS - Armazenamento da primeira análise
window.lastReferenceJobId = null;
// ❌ REMOVER: window.referenceAnalysisData agora é definido como getter read-only dinamicamente
// quando a primeira análise é salva via FirstAnalysisStore.setOnce()

// 🎯 COMPARAÇÃO ENTRE FAIXAS - Métricas de comparação (substitui __activeRefData quando em modo reference)
let referenceComparisonMetrics = null;

// 🎯 JOBS - Sistema de acompanhamento de jobs remotos
let currentJobId = null;
let jobPollingInterval = null;

// 🎯 Funções de Acessibilidade e Gestão de Modais

function openModeSelectionModal() {
    // 🔓 MODO ANÔNIMO: Verificar limite de análises
    if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
        if (!window.SoundyAnonymous.interceptAnalysis()) {
            console.log('🚫 [ANALYZER] Análise bloqueada - limite anônimo atingido');
            return;
        }
    }
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        // Bloquear scroll do body
        document.body.classList.add('modal-open');
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no primeiro botão
        const firstButton = modal.querySelector('.mode-card button');
        if (firstButton) {
            firstButton.focus();
        }
        
        // Adicionar listener para ESC
        document.addEventListener('keydown', handleModalEscapeKey);
        
        // Trap focus no modal
        trapFocus(modal);
    }
}

function closeModeSelectionModal() {
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        
        // Desbloquear scroll do body
        document.body.classList.remove('modal-open');
        
        // Remover listeners
        document.removeEventListener('keydown', handleModalEscapeKey);
        
        // Retornar foco para o botão que abriu o modal
        const audioAnalysisBtn = document.querySelector('button[onclick="openAudioModal()"]');
        if (audioAnalysisBtn) {
            audioAnalysisBtn.focus();
        }
    }
}

function handleModalEscapeKey(e) {
    if (e.key === 'Escape') {
        closeModeSelectionModal();
    }
}

function trapFocus(modal) {
    const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    
    const handleTabKey = (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey && document.activeElement === firstElement) {
                e.preventDefault();
                lastElement.focus();
            } else if (!e.shiftKey && document.activeElement === lastElement) {
                e.preventDefault();
                firstElement.focus();
            }
        }
    };
    
    modal.addEventListener('keydown', handleTabKey);
}

// 🎯 Função Principal de Seleção de Modo
async function selectAnalysisMode(mode) {
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔐 ENTITLEMENT GATE: Bloquear MODO REFERÊNCIA para FREE/PLUS IMEDIATAMENTE
    // ═══════════════════════════════════════════════════════════════════════════════
    if (mode === 'reference') {
        // 🔐 CORREÇÃO CRÍTICA: Se cache não estiver preenchido, buscar do Firestore primeiro
        let currentPlan = window.PlanCapabilities?.detectUserPlan?.() || 'free';
        
        // Se plano é 'free' mas usuário está autenticado, forçar refresh do Firestore
        if (currentPlan === 'free' && window.auth?.currentUser) {
            console.log('🔐 [ENTITLEMENT] Plano cache é free, mas usuário autenticado. Verificando Firestore...');
            try {
                const freshPlan = await window.PlanCapabilities?.fetchUserPlan?.();
                if (freshPlan) {
                    currentPlan = freshPlan;
                    console.log(`🔐 [ENTITLEMENT] Plano atualizado do Firestore: ${currentPlan}`);
                }
            } catch (err) {
                console.warn('🔐 [ENTITLEMENT] Erro ao buscar plano do Firestore:', err);
            }
        }
        
        // 🔐 REGRA CRÍTICA: PRO e DJ nunca são bloqueados no modo referência
        const shouldBlock = currentPlan !== 'pro' && currentPlan !== 'dj';
        
        console.log(`🔐 [ENTITLEMENT] Verificação de Modo Referência: plan=${currentPlan}, shouldBlock=${shouldBlock}`);
        
        if (shouldBlock) {
            console.log('🔐 [ENTITLEMENT] Modo Referência BLOQUEADO - plano não permite');
            
            // Mostrar modal de upgrade IMEDIATAMENTE (sem abrir file picker)
            if (window.EntitlementsHandler?.showUpgradeModal) {
                window.EntitlementsHandler.showUpgradeModal('reference', currentPlan);
            } else {
                // Fallback se handler não estiver carregado
                alert('O Modo Referência está disponível apenas no plano PRO. Faça upgrade para usar esta funcionalidade!');
            }
            
            // PARAR AQUI - não mudar modo, não abrir modal, não fazer nada mais
            return;
        }
        
        console.log('🔐 [ENTITLEMENT] Modo Referência PERMITIDO - plano PRO confirmado');
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // 🔍 PR1: Instrumentação - Seleção de modo
    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
    const previousMode = window.currentAnalysisMode;
    
    if (window.logStep) {
        window.logStep(traceId, 'MODE_SELECTED', {
            selectedMode: mode,
            previousMode: previousMode,
            userClick: true,
        });
    }
    
    // 🔍 PR1: Detectar mudança de modo
    if (window.detectModeChange && previousMode) {
        window.detectModeChange(previousMode, mode);
    }
    
    console.log('🎯 Modo selecionado:', mode);
    
    // 🔍 AUDIT: Dump ANTES de setar state machine
    if (window.debugDump) window.debugDump('BEFORE_SET_MODE', { mode, previousMode });
    
    // 🆕 PR2: USAR STATE MACHINE (com guard robusto)
    const stateMachine = window.AnalysisStateMachine;
    if (!stateMachine) {
        console.error('%c[CRITICAL] AnalysisStateMachine não disponível!', 'color:red;font-weight:bold;font-size:14px;');
        console.error('[CRITICAL] Isso impede o fluxo de referência. Script pode não ter carregado.');
        console.error('[CRITICAL] Tentando continuar com fallback para currentAnalysisMode...');
        
        // Fallback: usar apenas currentAnalysisMode se state machine não existir
        window.currentAnalysisMode = mode;
        
        if (mode === 'reference') {
            userExplicitlySelectedReferenceMode = true;
            console.log('[FALLBACK] Flag userExplicitlySelectedReferenceMode ativada manualmente');
        }
    } else {
        // State machine disponível - usar normalmente
        const currentState = stateMachine.getState();
        const currentMode = stateMachine.getMode();
        
        console.log('[PR2] State machine ANTES de setMode:', { currentMode, currentState });
        
        // Atualizar state machine com modo selecionado
        stateMachine.setMode(mode, { userExplicitlySelected: true });
        
        const newState = stateMachine.getState();
        const newMode = stateMachine.getMode();
        
        console.log('[PR2] State machine DEPOIS de setMode:', { newMode, newState });
        
        // 🔒 VERIFICAR se setMode funcionou
        if (newMode !== mode) {
            console.error('%c[CRITICAL] setMode falhou! Esperado:', mode, 'Obtido:', newMode, 'color:red;font-weight:bold;');
            alert('Erro ao configurar modo de análise. Por favor, recarregue a página.');
            return;
        }
        
        console.log('%c[PR2] ✅ State machine configurado com sucesso para:', mode, 'color:green;font-weight:bold;');
    }
    
    // 🔍 AUDIT: Dump DEPOIS de setar state machine
    if (window.debugDump) window.debugDump('AFTER_SET_MODE', { mode, stateMachineState: stateMachine?.getState() });
    
    // ========================================
    // 🔥 BARREIRA 4: LIMPEZA AO SELECIONAR MODO GÊNERO
    // ========================================
    if (mode === 'genre') {
        // 🔍 PR1: Log reset start
        if (window.logStep) {
            window.logStep(traceId, 'RESET_START', {
                reason: 'genre_mode_selected',
                willResetReferenceState: true,
            });
        }
        console.log('%c[GENRE-BARRIER] 🚧 BARREIRA 4 ATIVADA: Modo gênero selecionado', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
        
        // 🔥 EXECUTAR LIMPEZA COMPLETA do estado de referência
        resetReferenceStateFully();
        
        // 🛡️ PROTEÇÃO: Resetar flag de seleção explícita (legacy - state machine é fonte de verdade)
        persistReferenceFlag(false);
        console.log('%c[PROTECTION] ✅ Flag userExplicitlySelectedReferenceMode resetada para false', 'color:#00FF88;font-weight:bold;');
        
        console.log('%c[GENRE-BARRIER] ✅ BARREIRA 4 CONCLUÍDA: Estado limpo ao selecionar gênero', 'color:#00FF88;font-weight:bold;');
        
        // 🔍 PR1: Log reset end
        if (window.logStep) {
            window.logStep(traceId, 'RESET_END', {
                userExplicitlySelectedReferenceMode: false,
                referenceStateCleared: true,
            });
        }
    }
    
    // 🛡️ PROTEÇÃO: Definir flag quando usuário seleciona modo reference EXPLICITAMENTE (legacy)
    if (mode === 'reference') {
        persistReferenceFlag(true);
        console.log('%c[PROTECTION] ✅ Flag userExplicitlySelectedReferenceMode ATIVADA - usuário clicou em modo A/B', 'color:#FFD700;font-weight:bold;font-size:14px;');
        console.log('[REF_FIX] 🎯 Modo Reference selecionado pelo usuário - estado será preservado');
        
        // 🔍 PR1: Assert invariante
        if (window.assertInvariant) {
            window.assertInvariant(
                'REFERENCE_MODE_EXPLICIT_FLAG',
                userExplicitlySelectedReferenceMode === true,
                { mode: 'reference', flagValue: userExplicitlySelectedReferenceMode }
            );
        }
    }
    
    // Armazenar modo selecionado (legacy - state machine é fonte de verdade)
    window.currentAnalysisMode = mode;
    
    // 🔍 PR1: Validar consistência
    if (window.validateModeConsistency) {
        const validation = window.validateModeConsistency(mode);
        if (!validation.consistent) {
            console.warn('[MODE_INCONSISTENCY]', validation);
        }
    }
    
    // Fechar modal de seleção
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // 🆕 STREAMING MODE: Abrir modal de destino ANTES do modal de gênero
        openSoundDestinationModal((destinationMode) => {
            console.log('[SELECT-MODE] Destino escolhido:', destinationMode);
            // Modo tradicional - abrir modal de análise normal
            openAnalysisModalForMode('genre');
        });
    } else if (mode === 'reference') {
        // Modo referência - abrir interface específica (sem modal de destino)
        // Reference mode sempre usa targets da referência, não precisa de Pista/Streaming
        setSoundDestinationMode('pista'); // Reset para default
        openAnalysisModalForMode('reference');
    }
}

// 🎯 Modal de Análise por Referência
function openReferenceAnalysisModal() {
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        // Configurar modal para modo referência
        const modalContent = modal.querySelector('.modal-content');
        const title = modalContent.querySelector('h2');
        const steps = document.getElementById('referenceProgressSteps');
        
        if (title) {
            title.textContent = '🎵 Análise por Música de Referência';
        }
        
        // Mostrar passos do progresso
        if (steps) {
            steps.style.display = 'block';
            updateProgressStep(1); // Primeiro passo ativo
        }
        
        // Modificar texto do botão de upload
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn) {
            uploadBtn.textContent = '📤 Upload da Música Original';
            uploadBtn.onclick = () => handleReferenceFileSelection('original');
        }
        
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        
        // Foco no botão de upload
        if (uploadBtn) {
            uploadBtn.focus();
        }
    }
}

// 🎯 Gestão de Progresso para Modo Referência
function updateProgressStep(step) {
    const steps = document.querySelectorAll('.progress-step');
    steps.forEach((stepEl, index) => {
        const stepNumber = index + 1;
        stepEl.classList.remove('active', 'completed');
        
        if (stepNumber < step) {
            stepEl.classList.add('completed');
        } else if (stepNumber === step) {
            stepEl.classList.add('active');
        }
    });
}

// � SISTEMA DE UPLOAD E ANÁLISE REMOTA
// ✅ FLUXO OFICIAL: Presigned URL → Upload → Job Creation → Status Polling

// �🎯 Seleção de Arquivos para Modo Referência (fileKeys apenas)
let uploadedFiles = {
    original: null,
    reference: null
};

/**
 * ✅ OBTER URL PRÉ-ASSINADA DO BACKEND
/**
 * Obter URL pré-assinada do backend
/**
 * 🚀 OBTER URL PRÉ-ASSINADA DO BACKEND
 * @param {File} file - Arquivo para upload
 * @returns {Promise<{uploadUrl: string, fileKey: string}>}
 */
async function getPresignedUrl(file) {
  try {
    // Extrair extensão do arquivo
    const ext = file.name.split('.').pop().toLowerCase();

    __dbg('🌐 Solicitando URL pré-assinada...', {
      filename: file.name,
      ext,
           size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
    });

    // ✅ Agora manda "ext" 
    const response = await fetch(`/api/presign?ext=${encodeURIComponent(ext)}`, {
  method: "GET",
  headers: {
    "Accept": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro ao obter URL de upload: ${response.status} - ${errorText}`);
    }

    const data = await response.json();

    if (!data.uploadUrl || !data.fileKey) {
      throw new Error('Resposta inválida do servidor: uploadUrl ou fileKey ausente');
    }

    return {
      uploadUrl: data.uploadUrl,
      fileKey: data.fileKey
    };
  } catch (error) {
    console.error('❌ Erro ao obter URL pré-assinada:', error);
    throw new Error(`Falha ao gerar URL de upload: ${error.message}`);
  }
}



/**
 * ✅ UPLOAD DIRETO PARA BUCKET VIA URL PRÉ-ASSINADA
 * @param {string} uploadUrl - URL pré-assinada para upload
 * @param {File} file - Arquivo para upload
 * @returns {Promise<void>}
 */
async function uploadToBucket(uploadUrl, file) {
  try {
    __dbg('📤 Iniciando upload para bucket...', { 
      filename: file.name,
      size: `${(file.size / 1024 / 1024).toFixed(2)}MB`,
      url: uploadUrl.substring(0, 50) + '...'
    });

    showUploadProgress(`Enviando ${file.name} para análise...`);

    // 👇 sem headers, só body = file
   const response = await fetch(uploadUrl, {
  method: "PUT",
  body: file
});

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erro no upload: ${response.status} - ${errorText}`);
    }

    __dbg('✅ Upload para bucket concluído com sucesso');
    showUploadProgress(`Upload concluído! Processando ${file.name}...`);

  } catch (error) {
    console.error('❌ Erro no upload para bucket:', error);
    throw new Error(`Falha ao enviar arquivo para análise: ${error.message}`);
  }
}


/**
 * 🆕 PR2: CONSTRUIR PAYLOAD PARA MODO GENRE
 * @param {string} fileKey
 * @param {string} fileName
 * @param {string} idToken
 * @returns {Object} payload para mode=genre
 */
function buildGenrePayload(fileKey, fileName, idToken) {
    console.log('[PR2] buildGenrePayload()');
    
    // Obter gênero selecionado
    let genre = window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE;
    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (!genre || typeof genre !== "string" || genre.trim() === "") {
        genre = genreSelect?.value || "default";
    }
    genre = genre.trim();
    
    // Obter targets do gênero
    let genreTargets = null;
    const previousAnalysis = window.currentAnalysisData || window.__soundyState?.previousAnalysis;
    if (previousAnalysis) {
        console.log('[PR2] Extraindo targets da análise anterior');
        genreTargets = extractGenreTargetsFromAnalysis(previousAnalysis);
    }
    if (!genreTargets) {
        console.log('[PR2] FALLBACK: targets das variáveis globais');
        genreTargets = window.__CURRENT_GENRE_TARGETS || window.currentGenreTargets || window.__activeRefData?.targets;
    }
    
    // Validação obrigatória
    if (!genre) {
        throw new Error('[PR2] buildGenrePayload: genre é obrigatório');
    }
    if (!genreTargets || Object.keys(genreTargets).length === 0) {
        console.warn('[PR2] buildGenrePayload: genreTargets ausentes ou vazios');
    }
    
    // 🆕 STREAMING MODE: Obter destino do som (pista/streaming)
    const soundDestination = getSoundDestinationMode();
    console.log('[PR2] soundDestination:', soundDestination);
    
    const payload = {
        fileKey,
        mode: 'genre',  // Mantido por compatibilidade
        analysisType: 'genre',  // 🆕 Campo explícito sem ambiguidade
        soundDestination,  // 🆕 'pista' | 'streaming' - NUNCA undefined
        fileName,
        genre,
        genreTargets,
        hasTargets: !!genreTargets,
        idToken
    };
    
    console.log('[PR2] Genre payload:', {
        mode: payload.mode,
        analysisType: payload.analysisType,
        soundDestination: payload.soundDestination,
        genre: payload.genre,
        hasTargets: payload.hasTargets,
        targetKeys: genreTargets ? Object.keys(genreTargets).length : 0
    });
    
    return payload;
}

/**
 * 🆕 PR2: CONSTRUIR PAYLOAD PARA MODO REFERENCE
 * @param {string} fileKey
 * @param {string} fileName
 * @param {string} idToken
 * @param {Object} options
 * @param {boolean} options.isFirstTrack - Se é primeira ou segunda track
 * @param {string|null} options.referenceJobId - Job ID da primeira track (null na primeira)
 * @returns {Object} payload para mode=reference
 */
function buildReferencePayload(fileKey, fileName, idToken, options = {}) {
    const { isFirstTrack = true, referenceJobId = null } = options;
    
    console.log('[REF-PAYLOAD] buildReferencePayload()', { isFirstTrack, referenceJobId });
    
    // 🎯 PATCH CRÍTICO D: Garantir genre=null em TODAS chamadas
    if (isFirstTrack) {
        // ✅ PRIMEIRA TRACK: payload LIMPO sem genre/targets
        console.log('[REF-PAYLOAD] Reference primeira track - SEM genre/targets (base pura)');
        
        const payload = {
            fileKey,
            mode: 'reference',
            analysisType: 'reference',
            referenceStage: 'base',
            fileName,
            isReferenceBase: true,
            referenceJobId: null,
            genre: null, // 🎯 PATCH D: Explícito
            genreTargets: null, // 🎯 PATCH D: Explícito
            idToken
        };
        
        console.log('[REF-PAYLOAD] ✅ Reference primeira track (BASE) payload:', {
            mode: payload.mode,
            referenceStage: payload.referenceStage,
            hasGenre: payload.genre !== null,
            hasTargets: payload.genreTargets !== null,
            isReferenceBase: payload.isReferenceBase,
            referenceJobId: payload.referenceJobId
        });
        
        // 🔒 SANITY CHECK: Garantir que NÃO tem genre/genreTargets
        if (payload.genre || payload.genreTargets) {
            console.error('[REF-PAYLOAD] SANITY_FAIL: Reference primeira track NÃO deve ter genre/targets!', payload);
            throw new Error('[REF-PAYLOAD] Reference primeira track (base) NÃO deve ter genre/genreTargets');
        }
        
        return payload;
    } else {
        // ✅ SEGUNDA TRACK: payload LIMPO (sem genre/targets) com referenceJobId para comparação
        if (!referenceJobId) {
            throw new Error('[REF-PAYLOAD] buildReferencePayload: segunda track requer referenceJobId');
        }
        
        const payload = {
            fileKey,
            mode: 'reference',       // Mantido por compatibilidade
            analysisType: 'reference',  // 🆕 Campo explícito
            referenceStage: 'compare',  // 🆕 Indica segunda música (comparação)
            fileName,
            referenceJobId,          // JobId da primeira música (BASE) - obrigatório
            isReferenceBase: false,  // Flag legada mantida
            genre: null, // 🎯 PATCH D: Explícito
            genreTargets: null, // 🎯 PATCH D: Explícito
            idToken
        };
        
        console.log('[REF-PAYLOAD] ✅ Reference segunda track (COMPARAÇÃO) payload:', {
            mode: payload.mode,
            referenceJobId: payload.referenceJobId,
            hasGenre: payload.genre !== null, // ✅ Segunda track NÃO inclui genre
            hasTargets: payload.genreTargets !== null, // ✅ Segunda track NÃO inclui genreTargets
            isReferenceBase: payload.isReferenceBase
        });
        
        // 🔒 SANITY CHECK: Garantir que NÃO tem genre/genreTargets
        if (payload.genre || payload.genreTargets) {
            console.error('[REF-PAYLOAD] SANITY_FAIL: Reference segunda track tem genre/targets!', payload);
            throw new Error('[REF-PAYLOAD] Reference segunda track NÃO deve ter genre/genreTargets');
        }
        
        return payload;
    }
}

/**
 * ✅ CRIAR JOB DE ANÁLISE NO BACKEND
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} mode - Modo de análise ('genre' ou 'reference')
 * @param {string} fileName - Nome original do arquivo
 * @returns {Promise<{jobId: string, success: boolean}>}
 */
async function createAnalysisJob(fileKey, mode, fileName) {
    try {
        __dbg('🔧 Criando job de análise...', { fileKey, mode, fileName });

        // 🎯 SISTEMA DE MODOS DE ACESSO
        // Usar função global getAccessMode() para determinar rota correta
        const accessMode = typeof window.getAccessMode === 'function' 
            ? window.getAccessMode() 
            : (window.SoundyAnonymous?.isAnonymousMode ? 'anonymous' : 'logged');
        
        // Obter visitorId do modo ativo (Demo ou Anonymous)
        const visitorId = window.SoundyDemo?.visitorId || window.SoundyAnonymous?.visitorId;
        
        console.log('🎯 [ACCESS-MODE] Modo detectado:', accessMode, { hasVisitorId: !!visitorId });
        
        // ═══════════════════════════════════════════════════════════
        // 🔥 MODO DEMO: Usa rota anônima (1 análise permitida)
        // ═══════════════════════════════════════════════════════════
        if (accessMode === 'demo') {
            console.log('🔥 [DEMO] Modo demo ativo - usando rota anônima para 1 análise');
            
            // Demo só permite modo genre (reference requer conta)
            if (mode === 'reference') {
                console.warn('⚠️ [DEMO] Modo reference não disponível no demo');
                window.SoundyDemo.showConversionModal('reference');
                throw new Error('Modo de referência requer conta. Crie uma conta para continuar.');
            }
            
            const demoVisitorId = window.SoundyDemo?.visitorId;
            if (!demoVisitorId) {
                console.error('❌ [DEMO] visitorId não disponível');
                throw new Error('Identificação do demo não disponível. Recarregue a página.');
            }
            
            // 🛡️ Obter fingerprint forte do dispositivo
            let deviceFingerprint = null;
            let hardwareSummary = null;
            if (window.SoundyFingerprint) {
                try {
                    const fpData = await window.SoundyFingerprint.get();
                    deviceFingerprint = fpData.fingerprint_hash;
                    hardwareSummary = fpData.hardware_summary;
                    console.log('🔐 [DEMO] Fingerprint forte obtido:', deviceFingerprint?.substring(0, 16) + '...');
                } catch (e) {
                    console.warn('⚠️ [DEMO] Erro ao obter fingerprint forte:', e.message);
                }
            }
            
            // Usar mesma lógica do Anonymous, mas com visitorId do Demo
            const genreSelect = document.getElementById('audioRefGenreSelect');
            let demoGenre = window.__CURRENT_SELECTED_GENRE || 
                            window.PROD_AI_REF_GENRE || 
                            genreSelect?.value;
            
            if (!demoGenre || typeof demoGenre !== 'string' || demoGenre.trim() === '') {
                throw new Error('Por favor, selecione um gênero antes de analisar.');
            }
            
            demoGenre = demoGenre.trim();
            
            const demoTargets = window.__CURRENT_GENRE_TARGETS || 
                                window.currentGenreTargets || 
                                window.__activeRefData?.targets;
            
            console.log('[DEMO] 🎵 Gênero capturado:', demoGenre);
            
            const demoPayload = {
                fileKey,
                fileName,
                genre: demoGenre,
                genreTargets: demoTargets,
                visitorId: demoVisitorId,
                soundDestination: window.selectedSoundDestination || 'pista',
                analysisMode: 'genre',
                isDemo: true,
                // 🛡️ Fingerprint forte para bloqueio definitivo
                fingerprintHash: deviceFingerprint,
                hardwareSummary: hardwareSummary
            };
            
            console.log('[DEMO] Payload para análise:', demoPayload);
            
            // Usar mesma rota anônima
            const response = await fetch('/api/audio/analyze-anonymous', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(demoPayload)
            });
            
            const data = await response.json();
            
            if (!response.ok) {
                // 🔥 Verificar se backend sinaliza para mostrar modal de conversão
                if (data.showConversionModal || data.checkoutRequired || 
                    data.requiresLogin || data.error === 'ANON_ANALYSIS_LIMIT_REACHED' ||
                    data.error === 'DEMO_LIMIT_REACHED') {
                    console.log('🚫 [DEMO] Limite de análise atingido - mostrando modal de upgrade');
                    window.SoundyDemo.showConversionModal('analysis_limit');
                    // NÃO throw error - deixar modal de upgrade ser exibido sem modal de erro
                    return { blocked: true, showConversion: true };
                }
                throw new Error(data.message || `Erro ao criar job: ${response.status}`);
            }
            
            console.log('[DEMO] ✅ Job demo criado:', data.jobId);
            
            return {
                jobId: data.jobId,
                success: true,
                demo: true
            };
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🔓 MODO ANÔNIMO: Usar rota /analyze-anonymous (SEM AUTH)
        // ═══════════════════════════════════════════════════════════
        if (accessMode === 'anonymous') {
            console.log('🔓 [ANONYMOUS] Modo anônimo ativo - usando rota anônima');
            
            // Anônimos só podem usar modo genre (reference requer conta)
            if (mode === 'reference') {
                console.warn('⚠️ [ANONYMOUS] Modo reference não disponível para anônimos');
                window.SoundyAnonymous.showLoginModal('reference');
                throw new Error('Modo de referência requer conta. Crie uma conta grátis para continuar.');
            }
            
            if (!visitorId) {
                console.error('❌ [ANONYMOUS] visitorId não disponível');
                throw new Error('Identificação de visitante não disponível. Recarregue a página.');
            }
            
            // �️ Obter fingerprint forte do dispositivo
            let deviceFingerprint = null;
            let hardwareSummary = null;
            if (window.SoundyFingerprint) {
                try {
                    const fpData = await window.SoundyFingerprint.get();
                    deviceFingerprint = fpData.fingerprint_hash;
                    hardwareSummary = fpData.hardware_summary;
                    console.log('🔐 [ANONYMOUS] Fingerprint forte obtido:', deviceFingerprint?.substring(0, 16) + '...');
                } catch (e) {
                    console.warn('⚠️ [ANONYMOUS] Erro ao obter fingerprint forte:', e.message);
                }
            }
            
            // 🔧 FIX BUG 2: Obter gênero corretamente (mesmo padrão do modo autenticado)
            const genreSelect = document.getElementById('audioRefGenreSelect');
            let anonymousGenre = window.__CURRENT_SELECTED_GENRE || 
                                 window.PROD_AI_REF_GENRE || 
                                 genreSelect?.value;
            
            // Validação obrigatória de gênero
            if (!anonymousGenre || typeof anonymousGenre !== 'string' || anonymousGenre.trim() === '') {
                console.error('❌ [ANONYMOUS] Gênero não selecionado!');
                console.error('   window.__CURRENT_SELECTED_GENRE:', window.__CURRENT_SELECTED_GENRE);
                console.error('   window.PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
                console.error('   genreSelect?.value:', genreSelect?.value);
                throw new Error('Por favor, selecione um gênero antes de analisar.');
            }
            
            anonymousGenre = anonymousGenre.trim();
            
            // Obter targets do gênero
            let anonymousTargets = window.__CURRENT_GENRE_TARGETS || 
                                   window.currentGenreTargets || 
                                   window.__activeRefData?.targets;
            
            console.log('[ANONYMOUS] 🎵 Gênero capturado:', anonymousGenre);
            console.log('[ANONYMOUS] 🎯 Targets capturados:', anonymousTargets ? 'SIM' : 'NÃO');
            
            // Construir payload anônimo com fingerprint forte
            const anonymousPayload = {
                fileKey,
                fileName,
                genre: anonymousGenre,
                genreTargets: anonymousTargets,
                visitorId,
                soundDestination: window.selectedSoundDestination || 'pista',
                // Metadados para debug
                analysisMode: 'genre',
                isAnonymous: true,
                // 🛡️ Fingerprint forte para bloqueio definitivo
                fingerprintHash: deviceFingerprint,
                hardwareSummary: hardwareSummary
            };
            
            console.log('[ANONYMOUS] Payload para análise anônima:', anonymousPayload);
            
            // Usar rota anônima
            const response = await fetch('/api/audio/analyze-anonymous', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify(anonymousPayload)
            });
            
            const data = await response.json();
            
            // Tratar limite atingido
            if (!response.ok) {
                if (data.requiresLogin || data.error === 'ANON_ANALYSIS_LIMIT_REACHED') {
                    console.log('🚫 [ANONYMOUS] Limite de análises atingido');
                    window.SoundyAnonymous.showLoginModal('analysis');
                    throw new Error(data.message || 'Limite de análises atingido. Crie uma conta grátis para continuar.');
                }
                throw new Error(data.message || `Erro ao criar job: ${response.status}`);
            }
            
            console.log('[ANONYMOUS] ✅ Job anônimo criado:', data.jobId);
            
            // Atualizar contador local
            if (data.limits) {
                console.log(`📊 [ANONYMOUS] Análises: ${data.limits.used}/${data.limits.limit}`);
            }
            
            return {
                jobId: data.jobId,
                success: true,
                anonymous: true
            };
        }

        // ✅ MODO AUTENTICADO: Obter Firebase ID Token ANTES de fazer o fetch
        console.log('🔐 Obtendo Firebase ID Token...');
        
        // Aguardar Firebase estar pronto
        if (typeof waitForFirebase === 'function') {
            await waitForFirebase();
        }
        
        // Tentar obter token (prioridade: currentUser > localStorage)
        let idToken = null;
        
        // Prioridade 1: Obter do currentUser
        const currentUser = window.auth?.currentUser;
        if (currentUser) {
            try {
                idToken = await currentUser.getIdToken();
                console.log('✅ Token obtido do currentUser');
            } catch (err) {
                console.warn('⚠️ Erro ao obter token do currentUser:', err.message);
            }
        }
        
        // Prioridade 2: Fallback para localStorage
        if (!idToken) {
            idToken = localStorage.getItem('authToken') || localStorage.getItem('idToken');
            if (idToken) {
                console.log('✅ Token obtido do localStorage (fallback)');
            }
        }
        
        // ═══════════════════════════════════════════════════════════
        // 🚨 FALLBACK: Se não há token, tentar ativar modo anônimo
        // ═══════════════════════════════════════════════════════════
        if (!idToken) {
            console.warn('⚠️ [FALLBACK] Token não encontrado, verificando se pode usar modo anônimo...');
            
            // Verificar se SoundyAnonymous está disponível e habilitado
            if (window.SoundyAnonymous && window.SoundyAnonymous.isEnabled) {
                // Se ainda não foi ativado, ativar agora
                if (!window.SoundyAnonymous.isAnonymousMode) {
                    console.log('🔄 [FALLBACK] Tentando ativar modo anônimo automaticamente...');
                    await window.SoundyAnonymous.activate();
                }
                
                // Verificar se ativou com sucesso
                if (window.SoundyAnonymous.isAnonymousMode && window.SoundyAnonymous.visitorId) {
                    console.log('✅ [FALLBACK] Modo anônimo ativado! Redirecionando para rota anônima...');
                    
                    // Recursivamente chamar createAnalysisJob que agora irá detectar modo anônimo
                    return createAnalysisJob(fileKey, mode, fileName);
                }
            }
            
            console.error('[CRITICAL] ID Token ausente e modo anônimo não disponível.');
            console.error('❌ Usuário não autenticado - não é possível criar job');
            throw new Error('Você precisa estar logado para analisar áudio.');
        }
        
        console.log('✅ Token válido disponível para envio');

        // 🆕 PR2: USAR STATE MACHINE como fonte de verdade
        const stateMachine = window.AnalysisStateMachine;
        if (!stateMachine) {
            console.error('%c[CRITICAL] AnalysisStateMachine não disponível em createAnalysisJob!', 'color:red;font-weight:bold;font-size:14px;');
            console.error('[CRITICAL] Modo solicitado:', mode);
            console.error('[CRITICAL] currentAnalysisMode:', window.currentAnalysisMode);
            
            // Se não tem state machine MAS o mode é reference, tentar continuar com fallback
            if (mode === 'reference') {
                console.warn('[FALLBACK] Tentando continuar reference sem state machine...');
                console.warn('[FALLBACK] Usando window.currentAnalysisMode e flags globais');
                
                // Criar payload manualmente sem state machine
                if (window.userExplicitlySelectedReferenceMode) {
                    // Determinar se é primeira ou segunda track pelas flags globais
                    const hasFirstJobId = window.__REFERENCE_JOB_ID__ || window.lastReferenceJobId;
                    
                    payload = buildReferencePayload(fileKey, fileName, idToken, {
                        isFirstTrack: !hasFirstJobId,
                        referenceJobId: hasFirstJobId || null
                    });
                    
                    console.log('[FALLBACK] Payload reference criado:', payload);
                } else {
                    throw new Error('[CRITICAL] State machine ausente E userExplicitlySelectedReferenceMode=false. Não é possível processar reference.');
                }
            } else {
                // Modo genre não precisa de state machine
                payload = buildGenrePayload(fileKey, fileName, idToken);
            }
        } else {
            // State machine disponível - fluxo normal
            const currentState = stateMachine.getState();
            const currentSMMode = stateMachine.getMode();
            
            console.log('[PR2] Estado atual da máquina:', { mode: currentSMMode, state: currentState });
            
            // 🔒 VERIFICAÇÃO CRÍTICA: se mode é reference, state machine DEVE estar em reference
            if (mode === 'reference' && currentSMMode !== 'reference') {
                console.error('%c[CRITICAL] INCONSISTÊNCIA DETECTADA!', 'color:red;font-weight:bold;font-size:16px;');
                console.error('[STATE] Parâmetro mode:', mode);
                console.error('[STATE] stateMachine.getMode():', currentSMMode);
                console.error('[STATE] currentAnalysisMode:', window.currentAnalysisMode);
                console.error('[STATE] State completo:', currentState);
                
                console.warn('[FIX_ATTEMPT] Tentando corrigir state machine...');
                try {
                    stateMachine.setMode('reference', { userExplicitlySelected: true });
                    const fixedMode = stateMachine.getMode();
                    console.log('[FIX_RESULT] Novo mode:', fixedMode);
                    
                    if (fixedMode !== 'reference') {
                        throw new Error(`setMode falhou: ainda está em '${fixedMode}'`);
                    }
                    
                    console.log('%c[FIX_SUCCESS] State machine corrigido para reference', 'color:green;font-weight:bold;');
                } catch (fixError) {
                    console.error('[FIX_FAILED] Não foi possível corrigir:', fixError);
                    throw new Error(`[INVARIANTE] State machine está em '${currentSMMode}' mas mode param é '${mode}'. Correção falhou: ${fixError.message}`);
                }
            }
            
            // Agora sim, continuar com o fluxo normal baseado no modo
            if (mode === 'genre') {
                console.log('[PR2] Usando buildGenrePayload');
                payload = buildGenrePayload(fileKey, fileName, idToken);
                
            } else if (mode === 'reference') {
                // MODO REFERENCE: usar ReferenceFlowController
                const refFlow = window.referenceFlow;
                if (!refFlow) {
                    throw new Error('[REF-FLOW] ReferenceFlowController não disponível');
                }
                
                const isFirstTrack = refFlow.isFirstTrack() || !refFlow.isAwaitingSecond();
                const referenceJobId = refFlow.getBaseJobId();
                
                console.log('[REF-FLOW] Usando buildReferencePayload', { isFirstTrack, referenceJobId });
            
            if (isFirstTrack) {
                // Primeira track: iniciar fluxo
                console.log('[REF-FLOW] onFirstTrackSelected() chamado');
                refFlow.onFirstTrackSelected();
                
                payload = buildReferencePayload(fileKey, fileName, idToken, {
                    isFirstTrack: true,
                    referenceJobId: null
                });
                
                // 🔒 BIND: Marcar payload para binding posterior
                payload._pendingBinding = { track: 'base', baseJobId: null, referenceJobId: null };
            } else {
                // Segunda track: comparar
                if (!referenceJobId) {
                    throw new Error('[REF-FLOW] Segunda track requer baseJobId');
                }
                
                console.log('[REF-FLOW] onSecondTrackSelected() chamado');
                refFlow.onSecondTrackSelected();
                
                payload = buildReferencePayload(fileKey, fileName, idToken, {
                    isFirstTrack: false,
                    referenceJobId
                });
                
                // 🔒 BIND: Marcar payload para binding posterior
                payload._pendingBinding = { track: 'compare', baseJobId: referenceJobId, referenceJobId };
            }
            
            } else {
                throw new Error(`[PR2] Modo inválido: ${mode}`);
            }
        }
        
        // 🔍 PR1: Trace ID para rastreamento
        const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
        if (window.logStep) {
            window.logStep(traceId, 'PAYLOAD_BUILD_END', {
                mode: payload.mode,
                isReferenceBase: payload.isReferenceBase || false,
                referenceJobId: payload.referenceJobId || null,
            });
        }
        
        // 🔍 PR1: Log payload final (mascarado)
        if (window.logStep && window.maskSensitiveData) {
            const maskedPayload = window.maskSensitiveData(payload);
            window.logStep(traceId, 'PAYLOAD_BUILD_END', {
                payload: maskedPayload,
            });
        }
        
        // 🔍 PR1: Sanity check do payload
        if (window.logStep) {
            const uiMode = window.currentAnalysisMode;
            const payloadMode = payload.mode;
            
            window.logStep(traceId, 'PAYLOAD_SANITY_CHECK', {
                uiMode,
                payloadMode,
                match: uiMode === payloadMode || (uiMode === 'reference' && payloadMode === 'genre' && payload.isReferenceBase),
                hasGenreInPayload: !!payload.genre,
                hasTargetsInPayload: !!payload.genreTargets,
                referenceJobIdPresent: !!payload.referenceJobId,
                isReferenceBase: payload.isReferenceBase || false,
            });
            
            // 🆕 PR2: VALIDAÇÃO RÍGIDA - Se mode=reference (segunda track), NÃO pode ter genre/targets
            if (payload.mode === 'reference' && payload.referenceJobId) {
                if (payload.genre || payload.genreTargets) {
                    console.error('%c[PR2-SANITY-FAIL]', 'color:#FF0000;font-weight:bold;', {
                        message: 'REFERENCE mode segunda track TEM genre/genreTargets!',
                        payload,
                        traceId,
                        stack: new Error().stack,
                    });
                    throw new Error('[PR2] SANITY FAIL: Reference segunda track não pode ter genre/genreTargets');
                }
            }
        }
        
        console.log('[PR2] Payload final:', payload);
        
        // � VALIDAÇÃO CRÍTICA: Verificar se AuthGate permite chamada autenticada
        if (window.AuthGate && window.AuthGate.shouldBlockAuthenticatedCall('/api/audio/analyze')) {
            console.error('🚫 [CREATEJOB] Tentativa de chamada autenticada bloqueada pelo AuthGate');
            console.error('   Estado:', {
                isAnonymousMode: window.SoundyAnonymous?.isAnonymousMode,
                forceCleanState: window.SoundyAnonymous?.forceCleanState,
                hasCurrentUser: !!window.auth?.currentUser
            });
            throw new Error('Sessão inválida. Por favor, faça login novamente ou use o modo anônimo.');
        }
        
        // �🔍 PR1: Log antes do request
        if (window.logStep && window.maskSensitiveData) {
            window.logStep(traceId, 'REQUEST_SENT', {
                endpoint: '/api/audio/analyze',
                payload: window.maskSensitiveData(payload),
            });
        }

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${idToken}`, // ✅ CORREÇÃO CRÍTICA: Token adicionado
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorText = await response.text();
            
            // 🎯 V2: Preservar JSON estruturado para ErrorMapper com SCOPE
            let structuredError = null;
            try {
                structuredError = JSON.parse(errorText);
                console.log('[ANALYZE] Erro estruturado do backend:', structuredError);
            } catch (e) {
                // Não é JSON válido, usar texto
                console.warn('[ANALYZE] Erro não é JSON:', errorText);
            }
            
            // Se temos erro estruturado, criar Error com dados preservados
            if (structuredError && (structuredError.code || structuredError.error)) {
                const err = new Error(structuredError.message || `Erro ${response.status}`);
                err.structuredData = structuredError; // 🔑 Preservar dados para showModalError
                err.httpStatus = response.status;
                throw err;
            }
            
            throw new Error(`Erro ao criar job: ${response.status} - ${errorText}`);
        }

        const data = await response.json();

        console.log("[ANALYZE-RESPONSE]", data);

        // 🔒 CAPTURA ROBUSTA: Múltiplas tentativas de obter jobId
        const newJobId =
            data.jobId ||
            data.id ||
            data.job?.id;

        if (!newJobId) {
            console.error("[ANALYZE] ❌ Nenhum jobId retornado pelo backend!", data);
            throw new Error('Resposta inválida do servidor: jobId ausente');
        }

        __dbg('✅ Job de análise criado:', { 
            jobId: newJobId,
            mode: data.mode,
            fileKey: data.fileKey
        });

        // 🔒 BIND: Registrar binding se payload tinha _pendingBinding
        if (payload._pendingBinding && window.referenceFlow) {
            window.referenceFlow.bindJob(newJobId, payload._pendingBinding);
            console.log('[REF-BIND] Job bound após POST:', newJobId, payload._pendingBinding);
        }

        return {
            jobId: newJobId,
            success: true
        };

    } catch (error) {
        console.error('❌ Erro ao criar job de análise:', error);
        throw new Error(`Falha ao criar job de análise: ${error.message}`);
    }
}

/**
 * ✅ ACOMPANHAR STATUS DO JOB DE ANÁLISE
 * @param {string} jobId - ID do job
 * @returns {Promise<Object>} - Resultado da análise quando completa
 */
async function pollJobStatus(jobId) {
    // 🔒 BLINDAGEM: Validar jobId ANTES de iniciar polling
    if (!jobId || typeof jobId !== "string") {
        console.error("[POLLING] ❌ jobId inválido ou undefined:", jobId);
        return Promise.reject(new Error("Job ID inválido - polling abortado"));
    }

    console.log("[POLLING] ✅ Iniciando com jobId válido:", jobId);

    return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 60; // 5 minutos máximo (5s * 60 = 300s)
        let initialQueuePosition = null;
        
        const poll = async () => {
            try {
                attempts++;
                __dbg(`🔄 Verificando status do job (tentativa ${attempts}/${maxAttempts})...`);

                const response = await fetch(`/api/jobs/${jobId}`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao verificar status: ${response.status}`);
                }

                const jobData = await response.json();
                
                // � PR1: Log resultado do polling (apenas no completed)
                if (jobData.status === 'completed' && window.logStep) {
                    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
                    const job = jobData.job || jobData;
                    window.logStep(traceId, 'POLL_RESULT_RECEIVED', {
                        jobId: jobId,
                        status: job.status,
                        mode: job.mode || job.results?.mode,
                        hasReferenceComparison: !!(job.results?.referenceComparison),
                        hasGenreTargets: !!(job.results?.data?.genreTargets || job.results?.genreTargets),
                    });
                }
                
                // �🔧 COMPATIBILIDADE: Suporte para formato novo (ok/job) e antigo
                const job = jobData.job || jobData;
                const status = job.status || jobData.status;
                
                __dbg(`📊 Status do job:`, { 
                    status: status, 
                    progress: job.progress || jobData.progress || 'N/A' 
                });

                // Calcular progresso baseado na posição da fila
                let calculatedProgress = 0;
                let progressMessage = '🚀 Inicializando...';
                
                // Obter status da fila se disponível
                const queueStatus = window.getAudioQueueStatus ? window.getAudioQueueStatus() : null;
                
                if (status === 'queued') {
                    // Job na fila - calcular posição
                    if (queueStatus && queueStatus.queue) {
                        const totalInQueue = queueStatus.queue.total || 0;
                        
                        // Armazenar posição inicial na primeira tentativa
                        if (initialQueuePosition === null) {
                            initialQueuePosition = totalInQueue;
                        }
                        
                        // Calcular progresso: quanto mais próximo de 0, mais perto de processar
                        if (initialQueuePosition > 0) {
                            calculatedProgress = Math.min(
                                Math.max(
                                    ((initialQueuePosition - totalInQueue) / initialQueuePosition) * 50, // 0-50% enquanto na fila
                                    5 // Mínimo 5%
                                ),
                                50
                            );
                        } else {
                            calculatedProgress = 10;
                        }
                        
                        progressMessage = `⏳ Na fila... Posição: ${totalInQueue + 1} | Processando: ${queueStatus.running || 0}`;
                    } else {
                        calculatedProgress = 10;
                        progressMessage = '⏳ Aguardando processamento...';
                    }
                } else if (status === 'processing') {
                    // Job processando - 50% a 95%
                    if (job.progress || jobData.progress) {
                        // Se o backend enviar progresso específico, usar e mapear para 50-95%
                        calculatedProgress = 50 + (jobData.progress * 0.45);
                    } else {
                        // Progresso incremental baseado em tentativas
                        calculatedProgress = 50 + Math.min((attempts - (initialQueuePosition || 0)) * 5, 45);
                    }
                    progressMessage = '🔄 Analisando áudio...';
                } else if (status === 'completed' || status === 'done') {
                    calculatedProgress = 100;
                    progressMessage = '✅ Análise concluída!';
                }

                // Atualizar progresso na UI
                updateModalProgress(calculatedProgress, progressMessage);

                if (status === 'completed' || status === 'done') {
                    __dbg('✅ Job concluído com sucesso');
                    
                    // 🎯 NOVO: Verificar modo e decidir fluxo
                    let jobResult = job.results || jobData.results || job.result || jobData.result || jobData;
                    jobResult.jobId = jobId; // Incluir jobId no resultado
                    jobResult.mode = jobData.mode; // Incluir mode no resultado
                    
                    // ═══════════════════════════════════════════════════════════════
                    // 🔐 FRONTEND GUARD: Defesa em profundidade contra vazamento
                    // ═══════════════════════════════════════════════════════════════
                    // Se por algum bug o backend enviar texto em modo reduced,
                    // sanitizar em memória ANTES de renderizar (defesa extra)
                    // ═══════════════════════════════════════════════════════════════
                    if (jobResult.isReduced === true || jobResult.analysisMode === 'reduced') {
                        console.log('[FRONTEND-GUARD] 🔐 Modo REDUCED detectado - Aplicando sanitização extra');
                        
                        const sanitizeItem = (s = {}) => ({
                            ...s,
                            // Preservar campos não sensíveis
                            categoria: s.categoria ?? s.category ?? null,
                            metricKey: s.metricKey ?? s.metric ?? null,
                            severity: s.severity ?? null,
                            type: s.type ?? null,
                            // Remover texto sensível
                            problema: null,
                            causa: null,
                            solucao: null,
                            plugin: null,
                            dica: null,
                            texto: null,
                            content: null,
                            details: null,
                            raw: null,
                            description: null,
                        });
                        
                        if (Array.isArray(jobResult.suggestions)) {
                            jobResult.suggestions = jobResult.suggestions.map(sanitizeItem);
                        }
                        
                        if (Array.isArray(jobResult.aiSuggestions)) {
                            jobResult.aiSuggestions = jobResult.aiSuggestions.map(sanitizeItem);
                        }
                        
                        console.log('[FRONTEND-GUARD] ✅ Sanitização extra aplicada');
                    }
                    // ═══════════════════════════════════════════════════════════════
                    
                    // ═══════════════════════════════════════════════════════════════
                    // 🔍 AUDITORIA COMPLETA - ESTRUTURA REAL DO JSON RECEBIDO
                    // ═══════════════════════════════════════════════════════════════
                    console.log('\n\n🔍🔍🔍 [AUDIT] JSON RECEBIDO DO BACKEND 🔍🔍🔍');
                    console.log('[AUDIT] jobResult COMPLETO:', jobResult);
                    console.log('[AUDIT] Keys do jobResult:', Object.keys(jobResult));
                    console.log('[AUDIT] Tipo de jobResult:', typeof jobResult);
                    console.log('[AUDIT] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('[AUDIT] Verificando campos de targets:');
                    console.log('[AUDIT]   ✓ jobResult.targets:', !!jobResult.targets);
                    console.log('[AUDIT]   ✗ jobResult.data?.genreTargets:', !!jobResult.data?.genreTargets);
                    console.log('[AUDIT]   ✗ jobResult.results?.genreTargets:', !!jobResult.results?.genreTargets);
                    console.log('[AUDIT]   ✗ jobResult.data?.targets:', !!jobResult.data?.targets);
                    console.log('[AUDIT]   ✗ jobResult.results?.targets:', !!jobResult.results?.targets);
                    console.log('[AUDIT] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    
                    if (jobResult.targets) {
                        console.log('[AUDIT] ✅ CAMPO CORRETO ENCONTRADO: jobResult.targets');
                        console.log('[AUDIT] Keys de targets:', Object.keys(jobResult.targets));
                        console.log('[AUDIT] Estrutura de targets:', {
                            hasLufsTarget: 'lufs_target' in jobResult.targets,
                            hasTruePeakTarget: 'true_peak_target' in jobResult.targets,
                            hasDrTarget: 'dr_target' in jobResult.targets,
                            hasStereoTarget: 'stereo_target' in jobResult.targets,
                            hasBands: 'bands' in jobResult.targets || 'spectral_bands' in jobResult.targets,
                            lufsValue: jobResult.targets.lufs_target,
                            truePeakValue: jobResult.targets.true_peak_target,
                            drValue: jobResult.targets.dr_target,
                            stereoValue: jobResult.targets.stereo_target
                        });
                    } else {
                        console.error('[AUDIT] ❌ CAMPO "targets" NÃO ENCONTRADO!');
                        console.error('[AUDIT] Estrutura recebida pode estar incorreta');
                    }
                    console.log('🔍🔍🔍 [AUDIT] FIM DA AUDITORIA 🔍🔍🔍\n\n');
                    
                    // 🎯 PATCH CRÍTICO: Garantir que analysis.targets existe (caminho correto)
                    if (jobResult.targets) {
                        console.log('[POLLING] ✅ targets encontrado no jobResult (Postgres)');
                        console.log('[POLLING] Keys:', Object.keys(jobResult.targets));
                    } else if (jobResult.mode === 'genre') {
                        console.warn('[POLLING] ⚠️ Modo genre mas "targets" ausente no JSON');
                        console.warn('[POLLING] Isso pode causar validação incorreta de sugestões');
                    }
                    
                    // 🔥 AUDITORIA CRÍTICA: Verificar technicalData APÓS polling
                    console.log('\n\n🔥🔥🔥 [AUDIT-TECHNICAL-DATA] FRONTEND POST-POLLING 🔥🔥🔥');
                    console.log('[AUDIT-TECHNICAL-DATA] jobResult.technicalData:', {
                      exists: !!jobResult.technicalData,
                      type: typeof jobResult.technicalData,
                      isEmpty: jobResult.technicalData && Object.keys(jobResult.technicalData).length === 0,
                      keys: jobResult.technicalData ? Object.keys(jobResult.technicalData) : [],
                      hasSampleFields: {
                        lufsIntegrated: jobResult.technicalData?.lufsIntegrated,
                        truePeakDbtp: jobResult.technicalData?.truePeakDbtp,
                        dynamicRange: jobResult.technicalData?.dynamicRange,
                        spectral_balance: !!jobResult.technicalData?.spectral_balance
                      }
                    });
                    console.log('[AUDIT-TECHNICAL-DATA] jobResult outros campos:', {
                      hasScore: jobResult.score !== undefined,
                      scoreValue: jobResult.score,
                      hasClassification: !!jobResult.classification,
                      hasTargets: !!jobResult.targets,
                      jobId: jobResult.jobId,
                      mode: jobResult.mode
                    });
                    console.log('🔥🔥🔥 [AUDIT-TECHNICAL-DATA] END 🔥🔥🔥\n\n');
                    
                    // ═══════════════════════════════════════════════════════════════
                    // � REFERENCE MODE: Detectar se é base (1ª música) e abrir modal para 2ª
                    // ═══════════════════════════════════════════════════════════════
                    const stateMachine = window.AnalysisStateMachine;
                    const isReferenceMode = jobResult.mode === 'reference' || stateMachine?.getMode() === 'reference';
                    const isReferenceBase = jobResult.referenceStage === 'base' || jobResult.requiresSecondTrack === true;
                    const hasNextAction = jobResult.nextAction === 'upload_second_track';
                    
                    // 🔍 Log de trace para produção
                    const traceId = jobResult.traceId || window.referenceFlow?.state?.traceId || `trace_${Date.now()}`;
                    console.log('[POLL-TRACE]', {
                        traceId,
                        timestamp: new Date().toISOString(),
                        jobId: jobResult.id || jobResult.jobId || jobId,
                        status: jobResult.status,
                        mode: jobResult.mode,
                        referenceStage: jobResult.referenceStage,
                        nextAction: jobResult.nextAction,
                        requiresSecondTrack: jobResult.requiresSecondTrack,
                        baseJobId: window.referenceFlow?.state?.baseJobId,
                        willOpenModal: isReferenceMode && isReferenceBase && hasNextAction
                    });
                    
                    if (isReferenceMode && isReferenceBase) {
                        console.log('[POLLING][REFERENCE] 🎯 Base completada', { hasNextAction, traceId });
                        console.log('[POLLING][REFERENCE] referenceStage:', jobResult.referenceStage);
                        console.log('[POLLING][REFERENCE] requiresSecondTrack:', jobResult.requiresSecondTrack);
                        console.log('[POLLING][REFERENCE] referenceJobId:', jobResult.referenceJobId);
                        
                        // Salvar state machine
                        if (stateMachine) {
                            try {
                                stateMachine.setReferenceFirstResult({
                                    firstJobId: jobResult.referenceJobId || jobId,
                                    firstResultSummary: {
                                        score: jobResult.score,
                                        jobId: jobResult.referenceJobId || jobId,
                                        technicalData: jobResult.technicalData || {},
                                        spectralBands: jobResult.spectralBands || {},
                                        classification: jobResult.classification
                                    }
                                });
                                console.log('[POLLING][REFERENCE] ✅ State machine atualizado');
                            } catch (err) {
                                console.error('[POLLING][REFERENCE] ❌ Erro ao atualizar state machine:', err);
                            }
                        }
                        
                        // Abrir modal para 2ª música
                        setTimeout(() => {
                            if (typeof openReferenceUploadModal === 'function') {
                                const refJobId = jobResult.referenceJobId || jobId;
                                openReferenceUploadModal(refJobId, jobResult);
                                console.log('[POLLING][REFERENCE] ✅ Modal da 2ª música aberto - referenceJobId:', refJobId);
                            } else {
                                console.error('[POLLING][REFERENCE] ❌ openReferenceUploadModal não encontrada');
                                alert('✅ Música A analisada! Por favor, clique em "Comparação A/B" para enviar a Música B.');
                            }
                        }, 500);
                    } else if (isReferenceMode && !isReferenceBase) {
                        console.log('[POLLING][REFERENCE] 🎯 Compare completado - preparando renderização');
                    }
                    // ═══════════════════════════════════════════════════════════════
                    
                    resolve(jobResult);
                    return;
                }

                // ❌ JOB COM ERRO
                if (status === 'failed' || status === 'error') {
                    const errorMsg = job.error || jobData.error || 'Erro desconhecido no processamento';
                    reject(new Error(`Falha na análise: ${errorMsg}`));
                    return;
                }

                // Status 'queued', 'processing', etc. - continuar polling
                if (attempts >= maxAttempts) {
                    reject(new Error('Timeout: Análise demorou mais que o esperado'));
                    return;
                }

                // Aguardar 5 segundos antes da próxima verificação
                setTimeout(poll, 5000);

            } catch (error) {
                console.error('❌ Erro no polling:', error);
                reject(error);
            }
        };

        // Iniciar polling
        poll();
    });
}

/**
 * Mostrar progresso de upload na UI
 * @param {string} message - Mensagem de progresso
 */
function showUploadProgress(message) {
    const progressText = document.getElementById('audioProgressText');
    const connectionHint = document.getElementById('audioConnectionHint');
    const analysisWarning = document.querySelector('.audio-analysis-warning');
    
    if (progressText) {
        progressText.innerHTML = `🌐 ${message}`;
    }
    
    // 🎯 Mostrar dica de conexão APENAS durante upload para bucket
    const isUploadingToBucket = message.toLowerCase().includes('enviando') && 
                                (message.toLowerCase().includes('análise') || 
                                 message.toLowerCase().includes('bucket') ||
                                 message.toLowerCase().includes('bookit'));
    
    if (connectionHint) {
        connectionHint.style.display = isUploadingToBucket ? 'flex' : 'none';
    }
    
    // 🎯 Ocultar aviso de análise durante upload, mostrar depois
    if (analysisWarning) {
        analysisWarning.style.display = isUploadingToBucket ? 'none' : 'flex';
    }
}

/**
 * Atualizar progresso do modal de análise
 * @param {number} percentage - Porcentagem (0-100)
 * @param {string} message - Mensagem de status
 */
function updateModalProgress(percentage, message) {
    const progressText = document.getElementById('audioProgressText');
    const progressBar = document.getElementById('audioProgressFill') || document.querySelector('.progress-fill');
    const connectionHint = document.getElementById('audioConnectionHint');
    const analysisWarning = document.querySelector('.audio-analysis-warning');
    
    if (progressText) {
        progressText.innerHTML = `${message}`;
    }
    
    // 🎯 Ocultar dica de conexão e mostrar aviso de análise quando não estiver mais em upload
    if (connectionHint) {
        connectionHint.style.display = 'none';
    }
    
    if (analysisWarning) {
        analysisWarning.style.display = 'flex';
    }
    
    if (progressBar) {
        // Garantir que a porcentagem está entre 0 e 100
        const clampedPercentage = Math.min(Math.max(percentage, 0), 100);
        progressBar.style.width = `${clampedPercentage}%`;
        
        __dbg(`📊 Progresso atualizado: ${clampedPercentage.toFixed(1)}%`);
    }
}

/**
 * ✅ NOVA IMPLEMENTAÇÃO: Seleção de arquivo de referência com presigned URL
 * @param {string} type - Tipo do arquivo ('original' ou 'reference')
 */
function handleReferenceFileSelection(type) {
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔐 FAIL-SAFE: Bloqueio de entitlement no upload de referência
    // ═══════════════════════════════════════════════════════════════════════════════
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        console.log(`🔐 [ENTITLEMENT FAIL-SAFE] Upload de referência BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.wav,.flac,.mp3,.m4a';
    input.style.display = 'none';

    input.onchange = async function (e) {
        const file = e.target.files[0];
        if (file) {
            // 🔓 [ANONYMOUS-MODE] Interceptar análise em modo anônimo
            if (window.SoundyAnonymous?.isAnonymousMode) {
                const canProceed = window.SoundyAnonymous.interceptAnalysis();
                if (!canProceed) {
                    console.log('🚫 [ANONYMOUS] Análise referência (type) bloqueada - limite atingido');
                    return;
                }
            }
            
            try {
                // Validar arquivo
                if (file.size > 150 * 1024 * 1024) {
                    alert('❌ Arquivo muito grande. Limite: 150MB');
                    return;
                }

                __dbg(`🎯 Processando arquivo ${type} com presigned URL:`, file.name);

                // 🌐 NOVO FLUXO: Presigned URL → Upload → Job Creation → Polling
                
                // 1. Obter URL pré-assinada
                const { uploadUrl, fileKey } = await getPresignedUrl(file);
                
                // 2. Upload direto para bucket
                await uploadToBucket(uploadUrl, file);
                
                // 3. Criar job de análise
                const jobResult = await createAnalysisJob(fileKey, 'reference', file.name);
                
                // 🔥 [DEMO] Se análise foi bloqueada, interromper fluxo
                if (jobResult.blocked || jobResult.showConversion) {
                    console.log('🚫 [DEMO] Análise bloqueada no modo reference - fluxo interrompido');
                    return; // Modal de conversão já está sendo exibido
                }
                
                const { jobId } = jobResult;
                
                // 4. Aguardar resultado da análise
                const analysisResult = await pollJobStatus(jobId);
                
                // 🎯 REDUCED MODE AUTO-ACTIVATION: Detectar se backend retornou modo reduced
                // Isso acontece quando free/plus/pro atingem seu limite de análises completas
                if (analysisResult.analysisMode === 'reduced' || analysisResult.mode === 'reduced') {
                    console.log('%c[REDUCED-MODE-REF] ⚠️ Backend sinalizou modo REDUCED', 'color:orange;font-weight:bold;font-size:14px;');
                    console.log('[REDUCED-MODE-REF] Ativando modo reduced automaticamente...');
                    
                    // Forçar window.analysisMode para 'reduced'
                    window.analysisMode = 'reduced';
                    
                    // Mostrar toast informativo (não bloqueante)
                    if (window.showToast || window.Toastify) {
                        const message = 'Você atingiu o limite de análises completas. Continuando em modo reduzido (métricas básicas).';
                        if (window.showToast) {
                            window.showToast(message, 'warning');
                        } else if (window.Toastify) {
                            window.Toastify({
                                text: message,
                                duration: 7000,
                                gravity: "top",
                                position: "center",
                                backgroundColor: "#ff9800",
                                stopOnFocus: true
                            }).showToast();
                        }
                    }
                }
                
                // 🎯 FIX CRÍTICO: Injetar file.name no resultado ANTES de salvar no store
                if (file && file.name) {
                    if (!analysisResult.fileName) {
                        analysisResult.fileName = file.name;
                        console.log('[FILENAME-FIX-REF] ✅ Injetado fileName:', file.name);
                    }
                    if (!analysisResult.metadata) {
                        analysisResult.metadata = {};
                    }
                    if (!analysisResult.metadata.fileName) {
                        analysisResult.metadata.fileName = file.name;
                        console.log('[FILENAME-FIX-REF] ✅ Injetado metadata.fileName:', file.name);
                    }
                }
                
                // 🔍 LOG DE DEBUG: Verificar se análise está completa
                console.log('🔍 [DEBUG] Análise retornada do polling:', {
                    hasResult: !!analysisResult,
                    hasTechnicalData: !!analysisResult?.technicalData,
                    avgLoudness: analysisResult?.technicalData?.avgLoudness,
                    lufsIntegrated: analysisResult?.technicalData?.lufsIntegrated,
                    truePeakDbtp: analysisResult?.technicalData?.truePeakDbtp,
                    dynamicRange: analysisResult?.technicalData?.dynamicRange
                });
                
                // 🧩 AUDITORIA 1: Verificar se displayModalResults está disponível
                console.log("[AUDITORIA] displayModalResults:", typeof window.displayModalResults);
                
                // Mostrar resultados no modal (com validação interna de métricas)
                const tryShowModal = (result, attempts = 0) => {
                    if (typeof window.displayModalResults === "function") {
                        console.log("✅ [AUDITORIA] displayModalResults encontrada, exibindo modal...");
                        console.log("✅ [RETRY_SUCCESS] Tentativa", attempts + 1, "bem-sucedida, chamando displayModalResults");
                        console.log("[DISPLAY] Metrics modal triggered from tryShowModal");
                        displayModalResults(result);
                    } else if (attempts < 10) {
                        console.warn("[AUDITORIA] displayModalResults não disponível, tentativa", attempts + 1);
                        setTimeout(() => tryShowModal(result, attempts + 1), 500);
                    } else {
                        console.error("[AUDITORIA] Falha ao exibir modal após múltiplas tentativas");
                        // Fallback: tentar exibir em modal simples
                        alert("Análise concluída, mas modal não pôde ser exibido. Verifique o console para dados.");
                        console.log("[AUDITORIA] Dados da análise:", result);
                    }
                };
                
                tryShowModal(analysisResult);
                
                // � [ANONYMOUS-MODE] Registrar análise concluída
                if (window.SoundyAnonymous?.isAnonymousMode) {
                    window.SoundyAnonymous.registerAnalysis();
                    console.log('📊 [ANONYMOUS] Análise registrada com sucesso');
                }
                
                // �🔥 [DEMO-MODE] Registrar análise concluída
                if (window.SoundyDemo?.isActive) {
                    window.SoundyDemo.registerAnalysis();
                    console.log('📊 [DEMO] Análise registrada com sucesso');
                }

                // 5. Armazenar resultado
                uploadedFiles[type] = {
                    fileKey: fileKey,
                    fileName: file.name,
                    analysisResult: analysisResult
                };

                console.log(`✅ Arquivo ${type} processado com sucesso:`, file.name, "fileKey:", fileKey);

                // Atualizar interface
                updateFileStatus(type, file.name);

                // Avançar fluxo
                if (type === "original") {
                    updateProgressStep(2);
                    promptReferenceFile();
                } else if (type === "reference") {
                    updateProgressStep(3);
                    enableAnalysisButton();
                }

            } catch (error) {
                console.error(`❌ Erro no processamento do arquivo ${type}:`, error);
                alert(`❌ Erro ao processar arquivo: ${error.message}`);

                // Abrir modal de análise em caso de erro
                abrirModalDeAnalise("Erro ao processar arquivo para análise.");
            }
        }
    };

    document.body.appendChild(input);
    input.click();
    document.body.removeChild(input);
}


function updateFileStatus(type, filename) {
    const statusContainer = document.getElementById('fileUploadStatus');
    if (!statusContainer) return;
    
    let statusDiv = statusContainer.querySelector(`#${type}FileStatus`);
    if (!statusDiv) {
        statusDiv = document.createElement('div');
        statusDiv.id = `${type}FileStatus`;
        statusDiv.className = 'file-status';
        statusContainer.appendChild(statusDiv);
    }
    
    const label = type === 'original' ? '🎵 Música Original' : '🎯 Referência';
    statusDiv.innerHTML = `
        <div class="file-item">
            <span class="file-label">${label}:</span>
            <span class="file-name">${filename}</span>
            <span class="file-check">✅</span>
        </div>
    `;
}

function promptReferenceFile() {
    const modal = document.getElementById('audioAnalysisModal');
    const uploadBtn = modal.querySelector('#uploadButton');
    
    if (uploadBtn) {
        uploadBtn.textContent = '🎯 Upload da Música de Referência';
        uploadBtn.onclick = () => handleReferenceFileSelection('reference');
    }
}

function enableAnalysisButton() {
    const modal = document.getElementById('audioAnalysisModal');
    let analyzeBtn = modal.querySelector('#analyzeReferenceBtn');
    
    if (!analyzeBtn) {
        analyzeBtn = document.createElement('button');
        analyzeBtn.id = 'analyzeReferenceBtn';
        analyzeBtn.className = 'btn btn-primary';
        analyzeBtn.textContent = '🔬 Iniciar Análise Comparativa';
        analyzeBtn.onclick = startReferenceAnalysis;
        
        const uploadBtn = modal.querySelector('#uploadButton');
        if (uploadBtn && uploadBtn.parentNode) {
            uploadBtn.parentNode.insertBefore(analyzeBtn, uploadBtn.nextSibling);
        }
    }
    
    analyzeBtn.style.display = 'block';
    analyzeBtn.disabled = false;
}

// 🎯 Análise Comparativa
async function startReferenceAnalysis() {
    if (!uploadedFiles.original || !uploadedFiles.reference) {
        alert('❌ Por favor, faça upload de ambos os arquivos');
        return;
    }

    updateProgressStep(4);

    try {
        showAnalysisProgress();

        // 🎯 Extrair gênero selecionado do dropdown
        const genreSelect = document.getElementById('audioRefGenreSelect');
        let selectedGenre = genreSelect?.value;
        
        // 🎯 CORREÇÃO: Validar se é string não-vazia antes de fallback
        if (!selectedGenre || selectedGenre.trim() === '') {
            selectedGenre = window.PROD_AI_REF_GENRE || 'default';
        }
        
        console.log('[TRACE-GENRE][FRONTEND-REF] 🎵 Gênero para análise de referência:', {
            'genreSelect.value': genreSelect?.value,
            'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE,
            'selectedGenre (final)': selectedGenre
        });

        // ✅ Obter token (prioridade: currentUser > localStorage)
        let token = null;
        const currentUser = window.auth?.currentUser;
        
        if (currentUser) {
            try {
                token = await currentUser.getIdToken();
                console.log('✅ [REF-MODE] Token obtido do currentUser');
            } catch (err) {
                console.warn('⚠️ [REF-MODE] Erro ao obter token do currentUser:', err.message);
            }
        }
        
        if (!token) {
            token = localStorage.getItem('authToken') || localStorage.getItem('idToken');
            if (token) {
                console.log('✅ [REF-MODE] Token obtido do localStorage (fallback)');
            }
        }
        
        if (!token) {
            console.error('[CRITICAL] ID Token ausente no localStorage após login.');
            console.error('❌ Token não disponível - usuário não autenticado');
            throw new Error('Você precisa estar logado para analisar áudio.');
        }

        const response = await fetch('/api/audio/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}` // ✅ Token também no header
            },
            body: JSON.stringify({
                originalKey: uploadedFiles.original,
                referenceKey: uploadedFiles.reference,
                mode: 'reference',
                genre: selectedGenre, // 🎯 FIX CRÍTICO: Gênero agora incluído
                idToken: token // ✅ CORREÇÃO CRÍTICA: Chave correta para backend (req.body.idToken)
            })
        });

        if (!response.ok) {
            throw new Error(`Erro na análise: ${response.status}`);
        }

        const result = await response.json();
        
        console.log('🔍 [REF-ANALYSIS] Resposta do POST /analyze:', result);
        
        // ✅ CORREÇÃO CRÍTICA: result só tem jobId, precisa fazer POLLING
        if (!result.success || !result.jobId) {
            throw new Error('Falha ao criar job de análise');
        }
        
        console.log('⏳ [REF-ANALYSIS] Iniciando polling do job:', result.jobId);
        
        // Fazer polling até análise completar
        const pollInterval = 2000; // 2 segundos
        const maxAttempts = 60; // 2 minutos máximo
        let attempts = 0;
        let analysisComplete = false;
        let completeResult = null;
        
        while (!analysisComplete && attempts < maxAttempts) {
            attempts++;
            
            try {
                const pollResponse = await fetch(`/api/jobs/${result.jobId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!pollResponse.ok) {
                    throw new Error(`Erro ao consultar job: ${pollResponse.status}`);
                }
                
                const jobStatus = await pollResponse.json();
                
                console.log(`🔄 [REF-POLLING] Tentativa ${attempts}/${maxAttempts} - Status: ${jobStatus.status}`);
                
                if (jobStatus.status === 'completed' && jobStatus.results) {
                    analysisComplete = true;
                    completeResult = jobStatus.results;
                    console.log('✅ [REF-POLLING] Análise completa!');
                    break;
                } else if (jobStatus.status === 'failed') {
                    throw new Error('Análise falhou no backend');
                }
                
                // Aguardar antes da próxima tentativa
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                
            } catch (pollError) {
                console.error('❌ [REF-POLLING] Erro no polling:', pollError);
                throw pollError;
            }
        }
        
        if (!completeResult) {
            throw new Error('Timeout: Análise não completou em 2 minutos');
        }
        
        // Agora sim, chamar com resultado COMPLETO
        displayReferenceComparison(completeResult);

    } catch (error) {
        console.error('❌ Erro na análise:', error);
        alert('❌ Erro durante a análise. Tente novamente.');
    }
}


function showAnalysisProgress() {
    const modal = document.getElementById('audioAnalysisModal');
    const content = modal.querySelector('.modal-content');
    
    // Criar overlay de progresso
    const progressOverlay = document.createElement('div');
    progressOverlay.id = 'analysisProgressOverlay';
    progressOverlay.className = 'analysis-progress-overlay';
    progressOverlay.innerHTML = `
        <div class="progress-content">
            <div class="spinner"></div>
            <h3>🔬 Analisando Arquivos...</h3>
            <p>Processando características espectrais e comparando com referência...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
        </div>
    `;
    
    content.appendChild(progressOverlay);
}

function displayReferenceComparison(data) {
    // 🔍 DEBUG CRÍTICO: Ver exatamente o que chega aqui
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('🔍 [DEBUG] displayReferenceComparison CHAMADA');
    console.log('🔍 [DEBUG] Type of data:', typeof data);
    console.log('🔍 [DEBUG] Data keys:', data ? Object.keys(data) : 'null');
    console.log('🔍 [DEBUG] Data completo:', JSON.stringify(data, null, 2).substring(0, 500));
    console.log('🔍 [DEBUG] Validações:');
    console.log('  - data existe?', !!data);
    console.log('  - data.technicalData?', !!data?.technicalData);
    console.log('  - data._fromHistory?', data?._fromHistory);
    console.log('  - data.success?', data?.success);
    console.log('  - data.jobId?', data?.jobId);
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    
    const modal = document.getElementById('audioAnalysisModal');
    const progressOverlay = document.getElementById('analysisProgressOverlay');
    
    // Remover overlay de progresso
    if (progressOverlay) {
        progressOverlay.remove();
    }
    
    // 🕐 HISTÓRICO PRO: Ponto único de salvamento para análises de REFERÊNCIA
    // ✅ Salvar AQUI onde temos o dado completo
    if (data && !data._fromHistory && data.technicalData) {
        console.log('🕐 [HISTORY-SAVE] displayReferenceComparison detectou análise de referência');
        console.log('🕐 [HISTORY-SAVE] Estrutura do data:', {
            hasOriginal: !!data.original,
            hasReference: !!data.reference,
            hasComparison: !!data.comparison,
            hasTechnicalData: !!data.technicalData,
            hasMetadata: !!data.metadata,
            keys: Object.keys(data)
        });
        
        const referenceAnalysisData = {
            ...data,
            mode: 'reference',
            analysisMode: 'reference',
            metadata: data.metadata || {
                fileName: data.original?.metadata?.fileName || data.current?.fileName || 'Música Original',
                referenceName: data.base?.fileName || data.reference?.metadata?.fileName || 'Referência'
            }
        };
        
        // Salvar assíncrono (não bloqueia UI)
        saveAnalysisToHistory(referenceAnalysisData).catch(err => {
            console.warn('🕐 [HISTORY-SAVE] Erro ao salvar (não crítico):', err);
        });
    } else {
        console.warn('🕐 [HISTORY-SAVE] ❌ Análise de referência NÃO será salva:', {
            hasData: !!data,
            isFromHistory: data?._fromHistory,
            hasTechnicalData: !!data?.technicalData
        });
    }
    
    // Criar seção de resultados
    const resultsSection = document.createElement('div');
    resultsSection.id = 'referenceResults';
    resultsSection.className = 'reference-results';
    
    resultsSection.innerHTML = generateComparisonHTML(data);
    
    const content = modal.querySelector('.modal-content');
    content.appendChild(resultsSection);
    
    // 🚫 OCULTAR BOTÃO "PLANO DE CORREÇÃO" NO MODO REFERÊNCIA
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan) {
        btnCorrectionPlan.style.display = 'none';
        console.log('[REFERENCE-UI] 🔒 Botão "Plano de Correção" ocultado no modo referência');
    }
    
    // Scroll para resultados
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

function generateComparisonHTML(data) {
    const { original, reference, comparison } = data;
    
    return `
        <div class="comparison-header">
            <h3>📊 Análise Comparativa Concluída</h3>
            <div class="overall-similarity">
                <span class="similarity-label">Similaridade Geral:</span>
                <span class="similarity-score ${getSimilarityClass(comparison.overallSimilarity)}">
                    ${comparison.overallSimilarity}%
                </span>
            </div>
        </div>
        
        <div class="comparison-grid">
            <div class="comparison-section">
                <h4>🎵 Música Original</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(original)}
                </div>
            </div>
            
            <div class="comparison-section">
                <h4>🎯 Música de Referência</h4>
                <div class="audio-analysis-card">
                    ${generateAudioAnalysisCard(reference)}
                </div>
            </div>
        </div>
        
        <div class="differences-section">
            <h4>🔍 Principais Diferenças</h4>
            <div class="differences-grid">
                ${generateDifferencesGrid(comparison.differences)}
            </div>
        </div>
        
        <div class="suggestions-section">
            <h4>💡 Sugestões de Melhoria</h4>
            <div class="suggestions-list">
                ${generateSuggestionsList(comparison.suggestions)}
            </div>
        </div>
    `;
}

function generateAudioAnalysisCard(analysis) {
    return `
        <div class="spectral-info">
            <div class="info-item">
                <span class="label">Frequência Fundamental:</span>
                <span class="value">${analysis.fundamentalFreq} Hz</span>
            </div>
            <div class="info-item">
                <span class="label">Faixa Dinâmica:</span>
                <span class="value">${analysis.dynamicRange} dB</span>
            </div>
            <div class="info-item">
                <span class="label">Stereo Width:</span>
                <span class="value">${analysis.stereoWidth}%</span>
            </div>
        </div>
        
        <!-- REMOVED: Bandas de Frequência duplicada - consolidada nas métricas avançadas -->
        <!-- frequency-bands section removed to avoid duplication -->
    `;
}

function generateDifferencesGrid(differences) {
    return differences.map(diff => `
        <div class="difference-item ${diff.severity}">
            <div class="diff-header">
                <span class="diff-parameter">${diff.parameter}</span>
                <span class="diff-value">${diff.difference}</span>
            </div>
            <div class="diff-description">${diff.description}</div>
        </div>
    `).join('');
}

function generateSuggestionsList(suggestions) {
    return suggestions.map(suggestion => `
        <div class="suggestion-item">
            <div class="suggestion-title">${suggestion.title}</div>
            <div class="suggestion-description">${suggestion.description}</div>
            <div class="suggestion-priority priority-${suggestion.priority}">
                Prioridade: ${suggestion.priority.toUpperCase()}
            </div>
        </div>
    `).join('');
}

function getSimilarityClass(similarity) {
    if (similarity >= 80) return 'high-similarity';
    if (similarity >= 60) return 'medium-similarity';
    return 'low-similarity';
}

// 🎯 Exposição de Funções Globais
window.openModeSelectionModal = openModeSelectionModal;
window.closeModeSelectionModal = closeModeSelectionModal;
window.selectAnalysisMode = selectAnalysisMode;

//! DEBUG: Função de debug global para forçar recarga
window.forceReloadRefs = async function(genre = 'funk_bruxaria') {
    console.log('🔄 FORÇA RECARGA DE REFERÊNCIAS:', genre);
    
    // Limpar tudo
    delete window.__refDataCache;
    window.__refDataCache = {};
    window.REFS_BYPASS_CACHE = true;
    window.__activeRefData = null;
    window.__activeRefGenre = null;
    delete window.PROD_AI_REF_DATA;
    
    console.log('💥 Cache limpo, forçando reload...');
    
    try {
        const result = await loadReferenceData(genre);
        console.log('✅ Recarga forçada concluída:', {
            version: result.version,
            lufs_target: result.lufs_target,
            true_peak_target: result.true_peak_target,
            presenca_band: result.bands?.presenca?.target_db
        });
        
        // Resetar flag
        window.REFS_BYPASS_CACHE = false;
        return result;
    } catch (error) {
        console.error('💥 Erro na recarga forçada:', error);
        window.REFS_BYPASS_CACHE = false;
        throw error;
    }
};

// 🔍 Função de Diagnóstico de Referências (somente dev)
window.diagnosRefSources = function(genre = null) {
    const targetGenre = genre || __activeRefGenre || 'funk_bruxaria';
    const currentData = __activeRefData;
    const cached = __refDataCache[targetGenre];
    
    console.log('🎯 REFERÊNCIAS DIAGNÓSTICO COMPLETO:', {
        requestedGenre: targetGenre,
        activeGenre: __activeRefGenre,
        currentSource: currentData ? 'loaded' : 'none',
        cacheExists: !!cached,
        REFS_ALLOW_NETWORK: typeof window !== 'undefined' ? window.REFS_ALLOW_NETWORK : 'undefined',
        currentData: currentData ? {
            version: currentData.version,
            num_tracks: currentData.num_tracks,
            lufs_target: currentData.lufs_target,
            true_peak_target: currentData.true_peak_target,
            stereo_target: currentData.stereo_target,
            sub_band: currentData.bands?.sub?.target_db,
            presenca_band: currentData.bands?.presenca?.target_db
        } : null
    });
    
    // Test fetch do JSON externo
    const testUrl = `/refs/out/${targetGenre}.json?v=diagnostic`;
    fetch(testUrl).then(r => r.json()).then(j => {
        const data = j[targetGenre];
        console.log('🌐 EXTERNAL JSON TEST:', {
            url: testUrl,
            success: true,
            version: data?.version,
            num_tracks: data?.num_tracks,
            lufs_target: data?.lufs_target,
            true_peak_target: data?.true_peak_target,
            stereo_target: data?.stereo_target
        });
    }).catch(e => console.log('❌ EXTERNAL JSON FAILED:', testUrl, e.message));
    
    return { targetGenre, currentData, cached };
};

// =============== ETAPA 2: Robustez & Completeness Helpers ===============
// Central logging para métricas ausentes / NaN (evita console spam e facilita auditoria)
function __logMetricAnomaly(kind, key, context={}) {
    try {
        if (typeof window === 'undefined') return;
        const store = (window.__METRIC_ANOMALIES__ = window.__METRIC_ANOMALIES__ || []);
        const stamp = Date.now();
        store.push({ t: stamp, kind, key, ctx: context });
        if (window.DEBUG_ANALYZER) console.warn('[METRIC_ANOMALY]', kind, key, context);
        // Limitar tamanho
        if (store.length > 500) store.splice(0, store.length - 500);
    } catch {}
}

// Placeholder seguro para valores não finitos (exibe '—' e loga uma vez por chave por render)
function safeDisplayNumber(val, key, decimals=2) {
    if (!Number.isFinite(val)) { __logMetricAnomaly('non_finite', key); return '—'; }
    return val.toFixed(decimals);
}

// 🆕 Função para exibir estruturas complexas das novas métricas
function safeDisplayComplexMetric(metric, type = 'generic') {
    if (!metric || typeof metric !== 'object') return '—';
    
    switch (type) {
        case 'frequency':
            // Para dominantFrequencies
            if (metric.value !== undefined) {
                const unit = metric.unit || 'Hz';
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(1) : '—';
                return `${value} ${unit}`;
            }
            return '—';
            
        case 'dcOffset':
            // Para dcOffset com canais L/R
            if (metric.detailed && (metric.detailed.L !== undefined || metric.detailed.R !== undefined)) {
                const L = Number.isFinite(metric.detailed.L) ? metric.detailed.L.toFixed(4) : '—';
                const R = Number.isFinite(metric.detailed.R) ? metric.detailed.R.toFixed(4) : '—';
                return `L: ${L}, R: ${R}`;
            } else if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(4) : '—';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '—';
            
        case 'spectral':
            // Para spectralUniformity
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(3) : '—';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '—';
            
        default:
            // Generic: tentar exibir value ou primeiro campo numérico
            if (metric.value !== undefined) {
                const value = Number.isFinite(metric.value) ? metric.value.toFixed(2) : '—';
                const unit = metric.unit || '';
                return `${value} ${unit}`;
            }
            return '—';
    }
}

// Invalidação ampla de caches derivados quando gênero mudar
function invalidateReferenceDerivedCaches() {
    try {
        if (typeof window === 'undefined') return;
        delete window.PROD_AI_REF_DATA; // força reuso atualizado
    } catch {}
}

// Enriquecimento de objeto de referência: preencher lacunas e padronizar escala
function enrichReferenceObject(refObj, genreKey) {
    try {
        if (!refObj || typeof refObj !== 'object') return refObj;
        
        // 🔥 CORREÇÃO CRÍTICA: Mapear hybrid_processing para propriedades root
        if (refObj.hybrid_processing && typeof refObj.hybrid_processing === 'object') {
            const hybrid = refObj.hybrid_processing;
            
            // Mapear original_metrics
            if (hybrid.original_metrics && typeof hybrid.original_metrics === 'object') {
                refObj.original_metrics = hybrid.original_metrics;
                
                // Mapear métricas individuais para compatibilidade
                if (hybrid.original_metrics.lufs_integrated !== undefined) {
                    refObj.lufs_target = hybrid.original_metrics.lufs_integrated;
                }
                if (hybrid.original_metrics.true_peak_dbtp !== undefined) {
                    refObj.true_peak_target = hybrid.original_metrics.true_peak_dbtp;
                }
                if (hybrid.original_metrics.dynamic_range !== undefined) {
                    refObj.dr_target = hybrid.original_metrics.dynamic_range;
                }
                if (hybrid.original_metrics.stereo_correlation !== undefined) {
                    refObj.stereo_target = hybrid.original_metrics.stereo_correlation;
                }
                if (hybrid.original_metrics.lra !== undefined) {
                    refObj.lra_target = hybrid.original_metrics.lra;
                }
            }
            
            // Mapear spectral_bands (prioridade sobre legacy)
            if (hybrid.spectral_bands && typeof hybrid.spectral_bands === 'object') {
                refObj.spectral_bands = hybrid.spectral_bands;
                
                // 🎯 CORREÇÃO CRÍTICA: Normalizar chaves de snake_case → camelCase
                if (!refObj.bands) {
                    const normalizedBands = {};
                    Object.keys(hybrid.spectral_bands).forEach(snakeKey => {
                        const camelKey = normalizeGenreBandName(snakeKey);
                        normalizedBands[camelKey] = hybrid.spectral_bands[snakeKey];
                    });
                    refObj.bands = normalizedBands;
                    console.log('[ENRICH] 🎯 Bandas normalizadas:', Object.keys(normalizedBands));
                }
            }
        }
        
        // CORREÇÃO CRÍTICA: Mapear legacy_compatibility para propriedades root (fallback)
        if (refObj.legacy_compatibility && typeof refObj.legacy_compatibility === 'object') {
            const legacy = refObj.legacy_compatibility;
            
            // Mapear propriedades principais (apenas se não foram definidas por hybrid)
            if (legacy.lufs_target !== undefined && refObj.lufs_target === undefined) refObj.lufs_target = legacy.lufs_target;
            if (legacy.tol_lufs !== undefined) refObj.tol_lufs = legacy.tol_lufs;
            if (legacy.true_peak_target !== undefined && refObj.true_peak_target === undefined) refObj.true_peak_target = legacy.true_peak_target;
            if (legacy.tol_true_peak !== undefined) refObj.tol_true_peak = legacy.tol_true_peak;
            if (legacy.dr_target !== undefined && refObj.dr_target === undefined) refObj.dr_target = legacy.dr_target;
            if (legacy.tol_dr !== undefined) refObj.tol_dr = legacy.tol_dr;
            if (legacy.lra_target !== undefined && refObj.lra_target === undefined) refObj.lra_target = legacy.lra_target;
            if (legacy.tol_lra !== undefined) refObj.tol_lra = legacy.tol_lra;
            if (legacy.stereo_target !== undefined && refObj.stereo_target === undefined) refObj.stereo_target = legacy.stereo_target;
            if (legacy.tol_stereo !== undefined) refObj.tol_stereo = legacy.tol_stereo;
            
            // Mapear bandas de frequência (apenas se não foram definidas por hybrid)
            if (legacy.bands && typeof legacy.bands === 'object' && !refObj.bands) {
                refObj.bands = legacy.bands;
            }
        }
        
        // Feature flag geral
        const enabled = (typeof window === 'undefined') || window.ENABLE_REF_ENRICHMENT !== false;
        if (!enabled) return refObj;
        // Definir escala default se ausente
        if (!refObj.scale) refObj.scale = 'log_ratio_db';
        // Preencher stereo_target se ausente usando estatísticas agregadas (Etapa 2)
        if (refObj.stereo_target == null) {
            try {
                const g = (genreKey||'').toLowerCase();
                const stat = __refDerivedStats[g];
                if (stat && Number.isFinite(stat.avgStereo) && stat.countStereo >= 2) {
                    refObj.stereo_target = stat.avgStereo;
                    refObj.__stereo_filled = 'dataset_avg';
                } else {
                    // fallback heurístico
                    refObj.stereo_target = g.includes('trance') ? 0.17 : (g.includes('funk') ? 0.12 : 0.15);
                    refObj.__stereo_filled = 'heuristic';
                }
                refObj.tol_stereo = refObj.tol_stereo == null ? 0.08 : refObj.tol_stereo;
            } catch { /* noop */ }
        }
        // Garantir tol_stereo razoável
        if (refObj.tol_stereo == null) refObj.tol_stereo = 0.08;
        // Bandas: marcar N/A para target_db null e permitir comparação ignorando
        if (refObj.bands && typeof refObj.bands === 'object') {
            for (const [k,v] of Object.entries(refObj.bands)) {
                if (!v || typeof v !== 'object') continue;
                if (v.target_db == null) {
                    v._target_na = true; // flag para UI
                }
            }
        }
        // Normalização opcional antecipada (apenas ajuste de metadado; cálculo real feito no analyzer)
        if (window && window.PRE_NORMALIZE_REF_BANDS === true && refObj.bands) {
            const vals = Object.values(refObj.bands).map(b=>b&&Number.isFinite(b.target_db)?b.target_db:null).filter(v=>v!=null);
            const negRatio = vals.filter(v=>v<0).length/Math.max(1,vals.length);
            const posRatio = vals.filter(v=>v>0).length/Math.max(1,vals.length);
            // Se maioria positiva mas queremos alinhar a negativos, apenas anotar
            if (posRatio>0.7 && negRatio<0.3) refObj.__scale_mismatch_hint = 'positive_targets_vs_negative_measurements';
        }
    } catch (e) { console.warn('[refEnrich] falha', e); }
    return refObj;
}

// Fallback embutido inline para evitar 404 em produção
// 🎛️ ATUALIZADO: Funk Mandela 2025-08-fixed-flex (18/08/2025) - Estrutura Fixed/Flex Implementada
const __INLINE_EMBEDDED_REFS__ = {
    manifest: { genres: [
        { key: 'trance', label: 'Trance' },
        { key: 'funk_mandela', label: 'Funk Mandela' },
        { key: 'funk_bruxaria', label: 'Funk Bruxaria' },
        { key: 'funk_automotivo', label: 'Funk Automotivo' },
        { key: 'eletronico', label: 'Eletrônico' },
        { key: 'eletrofunk', label: 'Eletrofunk' },
        { key: 'funk_consciente', label: 'Funk Consciente' },
        { key: 'trap', label: 'Trap' }
    ]},
    byGenre: {
        trance: { lufs_target: -14, tol_lufs: 0.5, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 9.4, tol_dr: 0.8, lra_target: 10.7, tol_lra: 2.7, stereo_target: 0.17, tol_stereo: 0.03, bands: { sub:{target_db:-17.3,tol_db:2.5}, low_bass:{target_db:-14.6,tol_db:4.3}, upper_bass:{target_db:-14.8,tol_db:2.5}, low_mid:{target_db:-12.6,tol_db:3.7}, mid:{target_db:-12,tol_db:4.0}, high_mid:{target_db:-20.2,tol_db:3.6}, brilho:{target_db:-24.7,tol_db:2.5}, presenca:{target_db:-32.1,tol_db:3.6} } },
    // Perfil atualizado Funk Mandela 2025-08-mandela-targets.4-tolerances-updated - TOLERÂNCIAS BIDIRECIONAIS ATUALIZADAS
    funk_mandela:   { 
        version: "2025-08-mandela-targets.4-tolerances-updated", 
        lufs_target: -8.0, tol_lufs: 2.5, tol_lufs_min: 2.5, tol_lufs_max: 2.5, 
        true_peak_target: -0.8, tol_true_peak: 1.0, true_peak_streaming_max: -1.2, true_peak_baile_max: -0.1, 
        dr_target: 8.0, tol_dr: 3.0, // Atualizado para ±3.0 unidades
        lra_target: 9.0, lra_min: 6.5, lra_max: 11.5, tol_lra: 2.5, 
        stereo_target: 0.60, tol_stereo: 0.25, stereo_width_target: 0.20, stereo_width_tol: 0.25, // Correlação 0.60 ± 0.25
        low_end_mono_cutoff: 100, clipping_sample_pct_max: 0.02, vocal_band_min_delta: -1.5,
        fixed: {
            lufs: { integrated: { target: -8.0, tolerance: 2.5 } },
            rms: { policy: "deriveFromLUFS" },
            truePeak: { streamingMax: -1.2, baileMax: -0.1, target: -8.0 },
            dynamicRange: { crest: { target: 8.0, min: 5.0, max: 11.0 } },
            lowEnd: { mono: { cutoffHz: 100 } },
            vocalPresence: { bandHz: [1000, 4000], vocalBandMinDeltaDb: -1.5 }
        },
        flex: {
            clipping: { samplePctMax: 0.02 },
            lra: { min: 6.5, max: 11.5, target: 9.0 },
            stereo: { correlation: { min: 0.35, max: 0.85 }, width: { min: 0.075, max: 0.325 } }
        },
        pattern_rules: { 
            hard_constraints: ["lufs", "truePeak", "dynamicRange", "lowEnd", "vocalPresence"], 
            soft_constraints: ["clipping", "lra", "stereo", "tonalCurve"] 
        }, 
        bands: { 
            sub:{target_db:-7.2,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            low_bass:{target_db:-8.9,tol_db:2.5,severity:"soft",range_hz:"60-120"}, 
            upper_bass:{target_db:-12.8,tol_db:2.5,severity:"soft",range_hz:"120-200"}, 
            low_mid:{target_db:-9.2,tol_db:2.0,severity:"soft",range_hz:"200-500"}, 
            mid:{target_db:-6.8,tol_db:1.5,severity:"hard",vocal_presence_range:true,range_hz:"500-2000"}, 
            high_mid:{target_db:-12.3,tol_db:1.5,severity:"soft",range_hz:"2000-4000"}, 
            brilho:{target_db:-16.2,tol_db:2.0,severity:"soft",range_hz:"4000-8000"}, 
            presenca:{target_db:-19.1,tol_db:2.5,severity:"hard",vocal_presence_range:true,range_hz:"8000-12000"} 
        } 
    },
        funk_bruxaria: { 
            version: "1.0.1",
            generated_at: "2025-08-23T18:03:37.143Z",
            num_tracks: 29,
            lufs_target: -14,
            tol_lufs: 0.5,
            true_peak_target: -1.0,
            tol_true_peak: 1.0,
            dr_target: 7.4,
            tol_dr: 1.3,
            lra_target: 8.4,
            tol_lra: 2.8,
            stereo_target: 0.3,
            tol_stereo: 0.1,
            calor_target: -11.95,
            brilho_target: -17.69,
            clareza_target: -1.21,
            bands: {
                sub: { target_db: -12.5, tol_db: 3 },
                low_bass: { target_db: -15.2, tol_db: 3 },
                upper_bass: { target_db: -15.2, tol_db: 2.3 },
                low_mid: { target_db: -12, tol_db: 1.7 },
                mid: { target_db: -8.7, tol_db: 1.7 },
                high_mid: { target_db: -14.5, tol_db: 2.8 },
                brilho: { target_db: -17.7, tol_db: 2.2 },
                presenca: { target_db: -26.7, tol_db: 2.8 }
            }
        },
        funk_automotivo:{ lufs_target: -8,  tol_lufs: 1.2, true_peak_target: -1.0, tol_true_peak: 1.0, dr_target: 8.1, tol_dr: 2.0, lra_target: 6.6, tol_lra: 4.0, stereo_target: 0.3, tol_stereo: 0.15, bands: { sub:{target_db:-7.6,tol_db:6.0}, low_bass:{target_db:-6.6,tol_db:4.5}, upper_bass:{target_db:-11.4,tol_db:3.5}, low_mid:{target_db:-8.2,tol_db:3.5}, mid:{target_db:-6.7,tol_db:3.0}, high_mid:{target_db:-12.8,tol_db:4.5}, brilho:{target_db:-16.6,tol_db:4.5}, presenca:{target_db:-22.7,tol_db:5.0} } },
        eletronico:     { 
            version: "1.0.1",
            lufs_target: -14, tol_lufs: 0.5, tol_lufs_min: 0.5, tol_lufs_max: 0.5,  
            true_peak_target: -1.0, tol_true_peak: 1.0, true_peak_streaming_max: -1.0, true_peak_baile_max: 0.0,
            dr_target: 10.1, tol_dr: 1.4, 
            lra_target: 5.2, lra_min: 1.2, lra_max: 9.2, tol_lra: 4, 
            stereo_target: 0.19, tol_stereo: 0.07, stereo_width_mids_highs_tolerance: "moderate",
            low_end_mono_cutoff: 80, clipping_sample_pct_max: 0.01, vocal_band_min_delta: -2.0,
            bands: { 
                sub:{target_db:-12.5,tol_db:3}, 
                low_bass:{target_db:-10.6,tol_db:3}, 
                upper_bass:{target_db:-13.7,tol_db:3}, 
                low_mid:{target_db:-12.1,tol_db:2.7}, 
                mid:{target_db:-11.8,tol_db:2.4}, 
                high_mid:{target_db:-19.1,tol_db:2.3}, 
                brilho:{target_db:-19.1,tol_db:2}, 
                presenca:{target_db:-24,tol_db:3} 
            } 
        },
        eletrofunk:     { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.12, tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        funk_consciente:{ lufs_target: -12, tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 10, tol_dr: 2, lra_target: 7, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-18,tol_db:4.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } },
        trap:           { lufs_target: -9,  tol_lufs: 1,  true_peak_target: -1, tol_true_peak: 1, dr_target: 8, tol_dr: 2, lra_target: 6, tol_lra: 3, stereo_target: 0.1,  tol_stereo: 0.1, bands: { sub:{target_db:-16,tol_db:5.5}, low_bass:{target_db:-16,tol_db:4.5}, upper_bass:{target_db:-15,tol_db:4.5}, low_mid:{target_db:-14,tol_db:4.5}, mid:{target_db:-13,tol_db:4.5}, high_mid:{target_db:-20,tol_db:4.5}, brilho:{target_db:-25,tol_db:4.5}, presenca:{target_db:-32,tol_db:4.5} } }
    }
};

// 🔄 CRIAR ALIASES PARA COMPATIBILIDADE COM IDs LEGADOS
// Isso garante que análises antigas e fallbacks inline continuem funcionando
(function createInlineLegacyAliases() {
  const byGenre = __INLINE_EMBEDDED_REFS__.byGenre;
  const aliases = {
    'progressive_trance': 'trance',
    'edm': 'funk_automotivo'
  };
  
  Object.entries(aliases).forEach(([newId, legacyId]) => {
    // Se existe o legado, criar o novo ID
    if (byGenre[legacyId] && !byGenre[newId]) {
      byGenre[newId] = byGenre[legacyId];
      console.log(`[INLINE-ALIAS] Criado novo ID: "${newId}" a partir de "${legacyId}"`);
    }
    // Se existe o novo, criar alias legado
    else if (byGenre[newId] && !byGenre[legacyId]) {
      byGenre[legacyId] = byGenre[newId];
      console.log(`[INLINE-ALIAS] Criado alias: "${legacyId}" → "${newId}"`);
    }
  });
})();

// Construir estatísticas agregadas (média stereo por gênero) a partir de refs carregadas
function buildAggregatedRefStats() {
    try {
        const map = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre;
        if (!map) return;
        for (const [g, data] of Object.entries(map)) {
            if (!data || typeof data !== 'object') continue;
            // stereo_target já definido conta; se null ignorar
            if (Number.isFinite(data.stereo_target)) {
                const st = (__refDerivedStats[g] = __refDerivedStats[g] || { sumStereo:0, countStereo:0 });
                st.sumStereo += data.stereo_target; st.countStereo += 1;
            }
        }
        for (const [g, st] of Object.entries(__refDerivedStats)) {
            if (st.countStereo > 0) st.avgStereo = st.sumStereo / st.countStereo;
        }
    } catch (e) { if (window.DEBUG_ANALYZER) console.warn('buildAggregatedRefStats fail', e); }
}

// Carregar dinamicamente o fallback embutido se necessário
async function ensureEmbeddedRefsReady(timeoutMs = 2500) {
    try {
        if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
        // Se não for explicitamente permitido, não tentar carregar pela rede para evitar 404
        if (!(typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true)) return false;
        // Injetar script apenas uma vez
        if (typeof document !== 'undefined' && !document.getElementById('embeddedRefsScript')) {
            const s = document.createElement('script');
            s.id = 'embeddedRefsScript';
            s.src = '/refs/embedded-refs.js?v=' + Date.now();
            s.async = true;
            document.head.appendChild(s);
        }
        // Esperar até ficar disponível ou timeout
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) return true;
            await new Promise(r => setTimeout(r, 100));
        }
        return (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) ? true : false;
    } catch { return false; }
}

// Helper: buscar JSON tentando múltiplos caminhos (resiliente a diferenças local x produção)
async function fetchRefJsonWithFallback(paths) {
    let lastErr = null;
    for (const p of paths) {
        if (!p) continue;
        try {
            // 🎯 CORREÇÃO: Usar window.location.origin para garantir caminho absoluto no deploy
            const baseUrl = (typeof window !== 'undefined' && window.location) 
                ? window.location.origin 
                : '';
            
            // Se o path já é absoluto (começa com http), não adicionar origin
            const fullUrl = p.startsWith('http') ? p : `${baseUrl}${p.startsWith('/') ? '' : '/'}${p}`;
            
            // Cache-busting para evitar CDN retornar 404 ou versões antigas
            const hasQ = fullUrl.includes('?');
            const url = fullUrl + (hasQ ? '&' : '?') + 'v=' + Date.now();
            
            if (__DEBUG_ANALYZER__) console.log('[refs] tentando fetch:', url);
            
            const res = await fetch(url, {
                cache: 'no-store',
                headers: { 
                    'Cache-Control': 'no-cache', 
                    'Pragma': 'no-cache',
                    'Accept': 'application/json'
                }
            });
            
            if (res.ok) {
                // 🎯 VALIDAÇÃO: Verificar Content-Type (permissivo para servidores simples)
                const contentType = res.headers.get('content-type') || '';
                // Aceita: application/json, text/plain, text/json ou vazio (servidores dev)
                const isAcceptable = contentType.includes('json') || 
                                     contentType.includes('text/plain') || 
                                     contentType === '' ||
                                     !contentType.includes('text/html');
                if (!isAcceptable) {
                    // Não mostrar warning, apenas fazer throw silencioso para tentar próximo path
                    throw new Error(`Content-Type HTML detectado: ${contentType}`);
                }
                
                if (__DEBUG_ANALYZER__) console.log('[refs] OK:', p);
                
                // Verificar se a resposta tem conteúdo JSON válido
                const text = await res.text();
                
                // 🎯 VALIDAÇÃO CRÍTICA: Detectar HTML no lugar de JSON
                if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                    console.error('[refs] ❌ ERRO: Servidor retornou HTML ao invés de JSON em', p);
                    console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                    throw new Error(`HTML retornado ao invés de JSON em ${p}`);
                }
                
                if (text.trim()) {
                    try {
                        const json = JSON.parse(text);
                        console.log('[refs] ✅ JSON válido carregado de:', p);
                        return json;
                    } catch (jsonError) {
                        console.error('[refs] ❌ JSON inválido em', p);
                        console.error('[refs] Erro:', jsonError.message);
                        console.error('[refs] Primeiros 200 caracteres:', text.substring(0, 200));
                        throw new Error(`JSON inválido em ${p}: ${jsonError.message}`);
                    }
                } else {
                    console.warn('[refs] Resposta vazia em', p);
                    throw new Error(`Resposta vazia em ${p}`);
                }
            } else {
                if (__DEBUG_ANALYZER__) console.warn('[refs] Falha', res.status, 'em', p);
                lastErr = new Error(`HTTP ${res.status} @ ${p}`);
            }
        } catch (e) {
            if (__DEBUG_ANALYZER__) console.warn('[refs] Erro fetch', p, e?.message || e);
            lastErr = e;
        }
    }
    throw lastErr || new Error('Falha ao carregar JSON de referência (todas as rotas testadas)');
}

// 📚 Carregar manifesto de gêneros (opcional). Se ausente, manter fallback.
async function loadGenreManifest() {
    // 1) Preferir embutido em window, depois inline
    try {
        const winEmb = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.manifest) || null;
        if (winEmb && Array.isArray(winEmb.genres)) { __genreManifest = winEmb.genres; return __genreManifest; }
    } catch {}
    if (!__genreManifest && __INLINE_EMBEDDED_REFS__?.manifest?.genres?.length) {
        __genreManifest = __INLINE_EMBEDDED_REFS__.manifest.genres;
        return __genreManifest;
    }
    // 2) Se permitido, tentar rede
    if (typeof window !== 'undefined' && window.REFS_ALLOW_NETWORK === true) {
        try {
            const json = await fetchRefJsonWithFallback([
                `/refs/out/genres.json`,
                `refs/out/genres.json`,
                `./refs/out/genres.json`,
                `../refs/out/genres.json`
            ]);
            if (json && Array.isArray(json.genres)) { __genreManifest = json.genres; return __genreManifest; }
        } catch (e) { __dwrn('Manifesto via rede indisponível:', e.message || e); }
    }
    return __genreManifest || null;
}

// 🏷️ Popular o <select> com base no manifesto, mantendo fallback e preservando seleção
function populateGenreSelect(manifestGenres) {
    const sel = document.getElementById('audioRefGenreSelect');
    if (!sel) return;
    if (!Array.isArray(manifestGenres) || manifestGenres.length === 0) {
        // Nada a fazer (fallback já em HTML)
        // Ainda assim, garantir que o gênero ativo esteja presente como opção
        ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
        return;
    }
    // Salvar valor atual (se houver)
    const current = sel.value;
    // Limpar opções atuais e reconstruir
    while (sel.options.length) sel.remove(0);
    for (const g of manifestGenres) {
        if (!g || !g.key) continue;
        const opt = document.createElement('option');
        opt.value = String(g.key);
        opt.textContent = String(g.label || labelizeKey(g.key));
        sel.appendChild(opt);
    }
    // Garantir que gênero ativo via URL/localStorage esteja presente
    ensureActiveGenreOption(sel, window.PROD_AI_REF_GENRE);
    // Restaurar seleção (priorizar PROD_AI_REF_GENRE > current > primeira opção)
    const target = window.PROD_AI_REF_GENRE || current || (sel.options[0] && sel.options[0].value);
    if (target) sel.value = target;
}

// 🔤 Converter chave em rótulo amigável (ex.: "funk_mandela" → "Funk Mandela")
function labelizeKey(key) {
    if (!key) return '';
    return String(key)
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\b\w/g, c => c.toUpperCase());
}

// ✅ Garantir que a opção do gênero ativo exista no select (para casos via URL)
function ensureActiveGenreOption(selectEl, genreKey) {
    if (!selectEl || !genreKey) return;
    const exists = Array.from(selectEl.options).some(o => o.value === genreKey);
    if (!exists) {
        const opt = document.createElement('option');
        opt.value = String(genreKey);
        opt.textContent = labelizeKey(genreKey);
        selectEl.appendChild(opt);
    }
}

/**
 * 🎯 NOVA FUNÇÃO: Extrair targets de gênero do JSON
 * Formato esperado do JSON:
 * {
 *   "nome_genero": {
 *     "version": "...",
 *     "hybrid_processing": {
 *       "original_metrics": {...},
 *       "spectral_bands": {...}  ← PRIORIDADE 1
 *     },
 *     "legacy_compatibility": {
 *       "bands": {...}  ← PRIORIDADE 2
 *     },
 *     "bands": {...}  ← PRIORIDADE 3 (fallback)
 *   }
 * }
 */
function extractGenreTargets(json, genreName) {
    // 1. Identificar o root real do gênero
    let root = null;
    
    // Tentar: json[genreName]
    if (json && typeof json === 'object' && json[genreName]) {
        root = json[genreName];
    }
    // Tentar: json já é o root (quando vem de cache ou embedded)
    else if (json && typeof json === 'object' && json.version) {
        root = json;
    }
    // Tentar: primeiro objeto no JSON
    else if (json && typeof json === 'object') {
        const firstKey = Object.keys(json)[0];
        if (firstKey && json[firstKey] && typeof json[firstKey] === 'object') {
            root = json[firstKey];
        }
    }
    
    if (!root) {
        console.error('[EXTRACT-TARGETS] ❌ Root não encontrado no JSON para:', genreName);
        return null;
    }
    
    // 2. Buscar targets na ordem de prioridade
    let targets = null;
    let source = null;
    
    // 🎯 PRIORIDADE 1: legacy_compatibility.bands (FONTE OFICIAL)
    if (root.legacy_compatibility?.bands) {
        targets = root.legacy_compatibility.bands;
        source = 'legacy_compatibility.bands';
    }
    // 🎯 PRIORIDADE 2: hybrid_processing.spectral_bands (fallback)
    else if (root.hybrid_processing?.spectral_bands) {
        targets = root.hybrid_processing.spectral_bands;
        source = 'hybrid_processing.spectral_bands';
    }
    // 🎯 PRIORIDADE 3: bands (fallback genérico)
    else if (root.bands) {
        targets = root.bands;
        source = 'bands';
    }
    // 🎯 PRIORIDADE 4: hybrid_processing.original_metrics (último recurso)
    else if (root.hybrid_processing?.original_metrics) {
        targets = root.hybrid_processing.original_metrics;
        source = 'hybrid_processing.original_metrics';
    }
    
    if (!targets) {
        console.error('[EXTRACT-TARGETS] ❌ Nenhum target encontrado no JSON para:', genreName);
        return null;
    }
    
    // 3. Criar objeto de resultado completo
    const result = {
        ...root,
        targets: targets,
        targetSource: source
    };
    
    // Log silencioso - apenas em modo debug
    if (__DEBUG_ANALYZER__) {
        console.log('[EXTRACT-TARGETS] ✅', genreName, '→', source, '|', Object.keys(targets).length, 'bands');
    }
    
    return result;
}

async function loadReferenceData(genre) {
    try {
        // 🎯 ALIAS DE FETCH: Mapeia novos IDs para JSONs legados existentes
        // Isso permite buscar trance.json quando o gênero é progressive_trance
        const FETCH_ALIAS = {
            'progressive_trance': 'trance',
            'rap_drill': 'phonk',
            'edm': 'funk_automotivo',
            'fullon': 'techno'
        };
        const fetchGenre = FETCH_ALIAS[genre] || genre;
        
        // Se feature flag de invalidar cache por troca de escala/gênero estiver ativa, ignorar cache salvo
        const bypassCache = (typeof window !== 'undefined' && window.REFS_BYPASS_CACHE === true);
        if (!bypassCache && __refDataCache[genre]) {
            __activeRefData = __refDataCache[genre];
            __activeRefGenre = genre;
            
            // ✅ Log detalhado dos targets carregados do cache
            console.log('[LOAD-REF] 📦 Carregado do cache:', {
                genre: genre,
                hasTargets: !!__activeRefData?.targets,
                targetKeys: __activeRefData?.targets ? Object.keys(__activeRefData.targets) : [],
                targetSource: __activeRefData?.targetSource
            });
            
            updateRefStatus('✔ referências (cache)', '#0d6efd');
            return __activeRefData;
        }
        if (bypassCache) {
            delete __refDataCache[genre];
        }
        updateRefStatus('⏳ carregando...', '#996600');
        
        if (__DEBUG_ANALYZER__) console.log('[refs] loadReferenceData:', { genre, fetchGenre, bypassCache });
        
        // PRIORIDADE CORRIGIDA: external > embedded > fallback
        // 1) Tentar carregar JSON externo primeiro (sempre, independente de REFS_ALLOW_NETWORK)
        // Usa fetchGenre para buscar o JSON legado correto
        try {
            const version = Date.now(); // Force cache bust
            const json = await fetchRefJsonWithFallback([
                `/refs/out/${fetchGenre}.json?v=${version}`,
                `refs/out/${fetchGenre}.json?v=${version}`,
                `./refs/out/${fetchGenre}.json?v=${version}`,
                `../refs/out/${fetchGenre}.json?v=${version}`
            ]);
            
            // ✅ NOVA LÓGICA: Usar extractGenreTargets para processar JSON
            const extractedData = extractGenreTargets(json, genre);
            
            if (extractedData && typeof extractedData === 'object' && extractedData.version) {
                const enrichedNet = enrichReferenceObject(extractedData, genre);
                __refDataCache[genre] = enrichedNet;
                __activeRefData = enrichedNet;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedNet;
                window.__activeRefData = enrichedNet; // ✅ Garantir disponibilidade global
                
                // Log silencioso - apenas em modo debug
                if (__DEBUG_ANALYZER__) {
                    console.log('[refs] ✅ Carregado (external):', genre, '→', extractedData.version);
                }
                
                updateRefStatus('✔ referências aplicadas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedNet;
            }
        } catch (netError) {
            // Silencioso: fallback para embedded é comportamento normal em dev
            if (__DEBUG_ANALYZER__) {
                console.log('[refs] External fetch não disponível, usando embedded...');
            }
            
            // 🔥 CORREÇÃO LOOP INFINITO: Forçar refsReady se refs internas já carregaram
            if (!window.refsReady && window.embeddedRefsLoaded) {
                window.refsReady = true;
            }
        }
        
        // 2) Fallback para referências embutidas (embedded)
        // Usar fetchGenre (alias) para buscar nos dados embedded também
        const embWin = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre && window.__EMBEDDED_REFS__.byGenre[fetchGenre]) || null;
        const embInline = __INLINE_EMBEDDED_REFS__?.byGenre?.[fetchGenre] || null;
        const useData = embWin || embInline;
        if (useData && typeof useData === 'object') {
            // ✅ NOVA LÓGICA: Extrair targets corretamente (passa fetchGenre para encontrar a chave)
            const extractedData = extractGenreTargets(useData, fetchGenre);
            
            if (extractedData) {
                const enriched = enrichReferenceObject(structuredClone(extractedData), genre);
                __refDataCache[genre] = enriched;
                __activeRefData = enriched;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enriched;
                window.__activeRefData = enriched; // ✅ Garantir disponibilidade global
                
                // Log silencioso - apenas em modo debug
                if (__DEBUG_ANALYZER__) {
                    console.log('[refs] ✅ Carregado (embedded):', genre, '→', extractedData.version || 'inline');
                }
                
                updateRefStatus('✔ referências embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enriched;
            }
        }
        
        // 3) Legacy path REFS_ALLOW_NETWORK removido - não mais necessário
        // O sistema agora usa fetch externo → embedded → fallback
        
        // 4) Último recurso: trance inline (fallback)
        const fallback = __INLINE_EMBEDDED_REFS__?.byGenre?.trance;
        if (fallback) {
            const enrichedFb = enrichReferenceObject(structuredClone(fallback), 'trance');
            __refDataCache['trance'] = enrichedFb;
            __activeRefData = enrichedFb;
            __activeRefGenre = 'trance';
            window.PROD_AI_REF_DATA = enrichedFb;
            
            // Log apenas em debug
            if (__DEBUG_ANALYZER__) {
                console.log('[refs] ⚠️ Usando fallback trance para:', genre);
            }
            
            updateRefStatus('✔ referências embutidas (fallback)', '#0d6efd');
            try { buildAggregatedRefStats(); } catch {}
            return enrichedFb;
        }
        throw new Error('Sem referências disponíveis');
    } catch (e) {
        console.warn('Falha ao carregar referências', genre, e);
        // Fallback: tentar EMBEDDED
        try {
            const embMap = (typeof window !== 'undefined' && window.__EMBEDDED_REFS__ && window.__EMBEDDED_REFS__.byGenre) || __INLINE_EMBEDDED_REFS__.byGenre || {};
            const emb = embMap[genre];
            if (emb && typeof emb === 'object') {
                const enrichedEmb = enrichReferenceObject(structuredClone(emb), genre);
                __refDataCache[genre] = enrichedEmb;
                __activeRefData = enrichedEmb;
                __activeRefGenre = genre;
                window.PROD_AI_REF_DATA = enrichedEmb;
                updateRefStatus('✔ referências embutidas', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmb;
            }
            // Se o gênero específico não existir, usar um padrão seguro (trance) se disponível
            if (embMap && embMap.trance) {
                const enrichedEmbTr = enrichReferenceObject(structuredClone(embMap.trance), 'trance');
                __refDataCache['trance'] = enrichedEmbTr;
                __activeRefData = enrichedEmbTr;
                __activeRefGenre = 'trance';
                window.PROD_AI_REF_DATA = enrichedEmbTr;
                updateRefStatus('✔ referências embutidas (fallback)', '#0d6efd');
                try { buildAggregatedRefStats(); } catch {}
                return enrichedEmbTr;
            }
        } catch(_) {}
        updateRefStatus('⚠ falha refs', '#992222');
        return null;
    }
}

function updateRefStatus(text, color) {
    const el = document.getElementById('audioRefStatus');
    if (el) { el.textContent = text; el.style.background = color || '#1f2b40'; }
}

/**
 * 🔒 FUNÇÃO DE PRESERVAÇÃO DE GÊNERO
 * Garante que o gênero selecionado NUNCA seja perdido em resets
 */
function preserveGenreState(sourceAnalysis = null) {
    console.log('[PRESERVE-GENRE] 🔒 Preservando estado do gênero');
    
    // 🎯 CORREÇÃO CRÍTICA: Se foi passada uma análise, extrair targets dela primeiro
    if (sourceAnalysis) {
        console.log('[PRESERVE-GENRE] 🎯 Análise fornecida - extraindo genre e targets (FONTE OFICIAL)');
        
        const extractedGenre = extractGenreFromAnalysis(sourceAnalysis);
        const extractedTargets = extractGenreTargetsFromAnalysis(sourceAnalysis);
        
        if (extractedGenre) {
            window.__CURRENT_SELECTED_GENRE = extractedGenre;
            window.PROD_AI_REF_GENRE = extractedGenre;
            console.log('[PRESERVE-GENRE] ✅ Gênero extraído de analysis.data.genre:', extractedGenre);
        }
        
        if (extractedTargets) {
            window.__CURRENT_GENRE_TARGETS = extractedTargets;
            window.currentGenreTargets = extractedTargets;
            console.log('[PRESERVE-GENRE] ✅ Targets extraídos de analysis.data.genreTargets:', Object.keys(extractedTargets));
        }
        
        // Se conseguiu extrair ambos, retornar
        if (extractedGenre && extractedTargets) {
            return;
        }
    }
    
    // Se __CURRENT_SELECTED_GENRE já existe, não precisa restaurar
    if (window.__CURRENT_SELECTED_GENRE) {
        console.log('[PRESERVE-GENRE] ✅ __CURRENT_SELECTED_GENRE já existe:', window.__CURRENT_SELECTED_GENRE);
        return;
    }

    // Se o CURRENT não existir, restaurar do refGenre
    if (window.PROD_AI_REF_GENRE) {
        window.__CURRENT_SELECTED_GENRE = window.PROD_AI_REF_GENRE;
        console.log('[PRESERVE-GENRE] ✅ __CURRENT_SELECTED_GENRE restaurado de PROD_AI_REF_GENRE:', window.PROD_AI_REF_GENRE);
    }

    // Reatribuir targets
    if (window.__CURRENT_GENRE_TARGETS) {
        window.currentGenreTargets = window.__CURRENT_GENRE_TARGETS;
        console.log('[PRESERVE-GENRE] ✅ currentGenreTargets restaurado de __CURRENT_GENRE_TARGETS');
    }
}

function applyGenreSelection(genre) {
    if (!genre) return Promise.resolve();
    window.PROD_AI_REF_GENRE = genre;
    localStorage.setItem('prodai_ref_genre', genre);
    // Invalidação de cache opcional
    if (typeof window !== 'undefined' && window.INVALIDATE_REF_CACHE_ON_GENRE_CHANGE === true) {
        try { delete __refDataCache[genre]; } catch {}
        invalidateReferenceDerivedCaches();
    }
    
    // 🎯 FORÇAR invalidação para garantir nova referência
    try { 
        delete __refDataCache[genre]; 
        invalidateReferenceDerivedCaches();
        console.log('✅ Cache invalidado para gênero:', genre);
    } catch(e) { console.warn('⚠️ Falha na invalidação:', e); }
    
    // Carregar refs e, se já houver análise no modal, atualizar sugestões de referência e re-renderizar
    return loadReferenceData(genre).then(() => {
        // 🔒 PATCH: Salvar gênero e targets em TODAS as variáveis globais
        window.__CURRENT_SELECTED_GENRE = genre;
        window.PROD_AI_REF_GENRE = genre;
        
        // Extrair targets do __activeRefData carregado
        if (window.__activeRefData?.targets) {
            window.__CURRENT_GENRE_TARGETS = window.__activeRefData.targets;
            window.currentGenreTargets = window.__activeRefData.targets;
            console.log('[APPLY-GENRE] ✅ Gênero e targets salvos:', {
                genre: genre,
                hasTargets: true,
                targetKeys: Object.keys(window.__activeRefData.targets)
            });
        } else {
            console.warn('[APPLY-GENRE] ⚠️ Targets não encontrados em __activeRefData');
        }
        
        try {
            if (typeof currentModalAnalysis === 'object' && currentModalAnalysis) {
                // 🎯 NOVO: Recalcular score com nova referência
                try {
                    if (typeof window !== 'undefined' && window.computeMixScore && __refData) {
                        // 🎯 CORREÇÃO: Passar mode para garantir que gates V3 usem o limite correto
                        const mode = window.__SOUNDY_ANALYSIS_MODE__ || 'streaming';
                        const scoreResult = window.computeMixScore(currentModalAnalysis.technicalData, __refData, { mode });
                        currentModalAnalysis.qualityOverall = scoreResult?.scorePct ?? scoreResult;
                        console.log('✅ Score recalculado para novo gênero:', currentModalAnalysis.qualityOverall);
                    }
                } catch(e) { console.warn('❌ Falha ao recalcular score:', e); }
                
                // Recalcular sugestões reference_* com as novas tolerâncias
                try { updateReferenceSuggestions(currentModalAnalysis); } catch(e) { console.warn('updateReferenceSuggestions falhou', e); }
                // Re-renderização completa para refletir sugestões e comparações
                try { 
                    // 🔒 UI GATE: Verificar se análise ainda é válida
                    const analysisRunId = currentModalAnalysis?.runId || currentModalAnalysis?.metadata?.runId;
                    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
                    
                    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                        console.warn(`🚫 [UI_GATE] Re-render cancelado - análise obsoleta (análise: ${analysisRunId}, atual: ${currentRunId})`);
                        return;
                    }
                    
                    displayModalResults(currentModalAnalysis); 
                } catch(e) { console.warn('re-render modal falhou', e); }
            }
        } catch (e) { console.warn('re-render comparação falhou', e); }
    });
}
// Expor global
if (typeof window !== 'undefined') {
    window.applyGenreSelection = applyGenreSelection;
}

// Health check utilitário (Etapa 2) – avalia estabilidade das métricas em múltiplos runs
if (typeof window !== 'undefined' && !window.__audioHealthCheck) {
    window.__audioHealthCheck = async function(file, opts = {}) {
        const runs = opts.runs || 3;
        const delayMs = opts.delayMs || 0;
        const out = { runs: [], spreads: {}, anomalies: [] };
        for (let i=0;i<runs;i++) {
            const t0 = performance.now();
            // 🆔 CORREÇÃO: Adicionar runId para funções de health check
            const healthOptions = prepareAnalysisOptions({}, `health_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, healthOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufsIntegrated: res?.technicalData?.lufsIntegrated,
                truePeakDbtp: res?.technicalData?.truePeakDbtp,
                dynamicRange: res?.technicalData?.dynamicRange,
                lra: res?.technicalData?.lra,
                stereoCorrelation: res?.technicalData?.stereoCorrelation,
                processingMs: (res?.processingMs ?? (t1 - t0))
            });
            if (delayMs) await new Promise(r=>setTimeout(r, delayMs));
        }
        const collect = (key) => out.runs.map(r=>r[key]).filter(v=>Number.isFinite(v));
        const stats = (arr) => arr.length?{min:Math.min(...arr),max:Math.max(...arr),spread:Math.max(...arr)-Math.min(...arr)}:null;
        ['lufsIntegrated','truePeakDbtp','dynamicRange','lra','stereoCorrelation','processingMs'].forEach(k=>{
            out.spreads[k] = stats(collect(k));
        });
        // Anomalias agrupadas (do logger central)
        try { out.anomalies = (window.__METRIC_ANOMALIES__||[]).slice(-100); } catch {}
        return out;
    };
}

// ================== ACCEPTANCE TEST HARNESS (Etapa 3) ==================
// ⚠️ REMOVIDO: Testes que dependem de Web Audio API
// TODO: Implementar testes baseados em análise remota se necessário

if (typeof window !== 'undefined' && !window.__runAcceptanceAudioTests) {
    window.__runAcceptanceAudioTests = async function(opts = {}) {
        console.warn('⚠️ Testes de aceitação de áudio foram removidos devido à migração para análise remota');
        return { 
            skipped: true, 
            reason: 'Web Audio API removida - usar testes de backend' 
        };
    };
}

// Inicializar quando DOM carregar
document.addEventListener('DOMContentLoaded', function() {
    initializeAudioAnalyzerIntegration();
});


function initializeAudioAnalyzerIntegration() {
    if (__audioIntegrationInitialized) {
        __dbg('ℹ️ Integração do Audio Analyzer já inicializada. Ignorando chamada duplicada.');
        return;
    }
    __audioIntegrationInitialized = true;
    __dbg('🎵 Inicializando integração do Audio Analyzer...');
    // Habilitar flag de referência por gênero via parâmetro de URL (ex.: ?refgenre=trance)
    try {
        if (typeof window !== 'undefined') {
            const params = new URLSearchParams(window.location.search);
            const rg = params.get('refgenre');
            if (rg && !window.PROD_AI_REF_GENRE) {
                window.PROD_AI_REF_GENRE = String(rg).trim().toLowerCase();
                __dbg(`[REF-GÊNERO] Ativado via URL: ${window.PROD_AI_REF_GENRE}`);
            }
            // Flags de controle por URL (não alteram CSS)
            if (params.has('surgical')) {
                const v = params.get('surgical');
                window.USE_SURGICAL_EQ = !(v === '0' || v === 'false');
                __dbg(`[FLAG] USE_SURGICAL_EQ = ${window.USE_SURGICAL_EQ}`);
            }
            if (params.has('useLog')) {
                const v = params.get('useLog');
                window.USE_LOG_BAND_ENERGIES = (v === '1' || v === 'true');
                __dbg(`[FLAG] USE_LOG_BAND_ENERGIES = ${window.USE_LOG_BAND_ENERGIES}`);
            }
            if (params.has('adv')) {
                const v = params.get('adv');
                const on = !(v === '0' || v === 'false');
                window.USE_ADVANCED_METRICS = on;
                window.USE_ADVANCED_LOUDNESS = on;
                window.USE_ADVANCED_TRUEPEAK = on;
                window.USE_ADVANCED_SPECTRUM = on;
                __dbg(`[FLAG] ADVANCED = ${on}`);
            }
            if (params.has('debug')) {
                const v = params.get('debug');
                window.DEBUG_ANALYZER = (v === '1' || v === 'true');
                __dbg(`[FLAG] DEBUG_ANALYZER = ${window.DEBUG_ANALYZER}`);
            }
            // Preferir métricas avançadas (ITU/oversampling) quando disponíveis, sem sobrescrever configs do usuário
            if (typeof window.PREFER_ADVANCED_METRICS === 'undefined') {
                window.PREFER_ADVANCED_METRICS = true;
                __dbg('[FLAG] PREFER_ADVANCED_METRICS = true (auto)');
            }
        }
    } catch (_) { /* noop */ }
    
    // Restaurar gênero salvo
    try {
        const saved = localStorage.getItem('prodai_ref_genre');
        if (!window.PROD_AI_REF_GENRE && saved) window.PROD_AI_REF_GENRE = saved;
    } catch {}

    const genreSelect = document.getElementById('audioRefGenreSelect');
    if (genreSelect) {
        // Popular dinamicamente a partir do manifesto, mantendo fallback
        loadGenreManifest().then(() => {
            populateGenreSelect(__genreManifest);
            // Listener de mudança (garantir apenas um)
            genreSelect.onchange = () => applyGenreSelection(genreSelect.value);
            // Aplicar seleção atual
            const selected = genreSelect.value || window.PROD_AI_REF_GENRE;
            applyGenreSelection(selected);
        });
    }

    // Botão de análise de música (novo design)
    const musicAnalysisBtn = document.getElementById('musicAnalysisBtn');
    if (musicAnalysisBtn) {
        musicAnalysisBtn.addEventListener('click', openAudioModal);
        __dbg('✅ Botão de Análise de Música configurado');
    }
    
    // Modal de áudio
    setupAudioModal();
    
    __dbg('🎵 Audio Analyzer Integration carregada com sucesso!');
    
    // 🧠 Aguarda refs e cache ficarem prontos antes de liberar o ForceActivator
    function waitForRefsAndCacheBeforeReady() {
        const checkReady = () => {
            const ready = !!(window.audioAnalyzer && window.CACHE_CTX_AWARE_V1_API && window.refsReady);
            console.log("⏳ [READY-CHECK] Estado atual:", {
                audioAnalyzer: !!window.audioAnalyzer,
                CACHE_CTX_AWARE_V1_API: !!window.CACHE_CTX_AWARE_V1_API,
                refsReady: !!window.refsReady
            });
            if (ready) {
                console.log("✅ [GLOBAL] Todos os sistemas prontos. Disparando analysisReady...");
                const evt = new Event("analysisReady");
                document.dispatchEvent(evt);
                return true;
            }
            return false;
        };

        if (!checkReady()) {
            const interval = setInterval(() => {
                if (checkReady()) clearInterval(interval);
            }, 300);
        }
    }

    // 🔥 Chamar a função de espera no ponto onde estava o dispatch antigo:
    waitForRefsAndCacheBeforeReady();

    // Aplicar estilos aprimorados ao seletor de gênero
    try { injectRefGenreStyles(); } catch(e) { /* silencioso */ }
    
    // 🆕 Inicializar Modal de Gênero Musical
    try { initGenreModal(); } catch(e) { console.warn('Falha ao inicializar modal de gênero:', e); }
}

// ============================================================================
// � MODAL DE BOAS-VINDAS À ANÁLISE - NOVO SISTEMA
// ============================================================================

/**
 * 🌟 Abrir modal de boas-vindas
 * Modal inicial que apresenta o sistema e direciona para o guia técnico
 */
function openWelcomeModal() {
    __dbg('🎉 Abrindo modal de boas-vindas à análise...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) {
        console.error('❌ Modal de boas-vindas não encontrado no DOM');
        return;
    }
    
    // Bloquear scroll do body
    document.body.classList.add('modal-open');
    
    // Abrir modal com animação
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    
    // Foco no modal para acessibilidade
    requestAnimationFrame(() => {
        modal.focus();
        
        // Foco no primeiro botão
        const firstBtn = modal.querySelector('.welcome-btn.primary');
        if (firstBtn) {
            firstBtn.focus();
        }
    });
    
    __dbg('✅ Modal de boas-vindas aberto com sucesso');
}

/**
 * ❌ Fechar modal de boas-vindas
 */
function closeWelcomeModal() {
    __dbg('❌ Fechando modal de boas-vindas...');
    
    const modal = document.getElementById('welcomeAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        
        // Desbloquear scroll do body
        document.body.classList.remove('modal-open');
    }
    
    __dbg('✅ Modal de boas-vindas fechado');
}

/**
 * 📖 Abrir guia técnico em nova aba
 */
function openTechnicalGuide() {
    __dbg('📖 Abrindo guia técnico de análise...');
    
    // Abrir guia na mesma pasta (public/)
    window.open('guia-tecnico-analise.html', '_blank', 'noopener,noreferrer');
    
    // Não fecha o modal - usuário pode ler o guia e voltar
    __dbg('✅ Guia técnico aberto em nova aba');
}

/**
 * ▶️ Prosseguir para análise (fechar modal de boas-vindas e continuar fluxo)
 */
function proceedToAnalysis() {
    __dbg('▶️ Prosseguindo para análise...');
    
    // Fechar modal de boas-vindas
    closeWelcomeModal();
    
    // Continuar com o fluxo original
    const isReferenceEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
    
    if (isReferenceEnabled) {
        // Abrir modal de seleção de modo
        openModeSelectionModal();
    } else {
        // Ir direto para modo gênero
        selectAnalysisMode('genre');
    }
    
    __dbg('✅ Fluxo de análise continuado');
}

// Expor funções globalmente para uso nos onclick do HTML
window.openWelcomeModal = openWelcomeModal;
window.closeWelcomeModal = closeWelcomeModal;
window.openTechnicalGuide = openTechnicalGuide;
window.proceedToAnalysis = proceedToAnalysis;

// 🎧 BETA DJS: Funções para controlar modal de encerramento
function openBetaExpiredModal() {
    const modal = document.getElementById('betaDjExpiredModal');
    if (!modal) {
        console.error('❌ Modal betaDjExpiredModal não encontrado');
        return;
    }
    
    console.log('🎧 [BETA-DJ] Abrindo modal de encerramento do beta');
    modal.style.display = 'flex';
    
    // Salvar preferência no localStorage para não exibir novamente na mesma sessão
    sessionStorage.setItem('betaDjModalShown', 'true');
}

function closeBetaExpiredModal() {
    const modal = document.getElementById('betaDjExpiredModal');
    if (modal) {
        modal.style.display = 'none';
        console.log('🎧 [BETA-DJ] Modal de encerramento fechado');
    }
}

window.openBetaExpiredModal = openBetaExpiredModal;
window.closeBetaExpiredModal = closeBetaExpiredModal;

/**
 * ⌨️ Configurar acessibilidade do modal de boas-vindas
 */
function setupWelcomeModalAccessibility() {
    const modal = document.getElementById('welcomeAnalysisModal');
    if (!modal) return;
    
    // ESC para fechar
    document.addEventListener('keydown', function handleWelcomeEscape(e) {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeWelcomeModal();
        }
    });
    
    // Tab navigation (trap focus)
    modal.addEventListener('keydown', function handleWelcomeTabNav(e) {
        if (e.key !== 'Tab') return;
        
        const focusableElements = modal.querySelectorAll(
            'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        
        if (focusableElements.length === 0) return;
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        if (e.shiftKey && document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
        }
    });
    
    __dbg('⌨️ Acessibilidade do modal de boas-vindas configurada');
}

// Inicializar acessibilidade quando DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupWelcomeModalAccessibility);
} else {
    setupWelcomeModalAccessibility();
}

// ============================================================================

// 🎵 Abrir modal de análise de áudio (MODIFICADO para usar novo fluxo)
function openAudioModal() {
    window.logReferenceEvent('open_modal_requested');
    
    // 🌟 NOVO: Abrir modal de boas-vindas PRIMEIRO
    openWelcomeModal();
}

// 🎯 NOVO: Abrir modal secundário para upload da música de referência
function openReferenceUploadModal(referenceJobId, firstAnalysisResult) {
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔐 FAIL-SAFE: Bloqueio de entitlement no modal de referência
    // ═══════════════════════════════════════════════════════════════════════════════
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        console.log(`🔐 [ENTITLEMENT FAIL-SAFE] Modal de referência BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    
    __dbg('🎯 Abrindo modal secundário para música de referência', { referenceJobId });
    
    // 🔍 PR1: Log tentativa de abrir modal
    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
    if (window.logStep) {
        window.logStep(traceId, 'OPEN_SECOND_MODAL_ATTEMPT', {
            referenceJobId,
            userExplicitlySelectedReferenceMode,
            currentMode: window.currentAnalysisMode,
        });
    }
    
    // 🎯 PROTEÇÃO: Garantir que primeira análise está completa
    if (!firstAnalysisResult) {
        console.error('❌ [PROTECTION] Primeira análise não está completa - abortando abertura do modal de referência');
        alert('⚠️ A primeira análise ainda não foi concluída. Por favor, aguarde.');
        return;
    }
    
    // 🎯 PROTEÇÃO: Validar que há dados essenciais
    if (!firstAnalysisResult.technicalData) {
        console.error('❌ [PROTECTION] Primeira análise não contém technicalData - dados incompletos');
        alert('⚠️ A primeira análise não foi concluída corretamente. Por favor, tente novamente.');
        return;
    }
    
    console.log('✅ [PROTECTION] Primeira análise validada com sucesso:', {
        hasJobId: !!referenceJobId,
        hasTechnicalData: !!firstAnalysisResult.technicalData,
        hasScore: !!firstAnalysisResult.score
    });
    
    window.logReferenceEvent('reference_upload_modal_opened', { referenceJobId });
    
    // 🎯 PERSISTIR DADOS DA PRIMEIRA FAIXA
    window.__REFERENCE_JOB_ID__ = referenceJobId;
    
    // � HARD-GUARD: Salvar primeira análise no FirstAnalysisStore (IMUTÁVEL)
    console.log('[FirstAnalysisStore] 🔒 Salvando primeira análise no store imutável...');
    
    // ✅ USAR NOVA API: FirstAnalysisStore.set() - clonagem interna
    FirstAnalysisStore.set(firstAnalysisResult);
    
    // ❌ REMOVER: Não usar mais window.referenceAnalysisData / window.__FIRST_ANALYSIS_RESULT__
    // A ÚNICA fonte de verdade é FirstAnalysisStore
    
    window.lastReferenceJobId = referenceJobId;
    
    console.log('✅ [COMPARE-MODE] Primeira faixa salva:', {
        jobId: referenceJobId,
        score: firstAnalysisResult?.score,
        lufs: firstAnalysisResult?.technicalData?.lufsIntegrated,
        storeProtected: FirstAnalysisStore.has()
    });
    
    // 🔥 FIX-REFERENCE: NÃO chamar reset completo - apenas limpar UI visualmente
    // closeAudioModal();   // ❌ REMOVIDO - deletava __REFERENCE_JOB_ID__
    // resetModalState();   // ❌ REMOVIDO - deletava __REFERENCE_JOB_ID__

    // Resetar apenas UI (sem limpar flags globais)
    const uploadAreaFirst = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');

    if (uploadAreaFirst) uploadAreaFirst.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';

    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';

    console.log('[FIX-REFERENCE] Modal reaberto SEM limpar flags de referência');
    
    // 🔍 AUDIT: Dump antes do guard de state machine
    const stateMachine = getSafeStateMachine();
    
    if (window.debugDump) window.debugDump('BEFORE_GUARD_STATE_MACHINE', { 
        stateMachineAvailable: !!stateMachine,
        isAwaitingSecondTrack: stateMachine?.isAwaitingSecondTrack(),
        stateMachineState: stateMachine?.getState()
    });
    
    // 🆕 PR2: GUARD USANDO STATE MACHINE
    if (stateMachine && !stateMachine.isAwaitingSecondTrack()) {
        console.error('%c[PR2-GUARD] ❌ BLOQUEIO: State machine não está aguardando segunda track', 'color:#FF0000;font-weight:bold;font-size:14px;');
        console.error('[PR2-GUARD] Estado atual:', stateMachine.getState());
        
        // 🔍 PR1: Log guard blocked
        if (window.logStep) {
            window.logStep(traceId, 'GUARD_BLOCKED', {
                guard: 'isAwaitingSecondTrack',
                value: false,
                reason: 'State machine not awaiting second track',
                stateMachineState: stateMachine.getState(),
                stack: new Error().stack,
            });
        }
        
        alert('⚠️ ERRO: Estado inválido - não é possível enviar segunda música.');
        return;
    }
    
    // 🛡️ PROTEÇÃO CRÍTICA: Não permitir ativação de modo reference se usuário não selecionou explicitamente
    // 🆕 FIX: Sincronizar com state machine que é fonte de verdade
    const stateMachineExplicit = stateMachine?.isUserExplicitlySelected?.() || false;
    const hasContext = hasActiveReferenceContext();
    const isExplicitlySelected = userExplicitlySelectedReferenceMode || stateMachineExplicit || hasContext;
    
    console.log('[REF-GUARD] openReferenceUploadModal:', {
      userExplicit: userExplicitlySelectedReferenceMode,
      stateMachineExplicit,
      hasContext,
      allowed: isExplicitlySelected
    });
    
    if (!isExplicitlySelected) {
        // 🔍 PR1: Log guard blocked
        if (window.logStep) {
            window.logStep(traceId, 'GUARD_BLOCKED', {
                guard: 'userExplicitlySelectedReferenceMode',
                legacyFlag: userExplicitlySelectedReferenceMode,
                stateMachineFlag: stateMachineExplicit,
                reason: 'User did not explicitly select reference mode',
                currentMode: window.currentAnalysisMode,
                referenceJobId: referenceJobId,
                stack: new Error().stack,
            });
        }
        
        console.error('%c[PROTECTION] ❌ BLOQUEIO ATIVADO: openReferenceUploadModal chamado mas flags de explicit = false', 'color:#FF0000;font-weight:bold;font-size:14px;');
        console.error('[PROTECTION] ❌ Legacy flag:', userExplicitlySelectedReferenceMode);
        console.error('[PROTECTION] ❌ StateMachine flag:', stateMachineExplicit);
        console.trace('[PROTECTION] Stack trace do bloqueio:');
        
        // 🔍 PR1: Assert invariante violada
        if (window.assertInvariant) {
            window.assertInvariant(
                'OPEN_MODAL_REQUIRES_EXPLICIT_FLAG',
                false, // sempre falha aqui (proposital para log)
                {
                    userExplicitlySelectedReferenceMode,
                    stateMachineExplicit,
                    referenceJobId,
                    currentMode: window.currentAnalysisMode,
                }
            );
        }
        
        alert('⚠️ ERRO: Sistema tentou ativar modo A/B automaticamente. Por favor, selecione o modo A/B explicitamente.');
        return;
    }
    
    console.log('[REF_FIX] ✅ Flag explicit verificada - abrindo modal para 2ª música');
    
    // 🎯 CORREÇÃO: Manter modo 'reference' para segunda música também
    // O backend identifica que é comparação pela presença do referenceJobId
    currentAnalysisMode = 'reference';
    console.log('%c[PROTECTION] ✅ currentAnalysisMode definido como reference - flag verificada', 'color:#00FF88;font-weight:bold;');
    
    // Abrir modal novamente
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('❌ Modal de análise de áudio não encontrado');
        return;
    }
    
    // Atualizar título e instruções do modal
    const modalTitle = document.getElementById('audioModalTitle');
    const modalSubtitle = document.getElementById('audioModalSubtitle');
    
    if (modalTitle) {
        modalTitle.innerHTML = '🎯 Upload da Música de Referência';
    }
    
    if (modalSubtitle) {
        modalSubtitle.innerHTML = '<span id="audioModeIndicator">Etapa 2/2: Envie a música de referência para comparação</span>';
        modalSubtitle.style.display = 'block';
    }
    
    // Atualizar mensagem na área de upload
    const uploadAreaSecond = document.getElementById('audioUploadArea');
    if (uploadAreaSecond) {
        const uploadContent = uploadAreaSecond.querySelector('.upload-content h4');
        if (uploadContent) {
            uploadContent.textContent = 'Enviar música de referência';
        }
        
        const uploadDescription = uploadAreaSecond.querySelector('.upload-content p');
        if (uploadDescription) {
            uploadDescription.textContent = 'Arraste a música de referência aqui ou clique para selecionar';
        }
    }
    
    // Mostrar modal
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    
    // 🎯 TRANSIÇÃO DE ESTADO: Modal 2 ABERTO → REF_B_WAIT_UPLOAD
    console.log('%c[REF-FLOW] 🎯 TRANSIÇÃO: Modal 2 ABERTO → REF_B_WAIT_UPLOAD', 'color:#00FF88;font-weight:bold;font-size:14px;');
    console.log('[REF-FLOW] Estado atual:', {
        stage: 'REF_B_WAIT_UPLOAD',
        modal2Open: true,
        awaitingSecondUpload: true,
        referenceJobId: referenceJobId,
        currentMode: window.currentAnalysisMode
    });
    
    __dbg('✅ Modal secundário de referência aberto');
}

// 🎯 NOVO: Modal de Seleção de Modo
function openModeSelectionModal() {
    __dbg('🎯 Abrindo modal de seleção de modo...');
    
    // 🔓 MODO ANÔNIMO: Verificar limite de análises
    if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
        if (!window.SoundyAnonymous.interceptAnalysis()) {
            console.log('🚫 [ANALYZER] Análise bloqueada - limite anônimo atingido');
            return;
        }
    }
    
    const modal = document.getElementById('analysisModeModal');
    if (!modal) {
        console.error('Modal de seleção de modo não encontrado');
        return;
    }
    
    // Verificar se modo referência está habilitado e mostrar/esconder botão
    const referenceModeBtn = document.getElementById('referenceModeBtn');
    if (referenceModeBtn) {
        const isEnabled = window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED;
        referenceModeBtn.style.display = isEnabled ? 'flex' : 'none';
        
        if (!isEnabled) {
            referenceModeBtn.disabled = true;
        }
    }
    
    modal.style.display = 'flex';
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('mode_selection_modal_opened');
}

function closeModeSelectionModal() {
    __dbg('❌ Fechando modal de seleção de modo...');
    
    const modal = document.getElementById('analysisModeModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    window.logReferenceEvent('mode_selection_modal_closed');
}

// 🎯 NOVO: Selecionar modo de análise
function selectAnalysisMode(mode) {
    window.logReferenceEvent('analysis_mode_selected', { mode });
    
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔐 ENTITLEMENT GATE: Bloquear MODO REFERÊNCIA para FREE/PLUS IMEDIATAMENTE
    // ═══════════════════════════════════════════════════════════════════════════════
    if (mode === 'reference') {
        const { shouldBlock, plan } = checkReferenceEntitlementSync();
        
        if (shouldBlock) {
            console.log(`🔐 [ENTITLEMENT] Modo Referência BLOQUEADO (plan=${plan})`);
            
            if (window.EntitlementsHandler?.showUpgradeModal) {
                window.EntitlementsHandler.showUpgradeModal('reference', plan);
            } else {
                alert('O Modo Referência está disponível apenas no plano PRO. Faça upgrade!');
            }
            return; // PARAR - não continuar
        }
        
        console.log('🔐 [ENTITLEMENT] Modo Referência PERMITIDO - plano PRO confirmado');
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    
    if (mode === 'reference' && !window.FEATURE_FLAGS?.REFERENCE_MODE_ENABLED) {
        alert('Modo de análise por referência não está disponível no momento.');
        return;
    }
    
    currentAnalysisMode = mode;
    
    // Fechar modal de seleção de modo
    closeModeSelectionModal();
    
    if (mode === 'genre') {
        // 🆕 STREAMING MODE: Abrir modal de destino ANTES do modal de gênero
        openSoundDestinationModal((destinationMode) => {
            console.log('[SELECT-MODE] Destino escolhido:', destinationMode);
            // Modo tradicional - abrir modal de análise normal
            openAnalysisModalForMode('genre');
        });
    } else if (mode === 'reference') {
        // Modo referência - abrir interface específica (sem modal de destino)
        setSoundDestinationMode('pista'); // Reset para default
        openAnalysisModalForMode('reference');
    } else {
        // Fallback para outros modos
        openAnalysisModalForMode(mode);
    }
}

// � NOVO MODAL DE GÊNERO MUSICAL - Sistema completo
// Feature flag para controlar ativação
window.FEATURE_NEW_GENRE_MODAL = true; // Definir como false para usar seletor antigo

// ═══════════════════════════════════════════════════════════════════════════════
// 🎯 MODAL DE DESTINO DO SOM (PISTA vs STREAMING)
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * @type {'pista' | 'streaming'}
 * @description Modo de destino do som - NUNCA deve ser undefined
 * @default 'pista'
 */
window.__SOUNDY_ANALYSIS_MODE__ = 'pista';

/**
 * 🆕 STREAMING TARGETS FIXOS
 */
const STREAMING_TARGETS = {
    lufs_target: -14,
    true_peak_target: -1.0
};

/**
 * 🆕 Aplica override de streaming nos targets (FRONTEND)
 * IMPORTANTE: Preserva TODAS as outras propriedades (DR, Stereo, Bands, etc)
 * Só altera LUFS e True Peak
 * @param {Object} targets - Targets originais
 * @returns {Object} - Targets com override se streaming
 */
function applyStreamingOverride(targets) {
    const mode = getSoundDestinationMode();
    if (mode !== 'streaming') return targets;
    
    if (!targets || typeof targets !== 'object') {
        console.log('[STREAMING] Criando targets minimos');
        return { lufs_target: -14, true_peak_target: -1.0 };
    }
    
    // Deep copy para preservar objetos aninhados (bands, etc)
    const result = JSON.parse(JSON.stringify(targets));
    
    // Apenas sobrescrever LUFS e True Peak
    result.lufs_target = -14;
    result.true_peak_target = -1.0;
    
    console.log('[STREAMING] Override aplicado: LUFS=-14, TP=-1.0');
    console.log('[STREAMING] Propriedades preservadas:', Object.keys(result));
    return result;
}

/**
 * Getter seguro para analysisMode (sempre retorna valor válido)
 */
function getSoundDestinationMode() {
    const mode = window.__SOUNDY_ANALYSIS_MODE__;
    if (mode !== 'pista' && mode !== 'streaming') {
        console.warn('[DEST-MODE] ⚠️ Modo inválido detectado, resetando para "pista"');
        window.__SOUNDY_ANALYSIS_MODE__ = 'pista';
        return 'pista';
    }
    return mode;
}

/**
 * Setter seguro para analysisMode
 * @param {'pista' | 'streaming'} mode
 */
function setSoundDestinationMode(mode) {
    if (mode !== 'pista' && mode !== 'streaming') {
        console.error('[DEST-MODE] ❌ Tentativa de setar modo inválido:', mode);
        return false;
    }
    window.__SOUNDY_ANALYSIS_MODE__ = mode;
    console.log(`[DEST-MODE] ✅ Modo definido: ${mode}`);
    return true;
}

/**
 * Injetar estilos do modal de destino
 */
function injectDestinationModalStyles() {
    if (document.getElementById('destination-modal-styles')) return;
    
    const styles = document.createElement('style');
    styles.id = 'destination-modal-styles';
    styles.textContent = `
        /* 🎯 Modal de Destino do Som - Glassmorphism Premium */
        #soundDestinationModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            z-index: 10001;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #soundDestinationModal.active {
            display: flex;
            opacity: 1;
        }
        
        .destination-modal-container {
            max-width: 800px;
            width: 90%;
            background: radial-gradient(
                circle at 20% 20%, 
                rgba(93, 21, 134, 0.85) 0%,
                rgba(0, 0, 0, 0.95) 60%,
                rgba(0, 102, 255, 0.4) 100%
            );
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 
                0 20px 40px rgba(91, 11, 156, 0.49),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            padding: 48px 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: modalFadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes modalFadeIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Efeito de fundo neural */
        .destination-modal-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 40px, rgba(106, 154, 255, 0.03) 40px, rgba(106, 154, 255, 0.03) 41px),
                repeating-linear-gradient(90deg, transparent, transparent 40px, rgba(106, 0, 255, 0.03) 40px, rgba(106, 0, 255, 0.03) 41px);
            opacity: 0.6;
            pointer-events: none;
            z-index: 1;
        }
        
        .destination-modal-container > * {
            position: relative;
            z-index: 5;
        }
        
        .destination-modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #fff;
            margin-bottom: 12px;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }
        
        .destination-modal-subtitle {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 40px;
        }
        
        .destination-grid {
            display: flex;
            gap: 24px;
            justify-content: center;
        }
        
        .destination-card {
            flex: 1;
            max-width: 340px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 32px 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            -webkit-appearance: none;
            appearance: none;
            color: inherit;
            font-family: inherit;
        }
        
        .destination-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .destination-card.pista:hover {
            border-color: rgba(255, 170, 0, 0.5);
            box-shadow: 0 0 30px rgba(255, 170, 0, 0.15);
        }

        .destination-card.streaming:hover {
            border-color: rgba(0, 212, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.15);
        }
        
        .destination-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.2));
        }
        
        .destination-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 12px;
            color: #fff;
        }
        
        .destination-desc {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 20px;
            line-height: 1.4;
            min-height: 3em;
        }
        
        .destination-features {
            padding: 0;
            margin: 0;
            text-align: left;
            width: 100%;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 20px;
        }
        
        .destination-feature {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .destination-feature::before {
            content: '✓';
            color: #00ff88;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .destination-grid {
                flex-direction: column;
                align-items: center;
            }
            .destination-card {
                width: 100%;
                max-width: 100%;
            }
            .destination-modal-container {
                padding: 32px 20px;
                max-height: 90vh;
                overflow-y: auto;
            }
            .destination-modal-title {
                font-size: 1.6rem;
            }
        }
    `;
    document.head.appendChild(styles);
}

/**
 * Criar modal de destino no DOM (se não existir)
 */
function ensureDestinationModalExists() {
    if (document.getElementById('soundDestinationModal')) return;
    
    const modal = document.createElement('div');
    modal.id = 'soundDestinationModal';
    modal.innerHTML = `
        <div class="destination-modal-container">
            <div class="destination-modal-title">Onde esse som vai tocar?</div>
            <div class="destination-modal-subtitle">Escolha o destino para otimizar a análise</div>
            
            <div class="destination-grid">
                <button class="destination-card pista" data-mode="pista">
                    <div class="destination-icon">🔊</div>
                    <div class="destination-name">Pista</div>
                    <div class="destination-desc">Para tocar alto em sistemas de som, carros, festas e shows.</div>
                    <div class="destination-features">
                        <div class="destination-feature">P.A, paredão e automotivo</div>
                        <div class="destination-feature">Mais impacto e pressão sonora</div>
                        <div class="destination-feature">Energia máxima para pista</div>
                    </div>
                </button>
                
                <button class="destination-card streaming" data-mode="streaming">
                    <div class="destination-icon">📡</div>
                    <div class="destination-name">Streaming</div>
                    <div class="destination-desc">Para subir em plataformas digitais com padrão profissional.</div>
                    <div class="destination-features">
                        <div class="destination-feature">Spotify, Deezer, Apple Music</div>
                        <div class="destination-feature">Loudness padronizado (-14 LUFS)</div>
                        <div class="destination-feature">Evita distorção e normalização agressiva</div>
                    </div>
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelectorAll('.destination-card').forEach(card => {
        card.addEventListener('click', (e) => {
            const mode = card.dataset.mode;
            selectSoundDestination(mode);
        });
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            // Não fechar ao clicar fora - forçar escolha
        }
    });
}

/**
 * Abrir modal de destino do som
 * @param {Function} callback - Função a chamar após seleção
 */
function openSoundDestinationModal(callback) {
    console.log('[DEST-MODAL] 🎯 Abrindo modal de destino do som...');
    
    injectDestinationModalStyles();
    ensureDestinationModalExists();
    
    // Guardar callback para chamar após seleção
    window.__destinationModalCallback__ = callback;
    
    const modal = document.getElementById('soundDestinationModal');
    console.log('[DEST-MODAL] Modal encontrado:', !!modal);
    
    if (modal) {
        modal.classList.add('active');
        modal.style.display = 'flex'; // Forçar display flex como backup
        console.log('[DEST-MODAL] ✅ Modal ativado com classe active');
        
        // Focus no primeiro botão
        setTimeout(() => {
            const firstBtn = modal.querySelector('.destination-card');
            if (firstBtn) firstBtn.focus();
        }, 100);
    } else {
        console.error('[DEST-MODAL] ❌ Modal não encontrado no DOM!');
        // Fallback: continuar sem o modal de destino
        if (typeof callback === 'function') {
            console.log('[DEST-MODAL] Usando fallback: modo pista');
            setSoundDestinationMode('pista');
            callback('pista');
        }
    }
}

/**
 * Fechar modal de destino
 */
function closeSoundDestinationModal() {
    const modal = document.getElementById('soundDestinationModal');
    if (modal) {
        modal.classList.remove('active');
        modal.style.display = 'none'; // Garantir que esconda
        console.log('[DEST-MODAL] Modal fechado');
    }
}

/**
 * Selecionar destino do som
 * @param {'pista' | 'streaming'} mode
 */
function selectSoundDestination(mode) {
    console.log(`[DEST-MODAL] ✅ Destino selecionado: ${mode}`);
    
    // Definir modo
    setSoundDestinationMode(mode);
    
    // Fechar modal
    closeSoundDestinationModal();
    
    // Chamar callback se existir
    if (typeof window.__destinationModalCallback__ === 'function') {
        window.__destinationModalCallback__(mode);
        window.__destinationModalCallback__ = null;
    }
}

// Expor funções globalmente
window.getSoundDestinationMode = getSoundDestinationMode;
window.setSoundDestinationMode = setSoundDestinationMode;
window.openSoundDestinationModal = openSoundDestinationModal;
window.closeSoundDestinationModal = closeSoundDestinationModal;

// ═══════════════════════════════════════════════════════════════════════════════
// FIM DO MODAL DE DESTINO DO SOM
// ═══════════════════════════════════════════════════════════════════════════════

// 🎵 Funções do Modal de Gênero Musical
function openGenreModal() {
    __dbg('[GENRE_MODAL] Abrindo modal de seleção de gênero...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal não encontrado no DOM');
        return;
    }
    
    // Injetar estilos se ainda não foi feito
    injectGenreModalStyles();
    
    // 🔧 CORREÇÃO FLASH BRANCO: Prepaint para evitar primeiro frame errado
    modal.classList.add('prepaint');  // Cards invisíveis enquanto CSS aplica
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
    
    // Libera a transição só de opacity no próximo frame
    requestAnimationFrame(() => {
        modal.classList.remove('prepaint');
        
        // Foco no primeiro botão de gênero
        const firstGenreCard = modal.querySelector('.genre-card');
        if (firstGenreCard) {
            firstGenreCard.focus();
        }
    });
    
    // 🎯 SCROLL FIX: Bloquear scroll do body quando modal aberto
    document.body.classList.add('modal-open');
    
    // Adicionar listeners de teclado
    modal.addEventListener('keydown', handleGenreModalKeydown);
    
    __dbg('[GENRE_MODAL] Modal aberto com sucesso (sem flash branco)');
}

function closeGenreModal() {
    __dbg('[GENRE_MODAL] Fechando modal de seleção de gênero...');
    
    const modal = document.getElementById('newGenreModal');
    if (modal) {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        
        // 🎯 SCROLL FIX: Liberar scroll do body ao fechar modal
        document.body.classList.remove('modal-open');
        
        // Remover listeners
        modal.removeEventListener('keydown', handleGenreModalKeydown);
    }
    
    __dbg('[GENRE_MODAL] Modal fechado');
}

function handleGenreModalKeydown(e) {
    if (e.key === 'Escape') {
        closeGenreModal();
    }
}

// 🎯 Inicialização do Modal de Gênero
function initGenreModal() {
    __dbg('[GENRE_MODAL] Inicializando sistema do modal...');
    
    const modal = document.getElementById('newGenreModal');
    if (!modal) {
        console.warn('[GENRE_MODAL] Modal não encontrado, inicialização cancelada');
        return;
    }
    
    const genreCards = modal.querySelectorAll('.genre-card');
    const closeBtn = modal.querySelector('[data-close]');
    
    // 🎯 Handler de clique nos gêneros
    genreCards.forEach(card => {
        card.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            const genre = card.dataset.genre;
            if (!genre) {
                console.error('[GENRE_MODAL] Gênero não definido no card');
                return;
            }
            
            __dbg('[GENRE_MODAL] Gênero selecionado:', genre);
            
            // 🔥 REUTILIZAR EXATAMENTE: Chamar applyGenreSelection como especificado
            if (typeof applyGenreSelection === 'function') {
                // ✅ CORREÇÃO CRÍTICA: Aguardar carregamento completo dos targets
                await applyGenreSelection(genre);
                
                // ✅ Log detalhado mostrando targets reais
                console.log('✅ [GENRE_MODAL] Targets de gênero carregados:', {
                    genre: genre,
                    hasActiveRefData: !!window.__activeRefData,
                    hasTargets: !!window.__activeRefData?.targets,
                    targetSource: window.__activeRefData?.targetSource,
                    targetKeys: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets) : [],
                    targetSample: window.__activeRefData?.targets ? Object.keys(window.__activeRefData.targets).slice(0, 3) : [],
                    lufs_target: window.__activeRefData?.lufs_target,
                    true_peak_target: window.__activeRefData?.true_peak_target,
                    version: window.__activeRefData?.version
                });
                
                __dbg('[GENRE_MODAL] ✅ applyGenreSelection concluído com sucesso');
            } else {
                console.error('[GENRE_MODAL] applyGenreSelection não está disponível');
                return;
            }
            
            // 🔥 Fechar modal conforme especificação
            closeGenreModal();
            
            // 🔥 CONTINUAR FLUXO: Abrir modal de upload automaticamente
            // ✅ CORREÇÃO: Removido setTimeout - targets já estão carregados
            openAnalysisModalForGenre();
        });
    });
    
    // Handler do botão fechar
    if (closeBtn) {
        closeBtn.addEventListener('click', closeGenreModal);
    }
    
    // Fechar clicando no fundo
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeGenreModal();
        }
    });
    
    __dbg('[GENRE_MODAL] Sistema inicializado com sucesso');
}

// 🎯 Abrir modal de análise após seleção de gênero
function openAnalysisModalForGenre() {
    __dbg('[GENRE_MODAL] Abrindo modal de análise para gênero selecionado...');
    
    // Usar o fluxo normal do modal de análise
    window.currentAnalysisMode = 'genre';
    
    // 🎯 LIMPAR estado de referência ao entrar em modo genre (conforme solicitado)
    const state = window.__soundyState || {};
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        console.log('✅ [GENRE-CLEANUP] Estado de referência limpo ao iniciar modo genre');
    }
    window.__soundyState = state;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('[GENRE_MODAL] Modal de análise não encontrado');
        return;
    }
    
    // Configurar modal para modo gênero
    configureModalForMode('genre');
    
    modal.style.display = 'flex';
    
    // ✅ CORREÇÃO CRÍTICA: NÃO resetar gênero/targets aqui!
    // Apenas limpar estado visual de upload (preserva gênero selecionado)
    clearAudioOnlyState();
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    __dbg('[GENRE_MODAL] Modal de análise aberto (gênero preservado)');
}

// Expor funções globalmente
window.openGenreModal = openGenreModal;
window.closeGenreModal = closeGenreModal;

// �🎯 NOVO: Abrir modal de análise configurado para o modo
function openAnalysisModalForMode(mode) {
    __dbg(`🎵 Abrindo modal de análise para modo: ${mode}`);
    
    // 🆕 FEATURE FLAG: Verificar se deve usar novo modal de gênero
    if (mode === 'genre' && window.FEATURE_NEW_GENRE_MODAL === true) {
        __dbg('🎨 Usando novo modal de gênero musical');
        openGenreModal();
        return;
    }
    
    // CORREÇÃO CRÍTICA: Definir window.currentAnalysisMode sempre que o modal for aberto
    // FIX: Guard para evitar sobrescrever reference por genre inadvertidamente
    const stateMachine = window.AnalysisStateMachine;
    const currentStateMode = stateMachine?.getMode();
    
    // Se state machine está em reference e modo solicitado é diferente, alertar
    if (currentStateMode === 'reference' && mode !== 'reference') {
        console.warn('[REF_FIX] ⚠️ Tentativa de abrir modal em modo', mode, 'mas state machine está em reference');
        console.warn('[REF_FIX] Mantendo modo reference para preservar estado');
        // Não sobrescrever - manter reference
        mode = 'reference';
    }
    
    window.currentAnalysisMode = mode;
    
    const modal = document.getElementById('audioAnalysisModal');
    if (!modal) {
        console.error('Modal de análise não encontrado');
        return;
    }
    
    // Configurar modal baseado no modo
    configureModalForMode(mode);
    
    // Reset state específico do modo
    if (mode === 'reference') {
        resetReferenceState();
    }
    
    modal.style.display = 'flex';
    
    // ✅ FIX 2: Reset seletivo baseado no modo
    if (mode === 'genre') {
        // Modo gênero: apenas limpar visual (preserva gênero)
        clearAudioOnlyState();
    } else if (mode === 'comparison') {
        // Modo comparison: pode resetar
        resetModalState();
    }
    // 🔒 Reference NÃO reseta (preserva estado da state machine)
    
    console.log('[REF_FIX] openAnalysisModalForMode:', mode, '- Reset aplicado:', mode === 'genre' || mode === 'comparison');
    
    modal.setAttribute('tabindex', '-1');
    modal.focus();
    
    window.logReferenceEvent('analysis_modal_opened', { mode });
}

// 🎯 NOVO: Configurar modal baseado no modo selecionado
function configureModalForMode(mode) {
    const title = document.getElementById('audioModalTitle');
    const subtitle = document.getElementById('audioModalSubtitle');
    const modeIndicator = document.getElementById('audioModeIndicator');
    const genreContainer = document.getElementById('audioRefGenreContainer');
    const progressSteps = document.getElementById('referenceProgressSteps');
    
    if (mode === 'genre') {
        // Modo Gênero: comportamento original
        if (title) title.textContent = '🎵 Análise de Áudio';
        if (subtitle) subtitle.style.display = 'none';
        if (genreContainer) genreContainer.style.display = 'flex';
        if (progressSteps) progressSteps.style.display = 'none';
        
        // 🔧 FIX: Limpar dados de referência ao trocar para modo genre
        if (window.__referenceComparisonActive) {
            console.log('[MODE_CHANGE] Trocando de REFERENCE para GENRE - limpando dados');
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            window.__referenceComparisonActive = false;
            
            console.log('[MODE_CHANGE] ✅ Dados de referência limpos para modo GENRE');
        }
        
    } else if (mode === 'reference') {
        // Modo Referência: interface específica
        if (title) title.textContent = '🎯 Análise por Referência';
        if (subtitle) {
            subtitle.style.display = 'block';
            if (modeIndicator) {
                modeIndicator.textContent = 'Comparação direta entre suas músicas';
            }
        }
        if (genreContainer) genreContainer.style.display = 'none';
        if (progressSteps) progressSteps.style.display = 'flex';
        
        // Configurar steps iniciais
        updateReferenceStep('userAudio');
    }
}

// 🎯 NOVO: Reset estado do modo referência (compatibilidade)
function resetReferenceState() {
    // 🚨 BLINDAGEM ABSOLUTA: NUNCA resetar em modo genre
    if (window.__CURRENT_MODE__ === 'genre') {
        console.warn('[GENRE-PROTECT] ⚠️ resetReferenceState() BLOQUEADO em modo genre');
        console.warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        return; // NÃO executar reset
    }

    referenceStepState = {
        currentStep: 'userAudio',
        userAudioFile: null,
        referenceAudioFile: null,
        userAnalysis: null,
        referenceAnalysis: null
    };
    
    window.logReferenceEvent('reference_state_reset');
}

// 🎯 FUNÇÃO AUXILIAR: Obter gênero ativo de múltiplas fontes
function getActiveGenre(analysis, fallback) {
    // 🎯 PRIORIDADE CORRETA: Fontes diretas ANTES de data.genre
    const genre = analysis?.genre ||             // ✅ 1ª prioridade: valor direto
                 analysis?.genreId ||            // ✅ 2ª prioridade: ID do gênero
                 analysis?.metadata?.genre ||    // ✅ 3ª prioridade: metadata
                 analysis?.data?.genre ||        // ⚠️ 4ª prioridade: pode ser null (contaminado)
                 fallback;                       // ✅ 5ª prioridade: fallback
    
    console.log('[GET-ACTIVE-GENRE] Gênero detectado:', genre, '(fallback:', fallback, ')');
    console.log('[GET-ACTIVE-GENRE] Fontes verificadas:', {
        'analysis.genre': analysis?.genre,
        'analysis.genreId': analysis?.genreId,
        'analysis.metadata.genre': analysis?.metadata?.genre,
        'analysis.data.genre': analysis?.data?.genre,
        'fallback': fallback,
        'final': genre
    });
    return genre;
}

// 🔥 CORREÇÃO CRÍTICA: Limpeza COMPLETA do estado de referência para modo gênero
function resetReferenceStateFully(preserveGenre) {
    // ✅ PROTEÇÃO: Não limpar targets no modo gênero
    const currentMode = window.currentAnalysisMode;
    if (currentMode === 'genre') {
        console.log('%c[GENRE-ISOLATION] 🛡️ Modo GENRE detectado - IGNORANDO reset de referência', 'color:#FFD700;font-weight:bold;font-size:14px;');
        console.log('[GENRE-ISOLATION] ✅ Targets de gênero preservados (reset bloqueado)');
        console.log('[REF_FIX] 🔒 FIX 4: Flag userExplicitlySelectedReferenceMode preservada (guard 100%)');
        // 🔒 FIX 4: NÃO resetar flag aqui - guard deve proteger TUDO
        return; // Sai SEM tocar em nada
    }
    
    console.group('%c[GENRE-ISOLATION] 🧹 Limpeza completa do estado de referência', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
    
    // 🛡️ PROTEÇÃO: Resetar flag ao limpar estado de referência (SÓ se passou do guard)
    persistReferenceFlag(false);
    console.log('%c[PROTECTION] ✅ Flag userExplicitlySelectedReferenceMode resetada em resetReferenceStateFully', 'color:#00FF88;font-weight:bold;');
    
    // ===============================================================
    // 🔒 BLOCO 1 — PRESERVAR GÊNERO ANTES DO RESET (MÚLTIPLAS FONTES)
    // ===============================================================
    let __PRESERVED_GENRE__ = null;

    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        __PRESERVED_GENRE__ = preserveGenre ||
                             window.__CURRENT_SELECTED_GENRE ||
                             window.PROD_AI_REF_GENRE ||
                             (genreSelect ? genreSelect.value : null) ||
                             window.__CURRENT_GENRE ||
                             window.__soundyState?.render?.genre ||
                             window.__activeUserGenre;

        console.log("[SAFE-RESET] ⚠️ Preservando gênero selecionado:", __PRESERVED_GENRE__);
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao capturar gênero antes do reset:", e);
    }
    
    // 🎯 SALVAR GÊNERO ANTES DE LIMPAR (compatibilidade com código existente)
    const __savedGenre = __PRESERVED_GENRE__;
    
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] 💾 Salvando gênero antes da limpeza:', __savedGenre);
    }
    
    // 1️⃣ Limpar variáveis globais window - CRÍTICO
    console.log('[GENRE-ISOLATION] 1️⃣ Limpando variáveis globais window...');
    
    // 🔥 CORREÇÃO CRÍTICA: Salvar targets do gênero preservado ANTES de limpar
    let __savedGenreTargets = null;
    if (__savedGenre) {
        // PROD_AI_REF_DATA pode ser dicionário ou objeto único
        if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object') {
            if (window.PROD_AI_REF_DATA[__savedGenre]) {
                // Estrutura de dicionário
                __savedGenreTargets = window.PROD_AI_REF_DATA[__savedGenre];
                console.log('[GENRE-ISOLATION] 💾 Targets do gênero salvos (dicionário):', __savedGenre);
            } else if (window.PROD_AI_REF_DATA.bands || window.PROD_AI_REF_DATA.legacy_compatibility) {
                // Objeto único
                __savedGenreTargets = window.PROD_AI_REF_DATA;
                console.log('[GENRE-ISOLATION] 💾 Targets salvos (objeto único):', __savedGenre);
            }
        }
        // Fallback para __activeRefData
        if (!__savedGenreTargets && window.__activeRefData) {
            __savedGenreTargets = window.__activeRefData;
            console.log('[GENRE-ISOLATION] 💾 Targets salvos de __activeRefData:', __savedGenre);
        }
    }
    
    // 🎯 CORREÇÃO CRÍTICA: Resetar PROD_AI_REF_DATA para false (não delete)
    window.PROD_AI_REF_DATA = false;
    console.log('   ✅ window.PROD_AI_REF_DATA: false');
    
    // 🔥 CORREÇÃO CRÍTICA: Restaurar targets do gênero preservado
    if (__savedGenre && __savedGenreTargets) {
        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
            window.PROD_AI_REF_DATA = {};
        }
        window.PROD_AI_REF_DATA[__savedGenre] = __savedGenreTargets;
        window.__activeRefData = __savedGenreTargets;
        console.log(`[GENRE-ISOLATION] 🔄 Targets restaurados para gênero: ${__savedGenre}`);
        console.log('   ✅ window.PROD_AI_REF_DATA[' + __savedGenre + ']: restaurado');
        console.log('   ✅ window.__activeRefData: restaurado com targets do gênero');
    } else {
        // 🎯 CORREÇÃO CRÍTICA: Resetar __activeRefData apenas se não houver gênero preservado
        window.__activeRefData = null;
        console.log('   ✅ window.__activeRefData: null');
    }
    
    // 🎯 CORREÇÃO CRÍTICA: Resetar __REFERENCE_JOB_ID__
    SOUNDY_MODE_ENGINE.clear();
    delete window.__REFERENCE_JOB_ID__;
    console.log('   ✅ window.__REFERENCE_JOB_ID__: removido');
    
    // 🎯 CORREÇÃO CRÍTICA: Resetar __REFERENCE_FILE_KEY__
    window.__REFERENCE_FILE_KEY__ = null;
    console.log('   ✅ window.__REFERENCE_FILE_KEY__: null');
    
    // 🎯 CORREÇÃO CRÍTICA: Resetar __CURRENT_JOB_ID__
    window.__CURRENT_JOB_ID__ = null;
    console.log('   ✅ window.__CURRENT_JOB_ID__: null');
    
    // 🎯 CORREÇÃO CRÍTICA: Resetar __activeUserData
    window.__activeUserData = null;
    console.log('   ✅ window.__activeUserData: null');
    
    delete window.referenceAnalysisData;
    window.__referenceComparisonActive = false;
    window.__FIRST_ANALYSIS_FROZEN__ = undefined;
    console.log('   ✅ window.referenceAnalysisData: removido');
    console.log('   ✅ window.__referenceComparisonActive: false');
    
    // 2️⃣ Limpar __soundyState
    console.log('[GENRE-ISOLATION] 2️⃣ Limpando window.__soundyState...');
    if (window.__soundyState) {
        delete window.__soundyState.reference;
        delete window.__soundyState.referenceAnalysis;
        delete window.__soundyState.previousAnalysis;
        if (window.__soundyState.render) {
            window.__soundyState.render.mode = 'genre';
        }
        console.log('   ✅ __soundyState.reference: removido');
        console.log('   ✅ __soundyState.referenceAnalysis: removido');
        console.log('   ✅ __soundyState.render.mode: forçado para "genre"');
    }
    
    // 3️⃣ Limpar localStorage
    console.log('[GENRE-ISOLATION] 3️⃣ Limpando localStorage...');
    try {
        localStorage.removeItem('referenceJobId');
        localStorage.removeItem('referenceAnalysis');
        console.log('   ✅ localStorage.referenceJobId: removido');
        console.log('   ✅ localStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   ⚠️ Falha ao limpar localStorage:', e.message);
    }
    
    // 4️⃣ Limpar sessionStorage
    console.log('[GENRE-ISOLATION] 4️⃣ Limpando sessionStorage...');
    try {
        sessionStorage.removeItem('referenceJobId');
        sessionStorage.removeItem('referenceAnalysis');
        console.log('   ✅ sessionStorage.referenceJobId: removido');
        console.log('   ✅ sessionStorage.referenceAnalysis: removido');
    } catch (e) {
        console.warn('   ⚠️ Falha ao limpar sessionStorage:', e.message);
    }
    
    // 5️⃣ Limpar Store (se existir)
    console.log('[GENRE-ISOLATION] 5️⃣ Limpando SoundyAI_Store...');
    if (window.SoundyAI_Store) {
        delete window.SoundyAI_Store.first;
        delete window.SoundyAI_Store.second;
        console.log('   ✅ SoundyAI_Store.first: removido');
        console.log('   ✅ SoundyAI_Store.second: removido');
    }
    
    // 6️⃣ Resetar referenceStepState
    console.log('[GENRE-ISOLATION] 6️⃣ Resetando referenceStepState...');
    if (typeof referenceStepState !== 'undefined') {
        referenceStepState = {
            currentStep: 'userAudio',
            userAudioFile: null,
            referenceAudioFile: null,
            userAnalysis: null,
            referenceAnalysis: null
        };
        console.log('   ✅ referenceStepState: resetado');
    }
    
    // 🔧 CORREÇÃO CRÍTICA: Resetar flag de renderização de IA
    // Permite que o módulo de sugestões seja re-renderizado após limpeza
    console.log('[GENRE-ISOLATION] 7️⃣ Resetando flags de renderização de IA...');
    window.__AI_RENDER_COMPLETED__ = false;
    console.log('   ✅ window.__AI_RENDER_COMPLETED__: false (permitir re-renderização)');
    
    // 🎯 RESTAURAR GÊNERO APÓS LIMPEZA
    if (__savedGenre) {
        console.log('[GENRE-ISOLATION] 🔄 Restaurando gênero:', __savedGenre);
        window.__CURRENT_GENRE = __savedGenre;
        
        if (!window.__soundyState) {
            window.__soundyState = {};
        }
        if (!window.__soundyState.render) {
            window.__soundyState.render = {};
        }
        
        window.__soundyState.render.genre = __savedGenre;
        window.__activeUserGenre = __savedGenre;
        window.PROD_AI_REF_GENRE = __savedGenre;  // ✅ CORREÇÃO: Sincronizar PROD_AI_REF_GENRE
        
        console.log('   ✅ window.__CURRENT_GENRE:', __savedGenre);
        console.log('   ✅ window.__soundyState.render.genre:', __savedGenre);
        console.log('   ✅ window.__activeUserGenre:', __savedGenre);
        console.log('   ✅ window.PROD_AI_REF_GENRE:', __savedGenre);
    }
    
    // ===============================================================
    // 🔒 BLOCO 3 — RESTAURAR GÊNERO NO DROPDOWN APÓS O RESET
    // ===============================================================
    try {
        const genreSelect = document.getElementById("audioRefGenreSelect");

        if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
            window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
            window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;
            window.__CURRENT_GENRE = __PRESERVED_GENRE__;

            if (genreSelect) {
                genreSelect.value = __PRESERVED_GENRE__;
            }

            console.log("[SAFE-RESET] ✅ Gênero restaurado no dropdown após reset:", __PRESERVED_GENRE__);
        } else {
            console.warn("[SAFE-RESET] ⚠️ Nenhum gênero válido preservado para dropdown.");
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar gênero no dropdown:", e);
    }
    
    console.log('%c[GENRE-ISOLATION] ✅ Estado de referência completamente limpo', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

// ========================================
// 🔥 UI HELPERS - SHOW/HIDE SEÇÕES
// ========================================

function hideReferenceUI() {
    console.log('[UI-CONTROL] 🙈 Ocultando elementos de UI de referência...');
    
    // Ocultar elementos específicos de referência
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ✅ Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showGenreUI() {
    console.log('[UI-CONTROL] 👁️ Exibindo elementos de UI de gênero...');
    
    // Exibir elementos específicos de gênero
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ✅ Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

function hideGenreUI() {
    console.log('[UI-CONTROL] 🙈 Ocultando elementos de UI de gênero...');
    
    const genreSelectors = [
        '[data-section="genre"]',
        '.genre-mode',
        '#genre-comparison-container',
        '.genre-comparison',
        '[data-mode="genre"]'
    ];
    
    genreSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.add('hidden');
            el.style.display = 'none';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ✅ Ocultos ${elements.length} elementos: ${selector}`);
        }
    });
}

function showReferenceUI() {
    console.log('[UI-CONTROL] 👁️ Exibindo elementos de UI de referência...');
    
    const refSelectors = [
        '[data-section="reference"]',
        '.reference-mode',
        '#reference-comparison-container',
        '.reference-comparison',
        '.track-comparison',
        '[data-mode="reference"]'
    ];
    
    refSelectors.forEach(selector => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
            el.classList.remove('hidden');
            el.style.display = '';
        });
        if (elements.length > 0) {
            console.log(`[UI-CONTROL]    ✅ Exibidos ${elements.length} elementos: ${selector}`);
        }
    });
}

// ========================================
// 🔥 RENDERIZAÇÃO ISOLADA DE GÊNERO
// ========================================

// 🎯 MÓDULO DE CONVERSÃO DE BANDAS (EXCLUSIVO PARA MODO GÊNERO)
// ========================================
/**
 * Converte nomes de bandas do backend para o formato esperado pelos targets de gênero.
 * 
 * Backend envia: sub, bass, lowMid, mid, highMid, presence, air
 * Targets esperam: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
 * 
 * ⚠️ USO EXCLUSIVO: Apenas para analysis.mode === "genre"
 * ❌ NUNCA usar para: mode === "reference", A/B, referenceComparison
 * 
 * @param {Object} bands - Bandas do backend (analysis.bands)
 * @returns {Object} Bandas convertidas para formato de targets de gênero
 */
// 🎯 SISTEMA DE ALIAS DE BANDAS (branch imersao)
const BAND_ALIASES = {
    'bass': ['low_bass', 'upper_bass'],
    'lowMid': ['low_mid'],
    'highMid': ['high_mid'],
    'presence': ['presenca'],
    'air': ['brilho']
};

/**
 * Busca banda com suporte a alias (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} bandsObject - Objeto com bandas
 * @returns {Object|null} Dados da banda ou null
 */
function searchBandWithAlias(bandKey, bandsObject) {
    if (!bandsObject || typeof bandsObject !== 'object') return null;
    
    // 1. Busca direta
    if (bandsObject[bandKey]) {
        return bandsObject[bandKey];
    }
    
    // 2. Busca por alias
    const aliases = BAND_ALIASES[bandKey];
    if (aliases) {
        for (const alias of aliases) {
            if (bandsObject[alias]) {
                console.log(`🔄 [ALIAS] ${bandKey} → ${alias}`);
                return bandsObject[alias];
            }
        }
    }
    
    return null;
}

/**
 * Busca banda em múltiplas fontes com cascata (branch imersao)
 * @param {string} bandKey - Chave da banda
 * @param {Object} analysis - Objeto de análise completo
 * @returns {Object|null} Dados da banda com source
 */

// ════════════════════════════════════════════════════════════════════════════════
// 🎯 FONTE ÚNICA DA VERDADE: buildMetricRows()
// ════════════════════════════════════════════════════════════════════════════════
/**
 * 📊 FUNÇÃO COMPARTILHADA: Gera rows de métricas e bandas para TABELA e MODAL.
 * 
 * REGRAS OBRIGATÓRIAS:
 * 1. BANDAS: Se target_range existe, usar SOMENTE min/max (NÃO aplicar tolerância)
 * 2. BANDAS: Fallback para target_db ± tol_db SOMENTE se target_range ausente
 * 3. MÉTRICAS: Sempre usar target ± tolerance
 * 4. SEVERIDADE: Mesma lógica em todos os casos (calcSeverity)
 * 5. ALIAS: upper_bass → bass (não aparece como key final)
 * 
 * @param {Object} analysis - Objeto de análise completo
 * @param {Object} targets - Targets de gênero ou referência
 * @param {string} mode - 'genre' ou 'reference'
 * @returns {Array<Object>} rows com { key, type, label, value, targetText, min, max, target, delta, severity, severityClass, actionText, category }
 */
window.buildMetricRows = function(analysis, targets, mode = 'genre') {
    console.group('[BUILD_ROWS] 🏗️ Construindo rows compartilhados');
    console.log('[BUILD_ROWS] Mode:', mode);
    console.log('[BUILD_ROWS] Targets:', targets ? Object.keys(targets) : 'null');
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🎯 PRIORIDADE 1: Usar comparisonResult do backend (FONTE ÚNICA DA VERDADE)
    // Se disponível, retornar diretamente sem cálculo local
    // ═══════════════════════════════════════════════════════════════════════════
    const comparisonResult = analysis?.data?.comparisonResult;
    if (comparisonResult && Array.isArray(comparisonResult.rows) && comparisonResult.rows.length > 0) {
        console.log('[BUILD_ROWS] 🎯 Usando comparisonResult do backend (FONTE ÚNICA)');
        console.log('[BUILD_ROWS] Rows do backend:', comparisonResult.rows.length);
        
        // Adaptar formato se necessário (actionText vs action)
        const adaptedRows = comparisonResult.rows.map(row => ({
            ...row,
            actionText: row.action || row.actionText || '—'
        }));
        
        console.groupEnd();
        return adaptedRows;
    }
    
    console.log('[BUILD_ROWS] ⚠️ comparisonResult não disponível, usando cálculo local');
    
    const rows = [];
    
    // ✅ FLAG DE CONTROLE
    if (!window.USE_TABLE_ROWS_FOR_MODAL) {
        console.warn('[BUILD_ROWS] ⚠️ Flag USE_TABLE_ROWS_FOR_MODAL = false, usando lógica antiga');
        console.groupEnd();
        return rows;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🔄 FALLBACK: Usar targets normalizados do backend
    // ═══════════════════════════════════════════════════════════════════════════
    const normalizedTargets = getNormalizedTargetsFromAnalysis(analysis);
    const useNormalizedTargets = normalizedTargets !== null;
    
    if (useNormalizedTargets) {
        console.log('[BUILD_ROWS] ✅ Usando referenceTargetsNormalized do backend');
    } else {
        console.log('[BUILD_ROWS] ⚠️ Usando targets locais (fallback)');
    }
    
    // 🎯 ALIAS MAP: upper_bass → bass (não aparece como key final)
    const BAND_ALIAS_MAP = {
        'upper_bass': 'bass',
        'low_bass': 'bass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // 🎯 LISTA CANÔNICA DE BANDAS (ordem LOW END → MID → HIGH)
    // ⚠️ CORREÇÃO: Frequências alinhadas com padrão do projeto
    // air = Brilho (4k-10k Hz), presence = Presença (10k-20k Hz)
    const CANONICAL_BANDS = [
        { key: 'sub', label: '🔉 Sub (20-60 Hz)', category: 'LOW END' },
        { key: 'bass', label: '🔊 Bass (60-150 Hz)', category: 'LOW END' },
        { key: 'lowMid', label: '🎵 Low Mid (150-500 Hz)', category: 'MID' },
        { key: 'mid', label: '🎵 Mid (500-2k Hz)', category: 'MID' },
        { key: 'highMid', label: '🎸 High Mid (2k-4k Hz)', category: 'HIGH' },
        { key: 'air', label: '✨ Brilho (4k-10k Hz)', category: 'HIGH' },
        { key: 'presence', label: '💎 Presença (10k-20k Hz)', category: 'HIGH' }
    ];
    
    // 🎯 HELPER: Calcular severidade (usando evaluateMetric como Single Source of Truth)
    const calcSeverity = (value, target, tolerance, options = {}) => {
        const { targetRange } = options;
        
        if (!Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        // Construir targetSpec para evaluateMetric
        let targetSpec = {};
        
        if (targetRange && typeof targetRange === 'object') {
            const min = targetRange.min ?? targetRange.min_db;
            const max = targetRange.max ?? targetRange.max_db;
            if (typeof min === 'number' && typeof max === 'number') {
                targetSpec = { min, max, tol: tolerance || 2.0 };
            }
        }
        
        // Se não tem range, usar target ± tol
        if (!targetSpec.min && !targetSpec.max) {
            if (target !== null && target !== undefined) {
                targetSpec = { target, tol: tolerance || 1.0 };
            } else {
                return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
            }
        }
        
        // 🎯 Usar evaluateMetricForTable (SINGLE SOURCE OF TRUTH)
        return window.evaluateMetricForTable('metric', value, targetSpec);
    };
    
    // ════════════════════════════════════════════════════════════════════
    // 1️⃣ MÉTRICAS PRINCIPAIS - AGORA COM SUPORTE A MIN/MAX EXPLÍCITO
    // ════════════════════════════════════════════════════════════════════
    
    const genreData = targets;
    const technicalData = analysis.technicalData || {};
    
    // 🔊 LUFS - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.lufs_target != null && Number.isFinite(technicalData.lufsIntegrated)) {
        
        // 🎯 PRIORIDADE 1: Usar severidade pré-calculada do backend (FONTE ÚNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'lufs') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.lufs) {
            // Usar targets normalizados do backend
            const lufs = normalizedTargets.metrics.lufs;
            min = lufs.min;
            max = lufs.max;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} LUFS`;
            console.log(`[BUILD_ROWS] ✅ LUFS: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // Fallback: calcular localmente
            const lufsBounds = getMetricBounds(genreData, 'lufs');
            
            if (lufsBounds && lufsBounds.mode === 'minmax') {
                min = lufsBounds.min;
                max = lufsBounds.max;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} LUFS`;
                console.log(`[BUILD_ROWS] ⚠️ LUFS: usando min/max local [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else {
                // Fallback para target ± tol
                min = genreData.lufs_target - (genreData.tol_lufs || 1.0);
                max = genreData.lufs_target + (genreData.tol_lufs || 1.0);
                targetText = `${genreData.lufs_target.toFixed(1)} LUFS`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // 🎯 USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÍTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÇÃO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            console.log(`[BUILD_ROWS] ✅ LUFS: severidade do backend = ${result.severity}`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            result = calcSeverity(technicalData.lufsIntegrated, genreData.lufs_target, genreData.tol_lufs || 1.0, 
                { targetRange: { min, max } });
        }
        
        rows.push({
            key: 'lufsIntegrated',
            type: 'metric',
            label: '🔊 Loudness (LUFS)',
            value: technicalData.lufsIntegrated,
            targetText,
            min,
            max,
            target: genreData.lufs_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // 🎚️ True Peak - AGORA COM SUPORTE A true_peak_min/true_peak_max
    // 🚨 REGRA CRÍTICA: true_peak_max NUNCA pode ser > 0 dBTP
    if (genreData.true_peak_target != null && Number.isFinite(technicalData.truePeakDbtp)) {
        
        // 🎯 PRIORIDADE 1: Usar severidade pré-calculada do backend (FONTE ÚNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'truePeak') : null;
        
        // Extrair bounds
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.truePeak) {
            // Usar targets normalizados do backend
            const tp = normalizedTargets.metrics.truePeak;
            min = tp.min;
            max = Math.min(tp.max, TRUE_PEAK_HARD_CAP); // 🚨 GARANTIR HARD CAP
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dBTP`;
            console.log(`[BUILD_ROWS] ✅ True Peak: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}] hardCap=${tp.hardCap}`);
        } else {
            // Fallback: calcular localmente
            const tpBounds = getMetricBounds(genreData, 'true_peak');
            
            if (tpBounds && tpBounds.mode === 'minmax') {
                min = tpBounds.min;
                max = Math.min(tpBounds.max, TRUE_PEAK_HARD_CAP); // 🚨 NUNCA > 0 dBTP
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dBTP`;
            } else {
                min = genreData.true_peak_target - (genreData.tol_true_peak || 0.5);
                max = Math.min(genreData.true_peak_target + (genreData.tol_true_peak || 0.5), TRUE_PEAK_HARD_CAP);
                targetText = `${genreData.true_peak_target.toFixed(1)} dBTP`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // 🎯 USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÍTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÇÃO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            console.log(`[BUILD_ROWS] ✅ True Peak: severidade do backend = ${result.severity}`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            result = calculateTruePeakSeverityLocal(technicalData.truePeakDbtp, normalizedTargets || genreData);
        }
        
        rows.push({
            key: 'truePeak',
            type: 'metric',
            label: '🎚️ True Peak (dBTP)',
            value: technicalData.truePeakDbtp,
            targetText,
            min,
            max,
            target: genreData.true_peak_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets // Debug: indicar fonte
        });
    }
    
    // 📊 DR - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.dr_target != null && Number.isFinite(technicalData.dynamicRange)) {
        
        // 🎯 PRIORIDADE 1: Usar severidade pré-calculada do backend (FONTE ÚNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'dr') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.dr) {
            // Usar targets normalizados do backend
            const dr = normalizedTargets.metrics.dr;
            min = dr.min;
            max = dr.max;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} DR`;
            console.log(`[BUILD_ROWS] ✅ DR: usando normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // Fallback: calcular localmente
            const drBounds = getMetricBounds(genreData, 'dr');
            
            if (drBounds && drBounds.mode === 'minmax') {
                min = drBounds.min;
                max = drBounds.max;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} DR`;
                console.log(`[BUILD_ROWS] ⚠️ DR: usando min/max local [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else {
                // Fallback para target ± tol
                min = genreData.dr_target - (genreData.tol_dr || 1.0);
                max = genreData.dr_target + (genreData.tol_dr || 1.0);
                targetText = `${genreData.dr_target.toFixed(1)} DR`;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // 🎯 USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÍTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÇÃO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            console.log(`[BUILD_ROWS] ✅ DR: severidade do backend = ${result.severity}`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            result = calcSeverity(technicalData.dynamicRange, genreData.dr_target, genreData.tol_dr || 1.0,
                { targetRange: { min, max } });
        }
        
        rows.push({
            key: 'dr',
            type: 'metric',
            label: '📊 Dynamic Range (DR)',
            value: technicalData.dynamicRange,
            targetText,
            min,
            max,
            target: genreData.dr_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // 🎧 Stereo - AGORA COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    if (genreData.stereo_target != null && Number.isFinite(technicalData.stereoCorrelation)) {
        
        // 🎯 PRIORIDADE 1: Usar severidade pré-calculada do backend (FONTE ÚNICA)
        const preCalcSeverity = useNormalizedTargets ? getSeverityFromNormalized(normalizedTargets, 'stereo') : null;
        
        let min, max, targetText;
        
        if (useNormalizedTargets && normalizedTargets.metrics?.stereo) {
            // Usar targets normalizados do backend
            const stereo = normalizedTargets.metrics.stereo;
            min = stereo.min;
            max = stereo.max;
            targetText = `${min.toFixed(3)} a ${max.toFixed(3)}`;
            console.log(`[BUILD_ROWS] ✅ Stereo: usando normalizedTargets [${min.toFixed(3)}, ${max.toFixed(3)}]`);
        } else {
            // Fallback: calcular localmente
            min = genreData.stereo_target - (genreData.tol_stereo || 0.1);
            max = genreData.stereo_target + (genreData.tol_stereo || 0.1);
            targetText = `${genreData.stereo_target.toFixed(3)}`;
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcSeverity) {
            // 🎯 USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcSeverity.severity,
                severityClass: preCalcSeverity.severity === 'CRÍTICA' ? 'critical' : 
                              preCalcSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcSeverity.severity === 'ATENÇÃO' ? 'caution' : 'ok',
                action: preCalcSeverity.action,
                diff: preCalcSeverity.delta
            };
            console.log(`[BUILD_ROWS] ✅ Stereo: severidade do backend = ${result.severity}`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            result = calcSeverity(technicalData.stereoCorrelation, genreData.stereo_target, genreData.tol_stereo || 0.1);
        }
        
        rows.push({
            key: 'stereo',
            type: 'metric',
            label: '🎧 Stereo Correlation',
            value: technicalData.stereoCorrelation,
            targetText,
            min,
            max,
            target: genreData.stereo_target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: 'METRICS',
            _sourceNormalized: useNormalizedTargets
        });
    }
    
    // ════════════════════════════════════════════════════════════════════
    // 2️⃣ BANDAS ESPECTRAIS - COM SUPORTE A TARGETS NORMALIZADOS DO BACKEND
    // ════════════════════════════════════════════════════════════════════
    
    const userBands = technicalData.spectral_balance || technicalData.bands || analysis.bands || {};
    const targetBands = genreData.bands || genreData.spectral_bands || {};
    
    // 🎯 Usar bandas normalizadas do backend se disponíveis
    const normalizedBands = useNormalizedTargets ? normalizedTargets.bands : null;
    
    console.log('[BUILD_ROWS] 🎵 Processando bandas:');
    console.log('[BUILD_ROWS]   - userBands keys:', Object.keys(userBands));
    console.log('[BUILD_ROWS]   - targetBands keys:', Object.keys(targetBands));
    console.log('[BUILD_ROWS]   - normalizedBands:', normalizedBands ? Object.keys(normalizedBands) : 'N/A');
    
    let bandsProcessed = 0;
    let bandsMissing = [];
    
    CANONICAL_BANDS.forEach(bandInfo => {
        const bandKey = bandInfo.key;
        
        // 🔍 PRIORIDADE 1: Verificar se temos severidade pré-calculada para esta banda
        const preCalcBandSeverity = useNormalizedTargets ? 
            getBandSeverityFromNormalized(normalizedTargets, bandKey) : null;
        
        // 🔍 Buscar target (do backend normalizado ou local)
        let normalizedBand = normalizedBands?.[bandKey];
        let targetBand = targetBands[bandKey];
        
        if (!targetBand && !normalizedBand) {
            // Buscar por alias reverso (ex: 'bass' pode estar como 'low_bass' no target)
            const reverseAliases = {
                'bass': ['low_bass', 'upper_bass'],
                'lowMid': ['low_mid'],
                'highMid': ['high_mid'],
                'presence': ['presenca'],
                'air': ['brilho']
            };
            const aliases = reverseAliases[bandKey];
            if (aliases) {
                for (const alias of aliases) {
                    if (targetBands[alias]) {
                        targetBand = targetBands[alias];
                        console.log(`[BUILD_ROWS] 🔄 Alias encontrado: ${bandKey} ← ${alias}`);
                        break;
                    }
                    if (normalizedBands?.[alias]) {
                        normalizedBand = normalizedBands[alias];
                        console.log(`[BUILD_ROWS] 🔄 Normalized alias: ${bandKey} ← ${alias}`);
                        break;
                    }
                }
            }
        }
        
        if (!targetBand && !normalizedBand) {
            console.log(`[BUILD_ROWS] ⏭️ Banda sem target: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // 🔍 Buscar valor do usuário (mesma lógica anterior)
        const reverseAliases = {
            'bass': ['low_bass', 'upper_bass'],
            'lowMid': ['low_mid'],
            'highMid': ['high_mid'],
            'presence': ['presenca'],
            'air': ['brilho']
        };
        
        let bandData = userBands[bandKey];
        if (!bandData && reverseAliases[bandKey]) {
            for (const alias of reverseAliases[bandKey]) {
                if (userBands[alias]) {
                    bandData = userBands[alias];
                    console.log(`[BUILD_ROWS] 🔄 User alias: ${bandKey} ← ${alias}`);
                    break;
                }
            }
        }
        
        if (!bandData) {
            console.log(`[BUILD_ROWS] ⏭️ Banda sem dados user: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // Extrair valor
        let energyDb = typeof bandData === 'number' ? bandData : (bandData.energy_db ?? bandData.rms_db ?? null);
        if (!Number.isFinite(energyDb)) {
            console.log(`[BUILD_ROWS] ⏭️ Banda sem valor numérico: ${bandKey}`);
            bandsMissing.push(bandKey);
            return;
        }
        
        // 🎯 PRIORIDADE 1: Usar targets normalizados do backend
        let targetText, min, max, target;
        
        if (normalizedBand) {
            // ✅ USAR TARGETS NORMALIZADOS DO BACKEND (FONTE ÚNICA)
            min = normalizedBand.min;
            max = normalizedBand.max;
            target = normalizedBand.target;
            targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dB`;
            console.log(`[BUILD_ROWS] ✅ ${bandKey}: normalizedTargets [${min.toFixed(1)}, ${max.toFixed(1)}]`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            const targetRange = targetBand.target_range || targetBand.targetRange;
            
            if (targetRange && (typeof targetRange.min === 'number' || typeof targetRange.min_db === 'number')) {
                // ✅ Usar range explícito (NUNCA aplicar tolerância)
                min = targetRange.min ?? targetRange.min_db;
                max = targetRange.max ?? targetRange.max_db;
                target = (min + max) / 2;
                targetText = `${min.toFixed(1)} a ${max.toFixed(1)} dB`;
                console.log(`[BUILD_ROWS] ⚠️ ${bandKey}: fallback target_range [${min.toFixed(1)}, ${max.toFixed(1)}]`);
            } else if (typeof targetBand.target_db === 'number') {
                // 🔄 Fallback: target_db ± tol_db
                target = targetBand.target_db;
                const tolerance = targetBand.tol_db ?? 2.0;
                min = target - tolerance;
                max = target + tolerance;
                targetText = `${target.toFixed(1)} dB (±${tolerance.toFixed(1)})`;
                console.log(`[BUILD_ROWS] ⚠️ ${bandKey}: fallback target_db ± tol_db`);
            } else {
                console.log(`[BUILD_ROWS] ❌ Banda sem target válido: ${bandKey}`);
                bandsMissing.push(bandKey);
                return;
            }
        }
        
        // Calcular severidade
        let result;
        
        if (preCalcBandSeverity) {
            // 🎯 USAR SEVERIDADE DO BACKEND
            result = {
                severity: preCalcBandSeverity.severity,
                severityClass: preCalcBandSeverity.severity === 'CRÍTICA' ? 'critical' : 
                              preCalcBandSeverity.severity === 'ALTA' ? 'warning' :
                              preCalcBandSeverity.severity === 'ATENÇÃO' ? 'caution' : 'ok',
                action: preCalcBandSeverity.action,
                diff: preCalcBandSeverity.delta
            };
            console.log(`[BUILD_ROWS] ✅ ${bandKey}: severidade do backend = ${result.severity}`);
        } else {
            // 🔄 FALLBACK: calcular localmente
            result = calcSeverity(energyDb, target, null, { targetRange: { min, max } });
        }
        
        rows.push({
            key: bandKey,
            type: 'band',
            label: bandInfo.label,
            value: energyDb,
            targetText,
            min,
            max,
            target,
            delta: result.diff,
            severity: result.severity,
            severityClass: result.severityClass,
            actionText: result.action,
            category: bandInfo.category,
            _sourceNormalized: !!normalizedBand
        });
        
        bandsProcessed++;
        console.log(`[BUILD_ROWS] ✅ ${bandKey}: ${energyDb.toFixed(2)} dB | ${result.severity} | normalized=${!!normalizedBand}`);
    });
    
    // 📊 LOGS DE VALIDAÇÃO
    console.log('[BUILD_ROWS] 📊 RESULTADO:');
    console.log(`[BUILD_ROWS]   - Total rows: ${rows.length}`);
    console.log(`[BUILD_ROWS]   - Bandas processadas: ${bandsProcessed}/7`);
    console.log(`[BUILD_ROWS]   - Bandas missing: ${bandsMissing.length}`, bandsMissing);
    console.log(`[BUILD_ROWS]   - Rows não-OK: ${rows.filter(r => r.severity !== 'OK').length}`);
    console.groupEnd();
    
    return rows;
};

// ✅ FLAG GLOBAL
window.USE_TABLE_ROWS_FOR_MODAL = true;

/**
 * Normaliza nomes de bandas do backend para formato dos targets de gênero.
 * Backend: ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air']
 * Targets: ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca']
 */
function normalizeGenreBandName(name) {
    // 🎯 PATCH DEFINITIVO: Backend JÁ normalizou (low_bass → bass, presenca → presence, etc.)
    // Não converter novamente! Apenas garantir compatibilidade com snake_case legado
    const map = {
        // Se ainda receber snake_case (compatibilidade), converter para camelCase
        'low_bass': 'bass',
        'upper_bass': 'upperBass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air',
        // CamelCase já normalizado - retornar como está
        'bass': 'bass',
        'upperBass': 'upperBass',
        'lowMid': 'lowMid',
        'highMid': 'highMid',
        'presence': 'presence',
        'air': 'air',
        'sub': 'sub',
        'mid': 'mid'
    };
    return map[name] || name;
}

function getBandDataWithCascade(bandKey, analysis) {
    // 🎯 CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    
    // 1. Prioridade: analysis.metrics.bands (centralizado - mantido por compatibilidade)
    if (analysis.metrics?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.metrics.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'centralized' 
            };
        }
    }
    
    // 🎯 CORREÇÃO: 2. analysis.technicalData.bands (caminho REAL do backend - prioridade 2)
    if (analysis.technicalData?.bands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'technical' 
            };
        }
    }
    
    // 🎯 CORREÇÃO: 3. analysis.technicalData.spectral_balance (fonte real - alias de bands)
    if (analysis.technicalData?.spectral_balance) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectral_balance);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectral_balance' 
            };
        }
    }
    
    // 4. Fallback: tech.bandEnergies (legado)
    if (analysis.technicalData?.bandEnergies) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.bandEnergies);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'legacy' 
            };
        }
    }
    
    // 5. Fallback: tech.spectralBands (legado)
    if (analysis.technicalData?.spectralBands) {
        const data = searchBandWithAlias(bandKey, analysis.technicalData.spectralBands);
        if (data) {
            return { 
                energy_db: data.energy_db || data.rms_db, 
                source: 'spectralBands' 
            };
        }
    }
    
    return null;
}

function mapBackendBandsToGenreBands(bands) {
    if (!bands || typeof bands !== 'object') {
        console.warn('[BAND-MAPPER] ⚠️ Bandas inválidas recebidas:', bands);
        return {};
    }
    
    console.group('[BAND-MAPPER] 🔄 Convertendo bandas do backend para formato de gênero');
    console.log('[BAND-MAPPER] Bandas originais (backend):', Object.keys(bands));
    
    const mapped = {
        // Mapeamento direto (mesma chave)
        sub: bands.sub || null,
        mid: bands.mid || null,
        
        // Conversões necessárias
        low_bass: bands.bass || null,           // bass → low_bass
        upper_bass: null,                       // ❌ não existe no backend atual
        low_mid: bands.lowMid || null,          // lowMid → low_mid
        high_mid: bands.highMid || null,        // highMid → high_mid
        brilho: bands.air || null,              // air → brilho
        presenca: bands.presence || null        // presence → presenca
    };
    
    console.log('[BAND-MAPPER] Bandas convertidas (targets):', Object.keys(mapped).filter(k => mapped[k] !== null));
    console.log('[BAND-MAPPER] Bandas ausentes:', Object.keys(mapped).filter(k => mapped[k] === null));
    console.groupEnd();
    
    return mapped;
}

/**
 * Aplica conversão de bandas EXCLUSIVAMENTE para modo gênero.
 * 
 * @param {Object} analysis - Objeto de análise completo
 * @returns {Object} Análise com bandas convertidas (analysis.genreBands)
 */
function applyGenreBandConversion(analysis) {
    // 🛡️ GUARD: Apenas para modo gênero
    if (analysis?.mode !== 'genre') {
        console.log('[BAND-MAPPER] ⏭️ Modo não é gênero, pulando conversão');
        return analysis;
    }
    
    console.group('[BAND-MAPPER] 🎯 Aplicando conversão de bandas para modo GÊNERO');
    console.log('[BAND-MAPPER] Mode:', analysis.mode);
    console.log('[BAND-MAPPER] Bandas originais:', analysis.bands ? Object.keys(analysis.bands) : 'N/A');
    
    // Converter bandas do backend para formato de targets
    if (analysis.bands) {
        analysis.genreBands = mapBackendBandsToGenreBands(analysis.bands);
        console.log('[BAND-MAPPER] ✅ analysis.genreBands criado com', Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null).length, 'bandas');
    } else {
        console.warn('[BAND-MAPPER] ⚠️ analysis.bands não disponível');
        analysis.genreBands = {};
    }
    
    console.groupEnd();
    return analysis;
}

function renderGenreView(analysis) {
    console.group('%c[GENRE-VIEW] 🎨 Renderizando UI exclusiva de gênero', 'color:#00C9FF;font-weight:bold;font-size:14px;');
    
    // 🔥 ISOLAMENTO TOTAL: Limpar TODAS as variáveis de referência
    console.log('[GENRE-VIEW] 🧹 LIMPANDO variáveis de referência...');
    analysis.referenceComparison = undefined;
    analysis.referenceComparisonMetrics = undefined;
    window.referenceComparisonMetrics = null;
    console.log('[GENRE-VIEW] ✅ Variáveis de referência limpas');
    
    // 1️⃣ Validar análise
    if (!analysis) {
        console.error('[GENRE-VIEW] ❌ ERRO: Análise não fornecida');
        console.groupEnd();
        return;
    }
    
    // 2️⃣ Garantir limpeza completa
    console.log('[GENRE-VIEW] 1️⃣ Executando limpeza preventiva...');
    // 🎯 PRESERVAR GÊNERO durante o reset - USANDO extractGenreName
    const genreToPreserve = extractGenreName(analysis) || window.PROD_AI_REF_GENRE;
    resetReferenceStateFully(genreToPreserve);
    
    // 🎯 GARANTIR que analysis.genre está definido
    if (genreToPreserve && !analysis.genre) {
        analysis.genre = genreToPreserve;
    }
    
    // 3️⃣ Configurar ViewMode
    console.log('[GENRE-VIEW] 2️⃣ Configurando ViewMode...');
    setViewMode("genre");
    
    // 4️⃣ Controlar UI visibility
    console.log('[GENRE-VIEW] 3️⃣ Controlando visibilidade de UI...');
    hideReferenceUI();
    showGenreUI();
    
    // 5️⃣ Obter gênero - USANDO NOVA FUNÇÃO GENRE-ONLY
    const genre = extractGenreName(analysis) || 'default';
    
    console.log('[GENRE-VIEW] 4️⃣ Gênero identificado:', genre);
    
    // 🎯 CONVERSÃO DE BANDAS: Backend → Targets de gênero
    console.log('[GENRE-VIEW] 🔄 Aplicando conversão de bandas...');
    applyGenreBandConversion(analysis);
    console.log('[GENRE-VIEW] ✅ Bandas convertidas:', analysis.genreBands ? Object.keys(analysis.genreBands).filter(k => analysis.genreBands[k] !== null) : 'N/A');
    
    // 6️⃣ Obter targets de gênero - SEMPRE USAR PROD_AI_REF_DATA COMO BASE
    // 🎯 ESTRATÉGIA: PROD_AI_REF_DATA[genre] tem TODAS as métricas (DR, LRA, Stereo, Bandas)
    //    Depois aplicamos streaming override APENAS em LUFS e TP se necessário
    
    let genreTargets = null;
    
    // 🎯 PRIORIDADE 1: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
    if (window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
        genreTargets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
        console.log('[GENRE-VIEW] 📦 Targets BASE obtidos de PROD_AI_REF_DATA[genre]');
    }
    
    // 🎯 FALLBACK: __activeRefData
    if (!genreTargets && window.__activeRefData) {
        genreTargets = JSON.parse(JSON.stringify(window.__activeRefData));
        console.log('[GENRE-VIEW] 📦 Targets obtidos de __activeRefData (fallback)');
    }
    
    // 🎯 FALLBACK 2: extractGenreTargets
    if (!genreTargets) {
        genreTargets = extractGenreTargets(analysis);
        console.log('[GENRE-VIEW] 📦 Targets obtidos de extractGenreTargets');
    }
    
    // 📡 STREAMING MODE: Aplicar override de LUFS e TP (mantém DR, LRA, Stereo, Bandas)
    if (getSoundDestinationMode() === 'streaming' && genreTargets) {
        console.log('[GENRE-VIEW] 📡 STREAMING MODE DETECTADO - Aplicando override de LUFS/TP');
        genreTargets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
        genreTargets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
        console.log('[GENRE-VIEW] 📡 Targets atualizados:', {
            lufs_target: genreTargets.lufs_target,
            true_peak_target: genreTargets.true_peak_target,
            dr_target: genreTargets.dr_target,
            lra_target: genreTargets.lra_target,
            stereo_target: genreTargets.stereo_target,
            bands: genreTargets.bands ? 'presente' : 'ausente'
        });
    }
    
    // 🎯 FALLBACK 3: Carregar targets padrão se nada funcionar
    if (!genreTargets) {
        console.warn('[GENRE-VIEW] ⚠️ Nenhum target encontrado - carregando defaults');
        genreTargets = loadDefaultGenreTargets(genre);
        // Salvar em analysis.data.genreTargets para uso posterior
        if (!analysis.data) analysis.data = {};
        analysis.data.genreTargets = genreTargets;
    }
    
    if (!genreTargets) {
        console.error('[GENRE-VIEW] ❌ CRÍTICO: Targets de gênero não disponíveis - ABORTANDO');
        console.error('[GENRE-VIEW]    window.PROD_AI_REF_DATA:', window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    window.__activeRefData:', window.__activeRefData);
        console.error('[GENRE-VIEW]    Tipo PROD_AI_REF_DATA:', typeof window.PROD_AI_REF_DATA);
        console.error('[GENRE-VIEW]    analysis.referenceComparison:', analysis.referenceComparison);
        console.error('[GENRE-VIEW] 🔍 DIAGNÓSTICO: Verificar se targets foram carregados antes de displayModalResults');
        console.groupEnd();
        return; // ❌ ABORTAR se não houver targets
    } else {
        console.log('[GENRE-VIEW] 5️⃣ Targets encontrados:', {
            hasBands: !!genreTargets?.bands,
            bandsCount: genreTargets?.bands ? Object.keys(genreTargets.bands).length : 0,
            hasLegacyCompatibility: !!genreTargets?.legacy_compatibility,
            hasLufsTarget: genreTargets?.lufs_target !== undefined,
            bandas: genreTargets?.bands ? Object.keys(genreTargets.bands) : 'N/A'
        });
    }
    
    // 7️⃣ Renderizar tabela de comparação de gênero
    console.log('[GENRE-VIEW] 6️⃣ Renderizando tabela de comparação...');
    console.log('[GENRE-VIEW] 🎯 GARANTIA: Chamando renderGenreComparisonTable com targets validados');
    console.log('[GENRE-VIEW] 🔍 AUDIT: Targets sendo passados:', {
        hasHybridProcessing: !!genreTargets?.hybrid_processing,
        hasSpectralBands: !!genreTargets?.hybrid_processing?.spectral_bands,
        spectralBandsKeys: genreTargets?.hybrid_processing?.spectral_bands ? Object.keys(genreTargets.hybrid_processing.spectral_bands) : 'N/A'
    });
    
    renderGenreComparisonTable({
        analysis,
        genre,
        targets: genreTargets
    });
    
    console.log('[GENRE-VIEW] 🎯 GARANTIA: renderGenreComparisonTable executado');
    console.log('[GENRE-VIEW] 🔍 AUDIT: Verificando se #referenceComparisons foi preenchido...');
    
    const refCompContainer = document.getElementById('referenceComparisons');
    if (refCompContainer) {
        console.log('[GENRE-VIEW] ✅ Container encontrado:', {
            innerHTML: refCompContainer.innerHTML.length > 0 ? `${refCompContainer.innerHTML.length} chars` : 'VAZIO',
            display: window.getComputedStyle(refCompContainer).display,
            visibility: window.getComputedStyle(refCompContainer).visibility,
            opacity: window.getComputedStyle(refCompContainer).opacity
        });
    } else {
        console.error('[GENRE-VIEW] ❌ Container #referenceComparisons NÃO ENCONTRADO!');
    }
    
    console.log('%c[GENRE-VIEW] ✅ Renderização de gênero concluída', 'color:#00FF88;font-weight:bold;');
    console.groupEnd();
}

/**
 * 🎯 HELPER: Aplicar controle de realismo de masterização nas ações sugeridas
 * Garante que nenhuma sugestão mostre ajustes maiores que ±5 dB
 * 
 * @param {number} realDiff - Diferença real calculada (em dB)
 * @param {string} direction - 'increase' ou 'decrease'
 * @param {string} emoji - Emoji de severidade (🔴, 🟡, ⚠️, etc)
 * @returns {string} - Texto realista da ação sugerida
 */
function buildRealisticAction(realDiff, direction, emoji) {
    const absDiff = Math.abs(realDiff);
    
    // 🎯 CLAMP: Valores acima de ±5 dB devem ser expressos de forma genérica
    if (absDiff > 5.0) {
        if (direction === 'decrease') {
            return `${emoji} Reduzir suavemente (≈ −2 a −5 dB)`;
        } else {
            return `${emoji} Aumentar levemente (≈ +2 a +5 dB)`;
        }
    }
    
    // 🎯 RANGE MÉDIO: Mostrar valor aproximado ou range
    if (absDiff >= 1.0 && absDiff <= 5.0) {
        const roundedDiff = Math.round(absDiff * 2) / 2; // Arredondar para 0.5 dB
        if (direction === 'decrease') {
            return `${emoji} Reduzir ${roundedDiff.toFixed(1)} dB`;
        } else {
            return `${emoji} Aumentar ${roundedDiff.toFixed(1)} dB`;
        }
    }
    
    // 🎯 AJUSTE FINO: Valores abaixo de 1 dB
    if (absDiff < 1.0) {
        if (direction === 'decrease') {
            return `${emoji} Reduzir levemente (≈ −${absDiff.toFixed(1)} dB)`;
        } else {
            return `${emoji} Aumentar levemente (≈ +${absDiff.toFixed(1)} dB)`;
        }
    }
    
    // Fallback (não deveria chegar aqui)
    return `${emoji} Ajustar conforme necessário`;
}

/**
 * 🎯 HELPER: Verificar se a métrica é uma banda espectral (EQ/frequência)
 * Usado para aplicar controle de realismo APENAS em bandas espectrais
 * 
 * @param {string} metricKey - Chave da métrica (sub, bass, lufs, dr, etc)
 * @returns {boolean} - true se for banda espectral, false caso contrário
 */
function isSpectralBand(metricKey) {
    const SPECTRAL_BANDS = [
        'sub', 'bass', 'low_bass', 'upperBass', 'upper_bass',
        'lowMid', 'low_mid', 'mid', 'highMid', 'high_mid',
        'presence', 'presenca', 'air', 'brilho'
    ];
    return SPECTRAL_BANDS.includes(metricKey);
}

function renderGenreComparisonTable(options) {
    const { analysis, genre, targets } = options;
    
    console.group('[GENRE-TABLE] 📊 RENDERIZAÇÃO COMPLETA DE GÊNERO');
    console.log('[GENRE-TABLE] 🎯 Gênero:', genre);
    console.log('[GENRE-TABLE] 📁 Targets recebidos (parâmetro):', targets);
    
    // 🆕 LOG DE DIAGNÓSTICO STREAMING MODE
    console.log('[GENRE-TABLE] 📡 STREAMING DIAGNÓSTICO:', {
        soundDestination: analysis?.soundDestination,
        'analysis.data.genreTargets.lufs_target': analysis?.data?.genreTargets?.lufs_target,
        'analysis.data.genreTargets.true_peak_target': analysis?.data?.genreTargets?.true_peak_target,
        'targets.lufs_target': targets?.lufs_target,
        'targets.true_peak_target': targets?.true_peak_target,
        isStreaming: analysis?.soundDestination === 'streaming'
    });
    
    // 🛡️ GUARD: Apenas para modo gênero
    if (analysis?.mode !== 'genre') {
        console.warn('[GENRE-TABLE] ⏭️ Modo não é gênero, abortando renderização');
        console.groupEnd();
        return;
    }
    
    // Buscar container
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('[GENRE-TABLE] ❌ Container #referenceComparisons não encontrado!');
        console.groupEnd();
        return;
    }
    
    // � STREAMING OVERRIDE: Aplicar targets de streaming se necessário
    let genreData = applyStreamingOverride(targets);
    console.log('[GENRE-TABLE] 🎯 Targets após streaming check:', {
        lufs_target: genreData?.lufs_target,
        true_peak_target: genreData?.true_peak_target,
        mode: getSoundDestinationMode()
    });
    
    console.log('[GENRE-TABLE] 📦 Genre data recebido (flat object):', Object.keys(genreData || {}));
    
    if (!genreData) {
        console.error('[GENRE-TABLE] ❌ CRÍTICO: Nenhum target disponível!');
        console.error('[GENRE-TABLE]    - analysis.data.genreTargets:', !!analysis?.data?.genreTargets);
        console.error('[GENRE-TABLE]    - targets parameter:', !!targets);
        console.groupEnd();
        return;
    }
    
    console.log('[GENRE-TABLE] 📦 Genre data:', {
        lufs_target: genreData.lufs_target,
        true_peak_target: genreData.true_peak_target,
        dr_target: genreData.dr_target,
        lra_target: genreData.lra_target,
        stereo_target: genreData.stereo_target,
        tol_lufs: genreData.tol_lufs,
        tol_true_peak: genreData.tol_true_peak,
        tol_dr: genreData.tol_dr,
        tol_lra: genreData.tol_lra,
        tol_stereo: genreData.tol_stereo,
        hasBands: !!genreData.bands
    });
    
    // 🎯 EXTRAIR VALORES DO ANALYSIS (mesmas fontes usadas em calculateScore)
    const lufsIntegrated = analysis.loudness?.integrated ?? analysis.technicalData?.lufsIntegrated ?? null;
    const truePeakDbtp = analysis.truePeakDbtp ?? analysis.truePeak?.maxDbtp ?? analysis.technicalData?.truePeakDbtp ?? null;
    const dynamicRange = analysis.dynamicRange ?? analysis.dynamics?.range ?? analysis.technicalData?.dynamicRange ?? null;
    const lra = analysis.lra ?? analysis.loudness?.lra ?? analysis.technicalData?.lra ?? null;
    const stereoCorrelation = analysis.stereoCorrelation ?? analysis.stereo?.correlation ?? analysis.technicalData?.stereoCorrelation ?? null;
    
    console.log('[GENRE-TABLE] 📊 Valores extraídos do analysis:', {
        lufsIntegrated,
        truePeakDbtp,
        dynamicRange,
        lra,
        stereoCorrelation
    });
    
    // 🎯 CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode não existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const userBands = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    console.log('[GENRE-TABLE] 🎵 Fonte de bandas do usuário:', 
        technicalBands ? '✅ technicalData.bands (prioridade 1)' : 
        centralizedBands ? '⚠️ metrics.bands (fallback 2)' : 
        spectralBalance ? '⚠️ spectral_balance (fallback 3)' : 
        '⚠️ bandEnergies (fallback 4 - legado)');
    
    console.log('[GENRE-TABLE] 🎵 Bandas disponíveis:', userBands ? Object.keys(userBands) : 'NENHUMA');
    
    console.log('[GENRE-TABLE] 🎵 Bandas do usuário:', userBands ? Object.keys(userBands) : 'N/A');
    
    // 🎯 PATCH: Aceitar 'bands' (normalizado) OU 'spectral_bands' (com underscore) com normalização
    const targetBands = (() => {

        // 🎯 PRIORIDADE 1: spectral_bands (estrutura correta do JSON com snake_case)
        if (genreData.spectral_bands && typeof genreData.spectral_bands === 'object' && Object.keys(genreData.spectral_bands).length > 0) {
            console.log('[GENRE-TABLE] 🎯 Usando genreData.spectral_bands (normalizando)');
            
            // Normalizar chaves de snake_case → camelCase
            const normalized = {};
            Object.keys(genreData.spectral_bands).forEach(snakeKey => {
                const camelKey = normalizeGenreBandName(snakeKey);
                normalized[camelKey] = genreData.spectral_bands[snakeKey];
            });
            
            console.log('[GENRE-TABLE] 🎯 Bandas normalizadas:', Object.keys(normalized));
            return normalized;
        }

        // 🎯 PRIORIDADE 2: bands (já normalizado via enrichReferenceObject)
        if (genreData.bands && Object.keys(genreData.bands).length > 0) {
            console.log('[GENRE-TABLE] 🎯 Usando genreData.bands (já normalizado)');
            return genreData.bands;
        }

        // 🎯 FALLBACK: extrair bandas da raiz (compatibilidade legado)
        const bandsFromRoot = {};
        const metricKeys = [
            'lufs_target','true_peak_target','dr_target','lra_target','stereo_target',
            'tol_lufs','tol_true_peak','tol_dr','tol_lra','tol_stereo'
        ];

        Object.keys(genreData).forEach(key => {
            const value = genreData[key];

            // Se é um objeto, não está na lista de métricas e possui target_db = é banda válida
            if (typeof value === 'object' && value !== null && 
                !metricKeys.includes(key) &&
                (value.target_db !== undefined || value.target !== undefined)
            ) {
                // Normalizar chave de snake_case → camelCase
                const normalizedKey = normalizeGenreBandName(key);
                bandsFromRoot[normalizedKey] = value;
            }
        });

        console.log('[GENRE-TABLE] 🎯 Bandas extraídas da raiz (normalizadas):', Object.keys(bandsFromRoot));
        return bandsFromRoot;
    })();
    
    console.log('[GENRE-TABLE] 🎯 Target bands (source):', genreData.bands ? 'bands' : (genreData.spectralBands ? 'spectralBands' : 'ROOT'));
    console.log('[GENRE-TABLE] 🎯 Target bands (keys):', Object.keys(targetBands));
    
    // 🎯 HELPER: Calcular severidade e ação baseado em diferença e tolerância
    const calcSeverity = (value, target, tolerance, options = {}) => {
        const { targetRange } = options;
        
        if (!Number.isFinite(value)) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        // 🎯 NOVA LÓGICA: Priorizar target_range se existir
        if (targetRange && typeof targetRange === 'object') {
            // Suportar ambos formatos: { min, max } ou { min_db, max_db }
            const min = targetRange.min ?? targetRange.min_db;
            const max = targetRange.max ?? targetRange.max_db;
            
            if (typeof min !== 'number' || typeof max !== 'number') {
                // Range inválido, usar fallback
                if (target === null || target === undefined) {
                    return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
                }
            } else {
                // ✅ Valor dentro do range
                if (value >= min && value <= max) {
                    return { severity: 'OK', severityClass: 'ok', action: '✅ Dentro do padrão', diff: 0 };
                }
                
                // ❌ Valor fora do range: calcular distância até borda mais próxima
                let diff;
                let absDelta;
                if (value < min) {
                    diff = value - min;  // negativo (precisa subir)
                    absDelta = min - value;
                } else {
                    diff = value - max;  // positivo (precisa descer)
                    absDelta = value - max;
                }
                
                // Thresholds para severidade baseados na distância
                // 🎯 CONTROLE DE REALISMO: Usar buildRealisticAction APENAS para bandas espectrais
                if (absDelta >= 2) {
                    const direction = diff > 0 ? 'decrease' : 'increase';
                    const action = buildRealisticAction(absDelta, direction, '🔴');
                    return { severity: 'CRÍTICA', severityClass: 'critical', action, diff };
                } else {
                    const direction = diff > 0 ? 'decrease' : 'increase';
                    const action = buildRealisticAction(absDelta, direction, '⚠️');
                    return { severity: 'ATENÇÃO', severityClass: 'caution', action, diff };
                }
            }
        }
        
        // 🔄 FALLBACK: Lógica antiga com target fixo (para métricas sem range)
        if (target === null || target === undefined) {
            return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
        }
        
        const diff = value - target;
        const absDiff = Math.abs(diff);
        
        if (absDiff <= tolerance) {
            return { severity: 'OK', severityClass: 'ok', action: '✅ Dentro do padrão', diff };
        } else if (absDiff <= tolerance * 2) {
            const action = diff > 0 ? `⚠️ Reduzir ${absDiff.toFixed(1)}` : `⚠️ Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ATENÇÃO', severityClass: 'caution', action, diff };
        } else if (absDiff <= tolerance * 3) {
            const action = diff > 0 ? `🟡 Reduzir ${absDiff.toFixed(1)}` : `🟡 Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'ALTA', severityClass: 'warning', action, diff };
        } else {
            const action = diff > 0 ? `🔴 Reduzir ${absDiff.toFixed(1)}` : `🔴 Aumentar ${absDiff.toFixed(1)}`;
            return { severity: 'CRÍTICA', severityClass: 'critical', action, diff };
        }
    };
    
    // Construir linhas da tabela
    const rows = [];
    let metricsCount = 0;
    let bandsCount = 0;
    
    // ════════════════════════════════════════════════════════════════════
    // 1️⃣ MÉTRICAS PRINCIPAIS (LUFS, TRUE PEAK, DR, LRA, STEREO)
    // ════════════════════════════════════════════════════════════════════
    
    // 🔊 LUFS Integrado
    if (genreData.lufs_target !== null && genreData.lufs_target !== undefined) {
        const lufsValue = lufsIntegrated;
        if (Number.isFinite(lufsValue) && Number.isFinite(genreData.lufs_target)) {
            const result = calcSeverity(lufsValue, genreData.lufs_target, genreData.tol_lufs || 1.0);
            if (result && Number.isFinite(result.diff)) {
                // 🔐 SECURITY GUARD: Verificar se deve renderizar valor real
                const canRender = shouldRenderRealValue('lufsIntegrated', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">🔊 Loudness (LUFS Integrado)</td>
                        <td class="metric-value">${canRender ? lufsValue.toFixed(2) + ' LUFS' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.lufs_target.toFixed(1) + ' LUFS' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} LUFS: ${lufsValue.toFixed(2)} | Target: ${genreData.lufs_target} | ${result.severity}`);
            }
        }
    }
    
    // 🎚️ True Peak
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🚨 REGRA ABSOLUTA: TRUE PEAK > 0.0 dBTP = CRÍTICA SEMPRE
    // Esta regra NÃO pode ser sobrescrita por tolerância ou target do gênero
    // ═══════════════════════════════════════════════════════════════════════════════
    const TRUE_PEAK_HARD_CAP = 0.0; // dBTP - Limite máximo ABSOLUTO
    
    if (genreData.true_peak_target !== null && genreData.true_peak_target !== undefined) {
        const tpValue = truePeakDbtp;
        if (Number.isFinite(tpValue) && Number.isFinite(genreData.true_peak_target)) {
            let result;
            const tpTarget = genreData.true_peak_target;  // ✅ SSOT: target do gênero
            
            // 🚨 HARD LIMIT: TP > 0.0 = CRÍTICA (ignora tolerância)
            // 🔧 FIX: Ação usa deltaToTarget (não hardCap) para consistência com coluna "Diferença"
            if (tpValue > TRUE_PEAK_HARD_CAP) {
                const deltaToTarget = tpValue - tpTarget;  // ✅ SSOT: sempre usa target do gênero
                result = {
                    severity: 'CRÍTICA',
                    severityClass: 'critical',
                    action: `🔴 CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dB`,
                    diff: deltaToTarget
                };
                console.log('[GENRE-TABLE] 🚨 TRUE PEAK CRÍTICO: TP > 0.0 dBTP detectado:', tpValue, '| deltaToTarget:', deltaToTarget);
            } else {
                // Lógica normal para TP <= 0.0
                result = calcSeverity(tpValue, genreData.true_peak_target, genreData.tol_true_peak || 0.5);
            }
            
            if (result && Number.isFinite(result.diff)) {
                // 🔐 SECURITY GUARD
                const canRender = shouldRenderRealValue('truePeak', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">🎚️ Pico Real (dBTP)</td>
                        <td class="metric-value">${canRender ? tpValue.toFixed(2) + ' dBTP' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.true_peak_target.toFixed(1) + ' dBTP' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} True Peak: ${tpValue.toFixed(2)} | Target: ${genreData.true_peak_target} | ${result.severity}`);
            }
        }
    }
    
    // 📊 Dynamic Range (DR)
    if (genreData.dr_target !== null && genreData.dr_target !== undefined) {
        const drValue = dynamicRange;
        if (Number.isFinite(drValue) && Number.isFinite(genreData.dr_target)) {
            const result = calcSeverity(drValue, genreData.dr_target, genreData.tol_dr || 1.0);
            if (result && Number.isFinite(result.diff)) {
                // 🔐 SECURITY GUARD (DR é LIBERADO)
                const canRender = shouldRenderRealValue('dr', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">📊 Dinâmica (DR)</td>
                        <td class="metric-value">${canRender ? drValue.toFixed(2) + ' DR' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.dr_target.toFixed(1) + ' DR' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} DR: ${drValue.toFixed(2)} | Target: ${genreData.dr_target} | ${result.severity}`);
            }
        }
    }
    
    // 📈 Loudness Range (LRA)
    if (genreData.lra_target !== null && genreData.lra_target !== undefined) {
        const lraValue = lra;
        if (Number.isFinite(lraValue) && Number.isFinite(genreData.lra_target)) {
            const result = calcSeverity(lraValue, genreData.lra_target, genreData.tol_lra || 2.0);
            if (result && Number.isFinite(result.diff)) {
                // 🔐 SECURITY GUARD (LRA é BLOQUEADO)
                const canRender = shouldRenderRealValue('lra', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">📈 LRA (Faixa de Loudness)</td>
                        <td class="metric-value">${canRender ? lraValue.toFixed(2) + ' LU' : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.lra_target.toFixed(1) + ' LU' : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(2) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} LRA: ${lraValue.toFixed(2)} | Target: ${genreData.lra_target} | ${result.severity}`);
            }
        }
    }
    
    // 🎧 Stereo Correlation
    if (genreData.stereo_target !== null && genreData.stereo_target !== undefined) {
        const stereoValue = stereoCorrelation;
        if (Number.isFinite(stereoValue) && Number.isFinite(genreData.stereo_target)) {
            const result = calcSeverity(stereoValue, genreData.stereo_target, genreData.tol_stereo || 0.1);
            if (result && Number.isFinite(result.diff)) {
                // 🔐 SECURITY GUARD (Stereo é LIBERADO)
                const canRender = shouldRenderRealValue('stereo', 'table', analysis);
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">🎧 Imagem Estéreo</td>
                        <td class="metric-value">${canRender ? stereoValue.toFixed(3) : renderSecurePlaceholder('value')}</td>
                        <td class="metric-target">${canRender ? genreData.stereo_target.toFixed(3) : renderSecurePlaceholder('target')}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${canRender ? (result.diff >= 0 ? '+' : '') + result.diff.toFixed(3) : renderSecurePlaceholder('diff')}</td>
                        <td class="metric-severity ${result.severityClass}">${canRender ? result.severity : renderSecurePlaceholder('severity')}</td>
                        <td class="metric-action ${result.severityClass}">${canRender ? result.action : renderSecurePlaceholder('action')}</td>
                    </tr>
                `);
                metricsCount++;
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} Stereo: ${stereoValue.toFixed(3)} | Target: ${genreData.stereo_target} | ${result.severity}`);
            }
        }
    }
    
    // ════════════════════════════════════════════════════════════════════
    // 2️⃣ BANDAS ESPECTRAIS
    // ════════════════════════════════════════════════════════════════════
    
    // 🎯 PATCH: Usar nomenclatura NORMALIZADA (camelCase) igual ao backend
    const nomesBandas = {
        sub: '🔉 Sub (20-60 Hz)',
        bass: '🔊 Bass (60-120 Hz)',           // ← low_bass normalizado
        upperBass: '🔊 Upper Bass (120-250 Hz)', // ← upper_bass normalizado
        lowMid: '🎵 Low Mid (250-500 Hz)',      // ← low_mid normalizado
        mid: '🎵 Mid (500-2k Hz)',
        highMid: '🎸 High Mid (2k-4k Hz)',      // ← high_mid normalizado
        presence: '💎 Presença (10k-20k Hz)',   // ← presenca normalizado
        air: '✨ Brilho (4k-10k Hz)',           // ← brilho normalizado
        // Compatibilidade com nomes legados (snake_case)
        low_bass: '🔊 Bass (60-120 Hz)',
        upper_bass: '🔊 Upper Bass (120-250 Hz)',
        low_mid: '🎵 Low Mid (250-500 Hz)',
        high_mid: '🎸 High Mid (2k-4k Hz)',
        presenca: '💎 Presença (10k-20k Hz)',
        brilho: '✨ Brilho (4k-10k Hz)'
    };
    
    // 🎯 ITERAR APENAS SOBRE BANDAS QUE EXISTEM NOS DOIS LADOS (target-driven)
    // Previne erro: "Cannot read properties of undefined (reading 'toFixed')"
    if (targetBands && Object.keys(targetBands).length > 0) {
        Object.keys(targetBands).forEach(targetKey => {
            try {
                // 🛡️ PROTEÇÃO #1: Verificar se target tem estrutura válida
                const targetBand = targetBands[targetKey];
                if (!targetBand || typeof targetBand !== 'object') {
                    console.log(`[GENRE-TABLE] ⏭️ Pulando banda com target inválido: ${targetKey}`);
                    return;
                }
                
                // 🛡️ PROTEÇÃO #2: Validar se existe valor target (range ou db)
                const hasRange = targetBand.target_range 
                    && (typeof targetBand.target_range.min === 'number' || typeof targetBand.target_range.min_db === 'number')
                    && (typeof targetBand.target_range.max === 'number' || typeof targetBand.target_range.max_db === 'number');
                const hasTargetDb = typeof targetBand.target_db === 'number';
                
                if (!hasRange && !hasTargetDb) {
                    console.log(`[GENRE-TABLE] ⏭️ Pulando banda sem target válido: ${targetKey}`);
                    return;
                }
                
                // 🔄 NORMALIZAR nome da banda para buscar no userBands
                // targetKey já está normalizado (camelCase), procurar no userBands
                const bandData = userBands?.[targetKey];
                
                // 🛡️ PROTEÇÃO #3: Verificar se usuário tem essa banda
                if (!bandData) {
                    console.log(`[GENRE-TABLE] ⏭️ Pulando banda sem dados do usuário: ${targetKey}`);
                    return;
                }
                
                // 🛡️ PROTEÇÃO #4: Extrair valor numérico com fallbacks seguros
                let energyDb = null;
                if (typeof bandData === 'number') {
                    energyDb = bandData;
                } else if (typeof bandData === 'object') {
                    energyDb = bandData.energy_db ?? bandData.rms_db ?? bandData.db ?? null;
                }
                
                // 🛡️ PROTEÇÃO #5: Validar que energyDb é número finito
                if (!Number.isFinite(energyDb)) {
                    console.log(`[GENRE-TABLE] 🔇 Banda sem valor numérico válido: ${targetKey} (valor: ${energyDb})`);
                    return;
                }
                
                // 🎯 PRIORIZAR target_range (min/max) - IGNORAR tol_db
                const targetRange = hasRange ? targetBand.target_range : null;
                const targetValue = hasTargetDb ? targetBand.target_db : null;
                
                // ⚠️ NÃO USAR tol_db - apenas para compatibilidade com fallback legado
                // Range é a tolerância quando existir
                
                // 🧮 Calcular severidade com suporte a range
                const result = calcSeverity(energyDb, targetValue, 2.0, { targetRange });
                
                // 🛡️ PROTEÇÃO #6: Validar resultado antes de usar
                if (!result || typeof result.diff !== 'number') {
                    console.warn(`[GENRE-TABLE] ⚠️ Resultado de severidade inválido para: ${targetKey}`);
                    return;
                }
                
                // 🎨 Formatar coluna ALVO: mostrar range se existir, senão target fixo
                let targetLabel;
                if (targetRange) {
                    // Suportar ambos formatos: { min, max } ou { min_db, max_db }
                    const minValue = targetRange.min ?? targetRange.min_db;
                    const maxValue = targetRange.max ?? targetRange.max_db;
                    const minSafe = Number.isFinite(minValue) ? minValue.toFixed(1) : '?';
                    const maxSafe = Number.isFinite(maxValue) ? maxValue.toFixed(1) : '?';
                    targetLabel = `${minSafe} dB a ${maxSafe} dB`;
                } else if (targetValue !== null) {
                    targetLabel = `${targetValue.toFixed(1)} dB`;
                } else {
                    targetLabel = '—';
                }
                
                const nomeAmigavel = nomesBandas[targetKey] || targetKey;
                
                // � SECURITY GUARD: Verificar se banda deve ser renderizada
                const canRender = shouldRenderRealValue(targetKey, 'table', analysis);
                
                // 🛡️ PROTEÇÃO #7: Usar valores seguros em .toFixed()
                const energyDbSafe = canRender && Number.isFinite(energyDb) ? energyDb.toFixed(2) + ' dB' : renderSecurePlaceholder('value');
                const targetLabelSafe = canRender ? targetLabel : renderSecurePlaceholder('target');
                const diffSafe = canRender && Number.isFinite(result.diff) ? result.diff.toFixed(2) : '0.00';
                const diffSign = result.diff >= 0 ? '+' : '';
                const diffDisplay = canRender ? `${diffSign}${diffSafe} dB` : renderSecurePlaceholder('diff');
                const severityDisplay = canRender ? result.severity : renderSecurePlaceholder('severity');
                const actionDisplay = canRender ? result.action : renderSecurePlaceholder('action');
                
                rows.push(`
                    <tr class="genre-row ${result.severityClass}">
                        <td class="metric-name">${nomeAmigavel}</td>
                        <td class="metric-value">${energyDbSafe}</td>
                        <td class="metric-target">${targetLabelSafe}</td>
                        <td class="metric-diff ${result.diff >= 0 ? 'positive' : 'negative'}">${diffDisplay}</td>
                        <td class="metric-severity ${result.severityClass}">${severityDisplay}</td>
                        <td class="metric-action ${result.severityClass}">${actionDisplay}</td>
                    </tr>
                `);
                bandsCount++;
                
                // Log mais informativo mostrando range quando disponível
                const targetInfo = targetRange 
                    ? `[${(targetRange.min ?? targetRange.min_db).toFixed(1)}, ${(targetRange.max ?? targetRange.max_db).toFixed(1)}]` 
                    : (targetValue !== null ? targetValue.toFixed(1) : 'N/A');
                console.log(`[GENRE-TABLE] ${canRender ? '✅' : '🔒'} ${nomeAmigavel}: ${energyDb.toFixed(2)} dB | Target: ${targetInfo} | ${result.severity}`);
                
            } catch (err) {
                // 🛡️ PROTEÇÃO #8: Capturar qualquer erro e continuar com próxima banda
                console.warn(`[GENRE-TABLE][SAFE-FAIL] Erro ao processar banda ${targetKey}:`, err.message);
                return; // Pular essa banda e continuar com as outras
            }
        });
    }
    
    // Renderizar HTML completo
    // 🆕 STREAMING MODE: Verificar se é análise streaming e adicionar badge
    const isStreamingMode = analysis.soundDestination === 'streaming';
    const targetColumnHeader = isStreamingMode 
        ? 'Alvo <span class="streaming-badge" title="Targets otimizados para Streaming (LUFS -14, TP -1.0)">📡</span>'
        : 'Alvo';
    
    const tableHTML = `
        <div class="card genre-comparison-classic" style="margin-top:12px;">
            <div class="card-title">COMPARAÇÃO COM ${genre.toUpperCase()}${isStreamingMode ? ' <span class="streaming-mode-label">📡 Streaming</span>' : ''}</div>
            <table class="classic-genre-table">
                <thead>
                    <tr>
                        <th>Métrica</th>
                        <th>Valor</th>
                        <th>${targetColumnHeader}</th>
                        <th>Diferença</th>
                        <th>Severidade</th>
                        <th>Ação Sugerida</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows.join('')}
                </tbody>
            </table>
        </div>
    `;
    
    // 🔥 AUDITORIA CRÍTICA: Verificar container ANTES de inserir HTML
    console.log('[GENRE-TABLE-AUDIT] 🔍 ANTES de innerHTML:', {
        containerExists: !!container,
        containerVisible: container ? window.getComputedStyle(container).display : 'N/A',
        containerOpacity: container ? window.getComputedStyle(container).opacity : 'N/A',
        containerParent: container ? container.parentElement?.id : 'N/A',
        tableHTMLLength: tableHTML.length,
        rowsCount: rows.length
    });
    
    try {
        container.innerHTML = tableHTML;
        
        // 🔥 AUDITORIA CRÍTICA: Verificar container DEPOIS de inserir HTML
        console.log('[GENRE-TABLE-AUDIT] 🔍 DEPOIS de innerHTML:', {
            containerInnerHTMLLength: container.innerHTML.length,
            containerFirstChild: container.firstChild ? container.firstChild.className : 'N/A',
            tableExists: !!container.querySelector('.classic-genre-table'),
            rowsInDOM: container.querySelectorAll('tr').length
        });
    } catch (err) {
        console.error('[GENRE-TABLE-ERROR] ❌ Erro ao inserir HTML:', err);
        container.innerHTML = `<div class="error-message">❌ Erro ao renderizar tabela: ${err.message}</div>`;
    }
    
    // Forçar visibilidade
    container.classList.remove('hidden');
    container.style.display = 'block';
    container.style.visibility = 'visible';
    container.style.opacity = '1';
    
    // 🔥 AUDITORIA FINAL: Verificar visibilidade computada
    const computedStyle = window.getComputedStyle(container);
    console.log('[GENRE-TABLE-AUDIT] 🔍 VISIBILIDADE FINAL:', {
        display: computedStyle.display,
        visibility: computedStyle.visibility,
        opacity: computedStyle.opacity,
        height: computedStyle.height,
        overflow: computedStyle.overflow
    });
    
    // 🎨 INJETAR ESTILOS CSS PARA TABELA CLÁSSICA DE GÊNERO (branch imersao)
    if (!document.getElementById('classicGenreTableStyles')) {
        const style = document.createElement('style');
        style.id = 'classicGenreTableStyles';
        style.textContent = `
            /* 🎯 TABELA CLÁSSICA DE GÊNERO */
            .genre-comparison-classic {
                background: linear-gradient(135deg, rgba(14, 20, 34, 0.95), rgba(31, 43, 64, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 16px;
                padding: 24px;
                margin-top: 16px;
            }
            
            .classic-genre-table {
                width: 100%;
                border-collapse: collapse;
                table-layout: fixed;
                font-size: 13px;
            }
            
            .classic-genre-table thead {
                background: rgba(0, 102, 255, 0.15);
                border-bottom: 2px solid rgba(36, 157, 255, 0.4);
            }
            
            .classic-genre-table th {
                font-weight: 600;
                padding: 12px 16px;
                text-align: center;
                font-size: 12px;
                color: #00f0ff;
                letter-spacing: 0.5px;
                text-transform: uppercase;
            }
            
            .classic-genre-table th:first-child {
                text-align: left;
                width: 20%;
            }
            
            .classic-genre-table th:nth-child(2) { width: 14%; }
            .classic-genre-table th:nth-child(3) { width: 14%; }
            .classic-genre-table th:nth-child(4) { width: 14%; }
            .classic-genre-table th:nth-child(5) { width: 14%; }
            .classic-genre-table th:nth-child(6) { width: 24%; }
            
            .classic-genre-table td {
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                color: #f5f7fa;
                text-align: center;
            }
            
            .classic-genre-table td:first-child {
                text-align: left;
                font-weight: 500;
            }
            
            .classic-genre-table tr:last-child td {
                border-bottom: 0;
            }
            
            .classic-genre-table tbody tr:hover {
                background: rgba(255, 255, 255, 0.05);
            }
            
            /* 🎨 CORES DE SEVERIDADE */
            .classic-genre-table .genre-row.ok {
                background: rgba(82, 247, 173, 0.08);
            }
            
            .classic-genre-table .genre-row.caution {
                background: rgba(255, 206, 77, 0.08);
            }
            
            .classic-genre-table .genre-row.warning {
                background: rgba(255, 165, 0, 0.08);
            }
            
            .classic-genre-table .genre-row.critical {
                background: rgba(255, 123, 123, 0.08);
            }
            
            .classic-genre-table .metric-severity.ok {
                color: #52f7ad;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.caution {
                color: #ffce4d;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.warning {
                color: #ffa500;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-severity.critical {
                color: #ff7b7b;
                font-weight: 600;
            }
            
            .classic-genre-table .metric-action {
                font-size: 12px;
            }
            
            .classic-genre-table .metric-diff.positive {
                color: #ffa500;
            }
            
            .classic-genre-table .metric-diff.negative {
                color: #00d4ff;
            }
            
            /* 🎯 MOBILE RESPONSIVO - TABELA GÊNERO */
            @media (max-width: 768px) {
                .genre-comparison-classic {
                    padding: 12px !important;
                    border-radius: 12px !important;
                    overflow-x: hidden !important;
                }
                
                .classic-genre-table {
                    table-layout: fixed !important;
                    width: 100% !important;
                    font-size: 10px !important;
                    overflow-x: auto !important;
                    display: block !important;
                }
                
                .classic-genre-table thead,
                .classic-genre-table tbody,
                .classic-genre-table tr {
                    display: table !important;
                    width: 100% !important;
                    table-layout: fixed !important;
                }
                
                .classic-genre-table th {
                    padding: 8px 4px !important;
                    font-size: 9px !important;
                    letter-spacing: 0.3px !important;
                    line-height: 1.2 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table td {
                    padding: 8px 4px !important;
                    font-size: 10px !important;
                    line-height: 1.3 !important;
                    word-wrap: break-word !important;
                }
                
                .classic-genre-table th:nth-child(1),
                .classic-genre-table td:nth-child(1) {
                    width: 22% !important;
                    text-align: left !important;
                }
                
                .classic-genre-table th:nth-child(2),
                .classic-genre-table td:nth-child(2),
                .classic-genre-table th:nth-child(3),
                .classic-genre-table td:nth-child(3),
                .classic-genre-table th:nth-child(4),
                .classic-genre-table td:nth-child(4) {
                    width: 14% !important;
                }
                
                .classic-genre-table th:nth-child(5),
                .classic-genre-table td:nth-child(5) {
                    width: 15% !important;
                }
                
                .classic-genre-table th:nth-child(6),
                .classic-genre-table td:nth-child(6) {
                    width: 21% !important;
                }
                
                .classic-genre-table td .icon,
                .classic-genre-table td i,
                .classic-genre-table td svg {
                    width: 12px !important;
                    height: 12px !important;
                    font-size: 12px !important;
                }
                
                .classic-genre-table .metric-severity {
                    font-size: 9px !important;
                    font-weight: 600 !important;
                }
                
                .classic-genre-table .metric-action {
                    font-size: 9px !important;
                }
                
                .classic-genre-table .metric-diff {
                    font-size: 9px !important;
                }
                
                .genre-comparison-classic .card-title {
                    font-size: 13px !important;
                    padding: 8px 0 !important;
                }
            }
            
            /* 🆕 STREAMING MODE BADGE */
            .streaming-badge {
                display: inline-block;
                font-size: 0.85em;
                margin-left: 4px;
                vertical-align: middle;
                cursor: help;
            }
            
            .streaming-mode-label {
                display: inline-block;
                background: linear-gradient(135deg, rgba(0, 200, 255, 0.2), rgba(0, 150, 255, 0.1));
                border: 1px solid rgba(0, 200, 255, 0.4);
                color: #00c8ff;
                font-size: 0.7em;
                padding: 2px 8px;
                border-radius: 12px;
                margin-left: 8px;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                vertical-align: middle;
            }
        `;
        document.head.appendChild(style);
        console.log('[GENRE-TABLE] 🎨 Estilos CSS injetados');
    }
    
    console.log('[GENRE-TABLE] ✅ Tabela COMPLETA renderizada:', {
        metricas: metricsCount,
        bandas: bandsCount,
        totalLinhas: rows.length
    });
    console.groupEnd();
}

// 🎯 NOVO: Atualizar step ativo no modo referência
function updateReferenceStep(step) {
    const steps = ['userAudio', 'referenceAudio', 'analysis'];
    const stepElements = {
        userAudio: document.getElementById('stepUserAudio'),
        referenceAudio: document.getElementById('stepReferenceAudio'),
        analysis: document.getElementById('stepAnalysis')
    };
    
    // Reset todos os steps
    Object.values(stepElements).forEach(el => {
        if (el) {
            el.classList.remove('active', 'completed');
        }
    });
    
    // Marcar steps anteriores como completed
    const currentIndex = steps.indexOf(step);
    for (let i = 0; i < currentIndex; i++) {
        const stepElement = stepElements[steps[i]];
        if (stepElement) {
            stepElement.classList.add('completed');
        }
    }
    
    // Marcar step atual como active
    const currentElement = stepElements[step];
    if (currentElement) {
        currentElement.classList.add('active');
    }
    
    referenceStepState.currentStep = step;
    
    window.logReferenceEvent('reference_step_updated', { step, currentIndex });
}

// ❌ Fechar modal de análise de áudio
function closeAudioModal() {
    __dbg('❌ Fechando modal de análise de áudio...');
    
    const modal = document.getElementById('audioAnalysisModal');
    if (modal) {
        modal.style.display = 'none';
        currentModalAnalysis = null;
        
        // 🚫 CRITICAL: Limpar globalmente também
        window.currentModalAnalysis = null;
        window.__CURRENT_ANALYSIS__ = null;
        
        // 🛡️ FIX 3: Verificar se está aguardando segunda track ou em modo reference
        const stateMachine = window.AnalysisStateMachine;
        const isAwaitingSecond = stateMachine?.isAwaitingSecondTrack?.();
        const currentMode = stateMachine?.getMode() || window.currentAnalysisMode;
        
        if (isAwaitingSecond) {
            console.warn('[REF_FIX] 🔒 closeAudioModal() - PRESERVANDO estado (awaitingSecondTrack)');
            console.log('[REF_FIX] Modal fechado mas estado Reference mantido');
            // NÃO chamar resetModalState nem destruir estado
            return; // Sai aqui sem destruir nada
        }
        
        if (currentMode === 'reference') {
            console.warn('[REF_FIX] 🔒 closeAudioModal() - PRESERVANDO estado (modo Reference)');
            console.log('[REF_FIX] referenceJobId e flags preservados');
            // NÃO resetar se ainda estiver em reference
            return;
        }
        
        // ✅ SEGURO: Só reseta se NÃO for reference e NÃO estiver aguardando
        resetModalState();
        console.log('[REF_FIX] closeAudioModal() - Reset normal (modo:', currentMode, ')');
        
        // 🔧 CORREÇÃO: Garantir que o modal pode ser usado novamente
        // Limpar cache de arquivos para forçar novo processamento
        const fileInput = document.getElementById('modalAudioFileInput');
        if (fileInput) {
            fileInput.value = ''; // Limpar input para permitir re-seleção do mesmo arquivo
        }
        
        // Resetar flags globais para próxima análise
        if (typeof window !== 'undefined') {
            delete window.__AUDIO_ADVANCED_READY__;
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        
        // 🔧 FIX: Verificar se há comparação ativa antes de limpar
        const hasActiveComparison = window.__referenceComparisonActive === true;
        
        // 🚨 BLINDAGEM: NÃO limpar FirstAnalysisStore em modo genre
        const isGenreMode = window.__CURRENT_MODE__ === 'genre';
        
        if (!hasActiveComparison && !isGenreMode) {
            // 🧹 LIMPEZA COMPLETA: Apenas se não houver comparação ativa E não for modo genre
            // 🔒 HARD-GUARD: Limpar FirstAnalysisStore (única fonte de verdade)
            FirstAnalysisStore.clear();
            
            // ❌ REMOVER: window.referenceAnalysisData agora é read-only (não pode ser setado)
            // Ele sempre aponta para FirstAnalysisStore.get(), que acabamos de limpar
            
            // Limpar Mode Engine
            SOUNDY_MODE_ENGINE.clear();
            
            referenceComparisonMetrics = null;
            window.lastReferenceJobId = null;
            
            // Limpar IDs de referência
            delete window.__REFERENCE_JOB_ID__;
            delete window.__FIRST_ANALYSIS_RESULT__;
            localStorage.removeItem('referenceJobId');
            
            console.log('[CLEANUP] closeAudioModal: LIMPEZA TOTAL (sem comparação ativa)');
            console.log('[CLEANUP] FirstAnalysisStore limpo - window.referenceAnalysisData agora retorna null');
        } else if (isGenreMode) {
            // Preservar gênero em modo genre
            console.log('[CLEANUP] closeAudioModal: PRESERVANDO gênero (modo genre)');
            console.log('[GENRE-PROTECT] ⚠️ Limpeza FirstAnalysisStore BLOQUEADA em modo genre');
            console.log('[GENRE-PROTECT]   - Preservando:', {
                selectedGenre: window.__CURRENT_SELECTED_GENRE,
                mode: window.__CURRENT_MODE__
            });
        } else {
            // Preservar dados de referência
            console.log('[CLEANUP] closeAudioModal: PRESERVANDO referência (comparação ativa)');
            console.log('[CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
            console.log('[CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
        }
        
        // Limpeza de state global (sempre limpar estado temporário de renderização)
        const state = window.__soundyState || {};
        if (state.reference) {
            state.reference.analysis = null;
            state.reference.isSecondTrack = false;
            // NÃO limpar jobId se houver comparação ativa
            if (!hasActiveComparison) {
                state.reference.jobId = null;
                state.reference.userAnalysis = null;
                state.reference.referenceAnalysis = null;
            }
        }
        
        // Limpar análises temporárias mas preservar previousAnalysis se necessário
        state.userAnalysis = null;
        state.referenceAnalysis = null;
        if (!hasActiveComparison) {
            state.previousAnalysis = null;
        }
        
        state.render = state.render || {};
        state.render.mode = null;
        
        window.__soundyState = state;
        
        __dbg('✅ Modal resetado e pronto para próxima análise');
    }
}

// 🔄 Reset estado do modal
/**
 * 🆕 NOVA FUNÇÃO: Limpa APENAS estado visual de upload
 * NÃO toca em gênero, targets ou localStorage
 * Usada ao abrir modal de análise (preserva seleção de gênero)
 */
function clearAudioOnlyState() {
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    const fileInput = document.getElementById('modalAudioFileInput');

    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    if (fileInput) fileInput.value = '';

    console.log('[AUDIO-RESET] ✅ Apenas estado de áudio foi limpo (gênero preservado)');
    console.log('[AUDIO-RESET] 📊 Gênero mantido:', {
        PROD_AI_REF_GENRE: window.PROD_AI_REF_GENRE,
        __CURRENT_SELECTED_GENRE: window.__CURRENT_SELECTED_GENRE,
        hasTargets: !!window.__activeRefData
    });
}

function resetModalState() {
    __dbg('🔄 Resetando estado do modal...');
    
    // �️ FIX 1: Verificar state machine primeiro, fallback para currentAnalysisMode
    const stateMachine = window.AnalysisStateMachine;
    const currentMode = stateMachine?.getMode() || window.currentAnalysisMode;
    
    // 🔒 Guard primário: NUNCA resetar em modo reference
    if (currentMode === 'reference') {
        console.warn('[REF_FIX] 🔒 resetModalState() BLOQUEADO - modo Reference ativo');
        console.log('[REF_FIX] Fonte:', stateMachine ? 'StateMachine' : 'currentAnalysisMode');
        return;
    }
    
    // 🔒 Guard secundário: NUNCA resetar se aguardando segunda track
    if (stateMachine?.isAwaitingSecondTrack?.()) {
        console.warn('[REF_FIX] 🔒 resetModalState() BLOQUEADO - aguardando segunda track');
        return;
    }
    
    // 🚨 BLINDAGEM: NUNCA resetar em modo genre (guard original)
    // FIX: Remover dependência de window.__CURRENT_MODE__ (variável fantasma)
    if (currentMode === 'genre') {
        console.warn('[GENRE-PROTECT] ⚠️ resetModalState() BLOQUEADO em modo genre');
        console.warn('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: currentMode
        });
        return; // NÃO executar reset
    }
    
    // ✅ CORREÇÃO: NÃO preservar gênero em modo reference
    // Isso estava causando contaminação de estado
    if (currentMode !== 'reference') {
        // 🔒 PATCH: PRESERVAR GÊNERO SOMENTE EM MODO GENRE
        preserveGenreState();
    } else {
        console.log('[REF_FIX] 🔒 preserveGenreState() BLOQUEADO - modo Reference não usa gênero');
    }
    
    // ===============================================================
    // 🔒 BLOCO 1 — PRESERVAR GÊNERO ANTES DO RESET
    // ===============================================================
    let __PRESERVED_GENRE__ = null;
    let __PRESERVED_TARGETS__ = null;

    // ✅ CORREÇÃO: Só preservar gênero se NÃO estiver em modo reference
    if (currentMode !== 'reference') {
        try {
            const genreSelect = document.getElementById("audioRefGenreSelect");

            __PRESERVED_GENRE__ =
                window.__CURRENT_SELECTED_GENRE ||
                window.PROD_AI_REF_GENRE ||
                (genreSelect ? genreSelect.value : null);
            
            __PRESERVED_TARGETS__ =
                window.__CURRENT_GENRE_TARGETS ||
                window.currentGenreTargets ||
                window.__activeRefData?.targets;

            console.log("[SAFE-RESET] ⚠️ Preservando gênero selecionado:", __PRESERVED_GENRE__);
            console.log("[SAFE-RESET] ⚠️ Preservando targets:", __PRESERVED_TARGETS__ ? Object.keys(__PRESERVED_TARGETS__) : 'null');
        } catch (e) {
            console.warn("[SAFE-RESET] Falha ao capturar gênero antes do reset:", e);
        }
    } else {
        console.log("[REF_FIX] 🔒 Preservação de gênero/targets BLOQUEADA - modo Reference ativo");
    }
    
    // Mostrar área de upload
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'block';
    if (loading) loading.style.display = 'none';
    if (results) results.style.display = 'none';
    
    // Reset progress
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = '';
    
    currentModalAnalysis = null;
    
    // 🚫 CRITICAL: Limpar globalmente também
    window.currentModalAnalysis = null;
    window.__CURRENT_ANALYSIS__ = null;
    
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) fileInput.value = '';
    
    // 🧩 CORREÇÃO #4: Reset completo de estado (limpeza total)
    const state = window.__soundyState || {};
    
    // Limpar completamente estado de referência
    state.reference = null;
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    // Limpar modo de renderização
    if (!state.render) state.render = {};
    state.render.mode = null;
    
    window.__soundyState = state;
    
    // 🔥 FIX-REFERENCE: Verificar se estamos aguardando segunda música ANTES de limpar
    const isAwaitingSecondTrack = currentAnalysisMode === 'reference' && window.__REFERENCE_JOB_ID__;
    
    console.log('[FIX_REFID_RESET] ═══════════════════════════════════════');
    console.log(`[FIX_REFID_RESET] Mode atual: ${currentAnalysisMode}`);
    console.log(`[FIX_REFID_RESET] Reference Job ID existe: ${window.__REFERENCE_JOB_ID__ ? 'SIM' : 'NÃO'}`);
    console.log(`[FIX_REFID_RESET] Aguardando segunda música: ${isAwaitingSecondTrack ? 'SIM' : 'NÃO'}`);

    if (!isAwaitingSecondTrack) {
        // 🧼 LIMPEZA COMPLETA: Só limpar se NÃO estivermos aguardando segunda música
        SOUNDY_MODE_ENGINE.clear();
        window.__REFERENCE_JOB_ID__ = null;
        window.referenceComparisonMetrics = null;
        window.lastReferenceJobId = null;
        delete window.__REFERENCE_JOB_ID__;
        localStorage.removeItem('referenceJobId');
        
        // ✅ LIMPAR FirstAnalysisStore
        FirstAnalysisStore.clear();
        
        console.log('[FIX_REFID_RESET] Estado limpo completamente ✅');
        console.log('[FIX_REFID_RESET] Limpeza incluiu: window, localStorage e estado global');
        console.log('[FIX_REFID_RESET] Flags de referência LIMPAS (modo não-reference)');
    } else {
        // Preservar IDs de referência para segunda música
        console.log('[FIX_REFID_RESET] ⚠️ PRESERVANDO flags de referência!');
        console.log(`[FIX_REFID_RESET] Reference Job ID mantido: ${window.__REFERENCE_JOB_ID__}`);
        console.log(`[FIX_REFID_RESET] localStorage.referenceJobId: ${localStorage.getItem('referenceJobId')}`);
        console.log('[FIX_REFID_RESET] Aguardando upload da segunda música...');
    }
    console.log('[FIX_REFID_RESET] ═══════════════════════════════════════');

    // Flags internas
    delete window.__AUDIO_ADVANCED_READY__;
    delete window.__MODAL_ANALYSIS_IN_PROGRESS__;    console.log('[CLEANUP] resetModalState: estado global/flags limpos');
    
    // ===============================================================
    // 🔒 BLOCO 3 — RESTAURAR GÊNERO E TARGETS APÓS O RESET
    // ===============================================================
    try {
        // ✅ CORREÇÃO: Só restaurar gênero se NÃO estiver em modo reference
        if (currentMode !== 'reference') {
            const genreSelect = document.getElementById("audioRefGenreSelect");

            if (__PRESERVED_GENRE__ && typeof __PRESERVED_GENRE__ === "string") {
                window.__CURRENT_SELECTED_GENRE = __PRESERVED_GENRE__;
                window.PROD_AI_REF_GENRE = __PRESERVED_GENRE__;

                if (genreSelect) {
                    genreSelect.value = __PRESERVED_GENRE__;
                }

                console.log("[SAFE-RESET] ✅ Gênero restaurado após reset:", __PRESERVED_GENRE__);
            } else {
                console.warn("[SAFE-RESET] ⚠️ Nenhum gênero válido preservado.");
            }
        } else {
            console.log("[REF_FIX] 🔒 Restauração de gênero BLOQUEADA - modo Reference ativo");
        }
        
        // 🔒 PATCH: RESTAURAR TARGETS TAMBÉM (somente em modo genre)
        if (__PRESERVED_TARGETS__ && currentMode !== 'reference') {
            window.__CURRENT_GENRE_TARGETS = __PRESERVED_TARGETS__;
            window.currentGenreTargets = __PRESERVED_TARGETS__;
            console.log("[SAFE-RESET] ✅ Targets restaurados após reset:", Object.keys(__PRESERVED_TARGETS__));
        }
    } catch (e) {
        console.warn("[SAFE-RESET] Falha ao restaurar gênero:", e);
    }
    
    // 🔓 RESTAURAR BOTÃO "PLANO DE CORREÇÃO" (visível em outros modos)
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan && currentMode !== 'reference') {
        btnCorrectionPlan.style.display = '';
        console.log('[RESET-UI] ✅ Botão "Plano de Correção" restaurado');
    }
    
    __dbg('✅ Estado do modal resetado completamente');
}

// ⚙️ Configurar modal de áudio
function setupAudioModal() {
    const modal = document.getElementById('audioAnalysisModal');
    const fileInput = document.getElementById('modalAudioFileInput');
    const uploadArea = document.getElementById('audioUploadArea');
    
    if (!modal || !fileInput || !uploadArea) {
        __dwrn('⚠️ Elementos do modal não encontrados');
        return;
    }
    
    // Fechar modal clicando fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeAudioModal();
        }
    });
    
    // Fechar modal com ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeAudioModal();
        }
    });
    
    // Detectar se é dispositivo móvel
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    if (!isMobile) {
        // Drag and Drop (apenas para desktop)
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.querySelector('.upload-content').classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleModalFileSelection(files[0]);
            }
        });
    }
    
    // File input change event
    fileInput.addEventListener('change', (e) => {
        __dbg('📁 File input change triggered');
        if (e.target.files.length > 0) {
            __dbg('📁 File selected:', e.target.files[0].name);
            handleModalFileSelection(e.target.files[0]);
        }
    });
    
    // Não adicionar nenhum listener JS ao botão/label de upload!
    uploadArea.onclick = null;
    
    __dbg('✅ Modal de áudio configurado com sucesso');
}

// 📁 Processar arquivo selecionado no modal
/**
 * 🎯 HELPER: Retorna state machine seguro (nunca undefined)
 * @returns {Object} State machine real ou stub funcional
 */
function getSafeStateMachine() {
    if (window.AnalysisStateMachine) {
        return window.AnalysisStateMachine;
    }
    
    console.warn('[STATE-MACHINE] ⚠️ AnalysisStateMachine não carregado - usando stub');
    
    // Stub funcional que preserva estado
    return {
        getMode: () => window.currentAnalysisMode || 'genre',
        setMode: (mode, opts) => {
            console.log('[STATE-MACHINE-STUB] setMode:', mode, opts);
            window.currentAnalysisMode = mode;
            if (opts?.userExplicitlySelected) {
                window.userExplicitlySelectedReferenceMode = (mode === 'reference');
            }
        },
        getState: () => ({
            mode: window.currentAnalysisMode || 'genre',
            userExplicitlySelected: window.userExplicitlySelectedReferenceMode || false,
            referenceFirstJobId: window.__REFERENCE_JOB_ID__ || null
        })
    };
}

async function handleModalFileSelection(file) {
    __dbg('📁 Arquivo selecionado no modal:', file.name);
    
    // 🔓 [ANONYMOUS-MODE] Interceptar análise em modo anônimo - PONTO CRÍTICO DE BLOQUEIO
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            console.log('🚫 [ANONYMOUS] Análise bloqueada em handleModalFileSelection - limite atingido');
            return; // Modal de login já foi mostrado
        }
        console.log('✅ [ANONYMOUS] Análise permitida em modo anônimo');
    }
    
    // 🎮 [DEMO-MODE] Interceptar análise em modo demo
    if (window.SoundyDemo?.isActive) {
        const canProceed = window.SoundyDemo.interceptAnalysis();
        if (!canProceed) {
            console.log('🚫 [DEMO] Análise bloqueada - limite atingido');
            return; // Modal de conversão já foi mostrado
        }
        console.log('✅ [DEMO] Análise permitida em modo demo');
    }
    
    // �🔍 [INVARIANTE #1] Verificar estado do mode ANTES de qualquer processamento
    const stateMachine = getSafeStateMachine();  // ✅ Nunca undefined
    const currentMode = stateMachine.getMode();
    
    console.group('[REF_DEBUG] 🎯 handleModalFileSelection - INÍCIO');
    console.log('📁 Arquivo:', file.name);
    console.log('🎯 currentAnalysisMode (window):', window.currentAnalysisMode);
    console.log('🎯 StateMachine.getMode():', stateMachine?.getMode());
    console.log('🎯 StateMachine.state:', stateMachine?.getState());
    console.log('🔒 userExplicitlySelectedReferenceMode:', window.userExplicitlySelectedReferenceMode);
    console.log('🔑 __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('📊 FirstAnalysisStore:', FirstAnalysisStore?.has());
    console.groupEnd();
    
    // 🧹 ISOLAMENTO: Se modo reference, resetar contexto de gênero
    if (window.currentAnalysisMode === 'reference' || currentMode === 'reference') {
        resetGenreContextForReference();
    }
    
    // 🔒 [INVARIANTE #1] Se estamos em reference mas state machine não está, CORRIGIR
    if (window.currentAnalysisMode === 'reference' && currentMode !== 'reference') {
        console.error('%c[INVARIANTE #1 VIOLADA] currentAnalysisMode=reference mas StateMachine=' + currentMode, 'color:red;font-weight:bold;font-size:14px;');
        console.error('[FIX_ATTEMPT] Tentando corrigir state machine para reference...');
        
        if (stateMachine) {
            try {
                stateMachine.setMode('reference', { userExplicitlySelected: true });
                console.log('%c[FIX_SUCCESS] State machine corrigido para reference', 'color:green;font-weight:bold;');
            } catch (err) {
                console.error('[FIX_FAILED] Não foi possível corrigir state machine:', err);
                alert('⚠️ ERRO: Estado inconsistente. Por favor, selecione o modo A/B novamente.');
                return;
            }
        } else {
            console.error('[FIX_FAILED] AnalysisStateMachine não disponível!');
            alert('⚠️ ERRO: Sistema não inicializado corretamente.');
            return;
        }
    }
    
    // ========================================
    // 🔒 DECLARAÇÃO DE ESCOPO GLOBAL: normalizedFirst
    // ========================================
    // Garantir que normalizedFirst sempre exista no escopo da função
    let normalizedFirst = window.__FIRST_ANALYSIS_FROZEN__ 
        ? structuredClone(window.__FIRST_ANALYSIS_FROZEN__) 
        : null;
    
    // 🔧 CORREÇÃO: Prevenir múltiplas análises simultâneas
    if (typeof window !== 'undefined' && window.__MODAL_ANALYSIS_IN_PROGRESS__) {
        __dbg('⚠️ Análise já em progresso, ignorando nova seleção');
        return;
    }
    
    try {
        // Marcar análise em progresso
        if (typeof window !== 'undefined') {
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = true;
        }
        
        // Validação comum de arquivo
        if (!validateAudioFile(file)) {
            return; // validateAudioFile já mostra erro
        }
        
        // 🌐 NOVO FLUXO COMPLETO: Presigned URL → Upload → Job Creation → Polling
        __dbg('🌐 Iniciando fluxo de análise remota completo...');
        
        // Mostrar loading
        hideUploadArea();
        showAnalysisLoading();
        showUploadProgress(`Preparando upload de ${file.name}...`);
        
        // 🌐 ETAPA 1: Obter URL pré-assinada
        const { uploadUrl, fileKey } = await getPresignedUrl(file);
        
        // 🌐 ETAPA 2: Upload direto para bucket
        await uploadToBucket(uploadUrl, file);
        
        // 🌐 ETAPA 3: Criar job de análise no backend
        const jobResult = await createAnalysisJob(fileKey, currentAnalysisMode, file.name);
        
        // 🔥 [DEMO] Se análise foi bloqueada, interromper fluxo (modal de upgrade já foi exibido)
        if (jobResult.blocked || jobResult.showConversion) {
            console.log('🚫 [DEMO] Análise bloqueada - fluxo interrompido');
            window.__MODAL_ANALYSIS_IN_PROGRESS__ = false;
            return; // Modal de conversão já está sendo exibido
        }
        
        const { jobId } = jobResult;
        
        // 🌐 ETAPA 4: Acompanhar progresso e aguardar resultado
        showUploadProgress(`Analisando ${file.name}... Aguarde.`);
        const analysisResult = await pollJobStatus(jobId);
        
        // 🎯 REDUCED MODE AUTO-ACTIVATION: Detectar se backend retornou modo reduced
        // Isso acontece quando free/plus/pro atingem seu limite de análises completas
        if (analysisResult.analysisMode === 'reduced' || analysisResult.mode === 'reduced') {
            console.log('%c[REDUCED-MODE] ⚠️ Backend sinalizou modo REDUCED', 'color:orange;font-weight:bold;font-size:14px;');
            console.log('[REDUCED-MODE] Ativando modo reduced automaticamente...');
            console.log('[REDUCED-MODE] Usuário pode continuar analisando com métricas limitadas');
            
            // Forçar window.analysisMode para 'reduced'
            window.analysisMode = 'reduced';
            
            // Mostrar toast informativo (não bloqueante)
            if (window.showToast || window.Toastify) {
                const message = 'Você atingiu o limite de análises completas. Continuando em modo reduzido (métricas básicas).';
                if (window.showToast) {
                    window.showToast(message, 'warning');
                } else if (window.Toastify) {
                    window.Toastify({
                        text: message,
                        duration: 7000,
                        gravity: "top",
                        position: "center",
                        backgroundColor: "#ff9800",
                        stopOnFocus: true
                    }).showToast();
                }
            } else {
                // Fallback: log no console
                console.log('%c[REDUCED-MODE] ⚠️ MODO REDUZIDO ATIVADO', 'color:orange;font-weight:bold;font-size:16px;');
                console.log('[REDUCED-MODE] Métricas disponíveis: Score, LUFS, True Peak, Dynamic Range');
                console.log('[REDUCED-MODE] Métricas bloqueadas: Frequências, Estéreo, Detalhes avançados');
            }
        }
        
        // 📝 FIX CRÍTICO: Injetar file.name no resultado ANTES de salvar no store
        // O backend retorna technicalData mas não inclui fileName no resultado
        // Garantimos que fileName esteja disponível em ambos os caminhos (root e metadata)
        if (file && file.name) {
            if (!analysisResult.fileName) {
                analysisResult.fileName = file.name;
                console.log('[FILENAME-FIX] ✅ Injetado fileName no analysisResult:', file.name);
            }
            if (!analysisResult.metadata) {
                analysisResult.metadata = {};
            }
            if (!analysisResult.metadata.fileName) {
                analysisResult.metadata.fileName = file.name;
                console.log('[FILENAME-FIX] ✅ Injetado metadata.fileName no analysisResult:', file.name);
            }
        }
        
        // �🌐 ETAPA 5: Processar resultado baseado no modo e contexto
        // 🎯 [FLUXO DETERMINÍSTICO] Usar BINDING como ÚNICA fonte de verdade
        const jobMode = analysisResult.mode || currentAnalysisMode;
        
        // ✅ NOVO FLUXO: Usar binding de job (imutável e confiável)
        const refFlow = window.referenceFlow;
        const jobBinding = refFlow ? refFlow.getJobBinding(jobId) : null;
        
        const isFirstReferenceTrack = jobBinding && jobBinding.track === 'base';
        const isSecondTrack = jobBinding && jobBinding.track === 'compare';
        
        // 🔍 [DEBUG] Log detalhado do estado
        console.group('[REF-FLOW] 🎯 Determinação de Track (Primeira vs Segunda)');
        console.log('📊 analysisResult.mode:', analysisResult?.mode);
        console.log('🎯 currentAnalysisMode:', currentAnalysisMode);
        console.log('🔑 jobId retornado:', jobId);
        console.log('🔒 jobBinding:', jobBinding);
        console.log('🎰 ReferenceFlow.stage:', refFlow?.getStage());
        console.log('🔍 Binding Info:');
        console.log('  - track:', jobBinding?.track);
        console.log('  - baseJobId:', jobBinding?.baseJobId);
        console.log('  - referenceJobId:', jobBinding?.referenceJobId);
        console.log('✅ RESULTADO:');
        console.log('  - isFirstReferenceTrack:', isFirstReferenceTrack);
        console.log('  - isSecondTrack:', isSecondTrack);
        console.groupEnd();
        
        if (isFirstReferenceTrack) {
            console.log('%c[REF-FLOW] 🎯 PRIMEIRA TRACK EM REFERENCE MODE', 'color:cyan;font-weight:bold;font-size:14px;');
            
            // ✅ Chamar onFirstTrackCompleted quando job completa
            if (refFlow && jobId) {
                refFlow.onFirstTrackCompleted(analysisResult);
            }
            
            // 🔒 [INVARIANTE #1] Garantir que state machine está em reference ANTES de startReferenceFirstTrack
            const stateMachine = getSafeStateMachine();
            const smMode = stateMachine?.getMode();
            if (smMode !== 'reference') {
                console.error('%c[INVARIANTE #1 VIOLADA] State machine não está em reference antes de startReferenceFirstTrack!', 'color:red;font-weight:bold;font-size:14px;');
                console.error('[STATE] smMode:', smMode, '| currentAnalysisMode:', currentAnalysisMode);
                
                // Tentar corrigir
                if (stateMachine && currentAnalysisMode === 'reference') {
                    console.warn('[FIX_ATTEMPT] Corrigindo state machine para reference...');
                    stateMachine.setMode('reference', { userExplicitlySelected: true });
                    console.log('%c[FIX_SUCCESS] State machine corrigido', 'color:green;font-weight:bold;');
                } else {
                    alert('⚠️ ERRO: Estado inconsistente no modo referência. Por favor, recarregue a página.');
                    return;
                }
            }
            
            // PRIMEIRA música em modo reference: abrir modal para música de referência
            __dbg('🎯 Primeira música analisada - abrindo modal para segunda');
            
            // ========================================
            // 🔒 SALVAR PRIMEIRA ANÁLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel USER
            const { vid: userVid, clone: userClone } = cacheResultByRole(analysisResult, { isSecondTrack: false });
            
            // 💾 SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveFirstAnalysis(userClone || analysisResult);
            
            // Atualizar normalizedFirst para uso nos logs e modal
            if (!normalizedFirst && userClone) {
                normalizedFirst = userClone;
                window.__FIRST_ANALYSIS_FROZEN__ = structuredClone(normalizedFirst); // Mantido para compatibilidade
                console.log('[SCOPE] ✅ normalizedFirst inicializado com userClone');
            }
            
            if (!window.FirstAnalysisStore?.has()) {
                // � PR1: Log tentativa de salvar primeira track
                if (window.logStep) {
                    const traceId = window.createTraceId ? window.createTraceId() : 'NO-TRACE';
                    window.logStep(traceId, 'FIRST_TRACK_SAVED', {
                        jobId: analysisResult.jobId,
                        fileName: userClone?.fileName || userClone?.metadata?.fileName,
                        vid: userVid,
                        userExplicitlySelectedReferenceMode: userExplicitlySelectedReferenceMode,
                        willSaveAsReference: userExplicitlySelectedReferenceMode,
                    });
                }
                
                // PROTEÇÃO CRÍTICA: Não salvar como referência se modo não foi selecionado explicitamente
                const hasContext = hasActiveReferenceContext();
                const allowSave = userExplicitlySelectedReferenceMode || hasContext;
                
                console.log('[REF-GUARD] Salvando primeira análise:', {
                  userExplicit: userExplicitlySelectedReferenceMode,
                  hasContext,
                  allowed: allowSave
                });
                
                if (!allowSave) {
                    console.warn('%c[PROTECTION] ⚠️ BLOQUEIO: Tentativa de salvar __REFERENCE_JOB_ID__ mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FFA500;font-weight:bold;');
                    console.warn('[PROTECTION] ⚠️ Sistema em modo genre - ignorando salvamento de referência');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃO executar salvamento de referência
                } else {
                    // Salvar como USER no FirstAnalysisStore
                    FirstAnalysisStore.setUser(userClone, userVid, analysisResult.jobId);
                    window.__REFERENCE_JOB_ID__ = analysisResult.jobId;
                    
                    console.log('[A/B] 🧊 primeira faixa salva com VID', {
                        vid: userVid,
                        jobId: analysisResult.jobId, 
                        file: userClone?.fileName || userClone?.metadata?.fileName,
                        role: 'USER'
                    });
                    console.log('%c[PROTECTION] ✅ __REFERENCE_JOB_ID__ definido - flag verificada', 'color:#00FF88;font-weight:bold;');
                }
            }
            
            // 🔍 AUDITORIA: Estado APÓS salvar primeira análise
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] 💾 Primeira Análise SALVA');
            console.log('⚙️ Contexto: Salvamento da primeira faixa');
            console.log('📊 analysisResult (original):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const storedFirst = FirstAnalysisStore.get();
            console.log('🔒 FirstAnalysisStore (clone):', {
                jobId: storedFirst?.jobId,
                fileName: storedFirst?.metadata?.fileName || storedFirst?.fileName,
                lufs: storedFirst?.technicalData?.lufsIntegrated,
                sameAsOriginal: false // sempre retorna clone
            });
            console.log('💡 Verificação de isolamento:');
            console.log('  FirstAnalysisStore.get() !== analysisResult?', storedFirst !== analysisResult);
            console.log('  FirstAnalysisStore retorna clones:', true);
            console.groupEnd();
            
            // ========================================
            // 🛡️ VALIDAÇÃO: Garantir que normalizedFirst existe
            // ========================================
            if (!normalizedFirst) {
                console.warn('[WARN] normalizedFirst ausente — usando fallback do FirstAnalysisStore.');
                normalizedFirst = structuredClone(FirstAnalysisStore.getUser() || {});
            }
            
            console.log('[REF-SAVE ✅] ═══════════════════════════════════════');
            console.log('[REF-SAVE ✅] Primeira música processada com sucesso!');
            console.log(`[REF-SAVE ✅] Job ID salvo globalmente: ${normalizedFirst?.jobId || 'unknown'}`);
            console.log('[REF-SAVE ✅] Locais de salvamento:');
            console.log('[REF-SAVE ✅]   - window.__REFERENCE_JOB_ID__');
            console.log('[REF-SAVE ✅]   - localStorage.referenceJobId');
            console.log('[REF-SAVE ✅]   - window.AnalysisCache (imutável)');
            console.log('[REF-SAVE ✅]   - window.FirstAnalysisStore (imutável + clonagem automática)');
            console.log(`[REF-SAVE ✅] File Name: ${normalizedFirst?.metadata?.fileName || normalizedFirst?.fileName || 'unknown'}`);
            console.log(`[REF-SAVE ✅] LUFS: ${normalizedFirst?.technicalData?.lufsIntegrated || 'N/A'} LUFS`);
            console.log(`[REF-SAVE ✅] DR: ${normalizedFirst?.technicalData?.dynamicRange || 'N/A'} dB`);
            console.log('[REF-SAVE ✅] Este ID será usado na segunda música');
            console.log('[REF-SAVE ✅] Primeira análise salva e congelada.');
            console.log('[REF-SAVE ✅] ═══════════════════════════════════════');
            
            // 🎯 TRANSIÇÃO DE ESTADO: REF_A_DONE → REF_B_WAIT_UPLOAD
            console.log('%c[REF-FLOW] 🎯 TRANSIÇÃO DE ESTADO: REF_A_DONE → REF_B_WAIT_UPLOAD', 'color:#00FF88;font-weight:bold;font-size:14px;');
            console.log('[REF-FLOW] Estado atual:', {
                stage: 'REF_A_DONE',
                firstJobId: normalizedFirst?.jobId,
                hasFirstAnalysis: FirstAnalysisStore?.has(),
                currentMode: window.currentAnalysisMode,
                userExplicitFlag: window.userExplicitlySelectedReferenceMode
            });
            
            // ✅ Notificar referenceFlow sobre conclusão da primeira track
            if (refFlow && normalizedFirst) {
                refFlow.onFirstTrackCompleted(normalizedFirst);
                console.log('[REF-FLOW] ✅ onFirstTrackCompleted() chamado');
            }
            
            if (normalizedFirst && normalizedFirst.jobId) {
                openReferenceUploadModal(normalizedFirst.jobId, normalizedFirst);
            } else {
                console.error('[ERROR] ❌ Não foi possível abrir modal: normalizedFirst inválido');
            }
        } else if (isSecondTrack) {
            // ✅ SEGUNDA música em modo reference: mostrar resultado comparativo
            console.log('%c[REF-FLOW] 🎯 TRANSIÇÃO: REF_B_PROCESSING → REF_B_DONE', 'color:#00FF88;font-weight:bold;font-size:14px;');
            console.log('[REF-FLOW] Segunda track detectada - bloco de comparação A/B');
            console.log('[REF-FLOW] Estado atual:', {
                stage: 'REF_B_DONE',
                jobMode: jobMode,
                currentAnalysisMode: currentAnalysisMode,
                secondJobId: analysisResult?.jobId,
                baseJobId: refFlow?.getBaseJobId(),
                hasFirstAnalysis: FirstAnalysisStore?.has()
            });
            
            // ✅ Notificar referenceFlow sobre conclusão da segunda track
            if (refFlow) {
                refFlow.onCompareCompleted(analysisResult);
                console.log('[REF-FLOW] ✅ onCompareCompleted() chamado');
            }
            
            __dbg('🎯 Segunda música analisada - exibindo resultado comparativo');
            
            // ========================================
            // 🔒 SALVAR SEGUNDA ANÁLISE COM VIRTUAL ID
            // ========================================
            // Usar cacheResultByRole para criar VID e salvar com papel REF
            const { vid: refVid, clone: refClone } = cacheResultByRole(analysisResult, { isSecondTrack: true });
            
            // 💾 SALVAR NO STORE ISOLADO (fonte de verdade principal)
            saveSecondAnalysis(refClone || analysisResult);
            
            // 🎯 NORMALIZAR ANTES DE SALVAR: Garante shape consistente
            const refNormalized = normalizeAnalysis(refClone || analysisResult);
            
            // Salvar como REF no FirstAnalysisStore (mantido para compatibilidade)
            FirstAnalysisStore.setRef(refNormalized, refVid, analysisResult.jobId);
            
            console.log('[STORE-SAVE] ✅ Referência salva NORMALIZADA:', {
                jobId: analysisResult.jobId,
                hasBands: !!refNormalized.bands && Object.keys(refNormalized.bands).length > 0,
                hasMetrics: !!refNormalized.metrics && Object.keys(refNormalized.metrics).length > 0
            });
            
            console.log('[A/B] 🧊 segunda faixa salva com VID', {
                vid: refVid,
                jobId: analysisResult.jobId,
                file: refClone?.fileName || refClone?.metadata?.fileName,
                role: 'REF'
            });
            
            // � AUDITORIA: Estado ANTES de construir estrutura A/B
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] 🎯 Segunda Análise RECEBIDA');
            console.log('⚙️ Contexto: Recepção da segunda faixa');
            console.log('📊 analysisResult (2ª faixa):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const frozenFirst = FirstAnalysisStore.get();
            console.log('🔒 FirstAnalysisStore (1ª faixa congelada):', {
                jobId: frozenFirst?.jobId,
                fileName: frozenFirst?.metadata?.fileName,
                lufs: frozenFirst?.technicalData?.lufsIntegrated
            });
            console.log('💾 window.__soundyState.previousAnalysis (1ª faixa):', {
                jobId: window.__soundyState?.previousAnalysis?.jobId,
                fileName: window.__soundyState?.previousAnalysis?.metadata?.fileName,
                lufs: window.__soundyState?.previousAnalysis?.technicalData?.lufsIntegrated,
                objectId: window.__soundyState?.previousAnalysis
            });
            console.log('⚠️ CHECKPOINT CRÍTICO: Verificar se objetos são distintos');
            console.log('  analysisResult !== previousAnalysis?', analysisResult !== window.__soundyState?.previousAnalysis);
            console.log('  analysisResult !== FirstAnalysisStore?', analysisResult !== FirstAnalysisStore.get());
            console.groupEnd();
            
            // �🔥 CORREÇÃO CRÍTICA: Primeira música é ATUAL (sua faixa), segunda é REFERÊNCIA (alvo)
            const state = window.__soundyState || {};
            
            // 🧊 PROTEÇÃO ANTIFALSA ATUALIZAÇÃO DA REFERÊNCIA
            if (state?.render?.mode === 'reference' && window.__FIRST_ANALYSIS_FROZEN__) {
                console.warn('[STATE-FIX] 🔒 Bloqueando sobrescrita de referência - usando cópia congelada');
                console.warn('[STATE-FIX]   __FIRST_ANALYSIS_FROZEN__:', window.__FIRST_ANALYSIS_FROZEN__?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
                console.warn('[STATE-FIX]   analysisResult (2ª faixa):', analysisResult?.fileName || analysisResult?.metadata?.fileName);
                
                // Garantir que previousAnalysis aponte para o frozen
                if (!state.previousAnalysis || state.previousAnalysis.jobId === analysisResult.jobId) {
                    console.warn('[STATE-FIX] ⚠️ Corrigindo previousAnalysis contaminado');
                    state.previousAnalysis = JSON.parse(JSON.stringify(window.__FIRST_ANALYSIS_FROZEN__));
                }
            }
            
            if (state.previousAnalysis) {
                // ✅ SEMÂNTICA CORRETA DO FLUXO A/B:
                // - Primeira faixa (previousAnalysis) = userAnalysis (SUA MÚSICA/ATUAL)
                // - Segunda faixa (analysisResult) = referenceAnalysis (ALVO/REFERÊNCIA a alcançar)
                
                // 🛡️ PROTEÇÃO CRÍTICA: Não permitir isSecondTrack = true se usuário não selecionou modo reference
                const hasContext = hasActiveReferenceContext();
                const allowSecondTrack = userExplicitlySelectedReferenceMode || hasContext;
                
                console.log('[REF-GUARD] Detectando segunda track (1):', {
                  userExplicit: userExplicitlySelectedReferenceMode,
                  hasContext,
                  allowed: allowSecondTrack
                });
                
                if (!allowSecondTrack) {
                    console.error('%c[PROTECTION] ❌ BLOQUEIO CRÍTICO: Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    console.error('[PROTECTION] ❌ Sistema em modo genre - NÃO pode processar segunda track');
                    console.error('[PROTECTION] ❌ state.previousAnalysis existe mas modo não é reference explícito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // 🧊 PROTEÇÃO ANTICONTAMINAÇÃO: Deep clone obrigatório
                console.log('[STATE-FIX] 🔒 Criando deep clones para evitar contaminação de estado');
                state.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));      // 1ª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));         // 2ª = faixa de referência (alvo)
                
                // 🎯 ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(state.previousAnalysis));    // 1ª faixa (sua música/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));       // 2ª faixa (referência/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('%c[PROTECTION] ✅ isSecondTrack = true PERMITIDO - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                console.log('✅ [REFERENCE-A/B-CORRECTED] ═══════════════════════════════════════');
                console.log('✅ [REFERENCE-A/B-CORRECTED] Atribuição correta A/B:');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   1ª Faixa (ATUAL/SUA MÚSICA):', state.previousAnalysis.fileName || state.previousAnalysis.metadata?.fileName || '1ª Faixa');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   2ª Faixa (REFERÊNCIA/ALVO):', analysisResult.fileName || analysisResult.metadata?.fileName || '2ª Faixa');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   Comparação: SUA MÚSICA vs REFERÊNCIA');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   Modal mostrará: ESQUERDA=sua música, DIREITA=referência');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   1ª tem bandas:', !!state.userAnalysis?.technicalData?.spectral_balance);
                console.log('✅ [REFERENCE-A/B-CORRECTED]   2ª tem bandas:', !!state.referenceAnalysis?.technicalData?.spectral_balance);
                console.log('✅ [REFERENCE-A/B-CORRECTED] ═══════════════════════════════════════');
                
                // 🔍 AUDITORIA: Estado APÓS construir estrutura A/B
                console.groupCollapsed('[AUDITORIA_STATE_FLOW] 🔧 Estrutura A/B CONSTRUÍDA');
                console.log('⚙️ Contexto: Estrutura state.reference montada');
                console.log('📊 state.userAnalysis (1ª faixa - SUA MÚSICA):', {
                    jobId: state.userAnalysis?.jobId,
                    fileName: state.userAnalysis?.metadata?.fileName || state.userAnalysis?.fileName,
                    lufs: state.userAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.userAnalysis
                });
                console.log('📊 state.referenceAnalysis (2ª faixa - REFERÊNCIA):', {
                    jobId: state.referenceAnalysis?.jobId,
                    fileName: state.referenceAnalysis?.metadata?.fileName || state.referenceAnalysis?.fileName,
                    lufs: state.referenceAnalysis?.technicalData?.lufsIntegrated,
                    objectId: state.referenceAnalysis
                });
                console.log('⚠️ VERIFICAÇÃO DE CONTAMINAÇÃO:');
                console.log('  state.userAnalysis === state.referenceAnalysis?', state.userAnalysis === state.referenceAnalysis);
                console.log('  state.userAnalysis === analysisResult?', state.userAnalysis === analysisResult);
                console.log('  state.userAnalysis === state.previousAnalysis?', state.userAnalysis === state.previousAnalysis);
                console.log('  state.referenceAnalysis === analysisResult?', state.referenceAnalysis === analysisResult);
                console.log('💡 Próximo passo: Normalizar analysisResult antes de enviar para displayModalResults');
                console.groupEnd();
                
                // 🎯 LOG AUDIT-MODE-FLOW (conforme solicitado)
                console.log('[AUDIT-MODE-FLOW]', {
                    mode: 'reference',
                    isSecondTrack: state.reference.isSecondTrack,
                    refJobId: state.reference.jobId,
                    hasUserAnalysis: !!state.userAnalysis,
                    hasReferenceAnalysis: !!state.referenceAnalysis
                });
                
                // 🎯 LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            } else if (FirstAnalysisStore.has()) {
                // 🔥 FALLBACK: Primeira música é ATUAL (sua faixa), segunda é REFERÊNCIA (alvo)
                const firstAnalysis = FirstAnalysisStore.get(); // sempre clone
                
                // 🛡️ PROTEÇÃO CRÍTICA: Não permitir isSecondTrack = true se usuário não selecionou modo reference E não há contexto ativo
                const hasContextFallback = hasActiveReferenceContext();
                const allowSecondTrackFallback = userExplicitlySelectedReferenceMode || hasContextFallback;
                
                console.log('[REF-GUARD] isSecondTrack (FALLBACK):', {
                    userExplicit: userExplicitlySelectedReferenceMode,
                    hasContext: hasContextFallback,
                    allowed: allowSecondTrackFallback
                });
                
                if (!allowSecondTrackFallback) {
                    console.error('%c[PROTECTION] ❌ BLOQUEIO CRÍTICO (FALLBACK): Tentativa de ativar isSecondTrack mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                    console.error('[PROTECTION] ❌ Sistema em modo genre - NÃO pode processar segunda track');
                    console.error('[PROTECTION] ❌ FirstAnalysisStore.has() = true mas modo não é reference explícito');
                    console.trace('[PROTECTION] Stack trace do bloqueio:');
                    // NÃO construir estrutura A/B - abortar processamento de segunda track
                    return;
                }
                
                // 🧊 PROTEÇÃO ANTICONTAMINAÇÃO: Deep clone obrigatório
                console.log('[STATE-FIX] 🔒 FALLBACK - Criando deep clones para evitar contaminação');
                state.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));    // 1ª = sua faixa (atual)
                state.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                 // 2ª = referência (alvo)
                
                // 🎯 ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                state.reference = state.reference || {};
                state.reference.userAnalysis = JSON.parse(JSON.stringify(firstAnalysis));  // 1ª faixa (sua música/atual)
                state.reference.referenceAnalysis = JSON.parse(JSON.stringify(analysisResult));                // 2ª faixa (referência/alvo)
                state.reference.isSecondTrack = true;
                state.reference.jobId = analysisResult.jobId || null;
                
                console.log('%c[PROTECTION] ✅ isSecondTrack = true PERMITIDO (FALLBACK) - flag verificada', 'color:#00FF88;font-weight:bold;');
                
                console.log('✅ [REFERENCE-A/B-CORRECTED] ═══════════════════════════════════════');
                console.log('✅ [REFERENCE-A/B-CORRECTED] Fallback - Atribuição correta A/B:');
                console.log('✅ [REFERENCE-A/B-CORRECTED]   1ª Faixa (ATUAL/SUA MÚSICA):', firstAnalysis?.fileName);
                console.log('✅ [REFERENCE-A/B-CORRECTED]   2ª Faixa (REFERÊNCIA/ALVO):', analysisResult.fileName);
                console.log('✅ [REFERENCE-A/B-CORRECTED] ═══════════════════════════════════════');
                
                // 🎯 LOG ASSERT_REF_FLOW
                console.log("[ASSERT_REF_FLOW]", {
                    mode: 'reference',
                    userTrack: state.userAnalysis?.fileName || 'Sua música (atual)',
                    referenceTrack: state.referenceAnalysis?.fileName || 'Faixa de referência (alvo)',
                    userBands: Object.keys(state.userAnalysis?.technicalData?.spectral_balance || {}),
                    refBands: Object.keys(state.referenceAnalysis?.technicalData?.spectral_balance || {})
                });
            }
            
            // 🚨 AUDIT_REF_FIX: NÃO chamar handleGenreAnalysisWithResult em modo reference!
            // Esta função limpa o estado e força mode='genre', quebrando o fluxo A/B
            
            // PRESERVAR modo reference até o final (reutilizar state já declarado acima)
            if (!state.render) state.render = {};
            state.render.mode = 'reference';
            window.__soundyState = state;
            
            console.log('[AUDIT_REF_FIX] Preservando modo reference até final da renderização');
            console.log('[MODE LOCKED] reference - handleGenreAnalysisWithResult PULADO');
            
            // 🔍 AUDITORIA: Estado ANTES de normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ⚙️ ANTES de normalizeBackendAnalysisData');
            console.log('⚙️ Contexto: Prestes a normalizar analysisResult (2ª faixa)');
            console.log('📊 analysisResult (ANTES de normalizar):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            const checkFirst = FirstAnalysisStore.get();
            console.log('🔒 FirstAnalysisStore (NÃO deve mudar):', {
                jobId: checkFirst?.jobId,
                fileName: checkFirst?.metadata?.fileName,
                lufs: checkFirst?.technicalData?.lufsIntegrated
            });
            console.log('⚠️ PONTO CRÍTICO: normalizeBackendAnalysisData() vai modificar analysisResult?');
            console.groupEnd();
            
            // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
            // ❌ REMOVIDO: normalizeBackendAnalysisData() destrói dados
            const normalizedResult = analysisResult; // ✅ LEITURA DIRETA
            
            // 🔒 POPULAR CACHE COM RESULTADO DIRETO
            AnalysisCache.put(normalizedResult);
            
            // 🔍🔍 AUDITORIA: Estado APÓS normalizar analysisResult
            console.groupCollapsed('[AUDITORIA_STATE_FLOW] ✅ DEPOIS de normalizeBackendAnalysisData');
            console.log('⚙️ Contexto: Normalização concluída');
            console.log('📊 normalizedResult (resultado da normalização):', {
                jobId: normalizedResult?.jobId,
                fileName: normalizedResult?.metadata?.fileName || normalizedResult?.fileName,
                lufs: normalizedResult?.technicalData?.lufsIntegrated,
                objectId: normalizedResult,
                sameAsOriginal: normalizedResult === analysisResult
            });
            console.log('📊 analysisResult (APÓS normalização - pode ter mudado?):', {
                jobId: analysisResult?.jobId,
                fileName: analysisResult?.metadata?.fileName || analysisResult?.fileName,
                lufs: analysisResult?.technicalData?.lufsIntegrated,
                objectId: analysisResult
            });
            console.log('🔒 window.__FIRST_ANALYSIS_FROZEN__ (deve estar INTACTO):', {
                jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
                fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
                lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
                isFrozen: Object.isFrozen(window.__FIRST_ANALYSIS_FROZEN__)
            });
            console.log('💡 Próximo: Enviar normalizedResult para displayModalResults()');
            console.groupEnd();
            
            // � PARTE 3.4: Garantir atribuição correta ANTES de displayModalResults
            // 🔧 PARTE 1: Normalize reference comparison structure
            if (state.render.mode === "reference" && analysisResult && state.previousAnalysis) {
                // 🧊 PROTEÇÃO ANTICONTAMINAÇÃO: Deep clone para evitar mutação
                console.log('[STATE-FIX] 🔒 Normalizando com deep clones');
                const firstResult = JSON.parse(JSON.stringify(state.previousAnalysis));
                const secondResult = JSON.parse(JSON.stringify(analysisResult));

                const normalizedUser = {
                    fileName: firstResult.fileName || firstResult.metadata?.fileName,
                    bands: firstResult.spectralBands || firstResult.bands || firstResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: firstResult.loudness?.integrated ?? firstResult.lufsIntegrated,
                        dr: firstResult.dynamics?.dr ?? firstResult.dynamicRange,
                        peak: firstResult.truePeak?.dbtp ?? firstResult.truePeakDbtp
                    }
                };

                const normalizedRef = {
                    fileName: secondResult.fileName || secondResult.metadata?.fileName,
                    bands: secondResult.spectralBands || secondResult.bands || secondResult.technicalData?.spectral_balance,
                    metrics: {
                        lufs: secondResult.loudness?.integrated ?? secondResult.lufsIntegrated,
                        dr: secondResult.dynamics?.dr ?? secondResult.dynamicRange,
                        peak: secondResult.truePeak?.dbtp ?? secondResult.truePeakDbtp
                    }
                };

                // 🧊 PROTEÇÃO: Usar deep clone para state.reference
                state.reference = {
                    mode: "reference",
                    isSecondTrack: true,
                    userAnalysis: JSON.parse(JSON.stringify(normalizedUser)),
                    referenceAnalysis: JSON.parse(JSON.stringify(normalizedRef)),
                    analysis: {
                        bands: JSON.parse(JSON.stringify(normalizedRef.bands))
                    }
                };

                state.render.mode = 'reference';
                window.__soundyState = state;
                console.log("[REF-FIX] Estrutura final corrigida", state.reference);
            }
            
            // 🔥 FORCE MODE REFERENCE EXPLICITAMENTE ANTES DE displayModalResults
            // 🛡️ PROTEÇÃO CRÍTICA: Só forçar modo reference se usuário selecionou explicitamente OU existe contexto ativo
            const hasContextForce = hasActiveReferenceContext();
            const allowForceMode = userExplicitlySelectedReferenceMode || hasContextForce;
            
            console.log('[REF-GUARD] Forçando modo reference:', {
              userExplicit: userExplicitlySelectedReferenceMode,
              hasContext: hasContextForce,
              requestedMode: 'reference',
              allowed: allowForceMode
            });
            
            if (!allowForceMode) {
                console.error('%c[PROTECTION] ❌ BLOQUEIO: Tentativa de forçar modo reference mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
                console.error('[PROTECTION] ❌ Sistema em modo genre - NÃO pode forçar modo reference');
                console.trace('[PROTECTION] Stack trace do bloqueio:');
                // NÃO forçar modo reference
                return;
            }
            
            state.render = state.render || {};
            state.render.mode = 'reference';
            currentAnalysisMode = 'reference';
            window.__soundyState = state;
            
            console.log('%c[PROTECTION] ✅ Modo forçado para reference - flag verificada', 'color:#00FF88;font-weight:bold;');
            console.log('🔥🔥🔥 [MODE-FORCE] ════════════════════════════════════════════════════════════');
            console.log('🔥 [MODE-FORCE] ✅ Modo FORÇADO para reference antes de displayModalResults');
            console.log('🔥 [MODE-FORCE] state.render.mode:', state.render.mode);
            console.log('🔥 [MODE-FORCE] currentAnalysisMode:', currentAnalysisMode);
            console.log('🔥 [MODE-FORCE] window.__soundyState.render.mode:', window.__soundyState.render.mode);
            console.log('🔥🔥🔥 [MODE-FORCE] ════════════════════════════════════════════════════════════');
            
            // 🔥 CORREÇÃO: Preparar dados para comparação A/B correta
            console.log('[REFERENCE-FLOW] ═══════════════════════════════════════');
            console.log('[REFERENCE-FLOW] Segunda música concluída - montando comparação A/B');
            
            // � PASSO 2: ATIVAR PROTEÇÃO DE CURRENTJOBID
            const currentJobId = normalizedResult?.jobId || analysisResult?.jobId;
            // 🔧 CORREÇÃO: Usar StorageManager
            const referenceJobId = window.__REFERENCE_JOB_ID__ || window.StorageManager.getReferenceJobId();
            
            if (currentJobId) {
                console.log('🔒 [PROTECTION] Ativando proteção para currentJobId:', currentJobId);
                console.log('🔍 [PROTECTION] ReferenceJobId:', referenceJobId);
                
                // 🚨 VALIDAÇÃO CRÍTICA: Garantir que jobIds são DIFERENTES
                if (currentJobId === referenceJobId) {
                    console.error('❌ [MODAL-FILE] ERRO CRÍTICO: Backend retornou mesmo jobId!');
                    console.error('   currentJobId:', currentJobId);
                    console.error('   referenceJobId:', referenceJobId);
                    console.trace();
                    alert('ERRO: O backend retornou o mesmo jobId da primeira música. Tente novamente.');
                    return;
                }
                
                console.log('✅ [MODAL-FILE] Segunda música analisada:');
                console.log('   Novo currentJobId:', currentJobId);
                console.log('   ReferenceJobId:', referenceJobId);
                console.log('   São diferentes?', currentJobId !== referenceJobId ? '✅ SIM' : '❌ NÃO');
                
                // Salvar em múltiplas camadas de proteção
                window.__CURRENT_JOB_ID__ = currentJobId;
                sessionStorage.setItem('currentJobId', currentJobId);
                
                protectCurrentJobId(currentJobId);
                console.log('✅ [PROTECTION] Proteção ativada - currentJobId protegido contra contaminação');
                console.log('✅ [PROTECTION] sessionStorage.currentJobId salvo:', sessionStorage.getItem('currentJobId'));
            } else {
                console.warn('⚠️ [PROTECTION] currentJobId não encontrado, proteção não ativada');
            }
            
            // �🛡️ DEEP CLONE OBRIGATÓRIO: Evitar contaminação de ponteiros que causa falso self-compare
            console.log('[DEEP-CLONE-GUARD] 🔒 Clonando userAnalysis para evitar compartilhamento de metadata');
            const userAnalysis = structuredClone(state.previousAnalysis || state.userAnalysis);
            
            console.log('[DEEP-CLONE-GUARD] 🔒 Clonando referenceAnalysisData para evitar compartilhamento de metadata');
            const referenceAnalysisData = structuredClone(normalizedResult || state.referenceAnalysis);
            
            // 🔍 VALIDAÇÃO CRÍTICA: Confirmar que os clones são independentes
            console.groupCollapsed('[INTEGRITY-CHECK] 🔒 Validação de Clones Independentes');
            console.log('✅ userAnalysis !== referenceAnalysisData?', userAnalysis !== referenceAnalysisData);
            console.log('✅ userAnalysis.metadata !== referenceAnalysisData.metadata?', userAnalysis?.metadata !== referenceAnalysisData?.metadata);
            console.log('📁 userFileName:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('📁 refFileName:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('🆔 userJobId:', userAnalysis?.jobId || userAnalysis?.id);
            console.log('🆔 refJobId:', referenceAnalysisData?.jobId || referenceAnalysisData?.id);
            console.log('⚠️ Nomes iguais?', (userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName));
            console.log('⚠️ JobIds iguais?', (userAnalysis?.jobId || userAnalysis?.id) === (referenceAnalysisData?.jobId || referenceAnalysisData?.id));
            
            if ((userAnalysis?.fileName || userAnalysis?.metadata?.fileName) === (referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName)) {
                console.error('🚨 CONTAMINAÇÃO DETECTADA: userFileName === refFileName!');
                console.error('🚨 Isso indica que os clones NÃO são independentes ou que a fonte está contaminada!');
            } else {
                console.log('✅ INTEGRIDADE CONFIRMADA: Arquivos são diferentes');
            }
            console.groupEnd();
            
            console.log('[REFERENCE-COMPARE] ═══════════════════════════════════════');
            console.log('[REFERENCE-COMPARE] 1ª FAIXA (SUA MÚSICA):');
            console.log('[REFERENCE-COMPARE]   Nome:', userAnalysis?.fileName || userAnalysis?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!userAnalysis?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', userAnalysis?.technicalData?.spectral_balance ? 'SIM' : 'NÃO');
            console.log('[REFERENCE-COMPARE]   bandas:', userAnalysis?.technicalData?.spectral_balance ? Object.keys(userAnalysis.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', userAnalysis?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] 2ª FAIXA (REFERÊNCIA):');
            console.log('[REFERENCE-COMPARE]   Nome:', referenceAnalysisData?.fileName || referenceAnalysisData?.metadata?.fileName);
            console.log('[REFERENCE-COMPARE]   technicalData:', !!referenceAnalysisData?.technicalData);
            console.log('[REFERENCE-COMPARE]   spectral_balance:', referenceAnalysisData?.technicalData?.spectral_balance ? 'SIM' : 'NÃO');
            console.log('[REFERENCE-COMPARE]   bandas:', referenceAnalysisData?.technicalData?.spectral_balance ? Object.keys(referenceAnalysisData.technicalData.spectral_balance) : 'NENHUMA');
            console.log('[REFERENCE-COMPARE]   LUFS:', referenceAnalysisData?.technicalData?.lufsIntegrated);
            console.log('[REFERENCE-COMPARE] ═══════════════════════════════════════');
            
            // Marcar no normalizedResult que é modo referência com dados corretos
            normalizedResult._isReferenceMode = true;
            // 🛡️ PROTEÇÃO CIRCULAR: usar clone seguro para evitar loops
            normalizedResult._userAnalysis = deepCloneSafe(userAnalysis);
            normalizedResult._referenceAnalysis = deepCloneSafe(referenceAnalysisData);
            
            // ==== CHECKPOINT AUDITORIA REF-CONTAMINAÇÃO ====
            console.group("[AUDITORIA REF-CONTAMINAÇÃO]");
            console.log("🌐 window.referenceAnalysisData:", window.referenceAnalysisData?.metadata?.fileName || window.referenceAnalysisData?.fileName);
            console.log("🧊 __FIRST_ANALYSIS_FROZEN__:", window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName || window.__FIRST_ANALYSIS_FROZEN__?.fileName);
            console.log("📦 analysis.metadata.fileName:", normalizedResult?.metadata?.fileName);
            console.groupEnd();
            
            // ========================================
            // 🧠 OBTER PAR DE ANÁLISES DO STORE ISOLADO
            // ========================================
            console.log('[STORE-FLOW] Obtendo par de análises do store isolado');
            const comparisonPair = getComparisonPair();
            
            if (comparisonPair) {
                console.log('✅ [STORE-FLOW] Par obtido com sucesso');
                console.log('   - ref.jobId:', comparisonPair.ref?.jobId);
                console.log('   - curr.jobId:', comparisonPair.curr?.jobId);
                console.log('   - ref.fileName:', comparisonPair.ref?.fileName || comparisonPair.ref?.metadata?.fileName);
                console.log('   - curr.fileName:', comparisonPair.curr?.fileName || comparisonPair.curr?.metadata?.fileName);
                
                // ✅ USAR DADOS DO STORE COMO FONTE DE VERDADE
                normalizedResult._comparisonPair = comparisonPair;
                normalizedResult._useStoreData = true;
                
                console.log('🎯 [STORE-FLOW] Dados do store anexados ao normalizedResult');
            } else {
                console.warn('⚠️ [STORE-FLOW] Store não pronto, usando dados legados');
            }
            
            console.log("[SAFE-MODAL] ✅ Fluxo reference intacto, iniciando renderização final.");
            
            // ========================================
            // 🤖 AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL
            // ========================================
            console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('[AI-SYNC] 🔍 Verificando status do enriquecimento IA...');
            console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // Verificar se aiSuggestions já está presente
            const hasAISuggestions = Array.isArray(normalizedResult.aiSuggestions) && 
                                     normalizedResult.aiSuggestions.length > 0 &&
                                     normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
            
            console.log('[AI-SYNC] 📊 Estado atual:', {
                hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
                aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
                aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
                jobId: normalizedResult.jobId
            });
            
            if (!hasAISuggestions) {
                console.log('[AI-SYNC] ⏳ aiSuggestions não está pronto, aguardando enriquecimento...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    console.error('[AI-SYNC] ❌ jobId inválido, não é possível aguardar enriquecimento:', normalizedResult.jobId);
                    console.warn('[AI-SYNC] ⚠️ Pulando enriquecimento IA - usando dados já disponíveis');
                } else {
                    // Mostrar spinner visual
                    showAILoadingSpinner('🤖 Conectando à IA para análise avançada...');
                    
                    try {
                        // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                    
                        if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                            // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                            normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        
                        console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        console.log('[AI-SYNC] ✅ Enriquecimento IA mesclado com sucesso!');
                        console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        console.log('[AI-SYNC] 📊 Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                        console.log('[AI-SYNC] 🤖 Marcadas como aiEnhanced:', 
                            normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                        
                        // Atualizar cache com dados enriquecidos
                        AnalysisCache.put(normalizedResult);
                        
                    } else {
                        console.warn('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        console.warn('[AI-SYNC] ⚠️ Enriquecimento IA não completou a tempo');
                        console.warn('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                        console.warn('[AI-SYNC] ℹ️ Modal será exibido com sugestões base');
                        console.warn('[AI-SYNC] ℹ️ IA pode estar desabilitada ou sobrecarregada');
                        }
                        
                    } catch (syncError) {
                        console.error('[AI-SYNC] ❌ Erro ao aguardar enriquecimento IA:', syncError);
                        console.warn('[AI-SYNC] ℹ️ Continuando com sugestões base...');
                    } finally {
                        // Remover spinner
                        hideAILoadingSpinner();
                    }
                } // PATCH JOB-ID: Fim do bloco de validação
                
            } else {
                console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log('[AI-SYNC] ✅ aiSuggestions já presente no resultado!');
                console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log('[AI-SYNC] ℹ️ Não é necessário aguardar, exibindo imediatamente');
            }
            
            console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('[AI-SYNC] 🎬 Iniciando renderização do modal...');
            console.log('[AI-SYNC] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // ========================================
            // ✅ CORREÇÃO: Aguardar enriquecimento IA antes de abrir modal
            // ========================================
            if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
                console.log('[AI-SYNC] ⏳ Enriquecimento IA ausente — aguardando resposta...');
                
                // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
                if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                    console.error('[AI-SYNC] ❌ jobId inválido, não é possível aguardar enriquecimento:', normalizedResult.jobId);
                    console.warn('[AI-SYNC] ⚠️ Pulando enriquecimento IA - abrindo modal com dados disponíveis');
                } else {
                    showAILoadingSpinner('🤖 Conectando à IA para análise avançada...');

                    try {
                        const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                    if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                        normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                        console.log(`[AI-SYNC] ✅ Sugestões enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                    } else {
                        console.warn('[AI-SYNC] ⚠️ Timeout ou IA não retornou sugestões válidas. Fallback para sugestões base.');
                    }
                } catch (error) {
                    console.error('[AI-SYNC] ❌ Erro ao aguardar sugestões enriquecidas:', error);
                } finally {
                    hideAILoadingSpinner();
                }
                } // PATCH JOB-ID: Fim do bloco de validação
            }

            // ✅ Agora sim, exibe o modal com ou sem IA (fallback incluso)
            await displayModalResults(normalizedResult);
            console.log('[FIX-REFERENCE] Modal aberto após segunda análise');
            
            // 🔍 VALIDAÇÃO FINAL: Confirmar que __FIRST_ANALYSIS_FROZEN__ permanece intacto
            console.groupCollapsed('[POST-RENDER-VALIDATION] 🔒 Verificação Final de Integridade');
            console.log('🧊 __FIRST_ANALYSIS_FROZEN__ APÓS segunda análise:');
            console.log('   fileName:', window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName);
            console.log('   jobId:', window.__FIRST_ANALYSIS_FROZEN__?.jobId);
            console.log('   É o mesmo que normalizedResult?', window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId);
            
            if (window.__FIRST_ANALYSIS_FROZEN__?.jobId === normalizedResult?.jobId) {
                console.error('🚨 FALHA CRÍTICA: __FIRST_ANALYSIS_FROZEN__ foi sobrescrito pela segunda análise!');
            } else {
                console.log('✅ INTEGRIDADE MANTIDA: __FIRST_ANALYSIS_FROZEN__ permanece intacto');
            }
            console.groupEnd();
            
            // ========================================
            // ✅ CORREÇÃO 1: EARLY RETURN - Impedir limpeza no modo reference
            // ========================================
            if (currentAnalysisMode === 'reference' || jobMode === 'reference') {
                console.log('✅ [CLEANUP] ═══════════════════════════════════════');
                console.log('✅ [CLEANUP] MODO REFERENCE ATIVO - Limpeza bloqueada por early return');
                console.log('✅ [CLEANUP] Referência PRESERVADA intacta:');
                console.log('✅ [CLEANUP]   - currentAnalysisMode:', currentAnalysisMode);
                console.log('✅ [CLEANUP]   - window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
                console.log('✅ [CLEANUP]   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('✅ [CLEANUP]   - FirstAnalysisStore.has():', FirstAnalysisStore.has());
                console.log('✅ [CLEANUP] ═══════════════════════════════════════');
                
                // Marcar que há uma comparação ativa
                window.__referenceComparisonActive = true;
                
                // EARLY RETURN: Não executa nenhuma limpeza
                // Continua para o próximo bloco de código sem deletar nada
            } else {
                // Modo normal (genre): limpar normalmente
                delete window.__REFERENCE_JOB_ID__;
                delete window.__FIRST_ANALYSIS_RESULT__;
                localStorage.removeItem('referenceJobId');
                
                console.log('✅ [CLEANUP] ═══════════════════════════════════════');
                console.log('✅ [CLEANUP] Referência removida (modo genre)');
                console.log('✅ [CLEANUP] ═══════════════════════════════════════');
            }
            
            // 🔒 MANTÉM: window.referenceAnalysisData e referenceComparisonMetrics para renderização
        } else {
            // Modo genre: análise por gênero tradicional
            __dbg('🎯 Exibindo resultado por gênero');
            await handleGenreAnalysisWithResult(analysisResult, file.name);
        }

    } catch (error) {
        console.error('🔴🔴🔴 [ERRO-CRÍTICO-CAPTURADO] ════════════════════════════════════');
        console.error('🔴 [ERRO-CRÍTICO] Erro capturado no handleModalFileSelection!');
        console.error('🔴 [ERRO-CRÍTICO] Error message:', error.message);
        console.error('🔴 [ERRO-CRÍTICO] Error stack:', error.stack);
        console.error('🔴 [ERRO-CRÍTICO] currentAnalysisMode ANTES:', currentAnalysisMode);
        console.error('🔴🔴🔴 [ERRO-CRÍTICO-CAPTURADO] ════════════════════════════════════');
        console.error('❌ Erro na análise do modal:', error);
        
        // 🔓 FIX BUG 3: Em modo anônimo, NUNCA resetar genre/mode após erro
        // Apenas permitir retry mantendo o estado atual
        const isAnonymousMode = window.SoundyAnonymous?.isAnonymousMode === true;
        if (isAnonymousMode) {
            console.log('🔓 [ANONYMOUS] Erro em modo anônimo - mantendo estado para retry');
            console.log('   🎵 Genre preservado:', window.__CURRENT_SELECTED_GENRE || window.PROD_AI_REF_GENRE);
            console.log('   🎯 Mode preservado:', currentAnalysisMode);
            
            // Mostrar erro específico mas NÃO resetar estado
            showModalError(error.message || 'Erro na análise. Tente novamente.');
            return; // EARLY RETURN - NÃO executa reset
        }
        
        // ✅ STEP 4/6: Bloquear fallback para genre em caso de self-compare ou circular structure
        const msg = String(error?.message || '');
        if (msg.includes('Self-compare') || msg.includes('circular structure')) {
            console.warn('[REF-FLOW] Erro de self-compare/circular structure — ignorando fallback pra genre.');
            showModalError('Erro de comparação detectado. Aguardando nova análise...');
            return; // Aborta sem resetar modo
        }
        
        // ========================================
        // 🛡️ [INVARIANTE #4] PROTEÇÃO: Fallback para gênero SOMENTE se não estiver em reference válido
        // ========================================
        if (currentAnalysisMode === 'reference') {
            console.group('[FALLBACK-GUARD] 🛡️ Verificando segurança do fallback');
            console.log('⚠️ Erro capturado durante reference mode');
            console.log('📊 Verificando se é seguro fazer fallback...');
            
            const smState = window.AnalysisStateMachine?.getState();
            const hasFirstAnalysis = window.FirstAnalysisStore?.has() || false;
            const hasContext = hasActiveReferenceContext();
            const smMode = smState?.mode;
            const userExplicitlySelected = smState?.userExplicitlySelected;
            
            console.log('[FALLBACK-GUARD] State Machine:', {
                mode: smMode,
                userExplicitlySelected,
                referenceFirstJobId: smState?.referenceFirstJobId,
                awaitingSecondTrack: smState?.awaitingSecondTrack
            });
            console.log('[FALLBACK-GUARD] FirstAnalysisStore.has():', hasFirstAnalysis);
            console.log('[FALLBACK-GUARD] hasActiveReferenceContext():', hasContext);
            console.log('[FALLBACK-GUARD] userExplicitlySelectedReferenceMode:', window.userExplicitlySelectedReferenceMode);
            console.groupEnd();
            
            // 🔒 [INVARIANTE #4] NUNCA fazer fallback se:
            // 1. Usuário selecionou explicitamente reference OU
            // 2. Já tem primeira análise salva OU
            // 3. Existe contexto ativo de referência
            const shouldBlockFallback = userExplicitlySelected || hasFirstAnalysis || hasContext;
            
            if (shouldBlockFallback) {
                console.log('%c[FALLBACK-GUARD] BLOQUEADO - mantendo reference mode', 'color:green;font-weight:bold;');
                console.log('[FALLBACK-GUARD] Razão:', 
                    userExplicitlySelected ? 'Usuário escolheu reference explicitamente' : 
                    hasFirstAnalysis ? 'Já tem primeira análise salva' :
                    'Contexto ativo de referência detectado'
                );
                
                showModalError(
                    hasFirstAnalysis 
                        ? 'Erro temporário na segunda faixa. Tente fazer upload novamente.' 
                        : 'Erro na primeira faixa. Por favor, tente novamente.'
                );
                // ✅ NÃO resetar modo - apenas mostrar erro e permitir retry
                return;
            } else {
                console.warn('%c[FALLBACK-GUARD] Permitindo fallback - sem contexto ativo', 'color:orange;font-weight:bold;');
                
                // Perguntar ao usuário explicitamente
                const userWantsFallback = confirm(
                    'A análise de referência encontrou um erro.\n\n' +
                    'Deseja tentar novamente (OK) ou usar análise por gênero (Cancelar)?'
                );
                
                if (!userWantsFallback) {
                    // Usuário escolheu fallback para gênero
                    console.warn('[FALLBACK-GUARD] Usuário optou por fallback para gênero');
                    currentAnalysisMode = 'genre';
                    persistReferenceFlag(false);
                    
                    // Atualizar state machine também
                    if (window.AnalysisStateMachine) {
                        window.AnalysisStateMachine.setMode('genre', { userExplicitlySelected: true });
                    }
                    
                    configureModalForMode('genre');
                } else {
                    // Usuário quer tentar reference novamente
                    console.log('[REF_DEBUG] Usuário optou por tentar reference novamente');
                    showModalError('Por favor, tente fazer upload da primeira faixa novamente.');
                }
            }
        } else {
            // Determinar tipo de erro para mensagem mais específica
            let errorMessage = error.message;
            if (error.message.includes('Falha ao gerar URL de upload')) {
                errorMessage = 'Falha ao gerar URL de upload. Verifique sua conexão e tente novamente.';
            } else if (error.message.includes('Falha ao enviar arquivo para análise')) {
                errorMessage = 'Falha ao enviar arquivo para análise. Verifique sua conexão e tente novamente.';
            }
            
            showModalError(`Erro ao processar arquivo: ${errorMessage}`);
        }
    } finally {
        // 🎵 WAV CLEANUP: Limpar otimizações WAV em caso de erro
        try {
            if (window.wavMobileOptimizer) {
                window.wavMobileOptimizer.cleanupWAVOptimizations();
            }
        } catch (cleanupError) {
            console.warn('WAV cleanup error in finally (non-critical):', cleanupError);
        }
        
        // 🔧 CORREÇÃO: Sempre limpar flag de análise em progresso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('✅ Flag de análise em progresso removida');
    }
}

// � NOVAS FUNÇÕES: Análise baseada em fileKey (pós-upload remoto)

/**
 * Processar análise por referência usando fileKey
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
// 🌐 NOVAS FUNÇÕES: Análise baseada em resultado remoto

/**
 * Processar análise por referência usando resultado remoto
 * @param {Object} analysisResult - Resultado da análise remota
 * @param {string} fileKey - Chave do arquivo no bucket
 * @param {string} fileName - Nome original do arquivo
 */
async function handleReferenceAnalysisWithResult(analysisResult, fileKey, fileName) {
    __dbg('🎯 Processando análise por referência com resultado remoto:', { fileKey, fileName });
    
    window.logReferenceEvent('reference_analysis_with_result_started', { 
        fileKey,
        fileName 
    });
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de análise inválido recebido do servidor');
        }
        
        updateModalProgress(90, '🎯 Aplicando resultado da análise...');
        
        // Determinar se é arquivo original ou de referência
        const isReference = currentAnalysisMode === 'reference' && uploadedFiles.original;
        const fileType = isReference ? 'reference' : 'original';
        
        // Armazenar resultado
        uploadedFiles[fileType] = {
            fileKey: fileKey,
            fileName: fileName,
            analysisResult: analysisResult
        };
        
        __dbg(`✅ Arquivo ${fileType} armazenado:`, uploadedFiles[fileType]);
        
        // Atualizar display na interface
        updateReferenceFileDisplay(fileType, fileName);
        
        // Log do evento
        window.logReferenceEvent('reference_file_processed', {
            fileType,
            fileName,
            hasResult: !!analysisResult
        });
        
        // Verificar se ambos os arquivos estão prontos para comparação
        if (uploadedFiles.original && uploadedFiles.reference) {
            enableReferenceComparison();
            updateModalProgress(100, '✅ Ambos os arquivos analisados! Comparação disponível.');
            
        
        }
        
    } catch (error) {
        console.error('❌ Erro ao processar análise por referência:', error);
        window.logReferenceEvent('reference_analysis_error', { 
            error: error.message,
            fileKey,
            fileName 
        });
        throw error;
    }
}

/**
 * Processar análise por gênero usando resultado remoto
 * @param {Object} analysisResult - Resultado da análise remota
 * @param {string} fileName - Nome original do arquivo
 */
async function handleGenreAnalysisWithResult(analysisResult, fileName) {
    __dbg('🎵 Processando análise por gênero com resultado remoto:', { fileName });
    
    // 🧩 AUDIT_REF_FIX: Verificar se NÃO estamos em modo reference antes de limpar
    const state = window.__soundyState || {};
    const currentMode = state?.render?.mode || currentAnalysisMode;
    const isSecondTrack = state?.reference?.isSecondTrack || false;
    
    // 🚨 PROTEÇÃO: NÃO limpar estado se estivermos em modo reference
    if (currentMode === 'reference' && isSecondTrack) {
        console.warn('⚠️ [AUDIT_REF_FIX] handleGenreAnalysisWithResult chamado em modo reference!');
        console.warn('⚠️ [AUDIT_REF_FIX] ABORTANDO limpeza para preservar dados A/B');
        console.log('[MODE LOCKED] reference - limpeza de estado BLOQUEADA');
        
        // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
        const normalizedResult = analysisResult; // ✅ LEITURA DIRETA
        
        // 🔒 POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        return normalizedResult;
    }
    
    // 🚨 BLINDAGEM: NÃO limpar estado em modo genre (preservar gênero)
    if (window.__CURRENT_MODE__ === 'genre') {
        console.warn('[GENRE-PROTECT] ⚠️ handleGenreAnalysisWithResult - limpeza BLOQUEADA em modo genre');
        console.log('[GENRE-PROTECT]   - Preservando:', {
            selectedGenre: window.__CURRENT_SELECTED_GENRE,
            mode: window.__CURRENT_MODE__
        });
        
        // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
        const normalizedResult = analysisResult; // ✅ LEITURA DIRETA
        AnalysisCache.put(normalizedResult);
        
        console.log('[GENRE-BEFORE-DISPLAY] 🎵 Genre preservado:', {
            preservedGenre: window.__CURRENT_SELECTED_GENRE,
            normalizedGenre: normalizedResult.genre
        });
        
        // ✅ Continuar processamento SEM limpar estado
        updateModalProgress(90, '🎵 Aplicando resultado da análise...');
        
        try {
            if (!analysisResult || typeof analysisResult !== 'object') {
                throw new Error('Resultado de análise inválido recebido do servidor');
            }
            
            return normalizedResult;
        } catch (error) {
            console.error('❌ Erro ao processar análise de gênero:', error);
            throw error;
        }
    }
    
    // 🧩 CORREÇÃO #1: Limpeza completa APENAS em modo Reference (quando não há segundo track)
    
    // Limpar completamente estado de referência
    state.userAnalysis = null;
    state.referenceAnalysis = null;
    state.previousAnalysis = null;
    
    if (state.reference) {
        state.reference.analysis = null;
        state.reference.isSecondTrack = false;
        state.reference.jobId = null;
        state.reference.userAnalysis = null;
        state.reference.referenceAnalysis = null;
    }
    
    // Forçar modo gênero explicitamente
    if (!state.render) state.render = {};
    state.render.mode = 'genre';
    
    window.__soundyState = state;
    
    // 🔒 HARD-GUARD: Limpar FirstAnalysisStore (única fonte de verdade)
    FirstAnalysisStore.clear();
    console.log('[CLEANUP] handleGenreAnalysisWithResult: FirstAnalysisStore limpo');
    
    // ❌ REMOVER: window.referenceAnalysisData agora é read-only (não pode ser setado)
    window.referenceComparisonMetrics = null;
    window.lastReferenceJobId = null;
    
    console.log('🎚️ [FIX-GENRE] Estado completamente limpo, modo forçado para "genre"');
    
    // 🔒 PATCH: PRESERVAR GÊNERO APÓS LIMPEZA
    preserveGenreState();
    
    try {
        // Verificar estrutura do resultado
        if (!analysisResult || typeof analysisResult !== 'object') {
            throw new Error('Resultado de análise inválido recebido do servidor');
        }
        
        updateModalProgress(90, '🎵 Aplicando resultado da análise...');
        
        // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
        // ❌ REMOVIDO: normalizeBackendAnalysisData() destrói dados
        const normalizedResult = analysisResult; // ✅ LEITURA DIRETA
        
        // 🔒 POPULAR CACHE COM RESULTADO DIRETO
        AnalysisCache.put(normalizedResult);
        
        // ========================================
        // 🔥 BARREIRA 3: LIMPEZA NO RECEBIMENTO DE ANÁLISE
        // ========================================
        // Se o backend retornar mode: "genre", garantir limpeza ANTES de processar
        const isGenreModeFromBackend = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreModeFromBackend) {
            console.log('%c[GENRE-BARRIER] 🚧 BARREIRA 3 ATIVADA: Análise de gênero recebida do backend', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
            console.log('[GENRE-BARRIER] normalizedResult.mode:', normalizedResult.mode);
            console.log('[GENRE-BARRIER] normalizedResult.isReferenceBase:', normalizedResult.isReferenceBase);
            
            // 🔥 EXECUTAR LIMPEZA COMPLETA
            // 🎯 PRESERVAR GÊNERO durante o reset
            const genreToPreserve = getActiveGenre(normalizedResult, window.PROD_AI_REF_GENRE);
            console.log('[GENRE-BARRIER] Gênero a preservar:', genreToPreserve);
            resetReferenceStateFully(genreToPreserve);
            
            // 🎯 GARANTIR que normalizedResult.genre está definido
            if (genreToPreserve && !normalizedResult.genre) {
                normalizedResult.genre = genreToPreserve;
                console.log('[GENRE-BARRIER] normalizedResult.genre restaurado:', genreToPreserve);
            }
            
            // 🔒 CONFIGURAR VIEW MODE
            setViewMode("genre");
            
            // 🔒 FORÇAR MODO GÊNERO
            window.currentAnalysisMode = 'genre';
            
            console.log('%c[GENRE-BARRIER] ✅ BARREIRA 3 CONCLUÍDA: Estado limpo antes de processar análise', 'color:#00FF88;font-weight:bold;');
        }
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 🎯 MODE ENGINE: Configuração baseada em mode + isReferenceBase
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // PRIMEIRA TRACK DO FLUXO A/B (mode: "genre" + isReferenceBase: true)
        if (normalizedResult.isReferenceBase === true && normalizedResult.mode === 'genre') {
            SOUNDY_MODE_ENGINE.startReferenceBase(normalizedResult);
            console.log('[MODE-ENGINE] Primeira track salva como referência base');
        }
        // SEGUNDA TRACK (mode: "reference" do backend)
        else if (normalizedResult.mode === 'reference') {
            SOUNDY_MODE_ENGINE.startReferenceCompare();
            console.log('[MODE-ENGINE] Segunda track detectada, modo A/B ativado');
        }
        
        // ✅ CORREÇÃO CRÍTICA: Carregar targets de gênero baseado em MODE, não em referenceComparison
        const isGenreMode = (
            normalizedResult.mode === 'genre' &&
            normalizedResult.isReferenceBase !== true
        );
        
        if (isGenreMode) {
            console.log('[GENRE-TARGETS] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('[GENRE-TARGETS] 🎵 MODO GÊNERO PURO DETECTADO');
            console.log('[GENRE-TARGETS] mode:', normalizedResult.mode);
            console.log('[GENRE-TARGETS] isReferenceBase:', normalizedResult.isReferenceBase);
            console.log('[GENRE-TARGETS] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            
            // 🔒 LIMPAR referenceComparison residual de sessões anteriores
            if (normalizedResult.referenceComparison) {
                console.log('[GENRE-TARGETS] ⚠️ referenceComparison residual detectado - removendo');
                delete normalizedResult.referenceComparison;
            }
            
            // Carregar targets de gênero de /refs/out/
            // 🎯 CORREÇÃO: Usar getActiveGenre ao invés de fallback direto para "default"
            const genreId = getActiveGenre(normalizedResult, null);
            
            if (!genreId) {
                console.warn('[GENRE-TARGETS] ⚠️ Nenhum gênero detectado - pulando carregamento de targets');
                console.warn('[GENRE-TARGETS] Fontes verificadas:', {
                    'normalizedResult.genre': normalizedResult.genre,
                    'normalizedResult.genreId': normalizedResult.genreId,
                    'normalizedResult.metadata?.genre': normalizedResult.metadata?.genre,
                    'window.__CURRENT_GENRE': window.__CURRENT_GENRE,
                    'window.PROD_AI_REF_GENRE': window.PROD_AI_REF_GENRE
                });
            } else {
                console.log(`[GENRE-TARGETS] Carregando targets para gênero: ${genreId}`);
            }
            
            // 🎯 VALIDAÇÃO: Só carregar se genreId for válido (não vazio, não 'default')
            if (genreId && genreId !== 'default') {
                try {
                    const response = await fetch(`/refs/out/${genreId}.json`);
                    if (response.ok) {
                        const rawJson = await response.json();
                        
                        // 🔥 CORREÇÃO CRÍTICA: Extrair o objeto interno do JSON
                        // O JSON tem estrutura: { "genreId": { ...dados... } }
                        const rootKey = Object.keys(rawJson)[0];
                        let targets = rawJson[rootKey] || rawJson;
                        
                        console.log('[GENRE-TARGETS] 📦 JSON bruto carregado:', { 
                            rootKey, 
                            hasRootKey: !!rootKey,
                            targetKeys: Object.keys(targets)
                        });
                        
                        // 🔥 CORREÇÃO CRÍTICA: Enriquecer targets usando enrichReferenceObject
                        targets = enrichReferenceObject(targets, genreId);
                        console.log('[GENRE-TARGETS] 🔧 Targets enriquecidos via enrichReferenceObject');
                        
                        // 🔍 DIAGNÓSTICO: Logs detalhados da estrutura após enriquecimento
                        console.log('[GENRE-TARGETS] 📊 Estrutura targets (APÓS enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasSpectralBands: !!targets?.spectral_bands,
                            spectralBandsCount: targets?.spectral_bands ? Object.keys(targets.spectral_bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasOriginalMetrics: !!targets?.original_metrics,
                            hasLufsTarget: targets?.lufs_target !== undefined,
                            hasTruePeakTarget: targets?.true_peak_target !== undefined,
                            hasDrTarget: targets?.dr_target !== undefined,
                            hasStereoTarget: targets?.stereo_target !== undefined
                        });
                        
                        // 🔍 DIAGNÓSTICO: Amostra das bandas
                        if (targets?.bands) {
                            const sampleBand = Object.keys(targets.bands)[0];
                            console.log('[GENRE-TARGETS] 📋 Amostra de banda:', sampleBand, targets.bands[sampleBand]);
                        }
                        
                        // 🔥 CORREÇÃO CRÍTICA: Criar referenceComparisonMetrics para UI
                        normalizedResult.referenceComparisonMetrics = {
                            bands: targets.bands || targets.spectral_bands,
                            spectralBands: targets.spectral_bands || targets.bands,
                            legacyBands: targets.legacy_compatibility?.bands,
                            originalMetrics: targets.original_metrics || targets.hybrid_processing?.original_metrics,
                            lufs_target: targets.lufs_target,
                            true_peak_target: targets.true_peak_target,
                            dr_target: targets.dr_target,
                            stereo_target: targets.stereo_target,
                            lra_target: targets.lra_target
                        };
                        console.log('[GENRE-TARGETS] 📦 referenceComparisonMetrics criado:', {
                            hasBands: !!normalizedResult.referenceComparisonMetrics.bands,
                            hasOriginalMetrics: !!normalizedResult.referenceComparisonMetrics.originalMetrics
                        });
                        
                        // 🔥 CORREÇÃO CRÍTICA: Atribuir targets a TODAS as variáveis globais
                        normalizedResult.referenceComparison = targets;
                        
                        // ✅ CORREÇÃO: Inicializar window.PROD_AI_REF_DATA como objeto se for false
                        if (!window.PROD_AI_REF_DATA || window.PROD_AI_REF_DATA === false) {
                            window.PROD_AI_REF_DATA = {};
                            console.log('[GENRE-TARGETS] 🔧 Inicializando window.PROD_AI_REF_DATA como objeto');
                        }
                        
                        // ✅ CORREÇÃO: Atribuir targets ao gênero específico
                        window.PROD_AI_REF_DATA[genreId] = targets;
                        console.log(`[GENRE-TARGETS] 📦 window.PROD_AI_REF_DATA['${genreId}'] atribuído`);
                        
                        // ✅ CORREÇÃO: Atualizar __activeRefData
                        window.__activeRefData = targets;
                        console.log('[GENRE-TARGETS] 📦 window.__activeRefData atualizado');
                        
                        // ✅ CORREÇÃO: Sincronizar gênero ativo
                        window.__CURRENT_GENRE = genreId;
                        console.log(`[GENRE-TARGETS] 🎯 window.__CURRENT_GENRE = '${genreId}'`);
                        
                        console.log(`[GENRE-TARGETS] ✅ Targets carregados e enriquecidos para ${genreId}`);
                        console.log('[GENRE-TARGETS] 📊 Estrutura targets (APÓS enriquecimento):', {
                            hasBands: !!targets?.bands,
                            bandsCount: targets?.bands ? Object.keys(targets.bands).length : 0,
                            hasLegacyCompatibility: !!targets?.legacy_compatibility,
                            hasHybridProcessing: !!targets?.hybrid_processing,
                            hasLufsTarget: !!targets?.lufs_target,
                            hasTruePeakTarget: !!targets?.true_peak_target,
                            hasDrTarget: !!targets?.dr_target,
                            hasStereoTarget: !!targets?.stereo_target
                        });
                        console.log('[GENRE-TARGETS] 📋 Targets.bands:', targets?.bands);
                    } else {
                        console.warn(`[GENRE-TARGETS] ⚠️ Arquivo não encontrado: /refs/out/${genreId}.json (${response.status})`);
                        console.warn(`[GENRE-TARGETS] Continuando sem targets específicos do gênero`);
                    }
                } catch (err) {
                    console.error("[GENRE-TARGETS] ❌ Erro ao carregar targets de gênero:", err);
                    console.error("[GENRE-TARGETS] Continuando com targets padrão ou sem targets");
                }
            } else {
                console.warn('[GENRE-TARGETS] ⚠️ GenreId inválido ou "default" - pulando fetch:', genreId);
            }
        } else {
            console.log("[GENRE-TARGETS] ⚠️ Não é modo gênero puro - pulando carregamento de targets");
            console.log("[GENRE-TARGETS] mode:", normalizedResult.mode);
            console.log("[GENRE-TARGETS] isReferenceBase:", normalizedResult.isReferenceBase);
        }
        
        // 🎯 CORREÇÃO CRÍTICA: Gerar sugestões no primeiro load
        if (__activeRefData && !normalizedResult._suggestionsGenerated) {
            console.log('🎯 [SUGGESTIONS] Engine chamado no primeiro load');
            try {
                updateReferenceSuggestions(normalizedResult, __activeRefData);
                normalizedResult._suggestionsGenerated = true;
                console.log(`🎯 [SUGGESTIONS] ${normalizedResult.suggestions?.length || 0} sugestões geradas no primeiro load`);
            } catch (error) {
                console.error('❌ [SUGGESTIONS] Erro ao gerar sugestões no primeiro load:', error);
            }
        } else if (!__activeRefData) {
            console.log('🎯 [SUGGESTIONS] Dados de referência não disponíveis para gerar sugestões');
        } else {
            console.log('🎯 [SUGGESTIONS] Sugestões já foram geradas anteriormente');
        }

        // 🚀 FORÇA EXIBIÇÃO: Sempre mostrar interface IA após sugestões serem processadas
        if (normalizedResult.suggestions && normalizedResult.suggestions.length > 0) {
            setTimeout(() => {
                console.log(`🚀 [AI-UI-FORCE] Tentando forçar interface IA aparecer com ${normalizedResult.suggestions.length} sugestões`);
                
                // Verificar múltiplas formas de chamar a interface IA
                if (window.aiUIController) {
                    console.log(`🚀 [AI-UI-FORCE] Usando aiUIController existente`);
                    window.aiUIController.checkForAISuggestions(normalizedResult, true);
                } else if (window.forceShowAISuggestions) {
                    console.log(`🚀 [AI-UI-FORCE] Usando forceShowAISuggestions como fallback`);
                    window.forceShowAISuggestions(normalizedResult);
                } else {
                    console.warn('⚠️ [AI-UI-FORCE] Nenhum método de interface IA encontrado, criando interface básica...');
                    
                    // Criar interface básica na hora
                    const aiSection = document.createElement('div');
                    aiSection.id = 'ai-suggestions-section';
                    aiSection.style.cssText = `
                        margin: 20px 0; padding: 20px; border: 2px solid #4CAF50;
                        border-radius: 10px; background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
                        color: white; font-family: Arial, sans-serif;
                    `;
                    aiSection.innerHTML = `
                        <h3 style="color: #4CAF50; margin: 0 0 15px 0;">🤖 Sugestões Inteligentes</h3>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #4CAF50;">
                            <p style="margin: 0 0 10px 0; color: #A5D6A7;">
                                💡 Interface IA carregada com ${normalizedResult.suggestions.length} sugestões
                            </p>
                            <p style="margin: 0; font-size: 14px; color: #81C784;">
                                Configure uma API Key da OpenAI para sugestões inteligentes personalizadas.
                            </p>
                            <button onclick="if(window.promptForAPIKey) window.promptForAPIKey(); else alert('Configure API Key da OpenAI para ativar IA')" 
                                    style="margin-top: 10px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                ⚙️ Configurar IA
                            </button>
                        </div>
                    `;
                    
                    // Inserir na interface
                    const modal = document.getElementById('audioAnalysisModal');
                    const content = modal?.querySelector('.modal-content');
                    if (content) {
                        // Remover seção anterior se existir
                        const existing = content.querySelector('#ai-suggestions-section');
                        if (existing) existing.remove();
                        
                        // Adicionar nova seção
                        content.appendChild(aiSection);
                        console.log('✅ [AI-UI-FORCE] Interface IA básica criada e inserida');
                    } else {
                        console.error('❌ [AI-UI-FORCE] Modal não encontrado para inserir interface');
                    }
                }
            }, 500); // Delay para garantir que o DOM esteja renderizado
        }
        
        // Definir como análise atual do modal
        currentModalAnalysis = normalizedResult;
        
        // 🚫 CRITICAL: Expor globalmente para premium-blocker e outros sistemas
        window.currentModalAnalysis = normalizedResult;
        window.__CURRENT_ANALYSIS__ = normalizedResult;
        
        // 🎯 ALIAS GLOBAL PARA RELATÓRIOS (Fonte de Verdade Única)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = normalizedResult;
            
            // Criar namespace global unificado
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = normalizedResult;
            
            console.log('✅ [PDF-READY] Análise armazenada globalmente:', {
                hasGlobalAlias: !!window.__soundyAI.analysis,
                hasCurrentModal: !!window.currentModalAnalysis,
                hasCurrent: !!window.__CURRENT_ANALYSIS__,
                fileName: normalizedResult.metadata?.fileName || normalizedResult.fileName,
                plan: normalizedResult.plan,
                analysisMode: normalizedResult.analysisMode,
                score: normalizedResult.score,
                hasMetrics: !!(normalizedResult.loudness || normalizedResult.technicalData)
            });
        }
        
        // 🔓 MODO ANÔNIMO: Registrar análise concluída
        if (window.SoundyAnonymous && window.SoundyAnonymous.isAnonymousMode) {
            window.SoundyAnonymous.registerAnalysis();
            console.log('🔓 [ANALYZER] Análise registrada no modo anônimo');
        }
        
        // ❌ REMOVIDO: Salvamento duplicado aqui
        // ✅ NOVO: Salvamento unificado acontece dentro de displayModalResults()
        // para garantir um único ponto de salvamento
        
        updateModalProgress(100, `✅ Análise de ${fileName} concluída!`);
        
        // ========================================
        // 🤖 AGUARDAR ENRIQUECIMENTO IA ANTES DE EXIBIR MODAL (MODO GENRE)
        // ========================================
        console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log('[AI-SYNC][GENRE] 🔍 Verificando status do enriquecimento IA...');
        console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        
        // Verificar se aiSuggestions já está presente
        const hasAISuggestionsGenre = Array.isArray(normalizedResult.aiSuggestions) && 
                                      normalizedResult.aiSuggestions.length > 0 &&
                                      normalizedResult.aiSuggestions.some(s => s.aiEnhanced === true);
        
        console.log('[AI-SYNC][GENRE] 📊 Estado atual:', {
            hasAiSuggestions: Array.isArray(normalizedResult.aiSuggestions),
            aiSuggestionsLength: normalizedResult.aiSuggestions?.length || 0,
            aiEnhancedCount: normalizedResult.aiSuggestions?.filter(s => s.aiEnhanced === true).length || 0,
            jobId: normalizedResult.jobId
        });
        
        if (!hasAISuggestionsGenre) {
            console.log('[AI-SYNC][GENRE] ⏳ aiSuggestions não está pronto, aguardando enriquecimento...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                console.error('[AI-SYNC][GENRE] ❌ jobId inválido, não é possível aguardar enriquecimento:', normalizedResult.jobId);
                console.warn('[AI-SYNC][GENRE] ⚠️ Pulando enriquecimento IA - usando dados já disponíveis');
            } else {
                // Mostrar spinner visual
                showAILoadingSpinner('🤖 Conectando à IA para análise avançada...');
            
            try {
                // Aguardar enriquecimento IA (timeout de 10 segundos, polling a cada 1 segundo)
                const enrichedDataGenre = await waitForAIEnrichment(normalizedResult.jobId, 10000, 1000);
                
                if (enrichedDataGenre && enrichedDataGenre.aiSuggestions && enrichedDataGenre.aiSuggestions.length > 0) {
                    // Sucesso: Mesclar aiSuggestions enriquecidas no normalizedResult
                    normalizedResult.aiSuggestions = enrichedDataGenre.aiSuggestions;
                    
                    console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('[AI-SYNC][GENRE] ✅ Enriquecimento IA mesclado com sucesso!');
                    console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('[AI-SYNC][GENRE] 📊 Total de aiSuggestions:', normalizedResult.aiSuggestions.length);
                    console.log('[AI-SYNC][GENRE] 🤖 Marcadas como aiEnhanced:', 
                        normalizedResult.aiSuggestions.filter(s => s.aiEnhanced === true).length);
                    
                    // Atualizar cache com dados enriquecidos
                    AnalysisCache.put(normalizedResult);
                    
                } else {
                    console.warn('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.warn('[AI-SYNC][GENRE] ⚠️ Enriquecimento IA não completou a tempo');
                    console.warn('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.warn('[AI-SYNC][GENRE] ℹ️ Modal será exibido com sugestões base');
                    console.warn('[AI-SYNC][GENRE] ℹ️ IA pode estar desabilitada ou sobrecarregada');
                }
                
            } catch (syncErrorGenre) {
                console.error('[AI-SYNC][GENRE] ❌ Erro ao aguardar enriquecimento IA:', syncErrorGenre);
                console.warn('[AI-SYNC][GENRE] ℹ️ Continuando com sugestões base...');
            } finally {
                // Remover spinner
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de validação
            
        } else {
            console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('[AI-SYNC][GENRE] ✅ aiSuggestions já presente no resultado!');
            console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
            console.log('[AI-SYNC][GENRE] ℹ️ Não é necessário aguardar, exibindo imediatamente');
        }
        
        console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        console.log('[AI-SYNC][GENRE] 🎬 Iniciando renderização do modal...');
        console.log('[AI-SYNC][GENRE] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        
        // ========================================
        // ✅ CORREÇÃO: Aguardar enriquecimento IA antes de abrir modal (MODO GENRE)
        // ========================================
        if (!normalizedResult.aiSuggestions || normalizedResult.aiSuggestions.length === 0) {
            console.log('[AI-SYNC][GENRE] ⏳ Enriquecimento IA ausente — aguardando resposta...');
            
            // PATCH JOB-ID: Validar jobId antes de chamar waitForAIEnrichment
            if (!normalizedResult.jobId || normalizedResult.jobId === 'undefined') {
                console.error('[AI-SYNC][GENRE] ❌ jobId inválido, não é possível aguardar enriquecimento:', normalizedResult.jobId);
                console.warn('[AI-SYNC][GENRE] ⚠️ Pulando enriquecimento IA - abrindo modal com dados disponíveis');
            } else {
                showAILoadingSpinner('🤖 Conectando à IA para análise avançada...');

                try {
                    const enrichedData = await waitForAIEnrichment(normalizedResult.jobId, 15000, 1500);

                if (enrichedData && enrichedData.aiSuggestions && enrichedData.aiSuggestions.length > 0) {
                    normalizedResult.aiSuggestions = enrichedData.aiSuggestions;
                    console.log(`[AI-SYNC][GENRE] ✅ Sugestões enriquecidas mescladas: ${enrichedData.aiSuggestions.length}`);
                } else {
                    console.warn('[AI-SYNC][GENRE] ⚠️ Timeout ou IA não retornou sugestões válidas. Fallback para sugestões base.');
                }
            } catch (error) {
                console.error('[AI-SYNC][GENRE] ❌ Erro ao aguardar sugestões enriquecidas:', error);
            } finally {
                hideAILoadingSpinner();
            }
            } // PATCH JOB-ID: Fim do bloco de validação
        }
        
        // ✅ Agora sim, exibe o modal com ou sem IA (fallback incluso)
        // 🛡️ VERIFICAÇÃO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            await displayModalResults(normalizedResult);
            console.log("[DISPLAY] Modal aberto com sucesso (modo genre)");
        } else {
            console.error('❌ [MODAL_MONITOR] Função displayModalResults não encontrada');
        }
        
    } catch (error) {
        console.error('❌ Erro ao processar análise por gênero:', error);
        throw error;
    }
}

/**
 * Atualizar display de arquivo de referência na interface
 * @param {string} fileType - Tipo do arquivo ('original' ou 'reference')
 * @param {string} fileName - Nome do arquivo
 */
function updateReferenceFileDisplay(fileType, fileName) {
    const displayElement = document.getElementById(`${fileType}FileDisplay`);
    if (displayElement) {
        displayElement.textContent = fileName;
        displayElement.style.display = 'block';
    }
    
    // Atualizar também elementos relacionados
    const labelElement = document.querySelector(`label[for="${fileType}FileInput"]`);
    if (labelElement) {
        labelElement.style.opacity = '0.7';
    }
}

/**
 * Habilitar botão de comparação de referência
 */
function enableReferenceComparison() {
    const compareButton = document.getElementById('compareButton');
    if (compareButton) {
        compareButton.disabled = false;
        compareButton.style.opacity = '1';
        compareButton.style.cursor = 'pointer';
    }
    
    // Atualizar indicador visual
    const indicator = document.querySelector('.reference-ready-indicator');
    if (indicator) {
        indicator.style.display = 'block';
    }
}


/**
 * Mostrar mensagem do próximo passo
 * @param {string} message - Mensagem a ser exibida
 */
function showNextStepMessage(message) {
    console.log(`➡️ ${message}`);
    
    // Implementar notificação visual se necessário
    const notification = document.createElement('div');
    notification.className = 'next-step-notification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    `;
    
    document.body.appendChild(notification);
    
    // Remover após 5 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 5000);
}

// �🎯 NOVO: Validação comum de arquivo
function validateAudioFile(file) {
    const MAX_UPLOAD_MB = 150;
    const MAX_UPLOAD_SIZE = MAX_UPLOAD_MB * 1024 * 1024;
    
    // Formatos aceitos: WAV, FLAC, MP3 (simplificado)
    const allowedTypes = ['audio/wav', 'audio/flac', 'audio/mpeg', 'audio/mp3'];
    const allowedExtensions = ['.wav', '.flac', '.mp3'];
    
    // Validar tipo de arquivo
    const isValidType = allowedTypes.includes(file.type.toLowerCase()) || 
                       allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));
    
    if (!isValidType) {
        showModalError(`Formato não suportado. Apenas WAV, FLAC e MP3 são aceitos.
                      💡 Prefira WAV ou FLAC para maior precisão na análise.`);
        return false;
    }
    
    // Validar tamanho (novo limite: 60MB)
    if (file.size > MAX_UPLOAD_SIZE) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        showModalError(`Arquivo muito grande: ${sizeInMB}MB. 
                      Limite máximo: ${MAX_UPLOAD_MB}MB.`);
        return false;
    }
    
    // 🎵 WAV MOBILE WARNING: Avisar sobre demora em arquivos WAV grandes no mobile
    const isWAV = file.name.toLowerCase().endsWith('.wav') || file.type.includes('wav');
    const isMobile = /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
    const isLargeWAV = isWAV && file.size > 20 * 1024 * 1024; // >20MB
    
    if (isLargeWAV && isMobile) {
        const sizeInMB = (file.size / 1024 / 1024).toFixed(1);
        const estimatedTime = Math.ceil(file.size / (2 * 1024 * 1024)); // ~2MB/s no mobile
        
        console.warn(`⏱️ WAV grande no mobile: ${sizeInMB}MB - tempo estimado: ${estimatedTime}s`);
        
        // Mostrar aviso não-bloqueante
        setTimeout(() => {
            if (document.getElementById('audioProgressText')) {
                document.getElementById('audioProgressText').innerHTML = 
                    `⏱️ Arquivo WAV grande (${sizeInMB}MB)<br>Tempo estimado: ${estimatedTime}-${estimatedTime*2}s<br>Aguarde...`;
            }
        }, 1000);
    }
    
    // Mostrar recomendação para MP3
    if (file.type === 'audio/mpeg' || file.type === 'audio/mp3' || file.name.toLowerCase().endsWith('.mp3')) {
        console.log('💡 MP3 detectado - Recomendação: Use WAV ou FLAC para maior precisão');
    }
    
    return true;
}

// 🎯 NOVO: Processar arquivo no modo referência
async function handleReferenceFileSelection(file) {
    // ═══════════════════════════════════════════════════════════════════════════════
    // 🔐 FAIL-SAFE: Bloqueio de entitlement no upload de referência
    // ═══════════════════════════════════════════════════════════════════════════════
    const { shouldBlock, plan } = checkReferenceEntitlementSync();
    if (shouldBlock) {
        console.log(`🔐 [ENTITLEMENT FAIL-SAFE] Upload de referência BLOQUEADO (plan=${plan})`);
        if (window.EntitlementsHandler?.showUpgradeModal) {
            window.EntitlementsHandler.showUpgradeModal('reference', plan);
        }
        return;
    }
    // ═══════════════════════════════════════════════════════════════════════════════
    
    // 🔓 [ANONYMOUS-MODE] Interceptar análise em modo anônimo
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            console.log('🚫 [ANONYMOUS] Análise referência bloqueada - limite atingido');
            return;
        }
    }
    
    window.logReferenceEvent('reference_file_selected', { 
        step: referenceStepState.currentStep,
        fileName: file.name,
        fileSize: file.size 
    });
    
    if (referenceStepState.currentStep === 'userAudio') {
        // Primeiro arquivo: música do usuário
        referenceStepState.userAudioFile = file;
        
        // 🐛 DIAGNÓSTICO: Verificar se está carregando dados de gênero no modo referência
        console.log('🔍 [DIAGNÓSTICO] Analisando USER audio em modo referência');
        console.log('🔍 [DIAGNÓSTICO] Current mode:', window.currentAnalysisMode);
        console.log('🔍 [DIAGNÓSTICO] Genre ativo antes da análise:', window.PROD_AI_REF_GENRE);
        console.log('🔍 [DIAGNÓSTICO] Active ref data:', !!__activeRefData);
        
        // Analisar arquivo do usuário
        showModalLoading();
        updateModalProgress(10, '🎵 Analisando sua música...');
        
        // 🎯 CORREÇÃO TOTAL: Analisar arquivo do usuário SEM aplicar targets
        const userAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparações
          debugModeReference: true,
          // Garantir mesmas configurações para ambos os arquivos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // 🆔 CORREÇÃO: Preparar options com runId
        const userOptionsWithRunId = prepareAnalysisOptions(userAnalysisOptions, 'user_ref');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, userOptionsWithRunId);
        
        // 🐛 VALIDAÇÃO: Verificar que não há comparação com gênero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('⚠️ [AVISO] Análise do usuário contaminada com comparação/score');
        }
        
        console.log('🔍 [DIAGNÓSTICO] User analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        referenceStepState.userAnalysis = analysis;
        
        // Avançar para próximo step
        updateReferenceStep('referenceAudio');
        updateUploadAreaForReferenceStep();
        
        window.logReferenceEvent('user_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
        
    } else if (referenceStepState.currentStep === 'referenceAudio') {
        // Segundo arquivo: música de referência
        referenceStepState.referenceAudioFile = file;
        
        // 🐛 DIAGNÓSTICO: Verificar análise do arquivo de referência
        console.log('🔍 [DIAGNÓSTICO] Analisando REFERENCE audio em modo referência');
        console.log('🔍 [DIAGNÓSTICO] Current mode:', window.currentAnalysisMode);
        console.log('🔍 [DIAGNÓSTICO] Genre ativo antes da análise:', window.PROD_AI_REF_GENRE);
        
        // Analisar arquivo de referência (extração de métricas com MESMAS configurações)
        showModalLoading();
        updateModalProgress(50, '🎯 Analisando música de referência...');
        
        // 🎯 CORREÇÃO TOTAL: Usar EXATAMENTE as mesmas configurações do usuário
        const refAnalysisOptions = { 
          mode: 'pure_analysis', // Modo puro, sem comparações
          debugModeReference: true,
          // 🎯 GARANTIR parâmetros idênticos
          normalizeLoudness: true,
          windowDuration: 30,
          fftSize: 4096
        };
        // 🆔 CORREÇÃO: Preparar options com runId
        const refOptionsWithRunId = prepareAnalysisOptions(refAnalysisOptions, 'ref_audio');
        const analysis = await window.audioAnalyzer.analyzeAudioFile(file, refOptionsWithRunId);
        
        // 🐛 VALIDAÇÃO: Verificar que não há comparação com gênero
        if (analysis.comparison || analysis.mixScore) {
          console.warn('⚠️ [AVISO] Análise da referência contaminada com comparação/score');
        }
        
        console.log('🔍 [DIAGNÓSTICO] Reference analysis (pura):', {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp,
          hasComparison: !!analysis.comparison,
          hasScore: !!analysis.mixScore
        });
        
        // 🎯 VALIDAÇÃO: Verificar se conseguimos extrair métricas válidas
        const referenceMetrics = {
          lufs: analysis.technicalData?.lufsIntegrated,
          stereoCorrelation: analysis.technicalData?.stereoCorrelation,
          dynamicRange: analysis.technicalData?.dynamicRange,
          truePeak: analysis.technicalData?.truePeakDbtp
        };
        
        // 🚨 ERRO CLARO: Falhar se não conseguir extrair métricas
        if (!Number.isFinite(referenceMetrics.lufs)) {
          throw new Error('REFERENCE_METRICS_FAILED: Não foi possível extrair métricas LUFS da música de referência. Verifique se o arquivo é válido.');
        }
        
        if (!Number.isFinite(referenceMetrics.stereoCorrelation)) {
          throw new Error('REFERENCE_METRICS_FAILED: Não foi possível extrair correlação estéreo da música de referência.');
        }
        
        console.log('✅ [SUCESSO] Métricas da referência extraídas:', referenceMetrics);
        
        referenceStepState.referenceAnalysis = analysis;
        referenceStepState.referenceMetrics = referenceMetrics;
        
        // Executar comparação
        updateReferenceStep('analysis');
        await performReferenceComparison();
        
        // 🎯 EXIBIR resultados da análise por referência
        const finalAnalysis = referenceStepState.finalAnalysis;
        
        updateModalProgress(100, '✅ Análise por referência concluída!');
        
        // 🎯 LOGS finais de validação
        console.log('🎉 [ANÁLISE POR REFERÊNCIA] Concluída com sucesso:');
        console.log('  - Baseline source:', finalAnalysis.comparison?.baseline_source);
        console.log('  - LUFS difference:', finalAnalysis.comparison?.loudness?.difference?.toFixed(2));
        console.log('  - Sugestões:', finalAnalysis.suggestions?.length || 0);
        console.log('  - Sem gênero:', !finalAnalysis.genre);
        
        // Exibir modal de resultados
        displayReferenceResults(finalAnalysis);
        
        window.logReferenceEvent('reference_audio_analyzed', { 
            fileName: file.name,
            hasAnalysis: !!analysis 
        });
    }
}

// 🎯 NOVO: Processar arquivo no modo gênero (comportamento original)
async function handleGenreFileSelection(file) {
    // � [ANONYMOUS-MODE] Interceptar análise em modo anônimo
    if (window.SoundyAnonymous?.isAnonymousMode) {
        const canProceed = window.SoundyAnonymous.interceptAnalysis();
        if (!canProceed) {
            console.log('🚫 [ANONYMOUS] Análise gênero bloqueada - limite atingido');
            return;
        }
    }
    
    // �🐛 DIAGNÓSTICO: Confirmar que este é o modo gênero
    console.log('🔍 [DIAGNÓSTICO] handleGenreFileSelection - modo:', window.currentAnalysisMode);
    console.log('🔍 [DIAGNÓSTICO] Este deveria ser APENAS modo gênero!');
    
    __dbg('🔄 Iniciando nova análise - forçando exibição do loading');
    showModalLoading();
    updateModalProgress(10, '⚡ Carregando Algoritmos Avançados...');
    
    // Aguardar audio analyzer carregar se necessário
    if (!window.audioAnalyzer) {
        __dbg('⏳ Aguardando Audio Analyzer carregar...');
        updateModalProgress(30, '🔧 Inicializando V2 Engine...');
        await waitForAudioAnalyzer();
    }

    // 🐛 CORREÇÃO CRÍTICA: Só carregar referências de gênero se estivermos NO MODO GÊNERO
    if (window.currentAnalysisMode === 'genre') {
        // 🎯 FALLBACK SEGURO: Restaurar gênero do localStorage se não estiver setado
        if (!window.PROD_AI_REF_GENRE) {
            const savedGenre = localStorage.getItem('prodai_ref_genre');
            if (savedGenre) {
                console.log('🔧 [GENRE-FALLBACK] Restaurando gênero do localStorage:', savedGenre);
                window.PROD_AI_REF_GENRE = savedGenre;
            } else {
                console.error('❌ [GENRE-CRITICAL] Gênero não encontrado - modo gênero sem targets');
            }
        }
        
        // 🎯 CORREÇÃO CRÍTICA: RESETAR ESTADO DE REFERÊNCIA ANTES DE CARREGAR TARGETS DE GÊNERO
        // 🎯 PRESERVAR GÊNERO durante o reset
        const currentGenre = window.PROD_AI_REF_GENRE || window.__CURRENT_GENRE;
        console.log('🧹 [GENRE-MODE] Resetando estado de referência antes de carregar targets...');
        console.log('🧹 [GENRE-MODE] Gênero preservado:', currentGenre);
        resetReferenceStateFully(currentGenre);
        
        // Garantir que referências do gênero selecionado estejam carregadas antes da análise
        try {
            const genre = window.PROD_AI_REF_GENRE;
            console.log('🔍 [DIAGNÓSTICO] Carregando referências de gênero:', genre);
            
            // ✅ CORREÇÃO: Sempre carregar targets se gênero existir
            if (genre) {
                updateModalProgress(25, `📚 Carregando referências: ${genre}...`);
                await loadReferenceData(genre);
                updateModalProgress(30, '📚 Referências ok');
                
                // ✅ VALIDAÇÃO: Confirmar que targets foram carregados
                if (!window.__activeRefData) {
                    console.error('❌ [GENRE-CRITICAL] Falha ao carregar targets de gênero');
                } else {
                    console.log('✅ [GENRE-SUCCESS] Targets carregados:', {
                        genre,
                        hasBands: !!window.__activeRefData.bands,
                        lufsTarget: window.__activeRefData.lufs_target
                    });
                }
            }
        } catch (e) { 
            console.error('❌ [GENRE-ERROR] Erro ao carregar referências de gênero:', e);
        }
    } else {
        console.log('🔍 [DIAGNÓSTICO] PULAR carregamento de referências - modo não é gênero');
    }
    
    // Analisar arquivo
    __dbg('🔬 Iniciando análise...');
    updateModalProgress(40, '🎵 Processando Waveform Digital...');
    
    // � WAV MOBILE OPTIMIZATION: Aplicar otimizações específicas para WAV
    try {
        // Carregar otimizador WAV se não estiver disponível
        if (typeof window.wavMobileOptimizer === 'undefined') {
            const optimizerScript = document.createElement('script');
            optimizerScript.src = '/lib/audio/wav-mobile-optimizer.js';
            optimizerScript.type = 'module';
            document.head.appendChild(optimizerScript);
            
            // Aguardar carregamento com timeout
            await new Promise((resolve) => {
                optimizerScript.onload = () => {
                    console.log('🎵 WAV optimizer carregado');
                    resolve();
                };
                optimizerScript.onerror = () => {
                    console.warn('⚠️ WAV optimizer falhou ao carregar');
                    resolve();
                };
                setTimeout(resolve, 1500); // fallback timeout
            });
        }
        
        // Aplicar otimizações se disponível
        if (window.wavMobileOptimizer) {
            const wavAnalysis = window.wavMobileOptimizer.applyWAVOptimizations(file);
            if (wavAnalysis.requiresOptimization) {
                updateModalProgress(45, `🎵 WAV ${wavAnalysis.sizeInMB}MB - otimização mobile ativa...`);
                console.log('🎵 WAV mobile optimizations applied:', wavAnalysis);
            }
        }
    } catch (optimizerError) {
        console.warn('⚠️ WAV optimizer failed, continuing with standard processing:', optimizerError);
    }
    
    // �🎯 CORREÇÃO: Passar modo correto para análise
    const analysisOptions = { 
      mode: window.currentAnalysisMode || 'genre' 
    };
    // 🆔 CORREÇÃO: Preparar options com runId para análise principal
    const optionsWithRunId = prepareAnalysisOptions(analysisOptions, 'main');
    const analysis = await window.audioAnalyzer.analyzeAudioFile(file, optionsWithRunId);
    currentModalAnalysis = analysis;
    
    // 🚫 CRITICAL: Expor globalmente para premium-blocker
    window.currentModalAnalysis = analysis;
    window.__CURRENT_ANALYSIS__ = analysis;
    
    // 🎵 WAV CLEANUP: Limpar otimizações WAV após conclusão
    try {
        if (window.wavMobileOptimizer) {
            window.wavMobileOptimizer.cleanupWAVOptimizations();
        }
    } catch (cleanupError) {
        console.warn('WAV cleanup error (non-critical):', cleanupError);
    }
    
    __dbg('✅ Análise concluída:', analysis);
    
    updateModalProgress(90, '🧠 Computando Métricas Avançadas...');
    
    // Aguardar um pouco para melhor UX
    await new Promise(resolve => setTimeout(resolve, 500));
    
    updateModalProgress(100, '✨ Análise Completa - Pronto!');
    
    // Mostrar resultados
    setTimeout(() => {
        // 🔒 FASE 2 UI GATE: Verificar se análise ainda é válida
        const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
        const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
        
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`🚫 [UI_GATE] Análise cancelada - não renderizar UI (análise: ${analysisRunId}, atual: ${currentRunId})`);
            return;
        }
        
        // Telemetria: verificar elementos alvo antes de preencher o modal
        const exists = {
            audioUploadArea: !!document.getElementById('audioUploadArea'),
            audioAnalysisLoading: !!document.getElementById('audioAnalysisLoading'),
            audioAnalysisResults: !!document.getElementById('audioAnalysisResults'),
            modalTechnicalData: !!document.getElementById('modalTechnicalData')
        };
        __dbg('🛰️ [Telemetry] Front antes de preencher modal (existência de elementos):', exists);
        
        // 🔒 UI GATE: Verificar novamente antes de renderizar
        if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
            __dbg(`🚫 [UI_GATE] Verificação dupla - análise cancelada durante delay`);
            return;
        }
        
        // 🛡️ VERIFICAÇÃO DEFENSIVA: Garantir que displayModalResults existe
        if (typeof displayModalResults === 'function') {
            displayModalResults(analysis);
        } else {
            console.warn('⚠️ [MODAL_MONITOR] Função displayModalResults não encontrada, aguardando carregamento...');
            // Tentar novamente em 1 segundo
            setTimeout(() => {
                if (typeof displayModalResults === 'function') {
                    displayModalResults(analysis);
                } else {
                    console.error('❌ [MODAL_MONITOR] Timeout - função displayModalResults não encontrada após espera');
                }
            }, 1000);
        }
        
        // 🔧 CORREÇÃO: Limpar flag de análise em progresso após sucesso
        if (typeof window !== 'undefined') {
            delete window.__MODAL_ANALYSIS_IN_PROGRESS__;
        }
        __dbg('✅ Análise concluída com sucesso - flag removida');
    }, 800);
}

// 🎯 NOVO: Atualizar upload area para step de referência
function updateUploadAreaForReferenceStep() {
    const uploadArea = document.getElementById('audioUploadArea');
    if (!uploadArea) return;
    
    const uploadContent = uploadArea.querySelector('.upload-content');
    if (!uploadContent) return;
    
    // Limpar input de arquivo
    const fileInput = document.getElementById('modalAudioFileInput');
    if (fileInput) {
        fileInput.value = '';
    }
    
    // Atualizar conteúdo baseado no step
    if (referenceStepState.currentStep === 'referenceAudio') {
        const icon = uploadContent.querySelector('.upload-icon');
        const title = uploadContent.querySelector('h4');
        const description = uploadContent.querySelector('p:not(.supported-formats):not(.format-recommendation)');
        
        if (icon) icon.textContent = '🎯';
        if (title) title.textContent = 'Música de Referência';
        if (description) description.textContent = 'Agora selecione a música que servirá como referência para comparação';
    }
    
    // Mostrar upload area novamente
    uploadArea.style.display = 'block';
    
    // Esconder loading
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) loading.style.display = 'none';
    
    window.logReferenceEvent('upload_area_updated', { 
        step: referenceStepState.currentStep 
    });
}

// 🎯 REESCRITA COMPLETA: Comparação baseada exclusivamente na referência
async function performReferenceComparison() {
    window.logReferenceEvent('reference_comparison_started');
    
    try {
        updateModalProgress(70, '🔄 Comparando as duas músicas...');
        
        const userAnalysis = referenceStepState.userAnalysis;
        const refAnalysis = referenceStepState.referenceAnalysis;
        const referenceMetrics = referenceStepState.referenceMetrics;
        
        if (!userAnalysis || !refAnalysis || !referenceMetrics) {
            throw new Error('COMPARISON_DATA_MISSING: Análises ou métricas de referência não encontradas');
        }
        
        // 🎯 EXTRAIR métricas do usuário (análise pura, sem comparações)
        const userMetrics = {
            lufs: userAnalysis.technicalData?.lufsIntegrated,
            stereoCorrelation: userAnalysis.technicalData?.stereoCorrelation,
            dynamicRange: userAnalysis.technicalData?.dynamicRange,
            truePeak: userAnalysis.technicalData?.truePeakDbtp
        };
        
        // 🚨 VALIDAÇÃO: Verificar métricas do usuário
        if (!Number.isFinite(userMetrics.lufs)) {
            throw new Error('USER_METRICS_FAILED: Não foi possível extrair métricas LUFS da sua música');
        }
        
        console.log('🔍 [COMPARAÇÃO] Métricas extraídas:');
        console.log('  - Usuário:', userMetrics);
        console.log('  - Referência:', referenceMetrics);
        
        // 🎯 CALCULAR diferenças PURAS (referência como baseline)
        const differences = {
            lufs: userMetrics.lufs - referenceMetrics.lufs,
            stereoCorrelation: userMetrics.stereoCorrelation - referenceMetrics.stereoCorrelation,
            dynamicRange: userMetrics.dynamicRange - referenceMetrics.dynamicRange,
            truePeak: userMetrics.truePeak - referenceMetrics.truePeak
        };
        
        console.log('🔍 [COMPARAÇÃO] Diferenças calculadas:', differences);
        
        // 🎯 GERAR sugestões baseadas APENAS na referência
        const referenceSuggestions = [];
        const THRESHOLD = 0.2; // Ignorar diferenças menores que 0.2dB
        
        // Loudness (LUFS) - 🚨 COM VERIFICAÇÃO DE HEADROOM SEGURO
        if (Math.abs(differences.lufs) > THRESHOLD) {
            const action = differences.lufs > 0 ? 'Diminuir' : 'Aumentar';
            const direction = differences.lufs > 0 ? 'decrease' : 'increase';
            const adjustmentDb = Math.abs(differences.lufs);
            
            // 🔒 Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                const userTruePeak = userMetrics.truePeak;
                const clippingSamples = userAnalysis.technical?.clippingSamples || 0;
                const isClipped = clippingSamples > 0;
                const headroomSafetyMargin = -0.6; // Target true peak seguro
                
                // 🚨 REGRA 1: Se CLIPPED, não sugerir aumento
                if (isClipped) {
                    console.log(`[REF-HEADROOM] 🚨 Clipping detectado - não sugerindo aumento de ${adjustmentDb.toFixed(1)}dB`);
                    referenceSuggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: `Impossível igualar referência - áudio tem clipping`,
                        action: `Primeiro resolver clipping, depois ajustar para referência`,
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        baseline_source: 'reference_audio',
                        warning: `Clipping detectado (${clippingSamples} samples)`
                    });
                } 
                // 🚨 REGRA 2: Verificar headroom disponível
                else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        referenceSuggestions.push({
                            type: 'reference_loudness',
                            message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar à música de referência`,
                            action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            baseline_source: 'reference_audio',
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponível`
                        });
                    } else {
                        console.log(`[REF-HEADROOM] ⚠️ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB - bloqueando`);
                        referenceSuggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: `Impossível igualar referência - sem headroom suficiente`,
                            action: `True Peak ${userTruePeak.toFixed(1)}dBTP permite apenas +${availableHeadroom.toFixed(1)}dB`,
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            baseline_source: 'reference_audio',
                            warning: `Necessário ${adjustmentDb.toFixed(1)}dB mas só ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    referenceSuggestions.push({
                        type: 'reference_loudness_conservative',
                        message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar referência (verificar clipping)`,
                        action: `${action} volume CUIDADOSAMENTE em ${adjustmentDb.toFixed(1)}dB`,
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        baseline_source: 'reference_audio',
                        warning: 'Sem dados True Peak - verifique clipping após ajuste'
                    });
                }
            } else {
                // Diminuir é sempre seguro
                referenceSuggestions.push({
                    type: 'reference_loudness',
                    message: `${action} volume em ${adjustmentDb.toFixed(1)}dB para igualar à música de referência`,
                    action: `${action} volume em ${adjustmentDb.toFixed(1)}dB`,
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction,
                    baseline_source: 'reference_audio'
                });
            }
        }
        
        // Dynamic Range
        if (Math.abs(differences.dynamicRange) > THRESHOLD) {
            const action = differences.dynamicRange > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_dynamics',
                message: `${action} range dinâmico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB para igualar à referência`,
                action: `${action} range dinâmico em ${Math.abs(differences.dynamicRange).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.dynamicRange),
                baseline_source: 'reference_audio'
            });
        }
        
        // Stereo Correlation
        if (Math.abs(differences.stereoCorrelation) > 0.05) { // 5% threshold para correlação
            const action = differences.stereoCorrelation > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_stereo',
                message: `${action} correlação estéreo para igualar à referência (diferença: ${(differences.stereoCorrelation * 100).toFixed(1)}%)`,
                action: `Ajustar correlação estéreo`,
                frequency_range: 'N/A',
                baseline_source: 'reference_audio'
            });
        }
        
        // Pico Real
        if (Math.abs(differences.truePeak) > THRESHOLD) {
            const action = differences.truePeak > 0 ? 'Reduzir' : 'Aumentar';
            referenceSuggestions.push({
                type: 'reference_peak',
                message: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB para igualar à referência`,
                action: `${action} pico em ${Math.abs(differences.truePeak).toFixed(1)}dB`,
                frequency_range: 'N/A',
                adjustment_db: Math.abs(differences.truePeak),
                baseline_source: 'reference_audio'
            });
        }
        
        console.log(`🔍 [COMPARAÇÃO] Sugestões geradas: ${referenceSuggestions.length}`);
        
        // 🎯 CRIAR análise final com comparação pura
        const finalAnalysis = {
            ...userAnalysis,
            comparison: {
                mode: 'reference',
                baseline_source: 'reference_audio',
                loudness: {
                    user: userMetrics.lufs,
                    reference: referenceMetrics.lufs,
                    difference: differences.lufs,
                    baseline: referenceMetrics.lufs
                },
                dynamics: {
                    user: userMetrics.dynamicRange,
                    reference: referenceMetrics.dynamicRange,
                    difference: differences.dynamicRange,
                    baseline: referenceMetrics.dynamicRange
                },
                stereo: {
                    user: userMetrics.stereoCorrelation,
                    reference: referenceMetrics.stereoCorrelation,
                    difference: differences.stereoCorrelation,
                    baseline: referenceMetrics.stereoCorrelation
                },
                peak: {
                    user: userMetrics.truePeak,
                    reference: referenceMetrics.truePeak,
                    difference: differences.truePeak,
                    baseline: referenceMetrics.truePeak
                }
            },
            suggestions: referenceSuggestions,
            // 🚫 NUNCA usar gênero em modo referência
            genre: null,
            mixScore: null, // Não gerar score baseado em gênero
            mixClassification: null
        };
        
        // 🎯 LOGS de validação final
        console.log('🎉 [SUCESSO] Comparação por referência concluída:');
        console.log('  - Modo:', finalAnalysis.comparison.mode);
        console.log('  - Baseline source:', finalAnalysis.comparison.baseline_source);
        console.log('  - Sugestões:', referenceSuggestions.length);
        console.log('  - Sem contaminação de gênero:', !finalAnalysis.genre);
        
        referenceStepState.finalAnalysis = finalAnalysis;
        console.log('🔍 [DIAGNÓSTICO] Reference analysis tem comparação com gênero:', !!refAnalysis.comparison);
        
        // 🎯 NOVO: Verificar se análises estão "limpas" (sem contaminar com gênero)
        const userClean = !userAnalysis.comparison && !userAnalysis.reference;
        const refClean = !refAnalysis.comparison && !refAnalysis.reference;
        console.log('🔍 [DIAGNÓSTICO] User analysis clean (sem gênero):', userClean);
        console.log('🔍 [DIAGNÓSTICO] Reference analysis clean (sem gênero):', refClean);
        
        // Gerar comparação
        const comparison = generateComparison(userAnalysis, refAnalysis);
        
        // 🐛 DIAGNÓSTICO: Verificar se comparison está usando os dados corretos
        console.log('🔍 [DIAGNÓSTICO] Comparison gerada:', comparison);
        console.log('🔍 [DIAGNÓSTICO] baseline_source: reference_audio (confirmed)');
        
        // Gerar sugestões baseadas na comparação
        const suggestions = generateReferenceSuggestions(comparison);
        
        // 🎯 CORREÇÃO #4: Garantir pelo menos 3 sugestões A/B
        console.log('🔍 [AB-SUGGESTIONS] Sugestões geradas:', suggestions.length);
        if (suggestions.length < 3) {
            console.warn('[AB-SUGGESTIONS] ⚠️ Menos de 3 sugestões - gerando padrão');
            // Garantir pelo menos 3 sugestões mínimas
            while (suggestions.length < 3) {
                suggestions.push({
                    type: 'reference_info',
                    message: 'Análise de comparação A/B concluída',
                    action: 'Continue monitorando as diferenças entre suas faixas',
                    explanation: 'Use a tabela acima para identificar áreas de melhoria',
                    frequency_range: 'N/A',
                    adjustment_db: 0,
                    direction: 'info'
                });
            }
        }
        
        // 🐛 DIAGNÓSTICO: Verificar se sugestões são baseadas apenas na comparison
        console.log('🔍 [DIAGNÓSTICO] Sugestões geradas (count):', suggestions.length);
        console.log('🔍 [DIAGNÓSTICO] Primeiro tipo de sugestão:', suggestions[0]?.type);
        
        // Criar análise combinada para exibição
        const combinedAnalysis = {
            ...userAnalysis,
            comparison,
            // 🎯 CORREÇÃO #4: Merge seguro de sugestões (user + A/B), sem duplicar
            suggestions: [
                ...(userAnalysis.suggestions || []),
                ...suggestions.filter(s => !userAnalysis.suggestions?.some(us => us.type === s.type))
            ],
            analysisMode: 'reference',
            referenceFile: referenceStepState.referenceAudioFile.name,
            userFile: referenceStepState.userAudioFile.name,
            // 🎯 NOVO: Incluir métricas da referência para renderReferenceComparisons
            referenceMetrics: {
                lufs: refAnalysis.technicalData?.lufsIntegrated,
                truePeakDbtp: refAnalysis.technicalData?.truePeakDbtp,
                dynamicRange: refAnalysis.technicalData?.dynamicRange,
                lra: refAnalysis.technicalData?.lra,
                stereoCorrelation: refAnalysis.technicalData?.stereoCorrelation,
                // 🔧 CORREÇÃO: Criar estrutura de bands compatível
                bands: refAnalysis.technicalData?.bandEnergies ? (() => {
                    const refBands = {};
                    const refBandEnergies = refAnalysis.technicalData.bandEnergies;
                    
                    // Criar estrutura de bands usando as métricas da referência como targets
                    Object.entries(refBandEnergies).forEach(([bandName, bandData]) => {
                        if (bandData && Number.isFinite(bandData.rms_db)) {
                            refBands[bandName] = {
                                target_db: bandData.rms_db,  // Usar valor da referência como target
                                tol_db: 3.0,  // Tolerância padrão
                                _target_na: false
                            };
                        }
                    });
                    
                    return refBands;
                })() : null
            },
            // 🐛 DIAGNÓSTICO: Adicionar metadados para diagnóstico
            _diagnostic: {
                baseline_source: 'reference_audio',
                mode: 'reference',
                userLufs: userAnalysis.technicalData?.lufsIntegrated,
                referenceLufs: refAnalysis.technicalData?.lufsIntegrated,
                difference: comparison.loudness?.difference,
                genreActive: window.PROD_AI_REF_GENRE,
                useGenreTargets: false,
                // 🎯 NOVO: Informações de normalização e janela
                usedWindowSeconds: 30, // TODO: pegar do analyzer quando implementado
                normalizedLUFS: {
                    user: userAnalysis.technicalData?.lufsIntegrated,
                    ref: refAnalysis.technicalData?.lufsIntegrated
                },
                analysisTimestamp: new Date().toISOString()
            }
        };
        
        console.log('🔍 [DIAGNÓSTICO] Combined analysis diagnostic:', combinedAnalysis._diagnostic);
        
        currentModalAnalysis = combinedAnalysis;
        
        // 🚫 CRITICAL: Expor globalmente para premium-blocker
        window.currentModalAnalysis = combinedAnalysis;
        window.__CURRENT_ANALYSIS__ = combinedAnalysis;
        
        // 🎯 ALIAS GLOBAL PARA RELATÓRIOS (Modo Referência)
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_RESULT__ = combinedAnalysis;
            window.__soundyAI = window.__soundyAI || {};
            window.__soundyAI.analysis = combinedAnalysis;
            
            console.log('✅ [PDF-READY] Comparação armazenada globalmente:', {
                mode: 'reference',
                hasComparison: !!combinedAnalysis.comparison,
                userFile: combinedAnalysis.userFile,
                referenceFile: combinedAnalysis.referenceFile
            });
        }
        
        updateModalProgress(100, '✨ Comparação Completa!');
        
        // Mostrar resultados
        setTimeout(() => {
            // 🔒 UI GATE: Verificar se análise ainda é válida
            const analysisRunId = combinedAnalysis?.runId || combinedAnalysis?.metadata?.runId;
            const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
            
            if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
                console.warn(`🚫 [UI_GATE] Comparação cancelada - não renderizar UI (análise: ${analysisRunId}, atual: ${currentRunId})`);
                return;
            }
            
            displayModalResults(combinedAnalysis);
            window.logReferenceEvent('reference_comparison_completed');
        }, 800);
        
    } catch (error) {
        console.error('❌ Erro na comparação:', error);
        window.logReferenceEvent('reference_comparison_error', { error: error.message });
        showModalError(`Erro na comparação: ${error.message}`);
    }
}

// 🎯 NOVO: Gerar comparação entre duas análises
function generateComparison(userAnalysis, refAnalysis) {
    const userTech = userAnalysis.technicalData || {};
    const refTech = refAnalysis.technicalData || {};
    
    return {
        loudness: {
            user: userTech.lufsIntegrated || null,
            reference: refTech.lufsIntegrated || null,
            difference: (userTech.lufsIntegrated && refTech.lufsIntegrated) 
                ? userTech.lufsIntegrated - refTech.lufsIntegrated 
                : null
        },
        dynamics: {
            user: userTech.lra || userTech.crestFactor || null,
            reference: refTech.lra || refTech.crestFactor || null,
            difference: (userTech.lra && refTech.lra) 
                ? userTech.lra - refTech.lra 
                : null
        },
        stereo: {
            user: userTech.stereoCorrelation || null,
            reference: refTech.stereoCorrelation || null,
            difference: (userTech.stereoCorrelation && refTech.stereoCorrelation) 
                ? userTech.stereoCorrelation - refTech.stereoCorrelation 
                : null
        },
        spectral: compareSpectralData(userTech, refTech)
    };
}

// 🎯 NOVO: Comparar dados espectrais
function compareSpectralData(userTech, refTech) {
    const bandNames = ['subBass', 'bass', 'lowMid', 'mid', 'upperMid', 'presence', 'brilliance', 'air'];
    const comparisons = {};
    
    bandNames.forEach(band => {
        const userValue = userTech[`${band}Energy`] || userTech[`energy_${band}`] || null;
        const refValue = refTech[`${band}Energy`] || refTech[`energy_${band}`] || null;
        
        if (userValue !== null && refValue !== null) {
            comparisons[band] = {
                user: userValue,
                reference: refValue,
                difference: userValue - refValue
            };
        }
    });
    
    return comparisons;
}

// 🎯 NOVO: Gerar sugestões baseadas na comparação
function generateReferenceSuggestions(comparison) {
    // 🐛 DIAGNÓSTICO: Logs para verificar fonte dos dados
    console.log('🔍 [DIAGNÓSTICO] generateReferenceSuggestions called with:', comparison);
    console.log('🔍 [DIAGNÓSTICO] Usando APENAS dados da comparison, não genre targets');
    console.log('🔍 [DIAGNÓSTICO] Genre ativo (NÃO usado):', window.PROD_AI_REF_GENRE);
    
    const suggestions = [];
    
    // Sugestões de loudness - 🚨 COM VERIFICAÇÃO DE HEADROOM SEGURO
    if (comparison.loudness.difference !== null) {
        const diff = comparison.loudness.difference;
        console.log('🔍 [DIAGNÓSTICO] Loudness difference:', diff);
        
        if (Math.abs(diff) > 1) {
            const adjustmentDb = Math.abs(diff);
            const direction = diff > 0 ? 'decrease' : 'increase';
            
            // 🔒 Verificar headroom se sugerindo aumento
            if (direction === 'increase') {
                // Tentar acessar dados do usuário para verificação de headroom
                const userTruePeak = comparison.userTruePeak || null;
                const userClipping = comparison.userClipping || 0;
                const isClipped = userClipping > 0;
                const headroomSafetyMargin = -0.6;
                
                if (isClipped) {
                    console.log(`[REF-HEADROOM] 🚨 Clipping detectado - bloqueando aumento de ${adjustmentDb.toFixed(1)}dB`);
                    suggestions.push({
                        type: 'reference_loudness_blocked_clipping',
                        message: 'Impossível igualar referência - áudio tem clipping',
                        action: 'Primeiro resolver clipping, depois ajustar para referência',
                        explanation: 'Clipping detectado impede aumento seguro',
                        frequency_range: 'N/A',
                        adjustment_db: 0,
                        direction: 'blocked',
                        warning: `Clipping detectado (${userClipping} samples)`
                    });
                } else if (Number.isFinite(userTruePeak)) {
                    const availableHeadroom = headroomSafetyMargin - userTruePeak;
                    
                    if (adjustmentDb <= availableHeadroom) {
                        const suggestion = {
                            type: 'reference_loudness',
                            message: 'Sua música está mais baixa que a referência',
                            action: `Aumentar volume em ${adjustmentDb.toFixed(1)}dB`,
                            explanation: 'Para match de loudness com a referência',
                            frequency_range: 'N/A',
                            adjustment_db: adjustmentDb,
                            direction: direction,
                            headroom_check: `Seguro: ${availableHeadroom.toFixed(1)}dB disponível`
                        };
                        suggestions.push(suggestion);
                    } else {
                        console.log(`[REF-HEADROOM] ⚠️ Ganho ${adjustmentDb.toFixed(1)}dB > headroom ${availableHeadroom.toFixed(1)}dB`);
                        suggestions.push({
                            type: 'reference_loudness_blocked_headroom',
                            message: 'Impossível igualar referência - sem headroom suficiente',
                            action: `True Peak permite apenas +${availableHeadroom.toFixed(1)}dB (necessário ${adjustmentDb.toFixed(1)}dB)`,
                            explanation: 'Aumentar mais causaria clipping (True Peak > -0.6 dBTP)',
                            frequency_range: 'N/A',
                            adjustment_db: availableHeadroom > 0 ? availableHeadroom : 0,
                            direction: 'limited',
                            warning: `Necessário ${adjustmentDb.toFixed(1)}dB mas só ${availableHeadroom.toFixed(1)}dB seguro`
                        });
                    }
                } else {
                    // Sem True Peak, modo conservador
                    suggestions.push({
                        type: 'reference_loudness_conservative',
                        message: 'Sua música está mais baixa que a referência (verificar clipping)',
                        action: `Aumentar CUIDADOSAMENTE volume em ${adjustmentDb.toFixed(1)}dB`,
                        explanation: 'Sem dados True Peak - risco de clipping',
                        frequency_range: 'N/A',
                        adjustment_db: adjustmentDb,
                        direction: direction,
                        warning: 'Verifique clipping após ajuste'
                    });
                }
            } else {
                // Diminuir é sempre seguro
                const suggestion = {
                    type: 'reference_loudness',
                    message: 'Sua música está mais alta que a referência',
                    action: `Diminuir volume em ${adjustmentDb.toFixed(1)}dB`,
                    explanation: 'Para match de loudness com a referência',
                    frequency_range: 'N/A',
                    adjustment_db: adjustmentDb,
                    direction: direction
                };
                suggestions.push(suggestion);
            }
            
            console.log('🔍 [DIAGNÓSTICO] Sugestão de loudness processada com headroom check');
        }
    }
    
    // Sugestões espectrais
    Object.entries(comparison.spectral).forEach(([band, data]) => {
        console.log(`🔍 [DIAGNÓSTICO] Spectral band ${band}:`, data);
        
        if (Math.abs(data.difference) > 2) {
            const freqRanges = {
                subBass: bandData.sub?.frequencyRange || '20-60 Hz',
                bass: bandData.bass?.frequencyRange || '60-150 Hz',
                lowMid: bandData.lowMid?.frequencyRange || '150-500 Hz',
                mid: bandData.mid?.frequencyRange || '500-2k Hz',
                upperMid: bandData.highMid?.frequencyRange || '2k-5k Hz',
                presence: bandData.presence?.frequencyRange || '5k-10k Hz',
                brilliance: bandData.air?.frequencyRange || '10k-20k Hz',
                air: bandData.air?.frequencyRange || '10k-20k Hz'
            };
            
            const suggestion = {
                type: 'reference_spectral',
                message: data.difference > 0 ? `Muito ${band} comparado à referência` : `Pouco ${band} comparado à referência`,
                action: data.difference > 0 ? `Cortar ${band}` : `Realçar ${band}`,
                explanation: `Para match espectral com a referência`,
                frequency_range: freqRanges[band] || 'N/A',
                adjustment_db: Math.abs(data.difference),
                direction: data.difference > 0 ? 'cut' : 'boost',
                q_factor: 1.0
            };
            
            console.log(`🔍 [DIAGNÓSTICO] Adicionando sugestão espectral para ${band}:`, suggestion);
            suggestions.push(suggestion);
        }
    });
    
    console.log('🔍 [DIAGNÓSTICO] Total sugestões geradas:', suggestions.length);
    console.log('🔍 [DIAGNÓSTICO] baseline_source: reference_audio (confirmed)');
    
    return suggestions;
}

// 🎯 NOVO: Adicionar seção de comparação com referência
function addReferenceComparisonSection(analysis) {
    const results = document.getElementById('audioAnalysisResults');
    if (!results) return;
    
    const comparison = analysis.comparison;
    const userFile = analysis.userFile || 'Sua música';
    const referenceFile = analysis.referenceFile || 'Música de referência';
    
    // Criar seção de comparação
    const comparisonSection = document.createElement('div');
    comparisonSection.className = 'reference-comparison-section';
    comparisonSection.innerHTML = `
        <div class="comparison-header">
            <h4>🎯 Comparação com Referência</h4>
            <div class="comparison-files">
                <span class="file-indicator user">📄 ${userFile}</span>
                <span class="vs-indicator">vs</span>
                <span class="file-indicator reference">🎯 ${referenceFile}</span>
            </div>
        </div>
        
        <div class="comparison-content">
            <div class="comparison-grid">
                ${generateComparisonRow('Loudness', comparison.loudness, 'LUFS')}
                ${generateComparisonRow('Faixa Dinâmica', comparison.dynamics, 'dB')}
                ${generateComparisonRow('Correlação Estéreo', comparison.stereo, '')}
            </div>
            
            ${comparison.spectral && Object.keys(comparison.spectral).length > 0 ? `
                <div class="spectral-comparison">
                    <h5>📊 Análise Espectral</h5>
                    <div class="spectral-grid">
                        ${Object.entries(comparison.spectral).map(([band, data]) => 
                            generateSpectralComparisonCard(band, data)
                        ).join('')}
                    </div>
                </div>
            ` : ''}
        </div>
    `;
    
    // Inserir no início da seção de resultados
    const resultsHeader = results.querySelector('.results-header');
    if (resultsHeader) {
        resultsHeader.insertAdjacentElement('afterend', comparisonSection);
    } else {
        results.insertBefore(comparisonSection, results.firstChild);
    }
    
    window.logReferenceEvent('comparison_section_displayed');
}

// 🎯 NOVO: Gerar linha de comparação
function generateComparisonRow(label, comparisonData, unit) {
    if (!comparisonData || comparisonData.difference === null) {
        return `
            <div class="comparison-row unavailable">
                <div class="comparison-label">${label}</div>
                <div class="comparison-values">
                    <span class="comparison-unavailable">Dados insuficientes</span>
                </div>
            </div>
        `;
    }
    
    const userValue = comparisonData.user?.toFixed?.(1) || comparisonData.user || '—';
    const refValue = comparisonData.reference?.toFixed?.(1) || comparisonData.reference || '—';
    const diff = comparisonData.difference?.toFixed?.(1) || '—';
    const diffClass = comparisonData.difference > 0 ? 'positive' : comparisonData.difference < 0 ? 'negative' : 'neutral';
    
    return `
        <div class="comparison-row">
            <div class="comparison-label">${label}</div>
            <div class="comparison-values">
                <div class="value-pair">
                    <span class="user-value">${userValue}${unit}</span>
                    <span class="ref-value">${refValue}${unit}</span>
                </div>
                <div class="difference-indicator ${diffClass}">
                    ${diff > 0 ? '+' : ''}${diff}${unit}
                </div>
            </div>
        </div>
    `;
}

// 🎯 NOVO: Gerar card de comparação espectral
function generateSpectralComparisonCard(band, data) {
    const bandNames = {
        subBass: 'Sub Bass',
        bass: 'Bass',
        lowMid: 'Low Mid',
        mid: 'Mid',
        upperMid: 'Upper Mid',
        presence: 'Presence',
        brilliance: 'Brilliance',
        air: 'Air'
    };
    
    const friendlyName = bandNames[band] || band;
    const diff = data.difference?.toFixed?.(1) || '—';
    const diffClass = data.difference > 2 ? 'high-positive' : 
                      data.difference > 0.5 ? 'positive' : 
                      data.difference < -2 ? 'high-negative' : 
                      data.difference < -0.5 ? 'negative' : 'neutral';
    
    return `
        <div class="spectral-card ${diffClass}">
            <div class="spectral-band-name">${friendlyName}</div>
            <div class="spectral-difference">${diff > 0 ? '+' : ''}${diff}dB</div>
        </div>
    `;
}

// ⏳ Aguardar Audio Analyzer carregar
function waitForAudioAnalyzer() {
    return new Promise((resolve) => {
        if (window.audioAnalyzer) {
            resolve();
            return;
        }
        
        const checkInterval = setInterval(() => {
            if (window.audioAnalyzer) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
        
        // Timeout após 10 segundos
        setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
        }, 10000);
    });
}

// � Atualizar progresso no modal
function updateModalProgress(percentage, message) {
    const progressFill = document.getElementById('audioProgressFill');
    const progressText = document.getElementById('audioProgressText');
    
    if (progressFill) {
        progressFill.style.width = percentage + '%';
    }
    
    if (progressText) {
        progressText.textContent = message || `${percentage}%`;
    }
    
    __dbg(`📈 Progresso: ${percentage}% - ${message}`);
}

// ❌ Mostrar erro no modal (usa ErrorMapper V3 com SCOPE e PLAN POLICY)
function showModalError(messageOrError, errorCode, meta = {}) {
    console.log('[showModalError] Recebido:', { messageOrError, errorCode, meta });
    
    // 🎯 V3: Extrair dados estruturados se disponíveis
    let structuredData = null;
    if (typeof messageOrError === 'object' && messageOrError !== null) {
        structuredData = messageOrError.structuredData || messageOrError;
    }
    
    // 🔥 [DEMO] Se é erro de limite de demo, mostrar modal de upgrade ao invés de erro
    const message = typeof messageOrError === 'string' ? messageOrError : (messageOrError?.message || '');
    const isDemoLimitError = message && (
        message.includes('Limite') ||
        message.includes('limite') ||
        message.includes('demonstrativa') ||
        message.includes('demo') ||
        message.includes('DEMO') ||
        message.includes('acesso completo') ||
        message.includes('Libere')
    );
    
    if (isDemoLimitError && window.SoundyDemo?.isActive && typeof window.SoundyDemo.showConversionModal === 'function') {
        console.log('🔥 [DEMO] Erro de limite detectado - mostrando modal de upgrade');
        window.SoundyDemo.showConversionModal('analysis_limit');
        return; // NÃO mostra modal de erro genérico
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    if (results) {
        results.style.display = 'block';
        
        // 🛡️ PRESERVAR #referenceComparisons antes de limpar
        const refContainer = document.getElementById('referenceComparisons');
        const refHTML = refContainer ? refContainer.outerHTML : '';
        
        // 🎯 V3: USAR ERROR MAPPER COM SCOPE E PLAN POLICY
        if (window.ErrorMapper && typeof window.ErrorMapper.mapBlockUi === 'function') {
            // Priorizar dados estruturados do backend
            const scope = structuredData?.scope || meta?.scope || 'analysis'; // Default: analysis para este arquivo
            const code = structuredData?.code || structuredData?.error || errorCode || meta?.errorCode;
            const feature = structuredData?.feature || meta?.feature;
            const plan = structuredData?.plan || meta?.plan || window.ErrorMapper.detectCurrentPlan();
            const backendMeta = structuredData?.meta || {};
            
            // Se não tem código explícito, tentar extrair do texto
            let detectedCode = code;
            if (!detectedCode && message) {
                const codePatterns = [
                    /SYSTEM_PEAK_USAGE/i,
                    /LIMIT_REACHED/i,
                    /ANALYSIS_LIMIT/i,
                    /CHAT_LIMIT/i,
                    /HARD_CAP/i,
                    /DEMO_LIMIT/i,
                    /PLAN_REQUIRED/i,
                    /FEATURE_NOT_AVAILABLE/i,
                    /FEATURE_LOCKED/i,
                    /AUTH_REQUIRED/i,
                    /TIMEOUT/i,
                    /RATE_LIMIT/i
                ];
                for (const pattern of codePatterns) {
                    const match = message.match(pattern);
                    if (match) {
                        detectedCode = match[0].toUpperCase().replace(/-/g, '_');
                        break;
                    }
                }
            }
            
            // Se ainda não tem código mas tem mensagem de limite, deduzir
            if (!detectedCode && message) {
                if (message.includes('limite') || message.includes('Limite')) {
                    detectedCode = 'LIMIT_REACHED';
                } else if (message.includes('alta demanda') || message.includes('ocupados')) {
                    detectedCode = 'SYSTEM_PEAK_USAGE';
                }
            }
            
            console.log('[showModalError] Chamando mapBlockUi com scope:', scope, 'code:', detectedCode, 'plan:', plan);
            
            const errorUi = window.ErrorMapper.mapBlockUi({
                scope: scope,
                code: detectedCode || 'SERVICE_ERROR',
                feature: feature,
                plan: plan,
                meta: {
                    ...meta,
                    ...backendMeta,
                    cap: backendMeta.cap || meta?.cap || meta?.limit,
                    used: backendMeta.used || meta?.used || meta?.current,
                    resetDate: backendMeta.resetDate || meta?.resetDate || meta?.nextReset
                }
            });
            
            // 🎯 V3: VERIFICAR POLÍTICA DE DOWNGRADE PARA ANÁLISE
            const policy = errorUi._policy || window.ErrorMapper.getPlanPolicy(plan);
            const isLimitError = ['LIMIT_REACHED', 'HARD_CAP_REACHED', 'ANALYSIS_LIMIT_REACHED'].includes(detectedCode?.toUpperCase());
            
            if (scope === 'analysis' && isLimitError) {
                console.log('[showModalError] 🎯 Verificando política de overflow para análise:', policy);
                
                if (policy.overflowAnalysis === 'downgrade_to_reduced') {
                    // FREE/PLUS/PRO: Mostrar modal mas permitir continuar em reduced
                    console.log('[showModalError] 📉 Policy: downgrade_to_reduced - Permitindo modo reduced após modal');
                    
                    // Configurar callback especial que abre upload em modo reduced
                    window.ErrorMapper.setRetryCallback(() => {
                        console.log('[showModalError] 🔄 Retry callback: Entrando em modo reduced');
                        window.__forceReducedMode = true; // Flag para o próximo upload
                        resetModalState();
                    });
                    
                    // Adicionar info de reduced no modal
                    if (policy.exposeLimits) {
                        const originalMessage = errorUi.message;
                        errorUi.message = originalMessage + '\n\nVocê ainda pode fazer análises no modo básico (Score, LUFS, True Peak).';
                        errorUi.secondaryCta = { label: '📊 Continuar Modo Básico', action: 'retry' };
                    }
                } else if (policy.overflowAnalysis === 'system_peak_modal') {
                    // STUDIO: Apenas modal de alta demanda, sem downgrade
                    console.log('[showModalError] ⏳ Policy: system_peak_modal - Apenas retry, sem downgrade');
                    window.ErrorMapper.setRetryCallback(resetModalState);
                }
            } else {
                // Callback padrão
                window.ErrorMapper.setRetryCallback(resetModalState);
            }
            
            // Renderizar usando ErrorMapper
            window.ErrorMapper.renderErrorModal(errorUi, results);
            console.log('[showModalError] ✅ Erro renderizado com ErrorMapper V3:', errorUi.title, errorUi._debug);
        } else if (window.ErrorMapper && typeof window.ErrorMapper.mapErrorToUi === 'function') {
            // 🔄 FALLBACK V1: mapErrorToUi (compatibilidade)
            console.warn('[showModalError] Usando mapErrorToUi (V1 fallback)');
            const errorUi = window.ErrorMapper.mapErrorToUi({
                code: errorCode || 'UNKNOWN',
                plan: meta?.plan || window.ErrorMapper.detectCurrentPlan(),
                feature: meta?.feature || 'analysis',
                meta: meta
            });
            window.ErrorMapper.setRetryCallback(resetModalState);
            window.ErrorMapper.renderErrorModal(errorUi, results);
        } else {
            // 🔴 FALLBACK: renderização antiga se ErrorMapper não disponível
            console.warn('[showModalError] ErrorMapper não disponível, usando fallback');
            results.innerHTML = `
                <div style="color: #ff4444; text-align: center; padding: 30px;">
                    <div style="font-size: 3em; margin-bottom: 15px;">⚠️</div>
                    <h3 style="margin: 0 0 15px 0; color: #ff4444;">Erro na Análise</h3>
                    <p style="margin: 0 0 25px 0; color: #666; line-height: 1.4;">${message}</p>
                    <button onclick="resetModalState()" style="
                        background: #ff4444; 
                        color: white; 
                        border: none; 
                        padding: 12px 25px; 
                        border-radius: 6px; 
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                        transition: background 0.3s;
                    " onmouseover="this.style.background='#ff3333'" 
                       onmouseout="this.style.background='#ff4444'">
                        Tentar Novamente
                    </button>
                </div>
            `;
        }
        
        // 🛡️ RESTAURAR #referenceComparisons após limpar
        if (refHTML) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = refHTML;
            results.appendChild(tempDiv.firstElementChild);
            console.log('[ERROR-HANDLER] ✅ #referenceComparisons preservado durante erro');
        }
    }
}

// �🔄 Mostrar loading no modal
function showModalLoading() {
    __dbg('🔄 Exibindo tela de loading no modal...');
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    // 🔧 CORREÇÃO: Garantir que o loading seja exibido corretamente
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('✅ Upload area ocultada');
    }
    if (results) {
        results.style.display = 'none';
        __dbg('✅ Results area ocultada');
    }
    if (loading) {
        loading.style.display = 'block';
        __dbg('✅ Loading area exibida');
    } else {
        __dbg('❌ Elemento audioAnalysisLoading não encontrado!');
    }
    
    // Reset progress
    updateModalProgress(0, '🔄 Inicializando Engine de Análise...');
    __dbg('✅ Progresso resetado e loading configurado');
}

// 📈 Simular progresso
// (função de simulação de progresso removida — não utilizada)

// ✅ FUNÇÃO DE MODO REDUZIDO
/**
 * Renderizar interface em modo reduzido (FREE/PLUS sem análises restantes)
 * Mostra apenas: Score, True Peak, LUFS, Dynamic Range
 * Oculta: Bandas, Espectro, Sugestões, IA Avançada
 */
// ========================================
// 🎯 SISTEMA DE MASCARAMENTO DINÂMICO PARA MODO REDUZIDO
// ========================================

/**
 * 🔍 Escaneia o DOM e constrói mapeamento de métricas por data-attribute
 * Aplica regras específicas por seção conforme especificação Reduced Mode
 * @param {Object} analysis - Dados da análise com JSON completo
 * @returns {Object} { allowedNodes: [], blockedNodes: [] }
 */
function buildMetricDomMap(analysis) {
    console.log('[DOM-SCAN] 🔍 Iniciando escaneamento do DOM...');
    
    // 🎯 REGRAS POR SEÇÃO - Métricas PERMITIDAS no modo reduced
    // ✅ LIBERADAS: DR, Estéreo, Low Mid, High Mid, Presença
    // 🔒 BLOQUEADAS: LUFS, True Peak, LRA, Sub, Bass, Mid, Brilho, Avançadas
    const allowedPrimaryMetrics = [
        'dr',
        'dynamicRange',
        'scoreFinal'
    ];
    
    // (B) FREQUÊNCIAS: Low Mid, High Mid, Presença LIBERADAS
    const allowedFrequencyMetrics = [
        'band_lowMid',
        'band_low_mid',
        'lowMid',
        'low_mid',
        'band_highMid',
        'band_high_mid',
        'highMid',
        'high_mid',
        'band_presence',
        'presence'
    ];
    
    // (C) MÉTRICAS AVANÇADAS: Nenhuma (tudo borrado)
    const allowedAdvancedMetrics = [];
    
    // Lista completa para scan geral
    const allowedMetrics = [
        ...allowedPrimaryMetrics,
        ...allowedFrequencyMetrics
    ];
    
    const allowedNodes = [];
    const blockedNodes = [];
    
    // Buscar por todos os elementos com data-metric-key
    const modalContainer = document.getElementById('audioAnalysisResults');
    if (!modalContainer) {
        console.warn('[DOM-SCAN] ⚠️ Container de resultados não encontrado');
        return { allowedNodes, blockedNodes };
    }
    
    // Selecionar TODOS os elementos com data-metric-key
    const metricNodes = modalContainer.querySelectorAll('[data-metric-key]');
    
    metricNodes.forEach(el => {
        const key = el.getAttribute('data-metric-key');
        
        if (allowedMetrics.includes(key)) {
            allowedNodes.push({ key, el });
            console.log('[DOM-SCAN] ✅ Métrica permitida encontrada:', key, '=', el.textContent.trim());
        } else {
            blockedNodes.push({ key, el });
            console.log('[DOM-SCAN] 🚫 Métrica BLOQUEADA encontrada:', key, '=', el.textContent.trim());
        }
    });
    
    console.log('[DOM-SCAN] ✅ Escaneamento completo:', {
        allowed: allowedNodes.length,
        blocked: blockedNodes.length
    });
    
    return { allowedNodes, blockedNodes };
}

/**
 * 🔒 Aplica máscaras visuais nas métricas restritas
 * ATENÇÃO: Aplica blur SOMENTE nos valores numéricos, NUNCA nos labels
 * @param {Object} scanResult - { allowedNodes, blockedNodes }
 */
function applyReducedModeMasks(scanResult) {
    console.log('[MASK] 🎨 Aplicando máscaras visuais (valores apenas, labels preservados)...');
    
    const { allowedNodes, blockedNodes } = scanResult;
    let maskedCount = 0;
    
    // Log de métricas permitidas
    allowedNodes.forEach(({ key }) => {
        console.log(`[ALLOWED] ✅ Métrica permitida: ${key}`);
    });
    
    // Aplicar blur SOMENTE nos valores numéricos usando .metric-blur
    blockedNodes.forEach(({ key, el }) => {
        // Buscar spans/divs que contém valores (números, dB, LUFS, Hz, %, etc)
        const valueSelectors = [
            '.value',
            '.metric-value',
            'span[class*="value"]',
            'div[class*="value"]'
        ];
        
        let valueFound = false;
        
        for (const selector of valueSelectors) {
            const valueSpan = el.querySelector(selector);
            if (valueSpan && !valueSpan.classList.contains('metric-blur')) {
                // Aplicar classe de blur SOMENTE no valor
                valueSpan.classList.add('metric-blur');
                maskedCount++;
                valueFound = true;
                console.log(`[MASK] 🔒 Blur aplicado no VALOR de: ${key} (selector: ${selector})`);
                break;
            }
        }
        
        // Se não encontrar seletores específicos, buscar elemento com texto numérico
        if (!valueFound) {
            const textContent = el.textContent.trim();
            // Verificar se contém números
            if (/\d+/.test(textContent)) {
                // Aplicar blur no elemento inteiro apenas se contiver números
                if (!el.classList.contains('metric-blur')) {
                    el.classList.add('metric-blur');
                    maskedCount++;
                    console.log(`[MASK] ⚠️ Blur aplicado no elemento completo (contém números): ${key}`);
                }
            } else {
                console.log(`[MASK] ⏭️ Ignorado (sem valores numéricos): ${key}`);
            }
        }
    });
    
    console.log(`[MASK] ✅ Total de ${maskedCount} métricas mascaradas`);
}

/**
 * 🚫 Oculta seções completas baseado em classes e padrões
 */
function hideRestrictedSections() {
    console.log('[HIDE] 🚫 Ocultando seções restritas...');
    
    // Seções que devem ser COMPLETAMENTE OCULTAS
    const sectionsToHide = [
        // Seções de diagnóstico
        { selector: '[id*="diagnostic"]', name: 'Elementos de Diagnóstico' },
        { selector: '.diagnostics-section', name: 'Seção de Diagnósticos' },
        
        // Análise espectral avançada
        { selector: '[id*="spectral"]', name: 'Elementos Espectrais' },
        { selector: '.spectral-section', name: 'Seção Espectral' },
        { selector: '.advanced-spectrum-section', name: 'Espectro Avançado' },
        
        // Problemas e análises avançadas
        { selector: '[id*="problem"]', name: 'Elementos de Problemas' },
        { selector: '.problems-section', name: 'Seção de Problemas' }
    ];
    
    let hiddenCount = 0;
    
    sectionsToHide.forEach(({ selector, name }) => {
        const elements = document.querySelectorAll(selector);
        if (elements.length > 0) {
            elements.forEach(el => {
                if (el && !el.classList.contains('plan-section-hidden')) {
                    el.classList.add('plan-section-hidden');
                    hiddenCount++;
                    console.log(`[HIDE] 🚫 Ocultado: ${name} (${selector})`);
                }
            });
        }
    });
    
    console.log(`[HIDE] ✅ Total de ${hiddenCount} elementos ocultados`);
}

/**
 * 🔒 Filtragem de sugestões já aplicada no ai-suggestion-ui-controller.js
 * Esta função foi removida pois a filtragem é feita no momento da renderização
 */
function blurAISuggestionTexts() {
    console.log('[BLUR-AI] 🔒 Aplicando blur em textos internos dos cards de IA...');
    
    // Selecionar todos os cards de sugestão IA
    const aiCards = document.querySelectorAll('.ai-suggestion-card');
    
    if (aiCards.length === 0) {
        console.log('[BLUR-AI] ⏭️ Nenhum card de IA encontrado');
        return;
    }
    
    // Aplicar blur APENAS nos textos internos, mantendo estrutura e títulos visíveis
    aiCards.forEach((card, index) => {
        // Borrar conteúdos de texto dentro dos blocos, não os títulos
        const contentBlocks = card.querySelectorAll('.ai-block-content');
        
        contentBlocks.forEach(block => {
            if (!block.classList.contains('metric-blur')) {
                block.classList.add('metric-blur');
            }
        });
        
        console.log(`[BLUR-AI] ✅ Card ${index + 1}: ${contentBlocks.length} textos borrados`);
    });
    
    console.log(`[BLUR-AI] ✅ Total de ${aiCards.length} cards processados`);
}

/**
 * 🎯 Aplica blur na tabela de comparação (valores atual e alvo)
 * REGRA (D): Permitir APENAS LRA, DR, Estéreo (BLOQUEAR frequências)
 * Blur: valores e targets de métricas bloqueadas, labels ficam visíveis
 */
function blurComparisonTableValues() {
    console.log('[BLUR-TABLE] 🎨 Aplicando blur na tabela de comparação...');
    
    // (D) TABELA COMPARAÇÃO: DR, Estéreo, Low Mid, High Mid, Presença permitidos
    // 🔒 BLOQUEADAS: LUFS, True Peak, LRA, Sub, Bass, Mid, Brilho/Air
    const allowedTableMetrics = [
        'dr',
        'dynamicRange',
        'dynamic_range',
        'dinâmica',
        'stereo',
        'stereoCorrelation',
        'correlation',
        'estéreo',
        'imagem estéreo',
        'lowmid',
        'low mid',
        'low_mid',
        'highmid',
        'high mid',
        'high_mid',
        'presence',
        'presença',
        'presenca'
    ];
    
    let blurredCount = 0;
    
    // Buscar todas as linhas da tabela de comparação
    const comparisonTables = document.querySelectorAll('#referenceComparisons table, .genre-comparison-table, .comparison-table');
    
    comparisonTables.forEach(table => {
        const rows = table.querySelectorAll('tr');
        
        rows.forEach(row => {
            // Pegar o nome da métrica da primeira célula (label)
            const firstCell = row.querySelector('td:first-child, th:first-child');
            if (!firstCell) return;
            
            const metricText = firstCell.textContent.toLowerCase().trim();
            const metricKey = row.getAttribute('data-metric-key');
            
            // Verificar se a métrica está na lista de permitidas
            const isAllowed = allowedTableMetrics.some(allowed => 
                metricText.includes(allowed.toLowerCase()) ||
                (metricKey && metricKey.toLowerCase().includes(allowed.toLowerCase()))
            );
            
            if (!isAllowed) {
                // Borrar valor atual e valor alvo SOMENTE (não severidade, ícones ou labels)
                const valueCells = row.querySelectorAll('.current-value, .target-value, td:nth-child(2), td:nth-child(3)');
                
                valueCells.forEach(cell => {
                    // Não borrar se for coluna de severidade ou ação
                    const cellText = cell.textContent.toLowerCase();
                    const isSeverityOrAction = cellText.includes('crítico') || 
                                              cellText.includes('atenção') || 
                                              cellText.includes('ok') ||
                                              cell.querySelector('.severity-badge') !== null ||
                                              cell.querySelector('[class*="icon"]') !== null;
                    
                    if (!isSeverityOrAction && !cell.classList.contains('metric-blur')) {
                        cell.classList.add('metric-blur');
                        blurredCount++;
                        console.log(`[BLUR-TABLE] 🔒 Valor borrado: ${metricText}`);
                    }
                });
            } else {
                console.log(`[BLUR-TABLE] ✅ Métrica permitida na tabela: ${metricText}`);
            }
        });
    });
    
    console.log(`[BLUR-TABLE] ✅ Total de ${blurredCount} valores na tabela borrados`);
}

/**
 * 📢 Insere mensagem de upgrade no modal (compacta e dentro do container)
 */
function insertUpgradeNotice() {
    console.log('[UPGRADE] 📢 Inserindo aviso de upgrade...');
    
    const modalContainer = document.getElementById('audioAnalysisResults');
    if (!modalContainer) {
        console.warn('[UPGRADE] ⚠️ Container de resultados não encontrado');
        return;
    }
    
    // Remover aviso anterior se existir
    const existingNotice = document.getElementById('reduced-mode-upgrade-notice');
    if (existingNotice) {
        existingNotice.remove();
    }
    
    // Criar novo aviso COMPACTO
    const notice = document.createElement('div');
    notice.id = 'reduced-mode-upgrade-notice';
    notice.className = 'upgrade-notice-compact';
    notice.innerHTML = `
        <div class="upgrade-notice-icon">🔒</div>
        <div class="upgrade-notice-content">
            <h4>Análises completas esgotadas</h4>
            <p>
                Métricas avançadas, sugestões IA e diagnósticos disponíveis no plano Plus.
            </p>
        </div>
        <button class="upgrade-notice-btn" onclick="window.location.href='/planos.html'">
            Ver planos
        </button>
    `;
    
    // Inserir no topo do container (DENTRO do modal, não fora)
    modalContainer.insertBefore(notice, modalContainer.firstChild);
    
    console.log('[UPGRADE] ✅ Aviso de upgrade inserido');
}

/**
 * 🎨 Injeta CSS dinâmico para máscaras
 */
function injectReducedModeCSS() {
    // Verificar se CSS já foi injetado
    if (document.getElementById('reduced-mode-dynamic-css')) {
        return;
    }
    
    const style = document.createElement('style');
    style.id = 'reduced-mode-dynamic-css';
    style.textContent = `
        /* 🔒 Máscara visual SOMENTE para valores numéricos - NUNCA para labels */
        .metric-blur {
            position: relative !important;
            filter: blur(7px) !important;
            opacity: 0.4 !important;
            pointer-events: none !important;
            user-select: none !important;
            user-select: none !important;
            display: inline-block !important;
        }
        
        /* Garantir que labels NUNCA sejam borrados */
        .metric-label,
        [class*="label"],
        [class*="name"],
        .metric-name {
            filter: none !important;
            opacity: 1 !important;
        }
        
        .metric-blur::after {
            content: "🔒" !important;
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            font-size: 11px !important;
            opacity: 0.8 !important;
            z-index: 10 !important;
        }
        
        /* Seções completamente ocultas */
        .plan-section-hidden {
            display: none !important;
        }
        
        /* 📢 Aviso de upgrade ELEGANTE E COMPACTO */
        .upgrade-notice-compact {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            margin: 0 0 12px 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.12);
            animation: slideDown 0.3s ease-out;
            font-size: 0.9em;
        }
        
        .upgrade-notice-compact .upgrade-notice-icon {
            font-size: 1.5em;
            line-height: 1;
            flex-shrink: 0;
        }
        
        .upgrade-notice-compact .upgrade-notice-content {
            flex: 1;
        }
        
        .upgrade-notice-compact .upgrade-notice-content h4 {
            margin: 0 0 3px 0;
            font-size: 0.95em;
            font-weight: 700;
        }
        
        .upgrade-notice-compact .upgrade-notice-content p {
            margin: 0;
            font-size: 0.75em;
            line-height: 1.3;
            opacity: 0.9;
        }
        
        .upgrade-notice-compact .upgrade-notice-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 8px 16px;
            border-radius: 7px;
            font-size: 0.8em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            white-space: nowrap;
        }
        
        .upgrade-notice-compact .upgrade-notice-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .upgrade-notice-compact {
                flex-direction: column;
                text-align: center;
                padding: 12px 14px;
            }
            
            .upgrade-notice-compact .upgrade-notice-icon {
                font-size: 1.4em;
            }
            
            .upgrade-notice-compact .upgrade-notice-btn {
                width: 100%;
                padding: 10px 14px;
            }
        }
    `;
    
    document.head.appendChild(style);
    console.log('[CSS] ✅ CSS dinâmico injetado');
}

/**
 * 🎯 FUNÇÃO PRINCIPAL: Renderiza modal em Modo Reduzido
 * @param {Object} analysis - Dados completos da análise
 */
function renderReducedModeAdvanced(analysis) {
    console.log('[REDUCED-MODE] 🎯 Iniciando renderização avançada do Modo Reduzido');
    console.log('[REDUCED-MODE] 📊 Análise recebida:', {
        hasData: !!analysis,
        keys: Object.keys(analysis || {}),
        analysisMode: analysis?.analysisMode,
        plan: analysis?.plan
    });
    
    try {
        // Injetar CSS uma única vez
        injectReducedModeCSS();
        
        // Aguardar DOM estar pronto
        console.log('[REDUCED-MODE] ⏱️ Aguardando renderização do DOM...');
        
        setTimeout(() => {
            try {
                // 1️⃣ Escanear DOM e construir mapeamento
                const scanResult = buildMetricDomMap(analysis);
                
                // 2️⃣ Aplicar máscaras nas métricas bloqueadas (SOMENTE nos valores)
                applyReducedModeMasks(scanResult);
                
                // 3️⃣ Aplicar blur nos textos das sugestões IA (mantém cards visíveis)
                blurAISuggestionTexts();
                
                // 4️⃣ Aplicar blur na tabela de comparação (exceto métricas permitidas)
                blurComparisonTableValues();
                
                // 5️⃣ Ocultar seções restritas (NÃO inclui sugestões)
                hideRestrictedSections();
                
                // 6️⃣ Inserir aviso de upgrade
                insertUpgradeNotice();
                
                console.log('[REDUCED-MODE] ✅ Modo Reduzido renderizado com sucesso');
                console.log('[REDUCED-MODE] 📊 Resumo:', {
                    metricsAllowed: scanResult.allowedNodes.length,
                    metricsBlocked: scanResult.blockedNodes.length
                });
                
            } catch (innerError) {
                console.error('[REDUCED-MODE][ERROR] Erro no processo de mascaramento:', innerError);
                console.error('[REDUCED-MODE][ERROR] Stack:', innerError.stack);
            }
        }, 500); // Timeout para garantir que o DOM foi completamente renderizado
        
    } catch (error) {
        console.error('[REDUCED-MODE][ERROR] Erro ao inicializar modo reduzido:', error);
        console.error('[REDUCED-MODE][ERROR] Stack:', error.stack);
        
        // Em caso de erro, modal continua funcionando normalmente
        console.warn('[REDUCED-MODE] ⚠️ Fallback: Modal renderizado sem mascaramento');
    }
}

// ========================================
// FIM DO SISTEMA DE MASCARAMENTO DINÂMICO
// ========================================

// ✅ HELPER: Mascarar valor baseado em permissão do plano
function maskValue(value, isAllowed, options = {}) {
    const { placeholder = '—', unit = '', decimalPlaces = null } = options;
    
    // Se não permitido, retornar placeholder
    if (!isAllowed) {
        return placeholder;
    }
    
    // Se valor não existe, retornar placeholder
    if (value === undefined || value === null) {
        return placeholder;
    }
    
    // Formatar valor se permitido
    if (decimalPlaces !== null && typeof value === 'number') {
        return `${value.toFixed(decimalPlaces)}${unit ? ' ' + unit : ''}`;
    }
    
    return `${value}${unit ? ' ' + unit : ''}`;
}

// ✅ HELPER SIMPLIFICADO: Aplicar classe de máscara visual (apenas CSS)
function applyMaskClass(selector, isAllowed) {
    const element = document.querySelector(selector);
    if (!element) {
        console.warn(`[MASK] Elemento não encontrado: ${selector}`);
        return;
    }
    
    if (!isAllowed) {
        // Adicionar classe de máscara (blur + "Plano limitado" via CSS::after)
        element.classList.add('metric-masked');
    } else {
        // Remover máscara se estava aplicada
        element.classList.remove('metric-masked');
    }
}

// ✅ HELPER: Ocultar/mostrar seção completamente
function toggleSectionVisibility(selector, isAllowed) {
    const element = document.querySelector(selector);
    if (!element) {
        console.warn(`[TOGGLE] Elemento não encontrado: ${selector}`);
        return;
    }
    
    if (!isAllowed) {
        element.classList.add('plan-section-hidden');
    } else {
        element.classList.remove('plan-section-hidden');
    }
}

function renderReducedMode(data) {
    console.log('[PLAN-FILTER] 🎯 Renderizando modo reduzido COM JSON COMPLETO:', data);
    console.log('[PLAN-FILTER] 📊 Campos recebidos:', Object.keys(data));
    
    // ✅ Obter features do plano (se disponíveis no JSON)
    const planFeatures = data.planFeatures || {
        canSuggestions: false,
        canSpectralAdvanced: false,
        canAiHelp: false,
        canPdf: false
    };
    
    console.log('[PLAN-FILTER] 🔐 Features do plano:', planFeatures);
    
    // Abrir modal de resultado
    const modal = document.getElementById('audioResultModal');
    const overlay = document.getElementById('audioModalOverlay');
    
    if (modal) {
        modal.style.display = 'block';
        modal.classList.add('show');
    }
    if (overlay) {
        overlay.style.display = 'block';
    }
    
    // Helper para atualizar campo de forma segura
    function updateField(selector, value) {
        const element = document.querySelector(selector);
        if (element) {
            element.textContent = value || '—';
        }
    }
    
    // ✅ EXIBIR MÉTRICAS PRINCIPAIS (SEMPRE VISÍVEIS) - TP, LUFS, DR, Score
    updateField('#audioScore', maskValue(data.score, true, { unit: '%' }));
    updateField('#audioLufs', maskValue(data.lufsIntegrated || data.lufs, true, { unit: 'LUFS', decimalPlaces: 1 }));
    updateField('#audioTruePeak', maskValue(data.truePeakDbtp || data.truePeak, true, { unit: 'dBTP', decimalPlaces: 2 }));
    updateField('#audioDynamicRange', maskValue(data.dynamicRange || data.dr, true, { unit: 'dB', decimalPlaces: 1 }));
    
    console.log('[PLAN-FILTER] ✅ Métricas principais renderizadas (sempre visíveis)');
    
    // ✅ APLICAR MÁSCARAS NAS MÉTRICAS AVANÇADAS (JSON completo preservado)
    const advancedMetrics = [
        { selector: '#audioHeadroom', value: data.headroom, unit: 'dB', decimals: 1 },
        { selector: '#audioLra', value: data.lra, unit: 'dB', decimals: 1 },
        { selector: '#audioStereoWidth', value: data.stereoWidth, unit: '', decimals: 2 },
        { selector: '#audioStereoCorrelation', value: data.stereoCorrelation, unit: '', decimals: 2 },
        { selector: '#audioPhaseCoherence', value: data.phaseCoherence, unit: '%', decimals: 0 },
        { selector: '#audioPeakToAverage', value: data.peakToAverage, unit: 'dB', decimals: 1 },
        { selector: '#audioCrestFactor', value: data.crestFactor, unit: 'dB', decimals: 1 }
    ];
    
    advancedMetrics.forEach(metric => {
        // Exibir valor REAL (não placeholder) - máscara visual é aplicada via CSS
        const formattedValue = maskValue(metric.value, true, { 
            unit: metric.unit, 
            decimalPlaces: metric.decimals 
        });
        updateField(metric.selector, formattedValue);
        applyMaskClass(metric.selector, false); // Aplicar blur + overlay via CSS
    });
    
    console.log('[PLAN-FILTER] ✅ Métricas avançadas MASCARADAS (dados completos preservados)');
    
    // ✅ BANDAS ESPECTRAIS - Mascarar visualmente
    const spectralBands = [
        { selector: '#audioSubBass', key: 'sub_bass' },
        { selector: '#audioBass', key: 'bass' },
        { selector: '#audioLowMid', key: 'low_mid' },
        { selector: '#audioMid', key: 'mid' },
        { selector: '#audioHighMid', key: 'high_mid' },
        { selector: '#audioPresence', key: 'presence' },
        { selector: '#audioBrilliance', key: 'brilliance' },
        { selector: '#audioAir', key: 'air' }
    ];
    
    spectralBands.forEach(band => {
        const value = data.bands?.[band.key]?.db || data.spectralData?.[band.key]?.db;
        const formattedValue = maskValue(value, true, { 
            unit: 'dB', 
            decimalPlaces: 1 
        });
        updateField(band.selector, formattedValue);
        applyMaskClass(band.selector, planFeatures.canSpectralAdvanced);
    });
    
    console.log('[PLAN-FILTER] ✅ Bandas espectrais MASCARADAS');
    
    // ✅ OCULTAR SEÇÕES DE SUGESTÕES/IA (se features não permitem)
    const sectionsToHide = [
        { selector: '#suggestionsSection', allowed: planFeatures.canSuggestions },
        { selector: '#aiSuggestionsSection', allowed: planFeatures.canSuggestions },
        { selector: '#problemsSection', allowed: planFeatures.canSuggestions },
        { selector: '#diagnosticsSection', allowed: planFeatures.canSuggestions },
        { selector: '.ai-suggestion-card', allowed: planFeatures.canSuggestions },
        { selector: '.advanced-spectrum-section', allowed: planFeatures.canSpectralAdvanced }
    ];
    
    sectionsToHide.forEach(({ selector, allowed }) => {
        toggleSectionVisibility(selector, allowed);
    });
    
    console.log('[PLAN-FILTER] ✅ Seções de sugestões/IA ocultadas conforme plano');
    
    // ✅ EXIBIR AVISO DE UPGRADE ATRAENTE
    const warningContainer = document.createElement('div');
    warningContainer.id = 'reducedModeWarning';
    warningContainer.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 24px;
        margin: 20px 0;
        border-radius: 16px;
        text-align: center;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.1);
    `;
    warningContainer.innerHTML = `
        <div style="font-size: 3em; margin-bottom: 10px;">🔒</div>
        <h3 style="margin: 0 0 12px 0; font-size: 1.4em; font-weight: 700;">Modo Reduzido Ativo</h3>
        <p style="margin: 12px 0; font-size: 1em; opacity: 0.95; line-height: 1.5;">
            ${data.limitWarning || 'Você atingiu o limite de análises completas do seu plano atual.'}
        </p>
        <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; margin: 15px 0;">
            <p style="margin: 0; font-size: 0.9em; opacity: 0.9;">
                <strong>✅ Métricas visíveis:</strong> Score, True Peak, LUFS, Dynamic Range
            </p>
            <p style="margin: 8px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                <strong>🔒 Bloqueadas:</strong> Métricas avançadas, espectro, sugestões IA
            </p>
        </div>
        <button id="upgradePlanBtn" style="
            background: white;
            color: #667eea;
            border: none;
            padding: 14px 36px;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 700;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
            🚀 Desbloquear Análise Completa
        </button>
    `;
    
    // Inserir aviso no início do modal
    const modalContent = document.querySelector('#audioResultModal .modal-content');
    if (modalContent) {
        // Remover aviso anterior se existir
        const oldWarning = document.getElementById('reducedModeWarning');
        if (oldWarning) {
            oldWarning.remove();
        }
        
        modalContent.insertBefore(warningContainer, modalContent.firstChild);
        console.log('[PLAN-FILTER] ✅ Aviso de upgrade exibido');
        
        // Adicionar evento de clique no botão de upgrade
        const upgradeBtn = document.getElementById('upgradePlanBtn');
        if (upgradeBtn) {
            upgradeBtn.addEventListener('click', () => {
                console.log('[PLAN-FILTER] 🚀 Botão de upgrade clicado');
                window.location.href = '/planos.html';
            });
        }
    }
    
    console.log('[PLAN-FILTER] ✅ Modo reduzido renderizado com JSON COMPLETO e máscaras visuais');
}

// 📊 Mostrar resultados no modal
async function displayModalResults(analysis) {
    console.log('[DEBUG-DISPLAY] 🧠 Início displayModalResults()');
    
    // 🕐 HISTÓRICO PRO: Ponto único de salvamento para análises de GÊNERO
    // (Análises de referência usam displayReferenceComparison)
    if (analysis && !analysis._fromHistory && analysis.technicalData) {
        const analysisMode = analysis.mode || analysis.analysisMode || 'genre';
        
        if (analysisMode === 'genre') {
            console.log('🕐 [HISTORY-SAVE] displayModalResults detectou análise de gênero');
            
            // Salvar assíncrono (não bloqueia UI)
            saveAnalysisToHistory(analysis).catch(err => {
                console.warn('🕐 [HISTORY-SAVE] Erro ao salvar (não crítico):', err);
            });
        }
    }
    
    // ✅ VERIFICAÇÃO PRIORITÁRIA: Modo Reduzido (backend envia JSON completo, frontend aplica máscara)
    const isReduced = analysis.analysisMode === 'reduced' || analysis.isReduced === true;
    
    if (isReduced) {
        console.log('[PLAN-FILTER] ⚠️ MODO REDUZIDO DETECTADO - JSON completo recebido');
        console.log('[PLAN-FILTER] 📊 Campos do JSON:', Object.keys(analysis));
        console.log('[PLAN-FILTER] 🎯 Usando sistema avançado de mascaramento dinâmico...');
        
        // ✅ NÃO parar aqui! Continuar renderização normal
        // O sistema de mascaramento será aplicado APÓS o DOM ser renderizado
        
        // Armazenar flag global para aplicação posterior
        window.__REDUCED_MODE_ACTIVE__ = true;
        window.__REDUCED_MODE_ANALYSIS__ = analysis;
    } else {
        window.__REDUCED_MODE_ACTIVE__ = false;
        window.__REDUCED_MODE_ANALYSIS__ = null;
    }
    
    console.log('[PLAN-FILTER] ℹ️ Continuando renderização normal do modal...');
    
    // 🔥 FASE 2 - VALIDAÇÃO IMEDIATA: Verificar se genreTargets chegou até aqui
    console.group('[FASE2-VALIDATION] 🎯 displayModalResults - ENTRADA');
    console.log('analysis.data.genreTargets:', analysis.data?.genreTargets ? '✅ PRESENTE' : '❌ AUSENTE');
    if (analysis.data?.genreTargets) {
        console.log('  → Keys:', Object.keys(analysis.data.genreTargets));
        console.log('  → Has bands:', !!analysis.data.genreTargets.bands);
        if (analysis.data.genreTargets.bands) {
            console.log('  → Band keys:', Object.keys(analysis.data.genreTargets.bands));
        }
    }
    console.groupEnd();
    
    // 🔥 VALIDAÇÃO FINAL OBRIGATÓRIA: Verificar dados essenciais ANTES de exibir modal
    console.log("\n\n🔥🔥🔥 [AUDIT-FINAL-FRONT] VALIDAÇÃO COMPLETA 🔥🔥🔥");
    console.log("[AUDIT-FINAL-FRONT]", {
        hasTechnicalData: !!analysis.technicalData,
        techKeys: Object.keys(analysis.technicalData || {}),
        techKeyCount: Object.keys(analysis.technicalData || {}).length,
        hasGenreTargets: !!analysis.data?.genreTargets,
        gtKeys: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets) : null,
        gtKeyCount: analysis.data?.genreTargets ? Object.keys(analysis.data.genreTargets).length : 0,
        hasScore: analysis.score !== undefined && analysis.score !== null,
        scoreValue: analysis.score,
        hasMetadata: !!analysis.metadata,
        metadataKeys: analysis.metadata ? Object.keys(analysis.metadata).length : 0,
        // Campos essenciais de technicalData
        essentialFields: {
            lufsIntegrated: analysis.technicalData?.lufsIntegrated,
            truePeakDbtp: analysis.technicalData?.truePeakDbtp,
            dynamicRange: analysis.technicalData?.dynamicRange,
            spectral_balance: analysis.technicalData?.spectral_balance ? Object.keys(analysis.technicalData.spectral_balance).length : 0,
            stereoCorrelation: analysis.technicalData?.stereoCorrelation,
            lra: analysis.technicalData?.lra
        },
        // Campos essenciais de genreTargets
        genreTargetsFields: analysis.data?.genreTargets ? {
            lufs: analysis.data.genreTargets.lufs,
            true_peak: analysis.data.genreTargets.true_peak,
            dr: analysis.data.genreTargets.dr,
            spectral_bands: analysis.data.genreTargets.spectral_bands ? Object.keys(analysis.data.genreTargets.spectral_bands).length : 0
        } : null
    });
    
    // ⚠️ ALERTA se technicalData tiver menos de 10 campos
    if (analysis.technicalData && Object.keys(analysis.technicalData).length < 10) {
        console.error("[AUDIT-FINAL-FRONT] ❌ technicalData TEM POUCOS CAMPOS!");
        console.error("[AUDIT-FINAL-FRONT] Campos presentes:", Object.keys(analysis.technicalData));
        console.error("[AUDIT-FINAL-FRONT] MODAL PODE NÃO ABRIR CORRETAMENTE!");
    } else if (analysis.technicalData && Object.keys(analysis.technicalData).length >= 30) {
        console.log("[AUDIT-FINAL-FRONT] ✅ technicalData COMPLETO com", Object.keys(analysis.technicalData).length, "campos");
    }
    
    if (!analysis.data?.genreTargets) {
        // 🔍 IDENTIFICAR O MODO DE ANÁLISE
        const mode = analysis.mode || window.currentAnalysisMode || 'single';
        
        // 🚫 REFERENCE MODE: Não exige genreTargets - usa buildComparisonRows
        if (mode === 'reference') {
            console.log('[REFERENCE-MODE] ✅ Modo referência - genreTargets NÃO necessário');
            console.log('[REFERENCE-MODE] Tabela A vs B será construída via buildComparisonRows()');
            // Skip validação - reference mode não usa genreTargets
        } else {
            // ❌ GENRE MODE: genreTargets é obrigatório
            console.error("[GENRE-MODE] ❌ genreTargets AUSENTE!");
            console.error("[GENRE-MODE] Tabelas de comparação NÃO vão funcionar!");
            
            // 🩹 PATCH CRÍTICO: Tentar reconstruir genreTargets do estado global (APENAS GENRE)
            if (mode === 'genre') {
                const genre = analysis.data?.genre || analysis.genre || window.__CURRENT_SELECTED_GENRE || window.__CURRENT_GENRE;
                const activeRef = window.__activeRefData || 
                                 (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) || 
                                 null;
                
                if (activeRef) {
                    const reconstructedTargets = activeRef.bands || 
                                               activeRef.spectralBands || 
                                               activeRef.spectral_bands ||
                                               (activeRef.targets && (activeRef.targets.bands || activeRef.targets.spectral_bands)) || 
                                               null;
                    
                    if (reconstructedTargets) {
                        console.log('[GENRE-FLOW-PATCH] ✅ genreTargets reconstruído do estado global:', {
                            genre,
                            keys: Object.keys(reconstructedTargets),
                            source: 'window.__activeRefData'
                        });
                        
                        // Garantir que analysis.data exista e persistir genreTargets
                        analysis.data = analysis.data || {};
                        analysis.data.genreTargets = reconstructedTargets;
                        
                        console.log("[GENRE-FLOW-PATCH] ✅ analysis.data.genreTargets restaurado com sucesso");
                    }
                }
            }
        }
    } else {
        console.log("[AUDIT-FINAL-FRONT] ✅ genreTargets presente com", Object.keys(analysis.data.genreTargets).length, "campos");
    }
    
    console.log("🔥🔥🔥 [AUDIT-FINAL-FRONT] FIM DA VALIDAÇÃO 🔥🔥🔥\n\n");
    
    // 🔥 AUDITORIA CRÍTICA: Verificar technicalData DENTRO de displayModalResults
    console.log('\n\n🔥🔥🔥 [AUDIT-TECHNICAL-DATA] DISPLAY ENTRY 🔥🔥🔥');
    console.log('[AUDIT-TECHNICAL-DATA] analysis.technicalData:', {
      exists: !!analysis?.technicalData,
      type: typeof analysis?.technicalData,
      isEmpty: analysis?.technicalData && Object.keys(analysis.technicalData).length === 0,
      keys: analysis?.technicalData ? Object.keys(analysis.technicalData) : [],
      hasSampleFields: {
        lufsIntegrated: analysis?.technicalData?.lufsIntegrated,
        truePeakDbtp: analysis?.technicalData?.truePeakDbtp,
        dynamicRange: analysis?.technicalData?.dynamicRange,
        spectral_balance: !!analysis?.technicalData?.spectral_balance
      }
    });
    console.log('[AUDIT-TECHNICAL-DATA] analysis outros campos:', {
      hasScore: analysis?.score !== undefined,
      scoreValue: analysis?.score,
      hasClassification: !!analysis?.classification,
      hasData: !!analysis?.data,
      hasDataGenreTargets: !!analysis?.data?.genreTargets,
      jobId: analysis?.jobId,
      mode: analysis?.mode
    });
    console.log('🔥🔥🔥 [AUDIT-TECHNICAL-DATA] END 🔥🔥🔥\n\n');
    
    // 🚨 LOG DIAGNÓSTICO: Gênero ANTES de exibir modal
    console.log('[GENRE-BEFORE-DISPLAY] 🎵 Estado do gênero:', {
        preservedGenre: window.__CURRENT_SELECTED_GENRE,
        analysisGenre: analysis?.genre,
        mode: window.__CURRENT_MODE__ || currentAnalysisMode,
        timestamp: new Date().toISOString()
    });

    // ========================================
    // ✅ CORREÇÃO 2: RESTAURAÇÃO DE DADOS DE REFERÊNCIA
    // ========================================
    // Verifica se dados de referência foram perdidos e restaura do cache
    
    // 🎯 CORREÇÃO DEFINITIVA: Usar getCorrectJobId() em vez de acesso direto
    console.group('🔍 [AUDIT-LOCALSTORAGE] displayModalResults - Leitura de referenceJobId');
    console.log('   - Antes: window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('   - Antes: window.__CURRENT_JOB_ID__:', window.__CURRENT_JOB_ID__);
    console.log('   - Antes: localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
    console.log('   - Mode:', currentAnalysisMode);
    
    // 🎯 USA FUNÇÃO SEGURA ao invés de acesso direto
    const referenceJobId = getCorrectJobId('reference'); // Primeira música
    
    console.log('   - Valor obtido via getCorrectJobId("reference"):', referenceJobId);
    console.trace('   - Stack trace:');
    console.groupEnd();
    
    if (referenceJobId && currentAnalysisMode === 'reference') {
        // Verificar se dados de referência estão ausentes
        const hasReferenceData = window.referenceAnalysisData || window.__FIRST_ANALYSIS_FROZEN__;
        const hasFirstAnalysisStore = FirstAnalysisStore.has();
        
        if (!hasReferenceData && !hasFirstAnalysisStore) {
            console.warn('[RESTORE] ⚠️ Dados de referência ausentes - tentando restaurar do cache');
            console.log('[RESTORE] referenceJobId:', referenceJobId);
            
            // Tentar restaurar do AnalysisCache
            if (window.AnalysisCache && window.AnalysisCache.has(referenceJobId)) {
                const cachedReference = window.AnalysisCache.get(referenceJobId);
                
                if (cachedReference) {
                    console.log('[RESTORE] ✅ Referência encontrada no AnalysisCache');
                    
                    // Clone profundo para evitar contaminação
                    const restoredReference = (typeof structuredClone === 'function')
                        ? structuredClone(cachedReference)
                        : JSON.parse(JSON.stringify(cachedReference));
                    
                    // Restaurar para FirstAnalysisStore
                    if (FirstAnalysisStore && typeof FirstAnalysisStore.set === 'function') {
                        FirstAnalysisStore.set(restoredReference);
                        console.log('[RESTORE] ✅ Referência restaurada no FirstAnalysisStore');
                    }
                    
                    // Restaurar window.referenceAnalysisData
                    window.referenceAnalysisData = restoredReference;
                    window.__FIRST_ANALYSIS_FROZEN__ = Object.freeze(restoredReference);
                    
                    console.log('[RESTORE] ✅ Dados de referência completamente restaurados:', {
                        jobId: restoredReference.jobId,
                        fileName: restoredReference.metadata?.fileName || restoredReference.fileName
                    });
                } else {
                    console.error('[RESTORE] ❌ Referência no cache está vazia');
                }
            } else {
                console.error('[RESTORE] ❌ Referência não encontrada no AnalysisCache');
                console.error('[RESTORE] Cache IDs disponíveis:', window.AnalysisCache?.ids?.() || 'N/A');
            }
        } else {
            console.log('[RESTORE] ✅ Dados de referência já existem - restauração não necessária');
        }
    }

    // ========================================
    // ✅ PROTEÇÃO DEFINITIVA CONTRA ERRO DE INTERFACE
    // ========================================
    // Espera o módulo aiUIController inicializar antes de renderizar
    let tries = 0;
    const MAX_TRIES = 30;
    const WAIT_MS = 150;

    while (
        (!window.aiUIController ||
         typeof window.aiUIController.renderMetricCards !== 'function' ||
         typeof window.aiUIController.renderScoreSection !== 'function') &&
        tries < MAX_TRIES
    ) {
        await new Promise(r => setTimeout(r, WAIT_MS));
        tries++;
        if (tries % 5 === 0) {
            console.warn(`[WAIT] aguardando aiUIController carregar... tentativa ${tries}`);
        }
    }

    // Falha definitiva — controller nunca carregou
    if (
        !window.aiUIController ||
        typeof window.aiUIController.renderMetricCards !== 'function'
    ) {
        console.error('[FATAL] aiUIController não carregado após todas as tentativas');
        alert('Erro ao carregar interface de resultados. Recarregue a página.');
        return;
    }

    console.log('[SAFE] ✅ aiUIController detectado, renderização liberada.');

    // 🔍 FLAG DE DEBUG PARA MÉTRICAS PRINCIPAIS
    const DEBUG_MAIN_METRICS = true;
    const DEBUG_LABEL_AUDIT = true; // 🚨 AUDITORIA DE LABELS
    let RENDER_ID = Date.now();

    // ========================================
    // ✅ CORREÇÃO 2: AB SAFETY - Hidratação e Forçar Modo Reference
    // ========================================
    const abState = ensureReferenceHydrated();
    const _modeNow = window.currentAnalysisMode || window.__soundyState?.render?.mode;

    // Se é segunda faixa e temos refId válido, o modo é obrigatoriamente 'reference'
    const isSecondTrack = !!(window.__REFERENCE_JOB_ID__ && window.FirstAnalysisStore?.has?.());
    
    // 🛡️ PROTEÇÃO CRÍTICA: Só forçar modo reference se usuário selecionou explicitamente OU há contexto ativo
    if (isSecondTrack && _modeNow !== 'reference') {
        const hasContextDisplay = hasActiveReferenceContext();
        const allowDisplayReference = userExplicitlySelectedReferenceMode || hasContextDisplay;
        
        console.log('[REF-GUARD] displayModalResults isSecondTrack:', {
            userExplicit: userExplicitlySelectedReferenceMode,
            hasContext: hasContextDisplay,
            allowed: allowDisplayReference
        });
        
        if (!allowDisplayReference) {
            console.error('%c[PROTECTION] ❌ BLOQUEIO em displayModalResults: isSecondTrack detectado mas userExplicitlySelectedReferenceMode = false E sem contexto ativo', 'color:#FF0000;font-weight:bold;font-size:16px;');
            console.error('[PROTECTION] ❌ Sistema em modo genre - NÃO pode forçar modo reference');
            console.error('[PROTECTION] ❌ Abortando renderização A/B');
            console.trace('[PROTECTION] Stack trace do bloqueio:');
            // NÃO forçar modo reference - abortar
            return;
        }
        
        window.currentAnalysisMode = 'reference';
        if (window.__soundyState?.render) window.__soundyState.render.mode = 'reference';
        console.warn('[AB-FORCE] Forçando mode=reference porque há segunda faixa + referenceId.');
        console.log('%c[PROTECTION] ✅ Modo forçado para reference em displayModalResults - flag verificada', 'color:#00FF88;font-weight:bold;');
    }

    // Validar referência e tentar hidratação se necessário
    if (isSecondTrack && (!abState.ok || !window.referenceAnalysisData?.bands)) {
        console.warn('[AB-BLOCK] Referência inicial não hidratada - tentando recuperar...');
        
        // 🎯 TENTATIVA DE HIDRATAÇÃO: Recuperar de FirstAnalysisStore
        const refFromStore = FirstAnalysisStore?.getRef?.();
        
        // 🔍 LOGS DIAGNÓSTICOS
        console.log('[REF-FIX] 📦 Verificando store:', {
            hasRefInStore: !!refFromStore,
            refKeys: refFromStore ? Object.keys(refFromStore) : null,
            refJobId: refFromStore?.jobId,
            hasMetrics: !!refFromStore?.metrics,
            hasTechnicalData: !!refFromStore?.technicalData
        });
        
        // 🔍 NOVA VALIDAÇÃO: Verificar métricas A/B ao invés de bands
        const refMetrics = extractABMetrics(refFromStore);
        console.log('[REF-FIX] 🔍 Extração de métricas:', {
            ok: refMetrics.ok,
            debugShape: refMetrics.debugShape
        });
        console.log('[AB-DATA] refFromStore keys:', refFromStore ? Object.keys(refFromStore) : null);
        console.log('[AB-DATA] ref metrics extraction:', refMetrics);
        
        if (refMetrics.ok) {
            console.log('[AB-HYDRATE] ✅ Recuperado de FirstAnalysisStore:', {
                jobId: refFromStore.jobId,
                fileName: refFromStore.fileName || refFromStore.metadata?.fileName,
                hasMetrics: refMetrics.ok,
                debugShape: refMetrics.debugShape
            });
            
            // Hidratar window.referenceAnalysisData
            window.referenceAnalysisData = {
                ...refFromStore,
                jobId: refFromStore.jobId,
                bands: refFromStore.bands || extractBands(refFromStore),
                metrics: refMetrics.metrics,
                technicalData: refMetrics.technicalData
            };
            
            // Atualizar abState
            abState.ok = true;
            abState.hasBands = true;
            
            console.log('[AB-HYDRATE] ✅ window.referenceAnalysisData hidratado com sucesso');
        } else {
            // ❌ DIAGNÓSTICO DETALHADO antes de mostrar fallback
            console.error('[REF-FIX] ❌ Hidratação falhou - DIAGNÓSTICO:');
            console.error('[REF-FIX]   1. FirstAnalysisStore.getRef() retornou:', refFromStore ? 'objeto' : 'null/undefined');
            console.error('[REF-FIX]   2. refFromStore.jobId:', refFromStore?.jobId);
            console.error('[REF-FIX]   3. refFromStore.technicalData existe?', !!refFromStore?.technicalData);
            console.error('[REF-FIX]   4. refFromStore.metrics existe?', !!refFromStore?.metrics);
            console.error('[REF-FIX]   5. extractABMetrics debugShape:', refMetrics.debugShape);
            console.error('[REF-FIX]   6. window.__REFERENCE_JOB_ID__:', getReferenceJobId());
            console.error('[REF-FIX]   7. Chaves disponíveis:', refFromStore ? Object.keys(refFromStore) : 'N/A');
            console.error('[AB-BLOCK] abState:', abState);
            console.error('[AB-BLOCK] FirstAnalysisStore.getRef():', refFromStore);
            console.error('[AB-DATA] ref metrics extraction failed:', refMetrics.debugShape);
            
            // Renderizar fallback com diagnóstico preciso
            const container = ensureReferenceContainer();
            if (container) {
                const diagnosticDetails = refFromStore 
                    ? `jobId: ${refFromStore.jobId || 'ausente'}, metrics: ${!!refFromStore.metrics ? 'presente' : 'ausente'}, technicalData: ${!!refFromStore.technicalData ? 'presente' : 'ausente'}`
                    : 'Store completamente vazio';
                
                container.innerHTML = `
                    <div class="card" style="margin-top: 20px; background: #2a1a1a; border: 2px solid #ff4444;">
                        <div class="card-title" style="color: #ff6666;">⚠️ Comparação A/B Indisponível</div>
                        <div style="padding: 15px; color: #ffaaaa; line-height: 1.6;">
                            <p><strong>Motivo:</strong> Não foi possível recuperar métricas da primeira música.</p>
                            <p><strong>Diagnóstico:</strong> ${diagnosticDetails}</p>
                            <p><strong>Solução:</strong> Selecione novamente o modo "Análise de Referência A/B" e faça upload das duas músicas.</p>
                        </div>
                    </div>
                `;
                container.style.display = 'block';
                console.log('[AB-FALLBACK] ✅ Mensagem de erro renderizada no DOM');
            }
            
            // NÃO abortar completamente - continuar renderizando cards da 2ª música
        }
    } else if (isSecondTrack) {
        console.log('[AB-SAFETY] ✅ Referência validada:', {
            ok: abState.ok,
            refId: abState.refId,
            hasBands: abState.hasBands,
            file: abState.file
        });
    }

    // =========================================================================
    // 🆔 INFO: Sistema agora usa Virtual IDs (VID) para separação por papel
    // =========================================================================
    // Mesmo que jobIds sejam iguais, Virtual IDs (jobId::USER e jobId::REF) mantêm separação
    // O bloqueio de self-compare agora é feito por conteúdo em renderReferenceComparisons
    console.log('[VID-INFO] ✅ Sistema usa Virtual IDs - jobId reutilizado não causa self-compare', {
        currentJobId: analysis?.jobId,
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        storeHasUser: !!FirstAnalysisStore.getUser(),
        storeHasRef: !!FirstAnalysisStore.getRef()
    });
    
    // ✅ HARD-GUARD: Validar FirstAnalysisStore - se vazio, é modo genre (não reference)
    if (!FirstAnalysisStore.has()) {
        console.log('[INFO] FirstAnalysisStore vazio - modo genre (não reference). Continuando render normalmente.');
        // ✅ NÃO RETORNA AQUI! Modo genre não precisa de primeira análise
    } else {
        console.log('[HARD-GUARD] ✅ FirstAnalysisStore validado - primeira análise protegida:', {
            jobId: FirstAnalysisStore.get()?.jobId,
            fileName: FirstAnalysisStore.get()?.metadata?.fileName
        });
    }
    
    // =========================================================================
    // �🚨 DEBUG CRÍTICO: Timing e Estado dos Dados (detecta chamada prematura)
    // =========================================================================
    console.groupCollapsed("[DEBUG-DISPLAY] 🧠 Início displayModalResults()");
    console.log("📦 analysis.metadata.fileName:", analysis?.metadata?.fileName);
    console.log("🧊 FirstAnalysisStore:", FirstAnalysisStore.has() ? FirstAnalysisStore.get()?.metadata?.fileName : 'null');
    console.log("📊 analysis.metrics:", !!analysis?.metrics, "technicalData:", !!analysis?.technicalData);
    const storedFirstForDebug = FirstAnalysisStore.get();
    console.log("📊 first.metrics:", !!storedFirstForDebug?.metrics, "technicalData:", !!storedFirstForDebug?.technicalData);
    console.groupEnd();
    
    // =========================================================================
    // 🚨 AUDITORIA COMPLETA EM TEMPO DE EXECUÇÃO - DESCOBRIR POR QUE NÃO RENDERIZA
    // =========================================================================
    try {
        console.groupCollapsed('[AUDITORIA_REFERENCE_MODE] 🔍 INVESTIGAÇÃO COMPLETA');
        console.log('[STEP 1] 🔍 Modo recebido:', analysis?.mode);
        console.log('[STEP 2] 🔍 Contém metrics?', !!analysis?.metrics);
        console.log('[STEP 3] 🔍 Contém technicalData?', !!analysis?.technicalData);
        console.log('[STEP 4] 🔍 Contém suggestions?', !!analysis?.suggestions);
        console.log('[STEP 5] 🔍 Funções disponíveis:', {
            renderMetricCards: typeof window.renderMetricCards,
            renderScoreSection: typeof window.renderScoreSection,
            renderSuggestions: typeof window.renderSuggestions,
            renderFinalScoreAtTop: typeof window.renderFinalScoreAtTop,
            renderAdvancedMetrics: typeof window.renderAdvancedMetrics,
        });
        console.log('[STEP 6] 🔍 analysis (safe):', safeStringify(analysis || {}));
        console.groupEnd();
    } catch (e) {
        console.warn('[AUDITORIA_REFERENCE_MODE] ⚠️ Falha ao logar analysis:', e.message);
    }
    
    // 🔍 AUDITORIA: Estado AO ENTRAR em displayModalResults
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] 🚀 displayModalResults - ENTRADA');
    console.log('⚙️ Função: displayModalResults');
    console.log('📊 analysis (parâmetro recebido):', {
        jobId: analysis?.jobId,
        fileName: analysis?.metadata?.fileName || analysis?.fileName,
        lufs: analysis?.technicalData?.lufsIntegrated,
        mode: analysis?.mode,
        objectId: analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis
    });
    console.log('🎧 analysis.userAnalysis:', analysis?.userAnalysis ? {
        fileName: analysis.userAnalysis?.metadata?.fileName || analysis.userAnalysis?.fileName,
        jobId: analysis.userAnalysis?.jobId,
        lufs: analysis.userAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.userAnalysis
    } : 'null');
    console.log('🎧 analysis.referenceAnalysis:', analysis?.referenceAnalysis ? {
        fileName: analysis.referenceAnalysis?.metadata?.fileName || analysis.referenceAnalysis?.fileName,
        jobId: analysis.referenceAnalysis?.jobId,
        lufs: analysis.referenceAnalysis?.technicalData?.lufsIntegrated,
        objectId: analysis.referenceAnalysis
    } : 'null');
    console.log('🌐 Estado global atual:');
    const storedFirstForAudit = FirstAnalysisStore.get();
    console.log('  FirstAnalysisStore:', storedFirstForAudit ? {
        fileName: storedFirstForAudit.metadata?.fileName,
        jobId: storedFirstForAudit.jobId,
        lufs: storedFirstForAudit.technicalData?.lufsIntegrated
    } : 'null');
    console.log('  window.__soundyState.previousAnalysis:', window.__soundyState?.previousAnalysis ? {
        fileName: window.__soundyState.previousAnalysis?.metadata?.fileName || window.__soundyState.previousAnalysis?.fileName,
        jobId: window.__soundyState.previousAnalysis?.jobId
    } : 'null');
    console.log('⚠️ VERIFICAÇÃO DE CONTAMINAÇÃO:');
    console.log('  analysis.userAnalysis === analysis.referenceAnalysis?', analysis?.userAnalysis === analysis?.referenceAnalysis);
    console.groupEnd();
    
    // 🎯 LOG INICIAL PARA CONFIRMAR CHAMADA DA FUNÇÃO APÓS CORREÇÕES
    console.log("✅ [DISPLAY_MODAL] Função displayModalResults chamada com dados:", analysis);
    console.log("✅ [DISPLAY_MODAL] Estrutura dos dados recebidos:", Object.keys(analysis || {}));
    
    // 🔒 PROTEÇÃO MODO REFERENCE: Evitar sobrescrita por interceptores
    if (analysis && analysis.mode === "reference") {
        const previous = window.__soundyState?.previousAnalysis;
        const user = analysis.userAnalysis || previous;
        const ref = analysis.referenceAnalysis || 
                    window.__soundyState?.referenceAnalysis || 
                    window.__soundyState?.reference?.referenceAnalysis || 
                    null;

        console.log("[REFERENCE-FLOW ✅] Comparação direta A/B antes da renderização:", {
            userTrack: user?.fileName || user?.metadata?.fileName,
            referenceTrack: ref?.fileName || ref?.metadata?.fileName,
            hasUserBands: !!(user?.technicalData?.spectral_balance || user?.bands),
            hasRefBands: !!(ref?.technicalData?.spectral_balance || ref?.bands),
        });

        // 🔒 Proteção contra sobrescrita por interceptores
        if (user) Object.freeze(user);
        if (ref) Object.freeze(ref);

        const payload = {
            mode: "reference",
            userAnalysis: user,
            referenceAnalysis: ref,
        };

        // ==== PATCH 3: DEFINITIVO - FirstAnalysisStore + refHardGuards ====
        const first = FirstAnalysisStore.get();
        
        if (!first) {
            console.error('[A/B] ❌ Primeira análise não encontrada no FirstAnalysisStore');
            console.warn('[A/B] ⚠️ Renderizando apenas segunda análise como single');
            
            // Renderiza apenas a segunda como single (fallback seguro)
            if (typeof window.aiUIController !== 'undefined') {
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            return; // não prossegue sem primeira análise
        }

        // ✅ MONTAGEM A/B COM ISOLAMENTO COMPLETO
        let userFull = first; // 1ª faixa (já é clone do FirstAnalysisStore.get())
        let refFull = (typeof structuredClone === 'function')
            ? structuredClone(analysis)
            : JSON.parse(JSON.stringify(analysis)); // 2ª faixa (clone explícito)

        // �️ APLICAR GUARDS: Isola jobIds se forem iguais
        ({ userFull, refFull } = refHardGuards({ userFull, refFull }));

        // 🔬 GERAR SUGESTÕES COMPARATIVAS A vs B (se ainda não existirem)
        const hasExistingSuggestions = Array.isArray(userFull?.aiSuggestions) && userFull.aiSuggestions.length > 0;
        
        if (!hasExistingSuggestions) {
            console.log('[A/B-FLOW] 🔬 Gerando sugestões comparativas A vs B...');
            const comparativeSuggestions = buildComparativeAISuggestions(userFull, refFull);
            
            if (comparativeSuggestions.length > 0) {
                // Injetar sugestões comparativas no userFull
                userFull.aiSuggestions = comparativeSuggestions;
                userFull.hasEnriched = true;
                userFull.mode = "compare";
                
                // 🎯 CORREÇÃO: Popular PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA para Enhanced Suggestion Engine
                // Isso permite que o engine também processe bandas espectrais no modo reference
                const referenceComparisonData = comparativeSuggestions
                    .filter(s => s.referenceMode === true || s.type === 'band_adjust')
                    .map(s => ({
                        metric: s.subtype || s.metric,
                        name: s.categoria,
                        category: 'spectral_bands',
                        value: s.parametros?.valorAtual,
                        ideal: s.parametros?.valorReferencia,
                        delta: s.parametros?.diferenca,
                        tolerance: s.technical?.tolerance || 1.5,
                        severity: s.severidade
                    }));
                
                if (referenceComparisonData.length > 0) {
                    window.PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA = referenceComparisonData;
                    console.log('[A/B-FLOW] 🎯 PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA populado:', {
                        total: referenceComparisonData.length,
                        bands: referenceComparisonData.map(r => r.metric).join(', ')
                    });
                }
                
                console.log('[A/B-FLOW] ✅ Sugestões comparativas injetadas:', {
                    quantidade: comparativeSuggestions.length,
                    metricas: comparativeSuggestions.filter(s => !s.referenceMode).length,
                    bandas: comparativeSuggestions.filter(s => s.referenceMode === true).length,
                    categorias: comparativeSuggestions.map(s => s.categoria).join(', ')
                });
            } else {
                console.warn('[A/B-FLOW] ⚠️ Nenhuma sugestão comparativa gerada - métricas insuficientes');
            }
        } else {
            console.log('[A/B-FLOW] ℹ️ Sugestões já existem - pulando geração comparativa');
        }

        // ✅ RENDER COMPLETO (nunca aborta por contaminação - trabalha direto nos objetos)
        if (typeof window.aiUIController !== 'undefined') {
            window.aiUIController.renderMetricCards({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderScoreSection({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderSuggestions({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.renderFinalScoreAtTop({ mode: 'reference', user: userFull, reference: refFull });
            window.aiUIController.checkForAISuggestions({ mode: 'reference', user: userFull, reference: refFull });
        }

        console.log('[A/B-END] ✅', {
            userFile: userFull?.fileName || userFull?.metadata?.fileName,
            refFile: refFull?.fileName || refFull?.metadata?.fileName,
            userId: userFull?.jobId || userFull?.id,
            refId: refFull?.jobId || refFull?.id
        });
        
        // ✅ CORREÇÃO CRÍTICA DA AUDITORIA (linha 4502)
        // REMOVIDO return prematuro que bloqueava:
        // - Normalização de dados (linha 4822)
        // - Cálculo de scores (linha 4889)
        // - Renderização de cards (linha 6623)
        // - renderFinalScoreAtTop() (linha 6620)
        // - advancedMetricsCard() (linha 6636)
        // ❌ return; ← REMOVIDO
        
        console.log('[AUDIT-CORRECTION] ✅ Fluxo continuará para renderizar cards, scores e sugestões');
        console.log('[AUDIT-CORRECTION] ✅ Return prematuro removido - pipeline completo ativado');
    } else if (analysis && analysis.mode === "genre") {
        // 🎯 PATCH 1: MODO GÊNERO COM TARGETS
        console.log('[GENRE-FLOW] 🎯 Renderizando modo gênero com targets');
        
        // 🎯 ESTRATÉGIA: Obter targets COMPLETOS de PROD_AI_REF_DATA, depois aplicar streaming override
        const genre = analysis.genre || analysis.data?.genre;
        let genreTargets = null;
        
        // 🎯 PRIORIDADE 1: PROD_AI_REF_DATA[genre] - FONTE COMPLETA
        if (genre && window.PROD_AI_REF_DATA && typeof window.PROD_AI_REF_DATA === 'object' && window.PROD_AI_REF_DATA[genre]) {
            genreTargets = JSON.parse(JSON.stringify(window.PROD_AI_REF_DATA[genre])); // Deep copy
            console.log('[GENRE-FLOW] 📦 Targets BASE obtidos de PROD_AI_REF_DATA[genre]');
        }
        
        // 🎯 FALLBACK: analysis.data.genreTargets
        if (!genreTargets && analysis.data?.genreTargets) {
            genreTargets = JSON.parse(JSON.stringify(analysis.data.genreTargets));
            console.log('[GENRE-FLOW] 📦 Targets obtidos de analysis.data.genreTargets (fallback)');
        }
        
        // 📡 STREAMING MODE: Aplicar override de LUFS e TP (mantém DR, LRA, Stereo, Bandas)
        if (getSoundDestinationMode() === 'streaming' && genreTargets) {
            console.log('[GENRE-FLOW] 📡 STREAMING MODE DETECTADO - Aplicando override de LUFS/TP');
            genreTargets.lufs_target = STREAMING_TARGETS.lufs_target;      // -14
            genreTargets.true_peak_target = STREAMING_TARGETS.true_peak_target; // -1.0
            console.log('[GENRE-FLOW] 📡 Targets atualizados para streaming:', {
                lufs_target: genreTargets.lufs_target,
                true_peak_target: genreTargets.true_peak_target
            });
        }
        
        if (!genreTargets) {
            console.warn('[GENRE-FLOW] ⚠️ genreTargets não encontrado em analysis.data!');
            console.warn('[GENRE-FLOW]    analysis.data:', analysis.data);
            console.warn('[GENRE-FLOW]    analysis.genreTargets:', analysis.genreTargets);
            
            // 🩹 PATCH: NÃO dar return - continuar com degradê
            console.warn('[GENRE-FLOW] ⚠️ Modo DEGRADÊ: Renderizando sem tabela de comparação');
            console.warn('[GENRE-FLOW] ✅ Score, métricas e sugestões serão exibidos normalmente');
            
            // Renderizar em modo single (sem targets)
            if (typeof window.aiUIController !== 'undefined') {
                console.log('[GENRE-FLOW] 🎯 Renderizando em modo single (degradê)');
                window.aiUIController.renderSuggestions({ mode: 'single', user: analysis });
                window.aiUIController.renderMetricCards({ mode: 'single', user: analysis });
                window.aiUIController.renderScoreSection({ mode: 'single', user: analysis });
                window.aiUIController.renderFinalScoreAtTop({ mode: 'single', user: analysis });
                window.aiUIController.checkForAISuggestions({ mode: 'single', user: analysis });
            }
            
            // ❌ NÃO dar return - deixar modal abrir normalmente
            // return; ← REMOVIDO
        } else {
            console.log('[GENRE-FLOW] ✅ genreTargets encontrado:', {
                lufs_target: genreTargets.lufs_target,
                true_peak_target: genreTargets.true_peak_target,
                dr_target: genreTargets.dr_target,
                spectralBands: genreTargets.spectralBands ? Object.keys(genreTargets.spectralBands) : null
            });
        
        // ✅ Renderizar tabela de comparação com targets
        renderGenreComparisonTable({
            analysis,
            genre: analysis.genre || analysis.data.genre,
            targets: genreTargets
        });
        
        // ✅ Renderizar sugestões com contexto de gênero
        if (typeof window.aiUIController !== 'undefined') {
            console.log('[GENRE-FLOW] 🎯 Renderizando sugestões em modo gênero');
            
            window.aiUIController.renderSuggestions({ 
                mode: 'genre', 
                user: analysis,
                targets: genreTargets
            });
            
            window.aiUIController.renderMetricCards({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderScoreSection({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.renderFinalScoreAtTop({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
            
            window.aiUIController.checkForAISuggestions({ 
                mode: 'genre', 
                user: analysis, 
                targets: genreTargets 
            });
        }
        
        console.log('[GENRE-FLOW] ✅ Renderização de modo gênero concluída');
        } // ← Fechar else do genreTargets
    }
    
    // [AUDIT-FLOW-CHECK] Verificar se chegou aqui (deveria chegar sempre, inclusive no modo reference)
    console.log('[AUDIT-FLOW-CHECK] ✅ Fluxo continua após blocos reference/genre - modo:', analysis?.mode);
    
    // 🔒 VALIDAÇÃO CRÍTICA: Garantir que métricas essenciais estão presentes
    // CORRIGIDO: Verificar novos caminhos do backend Redis
    const hasEssentialMetrics = (
        analysis?.technicalData && 
        (
            Number.isFinite(analysis.technicalData.lufsIntegrated) ||
            Number.isFinite(analysis.technicalData.lufs_integrated) ||
            Number.isFinite(analysis.technicalData.avgLoudness) ||
            Number.isFinite(analysis.technicalData.dynamicRange) ||
            // NOVOS CAMINHOS: Estrutura do backend Redis
            Number.isFinite(analysis.loudness?.integrated) ||
            Number.isFinite(analysis.technicalData?.dr) ||
            // Fallback: Se tem score, provavelmente tem dados válidos
            Number.isFinite(analysis.score)
        )
    );
    
    if (!hasEssentialMetrics) {
        console.warn('⚠️ [UI_GATE] Aguardando métricas essenciais... análise incompleta:', analysis);
        console.log('🔍 [UI_GATE] Debug - estrutura recebida:', {
            technicalData: analysis?.technicalData,
            loudness: analysis?.loudness,
            score: analysis?.score,
            hasScore: Number.isFinite(analysis?.score)
        });
        
        // CORREÇÃO: Verificar se é estrutura nova mas válida
        if (analysis?.loudness || analysis?.technicalData || Number.isFinite(analysis?.score)) {
            console.warn("⚠️ [UI_GATE] Estrutura nova detectada, prosseguindo com dados disponíveis");
        } else {
            console.warn('[AUDITORIA_CONDICAO] ⚠️ Retorno antecipado em: hasEssentialMetrics falhou - mode:', analysis?.mode);
            console.warn('[AUDITORIA_TIMING] normalizeBackendAnalysisData terminado?', !!window.currentAnalysisData);
            console.warn('[AUDITORIA_TIMING] displayModalResults chamado?', performance.now());
            // Tentar novamente em 2 segundos apenas se realmente não há dados
            setTimeout(() => displayModalResults(analysis), 2000);
            return;
        }
    }
    
    console.log('✅ [UI_GATE] Métricas essenciais presentes, exibindo resultados');
    
    // 🔥 CORREÇÃO COMPARAÇÃO A/B: Usar _userAnalysis (1ª faixa = sua música) para cards/métricas
    if (analysis._isReferenceMode && analysis._userAnalysis && analysis._referenceAnalysis) {
        console.log('[REFERENCE-DISPLAY] 🎯 ═══════════════════════════════════════');
        console.log('[REFERENCE-DISPLAY] 🎯 Modo A/B detectado - Configuração correta:');
        console.log('[REFERENCE-DISPLAY] ✅ 1ª faixa (SUA MÚSICA/ATUAL):', analysis._userAnalysis?.fileName || analysis._userAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] ✅ 2ª faixa (REFERÊNCIA/ALVO):', analysis._referenceAnalysis?.fileName || analysis._referenceAnalysis?.metadata?.fileName);
        console.log('[REFERENCE-DISPLAY] 📊 Cards principais: mostrarão métricas da SUA MÚSICA (1ª faixa)');
        console.log('[REFERENCE-DISPLAY] 📊 Tabela comparativa: SUA MÚSICA (esquerda) vs REFERÊNCIA (direita)');
        console.log('[REFERENCE-DISPLAY] 🎯 ═══════════════════════════════════════');
        
        // Salvar análise de referência antes de substituir
        const originalReferenceAnalysis = analysis._referenceAnalysis;
        
        // SUBSTITUIR analysis pelos dados da PRIMEIRA faixa (sua música/atual) para renderização dos cards
        const firstTrackAnalysis = analysis._userAnalysis;
        
        // Copiar propriedades importantes
        analysis = {
            ...firstTrackAnalysis,
            _isReferenceMode: true,
            _userAnalysis: firstTrackAnalysis,
            _referenceAnalysis: originalReferenceAnalysis,
            mode: 'reference' // Manter modo para lógica posterior
        };
        
        console.log('[REFERENCE-DISPLAY ✅] Analysis substituído por dados da sua música (1ª faixa)');
        console.log('[REFERENCE-DISPLAY] Métricas da SUA MÚSICA a serem exibidas nos cards:', {
            lufs: analysis.technicalData?.lufsIntegrated || analysis.loudness?.integrated,
            dr: analysis.technicalData?.dynamicRange || analysis.technicalData?.dr,
            tp: analysis.technicalData?.truePeakDbtp || analysis.truePeak?.maxDbtp
        });
    }
    
    // 🎯 DETECÇÃO DE MODO COMPARAÇÃO ENTRE FAIXAS
    const isSecondTrackCheck = window.__REFERENCE_JOB_ID__ !== null && window.__REFERENCE_JOB_ID__ !== undefined;
    const mode = analysis?.mode || currentAnalysisMode;
    
    // 🔴🔴🔴 DIAGNÓSTICO CRÍTICO: Por que não está entrando no bloco A/B?
    console.log('🔴🔴🔴 [DIAGNÓSTICO-AB] ════════════════════════════════════');
    console.log('🔴 [DIAGNÓSTICO-AB] Valores das variáveis da condicional:');
    console.log('🔴 [DIAGNÓSTICO-AB]   analysis?.mode:', analysis?.mode);
    console.log('🔴 [DIAGNÓSTICO-AB]   currentAnalysisMode:', currentAnalysisMode);
    console.log('🔴 [DIAGNÓSTICO-AB]   mode (final):', mode);
    console.log('🔴 [DIAGNÓSTICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
    console.log('🔴 [DIAGNÓSTICO-AB]   isSecondTrackCheck:', isSecondTrackCheck);
    console.log('🔴 [DIAGNÓSTICO-AB] Condicional será:', mode === 'reference' && isSecondTrackCheck);
    console.log('🔴 [DIAGNÓSTICO-AB]   mode === "reference"?', mode === 'reference');
    console.log('🔴 [DIAGNÓSTICO-AB]   isSecondTrackCheck?', isSecondTrackCheck);
    console.log('🔴🔴🔴 [DIAGNÓSTICO-AB] ════════════════════════════════════');
    
    // 🎯 DEFINIR MODO NO ESTADO ANTES DE QUALQUER CÁLCULO
    const state = window.__soundyState || {};
    state.render = state.render || {};
    
    // 🔴 FIX CRÍTICO: Remover verificação de window.__FIRST_ANALYSIS_FROZEN__ da condicional
    // para permitir entrada no bloco e fazer recuperação automática
    if (mode === 'reference' && isSecondTrackCheck) {
        console.log('🎯 [COMPARE-MODE] Modo reference detectado - Segunda faixa chegou');
        console.log('📊 [COMPARE-MODE] window.__FIRST_ANALYSIS_FROZEN__ existe?', !!window.__FIRST_ANALYSIS_FROZEN__);
        console.log('📊 [COMPARE-MODE] Segunda faixa:', analysis);
        
        // 🎯 DEFINIR MODO REFERENCE NO ESTADO
        state.render.mode = 'reference';
        window.__soundyState = state;
        console.log('✅ [COMPARE-MODE] Modo definido como REFERENCE no estado');
        
        // 🎯 CRIAR ESTRUTURA DE COMPARAÇÃO ENTRE FAIXAS COM CÓPIA DEFENSIVA
        
        // 🔍 AUDITORIA: Estado ANTES de deepCloneSafe + normalizeBackendAnalysisData
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] 🔒 ANTES deepCloneSafe + normalize');
        console.log('⚙️ Contexto: Prestes a criar refNormalized e currNormalized');
        console.log('📊 window.__FIRST_ANALYSIS_FROZEN__ (1ª faixa):', {
            fileName: window.__FIRST_ANALYSIS_FROZEN__?.metadata?.fileName,
            jobId: window.__FIRST_ANALYSIS_FROZEN__?.jobId,
            lufs: window.__FIRST_ANALYSIS_FROZEN__?.technicalData?.lufsIntegrated,
            objectId: window.__FIRST_ANALYSIS_FROZEN__
        });
        console.log('📊 analysis (2ª faixa):', {
            fileName: analysis?.metadata?.fileName || analysis?.fileName,
            jobId: analysis?.jobId,
            lufs: analysis?.technicalData?.lufsIntegrated,
            objectId: analysis
        });
        console.log('💡 Operação: deepCloneSafe() + normalizeBackendAnalysisData()');
        console.groupEnd();
        
        // ========================================
        // 🧠 PRIORIZAR DADOS DO STORE ISOLADO (FONTE DE VERDADE)
        // ========================================
        let refNormalized, currNormalized;
        
        // 🔒 PRIORIDADE ABSOLUTA: Verificar SoundyAI_Store PRIMEIRO
        const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
        
        if (storeHasBoth) {
            console.log('🎯 [STORE-ABSOLUTE-PRIORITY] ✅ Store tem ambas análises - USANDO COMO FONTE ÚNICA');
            console.log('   - Store.first.jobId:', window.SoundyAI_Store.first?.jobId);
            console.log('   - Store.second.jobId:', window.SoundyAI_Store.second?.jobId);
            console.log('   - Store.first.fileName:', window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName);
            console.log('   - Store.second.fileName:', window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName);
            
            // Normalizar dados do store (não do comparisonPair que pode estar desatualizado)
            refNormalized = normalizeSafe(window.SoundyAI_Store.first);   // Primeira música
            currNormalized = normalizeSafe(window.SoundyAI_Store.second); // Segunda música
            
            console.log('✅ [STORE-ABSOLUTE-PRIORITY] Dados do store normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
            
            // 🚨 VALIDAÇÃO CRÍTICA: Detectar contaminação no store
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('🚨 [STORE-ERROR] ❌ CONTAMINAÇÃO NO STORE DETECTADA!');
                console.error('   - JobIds são IGUAIS:', window.SoundyAI_Store.first.jobId);
                console.error('   - Isso indica bug no salvamento dos dados');
                console.trace();
            }
            
        } else if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('🎯 [STORE-PRIORITY] Usando dados do comparisonPair (anexado ao analysis)');
            const pair = analysis._comparisonPair;
            
            // Normalizar dados do comparisonPair
            refNormalized = normalizeSafe(pair.ref);   // Primeira música (referência)
            currNormalized = normalizeSafe(pair.curr); // Segunda música (atual)
            
            console.log('✅ [STORE-PRIORITY] Dados do comparisonPair normalizados:');
            console.log('   - refNormalized.jobId:', refNormalized?.jobId);
            console.log('   - currNormalized.jobId:', currNormalized?.jobId);
            console.log('   - refNormalized.fileName:', refNormalized?.fileName || refNormalized?.metadata?.fileName);
            console.log('   - currNormalized.fileName:', currNormalized?.fileName || currNormalized?.metadata?.fileName);
        } else {
            console.log('⚠️ [LEGACY-MODE] Store não disponível, usando modo legado');
            console.warn('⚠️ [LEGACY-WARN] ATENÇÃO: Modo legado pode ter contaminação!');
            
            // 🔒 HARD-GUARD: Usar FirstAnalysisStore.get() (única fonte de verdade - modo legado)
            const firstAnalysis = FirstAnalysisStore.get();
            
            console.log('🔴 [AUDIT-CRITICAL] ANTES de criar refNormalized/currNormalized:');
            console.log('  FirstAnalysisStore.has():', FirstAnalysisStore.has());
            console.log('  firstAnalysis.metadata?.fileName:', firstAnalysis?.metadata?.fileName);
            console.log('  firstAnalysis.jobId:', firstAnalysis?.jobId);
            console.log('  analysis.metadata?.fileName:', analysis?.metadata?.fileName);
            console.log('  analysis.jobId:', analysis?.jobId);
            console.log('  🚨 SÃO O MESMO ARQUIVO?', firstAnalysis?.metadata?.fileName === analysis?.metadata?.fileName);
            console.log('  🚨 SÃO O MESMO JOBID?', firstAnalysis?.jobId === analysis?.jobId);
            
            // ✅ STEP 2/6 REFATORADO: Normalização segura sem ciclos (modo legado)
            console.log('[NORMALIZE-DEFENSIVE] 🔒 Criando cópia isolada da 1ª faixa (normalizeSafe)');
            refNormalized = normalizeSafe(firstAnalysis);
            
            console.log('[NORMALIZE-DEFENSIVE] 🔒 Criando cópia isolada da 2ª faixa (normalizeSafe)');
            currNormalized = normalizeSafe(analysis);
        }
        
        // ========================================
        // 🚨 VALIDAÇÃO CRÍTICA ABSOLUTA: ABORTAR SE JOBIDS IGUAIS
        // ========================================
        const refFileName = refNormalized?.metadata?.fileName || refNormalized?.fileName;
        const currFileName = currNormalized?.metadata?.fileName || currNormalized?.fileName;
        const refJobId = refNormalized?.jobId || refNormalized?.id;
        const currJobId = currNormalized?.jobId || currNormalized?.id;
        
        console.groupCollapsed('[PRE-VALIDATION] 🔍 Verificação de Integridade dos Objetos');
        console.log('📁 Arquivo 1 (ref):', refFileName);
        console.log('📁 Arquivo 2 (curr):', currFileName);
        console.log('🆔 JobId 1 (ref):', refJobId);
        console.log('🆔 JobId 2 (curr):', currJobId);
        console.log('⚠️ Nomes iguais?', refFileName === currFileName);
        console.log('⚠️ JobIds iguais?', refJobId === currJobId);
        console.log('⚠️ Objetos são mesma referência?', refNormalized === currNormalized);
        console.log('⚠️ Metadata são mesma referência?', refNormalized?.metadata === currNormalized?.metadata);
        console.groupEnd();
        
        // 🚨 VALIDAÇÃO CRÍTICA: Se jobIds forem iguais, ABORTAR IMEDIATAMENTE
        if (refJobId && currJobId && refJobId === currJobId) {
            console.error('🚨🚨🚨 [CRITICAL-ERROR] JOBIDS IGUAIS DETECTADOS! 🚨🚨🚨');
            console.error('   - refJobId:', refJobId);
            console.error('   - currJobId:', currJobId);
            console.error('   - refFileName:', refFileName);
            console.error('   - currFileName:', currFileName);
            console.error('   - Sistema está tentando comparar a música consigo mesma!');
            console.error('   - ABORTANDO renderização para evitar dados incorretos');
            console.trace();
            
            // Mostrar alerta ao usuário
            alert('❌ ERRO CRÍTICO: Sistema detectou que está tentando comparar a mesma música.\n\n' +
                  'JobId 1: ' + refJobId + '\n' +
                  'JobId 2: ' + currJobId + '\n\n' +
                  'Por favor, recarregue a página e tente novamente com duas músicas DIFERENTES.');
            
            // ABORTAR renderização
            return;
        }
        
        console.log('✅ [VALIDATION-PASS] JobIds são diferentes - prosseguindo com renderização');
        
        // 🛡️ Proteção contra auto-comparação e renderização segura
        let isSelfCompare = false;
        
        // ========================================
        // 🔧 VALIDAÇÃO INTELIGENTE: Usar jobId e VID em vez de apenas fileName
        // ========================================
        const sameFileName = refFileName === currFileName;
        const sameJobId = !!(refJobId && currJobId && refJobId === currJobId);
        
        // Verificar Virtual IDs (mais confiável que fileName)
        const refVid = refNormalized?.vid || window.CacheIndex?.REF;
        const currVid = currNormalized?.vid || window.CacheIndex?.USER;
        const sameVid = !!(refVid && currVid && refVid === currVid);
        
        // Fallback: areSameTrack() para validação técnica
        const sameTrack = areSameTrack(refNormalized, currNormalized);
        
        console.groupCollapsed('[SMART-VALIDATION] 🧠 Análise de Self-Compare (VID-aware)');
        console.log('📋 Análise completa:', {
            sameFileName,
            sameJobId,
            refVid,
            currVid,
            sameVid,
            sameTrack,
            decisao: (sameJobId || sameVid) 
                ? 'SELF-COMPARE REAL (jobId ou VID idêntico)' 
                : (sameFileName && !sameJobId && !sameVid) 
                    ? 'MESMO ARQUIVO, IDs DIFERENTES → OK (não é self-compare)' 
                    : 'ARQUIVOS DIFERENTES'
        });
        console.groupEnd();
        
        // Self-compare detectado se: jobId OU VID idênticos
        if (sameJobId || sameVid) {
            console.warn('[REF-GUARD] ⚠️ Self-compare REAL detectado — marcando flag mas CONTINUANDO renderização A/B.');
            isSelfCompare = true;
            
            // 🔥 Marcar no estado que é self-compare (sem interromper fluxo)
            if (!state.render) state.render = {};
            state.render.isSelfCompare = true;
            
            console.log('[REF-GUARD] 🔄 Self-compare confirmado:', {
                sameJobId: sameJobId ? refJobId : false,
                sameVid: sameVid ? refVid : false,
                note: 'Score será 100% mas renderização continua'
            });
        } else if (sameFileName && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] ✅ Mesmo arquivo mas IDs diferentes → Não é self-compare, continuando normalmente');
        } else if (sameTrack && !sameJobId && !sameVid) {
            console.log('[REF-GUARD] ⚠️ areSameTrack() detectou semelhança mas IDs são diferentes → Continuando normalmente');
        } else {
            console.log('[REF-GUARD] ✅ Validação passou - faixas são diferentes');
        }
        
        // ✅ REVALIDAÇÃO: Garantir que não é falso-positivo
        // Se chegou aqui com isSelfCompare mas VIDs são diferentes, corrigir
        if (isSelfCompare && refVid !== currVid) {
            console.warn('[REF-GUARD] ❎ Corrigido selfCompare falso-positivo (VIDs diferentes):', {
                refVid,
                currVid,
                refFile: refFileName,
                currFile: currFileName
            });
            isSelfCompare = false;
            if (state.render) state.render.isSelfCompare = false;
        }
        
        // 🐛 DEBUG A/B
        console.log('[DEBUG-A/B]', {
            ref: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            curr: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            same: areSameTrack(refNormalized, currNormalized),
        });
        
        // 🔍 AUDITORIA: Estado APÓS criar refNormalized e currNormalized
        console.groupCollapsed('[AUDITORIA_STATE_FLOW] ✅ DEPOIS refNormalized + currNormalized');
        console.log('⚙️ Contexto: Clones normalizados criados');
        console.log('📊 refNormalized (1ª faixa normalizada):', {
            fileName: refNormalized?.metadata?.fileName,
            jobId: refNormalized?.jobId,
            lufs: refNormalized?.technicalData?.lufsIntegrated,
            objectId: refNormalized
        });
        console.log('📊 currNormalized (2ª faixa normalizada):', {
            fileName: currNormalized?.metadata?.fileName,
            jobId: currNormalized?.jobId,
            lufs: currNormalized?.technicalData?.lufsIntegrated,
            objectId: currNormalized
        });
        console.log('⚠️ VERIFICAÇÃO DE ISOLAMENTO:');
        console.log('  refNormalized !== currNormalized?', refNormalized !== currNormalized);
        console.log('  refNormalized !== window.__FIRST_ANALYSIS_FROZEN__?', refNormalized !== window.__FIRST_ANALYSIS_FROZEN__);
        console.log('  currNormalized !== analysis?', currNormalized !== analysis);
        console.log('  refNormalized.metadata?.fileName:', refNormalized?.metadata?.fileName);
        console.log('  currNormalized.metadata?.fileName:', currNormalized?.metadata?.fileName);
        console.log('  🚨 SAME FILE?', refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName);
        
        // 🔴 VALIDAÇÃO CRÍTICA: Se os arquivos são iguais, ABORTAR imediatamente
        if (refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName) {
            console.error('🔴 [AUDITORIA_STATE_FLOW] ❌❌❌ CONTAMINAÇÃO CONFIRMADA ❌❌❌');
            console.error('🔴 refNormalized e currNormalized têm O MESMO ARQUIVO!');
            console.error('🔴 Isso significa que window.__FIRST_ANALYSIS_FROZEN__ foi contaminado!');
            console.error('🔴 Sistema está comparando a música consigo mesma!');
            console.table({
                'refNormalized.fileName': refNormalized?.metadata?.fileName,
                'refNormalized.jobId': refNormalized?.jobId,
                'currNormalized.fileName': currNormalized?.metadata?.fileName,
                'currNormalized.jobId': currNormalized?.jobId,
                'sameFile': refNormalized?.metadata?.fileName === currNormalized?.metadata?.fileName,
                'sameJobId': refNormalized?.jobId === currNormalized?.jobId
            });
        }
        console.groupEnd();
        
        // [REF-FLOW] Construindo métricas A/B
        // ✅ SEMÂNTICA CORRETA:
        // - refNormalized = 1ª faixa = SUA MÚSICA (atual) = userAnalysis
        // - currNormalized = 2ª faixa = REFERÊNCIA (alvo a alcançar) = referenceAnalysis
        
        // 🧊 PROTEÇÃO ANTICONTAMINAÇÃO: Só criar se ainda não existir
        if (!referenceComparisonMetrics) {
            console.log('[STATE-FIX] ✅ Criando referenceComparisonMetrics pela primeira vez');
            referenceComparisonMetrics = {
                // ESTRUTURA NOVA (CORRETA) COM DEEP CLONE:
                userTrack: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),        // 1ª faixa (sua música/atual)
                referenceTrack: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2ª faixa (referência/alvo)
                
                userTrackFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceTrackFull: JSON.parse(JSON.stringify(currNormalized || null)),
                
                // LEGADO: manter por compatibilidade (mapeamento correto)
                user: JSON.parse(JSON.stringify(refNormalized?.technicalData || {})),       // 1ª = sua música (atual)
                reference: JSON.parse(JSON.stringify(currNormalized?.technicalData || {})), // 2ª = referência (alvo)
                userFull: JSON.parse(JSON.stringify(refNormalized || null)),
                referenceFull: JSON.parse(JSON.stringify(currNormalized || null))
            };
        } else {
            console.warn('[STATE-FIX] ⚠️ referenceComparisonMetrics já inicializado, não sobrescrevendo');
            console.warn('[STATE-FIX]   Mantendo dados originais:', {
                userFile: referenceComparisonMetrics.userFull?.fileName || referenceComparisonMetrics.userFull?.metadata?.fileName,
                refFile: referenceComparisonMetrics.referenceFull?.fileName || referenceComparisonMetrics.referenceFull?.metadata?.fileName
            });
        }
        
        console.log('[REF-FLOW] ✅ ═══════════════════════════════════════');
        console.log('[REF-FLOW] ✅ Métricas A/B construídas corretamente:');
        console.log('[REF-FLOW] ✅   SUA MÚSICA (1ª):', refNormalized.metadata?.fileName);
        console.log('[REF-FLOW] ✅   LUFS:', referenceComparisonMetrics.userTrack?.lufsIntegrated);
        console.log('[REF-FLOW] ✅   REFERÊNCIA (2ª):', currNormalized.metadata?.fileName);
        console.log('[REF-FLOW] ✅   LUFS:', referenceComparisonMetrics.referenceTrack?.lufsIntegrated);
        console.log('[REF-FLOW] ✅   Tabela: ESQUERDA=sua música, DIREITA=referência');
        console.log('[REF-FLOW] ✅ ═══════════════════════════════════════');
        
        console.log('[ASSERT] reference mode', {
            userIsFirst: !!(state?.userAnalysis || refNormalized),
            refIsSecond: !!(state?.referenceAnalysis || currNormalized)
        });
        
        // 🧩 PROTEÇÃO CONTRA DADOS INCOMPLETOS
        if (!currNormalized?.technicalData?.spectral_balance) {
            console.warn("⚠️ [REF-FIX] spectral_balance ausente em currNormalized, reconstruindo...");
            if (currNormalized?.bands) {
                currNormalized.technicalData.spectral_balance = currNormalized.bands;
            } else if (currNormalized?.technicalData?.bandEnergies) {
                currNormalized.technicalData.spectral_balance = currNormalized.technicalData.bandEnergies;
            } else {
                console.warn("⚠️ [REF-FIX] Criando estrutura vazia para currNormalized");
                if (!currNormalized.technicalData) currNormalized.technicalData = {};
                currNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }

        if (!refNormalized?.technicalData?.spectral_balance) {
            console.warn("⚠️ [REF-FIX] spectral_balance ausente em refNormalized, reconstruindo...");
            if (refNormalized?.bands) {
                refNormalized.technicalData.spectral_balance = refNormalized.bands;
            } else if (refNormalized?.technicalData?.bandEnergies) {
                refNormalized.technicalData.spectral_balance = refNormalized.technicalData.bandEnergies;
            } else {
                console.warn("⚠️ [REF-FIX] Criando estrutura vazia para refNormalized");
                if (!refNormalized.technicalData) refNormalized.technicalData = {};
                refNormalized.technicalData.spectral_balance = {
                    sub: 0, bass: 0, low_mid: 0, mid: 0,
                    high_mid: 0, presence: 0, air: 0
                };
            }
        }
        
        // 🧩 LOG DE AUDITORIA DETALHADO
        console.log("[ASSERT_REF_FLOW ✅]", {
            userTrack: refNormalized?.metadata?.fileName || "primeira faixa",
            referenceTrack: currNormalized?.metadata?.fileName || "segunda faixa",
            userBands: Object.keys(refNormalized?.technicalData?.spectral_balance || {}),
            referenceBands: Object.keys(currNormalized?.technicalData?.spectral_balance || {})
        });
        
        // 🧩 PROTEÇÃO NO displayModalResults: Validação de referenceTrack
        if (!currNormalized?.metadata?.fileName && !currNormalized?.fileName) {
            console.warn("⚠️ [DISPLAY_MODAL_FIX] Reference track com dados incompletos — continuando com fallback...");
            // ❌ REMOVIDO: return que bloqueava renderização
            // Agora continua o fluxo com dados disponíveis, mesmo que incompletos
        }
        
        // 🧩 CORREÇÃO #6: Chamada ÚNICA de renderização (remover duplicação)
        // SEMÂNTICA CORRETA:
        // - userAnalysis = 1ª faixa (SUA MÚSICA - atual)
        // - referenceAnalysis = 2ª faixa (REFERÊNCIA - alvo)
        
        // 🔍 [A/B-DEBUG] Dados ANTES de renderReferenceComparisons
        console.log("[A/B-DEBUG] ═══════════════════════════════════════");
        console.log("[A/B-DEBUG] Dados antes do SAFE_RENDER_REF:");
        console.log("[A/B-DEBUG] refNormalized (1ª faixa - SUA MÚSICA):", {
            fileName: refNormalized?.fileName || refNormalized?.metadata?.fileName,
            hasBands: !!refNormalized?.bands,
            hasSpectralBalance: !!refNormalized?.technicalData?.spectral_balance,
            bandsKeys: refNormalized?.bands ? Object.keys(refNormalized.bands) : [],
            spectralBalanceKeys: refNormalized?.technicalData?.spectral_balance ? Object.keys(refNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] currNormalized (2ª faixa - REFERÊNCIA):", {
            fileName: currNormalized?.fileName || currNormalized?.metadata?.fileName,
            hasBands: !!currNormalized?.bands,
            hasSpectralBalance: !!currNormalized?.technicalData?.spectral_balance,
            bandsKeys: currNormalized?.bands ? Object.keys(currNormalized.bands) : [],
            spectralBalanceKeys: currNormalized?.technicalData?.spectral_balance ? Object.keys(currNormalized.technicalData.spectral_balance) : []
        });
        console.log("[A/B-DEBUG] ═══════════════════════════════════════");
        
        // ✅ GARANTIR que bands esteja no nível correto (userAnalysis.bands e referenceAnalysis.bands)
        if (!refNormalized.bands && refNormalized?.technicalData?.spectral_balance) {
            refNormalized.bands = refNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] ✅ Bandas copiadas de technicalData.spectral_balance para bands (userAnalysis)");
        }
        
        if (!currNormalized.bands && currNormalized?.technicalData?.spectral_balance) {
            currNormalized.bands = currNormalized.technicalData.spectral_balance;
            console.log("[A/B-FIX] ✅ Bandas copiadas de technicalData.spectral_balance para bands (referenceAnalysis)");
        }
        
        console.log("[A/B-DEBUG] ✅ Bandas finais:", {
            userBandsLength: refNormalized?.bands ? Object.keys(refNormalized.bands).length : 0,
            referenceBandsLength: currNormalized?.bands ? Object.keys(currNormalized.bands).length : 0
        });
        
        // 🧊 PROTEÇÃO ANTICONTAMINAÇÃO: Deep clone antes de renderizar
        console.log('[STATE-FIX] 🔒 Criando frozen clones para renderReferenceComparisons');
        const frozenRef = JSON.parse(JSON.stringify(refNormalized));
        const frozenCurr = JSON.parse(JSON.stringify(currNormalized));
        
        // 🔍 AUDITORIA DE INTEGRIDADE
        console.log('[STATE-INTEGRITY]', {
            refJobId: frozenRef.jobId,
            currJobId: frozenCurr.jobId,
            refFile: frozenRef.fileName || frozenRef.metadata?.fileName,
            currFile: frozenCurr.fileName || frozenCurr.metadata?.fileName,
            sameJob: frozenRef.jobId === frozenCurr.jobId,
            sameFile: (frozenRef.fileName || frozenRef.metadata?.fileName) === (frozenCurr.fileName || frozenCurr.metadata?.fileName),
            areIndependent: frozenRef !== frozenCurr,
            metadataIndependent: frozenRef.metadata !== frozenCurr.metadata
        });
        
        // 🎯 VALIDAÇÃO CRÍTICA: Garantir que jobIds são DIFERENTES antes de renderizar
        console.group('🔍 [DISPLAY-MODAL] Validação de JobIds antes de renderizar');
        console.log('   - frozenRef.jobId:', frozenRef.jobId);
        console.log('   - frozenCurr.jobId:', frozenCurr.jobId);
        console.log('   - São diferentes?', frozenRef.jobId !== frozenCurr.jobId);
        
        // Validar com getCorrectJobId() também
        const expectedCurrentJobId = getCorrectJobId('current');
        const expectedReferenceJobId = getCorrectJobId('reference');
        console.log('   - getCorrectJobId("current"):', expectedCurrentJobId);
        console.log('   - getCorrectJobId("reference"):', expectedReferenceJobId);
        console.log('   - Esses também são diferentes?', expectedCurrentJobId !== expectedReferenceJobId);
        
        if (frozenRef.jobId === frozenCurr.jobId) {
            console.error('❌ [DISPLAY-MODAL] ERRO: frozenRef e frozenCurr têm o MESMO jobId!');
            console.error('   Isso significa que os dados estão contaminados!');
            console.trace();
            console.groupEnd();
            
            // Tentar recuperar usando getCorrectJobId
            console.warn('🔄 [DISPLAY-MODAL] Tentando recuperar dados corretos...');
            // Por enquanto, ABORTAR para evitar renderização incorreta
            alert('ERRO: Não foi possível carregar a comparação. Os dados estão contaminados. Recarregue a página.');
            return;
        }
        
        console.log('✅ [DISPLAY-MODAL] JobIds são diferentes - prosseguindo com renderização');
        console.groupEnd();
        
        // ========================================
        // 🧠 USAR DADOS DO STORE SE DISPONÍVEL
        // ========================================
        let renderUserAnalysis, renderRefAnalysis;
        
        if (analysis?._useStoreData && analysis?._comparisonPair) {
            console.log('🎯 [RENDER-STORE] Usando dados do store isolado para renderização');
            renderUserAnalysis = frozenRef;   // Já é clone de comparisonPair.ref
            renderRefAnalysis = frozenCurr;   // Já é clone de comparisonPair.curr
        } else {
            console.log('⚠️ [RENDER-LEGACY] Usando dados legados para renderização');
            renderUserAnalysis = frozenRef;
            renderRefAnalysis = frozenCurr;
        }
        
        // 🎯 [METRICS-DEBUG] LOG CRÍTICO DAS MÉTRICAS ANTES DE RENDERIZAR
        console.group('🎯 [METRICS-DEBUG] Métricas ANTES de renderReferenceComparisons');
        console.table({
            'User LUFS': renderUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': renderRefAnalysis?.technicalData?.lufsIntegrated,
            'User DR': renderUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': renderRefAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': renderUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': renderRefAnalysis?.technicalData?.truePeakDbtp,
            'User JobId': renderUserAnalysis?.jobId,
            'Ref JobId': renderRefAnalysis?.jobId,
            'User File': renderUserAnalysis?.fileName || renderUserAnalysis?.metadata?.fileName,
            'Ref File': renderRefAnalysis?.fileName || renderRefAnalysis?.metadata?.fileName
        });
        console.log('✅ [METRICS-DEBUG] Se os valores acima forem IGUAIS, há contaminação!');
        console.groupEnd();
        
        // 🔥 NOVO: Construir tabela A vs B via buildComparisonRows em reference mode
        console.log('[REFERENCE-MODE] 🔨 Construindo tabela de comparação A vs B');
        
        // 🎯 CORREÇÃO: Usar extractMetrics para garantir acesso robusto às métricas
        const userMetrics = extractMetrics(renderUserAnalysis) || renderUserAnalysis;
        const refMetrics = extractMetrics(renderRefAnalysis) || renderRefAnalysis;
        
        console.log('[REFERENCE-MODE] 📊 Métricas extraídas:', {
            userMetricsKeys: Object.keys(userMetrics),
            refMetricsKeys: Object.keys(refMetrics)
        });
        
        const comparisonRows = buildComparisonRows(userMetrics, refMetrics);
        
        if (comparisonRows && comparisonRows.length > 0) {
            console.log('[REFERENCE-MODE] ✅ Tabela construída com', comparisonRows.length, 'linhas');
            console.table(comparisonRows);
            
            // Anexar ao analysis para renderReferenceComparisons usar
            renderUserAnalysis.referenceComparisonRows = comparisonRows;
            renderRefAnalysis.referenceComparisonRows = comparisonRows;
            
            // Também disponibilizar globalmente se necessário
            window.__REFERENCE_COMPARISON_ROWS__ = comparisonRows;
        } else {
            console.warn('[REFERENCE-MODE] ⚠️ buildComparisonRows retornou vazio');
        }
        
        // 🎯 Usar helper getCompareMode (NUNCA ctx.mode como fallback)
        const compareMode = getCompareMode(analysis);
        
        renderReferenceComparisons({
            mode: 'reference',
            compareMode: compareMode,  // ✅ Passar explicitamente
            userAnalysis: renderUserAnalysis,        // 1ª faixa (sua música) - CLONE INDEPENDENTE
            referenceAnalysis: renderRefAnalysis,    // 2ª faixa (referência) - CLONE INDEPENDENTE
            analysis: {
                userAnalysis: renderUserAnalysis,
                referenceAnalysis: renderRefAnalysis
            },
            _useStoreData: analysis?._useStoreData  // Propagar flag
        });
        
        // ❌ REMOVIDO: renderTrackComparisonTable() - causava duplicação
        // renderReferenceComparisons() já renderiza tudo
        console.log('✅ [REFERENCE-RENDER] Renderização única completa (sem duplicação)');
        
        // Atualizar window.latestAnalysis para compatibilidade com IA e PDF
        window.latestAnalysis = {
            mode: "comparison",
            reference: window.referenceAnalysisData,
            current: analysis,
            scores: analysis.scores || {}
        };
        
        // ✅ CORREÇÃO CRÍTICA: NÃO retornar aqui!
        // Continuar para renderizar cards, scores e sugestões
        console.log('[AUDIT-FIX] ✅ Continuando renderização completa (cards, scores, sugestões)');
        
        // 🎯 GARANTIR que sugestões de IA sejam chamadas também no modo reference
        console.log('[AUDIT-FIX] 🤖 Iniciando renderização de sugestões de IA no modo reference');
        
        // ✅ CORREÇÃO: Garantir que analysisForSuggestions inclua suggestions completas
        const analysisForSuggestions = {
            ...(refNormalized || analysis),
            // ✅ Preservar suggestions da análise (pode vir do backend ou frontend)
            suggestions: 
                (refNormalized || analysis)?.suggestions || 
                (refNormalized || analysis)?.userAnalysis?.suggestions || 
                analysis?.suggestions ||
                [],
            mode: 'reference'
        };
        
        console.log('[SUG-AUDIT] reference deltas ready:', !!analysis.referenceComparison);
        console.log('[AUDIT-FIX] 📊 analysisForSuggestions preparado:', {
            hasSuggestions: !!analysisForSuggestions.suggestions,
            suggestionsLength: analysisForSuggestions.suggestions?.length || 0,
            mode: analysisForSuggestions.mode,
            hasReferenceComparison: !!analysisForSuggestions.referenceComparison
        });
        
        // 🔥 Chamada ao displayModalResults no fluxo normal (não self-compare)
        if (typeof AISuggestionsIntegration?.displayModalResults === 'function') {
            AISuggestionsIntegration.displayModalResults(currNormalized);
        }
        
        // Chamar sugestões de IA após pequeno delay para garantir que DOM está pronto
        setTimeout(() => {
            if (window.aiUIController) {
                // 🔍 PASSO 1: LOG CRÍTICO ANTES de checkForAISuggestions
                console.group('🔍 [PRE-AI-SUGGESTIONS] Estado ANTES de checkForAISuggestions');
                console.log('   - currentJobId (segunda música):', window.__CURRENT_JOB_ID__);
                console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                console.log('   - analysisForSuggestions:', {
                    jobId: analysisForSuggestions?.jobId,
                    fileName: analysisForSuggestions?.fileName || analysisForSuggestions?.metadata?.fileName,
                    hasSuggestions: !!analysisForSuggestions?.suggestions,
                    suggestionsLength: analysisForSuggestions?.suggestions?.length || 0
                });
                
                // 🔍 [AUDITORIA_DOM] Verificar estado do DOM de sugestões
                const aiSection = document.getElementById('aiSuggestionsExpanded');
                const aiContent = document.getElementById('aiExpandedGrid');
                const existingSuggestions = aiContent?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                
                console.log('   [AUDITORIA_DOM] Estado ANTES:', {
                    aiSection: !!aiSection,
                    aiSectionVisible: aiSection?.style?.display !== 'none',
                    aiContent: !!aiContent,
                    suggestionsExistentes: existingSuggestions
                });
                console.groupEnd();
                
                console.log('[AUDIT-FIX] ✅ Chamando aiUIController.checkForAISuggestions');
                console.log('[AUDIT-FIX] Passando analysisForSuggestions com', analysisForSuggestions?.suggestions?.length || 0, 'sugestões');
                window.aiUIController.checkForAISuggestions(analysisForSuggestions, true);
                
                // 🔍 PASSO 2: LOG CRÍTICO DEPOIS de checkForAISuggestions
                setTimeout(() => {
                    console.group('🔍 [POST-AI-SUGGESTIONS] Estado DEPOIS de checkForAISuggestions');
                    console.log('   - currentJobId:', window.__CURRENT_JOB_ID__);
                    console.log('   - referenceJobId:', window.__REFERENCE_JOB_ID__);
                    console.log('   - localStorage.referenceJobId:', localStorage.getItem('referenceJobId'));
                    console.log('   - MUDOU?', window.__CURRENT_JOB_ID__ === window.__REFERENCE_JOB_ID__ ? '❌ CONTAMINADO!' : '✅ Intacto');
                    
                    // 🔍 [AUDITORIA_DOM] Verificar estado do DOM de sugestões DEPOIS
                    const aiSectionAfter = document.getElementById('aiSuggestionsExpanded');
                    const aiContentAfter = document.getElementById('aiExpandedGrid');
                    const cardsAfter = aiContentAfter?.querySelectorAll('.ai-suggestion-card')?.length || 0;
                    
                    console.log('   [AUDITORIA_DOM] Estado DEPOIS:', {
                        aiSection: !!aiSectionAfter,
                        aiSectionVisible: aiSectionAfter?.style?.display !== 'none',
                        aiContent: !!aiContentAfter,
                        cards: cardsAfter
                    });
                    
                    if (cardsAfter === 0) {
                        console.error('   [AUDITORIA_DOM] ❌ NENHUM CARD FOI RENDERIZADO!');
                        console.error('   [AUDITORIA_DOM] Possíveis causas:');
                        console.error('   [AUDITORIA_DOM]   1. analysisForSuggestions não tem suggestions[]');
                        console.error('   [AUDITORIA_DOM]   2. Função checkForAISuggestions retornou cedo');
                        console.error('   [AUDITORIA_DOM]   3. Erro no renderCompactPreview()');
                    } else {
                        console.log('   [AUDITORIA_DOM] ✅', cardsAfter, 'cards renderizados com sucesso!');
                    }
                    console.groupEnd();
                }, 100); // Delay pequeno para dar tempo de renderizar
            } else if (window.forceShowAISuggestions) {
                console.log('[AUDIT-FIX] ✅ Chamando forceShowAISuggestions');
                window.forceShowAISuggestions(analysisForSuggestions);
            } else {
                console.warn('[AUDIT-FIX] ⚠️ Nenhuma função de IA disponível');
            }
        }, 800);
        
        // ⚠️ IMPORTANTE: Não usar return aqui - continuar fluxo normal
        // return; // ← REMOVIDO
    }
    else {
        // 🔴 DIAGNÓSTICO: Por que NÃO entrou no bloco A/B?
        console.error('🔴🔴🔴 [DIAGNÓSTICO-AB] NÃO ENTROU NO BLOCO A/B!');
        console.error('🔴 [DIAGNÓSTICO-AB] Motivo:');
        if (mode !== 'reference') {
            console.error('🔴 [DIAGNÓSTICO-AB]   ❌ mode !== "reference" (mode =', mode, ')');
        }
        if (!isSecondTrack) {
            console.error('🔴 [DIAGNÓSTICO-AB]   ❌ isSecondTrack = false');
            console.error('🔴 [DIAGNÓSTICO-AB]   window.__REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
        }
        console.error('🔴 [DIAGNÓSTICO-AB] Sistema VAI RENDERIZAR EM MODO SINGLE-TRACK!');
        console.error('🔴🔴🔴 [DIAGNÓSTICO-AB] ════════════════════════════════════');
    }
    
    // 🎯 CORREÇÃO: Definir modo baseado no contexto real da análise
    // NÃO forçar genre se for primeira faixa de referência
    if (mode === 'reference' && !isSecondTrack) {
        // Primeira faixa em modo reference - manter modo reference mas não renderizar ainda
        state.render.mode = 'reference';
        console.log('✅ [REFERENCE-FIRST] Primeira faixa de referência - aguardando segunda');
    } else if (mode !== 'reference' || (mode === 'reference' && !window.referenceAnalysisData)) {
        // 🔐 PARTE 3.3: Trava do modo Reference — NÃO forçar genre se estamos em fluxo de referência
        const isReferenceFlowLocked =
            (state?.reference?.isSecondTrack === true) ||
            (!!window.__REFERENCE_JOB_ID__ && state?.render?.mode === "reference");

        if (!isReferenceFlowLocked) {
            // Modo genre genuíno
            state.render.mode = 'genre';
            console.log('✅ [GENRE-MODE] Modo definido como GENRE no estado');
            
            // Limpar dados de referência para evitar contaminação APENAS em modo genre
            if (state.reference) {
                state.reference.isSecondTrack = false;
                state.reference.analysis = null;
            }
        } else {
            console.log('🔒 [REF-LOCK] Modo reference travado — genre forçado bloqueado');
        }
    }
    window.__soundyState = state;
    
    // 🔒 UI GATE: Verificação final antes de renderizar
    const analysisRunId = analysis?.runId || analysis?.metadata?.runId;
    const currentRunId = window.__CURRENT_ANALYSIS_RUN_ID__;
    
    if (analysisRunId && currentRunId && analysisRunId !== currentRunId) {
        console.warn('[AUDITORIA_CONDICAO] ⚠️ Retorno antecipado: analysisRunId !== currentRunId', { analysisRunId, currentRunId, mode: analysis?.mode });
        console.warn(`🚫 [UI_GATE] displayModalResults cancelado - análise obsoleta (análise: ${analysisRunId}, atual: ${currentRunId})`);
        return;
    }
    
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const technicalData = document.getElementById('modalTechnicalData');
    
    if (!results || !technicalData) {
        console.warn('[AUDITORIA_CONDICAO] ⚠️ Retorno antecipado: !results || !technicalData', { hasResults: !!results, hasTechnicalData: !!technicalData, mode: analysis?.mode });
        console.error('❌ Elementos de resultado não encontrados');
        return;
    }
    
    console.log('[AUDIT-FLOW-CHECK] ✅ Todos os gates passaram - continuando para renderização');
    
    // 🔥 CORREÇÃO CRÍTICA: Abrir modal ANTES de renderizar modo gênero
    // O container #referenceComparisons só existe DEPOIS do modal ser aberto
    if (uploadArea) uploadArea.style.display = 'none';
    if (loading) loading.style.display = 'none';
    results.style.display = 'block';
    console.log('[MODAL-OPEN] ✅ Modal aberto - results.style.display = "block"');
    
    // 🎵 RENDERIZAR BLOCO DE IDENTIFICAÇÃO DA MÚSICA (APENAS MODO GÊNERO)
    try {
        const musicIdContainer = document.getElementById('musicIdentificationBlock');
        const currentMode = analysis?.mode || window.currentAnalysisMode || 'genre';
        
        // ✅ CONDICIONAL: Renderizar APENAS em modo gênero
        if (musicIdContainer) {
            if (currentMode === 'genre') {
                const musicIdHTML = renderMusicIdentificationBlock(analysis);
                musicIdContainer.innerHTML = musicIdHTML;
                musicIdContainer.style.display = 'block';
                console.log('[MUSIC-ID] ✅ Bloco de identificação renderizado (modo gênero)');
            } else {
                // 🚫 Modo referência: OCULTAR bloco (nomes já aparecem no header A/B)
                musicIdContainer.innerHTML = '';
                musicIdContainer.style.display = 'none';
                console.log('[MUSIC-ID] ⏭️ Bloco ocultado (modo referência - nomes já no header A/B)');
            }
        } else {
            console.warn('[MUSIC-ID] ⚠️ Container #musicIdentificationBlock não encontrado no DOM');
        }
    } catch (error) {
        console.error('[MUSIC-ID] ❌ Erro ao renderizar bloco de identificação:', error);
    }
    
    // 📋 PLANO DE CORREÇÃO: Registrar event listener APÓS modal ser renderizado
    (function registerCorrectionPlanListener() {
        const planBtn = document.getElementById('btnGenerateCorrectionPlan');
        console.log('[CORRECTION-PLAN] 🔍 Buscando botão #btnGenerateCorrectionPlan:', planBtn);
        
        if (planBtn) {
            // Remover listener anterior se existir (evita duplicatas)
            planBtn.removeEventListener('click', window.handleGenerateCorrectionPlan);
            
            // Registrar novo listener
            planBtn.addEventListener('click', function(e) {
                console.log('[CORRECTION-PLAN] 🖱️ CLICK DETECTADO!');
                e.preventDefault();
                if (typeof window.handleGenerateCorrectionPlan === 'function') {
                    window.handleGenerateCorrectionPlan();
                } else {
                    console.error('[CORRECTION-PLAN] ❌ handleGenerateCorrectionPlan não está definida!');
                    alert('Erro: função não encontrada. Recarregue a página.');
                }
            });
            
            planBtn.dataset.listenerAttached = 'true';
            console.log('[CORRECTION-PLAN] ✅ Event listener registrado com sucesso!');
        } else {
            console.warn('[CORRECTION-PLAN] ⚠️ Botão não encontrado no DOM');
        }
    })();
    
    // 🎯 FIX: Ocultar botão "Pedir ajuda à IA" e texto de ajuda NO MODO REFERÊNCIA
    const currentModeForUI = analysis?.mode || window.currentAnalysisMode || 'genre';
    const btnAskAI = document.getElementById('btnAskAI');
    const aiHelperText = document.getElementById('aiHelperText');
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    
    if (currentModeForUI === 'reference') {
        console.log('[REFERENCE-UI] 🔒 Modo referência - ocultando botão "Pedir ajuda à IA", "Plano de Correção" e texto de ajuda');
        if (btnAskAI) btnAskAI.style.display = 'none';
        if (aiHelperText) aiHelperText.style.display = 'none';
        if (btnCorrectionPlan) btnCorrectionPlan.style.display = 'none';
    } else {
        // 🎯 Garantir visibilidade nos outros modos
        console.log('[GENRE-UI] ✅ Modo gênero - exibindo botão "Pedir ajuda à IA", "Plano de Correção" e texto de ajuda');
        if (btnAskAI) btnAskAI.style.display = '';
        if (aiHelperText) aiHelperText.style.display = '';
        if (btnCorrectionPlan) btnCorrectionPlan.style.display = '';
    }
    
    // 🎯 HOOK: Aplicar máscaras de Modo Reduzido se necessário
    if (window.__REDUCED_MODE_ACTIVE__ && window.__REDUCED_MODE_ANALYSIS__) {
        console.log('[REDUCED-MODE] 🔧 Aplicando sistema de mascaramento dinâmico...');
        
        // Aguardar um frame para garantir que o DOM foi atualizado
        requestAnimationFrame(() => {
            renderReducedModeAdvanced(window.__REDUCED_MODE_ANALYSIS__);
        });
    }
    
    // 🔧 CORREÇÃO CRÍTICA: Normalizar dados do backend para compatibilidade com front-end
    // ✅ PATCH: Normalização redundante REMOVIDA - dados já normalizados em handleModalFileSelection
    if (analysis && typeof analysis === 'object') {
        console.log('[AUDITORIA-RMS-LUFS] Verificando estado dos dados (já normalizados):', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.rms': analysis?.technicalData?.rms,
            'energy.rms': analysis?.energy?.rms,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'loudness.integrated': analysis?.loudness?.integrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
        });
        
        // 🚫 PATCH: Normalização redundante REMOVIDA para evitar contaminação
        // ❌ analysis = normalizeBackendAnalysisData(analysis);
        console.log('[NORMALIZE-SKIP] ✅ Evitando re-normalização destrutiva - dados já normalizados em handleModalFileSelection');
        console.log('[NORMALIZE-SKIP] ✅ Preservando integridade de referenceComparisonMetrics');
        
        console.log('[AUDITORIA-RMS-LUFS] Dados preservados:', {
            'technicalData.avgLoudness (RMS)': analysis?.technicalData?.avgLoudness,
            'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
            'technicalData.crestFactor': analysis?.technicalData?.crestFactor,
            'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
            'loudness.integrated': analysis?.loudness?.integrated,
            'dynamics.crest': analysis?.dynamics?.crest,
            'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp,
            'energy.rms': analysis?.energy?.rms
        });
        console.log('📊 [DEBUG] Dados preservados para exibição:', analysis);
        
        // 🎯 RECALCULAR hasReferenceComparisonMetrics APÓS NORMALIZAÇÃO
        const state = window.__soundyState || {};
        state.hasReferenceComparisonMetrics = computeHasReferenceComparisonMetrics(analysis);
        window.__soundyState = state;
        console.log('[ASSERT] hasReferenceComparisonMetrics recalculado após normalização:', state.hasReferenceComparisonMetrics);
        
        // 🛡️ PASSO 2: GARANTIR analysis.referenceComparison EXISTE
        if (!analysis.referenceComparison) {
            analysis.referenceComparison = {};
            console.log('🛡️ [PASSO 2] Criado analysis.referenceComparison vazio');
        }
        
        // 🎯 CORREÇÃO CRÍTICA: Preencher targets de GÊNERO completos
        const mode = analysis?.mode || currentAnalysisMode || 'genre';
        const isGenreMode = mode === 'genre';
        
        if (isGenreMode) {
            // Obter targets de gênero de múltiplas fontes
            const genreTargets = window.__activeRefData || 
                                window.PROD_AI_REF_DATA?.[analysis.genre] || 
                                window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE] || 
                                {};
            
            console.log('🎯 [GENRE-TARGETS-MERGE] Mesclando targets de gênero:', {
                hasGenreTargets: !!genreTargets,
                hasBands: !!(genreTargets.bands),
                source: window.__activeRefData ? '__activeRefData' : 'PROD_AI_REF_DATA'
            });
            
            if (genreTargets && Object.keys(genreTargets).length > 0) {
                // Fonte primária: referenceComparison ou referenceComparisonMetrics
                const src = genreTargets.referenceComparison || 
                           genreTargets.referenceComparisonMetrics || 
                           genreTargets;
                
                // ✅ CRÍTICO: Mesclar TODOS os targets incluindo bandas
                if (src.lufs_target != null)   analysis.referenceComparison.lufs_target   = src.lufs_target;
                if (src.tp_target != null)     analysis.referenceComparison.tp_target     = src.tp_target;
                if (src.dr_target != null)     analysis.referenceComparison.dr_target     = src.dr_target;
                if (src.lra_target != null)    analysis.referenceComparison.lra_target    = src.lra_target;
                if (src.stereo_target != null) analysis.referenceComparison.stereo_target = src.stereo_target;
                
                // ✅ CRÍTICO: Incluir BANDAS de gênero
                if (src.bands && Object.keys(src.bands).length > 0) {
                    analysis.referenceComparison.bands = src.bands;
                    console.log('✅ [GENRE-BANDS-MERGED] Bandas de gênero incluídas:', Object.keys(src.bands));
                }
                
                // Marcar como targets de gênero
                analysis.referenceComparison._isGenreMode = true;
                analysis.referenceComparison._genreTargetsLoaded = true;
            } else {
                console.warn('⚠️ [GENRE-TARGETS-MERGE] Targets de gênero não encontrados, usando fallback');
                // Fallback com valores padrão
                if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = -14;
                if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = -1;
                if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = 8;
                if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = 6;
                if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = 0.1;
            }
        } else {
            // Modo referência: usar fallback simples
            const genreTargets = __activeRefData || {};
            if (!analysis.referenceComparison.lufs_target)   analysis.referenceComparison.lufs_target   = genreTargets.lufs_target ?? -14;
            if (!analysis.referenceComparison.tp_target)     analysis.referenceComparison.tp_target     = genreTargets.true_peak_target ?? -1;
            if (!analysis.referenceComparison.dr_target)     analysis.referenceComparison.dr_target     = genreTargets.dr_target ?? 8;
            if (!analysis.referenceComparison.lra_target)    analysis.referenceComparison.lra_target    = genreTargets.lra_target ?? 6;
            if (!analysis.referenceComparison.stereo_target) analysis.referenceComparison.stereo_target = genreTargets.stereo_target ?? 0.1;
        }
        
        console.log('✅ [PASSO 2] analysis.referenceComparison garantido:', {
            hasBands: !!analysis.referenceComparison.bands,
            bandsCount: analysis.referenceComparison.bands ? Object.keys(analysis.referenceComparison.bands).length : 0,
            isGenreMode: analysis.referenceComparison._isGenreMode,
            targets: {
                lufs: analysis.referenceComparison.lufs_target,
                tp: analysis.referenceComparison.tp_target,
                dr: analysis.referenceComparison.dr_target
            }
        });
    }
    
    /* =========[ BLOCO: SCORES A/B – substitui 4888–5050 ]========= */

    /** Utilitários robustos (não colidem com nomes existentes) */
    const __EPS = 1e-3;
    const __DB_EPS = 0.5; // ~0.5 dB para "iguais"
    const __MIN_BANDS = 7;

    function __num(v){ return typeof v === 'number' && isFinite(v); }
    function __ae(a,b,eps=__EPS){ return __num(a) && __num(b) && Math.abs(a-b) <= eps; }
    function __keys(o){ return o ? Object.keys(o) : []; }

    function __getBandsSafe(from) {
      // aceita objetos tipo analysis, referenceFull, technicalData.spectral_balance etc.
      if (!from) return null;

      // 1) caminhos mais prováveis
      const td = from.technicalData || from.technical_data || null;
      if (td && td.spectral_balance) return td.spectral_balance;
      if (from.metrics && from.metrics.bands) return from.metrics.bands;
      if (from.bands) return from.bands;

      // 2) objetos já no formato bandas
      const maybeBands = (from.sub || from.lowMid || from.low_mid) ? from : null;
      if (maybeBands) return maybeBands;

      return null;
    }

    function __normalizeBandKeys(b) {
      if (!b) return null;
      // normaliza low_mid->lowMid, high_mid->highMid etc.
      const map = {
        sub: 'sub', bass: 'bass',
        low_mid: 'lowMid', lowmid: 'lowMid', lowMid: 'lowMid',
        mid: 'mid',
        high_mid: 'highMid', highmid: 'highMid', highMid: 'highMid',
        presence: 'presence', air: 'air',
        total: 'totalPercentage', total_percentage: 'totalPercentage', totalPercentage: 'totalPercentage',
        _status: '_status'
      };
      const out = {};
      for (const k of Object.keys(b)) {
        const nk = map[k] || k;
        out[nk] = b[k];
      }
      return out;
    }

    function __bandsAreMeaningful(bands) {
      if (!bands) return false;
      const k = __keys(bands).filter(k => ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (k.length < __MIN_BANDS) return false;
      // precisa ter variação real (evita vetor todo zero)
      const vals = k.map(k => bands[k]).filter(__num);
      if (vals.length < __MIN_BANDS) return false;
      const max = Math.max(...vals), min = Math.min(...vals);
      return isFinite(max) && isFinite(min) && (Math.abs(max - min) > 0.2); // >0.2 dB de amplitude mínima
    }

    function __bandsSimilar(a, b, epsDb = __DB_EPS) {
      if (!a || !b) return false;
      const ak = __keys(a), bk = __keys(b);
      const common = ak.filter(k => bk.includes(k) && ['sub','bass','lowMid','mid','highMid','presence','air'].includes(k));
      if (common.length < __MIN_BANDS) return false;
      let equal = 0;
      for (const k of common) {
        if (__num(a[k]) && __num(b[k]) && Math.abs(a[k] - b[k]) <= epsDb) equal++;
      }
      return equal >= __MIN_BANDS; // praticamente iguais
    }

    function __tracksLookSame(userTd, refTd, userMd, refMd, userBands, refBands) {
      // ========================================
      // 🔧 CORREÇÃO: Detecção segura de self-compare usando jobId e VID
      // ========================================
      // Recuperar objetos completos para acessar jobId e vid
      const userFull = referenceComparisonMetrics?.userFull || {};
      const refFull = referenceComparisonMetrics?.referenceFull || {};
      
      // Critério 1: jobId idêntico (mais confiável)
      const sameJobId = !!(userFull?.jobId && refFull?.jobId && userFull.jobId === refFull.jobId);
      
      // Critério 2: Virtual ID idêntico (detecta mesmo jobId::ROLE)
      const sameVid = !!(userFull?.vid && refFull?.vid && userFull.vid === refFull.vid);
      
      // Critério 3: Fallback - fileName idêntico APENAS se não há jobId em nenhum dos dois
      const sameName = (
        !userFull?.jobId && 
        !refFull?.jobId && 
        !!userMd?.fileName && 
        !!refMd?.fileName && 
        userMd.fileName === refMd.fileName
      );
      
      // Critérios técnicos (mantidos para validação adicional)
      const sameLufs = __ae(userTd?.lufsIntegrated, refTd?.lufsIntegrated, 0.05);
      const sameTp   = __ae(userTd?.truePeakDbtp,  refTd?.truePeakDbtp,  0.05);
      const sameDr   = __ae(userTd?.dynamicRange,  refTd?.dynamicRange,  0.1);
      const sameCent = __ae(userTd?.spectralCentroidHz, refTd?.spectralCentroidHz, 5);
      const sameBands = __bandsSimilar(userBands, refBands);
      
      // Self-compare detectado se:
      // 1. jobId idêntico OU
      // 2. VID idêntico OU
      // 3. Sem jobId em ambos E fileName idêntico OU
      // 4. Todas as métricas técnicas idênticas E bands similares
      const isSelfCompare = sameJobId || sameVid || sameName || (sameLufs && sameTp && sameDr && sameCent && sameBands);
      
      // Log de auditoria
      console.log("[COMPARE-FLAG] selfCompare:", isSelfCompare, {
        userJobId: userFull?.jobId || 'N/A',
        refJobId: refFull?.jobId || 'N/A',
        sameJobId,
        userVid: userFull?.vid || window.CacheIndex?.USER || 'N/A',
        refVid: refFull?.vid || window.CacheIndex?.REF || 'N/A',
        sameVid,
        userFile: userMd?.fileName || 'N/A',
        refFile: refMd?.fileName || 'N/A',
        sameName,
        technicalMatch: sameLufs && sameTp && sameDr && sameCent && sameBands,
        criteria: {
          sameJobId,
          sameVid,
          sameName,
          sameLufs,
          sameTp,
          sameDr,
          sameCent,
          sameBands
        }
      });
      
      return isSelfCompare;
    }

    /** 1) Extrai estruturas normalizadas que já existem nesse ponto do fluxo */
    // 🔧 FIX CRÍTICO: Mudado de const para let para permitir recuperação em caso de contaminação
    let userFull  = referenceComparisonMetrics?.userFull;       // 1ª faixa (sua música)
    let refFull   = referenceComparisonMetrics?.referenceFull;  // 2ª faixa (referência)
    
    // � HARD-GUARD: Se userFull está undefined, recuperar de FirstAnalysisStore.get()
    if (!userFull && FirstAnalysisStore.has()) {
        console.warn('[SAFEGUARD] userFull está undefined — recuperando de FirstAnalysisStore');
        userFull = structuredClone(FirstAnalysisStore.get());
        console.log('[SAFEGUARD] ✅ userFull recuperado:', {
            fileName: userFull?.metadata?.fileName,
            jobId: userFull?.jobId
        });
    }

    let userTd    = referenceComparisonMetrics?.userTrack   || {};
    let refTd     = referenceComparisonMetrics?.referenceTrack || {};
    let userMd    = userFull?.metadata || {};
    let refMd     = refFull?.metadata  || {};

    // bandas A/B normalizadas + keys padronizadas
    let userBands = __normalizeBandKeys(__getBandsSafe(userFull));
    let refBands  = __normalizeBandKeys(__getBandsSafe(refFull));

    /** 2) Hard-gates antes de montar o objeto de score */
    const isReferenceMode = !!(referenceComparisonMetrics && referenceComparisonMetrics.reference);
    
    // 🔍 LOG DE VERIFICAÇÃO MÍNIMO (temporário - conforme item 7 do plano)
    console.log('[AB-CHECK]', {
        userJobId: userFull?.jobId,
        refJobId: refFull?.jobId,
        userName: userFull?.metadata?.fileName,
        refName: refFull?.metadata?.fileName
    });
    
    // ✅ PATCH: Validação de integridade ANTES de calcular selfCompare
    console.log('[INTEGRITY-CHECK] Validando dados antes de calcular score:', {
        userFileName: userMd.fileName,
        refFileName: refMd.fileName,
        userLUFS: userTd.lufsIntegrated,
        refLUFS: refTd.lufsIntegrated,
        sameFile: userMd.fileName === refMd.fileName,
        sameLUFS: userTd.lufsIntegrated && refTd.lufsIntegrated ? 
            Math.abs(userTd.lufsIntegrated - refTd.lufsIntegrated) < 0.05 : false
    });
    
    // 🚨 PATCH: Alerta crítico se arquivos são iguais (contaminação detectada)
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.error('[INTEGRITY-CHECK] ❌ FALHA CRÍTICA: userFile === refFile');
        console.error('[INTEGRITY-CHECK] ❌ Provável contaminação de dados!');
        console.error('[INTEGRITY-CHECK] ❌ Tentando recuperar de state.previousAnalysis...');
        
        // Tentar recuperar userFull de previousAnalysis
        if (state.previousAnalysis.metadata?.fileName !== refMd.fileName) {
            console.warn('[INTEGRITY-CHECK] ⚠️ Recuperando userFull de state.previousAnalysis');
            
            // 🛡️ PROTEÇÃO: SEMPRE usar clone para evitar contaminação de ponteiros
            console.log('[SAFEGUARD] Clonando state.previousAnalysis para evitar referência compartilhada');
            const recoveredUserFull = structuredClone(state.previousAnalysis);
            const recoveredUserMd = recoveredUserFull.metadata || {};
            const recoveredUserTd = recoveredUserFull.technicalData || {};
            const recoveredUserBands = __normalizeBandKeys(__getBandsSafe(recoveredUserFull));
            
            // Reatribuir variáveis recuperadas
            userFull = recoveredUserFull;
            userMd = recoveredUserMd;
            userTd = recoveredUserTd;
            userBands = recoveredUserBands;
            
            console.log('[INTEGRITY-CHECK] ✅ Dados recuperados de state.previousAnalysis:', {
                fileName: recoveredUserMd.fileName,
                lufs: recoveredUserTd.lufsIntegrated
            });
        }
    }
    
    // 🔍 AUDITORIA: Estado ANTES de calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] 🎯 ANTES de __tracksLookSame (selfCompare)');
    console.log('⚙️ Contexto: Prestes a calcular selfCompare');
    console.log('📊 userMd (1ª faixa metadata):', {
        fileName: userMd?.fileName,
        objectId: userMd
    });
    console.log('📊 refMd (2ª faixa metadata):', {
        fileName: refMd?.fileName,
        objectId: refMd
    });
    console.log('📊 userTd (1ª faixa technicalData):', {
        lufs: userTd?.lufsIntegrated,
        dr: userTd?.dynamicRange,
        objectId: userTd
    });
    console.log('📊 refTd (2ª faixa technicalData):', {
        lufs: refTd?.lufsIntegrated,
        dr: refTd?.dynamicRange,
        objectId: refTd
    });
    console.log('📊 userFull (origem):', {
        fileName: userFull?.metadata?.fileName,
        jobId: userFull?.jobId,
        objectId: userFull
    });
    console.log('📊 refFull (origem):', {
        fileName: refFull?.metadata?.fileName,
        jobId: refFull?.jobId,
        objectId: refFull
    });
    console.log('⚠️ PRÉ-VERIFICAÇÃO DE CONTAMINAÇÃO:');
    console.log('  userMd.fileName === refMd.fileName?', userMd?.fileName === refMd?.fileName);
    console.log('  userFull === refFull?', userFull === refFull);
    console.log('  userTd === refTd?', userTd === refTd);
    console.groupEnd();
    
    // 🛡️ PROTEÇÃO: Detectar e corrigir contaminação ANTES de __tracksLookSame
    if (userMd.fileName === refMd.fileName && state.previousAnalysis) {
        console.warn('[FIX] 🚨 Detecção de self-compare FALSO – isolando referenceAnalysis');
        console.warn('[FIX] userFull foi contaminado com dados de refFull');
        console.warn('[FIX] Tentando recuperar de FirstAnalysisStore...');
        
        // � HARD-GUARD: SEMPRE usar FirstAnalysisStore.get() como fonte confiável
        if (!FirstAnalysisStore.has()) {
            console.error('[FIX] ❌ FirstAnalysisStore vazio! Abortando recuperação...');
            return;
        }
        
        // Recuperar primeira análise de fonte confiável (APENAS FirstAnalysisStore)
        const safeUserFull = structuredClone(FirstAnalysisStore.get());
        userFull = safeUserFull;
        userMd = safeUserFull.metadata || {};
        userTd = safeUserFull.technicalData || {};
        userBands = __normalizeBandKeys(__getBandsSafe(safeUserFull));
        
        console.log('[FIX] ✅ userFull recuperado:', {
            fileName: userMd.fileName,
            lufs: userTd.lufsIntegrated,
            source: 'FirstAnalysisStore'
        });
    }
    
    // 🛡️ VALIDAÇÃO FINAL: Garantir que userFull e refFull são DIFERENTES após todas as recuperações
    console.group('🔍 [FINAL VALIDATION] Verificação final de contaminação');
    console.log('userMd.fileName:', userMd?.fileName);
    console.log('refMd.fileName:', refMd?.fileName);
    console.log('userFull.jobId:', userFull?.jobId);
    console.log('refFull.jobId:', refFull?.jobId);
    console.log('userFull === refFull?', userFull === refFull);
    console.log('userMd === refMd?', userMd === refMd);
    console.log('userTd === refTd?', userTd === refTd);
    console.log('userBands === refBands?', userBands === refBands);
    console.groupEnd();
    
    // ✅ VALIDAÇÃO FINAL: Log apenas, não bloqueia renderização
    if (userMd?.fileName === refMd?.fileName || userFull?.jobId === refFull?.jobId) {
        console.warn('[INFO] ⚠️ Mesmo jobId/fileName detectado (self-compare falso). Continuando render normalmente.');
        console.warn('[INFO] userMd.fileName:', userMd?.fileName);
        console.warn('[INFO] refMd.fileName:', refMd?.fileName);
        console.warn('[INFO] userFull.jobId:', userFull?.jobId);
        console.warn('[INFO] refFull.jobId:', refFull?.jobId);
        // ✅ NÃO RETORNA AQUI! Continua o fluxo para permitir renderização
    } else {
        console.log('[FINAL VALIDATION] ✅ Dados validados - userFull e refFull são DIFERENTES');
    }
    
    // ✅ STEP 6/6 (FINAL): Integrity check - apenas log, não bloqueia
    if (areSameTrack(userFull, refFull)) {
        console.warn('[INFO] ⚠️ areSameTrack() retornou true (self-compare falso). Continuando render normalmente.');
        // ✅ NÃO RETORNA AQUI! Continua o fluxo para permitir renderização
    } else {
        console.log('[INTEGRITY CHECK] ✅ userFull e refFull são diferentes — prosseguindo com cálculo');
    }
    
    // 🎯 ROOT CAUSE FIX: Detectar modo gênero ANTES de calcular refBandsOK
    // Em modo gênero, refBands vem de genreTargets, NÃO de referenceAnalysis!
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    let finalRefBands = refBands;
    
    if (isGenreMode) {
        console.log('🎯 [GENRE-BANDS-FIX] Modo GÊNERO detectado - buscando bandas de genreTargets');
        
        // Buscar bandas dos targets de gênero carregados
        const genreTargets = window.__activeRefData || 
                           analysis?.referenceComparison || 
                           (analysis?.genre ? window.PROD_AI_REF_DATA?.[analysis.genre] : null);
        
        if (genreTargets) {
            // Tentar extrair bandas de diferentes estruturas possíveis
            finalRefBands = genreTargets.bands || 
                          genreTargets.legacy_compatibility?.bands ||
                          genreTargets.hybrid_processing?.spectral_bands ||
                          null;
            
            console.log('🎯 [GENRE-BANDS-FIX] Bandas de gênero encontradas:', {
                source: genreTargets.bands ? 'bands' : 
                       genreTargets.legacy_compatibility?.bands ? 'legacy_compatibility.bands' :
                       genreTargets.hybrid_processing?.spectral_bands ? 'hybrid_processing.spectral_bands' : 'null',
                bands: finalRefBands ? Object.keys(finalRefBands) : 'null',
                genre: analysis?.genre
            });
        } else {
            console.warn('⚠️ [GENRE-BANDS-FIX] Targets de gênero NÃO encontrados! refBands será null');
        }
    } else {
        console.log('🔄 [AB-MODE] Modo A/B detectado - usando refBands de referenceAnalysis');
    }
    
    const selfCompare = __tracksLookSame(userTd, refTd, userMd, refMd, userBands, finalRefBands);
    const refBandsOK  = __bandsAreMeaningful(finalRefBands);
    const userBandsOK = __bandsAreMeaningful(userBands);

    // 🧪 MODO VERIFICAÇÃO: Log estruturado com console.table
    console.table({
        'userFile': userMd?.fileName || 'N/A',
        'refFile': refMd?.fileName || 'N/A',
        'sameFile': userMd?.fileName === refMd?.fileName,
        'userJobId': userFull?.jobId || 'N/A',
        'refJobId': refFull?.jobId || 'N/A',
        'sameJobId': userFull?.jobId === refFull?.jobId,
        'userLUFS': userTd?.lufsIntegrated || 'N/A',
        'refLUFS': refTd?.lufsIntegrated || 'N/A',
        'userBandsOK': userBandsOK,
        'refBandsOK': refBandsOK,
        'isGenreMode': isGenreMode,
        'finalRefBands': finalRefBands ? 'OK' : 'null'
    });
    
    console.log('[VERIFY_AB_ORDER]', {
      mode: state.render.mode,
      isGenreMode: isGenreMode,
      userFile: userMd.fileName, refFile: refMd.fileName,
      userLUFS: userTd.lufsIntegrated, refLUFS: refTd.lufsIntegrated,
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      refBands: refBandsOK  ? __keys(finalRefBands)  : 'ausente',
      selfCompare
    });
    
    // 🔍 AUDITORIA: Estado APÓS calcular selfCompare
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ✅ DEPOIS de __tracksLookSame');
    console.log('⚙️ Contexto: selfCompare calculado');
    console.log('🎯 selfCompare:', selfCompare);
    console.log('🎯 refBandsOK:', refBandsOK);
    console.log('🎯 userBandsOK:', userBandsOK);
    console.log('🎯 disableFrequency será:', !refBandsOK || !userBandsOK || selfCompare);
    if (selfCompare) {
        console.warn('⚠️ selfCompare TRUE detectado - score será 100%');
        console.warn('⚠️ Verificar se é legítimo (mesma faixa 2x) ou contaminação');
    }
    console.groupEnd();

    /** 2.5) FUNÇÃO CRÍTICA: Injetar targets de gênero em refData */
    function injectGenreTargetsIntoRefData(refData, genreTargets) {
        if (!refData || !genreTargets) return refData;
        
        const fields = [
            "lufs_target",
            "true_peak_target",
            "dr_target",
            "lra_target",
            "stereo_target",
            "bands",
            "tol_lufs",
            "tol_true_peak",
            "tol_dr",
            "tol_lra",
            "tol_stereo"
        ];
        
        fields.forEach(key => {
            if (genreTargets[key] !== undefined) {
                refData[key] = genreTargets[key];
            }
        });
        
        console.log("[GENRE-FIX] Targets injetados em refData:", {
            lufs_target: refData.lufs_target,
            true_peak_target: refData.true_peak_target,
            dr_target: refData.dr_target,
            stereo_target: refData.stereo_target,
            hasBands: !!refData.bands,
            bandsCount: refData.bands ? Object.keys(refData.bands).length : 0
        });
        
        return refData;
    }

    /** 3) Se referência não é válida ou A==B, rebaixa o score de frequência via "disable" e re-normaliza pesos */
    let disableFrequency = false;
    let referenceDataForScores = null;

    if (!refBandsOK || !userBandsOK || selfCompare) {
      disableFrequency = true;
      console.warn('⚠️ [SCORES-GUARD] Desativando score de Frequência:',
        { refBandsOK, userBandsOK, selfCompare, isGenreMode });

      // monta alvo somente com métricas escalares (sem bandas)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: null, // força desativado
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _disabledBands: true
      };
    } else {
      // fluxo normal (A/B saudável OU modo gênero com targets)
      referenceDataForScores = {
        lufs_target:          refTd.lufsIntegrated ?? refTd.lufs_integrated,
        true_peak_target:     refTd.truePeakDbtp   ?? refTd.true_peak_dbtp,
        dr_target:            refTd.dynamicRange   ?? refTd.dynamic_range,
        lra_target:           refTd.lra,
        stereo_target:        refTd.stereoCorrelation ?? refTd.stereo_correlation,
        spectral_centroid_target: refTd.spectralCentroidHz ?? refTd.spectral_centroid,
        bands: finalRefBands, // <- bandas reais (de referência A/B ou gênero)
        tol_lufs: 0.5, tol_true_peak: 0.3, tol_dr: 1.0, tol_lra: 1.0, tol_stereo: 0.08, tol_spectral: 300,
        _isReferenceMode: true,
        _referenceAnalysisFull: refFull // 🎯 PATCH: análise completa de referência para extração de bandas no subscore
      };
    }

    console.log('[SCORE-FIX] Bandas preparadas p/ cálculo:', {
      disableFrequency, 
      refBands: referenceDataForScores.bands ? __keys(referenceDataForScores.bands) : 'desativado',
      userBands: userBandsOK ? __keys(userBands) : 'ausente',
      isGenreMode: isGenreMode
    });

    /** 4) Cálculo seguro com proteção de tolerância e re-balanceamento de pesos */
    function __safeCalculateAnalysisScores(analysisObj, refData, genre) {
      // Protege tolerâncias (evita tolDb=0)
      if (!refData || typeof refData !== 'object') refData = {};
      if (!__num(refData.tol_spectral) || refData.tol_spectral <= 0) refData.tol_spectral = 300;

      // 🎯 CORREÇÃO: Detectar modo gênero e targets de múltiplas fontes
      const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
      
      // 🎯 CORREÇÃO: Buscar targets de gênero de todas as fontes possíveis
      const genreTargets = window.__activeRefData || 
                          window.PROD_AI_REF_DATA?.[analysisObj?.genre] || 
                          window.PROD_AI_REF_DATA?.[window.PROD_AI_REF_GENRE];
      
      const genreBands = genreTargets?.bands || 
                        genreTargets?.referenceComparison?.bands ||
                        analysisObj?.referenceComparison?.bands;
      
      // ✅ CRÍTICO: hasGenreTargets deve ser true se houver targets ou bandas
      const hasGenreTargets = isGenreMode && (
        !!genreTargets || 
        !!(analysisObj?.referenceComparison?._genreTargetsLoaded) ||
        !!(analysisObj?.referenceComparison?.bands)
      );
      
      const hasRefBands = !!(genreBands && Object.keys(genreBands).length > 0);
      const refBandsOK = hasRefBands;
      
      console.log('🔍 [SCORES-GUARD-ENHANCED]', {
        isGenreMode,
        hasGenreTargets,
        hasRefBands,
        refBandsOK,
        analysisMode: analysisObj?.mode,
        viewMode: window.__soundyState?.render?.mode,
        refDataHasBands: !!(refData?.bands),
        genreTargetsFound: !!genreTargets,
        genreBandsCount: genreBands ? Object.keys(genreBands).length : 0,
        isReferenceMode: refData?._isReferenceMode,
        disabledBands: refData?._disabledBands
      });

      // Chama o cálculo original
      const out = calculateAnalysisScores(analysisObj, refData, genre) || {};

      // 🎯 DECISÃO DE DESATIVAR FREQUÊNCIA:
      // - Modo REFERENCE: desativar se !refData.bands ou _disabledBands
      // - Modo GENRE: NÃO desativar se houver targets de gênero carregados
      const shouldDisableFrequency = isGenreMode 
        ? (!hasGenreTargets && (!refData.bands || refData._disabledBands)) // Modo gênero: só desativar se NÃO houver targets
        : (!refData.bands || refData._disabledBands); // Modo reference: desativar se sem bandas A/B
      
      if (shouldDisableFrequency) {
        const subs = out.subscores || out; // compat: alguns retornam direto
        const weights = {
          loudness: 0.32, dinamica: 0.23, frequencia: 0.0, estereo: 0.15, tecnico: 0.30 // soma = 1.0
        };
        // recomputa final de forma defensiva
        const lv = __num(subs.loudness)   ? subs.loudness   : 0;
        const dv = __num(subs.dinamica)   ? subs.dinamica   : 0;
        const ev = __num(subs.estereo)    ? subs.estereo    : 0;
        const tv = __num(subs.tecnico)    ? subs.tecnico    : 0;
        const final = Math.round(
          lv*weights.loudness + dv*weights.dinamica + ev*weights.estereo + tv*weights.tecnico
        );
        out.final = final;
        out._weightsApplied = weights;
        out._freqDisabled = true;
        console.warn('⚠️ [SCORES-GUARD] Frequência desativada ⇒ pesos re-normalizados', weights);
      } else if (isGenreMode && hasGenreTargets) {
        console.log('✅ [SCORES-GUARD] Modo GÊNERO: Frequência ATIVADA (targets de gênero disponíveis)');
      }

      // ═══════════════════════════════════════════════════════════════════════════
      // 🚨 V3.4: GATES PROPORCIONAIS (substituem caps fixos)
      // ═══════════════════════════════════════════════════════════════════════════
      const techData = analysisObj?.technicalData || analysisObj?.metrics || {};
      const truePeak = techData.truePeakDbtp ?? techData.true_peak_dbtp ?? null;
      const clipping = techData.clippingPct ?? techData.clipping_pct ?? 0;
      const dcOffset = Math.abs(techData.dcOffset ?? techData.dc_offset ?? 0);
      const lufs = techData.lufsIntegrated ?? techData.lufs_integrated ?? null;
      
      // Determinar modo e targets
      const mode = window.__soundyState?.render?.mode || 'streaming';
      const MODE_TARGETS = {
        streaming: { truePeak: { target: -1.0, max: -1.0 }, lufs: { target: -14.0, max: -12.0 } },
        pista: { truePeak: { target: -0.3, max: 0.0 }, lufs: { target: -9.0, max: -6.0 } },
        reference: { truePeak: { target: -1.0, max: 0.0 }, lufs: { target: -14.0, max: -8.0 } }
      };
      const targets = MODE_TARGETS[mode] || MODE_TARGETS.streaming;
      const tpMax = targets.truePeak?.max ?? 0;
      const tpTarget = targets.truePeak?.target ?? tpMax;
      const lufsMax = targets.lufs?.max ?? -12;
      const lufsTarget = targets.lufs?.target ?? -14;
      
      // 🎯 V3.4: Função de cap PROPORCIONAL para True Peak
      // Quanto mais passou do limite, menor o cap (mas NUNCA fixo em 35)
      function calculateTruePeakCap(tp, max, target) {
        if (tp === null) return 100;
        
        const excess = tp - max; // Quanto passou do máximo
        
        if (excess <= 0) return 100; // Dentro do limite
        
        // Escala proporcional: +0.1 = 90%, +0.5 = 75%, +1.0 = 60%, +2.0 = 45%, +3.0 = 35%
        // Fórmula: cap = 95 - (excess * 20), com mínimo de 35
        const cap = Math.max(35, Math.round(95 - (excess * 20)));
        return cap;
      }
      
      // 🎯 V3.4: Função de cap PROPORCIONAL para LUFS
      function calculateLufsCap(lufsValue, max, target) {
        if (lufsValue === null) return 100;
        
        const excess = lufsValue - max; // Quanto passou do máximo (valores mais altos = piores)
        
        if (excess <= 0) return 100; // Dentro do limite
        
        // Escala proporcional: +1 LU = 90%, +2 LU = 80%, +4 LU = 65%, +6 LU = 50%
        // Fórmula: cap = 95 - (excess * 7.5), com mínimo de 50
        const cap = Math.max(50, Math.round(95 - (excess * 7.5)));
        return cap;
      }
      
      // Preservar score bruto SEMPRE
      const finalRaw = out.final;
      out.finalRaw = finalRaw;
      
      let gatesTriggered = [];
      let caps = [];
      
      // GATE #1: TRUE PEAK (proporcional ao excesso)
      if (truePeak !== null && truePeak > tpMax) {
        const tpCap = calculateTruePeakCap(truePeak, tpMax, tpTarget);
        const excess = truePeak - tpMax;
        const severity = truePeak > 0 ? 'CRITICAL' : (excess > 0.5 ? 'HIGH' : 'MODERATE');
        
        caps.push(tpCap);
        gatesTriggered.push({ 
          type: `TRUE_PEAK_${severity}`, 
          value: truePeak, 
          limit: tpMax,
          excess: excess.toFixed(2),
          cap: tpCap,
          description: `True Peak ${truePeak.toFixed(2)} dBTP (+${excess.toFixed(2)} dB acima do limite)`
        });
        console.warn(`[V3-GATE] ⚠️ TRUE PEAK ${severity}: ${truePeak.toFixed(2)} dBTP (excesso: +${excess.toFixed(2)} dB) → cap ${tpCap}%`);
      }
      
      // GATE #2: CLIPPING SEVERO (> 5%) - mantém proporcional
      if (clipping > 5) {
        const clipCap = Math.max(30, Math.round(80 - (clipping - 5) * 4));
        caps.push(clipCap);
        gatesTriggered.push({ 
          type: 'CLIPPING_SEVERE', 
          value: clipping, 
          cap: clipCap,
          description: `Clipping ${clipping.toFixed(2)}% (aceitável: < 5%)`
        });
        console.warn(`[V3-GATE] ⚠️ CLIPPING SEVERO: ${clipping.toFixed(2)}% → cap ${clipCap}%`);
      }
      
      // GATE #3: LUFS EXCESSIVO (proporcional ao excesso)
      if (lufs !== null && lufs > lufsMax) {
        const lufsCap = calculateLufsCap(lufs, lufsMax, lufsTarget);
        const excess = lufs - lufsMax;
        
        caps.push(lufsCap);
        gatesTriggered.push({ 
          type: 'LUFS_EXCESSIVE', 
          value: lufs, 
          limit: lufsMax,
          excess: excess.toFixed(1),
          cap: lufsCap,
          description: `LUFS ${lufs.toFixed(1)} (+${excess.toFixed(1)} LU acima do limite)`
        });
        console.warn(`[V3-GATE] ⚠️ LUFS EXCESSIVO: ${lufs.toFixed(1)} (excesso: +${excess.toFixed(1)} LU) → cap ${lufsCap}%`);
      }
      
      // APLICAR MENOR CAP (se houver gates)
      if (caps.length > 0) {
        const scoreCap = Math.min(...caps);
        
        if (out.final > scoreCap) {
          console.warn(`[V3-GATE] 📉 Score capado: ${out.final}% → ${scoreCap}%`);
          out.final = scoreCap;
          out._scoreCapped = true;
        }
      }
      
      // Preservar metadados de gates
      out._gatesTriggered = gatesTriggered;
      out._capsApplied = caps;
      
      // Log de diagnóstico
      console.log('[V3-GATE] 📊 Diagnóstico V3.4:', {
        truePeak, tpMax, tpTarget,
        lufs, lufsMax, lufsTarget,
        clipping,
        mode,
        finalRaw,
        finalCapped: out.final,
        gatesTriggered: gatesTriggered.map(g => `${g.type}: cap ${g.cap}%`),
        scoreCapped: out._scoreCapped || false
      });

      return out;
    }

    /** 5) EXECUTA o cálculo com o objeto blindado */
    const detectedGenre = analysis.metadata?.genre || analysis.genre || __activeRefGenre;
    
    // ═════════════════════════════════════════════════════════════════
    // 🔍 PARTE 4: TESTE DE INSPEÇÃO OBRIGATÓRIO (PRÉ-CÁLCULO)
    // ═════════════════════════════════════════════════════════════════
    console.group("🔍 [AUDIT-BACKEND-FLOW] MÉTRICAS RECEBIDAS DO BACKEND");
    console.log("📊 analysis.technicalData:", analysis.technicalData);
    console.log("📊 analysis.metrics:", analysis.metrics);
    console.log("🔑 Keys technicalData:", Object.keys(analysis.technicalData || {}));
    console.log("🔑 Keys metrics:", Object.keys(analysis.metrics || {}));
    console.log("📍 Métricas específicas:");
    console.log("  - technicalData.lufsIntegrated:", analysis.technicalData?.lufsIntegrated);
    console.log("  - metrics.lufs_integrated:", analysis.metrics?.lufs_integrated);
    console.log("  - technicalData.truePeakDbtp:", analysis.technicalData?.truePeakDbtp);
    console.log("  - metrics.true_peak_dbtp:", analysis.metrics?.true_peak_dbtp);
    console.log("  - technicalData.dynamicRange:", analysis.technicalData?.dynamicRange);
    console.log("  - metrics.dynamic_range:", analysis.metrics?.dynamic_range);
    console.log("  - technicalData.lra:", analysis.technicalData?.lra);
    console.log("  - metrics.lra:", analysis.metrics?.lra);
    console.log("  - technicalData.stereoCorrelation:", analysis.technicalData?.stereoCorrelation);
    console.log("  - metrics.stereo_correlation:", analysis.metrics?.stereo_correlation);
    console.log("  - technicalData.stereoWidth:", analysis.technicalData?.stereoWidth);
    console.log("  - metrics.stereo_width:", analysis.metrics?.stereo_width);
    console.log("📌 Targets para cálculo (refData):");
    console.log("  - lufs_target:", referenceDataForScores?.lufs_target);
    console.log("  - true_peak_target:", referenceDataForScores?.true_peak_target);
    console.log("  - dr_target:", referenceDataForScores?.dr_target);
    console.log("  - lra_target:", referenceDataForScores?.lra_target);
    console.log("  - stereo_target:", referenceDataForScores?.stereo_target);
    console.log("  - bands:", referenceDataForScores?.bands ? Object.keys(referenceDataForScores.bands) : 'null');
    console.groupEnd();
    
    // 🎯 [GENRE-FIX] CRÍTICO: Aplicar targets de gênero SOMENTE no modo genre
    // ⚠️ NUNCA AFETA MODO REFERENCE
    if (isGenreMode) {
        console.log("[GENRE-FIX] ✅ Modo genre detectado - aplicando targets oficiais");
        
        // 🎯 USAR NOVA FUNÇÃO: extractGenreTargets (FONTE OFICIAL)
        const officialGenreTargets = extractGenreTargets(analysis);
        
        if (officialGenreTargets) {
            console.log("[GENRE-FIX] ✅ Targets encontrados em analysis.data.genreTargets (FONTE OFICIAL)");
            console.log("[GENRE-FIX] Targets:", {
                lufs_target: officialGenreTargets.lufs_target,
                true_peak_target: officialGenreTargets.true_peak_target,
                dr_target: officialGenreTargets.dr_target,
                stereo_target: officialGenreTargets.stereo_target,
                hasBands: !!officialGenreTargets.bands,
                bandsCount: officialGenreTargets.bands ? Object.keys(officialGenreTargets.bands).length : 0
            });
            
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, officialGenreTargets);
        } else if (window.__activeRefData) {
            // 🎯 FALLBACK: Usar window.__activeRefData apenas se não houver targets oficiais
            console.warn("[GENRE-FIX] ⚠️ FALLBACK: Usando window.__activeRefData");
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, window.__activeRefData);
        } else {
            // 🎯 FALLBACK FINAL: Carregar defaults
            console.warn("[GENRE-FIX] ⚠️ Nenhum target encontrado - carregando defaults");
            const defaultTargets = loadDefaultGenreTargets(extractGenreName(analysis));
            referenceDataForScores = injectGenreTargetsIntoRefData(referenceDataForScores, defaultTargets);
        }
    }
    // 🛡️ MODO REFERENCE: Não fazer NADA - referenceDataForScores permanece intacto
    
    // 🎯 [FLOW-FIX] Calculando scores APÓS normalização de métricas
    console.log("[FLOW-FIX] Calculando scores APÓS normalização de métricas.");
    
    const analysisScores = __safeCalculateAnalysisScores(analysis, referenceDataForScores, detectedGenre);

    if (analysisScores) {
        // ═════════════════════════════════════════════════════════════════
        // 🔍 TAREFA 1: AUDITORIA COMPLETA DA ESTRUTURA DE SCORES
        // ═════════════════════════════════════════════════════════════════
        console.group('🔍 [AUDIT-SCORES] ESTRUTURA COMPLETA DE analysisScores');
        console.log('[AUDIT-SCORES] analysisScores bruto:', analysisScores);
        console.log('[AUDIT-SCORES] keys:', Object.keys(analysisScores || {}));
        console.log('[AUDIT-SCORES] Subscores individuais:');
        console.log('  - analysisScores.loudness:', analysisScores.loudness);
        console.log('  - analysisScores.dinamica:', analysisScores.dinamica);
        console.log('  - analysisScores.dynamics:', analysisScores.dynamics);
        console.log('  - analysisScores.estereo:', analysisScores.estereo);
        console.log('  - analysisScores.stereo:', analysisScores.stereo);
        console.log('  - analysisScores.frequency:', analysisScores.frequency);
        console.log('  - analysisScores.frequencia:', analysisScores.frequencia);
        console.log('  - analysisScores.technical:', analysisScores.technical);
        console.log('  - analysisScores.tecnico:', analysisScores.tecnico);
        console.log('  - analysisScores.subscores (objeto):', analysisScores.subscores);
        if (analysisScores.subscores) {
            console.log('    → subscores.loudness:', analysisScores.subscores.loudness);
            console.log('    → subscores.dynamics:', analysisScores.subscores.dynamics);
            console.log('    → subscores.stereo:', analysisScores.subscores.stereo);
            console.log('    → subscores.frequency:', analysisScores.subscores.frequency);
            console.log('    → subscores.technical:', analysisScores.subscores.technical);
        }
        console.log('  - analysisScores.breakdown:', analysisScores.breakdown);
        console.log('  - analysisScores.final:', analysisScores.final);
        console.log('  - analysisScores.composite:', analysisScores.composite);
        
        // 🔍 PARTE 5: DIAGNÓSTICO FINAL - Identificar subscores NULL
        const nullScores = [];
        if (analysisScores.loudness === null || analysisScores.loudness === undefined) nullScores.push('loudness');
        if (analysisScores.dinamica === null || analysisScores.dinamica === undefined) nullScores.push('dinamica');
        if (analysisScores.estereo === null || analysisScores.estereo === undefined) nullScores.push('estereo');
        if (analysisScores.frequencia === null || analysisScores.frequencia === undefined) nullScores.push('frequencia');
        if (analysisScores.tecnico === null || analysisScores.tecnico === undefined) nullScores.push('tecnico');
        
        if (nullScores.length > 0) {
            console.error('❌ [AUDIT-SCORES] SUBSCORES NULL DETECTADOS:', nullScores);
            console.error('⚠️ [AUDIT-SCORES] Causa provável: métricas ausentes em analysis.metrics ou analysis.technicalData');
        } else {
            console.log('✅ [AUDIT-SCORES] TODOS OS SUBSCORES SÃO VÁLIDOS');
        }
        console.groupEnd();
        
        // Adicionar scores à análise
        analysis.scores = analysisScores;
        console.log('✅ Scores calculados e adicionados à análise');
        
        // Também armazenar globalmente
        if (typeof window !== 'undefined') {
            window.__LAST_ANALYSIS_SCORES__ = analysisScores;
        }
    } else {
        console.warn('⚠️ Não foi possível calcular scores (dados insuficientes)');
    }

    /* =========[ /BLOCO: SCORES A/B ]========= */
    
    // 🔥 REMOVIDO: Modal já foi aberto no início da função (linha 8350)
    // Remover duplicação de abertura do modal que estava causando problemas no modo gênero
    
    // 🎯 NOVO: Verificar se é modo referência e adicionar seção de comparação
    if (analysis.analysisMode === 'reference' && analysis.comparison) {
        addReferenceComparisonSection(analysis);
    }
    
    // Marcar se pacote avançado chegou (LUFS integrado + Pico Real + LRA)
    // 🔍 AUDITORIA: Verificar múltiplos caminhos para lufsIntegrated e truePeakDbtp
    const lufsValue = analysis?.technicalData?.lufs_integrated ?? 
                     analysis?.technicalData?.lufsIntegrated ??
                     analysis?.metrics?.loudness?.integrated ??
                     analysis?.loudness?.integrated;
    
    const truePeakValue = analysis?.technicalData?.truePeakDbtp ??
                         analysis?.truePeak?.maxDbtp;
    
    const advancedReady = (
        Number.isFinite(lufsValue) && Number.isFinite(truePeakValue)
    );
    
    // 🎯 LOGS DE DIAGNÓSTICO - MÉTRICAS PRINCIPAIS
    console.log('[METRICS-FIX] advancedReady:', advancedReady);
    console.log('[METRICS-FIX] LUFS=', lufsValue, {
        'technicalData.lufs_integrated': analysis?.technicalData?.lufs_integrated,
        'technicalData.lufsIntegrated': analysis?.technicalData?.lufsIntegrated,
        'metrics.loudness.integrated': analysis?.metrics?.loudness?.integrated,
        'loudness.integrated': analysis?.loudness?.integrated
    });
    console.log('[METRICS-FIX] TRUEPEAK=', truePeakValue, {
        'technicalData.truePeakDbtp': analysis?.technicalData?.truePeakDbtp,
        'truePeak.maxDbtp': analysis?.truePeak?.maxDbtp
    });
    
    if (typeof window !== 'undefined') window.__AUDIO_ADVANCED_READY__ = advancedReady;

    // Helpers seguros com bloqueio de fallback se advanced não pronto
    const safeFixed = (v, d=1) => (Number.isFinite(v) ? v.toFixed(d) : '—');
    const safeHz = (v) => (Number.isFinite(v) ? `${Math.round(v)} Hz` : '—');
    const pct = (v, d=0) => (Number.isFinite(v) ? `${(v*100).toFixed(d)}%` : '—');
    const tonalSummary = (tb) => {
        if (!tb || typeof tb !== 'object') return '—';
        const parts = [];
        if (tb.sub && Number.isFinite(tb.sub.rms_db)) parts.push(`Sub ${tb.sub.rms_db.toFixed(1)}dB`);
        if (tb.low && Number.isFinite(tb.low.rms_db)) parts.push(`Low ${tb.low.rms_db.toFixed(1)}dB`);
        if (tb.mid && Number.isFinite(tb.mid.rms_db)) parts.push(`Mid ${tb.mid.rms_db.toFixed(1)}dB`);
        if (tb.high && Number.isFinite(tb.high.rms_db)) parts.push(`High ${tb.high.rms_db.toFixed(1)}dB`);
        return parts.length ? parts.join(' • ') : '—';
    };

        // Layout com cards e KPIs, mantendo o container #modalTechnicalData
        
        // 🔒 SISTEMA DE RENDERIZAÇÃO SEGURA (usando SecureRenderUtils)
        const isReducedModeSecure = (typeof window !== 'undefined' && window.SecureRenderUtils) 
            ? window.SecureRenderUtils.isReducedMode(analysis)
            : false;
        
        console.log('[SECURE-RENDER-INTEGRATION] Modo Reduced:', isReducedModeSecure);
        
        const kpi = (value, label, cls='', metricKey='', section='primary') => {
            // Se SecureRenderUtils disponível, usar renderização segura
            if (typeof window !== 'undefined' && window.SecureRenderUtils && metricKey) {
                return window.SecureRenderUtils.renderSecureKPI(
                    value, 
                    label, 
                    metricKey, 
                    section, 
                    analysis, 
                    { className: cls, decimals: 1 }
                );
            }
            
            // Fallback (modo compatibilidade)
            const metricKeyAttr = metricKey ? ` data-metric-key="${metricKey}"` : '';
            return `
            <div class="kpi ${cls}"${metricKeyAttr}>
                <div class="kpi-value"${metricKeyAttr}>${value}</div>
                <div class="kpi-label">${label}</div>
            </div>`;
        };

        const scoreKpi = Number.isFinite(analysis.qualityOverall) ? kpi(Number(analysis.qualityOverall.toFixed(1)), 'SCORE GERAL', 'kpi-score', 'scoreFinal') : '';
        const timeKpi = Number.isFinite(analysis.processingMs) ? kpi(analysis.processingMs, 'TEMPO (MS)', 'kpi-time') : '';

        // 🎯 Removido title="" para evitar tooltip nativo do browser conflitando com TooltipManager
        const src = (k) => (analysis.technicalData?._sources && analysis.technicalData._sources[k]) ? ` data-src="${analysis.technicalData._sources[k]}"` : '';
        
        // 🔥 DETECÇÃO DE AMBIENTE DEV/PROD
        const isDev = typeof window !== 'undefined' && (
            window.location.hostname === 'localhost' ||
            window.location.hostname === '127.0.0.1' ||
            window.location.hostname.includes('dev') ||
            window.location.port === '3000'
        );
        
        // 🎯 TOOLTIP REGISTRY COMPLETO - 100% ESPECÍFICO (SEM FALLBACKS GENÉRICOS)
        // Estrutura: 'metricKey': { title, body, variant }
        // REGRA: Se não houver entry aqui, NÃO mostrar ícone "i" (prod) ou LOGAR WARNING (dev)
        const TOOLTIP_REGISTRY = {
            // === CARD 1: MÉTRICAS PRINCIPAIS ===
            'rmsPeak300msDbfs': {
                title: 'Pico RMS (300ms)',
                body: 'Mede o volume máximo em janelas de 300ms. Representa o "pico percebido" - o momento mais alto da faixa sem considerar clipping instantâneo. Usado para avaliar headroom dinâmico.',
                variant: 'default'
            },
            'samplePeak': {
                title: 'Sample Peak (dBFS)',
                body: 'Maior amplitude instantânea registrada entre os canais L/R. Deve ficar abaixo de 0 dBFS para evitar clipping digital. Valores acima de -0.1 dBFS são considerados críticos.',
                variant: 'default'
            },
            'truePeakDbtp': {
                title: 'Pico Real (dBTP)',
                body: 'Pico real que ocorre ENTRE as amostras digitais, detectado via oversampling 4x. Crucial para evitar clipping em conversões D/A. Ideal: ≤ -1.0 dBTP. Crítico se > 0 dBTP.',
                variant: 'warning'
            },
            'avgLoudness': {
                title: 'Volume Médio (RMS)',
                body: 'Nível RMS médio ao longo da faixa. Representa o volume "sustentado" - quanto de energia contínua o áudio tem. Diferente de picos, indica a "força geral" do mix.',
                variant: 'default'
            },
            'lufsIntegrated': {
                title: 'Loudness (LUFS Integrado)',
                body: 'Loudness integrada no tempo pelo padrão ITU-R BS.1770-4. Usado por Spotify, Apple Music e YouTube. Meta: -14 LUFS (streaming) ou -16 LUFS (broadcast).',
                variant: 'primary'
            },
            'lufsShortTerm': {
                title: 'LUFS Curto Prazo (Short-Term)',
                body: 'Loudness em janelas de 3 segundos. Mostra variações rápidas de volume, útil para detectar partes muito altas/baixas. Complementa o LUFS integrado.',
                variant: 'secondary'
            },
            'dynamicRange': {
                title: 'Dinâmica (DR)',
                body: 'Dynamic Range - diferença entre as partes mais altas e mais baixas da faixa. Valores altos (>10 dB) = mix com "respiro" e punch. Valores baixos (<6 dB) = loudness war / brick-wall limiting.',
                variant: 'primary'
            },
            'lra': {
                title: 'Consistência de Volume (LRA)',
                body: 'Loudness Range - mede a variação de volume ao longo do tempo. 0 LU = volume perfeitamente estável (suspeito). 5-15 LU = dinâmica natural. >20 LU = variações extremas.',
                variant: 'primary'
            },
            'stereoCorrelation': {
                title: 'Imagem Estéreo',
                body: 'Correlação entre canais L/R. +1 = mono perfeito, 0 = estéreo amplo, -1 = fase invertida (problema grave). Ideal: 0.5 a 0.9. Valores negativos causam cancelamento em mono.',
                variant: 'primary'
            },
            'stereoWidth': {
                title: 'Abertura Estéreo (%)',
                body: 'Percentual de abertura do campo estéreo. 0% = mono, 100% = estéreo máximo. Valores altos (>80%) criam sensação de amplitude e espacialidade. Cuidado com phase issues.',
                variant: 'primary'
            },
            
            // === CARD 2: ANÁLISE DE FREQUÊNCIAS ===
            'band_sub': {
                title: 'Subgrave (20–60 Hz)',
                body: 'Frequências ultra-graves, sentidas fisicamente mais que ouvidas. Região do sub-bass e kick fundamental. Excesso causa "lama" no mix, falta causa som "magro".',
                variant: 'frequency'
            },
            'band_bass': {
                title: 'Graves (60–150 Hz)',
                body: 'Corpo principal do kick e baixo. Define a "fundação" do mix. Muito = som abafado, pouco = falta de corpo. Crítico para gêneros como hip-hop, EDM e rock.',
                variant: 'frequency'
            },
            'band_lowMid': {
                title: 'Médios-Graves (150–500 Hz)',
                body: 'Base harmônica de instrumentos graves e vocais masculinos. Excesso causa "boxiness" (som encaixotado). Fundamental para clareza sem perder corpo.',
                variant: 'frequency'
            },
            'band_mid': {
                title: 'Médios (500 Hz–2 kHz)',
                body: 'Região de máxima sensibilidade auditiva. Vocais, guitarras, snares vivem aqui. Muito = som nasal, pouco = falta de presença. A "alma" do mix.',
                variant: 'frequency'
            },
            'band_highMid': {
                title: 'Médios-Agudos (2–5 kHz)',
                body: 'Ataque, clareza e definição de instrumentos. Região da "mordida" de guitarras e "corte" de vocais. Excesso = fadiga auditiva, falta = som apagado.',
                variant: 'frequency'
            },
            'band_presence': {
                title: 'Presença (5–10 kHz)',
                body: 'Brilho, clareza e "ar" do mix. Pratos, harmonics de vocais, sibilância. Muito = som duro/agressivo, pouco = som abafado/distante. Define o "polish" final.',
                variant: 'frequency'
            },
            'band_air': {
                title: 'Ar (10–20 kHz)',
                body: 'Frequências super-agudas, sensação de "espaço" e "abertura". Harmonics sutis e reverbs vivem aqui. Muito = sibilância, falta = som fechado. Define a "respiração" do mix.',
                variant: 'frequency'
            },
            'spectralCentroidHz': {
                title: 'Frequência Central (Hz)',
                body: 'Centro de massa espectral - mostra onde está concentrada a maior parte da energia. Valores baixos (<2 kHz) = som escuro/grave, valores altos (>4 kHz) = som brilhante/agudo.',
                variant: 'frequency'
            },
            
            // === CARD 3: MÉTRICAS AVANÇADAS ===
            'samplePeakLeftDb': {
                title: 'Sample Peak L (dBFS)',
                body: 'Pico máximo do canal esquerdo. Valores próximos de 0 dBFS indicam risco de clipping. Compare com o canal R para detectar desbalanceamento.',
                variant: 'advanced'
            },
            'samplePeakRightDb': {
                title: 'Sample Peak R (dBFS)',
                body: 'Pico máximo do canal direito. Deve estar balanceado com o canal L (diferença < 1 dB). Desbalanços grandes (>3 dB) indicam problemas de mixagem.',
                variant: 'advanced'
            },
            'thd': {
                title: 'THD (Total Harmonic Distortion)',
                body: 'Distorção harmônica total - mede harmonics indesejados gerados pelo sistema. < 0.5% = limpo, 0.5-1% = leve warmth, > 1% = distorção audível. Pode ser intencional (tape saturation).',
                variant: 'advanced'
            },
            'headroomDb': {
                title: 'Headroom (dB)',
                body: 'Espaço disponível até 0 dBFS. Indica margem de segurança para picos. < 1 dB = risco alto de clipping, 1-3 dB = aceitável, > 3 dB = conservador. Crucial para mastering.',
                variant: 'advanced'
            },
            'crestFactor': {
                title: 'Fator de Crista (Crest Factor)',
                body: 'Diferença entre pico e RMS médio. Indica "punch" e headroom dinâmico. Valores baixos (< 6 dB) = muito comprimido (loudness war), valores altos (> 12 dB) = dinâmica natural.',
                variant: 'advanced'
            },
            'spectralCentroid': {
                title: 'Centro Espectral (Hz)',
                body: 'Ponto de equilíbrio espectral - frequência onde 50% da energia está abaixo e 50% acima. Indica o "brilho" geral do mix. Valores típicos: 1-4 kHz.',
                variant: 'advanced'
            },
            'spectralRolloff': {
                title: 'Rolloff Espectral 85% (Hz)',
                body: 'Frequência onde 85% da energia espectral está concentrada. Indica extensão de agudos. < 8 kHz = som escuro, > 12 kHz = som brilhante. Útil para detectar filtros passa-baixa.',
                variant: 'advanced'
            },
            'spectralBandwidthHz': {
                title: 'Largura Espectral (Hz)',
                body: 'Dispersão das frequências ao redor do centróide. Valores altos = espectro "espalhado" (som rico/complexo), valores baixos = espectro concentrado (som simples/monotonal).',
                variant: 'advanced'
            },
            'spectralKurtosis': {
                title: 'Kurtosis Espectral',
                body: 'Mede "picosdade" do espectro. Valores altos (> 3) indicam harmonics fortes ou distorção. Valores baixos (< 3) indicam espectro uniforme. Útil para detectar harshness.',
                variant: 'advanced'
            },
            'spectralSkewness': {
                title: 'Assimetria Espectral',
                body: 'Mede se o espectro "pende" mais para graves ou agudos. Positivo = mais energia em agudos, negativo = mais energia em graves. Próximo de 0 = balanceado.',
                variant: 'advanced'
            },
            'dominantFrequencies': {
                title: 'Frequências Dominantes',
                body: 'As 5 frequências com maior energia espectral. Útil para identificar resonâncias, fundamentais de instrumentos e problemas de acúmulo de energia.',
                variant: 'advanced'
            },
            'zeroCrossings': {
                title: 'Zero Crossings Rate',
                body: 'Taxa de cruzamento por zero - relacionada ao conteúdo de alta frequência. Valores altos = muitos agudos/ruído, valores baixos = predominância de graves. Útil para classificação de timbre.',
                variant: 'advanced'
            },
            'mfcc1': {
                title: 'MFCC 1',
                body: 'Primeiro coeficiente Mel-Frequency Cepstral. Representa características timbrísticas gerais. Usado em algoritmos de reconhecimento de áudio e ML.',
                variant: 'advanced'
            },
            'mfcc2': {
                title: 'MFCC 2',
                body: 'Segundo coeficiente MFCC - captura nuances espectrais de médio termo. Complementa o MFCC 1 para análise de timbre.',
                variant: 'advanced'
            },
            'mfcc3': {
                title: 'MFCC 3',
                body: 'Terceiro coeficiente MFCC - captura detalhes espectrais finos. Usado em fingerprinting e análise avançada de timbre.',
                variant: 'advanced'
            },
            'suggestions': {
                title: 'Sugestões Disponíveis',
                body: 'Número de sugestões técnicas geradas pela IA com base na análise. Cada sugestão aponta problemas específicos e soluções práticas para melhorar o áudio.',
                variant: 'success'
            },
            
            // === CARD 4: PROBLEMAS TÉCNICOS ===
            'clippingSamples': {
                title: 'Clipping Samples',
                body: 'Número de amostras em 0 dBFS. Indica distorção digital grave. 0 samples = limpo, > 100 samples = problema audível. Use limiters com lookahead para evitar.',
                variant: 'error'
            },
            'dcOffset': {
                title: 'DC Offset',
                body: 'Componente DC (corrente contínua) no sinal de áudio. Deve estar próximo de zero. Valores > 0.01 podem causar clipping assimétrico e problemas em processamento. Corrija com filtro HP.',
                variant: 'warning'
            },
            'thdPercent': {
                title: 'THD %',
                body: 'Percentual de distorção harmônica total. < 0.5% = transparente, 0.5-1% = coloração sutil, > 1% = distorção evidente. Pode ser desejável em alguns contextos (warmth, saturation).',
                variant: 'warning'
            },
            
            // === VALIDAÇÕES / CONSISTÊNCIAS ===
            'drConsistency': {
                title: 'DR Consistência',
                body: 'Verifica se o Dynamic Range medido é consistente com outras métricas. Δ pequeno = bom. Δ grande = possível problema de medição ou áudio muito processado.',
                variant: 'default'
            },
            'crestConsistency': {
                title: 'Crest Factor Consistência',
                body: 'Verifica se o Crest Factor está dentro do esperado para o tipo de áudio. Inconsistências indicam processamento excessivo ou problemas de dinâmica.',
                variant: 'default'
            },
            'lraPlausibility': {
                title: 'LRA Plausibilidade',
                body: 'Verifica se o Loudness Range é plausível para o conteúdo. Valores muito baixos ou muito altos podem indicar problemas de medição ou áudio atípico.',
                variant: 'default'
            },
            
            // === SUBSCORES ===
            'loudness': {
                title: 'Subscore: Loudness',
                body: 'Avalia LUFS integrado, picos e headroom. Boa loudness = volume competitivo sem clipagem. Meta: -14 LUFS com True Peak < -1 dBTP.',
                variant: 'default'
            },
            'dynamic': {
                title: 'Subscore: Dinâmica',
                body: 'Avalia Dynamic Range (DR) e Loudness Range (LRA). Boa dinâmica = mix com punch, respiração e contraste. Evita "loudness war".',
                variant: 'default'
            },
            'frequency': {
                title: 'Subscore: Frequência',
                body: 'Avalia balanço espectral entre graves, médios e agudos. Bom balanço = mix claro e cheio, sem acúmulos ou buracos. Todas as bandas devem estar presentes.',
                variant: 'default'
            },
            'stereo': {
                title: 'Subscore: Estéreo',
                body: 'Avalia correlação e abertura estéreo. Bom estéreo = imagem ampla sem phase issues. Deve soar bem tanto em estéreo quanto em mono.',
                variant: 'default'
            },
            'technical': {
                title: 'Subscore: Técnico',
                body: 'Avalia problemas técnicos: clipping, DC offset, THD, phase. Score 100% = áudio tecnicamente limpo, sem artefatos digitais ou distorções indesejadas.',
                variant: 'default'
            },
            
            // === SCORE FINAL E DIAGNÓSTICO ===
            'scoreFinal': {
                title: 'Score Final',
                body: 'Média ponderada de todos os subscores. Reflete a qualidade técnica geral do áudio. 90-100% = excelente, 70-89% = bom, 50-69% = aceitável, <50% = problemas graves.',
                variant: 'primary'
            },
            'diagnostico': {
                title: 'Diagnóstico Geral',
                body: 'Classificação qualitativa baseada no score final: EXCELENTE (90-100%), MUITO BOM (80-89%), BOM (70-79%), REGULAR (60-69%), NECESSITA AJUSTES (50-59%), CRÍTICO (<50%).',
                variant: 'primary'
            }
        };
        
        // � LOG DE DIAGNÓSTICO: Confirmar que TOOLTIP_REGISTRY foi carregado
        if (isDev) {
            const registryKeys = Object.keys(TOOLTIP_REGISTRY);
            console.log(`✅ [TOOLTIP-INIT] TOOLTIP_REGISTRY carregado com ${registryKeys.length} tooltips`);
        }
        
        // �🔒 FUNÇÃO DE LOOKUP SEGURA (retorna null se não encontrar, NÃO usa fallback)
        // 🛡️ PROTEÇÃO: Verifica se TOOLTIP_REGISTRY existe antes de acessar
        const getTooltip = (metricKey) => {
            if (!metricKey) return null;
            
            // 🛡️ SAFETY: Se TOOLTIP_REGISTRY não existir, retornar null sem quebrar
            if (typeof TOOLTIP_REGISTRY === 'undefined') {
                if (isDev) {
                    console.error('[TOOLTIP-ERROR] TOOLTIP_REGISTRY não está definido! Sistema de tooltips não foi inicializado.');
                }
                return null;
            }
            
            // Tentar busca direta primeiro
            let tooltip = TOOLTIP_REGISTRY[metricKey];
            
            // Se não encontrou, tentar variações da chave
            if (!tooltip) {
                // Tentar sem prefixo band_
                if (metricKey.startsWith('band_')) {
                    tooltip = TOOLTIP_REGISTRY[metricKey];
                }
                // Tentar com lowercase
                if (!tooltip) {
                    const lowerKey = metricKey.toLowerCase();
                    tooltip = TOOLTIP_REGISTRY[lowerKey];
                }
            }
            
            // Se não encontrar E estiver em DEV, logar warning
            if (!tooltip && isDev) {
                // Usar conjunto global para evitar logs duplicados
                if (!window._missingTooltipKeys) window._missingTooltipKeys = new Set();
                if (!window._missingTooltipKeys.has(metricKey)) {
                    window._missingTooltipKeys.add(metricKey);
                    console.warn(`[TOOLTIP-MISSING] Métrica sem tooltip: "${metricKey}". Adicione entry no TOOLTIP_REGISTRY.`);
                }
            }
            
            return tooltip || null;
        };
        
        const row = (label, valHtml, keyForSource=null, metricKey=null, section='primary') => {
            // � [LABEL-AUDIT][RENDER] Log ANTES de qualquer transformação
            const originalLabel = label;
            const originalKey = keyForSource;
            
            // 🔒 RENDERIZAÇÃO SEGURA: Detectar se valHtml contém valor numérico
            // Se contiver, extrair o valor e usar SecureRenderUtils
            if (typeof window !== 'undefined' && window.SecureRenderUtils && metricKey) {
                // Tentar extrair valor numérico de valHtml
                const match = valHtml.match(/([-]?\d+\.?\d*)/);
                if (match) {
                    const numericValue = parseFloat(match[1]);
                    
                    // Extrair unidade (o que vem depois do número)
                    const unit = valHtml.replace(match[0], '').trim();
                    
                    // 🎯 Buscar tooltip usando novo sistema (getTooltip + TOOLTIP_REGISTRY)
                    const tooltipData = metricKey ? getTooltip(metricKey) : null;
                    
                    // Usar renderização segura
                    return window.SecureRenderUtils.renderSecureRow(
                        label,
                        numericValue,
                        unit,
                        metricKey,
                        section,
                        analysis,
                        { keyForSource, tooltip: tooltipData }
                    );
                }
            }
            
            // Fallback: renderização tradicional (sem números ou SecureRenderUtils não disponível)
            // 🚨 PONTO CRÍTICO: window.enhanceRowLabel PODE TROCAR O LABEL AQUI
            const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
                ? window.enhanceRowLabel(label, keyForSource) 
                : label;
            
            // 🔍 [LABEL-AUDIT][RENDER] Log DEPOIS do enhanceRowLabel
            if (DEBUG_LABEL_AUDIT && metricKey) {
                const labelChanged = originalLabel !== enhancedLabel;
                console.log(`[LABEL-AUDIT][RENDER] metricKey="${metricKey}" section="${section}"`, {
                    originalLabel,
                    enhancedLabel,
                    labelChanged,
                    keyForSource: originalKey,
                    valueHtml: valHtml.substring(0, 50),
                    enhanceRowLabelExists: !!(window.enhanceRowLabel)
                });
                
                if (labelChanged) {
                    console.warn(`🚨 [LABEL-AUDIT] LABEL FOI ALTERADO POR enhanceRowLabel!`, {
                        de: originalLabel,
                        para: enhancedLabel,
                        metricKey,
                        keyForSource: originalKey
                    });
                    // Stack trace para ver quem chamou
                    console.trace('[LABEL-AUDIT] Stack trace do enhanceRowLabel:');
                }
            }
            
            // Limpar label (trim) e capitalizar primeira letra
            const cleanLabel = enhancedLabel.trim();
            const capitalizedLabel = cleanLabel.charAt(0).toUpperCase() + cleanLabel.slice(1);
            
            // 🎯 BUSCAR TOOLTIP NO REGISTRY
            const tooltipData = metricKey ? getTooltip(metricKey) : null;
            
            // 🎯 Se não houver tooltip válido, ESCONDER o ícone (não usar fallback TODO visível)
            let tooltipIconHtml = '';
            if (tooltipData && tooltipData.body) {
                const tooltipTitle = tooltipData.title.replace(/"/g, '&quot;');
                const tooltipBody = tooltipData.body.replace(/"/g, '&quot;');
                const tooltipVariant = tooltipData.variant || 'default';
                tooltipIconHtml = `<span class="metric-info-icon" 
                       data-tooltip-title="${tooltipTitle}"
                       data-tooltip-body="${tooltipBody}"
                       ${tooltipVariant !== 'default' ? `data-tooltip-variant="${tooltipVariant}"` : ''}
                       style="margin-left: 4px; cursor: pointer;">ℹ️</span>`;
                
                // Log em DEV para métricas COM tooltip
                if (isDev && !tooltipData) {
                    console.warn(`[TOOLTIP-MISSING] metricKey="${metricKey}" label="${capitalizedLabel}"`);
                }
            }
            
            const labelHtml = `<div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                 <span>${capitalizedLabel}</span>${tooltipIconHtml}
               </div>`;
            
            // 🎯 Adicionar data-metric-key para rastreamento + data-original-label para auditoria
            const metricKeyAttr = metricKey ? ` data-metric-key="${metricKey}"` : '';
            const originalLabelAttr = DEBUG_LABEL_AUDIT ? ` data-original-label="${originalLabel}"` : '';
            
            return `
                <div class="data-row"${keyForSource?src(keyForSource):''}${metricKeyAttr}${originalLabelAttr}>
                    <span class="label" data-label-source="row-function">${labelHtml}</span>
                    <span class="value"${metricKeyAttr}>${valHtml}</span>
                </div>`;
        };

        // 🎯 CENTRALIZAÇÃO DAS MÉTRICAS - Funções de acesso unificado com fallbacks robustos
        const getNestedValue = (obj, path) => {
            if (!obj || !path) return null;
            return path.split('.').reduce((current, key) => current?.[key], obj);
        };

        // 🔧 getMetricWithFallback: Suporta múltiplos caminhos de fallback em ordem de prioridade
        const getMetricWithFallback = (paths, defaultValue = null) => {
            if (!Array.isArray(paths)) paths = [paths];
            
            for (const pathConfig of paths) {
                let value = null;
                
                if (typeof pathConfig === 'string') {
                    // Caminho simples: tenta metrics > technicalData
                    value = getNestedValue(analysis.metrics, pathConfig) ?? 
                           getNestedValue(analysis.technicalData, pathConfig);
                } else if (Array.isArray(pathConfig)) {
                    // Array de caminhos aninhados: ['loudness', 'integrated']
                    value = getNestedValue(analysis, pathConfig.join('.'));
                }
                
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            
            return defaultValue;
        };

        const getMetric = (metricPath, fallbackPath = null) => {
            // Prioridade: metrics centralizadas > technicalData legado > fallback
            const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
            if (Number.isFinite(centralizedValue)) {
                // Log temporário para validação
                if (typeof window !== 'undefined' && window.METRICS_UI_VALIDATION !== false) {
                    const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
                    if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                        console.warn(`🎯 METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                    }
                }
                return centralizedValue;
            }
            
            // Fallback para technicalData legado
            const legacyValue = fallbackPath ? getNestedValue(analysis.technicalData, fallbackPath) : getNestedValue(analysis.technicalData, metricPath);
            return Number.isFinite(legacyValue) ? legacyValue : null;
        };

        const safePct = (v) => (Number.isFinite(v) ? `${(v*100).toFixed(0)}%` : '—');
        const monoCompat = (s) => s ? s : '—';

        // Função para obter o valor LUFS integrado usando métricas centralizadas
        const getLufsIntegratedValue = () => {
            return getMetric('lufs_integrated', 'lufsIntegrated');
        };

        // 🎯 FUNÇÃO DE STATUS DO TRUE PEAK (CORREÇÃO CRÍTICA)
        const getTruePeakStatus = (value) => {
            if (!Number.isFinite(value)) return { status: '—', class: '' };
            
            if (value <= -1.5) return { status: 'EXCELENTE', class: 'status-excellent' };
            if (value <= -1.0) return { status: 'IDEAL', class: 'status-ideal' };
            if (value <= -0.5) return { status: 'BOM', class: 'status-good' };
            if (value <= 0.0) return { status: 'ACEITÁVEL', class: 'status-warning' };
            return { status: 'ESTOURADO', class: 'status-critical' };
        };

        // 🎯 HELPER: Obter Sample Peak (max de L/R) de forma robusta
        const getSamplePeakMaxDbfs = (analysis) => {
            const leftDb = analysis.technicalData?.samplePeakLeftDb;
            const rightDb = analysis.technicalData?.samplePeakRightDb;
            
            // Verificar se ambos são números finitos
            if (!Number.isFinite(leftDb) || !Number.isFinite(rightDb)) {
                return null;
            }
            
            return Math.max(leftDb, rightDb);
        };

        const col1 = [
            // 🟣 CARD 1: MÉTRICAS PRINCIPAIS - Chaves canônicas
            
            // 🎯 DEBUG: Imprimir valores das métricas ANTES de renderizar
            (() => {
                console.group('🔍 [METRICS-DEBUG] Card MÉTRICAS PRINCIPAIS - Valores Brutos');
                console.log('📊 technicalData.peak (Pico RMS 300ms):', analysis.technicalData?.peak);
                console.log('📊 technicalData.avgLoudness (Volume Médio RMS):', analysis.technicalData?.avgLoudness);
                console.log('📊 technicalData.samplePeakLeftDb:', analysis.technicalData?.samplePeakLeftDb);
                console.log('📊 technicalData.samplePeakRightDb:', analysis.technicalData?.samplePeakRightDb);
                console.log('📊 Sample Peak Max (calculado):', getSamplePeakMaxDbfs(analysis));
                console.log('📊 technicalData.truePeakDbtp:', analysis.technicalData?.truePeakDbtp);
                console.groupEnd();
                return ''; // Não renderiza nada, só debug
            })(),
            
            // 🎯 1. RMS Peak (300ms): technicalData.peak
            (() => {
                const rmsPeakValue = getMetric('rmsPeak300msDbfs') ?? getMetric('rmsPeak300msDb') ?? getMetric('rmsPeakDbfs') ?? getMetric('peak_db', 'peak');
                if (!Number.isFinite(rmsPeakValue) || rmsPeakValue === 0) {
                    return '';
                }
                console.log('✅ [RENDER] Pico RMS (300ms) =', rmsPeakValue, 'dB');
                return row('Pico RMS (300ms)', `${safeFixed(rmsPeakValue)} dB`, 'rmsPeak300msDbfs', 'rmsPeak300msDbfs', 'primary');
            })(),
            
            // 🎯 2. Sample Peak (dBFS): max(samplePeakLeftDb, samplePeakRightDb)
            (() => {
                const samplePeakDbfs = getSamplePeakMaxDbfs(analysis);
                
                if (samplePeakDbfs === null) {
                    console.warn('⚠️ [RENDER] Sample Peak não disponível (left ou right ausente)');
                    return '';
                }
                
                const spStatus = getTruePeakStatus(samplePeakDbfs);
                console.log('✅ [RENDER] Sample Peak (dBFS) =', samplePeakDbfs, 'dBFS');
                return row('Sample Peak (dBFS)', `${safeFixed(samplePeakDbfs, 1)} dBFS <span class="${spStatus.class}">${spStatus.status}</span>`, 'samplePeak', 'samplePeak', 'primary');
            })(),
            
            // 🎯 3. True Peak (dBTP): technicalData.truePeakDbtp
            (() => {
                const tpValue = getMetric('truePeakDbtp') ?? getMetricWithFallback([['truePeak','maxDbtp'], 'technicalData.truePeakDbtp']);
                
                if (!advancedReady) {
                    console.warn('⚠️ [RENDER] Pico Real BLOQUEADO por advancedReady=false');
                    return '';
                }
                if (tpValue === null || tpValue === undefined) {
                    console.warn('⚠️ [RENDER] Pico Real NÃO ENCONTRADO');
                    return '';
                }
                if (!Number.isFinite(tpValue)) {
                    console.warn('⚠️ [RENDER] Pico Real valor inválido:', tpValue);
                    return '';
                }
                
                const tpStatus = getTruePeakStatus(tpValue);
                console.log('✅ [RENDER] Pico Real (dBTP) =', tpValue, 'dBTP');
                return row('Pico Real (dBTP)', `${safeFixed(tpValue, 2)} dBTP <span class="${tpStatus.class}">${tpStatus.status}</span>`, 'truePeakDbtp', 'truePeakDbtp', 'primary');
            })(),
            
            // 🎯 4. Volume Médio (RMS): technicalData.avgLoudness
            (() => {
                const rmsValue = analysis.technicalData?.avgLoudness ?? analysis.technicalData?.rms;
                
                // Exibir sempre, mesmo se 0 (valor técnico válido)
                if (rmsValue === null || rmsValue === undefined) {
                    console.warn('⚠️ [RENDER] Volume Médio (RMS) NÃO ENCONTRADO');
                    return row('Volume Médio (RMS)', `—`, 'avgLoudness', 'avgLoudness', 'primary');
                }
                if (!Number.isFinite(rmsValue)) {
                    console.warn('⚠️ [RENDER] Volume Médio (RMS) valor inválido:', rmsValue);
                    return row('Volume Médio (RMS)', `—`, 'avgLoudness', 'avgLoudness', 'primary');
                }
                
                console.log('✅ [RENDER] Volume Médio (RMS) =', rmsValue, 'dBFS');
                return row('Volume Médio (RMS)', `${safeFixed(rmsValue, 1)} dBFS`, 'avgLoudness', 'avgLoudness', 'primary');
            })(),
            
            // 🎯 Loudness (LUFS) - loudness perceptiva em LUFS
            (() => {
                const lufsValue = getMetricWithFallback([
                    ['loudness', 'integrated'],
                    'lufs_integrated',
                    'lufsIntegrated',
                    'technicalData.lufsIntegrated'
                ]);
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) - advancedReady:', advancedReady, 'lufsValue:', lufsValue);
                
                if (!advancedReady) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS BLOQUEADO por advancedReady=false');
                    return '';
                }
                // 🎯 Exibir sempre, mesmo se 0
                if (lufsValue === null || lufsValue === undefined) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS NÃO ENCONTRADO - exibindo 0');
                    return row('Loudness (LUFS Integrado)', `0.0 LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
                }
                if (!Number.isFinite(lufsValue)) {
                    console.warn('[AUDITORIA-RMS-LUFS] col1 > LUFS valor inválido:', lufsValue);
                    return row('Loudness (LUFS Integrado)', `0.0 LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > Loudness (LUFS) RENDERIZADO:', lufsValue, 'LUFS');
                return row('Loudness (LUFS Integrado)', `${safeFixed(lufsValue, 1)} LUFS`, 'lufsIntegrated', 'lufsIntegrated', 'primary');
            })(),
            
            // 🎯 LUFS Curto Prazo (Short-Term) - exibido logo após LUFS Integrado
            (() => {
                const lufsShortTermValue = analysis.technicalData?.lufsShortTerm ?? analysis.loudness?.shortTerm ?? null;
                if (!advancedReady) {
                    return '';
                }
                if (lufsShortTermValue === null || lufsShortTermValue === undefined || !Number.isFinite(lufsShortTermValue)) {
                    console.log('[AUDITORIA-RMS-LUFS] col1 > LUFS Curto Prazo não disponível ou inválido');
                    return '';
                }
                console.log('[AUDITORIA-RMS-LUFS] col1 > LUFS Curto Prazo RENDERIZADO:', lufsShortTermValue, 'LUFS');
                return row('LUFS Curto Prazo (Short-Term)', `${safeFixed(lufsShortTermValue, 1)} LUFS`, 'lufsShortTerm', 'lufsShortTerm', 'secondary');
            })(),
            
            row('Dinâmica (DR)', `${safeFixed(getMetric('dynamic_range', 'dynamicRange'))} dB`, 'dynamicRange', 'dynamicRange', 'primary'),
            row('Consistência de Volume (LU)', `${safeFixed(getMetric('lra', 'lra'))} LU`, 'lra', 'lra', 'primary'),
            // Imagem Estéreo (movido de col2)
            row('Imagem Estéreo', Number.isFinite(getMetric('stereo_correlation', 'stereoCorrelation')) ? safeFixed(getMetric('stereo_correlation', 'stereoCorrelation'), 3) : '—', 'stereoCorrelation', 'stereoCorrelation', 'primary'),
            // Abertura Estéreo (movido de col2)
            row('Abertura Estéreo (%)', Number.isFinite(getMetric('stereo_width', 'stereoWidth')) ? `${safeFixed(getMetric('stereo_width', 'stereoWidth') * 100, 0)}%` : '—', 'stereoWidth', 'stereoWidth', 'primary')
            ];

        // 🔍 [DEBUG_MAIN_METRICS] Sistema de Tracking Completo
        if (DEBUG_MAIN_METRICS) {
            const trackingData = [];
            
            // Linha 1: Pico RMS (300ms)
            const rmsPeakValue = getMetric('rmsPeak300msDbfs') ?? getMetric('rmsPeak300msDb') ?? getMetric('rmsPeakDbfs') ?? getMetric('peak_db', 'peak');
            trackingData.push({
                rowId: 1,
                labelHardcoded: 'Pico RMS (300ms)',
                labelKeyUsed: 'peak',
                valueKeyUsed: 'peak / rmsPeak300msDbfs',
                computedLabel: 'Pico RMS (300ms)',
                value: rmsPeakValue,
                rawSourcePath: 'analysis.technicalData.peak',
                actualSourceValue: analysis.technicalData?.peak
            });
            
            // Linha 2: Sample Peak
            const samplePeakDbfs = getSamplePeakMaxDbfs(analysis);
            trackingData.push({
                rowId: 2,
                labelHardcoded: 'Sample Peak (dBFS)',
                labelKeyUsed: 'samplePeak',
                valueKeyUsed: 'max(samplePeakLeftDb, samplePeakRightDb)',
                computedLabel: 'Sample Peak (dBFS)',
                value: samplePeakDbfs,
                rawSourcePath: 'Math.max(technicalData.samplePeakLeftDb, technicalData.samplePeakRightDb)',
                actualSourceValue: `L:${analysis.technicalData?.samplePeakLeftDb} R:${analysis.technicalData?.samplePeakRightDb}`
            });
            
            // Linha 3: True Peak
            const tpValue = getMetric('truePeakDbtp') ?? getMetricWithFallback([['truePeak','maxDbtp'], 'technicalData.truePeakDbtp']);
            trackingData.push({
                rowId: 3,
                labelHardcoded: 'Pico Real (dBTP)',
                labelKeyUsed: 'truePeakDbtp',
                valueKeyUsed: 'truePeakDbtp',
                computedLabel: 'Pico Real (dBTP)',
                value: tpValue,
                rawSourcePath: 'analysis.technicalData.truePeakDbtp',
                actualSourceValue: analysis.technicalData?.truePeakDbtp
            });
            
            // Linha 4: Volume Médio (RMS)
            const rmsValue = analysis.technicalData?.avgLoudness ?? analysis.technicalData?.rms;
            trackingData.push({
                rowId: 4,
                labelHardcoded: 'Volume Médio (RMS)',
                labelKeyUsed: 'avgLoudness',
                valueKeyUsed: 'avgLoudness',
                computedLabel: 'Volume Médio (RMS)',
                value: rmsValue,
                rawSourcePath: 'analysis.technicalData.avgLoudness',
                actualSourceValue: analysis.technicalData?.avgLoudness
            });
            
            // Linha 5: LUFS
            const lufsValue = getMetricWithFallback([
                ['loudness', 'integrated'],
                'lufs_integrated',
                'lufsIntegrated',
                'technicalData.lufsIntegrated'
            ]);
            trackingData.push({
                rowId: 5,
                labelHardcoded: 'Loudness (LUFS Integrado)',
                labelKeyUsed: 'lufsIntegrated',
                valueKeyUsed: 'lufsIntegrated / lufs_integrated',
                computedLabel: 'Loudness (LUFS Integrado)',
                value: lufsValue,
                rawSourcePath: 'analysis.technicalData.lufsIntegrated',
                actualSourceValue: analysis.technicalData?.lufsIntegrated
            });
            
            console.groupCollapsed(`🔍 [MAIN_METRICS] render #${RENDER_ID}`);
            console.table(trackingData);
            console.log('📦 technicalData keys:', Object.keys(analysis.technicalData || {}));
            console.log('📦 technicalData completo:', analysis.technicalData);
            console.trace('🔍 Stack trace:');
            console.groupEnd();
        }

        // Juntar HTML
        const col1Html = col1.join('');

        // 🔍 [DEBUG_MAIN_METRICS] Log do HTML gerado
        if (DEBUG_MAIN_METRICS) {
            console.group(`🔍 [MAIN_METRICS] HTML Gerado #${RENDER_ID}`);
            console.log('📝 col1Html length:', col1Html.length);
            console.log('📝 col1Html preview:', col1Html.substring(0, 500));
            console.log('📝 col1 array length:', col1.length);
            console.log('📝 col1 array items:', col1.map((item, idx) => ({ idx, isEmpty: item === '', length: item.length })));
            console.groupEnd();
        }

        // 🔍 [DEBUG_MAIN_METRICS] Ler DOM renderizado e comparar
        if (DEBUG_MAIN_METRICS) {
            // Agendar leitura do DOM após renderização
            setTimeout(() => {
                const modalTechData = document.getElementById('modalTechnicalData');
                if (!modalTechData) {
                    console.warn('[MAIN_METRICS] modalTechnicalData não encontrado no DOM');
                    return;
                }
                
                const dataRows = modalTechData.querySelectorAll('.data-row');
                const domContent = [];
                
                dataRows.forEach((row, idx) => {
                    const labelEl = row.querySelector('.label');
                    const valueEl = row.querySelector('.value');
                    
                    if (labelEl && valueEl) {
                        domContent.push({
                            domIndex: idx + 1,
                            domLabelText: labelEl.textContent.trim().replace(/ℹ️/g, '').trim(),
                            domValueText: valueEl.textContent.trim(),
                            domLabelHTML: labelEl.innerHTML.substring(0, 100),
                            domValueHTML: valueEl.innerHTML.substring(0, 100),
                            metricKey: row.getAttribute('data-metric-key'),
                            originalLabel: row.getAttribute('data-original-label')
                        });
                    }
                });
                
                console.groupCollapsed(`🔍 [MAIN_METRICS] DOM Renderizado #${RENDER_ID}`);
                console.table(domContent.slice(0, 5)); // Primeiras 5 linhas (métricas principais)
                console.log('📊 Total de rows no DOM:', dataRows.length);
                console.groupEnd();
                
                // 🔍 [LABEL-AUDIT] Instalar MutationObserver
                if (DEBUG_LABEL_AUDIT) {
                    console.log('🔍 [LABEL-AUDIT] Instalando MutationObserver...');
                    
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            if (mutation.type === 'characterData' || mutation.type === 'childList') {
                                const target = mutation.target;
                                const parentLabel = target.nodeType === Node.TEXT_NODE 
                                    ? target.parentElement 
                                    : target;
                                
                                // Verificar se é uma label
                                if (parentLabel && (
                                    parentLabel.classList.contains('label') || 
                                    parentLabel.classList.contains('metric-label-friendly') ||
                                    parentLabel.closest('.label')
                                )) {
                                    const row = parentLabel.closest('.data-row');
                                    const metricKey = row ? row.getAttribute('data-metric-key') : null;
                                    const originalLabel = row ? row.getAttribute('data-original-label') : null;
                                    
                                    console.group('🚨 [LABEL-AUDIT][MUTATION] Label foi alterada!');
                                    console.log('Timestamp:', new Date().toISOString());
                                    console.log('metricKey:', metricKey);
                                    console.log('originalLabel (data-attr):', originalLabel);
                                    console.log('Label atual (textContent):', parentLabel.textContent.trim());
                                    console.log('Tipo de mutação:', mutation.type);
                                    console.log('Target:', mutation.target);
                                    console.log('Elemento pai:', parentLabel);
                                    
                                    // Stack trace
                                    const e = new Error('[LABEL-AUDIT] Label mutated');
                                    console.log('Stack trace:');
                                    console.log(e.stack);
                                    console.groupEnd();
                                }
                            }
                        });
                    });
                    
                    // Observar todo o container de métricas
                    observer.observe(modalTechData, {
                        childList: true,
                        subtree: true,
                        characterData: true,
                        characterDataOldValue: true
                    });
                    
                    console.log('✅ [LABEL-AUDIT] MutationObserver instalado com sucesso');
                    
                    // Guardar referência global para debug
                    window.__LABEL_AUDIT_OBSERVER__ = observer;
                    
                    // 📊 Imprimir relatório resumido no console após 2s
                    setTimeout(() => {
                        console.group('📋 [LABEL-AUDIT] RELATÓRIO RESUMIDO');
                        console.log('%c🔍 AUDITORIA DE LABELS - Card "Métricas Principais"', 'font-size:14px;font-weight:bold;color:#00ffff');
                        console.log('');
                        console.log('%c📌 CAUSA RAIZ IDENTIFICADA:', 'font-weight:bold;color:#ff6b6b');
                        console.log('   Sistema friendly-labels.js com busca por substring causa matches espúrios');
                        console.log('   Arquivo: public/friendly-labels.js linha 159-195');
                        console.log('   Função: window.enhanceRowLabel()');
                        console.log('');
                        console.log('%c🚨 PROBLEMA:', 'font-weight:bold;color:#ffd700');
                        console.log('   1. enhanceRowLabel() busca substring em labels');
                        console.log('   2. "Sample Peak (dBFS)" contém "peak" → match com \'peak\': \'Pico RMS (300ms)\'');
                        console.log('   3. Primeiro match vence, causando labels trocados');
                        console.log('');
                        console.log('%c💡 SOLUÇÃO SUGERIDA:', 'font-weight:bold;color:#00ff92');
                        console.log('   Opção 1: Desabilitar enhanceRowLabel para métricas principais (section === "primary")');
                        console.log('   Opção 2: Melhorar lógica de match (exato antes de substring)');
                        console.log('   Opção 3: Whitelist de keys permitidas para substring match');
                        console.log('');
                        console.log('%c📄 RELATÓRIO COMPLETO:', 'font-weight:bold');
                        console.log('   Arquivo: REPORT_LABEL_AUDIT.md');
                        console.log('   Para desabilitar auditoria: DEBUG_LABEL_AUDIT = false (linha ~12037)');
                        console.log('');
                        console.log('%c🔍 DADOS COLETADOS:', 'font-weight:bold');
                        console.log('   - Logs [LABEL-AUDIT][RENDER]: Antes/depois do enhanceRowLabel');
                        console.log('   - Logs [LABEL-AUDIT][MUTATION]: Mudanças pós-render (se houver)');
                        console.log('   - Tabelas [MAIN_METRICS]: Mapeamento original vs DOM final');
                        console.groupEnd();
                    }, 2000);
                }
            }, 500); // Aguardar 500ms para DOM estar pronto
        }

        // 🎯 RESUMO FINAL: Card montado com sucesso
        console.group('✅ [METRICS-FINAL] Card MÉTRICAS PRINCIPAIS - Resumo');
        console.log('🎯 Linha 1: Pico RMS (300ms) → technicalData.peak');
        console.log('🎯 Linha 2: Sample Peak (dBFS) → max(samplePeakLeftDb, samplePeakRightDb)');
        console.log('🎯 Linha 3: Pico Real (dBTP) → technicalData.truePeakDbtp');
        console.log('🎯 Linha 4: Volume Médio (RMS) → technicalData.avgLoudness');
        console.log('📊 HTML gerado:', col1.length > 0 ? 'OK' : 'VAZIO');
        console.groupEnd();

        // 🎯 SANITY CHECK: Validação leve das métricas principais (não bloqueia renderização)
        (() => {
            const rmsPeak = getMetric('rmsPeak300msDbfs') ?? getMetric('peak');
            const avgRms = analysis.technicalData?.avgLoudness;
            const samplePeak = getSamplePeakMaxDbfs(analysis);
            
            console.group('🔍 [METRICS-SANITY] Validação de Consistência');
            
            // Check 1: RMS Peak deve ser maior (menos negativo) que RMS médio
            if (Number.isFinite(rmsPeak) && Number.isFinite(avgRms) && rmsPeak < avgRms) {
                console.warn('⚠️ Alerta: Pico RMS (300ms) menor que Volume Médio (RMS)', {
                    rmsPeak300ms: rmsPeak,
                    avgLoudness: avgRms,
                    diff: avgRms - rmsPeak
                });
            } else {
                console.log('✅ Pico RMS vs Volume Médio: OK');
            }
            
            // Check 2: Sample Peak principal deve corresponder ao max(L,R) em métricas avançadas
            if (Number.isFinite(samplePeak)) {
                const advancedL = analysis.technicalData?.samplePeakLeftDb;
                const advancedR = analysis.technicalData?.samplePeakRightDb;
                const maxAdvanced = Math.max(advancedL || -Infinity, advancedR || -Infinity);
                
                if (Math.abs(samplePeak - maxAdvanced) > 0.1) {
                    console.debug('ℹ️ Info: Sample Peak principal difere de max(L,R) avançado', {
                        samplePeakPrincipal: samplePeak,
                        samplePeakLeft: advancedL,
                        samplePeakRight: advancedR,
                        maxAdvanced: maxAdvanced,
                        diff: Math.abs(samplePeak - maxAdvanced)
                    });
                } else {
                    console.log('✅ Sample Peak vs max(L,R): OK');
                }
            }
            
            console.groupEnd();
        })();

        const col2 = (() => {
            // 🔵 CARD 2: ANÁLISE DE FREQUÊNCIAS - Reorganizado com sub-bandas espectrais
            const rows = [];
            
            // Sub-bandas espectrais (movidas de advancedMetricsCard)
            const spectralBands = analysis.technicalData?.spectral_balance || 
                                analysis.technicalData?.spectralBands || 
                                analysis.metrics?.bands || {};
            
            if (Object.keys(spectralBands).length > 0) {
                const bandMap = {
                    sub: { name: 'Subgrave (20–60 Hz)', range: '20-60Hz' },
                    bass: { name: 'Graves (60–150 Hz)', range: '60-150Hz' },
                    lowMid: { name: 'Médios-Graves (150–500 Hz)', range: '150-500Hz' },
                    mid: { name: 'Médios (500 Hz–2 kHz)', range: '500-2000Hz' },
                    highMid: { name: 'Médios-Agudos (2–5 kHz)', range: '2000-5000Hz' },
                    presence: { name: 'Presença (5–10 kHz)', range: '5000-10000Hz' },
                    air: { name: 'Ar (10–20 kHz)', range: '10000-20000Hz' }
                };
                
                Object.keys(bandMap).forEach(bandKey => {
                    const bandData = spectralBands[bandKey];
                    if (bandData && typeof bandData === 'object') {
                        const energyDb = bandData.energy_db;
                        const percentage = bandData.percentage;
                        const status = bandData.status;
                        
                        if (status && status !== 'not_calculated') {
                            let displayValue = '';
                            if (Number.isFinite(energyDb) && Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB (${safeFixed(percentage, 1)}%)`;
                            } else if (Number.isFinite(energyDb)) {
                                displayValue = `${safeFixed(energyDb, 1)} dB`;
                            } else if (Number.isFinite(percentage)) {
                                displayValue = `${safeFixed(percentage, 1)}%`;
                            } else {
                                displayValue = 'não calculado';
                            }
                            const metricKey = `band_${bandKey}`;
                            
                            // ✅ PRIORIZAR: Usar frequencyRange do backend se existir
                            const displayName = bandData.frequencyRange 
                                ? `${bandMap[bandKey].name.split('(')[0].trim()} (${bandData.frequencyRange})`
                                : bandMap[bandKey].name;
                            
                            rows.push(row(displayName, displayValue, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`, metricKey, 'frequency'));
                        }
                    } else if (Number.isFinite(bandData)) {
                        const metricKey = `band_${bandKey}`;
                        
                        // ✅ Fallback também usa range do backend se existir
                        const displayName = bandMap[bandKey].name;
                        
                        rows.push(row(displayName, `${safeFixed(bandData, 1)} dB`, `spectral${bandKey.charAt(0).toUpperCase() + bandKey.slice(1)}`, metricKey, 'frequency'));
                    }
                });
            }
            
            // Frequência Central (mantém aqui)
            rows.push(row('Frequência Central (Hz)', Number.isFinite(getMetric('spectral_centroid', 'spectralCentroidHz')) ? safeHz(getMetric('spectral_centroid', 'spectralCentroidHz')) : '—', 'spectralCentroidHz', 'spectralCentroidHz', 'frequency'));
            
            return rows.join('');
            // REMOVED: Correlação Estéreo - movido para col1
            // REMOVED: Largura Estéreo - movido para col1
        })();

            // 🧩 CORREÇÃO #5: Exibir frequências dominantes na UI (removido bloqueio)
            // Frequências dominantes agora visíveis
            console.log('🎛️ [DEBUG] Exibindo métricas de frequência na UI');
            
            const col3 = [
                // REMOVED: Dominant Frequencies UI (mantendo cálculo interno para suggestions)
                
                // REMOVED: clipping (%) - ocultado da interface conforme solicitado
                // REMOVED: dc offset - ocultado da interface conforme solicitado
                (Number.isFinite(getMetric('thd', 'thd')) ? row('thd', `${safeFixed(getMetric('thd', 'thd'), 2)}%`, 'thd') : ''),
                
                // REMOVED: Dinâmica e Fator de Crista duplicados - já exibidos em col1
                // REMOVED: row('Correlação Estéreo (largura)') - duplicado de col2
                // REMOVED: row('fator de crista') - duplicado de col1
                // REMOVED: row('Dinâmica (diferença entre alto/baixo)') - duplicado de col1 com DR e LRA
                
                // REMOVED: Placeholders hardcoded - substituir por valores reais quando disponíveis
                // row('crest consist', 'Δ=4.43 check', 'crestConsist'),
                // row('Variação de Volume (consistência)', 'ok', 'volumeConsistency'),
                
                // REMOVED: Problemas - ocultado da interface conforme solicitado
                // REMOVED: Sugestões - movido para o final do card MÉTRICAS AVANÇADAS
                // row('Sugestões', (analysis.suggestions?.length || 0) > 0 ? `<span class="tag tag-success">${analysis.suggestions.length} disponível(s)</span>` : '—')
                // REMOVED: col3Extras (dominant frequencies UI)
            ].join('');

            // Card extra: Métricas Avançadas (expandido para Web Audio API compatibility)
            const advancedMetricsCard = () => {
                const rows = [];
                
                // === MÉTRICAS DE PICO E CLIPPING (seção principal) ===
                
                // REMOVED: True Peak (dBTP) - agora exclusivo do card MÉTRICAS PRINCIPAIS
                // Se truePeakDbtp estiver mapeado no card de avançadas, remova de lá. 
                // True Peak deve existir apenas em Métricas Principais para evitar duplicação
                
                // Picos por canal separados (Sample Peak)
                if (Number.isFinite(analysis.technicalData?.samplePeakLeftDb)) {
                    rows.push(row('Sample Peak L (dBFS)', `${safeFixed(analysis.technicalData.samplePeakLeftDb, 1)} dBFS`, 'samplePeakLeftDb', 'samplePeakLeftDb', 'advanced'));
                }
                if (Number.isFinite(analysis.technicalData?.samplePeakRightDb)) {
                    rows.push(row('Sample Peak R (dBFS)', `${safeFixed(analysis.technicalData.samplePeakRightDb, 1)} dBFS`, 'samplePeakRightDb', 'samplePeakRightDb', 'advanced'));
                }
                
                // REMOVED: Clipping (%) - ocultado da interface conforme solicitado
                
                // REMOVED: Clipping samples - ocultado da interface conforme solicitado
                
                // REMOVED: DC OFFSET - ocultado da interface conforme solicitado
                
                // === THD (Total Harmonic Distortion) ===
                if (Number.isFinite(analysis.technicalData?.thd)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thd, 4)}%`, 'thd', 'thd', 'advanced'));
                } else if (Number.isFinite(analysis.technicalData?.thdPercent)) {
                    rows.push(row('thd', `${safeFixed(analysis.technicalData.thdPercent, 4)}%`, 'thdPercent', 'thd', 'advanced'));
                }
                
                // === HEADROOM ===
                if (Number.isFinite(analysis.technicalData?.headroomDb)) {
                    rows.push(row('headroom (dB)', `${safeFixed(analysis.technicalData.headroomDb, 1)} dB`, 'headroomDb', 'headroomDb', 'advanced'));
                }
                
                // === FATOR DE CRISTA (movido de MÉTRICAS PRINCIPAIS) ===
                const crestValue = getMetricWithFallback([
                    ['dynamics', 'crest'],
                    'crest_factor',
                    'crestFactor',
                    'technicalData.crestFactor'
                ]);
                if (Number.isFinite(crestValue)) {
                    console.log('[METRICS-FIX] advancedMetricsCard > Fator de Crista RENDERIZADO:', crestValue, 'dB');
                    rows.push(row('Fator de Crista (Crest Factor)', `${safeFixed(crestValue, 2)} dB`, 'crestFactor', 'crestFactor', 'advanced'));
                } else {
                    console.warn('[METRICS-FIX] advancedMetricsCard > Fator de Crista NÃO ENCONTRADO ou inválido:', crestValue);
                }
                
                // 🟢 CARD 3: MÉTRICAS AVANÇADAS - Sub-bandas espectrais REMOVIDAS (movidas para col2)
                // === MÉTRICAS ESPECTRAIS AVANÇADAS ===
                
                // Centro Espectral
                if (Number.isFinite(analysis.technicalData?.spectralCentroid)) {
                    rows.push(row('Centro Espectral (Hz)', `${Math.round(analysis.technicalData.spectralCentroid)} Hz`, 'spectralCentroid', 'spectralCentroid', 'advanced'));
                }
                
                // Spectral Rolloff (Extensão de agudos)
                if (Number.isFinite(analysis.technicalData?.spectralRolloff)) {
                    rows.push(row('Rolloff Espectral 85% (Hz)', `${Math.round(analysis.technicalData.spectralRolloff)} Hz`, 'spectralRolloff', 'spectralRolloff', 'advanced'));
                }
                
                // Spectral Flatness (Uniformidade espectral) - OCULTADO DA UI (sempre retorna 0, métrica instável)
                // O cálculo permanece no backend, apenas não é exibido na interface
                // if (Number.isFinite(analysis.technicalData?.spectralFlatness)) {
                //     rows.push(row('Uniformidade Espectral (%)', `${safeFixed(analysis.technicalData.spectralFlatness * 100, 2)}%`, 'spectralFlatness', 'spectralFlatness', 'advanced'));
                // }
                
                // Spectral Bandwidth (Bandas espectrais)
                if (Number.isFinite(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))) {
                    rows.push(row('Largura Espectral (Hz)', `${safeHz(getMetric('spectral_bandwidth', 'spectralBandwidthHz'))}`, 'spectralBandwidthHz', 'spectralBandwidthHz', 'advanced'));
                }
                
                // Spectral Kurtosis
                if (Number.isFinite(analysis.technicalData?.spectralKurtosis)) {
                    rows.push(row('Kurtosis Espectral', `${safeFixed(analysis.technicalData.spectralKurtosis, 3)}`, 'spectralKurtosis', 'spectralKurtosis', 'advanced'));
                }
                
                // Spectral Skewness
                if (Number.isFinite(analysis.technicalData?.spectralSkewness)) {
                    rows.push(row('Assimetria Espectral', `${safeFixed(analysis.technicalData.spectralSkewness, 3)}`, 'spectralSkewness', 'spectralSkewness', 'advanced'));
                }
                
                // === REMOVIDO: BANDAS ESPECTRAIS DETALHADAS (Sub, Bass, Low-Mid, etc.) ===
                // As sub-bandas espectrais foram movidas para o card "ANÁLISE DE FREQUÊNCIAS" (col2)
                // Comentado para evitar duplicação
                
                if (false && Object.keys({}).length > 0) {
                    // REMOVIDO: Código de bandas espectrais (sub, bass, lowMid, etc.)
                    // As sub-bandas espectrais foram movidas para col2 (ANÁLISE DE FREQUÊNCIAS)
                    // Este bloco foi comentado para evitar duplicação
                }
                
                // 🧩 CORREÇÃO #5: Exibir frequências dominantes e uniformidade espectral
                // === FREQUÊNCIAS DOMINANTES ===
                if (Array.isArray(analysis.technicalData?.dominantFrequencies) && analysis.technicalData.dominantFrequencies.length > 0) {
                    const freqList = analysis.technicalData.dominantFrequencies
                        .slice(0, 5)
                        .map(f => `${Math.round(f)}Hz`)
                        .join(', ');
                    rows.push(row('Frequências Dominantes', freqList, 'dominantFrequencies', 'dominantFrequencies', 'advanced'));
                    console.log('🎛️ [DEBUG] Frequências dominantes exibidas:', freqList);
                }
                
                // === UNIFORMIDADE ESPECTRAL === (OCULTADO DA UI - métrica instável, sempre retorna 0)
                // O cálculo permanece no backend, apenas não é exibido na interface
                // if (Number.isFinite(analysis.technicalData?.spectralUniformity)) {
                //     rows.push(row('uniformidade espectral', `${safeFixed(analysis.technicalData.spectralUniformity, 3)}`, 'spectralUniformity'));
                //     console.log('🎛️ [DEBUG] Uniformidade espectral exibida:', analysis.technicalData.spectralUniformity);
                // }
                
                // === ZEROS CROSSING RATE ===
                if (Number.isFinite(analysis.technicalData?.zcr)) {
                    rows.push(row('Zero Crossings Rate', `${Math.round(analysis.technicalData.zcr)}`, 'zeroCrossings', 'zeroCrossings', 'advanced'));
                }
                
                // === MFCC (primeiros coeficientes) ===
                if (Array.isArray(analysis.technicalData?.mfcc) && analysis.technicalData.mfcc.length > 0) {
                    analysis.technicalData.mfcc.slice(0, 3).forEach((coeff, idx) => {
                        if (Number.isFinite(coeff)) {
                            const mfccKey = `mfcc${idx + 1}`;
                            rows.push(row(`MFCC ${idx + 1}`, `${safeFixed(coeff, 3)}`, mfccKey, mfccKey, 'advanced'));
                        }
                    });
                }
                
                // === SUGESTÕES DISPONÍVEIS (movido de SCORES & DIAGNÓSTICO) ===
                const suggestionsCount = analysis.suggestions?.length || 0;
                console.log('[AUDITORIA-SUGESTOES] Sugestões detectadas:', suggestionsCount);
                
                if (suggestionsCount > 0) {
                    rows.push(row('Sugestões', `<span class="tag tag-success">${suggestionsCount} DISPONÍVEL${suggestionsCount > 1 ? 'S' : ''}</span>`, 'suggestions', 'suggestions', 'advanced'));
                }
                
                return rows.join('') || row('Status', 'Sem métricas avançadas disponíveis');
            };

            // Card extra: Problemas Técnicos detalhados
            const techProblems = () => {
                const rows = [];
                let hasActualProblems = false;
                
                // ===== SEMPRE MOSTRAR TODAS AS MÉTRICAS TÉCNICAS =====
                
                // 1. Clipping - SEMPRE mostrar com valores reais
                const clipVal = Number.isFinite(analysis.technicalData?.clippingSamples) ? analysis.technicalData.clippingSamples : 0;
                const clipPct = Number.isFinite(analysis.technicalData?.clippingPct) ? analysis.technicalData.clippingPct : 0;
                // 🎯 CLIPPING PRECEDENCE V2: Usar nova lógica de precedência
                const peak = Number.isFinite(analysis.technicalData?.peak) ? analysis.technicalData.peak : -Infinity;
                const truePeak = Number.isFinite(analysis.technicalData?.truePeakDbtp) ? analysis.technicalData.truePeakDbtp : null;
                
                // Verificar se temos dados do novo sistema de precedência
                const precedenceData = analysis.technicalData?._singleStage;
                let hasClippingProblem, clipText, clipClass;
                
                if (precedenceData && precedenceData.source === 'enhanced-clipping-v2') {
                    // 🚀 Usar novo sistema de precedência
                    const isClipped = precedenceData.finalState === 'CLIPPED';
                    const isTruePeakOnly = precedenceData.finalState === 'TRUE_PEAK_ONLY';
                    hasClippingProblem = isClipped || isTruePeakOnly;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = isClipped ? 'error' : 'warn'; // CLIPPED é mais severo que TRUE_PEAK_ONLY
                        
                        const details = [];
                        if (isClipped) {
                            details.push(`🔴 CLIPPED: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                            if (precedenceData.precedenceApplied) {
                                details.push(`TP override: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                            }
                        } else if (isTruePeakOnly) {
                            details.push(`🟡 TruePeak: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        }
                        
                        if (precedenceData.clippingSamples > 0) {
                            details.push(`${precedenceData.clippingSamples} samples (${precedenceData.clippingPct.toFixed(3)}%)`);
                        }
                        
                        clipText = details.join(' | ');
                    } else {
                        // Estado limpo com novo sistema
                        const safeDetails = [];
                        safeDetails.push(`✅ Sample: ${precedenceData.samplePeakMaxDbFS.toFixed(2)}dBFS`);
                        safeDetails.push(`TP: ${precedenceData.truePeakDbTP.toFixed(2)}dBTP`);
                        safeDetails.push(`${precedenceData.clippingSamples} samples`);
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                } else {
                    // 🔄 Fallback para sistema legado
                    const hasPeakClipping = peak > -0.1;
                    const hasTruePeakClipping = truePeak !== null && truePeak > -0.1;
                    const hasSampleClipping = clipVal > 0;
                    const hasPercentageClipping = clipPct > 0;
                    
                    hasClippingProblem = hasPeakClipping || hasTruePeakClipping || hasSampleClipping || hasPercentageClipping;
                    
                    if (hasClippingProblem) {
                        hasActualProblems = true;
                        clipClass = 'warn';
                        
                        const details = [];
                        if (hasPeakClipping) details.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (hasTruePeakClipping) details.push(`TruePeak: ${truePeak.toFixed(2)}dBTP`);
                        if (hasSampleClipping) details.push(`${clipVal} samples (${clipPct.toFixed(3)}%)`);
                        
                        clipText = details.join(' | ');
                    } else {
                        const safeDetails = [];
                        safeDetails.push(`${clipVal} samples`);
                        if (peak > -Infinity) safeDetails.push(`Peak: ${peak.toFixed(2)}dB`);
                        if (truePeak !== null) safeDetails.push(`TP: ${truePeak.toFixed(2)}dBTP`);
                        
                        clipText = safeDetails.join(' | ');
                        clipClass = '';
                    }
                }
                rows.push(row('Clipping', `<span class="${clipClass}">${clipText}</span>`, 'clippingSamples', 'clippingSamples', 'advanced'));
                
                // 2. DC Offset - SEMPRE mostrar (usando nova estrutura)
                let dcVal, hasDcProblem, dcClass;
                if (analysis.dcOffset && Number.isFinite(analysis.dcOffset.maxAbsDC)) {
                    // Usar nova estrutura detalhada
                    dcVal = analysis.dcOffset.maxAbsDC;
                    hasDcProblem = analysis.dcOffset.needsCorrection || analysis.dcOffset.severity !== 'none';
                    dcClass = hasDcProblem ? (analysis.dcOffset.isCritical ? 'error' : 'warn') : '';
                    if (hasDcProblem) hasActualProblems = true;
                    const dcDetails = `Max: ${safeFixed(dcVal, 4)} | L: ${safeFixed(analysis.dcOffset.leftDC, 4)} | R: ${safeFixed(analysis.dcOffset.rightDC, 4)} | ${analysis.dcOffset.severity}`;
                    rows.push(row('DC Offset (Detalhado)', `<span class="${dcClass}">${dcDetails}</span>`, 'dcOffset', 'dcOffset', 'advanced'));
                } else {
                    // Fallback para estrutura legada
                    dcVal = Number.isFinite(analysis.technicalData?.dcOffset) ? analysis.technicalData.dcOffset : 0;
                    hasDcProblem = Math.abs(dcVal) > 0.01;
                    if (hasDcProblem) hasActualProblems = true;
                    dcClass = hasDcProblem ? 'warn' : '';
                    rows.push(row('DC Offset', `<span class="${dcClass}">${safeFixed(dcVal, 4)}</span>`, 'dcOffset', 'dcOffset', 'advanced'));
                }
                
                // 3. THD - SEMPRE mostrar
                const thdVal = Number.isFinite(analysis.technicalData?.thdPercent) ? analysis.technicalData.thdPercent : 0;
                const hasThdProblem = thdVal > 1.0;
                if (hasThdProblem) hasActualProblems = true;
                const thdClass = hasThdProblem ? 'warn' : '';
                rows.push(row('THD', `<span class="${thdClass}">${safeFixed(thdVal, 2)}%</span>`, 'thdPercent', 'thdPercent', 'advanced'));
                
                // 4. Stereo Correlation - SEMPRE mostrar
                const stereoCorr = Number.isFinite(analysis.technicalData?.stereoCorrelation) ? analysis.technicalData.stereoCorrelation : 0;
                const hasStereoProb = stereoCorr !== null && (stereoCorr < -0.3 || stereoCorr > 0.95);
                if (hasStereoProb) hasActualProblems = true;
                const stereoClass = hasStereoProb ? 'warn' : '';
                let stereoText = safeFixed(stereoCorr, 3);
                if (hasStereoProb) {
                    const status = stereoCorr < -0.3 ? 'Fora de fase' : 'Mono demais';
                    stereoText += ` (${status})`;
                }
                rows.push(row('Stereo Corr.', `<span class="${stereoClass}">${stereoText}</span>`, 'stereoCorrelation', 'stereoCorrelation', 'advanced'));
                
                // 5. Fator de Crista - SEMPRE mostrar  
                const crestVal = Number.isFinite(analysis.technicalData?.crestFactor) ? analysis.technicalData.crestFactor : 0;
                const hasCrestProblem = crestVal < 6 || crestVal > 20; // Valores normais: 6-20dB
                if (hasCrestProblem) hasActualProblems = true;
                const crestClass = hasCrestProblem ? 'warn' : '';
                rows.push(row('Fator de Crista', `<span class="${crestClass}">${safeFixed(crestVal, 1)} dB</span>`, 'crestFactor', 'crestFactor', 'advanced'));
                
                // Consistência (se disponível) - mas sempre tentar mostrar
                if (analysis.metricsValidation && Object.keys(analysis.metricsValidation).length) {
                    const mv = analysis.metricsValidation;
                    const badge = (k,v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:${v==='ok'?'#143f2b':(v==='warn'?'#4d3808':'#4a1d1d')};color:${v==='ok'?'#29c182':(v==='warn'?'#ffce4d':'#ff7d7d')};margin-left:6px;">${v}</span>`;
                    
                    if (mv.dynamicRangeConsistency) {
                        rows.push(row('DR Consistência', `Δ=${mv.dynamicRangeDelta || '0'} ${badge('dr', mv.dynamicRangeConsistency)}`, 'drConsistency', 'drConsistency', 'advanced'));
                        if (mv.dynamicRangeConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('DR Consistência', `<span style="opacity:0.6;">Δ=0 ${badge('dr', 'ok')}</span>`, 'drConsistency', 'drConsistency', 'advanced'));
                    }
                    
                    if (mv.crestFactorConsistency) {
                        rows.push(row('Crest Consist.', `Δ=${mv.crestVsExpectedDelta || '0'} ${badge('cf', mv.crestFactorConsistency)}`, 'crestConsistency', 'crestConsistency', 'advanced'));
                        if (mv.crestFactorConsistency !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Δ=0 ${badge('cf', 'ok')}</span>`, 'crestConsistency', 'crestConsistency', 'advanced'));
                    }
                    
                    if (mv.lraPlausibility) {
                        rows.push(row('LRA Plausível', badge('lra', mv.lraPlausibility), 'lraPlausibility', 'lraPlausibility', 'advanced'));
                        if (mv.lraPlausibility !== 'ok') hasActualProblems = true;
                    } else {
                        rows.push(row('LRA Plausível', `<span style="opacity:0.6;">${badge('lra', 'ok')}</span>`, 'lraPlausibility', 'lraPlausibility', 'advanced'));
                    }
                } else {
                    // Mostrar como não disponível/OK
                    const badge = (v) => `<span style="padding:2px 6px;border-radius:4px;font-size:11px;background:#143f2b;color:#29c182;margin-left:6px;">${v}</span>`;
                    rows.push(row('DR Consistência', `<span style="opacity:0.6;">Δ=0 ${badge('ok')}</span>`, 'drConsistency', 'drConsistency', 'advanced'));
                    rows.push(row('Crest Consist.', `<span style="opacity:0.6;">Δ=0 ${badge('ok')}</span>`, 'crestConsistency', 'crestConsistency', 'advanced'));
                    rows.push(row('LRA Plausível', `<span style="opacity:0.6;">${badge('ok')}</span>`, 'lraPlausibility', 'lraPlausibility', 'advanced'));
                }
                
                return rows.join('');
            };

            // Card extra: Diagnóstico & Sugestões listados
            const diagCard = () => {
                // =========================================================================
                // 🚨 AUDITORIA: RENDERIZAÇÃO DE SUGESTÕES
                // =========================================================================
                console.log('[RENDER_SUGGESTIONS] ✅ Iniciada');
                
                const blocks = [];
                
                // 🔍 DEBUG: Verificar estado das sugestões
                console.log('🔍 [DEBUG_SUGGESTIONS] analysis.suggestions:', analysis.suggestions);
                console.log('🔍 [DEBUG_SUGGESTIONS] análise completa de sugestões:', {
                    hasAnalysis: !!analysis,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsType: typeof analysis.suggestions,
                    suggestionsLength: analysis.suggestions?.length || 0,
                    suggestionsArray: analysis.suggestions
                });

                // ═══════════════════════════════════════════════════════════════════
                // 🎯 NORMALIZAÇÃO E VALIDAÇÃO BASEADA NA TABELA
                // ═══════════════════════════════════════════════════════════════════
                
                /**
                 * Normaliza nomes de severidade para padrão único
                 * @param {string|object} sev - Severidade (string ou objeto com .level/.label)
                 * @returns {string} - 'OK', 'ATENÇÃO', 'ALTA', 'CRÍTICA', 'N/A'
                 */
                const normalizeSeverity = (sev) => {
                    if (!sev) return 'N/A';
                    
                    const str = (typeof sev === 'object' ? (sev.level || sev.label || '') : String(sev)).toLowerCase().trim();
                    
                    // Mapear variações para padrão da tabela
                    if (str === 'ok' || str === 'ideal' || str === 'perfeito') return 'OK';
                    if (str.includes('aten') || str === 'warning' || str === 'caution' || str === 'ajuste_leve' || str === 'leve') return 'ATENÇÃO';
                    if (str.includes('alt') || str === 'high') return 'ALTA';
                    if (str.includes('crit') || str.includes('crít') || str === 'corrigir' || str === 'severa' || str === 'critical') return 'CRÍTICA';
                    
                    // Se não reconhecer, assumir que precisa atenção
                    return 'ATENÇÃO';
                };
                
                /**
                 * Normaliza chaves de métricas para buscar nos dados
                 * @param {string} key - Chave da métrica
                 * @returns {string} - Chave normalizada
                 */
                const normalizeMetricKey = (key) => {
                    if (!key) return '';
                    const k = String(key).toLowerCase().replace(/[^a-z0-9_]/g, '');
                    
                    // Métricas principais
                    if (k.includes('loudness') || k.includes('lufs') || k === 'lufsintegrated') return 'loudness_integrated';
                    if (k.includes('truepeak') || k.includes('dbtp') || k === 'tp') return 'true_peak';
                    if (k.includes('dynamic') || k === 'dr') return 'dynamics';
                    if (k === 'lra' || k.includes('loudnessrange')) return 'lra';
                    if (k.includes('stereo') || k.includes('image')) return 'stereo';
                    
                    return k;
                };
                
                /**
                 * Normaliza chaves de bandas espectrais
                 * @param {string} key - Chave da banda
                 * @returns {string} - Chave normalizada
                 */
                const normalizeBandKey = (key) => {
                    if (!key) return '';
                    const k = String(key).toLowerCase().replace(/[^a-z0-9_]/g, '');
                    
                    // Remover prefixo band_ se existir
                    const clean = k.replace(/^band_/, '');
                    
                    // Mapeamento de aliases
                    if (clean === 'sub' || clean === 'subbass') return 'sub';
                    if (clean === 'bass' || clean === 'lowbass' || clean === 'low_bass') return 'bass';
                    if (clean === 'upperbass' || clean === 'upper_bass') return 'upperBass';
                    if (clean === 'lowmid' || clean === 'low_mid') return 'lowMid';
                    if (clean === 'mid' || clean === 'midrange') return 'mid';
                    if (clean === 'highmid' || clean === 'high_mid') return 'highMid';
                    if (clean === 'presence' || clean === 'presenca' || clean === 'presença') return 'presence';
                    if (clean === 'air' || clean === 'brilliance' || clean === 'brilho') return 'air';
                    
                    return clean;
                };
                
                /**
                 * Calcula severidade da métrica usando MESMA LÓGICA DA TABELA
                 * @param {number} value - Valor medido
                 * @param {number} target - Valor target
                 * @param {number} tolerance - Tolerância
                 * @param {object} options - { targetRange }
                 * @returns {object} - { severity, diff, action }
                 */
                const calcTableSeverity = (value, target, tolerance, options = {}) => {
                    const { targetRange } = options;
                    
                    if (!Number.isFinite(value)) {
                        return { severity: 'N/A', diff: 0, action: 'Sem dados' };
                    }
                    
                    // PRIORIDADE: target_range
                    if (targetRange && typeof targetRange === 'object') {
                        const min = targetRange.min ?? targetRange.min_db;
                        const max = targetRange.max ?? targetRange.max_db;
                        
                        if (typeof min === 'number' && typeof max === 'number') {
                            // Dentro do range = OK
                            if (value >= min && value <= max) {
                                return { severity: 'OK', diff: 0, action: '✅ Dentro do padrão' };
                            }
                            
                            // Fora do range: calcular distância
                            let diff, absDelta;
                            if (value < min) {
                                diff = value - min;
                                absDelta = min - value;
                            } else {
                                diff = value - max;
                                absDelta = value - max;
                            }
                            
                            if (absDelta >= 2) {
                                const action = diff > 0 ? `Reduzir ${absDelta.toFixed(1)}` : `Aumentar ${absDelta.toFixed(1)}`;
                                return { severity: 'CRÍTICA', diff, action };
                            } else {
                                const action = diff > 0 ? `Reduzir ${absDelta.toFixed(1)}` : `Aumentar ${absDelta.toFixed(1)}`;
                                return { severity: 'ATENÇÃO', diff, action };
                            }
                        }
                    }
                    
                    // FALLBACK: target ± tolerance
                    if (target === null || target === undefined) {
                        return { severity: 'N/A', diff: 0, action: 'Sem dados' };
                    }
                    
                    const diff = value - target;
                    const absDiff = Math.abs(diff);
                    
                    if (absDiff <= tolerance) {
                        return { severity: 'OK', diff, action: '✅ Dentro do padrão' };
                    } else if (absDiff <= tolerance * 2) {
                        return { severity: 'ATENÇÃO', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    } else if (absDiff <= tolerance * 3) {
                        return { severity: 'ALTA', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    } else {
                        return { severity: 'CRÍTICA', diff, action: diff > 0 ? `Reduzir ${absDiff.toFixed(1)}` : `Aumentar ${absDiff.toFixed(1)}` };
                    }
                };
                
                // ═══════════════════════════════════════════════════════════════════
                // 🛡️ FILTRO MASTER: Validar cada sugestão contra severidade da TABELA
                // ═══════════════════════════════════════════════════════════════════
                
                const validateSuggestionAgainstTable = (sug) => {
                    try {
                        // Extrair dados da análise
                        const metrics = analysis?.data?.metrics;
                        const targets = analysis?.data?.genreTargets;
                        
                        if (!metrics || !targets) {
                            console.warn('[SUGGESTION_VALIDATOR] Sem metrics/targets - permitindo sugestão', sug.metric);
                            return { valid: true, reason: 'no_data_to_validate' };
                        }
                        
                        // Normalizar métrica/banda
                        const metricRaw = sug.metric || sug.type || '';
                        const isBand = metricRaw.includes('band_') || metricRaw.includes('Bass') || metricRaw.includes('Mid') || metricRaw.includes('Sub');
                        
                        let measuredValue = null;
                        let targetConfig = null;
                        let metricName = '';
                        
                        if (isBand) {
                            const bandKey = normalizeBandKey(metricRaw);
                            metricName = `band_${bandKey}`;
                            
                            // Buscar valor medido
                            const bandData = metrics.bands?.[bandKey];
                            if (bandData) {
                                measuredValue = bandData.energy_db ?? bandData.rms_db ?? bandData.db ?? bandData.value;
                            }
                            
                            // Buscar target
                            targetConfig = targets.bands?.[bandKey];
                        } else {
                            const metricKey = normalizeMetricKey(metricRaw);
                            metricName = metricKey;
                            
                            // Mapeamento de métricas principais
                            const metricMap = {
                                'loudness_integrated': { key: 'loudness', targetKey: 'lufs', tolKey: 'tol_lufs' },
                                'true_peak': { key: 'truePeak', targetKey: 'truePeak', tolKey: 'tol_true_peak' },
                                'dynamics': { key: 'dr', targetKey: 'dr', tolKey: 'tol_dr' },
                                'lra': { key: 'lra', targetKey: 'lra', tolKey: 'tol_lra' },
                                'stereo': { key: 'stereo', targetKey: 'stereo', tolKey: 'tol_stereo' }
                            };
                            
                            const mapping = metricMap[metricKey];
                            if (mapping) {
                                const metricData = metrics[mapping.key];
                                measuredValue = metricData?.value ?? metricData;
                                
                                targetConfig = {
                                    target: targets[mapping.targetKey]?.target,
                                    tolerance: targets[mapping.targetKey]?.tolerance ?? targets[mapping.tolKey] ?? 1.0,
                                    target_range: targets[mapping.targetKey]?.target_range
                                };
                            }
                        }
                        
                        // Se não conseguiu encontrar valor ou target, permitir (fail-safe)
                        if (!Number.isFinite(measuredValue) || !targetConfig) {
                            console.warn('[SUGGESTION_VALIDATOR] ⚠️ Não encontrou dados para validar:', {
                                metric: metricName,
                                measuredValue,
                                hasTarget: !!targetConfig
                            });
                            return { valid: true, reason: 'incomplete_data' };
                        }
                        
                        // Calcular severidade usando MESMA lógica da tabela
                        const tableSeverity = calcTableSeverity(
                            measuredValue,
                            targetConfig.target ?? targetConfig.target_db,
                            targetConfig.tolerance ?? targetConfig.tol_db ?? 2.0,
                            { targetRange: targetConfig.target_range }
                        );
                        
                        // Normalizar severidade da sugestão
                        const sugSeverity = normalizeSeverity(sug.severity);
                        
                        // REGRA ABSOLUTA: Se tabela diz OK, PROIBIR sugestão
                        if (tableSeverity.severity === 'OK') {
                            console.log(`[SUGGESTION_VALIDATOR] ❌ BLOQUEADO: ${metricName} está OK na tabela`, {
                                measured: measuredValue.toFixed(2),
                                tableSeverity: tableSeverity.severity,
                                sugSeverity: sugSeverity,
                                diff: tableSeverity.diff
                            });
                            return { valid: false, reason: 'table_says_ok', tableSeverity: 'OK' };
                        }
                        
                        // Se tabela diz que precisa atenção/correção, PERMITIR
                        console.log(`[SUGGESTION_VALIDATOR] ✅ PERMITIDO: ${metricName}`, {
                            measured: measuredValue.toFixed(2),
                            tableSeverity: tableSeverity.severity,
                            sugSeverity: sugSeverity,
                            diff: tableSeverity.diff
                        });
                        
                        return { 
                            valid: true, 
                            reason: 'table_confirms_issue',
                            tableSeverity: tableSeverity.severity,
                            tableCalc: tableSeverity
                        };
                        
                    } catch (error) {
                        console.error('[SUGGESTION_VALIDATOR] Erro ao validar:', error);
                        return { valid: true, reason: 'validation_error' };  // Fail-safe: permitir em caso de erro
                    }
                };

                // 🚀 INTEGRAÇÃO SISTEMA ULTRA-AVANÇADO V2: Enriquecimento direto das sugestões existentes
                let enrichedSuggestions = analysis.suggestions || [];
                
                if (typeof window.UltraAdvancedSuggestionEnhancer !== 'undefined' && enrichedSuggestions.length > 0) {
                    try {
                        console.log('🚀 [ULTRA_V2] Iniciando sistema ultra-avançado V2...');
                        console.log('📊 [ULTRA_V2] Sugestões para enriquecer:', enrichedSuggestions.length);
                        
                        const ultraEnhancer = new window.UltraAdvancedSuggestionEnhancer();
                        
                        // Preparar contexto de análise
                        const analysisContext = {
                            detectedGenre: analysis.detectedGenre || 'general',
                            fileName: analysis.fileName,
                            duration: analysis.duration,
                            sampleRate: analysis.sampleRate,
                            mode: analysis.mode || 'genre',
                            // ✅ MODO REFERENCE: Adicionar dados de comparação A/B
                            referenceComparison: analysis.referenceComparison || null,
                            referenceJobId: analysis.referenceJobId || null,
                            referenceFileName: analysis.referenceFileName || null
                        };
                        
                        // 🎯 MODO GENRE: Usar EXCLUSIVAMENTE analysis.data (metrics + genreTargets)
                        // ❌ SEM FALLBACKS - se não existir, lista vazia
                        if (analysis.mode === "genre") {
                            // ✅ EXTRAIR METRICS de analysis.data.metrics
                            const metrics = analysis?.data?.metrics;
                            const correctTargets = getCorrectTargets(analysis);
                            
                            if (!metrics) {
                                console.error('[ULTRA_V2] ❌ CRÍTICO: analysis.data.metrics não encontrado');
                                throw new Error('NO_METRICS_FROM_BACKEND');
                            }
                            
                            if (!correctTargets) {
                                console.error('[ULTRA_V2] ❌ CRÍTICO: analysis.data.genreTargets não encontrado (Postgres)');
                                throw new Error('NO_TARGETS_FROM_POSTGRES');
                            }
                            
                            console.log('[ULTRA_V2] ✅ Injetando metrics e correctTargets em analysisContext');
                            console.log('[ULTRA_V2] Metrics:', {
                                loudness: metrics.loudness,
                                truePeak: metrics.truePeak,
                                dr: metrics.dr,
                                stereo: metrics.stereo,
                                hasBands: !!metrics.bands
                            });
                            console.log('[ULTRA_V2] Targets:', {
                                lufs: correctTargets.lufs,
                                truePeak: correctTargets.truePeak,
                                dr: correctTargets.dr,
                                stereo: correctTargets.stereo,
                                hasBands: !!correctTargets.bands
                            });
                            
                            // ✅ INJETAR NO CONTEXT
                            analysisContext.metrics = metrics;
                            analysisContext.correctTargets = correctTargets;
                        }
                        // 🛡️ MODO REFERENCE: Não injetar nada - usa dados de comparação A/B
                        
                        // ✅ Log para modo reference
                        if (analysisContext.mode === 'reference' && analysisContext.referenceComparison) {
                            console.log('[ULTRA_V2] 🎯 Modo reference detectado - enriquecendo com dados de comparação A/B');
                            console.log('[ULTRA_V2] Referência:', analysisContext.referenceFileName);
                            console.log('[ULTRA_V2] Deltas disponíveis:', Object.keys(analysisContext.referenceComparison));
                        }
                        
                        // 🚀 Enriquecer sugestões existentes
                        const ultraResults = ultraEnhancer.enhanceExistingSuggestions(enrichedSuggestions, analysisContext);
                        
                        if (ultraResults && ultraResults.enhancedSuggestions && ultraResults.enhancedSuggestions.length > 0) {
                            enrichedSuggestions = ultraResults.enhancedSuggestions;
                            
                            console.log('✨ [ULTRA_V2] Sistema ultra-avançado V2 aplicado com sucesso!', {
                                originalCount: analysis.suggestions?.length || 0,
                                enhancedCount: enrichedSuggestions.length,
                                processingTime: ultraResults.metadata?.processingTimeMs,
                                educationalLevel: ultraResults.metadata?.educationalLevel
                            });
                            
                            // Adicionar métricas do sistema ultra-avançado à análise
                            if (!analysis.enhancedMetrics) analysis.enhancedMetrics = {};
                            analysis.enhancedMetrics.ultraAdvancedSystem = {
                                applied: true,
                                version: ultraResults.metadata?.version,
                                processingTimeMs: ultraResults.metadata?.processingTimeMs,
                                enhancedCount: enrichedSuggestions.length,
                                educationalLevel: ultraResults.metadata?.educationalLevel,
                                originalCount: ultraResults.metadata?.originalCount
                            };
                            
                            // ✅ Log da primeira sugestão enriquecida para debug
                            if (enrichedSuggestions.length > 0) {
                                const firstEnhanced = enrichedSuggestions[0];
                                console.log('🎓 [ULTRA_V2] Exemplo de sugestão enriquecida:', {
                                    original: firstEnhanced.message,
                                    educationalTitle: firstEnhanced.educationalContent?.title,
                                    hasDAWExamples: !!(firstEnhanced.educationalContent?.dawExamples),
                                    severity: firstEnhanced.severity?.label,
                                    priority: firstEnhanced.priority
                                });
                            }
                            
                            // ═══════════════════════════════════════════════════════════════
                            // ✅ VALIDAÇÃO FINAL: Confirmar sistema configurado corretamente
                            // ═══════════════════════════════════════════════════════════════
                            if (analysisContext.mode === 'genre' && analysisContext.correctTargets && analysisContext.metrics) {
                                console.log('');
                                console.log('═══════════════════════════════════════════════════════════════');
                                console.log('✅ [VALIDAÇÃO FINAL] Sistema de Sugestões IA Configurado');
                                console.log('═══════════════════════════════════════════════════════════════');
                                console.log('📊 Fonte de Metrics: analysis.data.metrics');
                                console.log('📊 Fonte de Targets: analysis.data.genreTargets (Postgres)');
                                console.log('📊 Modo de Análise:', analysisContext.mode);
                                console.log('📊 Metrics Injetados:', {
                                    loudness: analysisContext.metrics.loudness?.value,
                                    truePeak: analysisContext.metrics.truePeak?.value,
                                    dr: analysisContext.metrics.dr?.value,
                                    stereo: analysisContext.metrics.stereo?.value
                                });
                                console.log('📊 Targets Injetados:', {
                                    lufs: analysisContext.correctTargets.lufs?.target,
                                    truePeak: analysisContext.correctTargets.truePeak?.target,
                                    dr: analysisContext.correctTargets.dr?.target,
                                    stereo: analysisContext.correctTargets.stereo?.target
                                });
                                console.log('📊 Diferenças Calculadas:', {
                                    lufs: (analysisContext.metrics.loudness?.value - analysisContext.correctTargets.lufs?.target).toFixed(2),
                                    truePeak: (analysisContext.metrics.truePeak?.value - analysisContext.correctTargets.truePeak?.target).toFixed(2),
                                    dr: (analysisContext.metrics.dr?.value - analysisContext.correctTargets.dr?.target).toFixed(2),
                                    stereo: (analysisContext.metrics.stereo?.value - analysisContext.correctTargets.stereo?.target).toFixed(4)
                                });
                                console.log('📊 Total de Sugestões Enriquecidas:', enrichedSuggestions.length);
                                console.log('═══════════════════════════════════════════════════════════════');
                                console.log('');
                            }
                            
                        } else {
                            console.warn('⚠️ [ULTRA_V2] Sistema não retornou sugestões válidas:', ultraResults);
                        }
                        
                    } catch (error) {
                        console.error('❌ [ULTRA_V2] Erro no sistema ultra-avançado V2:', error);
                        // Manter sugestões originais em caso de erro
                    }
                } else {
                    if (typeof window.UltraAdvancedSuggestionEnhancer === 'undefined') {
                        console.log('⚠️ [ULTRA_V2] Sistema ultra-avançado V2 não está disponível');
                    } else {
                        console.log('⚠️ [ULTRA_V2] Nenhuma sugestão para processar');
                    }
                }
                
                // 🛡️ FILTRO MASTER: Validar TODAS as sugestões contra severidade da TABELA
                console.log('[SUGGESTION_FILTER] ═══════════════════════════════════════════');
                console.log('[SUGGESTION_FILTER] Iniciando validação de', enrichedSuggestions.length, 'sugestões');
                
                let countOk = 0;
                let countBlocked = 0;
                let countAllowed = 0;
                let countErrors = 0;
                
                const validatedSuggestions = enrichedSuggestions.filter((s, idx) => {
                    const validation = validateSuggestionAgainstTable(s);
                    
                    if (!validation.valid) {
                        countBlocked++;
                        if (validation.tableSeverity === 'OK') countOk++;
                        console.log(`[SUGGESTION_FILTER] ❌ #${idx + 1} BLOQUEADO:`, {
                            metric: s.metric || s.type,
                            reason: validation.reason,
                            tableSeverity: validation.tableSeverity
                        });
                        return false;
                    }
                    
                    countAllowed++;
                    if (validation.reason === 'validation_error') countErrors++;
                    return true;
                });
                
                console.log('[SUGGESTION_FILTER] ═══════════════════════════════════════════');
                console.log('[SUGGESTION_FILTER] 📊 RESULTADO DA VALIDAÇÃO:');
                console.log('[SUGGESTION_FILTER]   - Total recebidas:', enrichedSuggestions.length);
                console.log('[SUGGESTION_FILTER]   - ✅ Permitidas:', countAllowed);
                console.log('[SUGGESTION_FILTER]   - ❌ Bloqueadas:', countBlocked);
                console.log('[SUGGESTION_FILTER]   - 🔴 Falso-positivos (OK na tabela):', countOk);
                console.log('[SUGGESTION_FILTER]   - ⚠️ Erros de validação:', countErrors);
                console.log('[SUGGESTION_FILTER] ═══════════════════════════════════════════');
                
                // Atualizar analysis.suggestions com as sugestões validadas
                analysis.suggestions = validatedSuggestions;

                // Helpers para embelezar as sugestões sem mudar layout/IDs
                const formatNumbers = (text, decimals = 2) => {
                    if (!text || typeof text !== 'string') return '';
                    return text.replace(/(-?\d+\.\d{3,})/g, (m) => {
                        const n = parseFloat(m);
                        return Number.isFinite(n) ? n.toFixed(decimals) : m;
                    });
                };
                const renderSuggestionItem = (sug) => {
                    // 🚀 PRIORIDADE: Verificar se tem conteúdo educacional do Sistema Ultra-Avançado V2
                    const hasUltraV2Content = sug.educationalContent && sug.educationalContent.title;
                    
                    if (hasUltraV2Content) {
                        // � SISTEMA ULTRA-AVANÇADO V2: Renderizar com conteúdo educacional completo
                        const edu = sug.educationalContent;
                        const severity = sug.severity || { level: 'medium', color: '#FF9800', label: 'Moderada' };
                        
                        // Extrair frequência se disponível
                        const freqMatch = (edu.action || sug.action || '').match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz|khz|kHz)/i);
                        const frequency = freqMatch ? freqMatch[1] : null;
                        
                        return `
                            <div class="enhanced-card ultra-advanced-v2">
                                <div class="card-header">
                                    <h4 class="card-title">${edu.title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency}${frequency > 1000 ? 'Hz' : 'kHz'}</span>` : ''}
                                        <span class="severity-badge ${severity.level}" style="background-color: ${severity.color};">${severity.label}</span>
                                        <span class="priority-badge">P${sug.priority || 5}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: ${severity.color};">
                                    <strong>📚 Explicação:</strong> ${edu.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50;">
                                    <div class="card-action-title">🔧 Ação Recomendada</div>
                                    <div class="card-action-content">${edu.action}</div>
                                </div>
                                
                                ${edu.dawExamples ? `
                                    <div class="card-daw-examples" style="background: rgba(33, 150, 243, 0.1); border-color: #2196F3; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #2196F3;">
                                        <div class="card-daw-title" style="font-weight: bold; margin-bottom: 8px; color: #2196F3;">🎛️ Exemplos por DAW</div>
                                        ${Object.entries(edu.dawExamples).map(([daw, instruction]) => 
                                            `<div style="margin-bottom: 6px;"><strong>${daw}:</strong> ${instruction}</div>`
                                        ).join('')}
                                    </div>
                                ` : ''}
                                
                                ${edu.expectedResult ? `
                                    <div class="card-result" style="background: rgba(76, 175, 80, 0.1); border-color: #4CAF50; margin: 12px 0; padding: 12px; border-radius: 6px; border-left: 3px solid #4CAF50;">
                                        <div class="card-result-title" style="font-weight: bold; margin-bottom: 8px; color: #4CAF50;">✨ Resultado Esperado</div>
                                        <div class="card-result-content">${edu.expectedResult}</div>
                                    </div>
                                ` : ''}
                                
                                ${edu.technicalDetails ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa; font-weight: bold;">📋 Detalhes Técnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;">${edu.technicalDetails}</div>
                                    </details>
                                ` : ''}
                                
                                ${sug.educationalMetadata ? `
                                    <div class="educational-metadata" style="margin-top: 12px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; font-size: 11px; color: #888;">
                                        📖 Tempo de leitura: ${sug.educationalMetadata.estimatedReadTime} | 
                                        🎯 Dificuldade: ${sug.educationalMetadata.practicalDifficulty} | 
                                        🧠 Conceitos: ${sug.educationalMetadata.concepts?.join(', ') || 'N/A'}
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    // 🔄 FALLBACK: Sistema anterior se não tiver conteúdo Ultra-Avançado V2
                    const hasTextGenerator = typeof window.SuggestionTextGenerator !== 'undefined';
                    let didacticText = null;
                    
                    if (hasTextGenerator) {
                        try {
                            const generator = new window.SuggestionTextGenerator();
                            didacticText = generator.generateDidacticText(sug);
                        } catch (error) {
                            console.warn('[RenderSuggestion] Erro no gerador de texto:', error);
                        }
                    }
                    
                    // Usar texto didático se disponível, senão usar texto original
                    const title = didacticText?.title || sug.message || '';
                    const explanation = didacticText?.explanation || sug.explanation || '';
                    const action = didacticText?.action || sug.action || '';
                    const rationale = didacticText?.rationale || '';
                    const technical = didacticText?.technical || sug.details || '';
                    
                    // 🎯 SISTEMA MELHORADO: Verificar se tem informações de severidade e prioridade
                    const hasEnhancedInfo = sug.severity && sug.priority;
                    const severityColor = hasEnhancedInfo ? sug.severity.color : '#9fb3d9';
                    const severityLevel = hasEnhancedInfo ? sug.severity.level : 'medium';
                    const severityLabel = hasEnhancedInfo ? sug.severity.label : '';
                    const priority = hasEnhancedInfo ? sug.priority : 0;
                    const confidence = hasEnhancedInfo ? sug.confidence : 1;
                    
                    // Detectar tipo de sugestão
                    const isSurgical = sug.type === 'surgical_eq' || (sug.subtype && ['sibilance', 'harshness', 'clipping'].includes(sug.subtype));
                    const isBandAdjust = sug.type === 'band_adjust';
                    const isClipping = sug.type === 'clipping' || title.toLowerCase().includes('clipping');
                    const isBalance = sug.type === 'balance' || title.toLowerCase().includes('balance');
                    
                    // Determinar classe do card
                    let cardClass = 'enhanced-card';
                    if (isSurgical) cardClass += ' surgical';
                    else if (isBandAdjust) cardClass += ' band-adjust';
                    else if (isClipping) cardClass += ' clipping';
                    else if (isBalance) cardClass += ' balance';
                    else cardClass += ' problem';
                    
                    // Extrair frequência e valores técnicos
                    const freqMatch = (title + ' ' + action).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                    const frequency = freqMatch ? freqMatch[1] : null;
                    
                    const dbMatch = action.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                    const dbValue = dbMatch ? dbMatch[1] : null;
                    
                    const qMatch = action.match(/Q\s*[=:]?\s*(\d+(?:\.\d+)?)/i);
                    const qValue = qMatch ? qMatch[1] : null;
                    
                    // Extrair faixa de frequência se disponível
                    const frequencyRange = sug.frequency_range || '';
                    const adjustmentDb = sug.adjustment_db;
                    
                    // 🚨 VERIFICAR SE É UM AVISO CRÍTICO
                    if (didacticText?.isCritical) {
                        return `
                            <div class="${cardClass} critical-alert">
                                <div class="card-header">
                                    <h4 class="card-title">🚨 Problema Crítico</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge severa">CRÍTICO</span>
                                    </div>
                                </div>
                                
                                <div class="card-description" style="border-left-color: #f44336;">
                                    <strong>⚠️ Problema:</strong> ${didacticText.explanation}
                                </div>
                                
                                <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                    <div class="card-action-title" style="color: #f44336;">
                                        🚨 Ação Urgente
                                    </div>
                                    <div class="card-action-content">${didacticText.action}</div>
                                </div>
                                
                                <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                    <div class="card-impact-title" style="color: #f44336;">⚠️ Por que é crítico</div>
                                    <div class="card-impact-content">${didacticText.rationale}</div>
                                </div>
                            </div>`;
                    }
                    
                    if (isSurgical) {
                        // Card cirúrgico aprimorado
                        const context = title.replace(/\[\d+Hz\]/, '').replace(/\d+Hz/, '').trim();
                        const severity = severityLevel === 'high' ? 'alta' : (severityLevel === 'medium' ? 'moderada' : 'leve');
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">🔧 Correção Cirúrgica</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severity}">${severity}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>Problema detectado:</strong> ${context || explanation || 'Ressonância problemática identificada'}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        🎛️ Ação Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequency || qValue || dbValue) ? `
                                    <div class="card-technical">
                                        ${frequency ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Frequência</div>
                                                <div class="tech-value">${frequency} Hz</div>
                                            </div>
                                        ` : ''}
                                        ${dbValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ganho</div>
                                                <div class="tech-value">${dbValue} dB</div>
                                            </div>
                                        ` : ''}
                                        ${qValue ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Q Factor</div>
                                                <div class="tech-value">${qValue}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">⚠️ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes Técnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    } 
                    
                    else if (isBandAdjust) {
                        // Card de ajuste de banda aprimorado
                        const shouldBoost = adjustmentDb > 0 || action.toLowerCase().includes('aumentar') || action.toLowerCase().includes('boost');
                        const actionIcon = shouldBoost ? '📈' : '📉';
                        const actionType = shouldBoost ? 'Boost' : 'Corte';
                        
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">${actionIcon} Ajuste de Banda</h4>
                                    <div class="card-badges">
                                        ${frequencyRange ? `<span class="frequency-badge">${frequencyRange}</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${actionType}</span>
                                    </div>
                                </div>
                                
                                <div class="card-description">
                                    <strong>Análise:</strong> ${explanation || title}
                                </div>
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        🎚️ Como Ajustar
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${(frequencyRange || adjustmentDb) ? `
                                    <div class="card-technical">
                                        ${frequencyRange ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Faixa</div>
                                                <div class="tech-value">${frequencyRange}</div>
                                            </div>
                                        ` : ''}
                                        ${adjustmentDb ? `
                                            <div class="tech-item">
                                                <div class="tech-label">Ajuste</div>
                                                <div class="tech-value">${adjustmentDb > 0 ? '+' : ''}${adjustmentDb.toFixed(1)} dB</div>
                                            </div>
                                        ` : ''}
                                        ${sug.details ? `
                                            <div class="tech-item" style="grid-column: span 2;">
                                                <div class="tech-label">Status</div>
                                                <div class="tech-value" style="font-size: 10px;">${sug.details.replace('Atual:', '').replace('Alvo:', '→')}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                ` : ''}
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">💡 Resultado Esperado</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    else {
                        // 🚨 VERIFICAR SE É TRUE PEAK COM MENSAGEM ESPECIAL
                        const isTruePeak = sug.type === 'reference_true_peak' || sug.metricType === 'true_peak' || 
                                         title.toLowerCase().includes('true peak') || title.toLowerCase().includes('tp');
                        const hasSpecialAlert = sug.specialAlert || sug.priorityWarning;
                        
                        if (isTruePeak && hasSpecialAlert) {
                            // Card especial para True Peak com mensagem de prioridade
                            return `
                                <div class="${cardClass} true-peak-priority">
                                    <div class="card-header">
                                        <h4 class="card-title">⚡ ${title}</h4>
                                        <div class="card-badges">
                                            <span class="priority-badge primeiro">PRIMEIRO</span>
                                            <span class="severity-badge critica">CRÍTICO</span>
                                        </div>
                                    </div>
                                    
                                    ${sug.priorityWarning ? `
                                        <div class="priority-warning" style="background: rgba(255, 193, 7, 0.2); border: 1px solid #FFC107; border-radius: 6px; padding: 12px; margin: 12px 0; color: #856404;">
                                            ${sug.priorityWarning}
                                        </div>
                                    ` : ''}
                                    
                                    ${explanation ? `
                                        <div class="card-description" style="border-left-color: #FF5722;">
                                            <strong>⚠️ Por que é prioritário:</strong> ${explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(255, 87, 34, 0.1); border-color: #FF5722;">
                                        <div class="card-action-title" style="color: #FF5722;">
                                            🚨 Correção Prioritária
                                        </div>
                                        <div class="card-action-content">${action}</div>
                                    </div>
                                    
                                    ${sug.why ? `
                                        <div class="card-impact" style="background: rgba(255, 87, 34, 0.05); border-color: #FF5722;">
                                            <div class="card-impact-title" style="color: #FF5722;">🔴 Motivo da Prioridade</div>
                                            <div class="card-impact-content">${sug.why}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${technical ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes Técnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                        </details>
                                    ` : ''}
                                </div>`;
                        }
                        
                        // Card genérico melhorado
                        return `
                            <div class="${cardClass}">
                                <div class="card-header">
                                    <h4 class="card-title">🎵 ${title}</h4>
                                    <div class="card-badges">
                                        ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                        <span class="severity-badge ${severityLevel}">${severityLabel || 'info'}</span>
                                    </div>
                                </div>
                                
                                ${explanation ? `
                                    <div class="card-description">
                                        <strong>Explicação:</strong> ${explanation}
                                    </div>
                                ` : ''}
                                
                                <div class="card-action">
                                    <div class="card-action-title">
                                        🔧 Ação Recomendada
                                    </div>
                                    <div class="card-action-content">${action}</div>
                                </div>
                                
                                ${sug.impact ? `
                                    <div class="card-impact">
                                        <div class="card-impact-title">⚠️ Impacto</div>
                                        <div class="card-impact-content">${sug.impact}</div>
                                    </div>
                                ` : ''}
                                
                                ${technical ? `
                                    <details style="margin-top: 12px;">
                                        <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes Técnicos</summary>
                                        <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${technical}</div>
                                    </details>
                                ` : ''}
                            </div>`;
                    }
                };
                if ((analysis.problems?.length || 0) > 0) {
                    // 🎯 Função local para deduplicar problemas por tipo
                    const deduplicateByType = (items) => {
                        const seen = new Map();
                        const deduplicated = [];
                        for (const item of items) {
                            if (!item || !item.type) continue;
                            
                            // 🎯 CORREÇÃO: Para band_adjust, usar type + subtype como chave única
                            let uniqueKey = item.type;
                            if (item.type === 'band_adjust' && item.subtype) {
                                uniqueKey = `${item.type}:${item.subtype}`;
                            }
                            
                            const existing = seen.get(uniqueKey);
                            if (!existing) {
                                seen.set(uniqueKey, item);
                                deduplicated.push(item);
                            } else {
                                // Manter o mais detalhado (com mais propriedades)
                                const currentScore = Object.keys(item).length + (item.explanation ? 10 : 0) + (item.impact ? 5 : 0);
                                const existingScore = Object.keys(existing).length + (existing.explanation ? 10 : 0) + (existing.impact ? 5 : 0);
                                if (currentScore > existingScore) {
                                    seen.set(uniqueKey, item);
                                    const index = deduplicated.findIndex(d => {
                                        if (d.type === 'band_adjust' && item.type === 'band_adjust') {
                                            return d.type === item.type && d.subtype === item.subtype;
                                        }
                                        return d.type === item.type;
                                    });
                                    if (index >= 0) deduplicated[index] = item;
                                }
                            }
                        }
                        return deduplicated;
                    };
                    
                    // Aplicar deduplicação dos problemas na UI
                    const deduplicatedProblems = deduplicateByType(analysis.problems);
                    const list = deduplicatedProblems.map(p => {
                        const msg = typeof p.message === 'string' ? p.message.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.message;
                        const sol = typeof p.solution === 'string' ? p.solution.replace(/(-?\d+\.\d{3,})/g, m => {
                            const n = parseFloat(m); return Number.isFinite(n) ? n.toFixed(2) : m;
                        }) : p.solution;
                        
                        // 🚨 USAR FORMATO NATIVO DOS PROBLEMAS - Evitar duplicação do SuggestionTextGenerator
                        // Os problemas já têm explanation, impact, frequency_range, adjustment_db, details
                        let didacticText = null; // Desabilitado para evitar duplicação
                        
                        // Se for problema crítico (clipping, etc), usar card crítico aprimorado
                        if (p.type === 'clipping' || p.severity === 'critical' || p.severity === 'high') {
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            
                            return `
                                <div class="enhanced-card critical-alert">
                                    <div class="card-header">
                                        <h4 class="card-title">🚨 Problema Crítico</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge severa">CRÍTICO</span>
                                        </div>
                                    </div>
                                    
                                    <div class="card-description" style="border-left-color: #f44336;">
                                        <strong>⚠️ Problema:</strong> ${msg}
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description" style="border-left-color: #f44336; background: rgba(244, 67, 54, 0.05);">
                                            <strong>Explicação:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action" style="background: rgba(244, 67, 54, 0.15); border-color: #f44336;">
                                        <div class="card-action-title" style="color: #f44336;">
                                            🚨 Ação Urgente
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || p.adjustment_db) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Frequências</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${p.adjustment_db ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${p.adjustment_db} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact" style="background: rgba(244, 67, 54, 0.1); border-color: #f44336;">
                                            <div class="card-impact-title" style="color: #f44336;">⚠️ Por que é crítico</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes Técnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        } else {
                            // Para problemas menos críticos, usar card padrão melhorado
                            const freqMatch = (msg + ' ' + sol).match(/(\d+(?:\.\d+)?)\s*(?:Hz|hz)/i);
                            const frequency = freqMatch ? freqMatch[1] : null;
                            const dbMatch = sol.match(/([+-]?\d+(?:\.\d+)?)\s*dB/i);
                            const dbValue = dbMatch ? dbMatch[1] : null;
                            
                            // Determinar tipo de problema
                            const problemType = p.type || 'general';
                            let cardClass = 'enhanced-card problem';
                            let problemIcon = '⚠️';
                            
                            if (problemType.includes('balance')) {
                                cardClass = 'enhanced-card balance';
                                problemIcon = '⚖️';
                            } else if (problemType.includes('dc_offset')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = '📊';
                            } else if (problemType.includes('phase')) {
                                cardClass = 'enhanced-card problem';
                                problemIcon = '🌊';
                            }
                            
                            return `
                                <div class="${cardClass}">
                                    <div class="card-header">
                                        <h4 class="card-title">${problemIcon} ${msg}</h4>
                                        <div class="card-badges">
                                            ${frequency ? `<span class="frequency-badge">${frequency} Hz</span>` : ''}
                                            <span class="severity-badge moderada">problema</span>
                                        </div>
                                    </div>
                                    
                                    ${p.explanation ? `
                                        <div class="card-description">
                                            <strong>Explicação:</strong> ${p.explanation}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="card-action">
                                        <div class="card-action-title">
                                            🔧 Como Resolver
                                        </div>
                                        <div class="card-action-content">${sol}</div>
                                    </div>
                                    
                                    ${(p.frequency_range || dbValue) ? `
                                        <div class="card-technical">
                                            ${p.frequency_range ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Frequências</div>
                                                    <div class="tech-value">${p.frequency_range}</div>
                                                </div>
                                            ` : ''}
                                            ${dbValue ? `
                                                <div class="tech-item">
                                                    <div class="tech-label">Ajuste</div>
                                                    <div class="tech-value">${dbValue} dB</div>
                                                </div>
                                            ` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${p.impact ? `
                                        <div class="card-impact">
                                            <div class="card-impact-title">⚠️ Impacto</div>
                                            <div class="card-impact-content">${p.impact}</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${p.details ? `
                                        <details style="margin-top: 12px;">
                                            <summary style="cursor: pointer; font-size: 12px; color: #aaa;">Detalhes Técnicos</summary>
                                            <div style="font-size: 11px; color: #ccc; margin-top: 8px; font-family: monospace;">${p.details}</div>
                                        </details>
                                    ` : ''}
                                </div>
                            `;
                        }
                    }).join('');
                    blocks.push(`<div class="diag-section"><div class="diag-heading">⚠️ Problemas Detectados:</div>${list}</div>`);
                }
                // 🛑 CARD DE SUGESTÕES ANTIGAS DESATIVADO - Removido conforme solicitado
                // O card "SUGESTÕES EDUCACIONAIS ULTRA-AVANÇADAS" foi desativado para limpar a UI
                // Apenas o novo sistema de sugestões (que aparece no final do modal) deve ser usado
                /*
                if ((analysis.suggestions?.length || 0) > 0) {
                    // [CÓDIGO COMENTADO - Card de sugestões antigas removido]
                }
                */
                // Subbloco opcional com diagnósticos do V2 PRO (quando disponíveis)
                const v2Pro = analysis.v2Pro || analysis.v2Diagnostics; // Compatibilidade
                if (v2Pro && (typeof window === 'undefined' || window.SUGESTOES_AVANCADAS !== false)) {
                    const v2p = (v2Pro.problems || []).map(p => `
                        <div class="diag-item danger">
                            <div class="diag-title">${p.message}</div>
                            <div class="diag-tip">${p.solution || ''}</div>
                        </div>`).join('');
                    // V2 Pro removido - não mostrar diagnósticos duplicados
                }
                console.log('[RENDER_SUGGESTIONS] ✅ Finalizada - Total de sugestões:', enrichedSuggestions?.length || 0);
                return blocks.join('') || '<div class="diag-empty">Sem diagnósticos</div>';
            };

        // 🎯 SUBSCORES: Corrigir mapeamento para backend Node.js
        const breakdown = analysis.scores || analysis.qualityBreakdown || {};
        
        // 🎯 APLICAR CAPS EM ESTADO CLIPPED
        const precedenceData = analysis.technicalData?._singleStage;
        const isClippedState = precedenceData?.finalState === 'CLIPPED' && precedenceData?.scoreCapApplied === true;
        
        // Aplicar caps nos sub-scores se em estado CLIPPED
        const applyClippingCaps = (originalBreakdown) => {
            if (!isClippedState) return originalBreakdown;
            
            const capped = { ...originalBreakdown };
            
            // Caps específicos para estado CLIPPED
            if (Number.isFinite(capped.loudness)) {
                capped.loudness = Math.min(capped.loudness, 70); // Loudness ≤ 70
            }
            if (Number.isFinite(capped.technical)) {
                capped.technical = Math.min(capped.technical, 60); // Técnico ≤ 60  
            }
            if (Number.isFinite(capped.dynamics)) {
                capped.dynamics = Math.min(capped.dynamics, 50); // Dinâmica ≤ 50
            }
            
            // Frequency e Stereo podem manter valores originais (não afetados diretamente pelo clipping)
            
            return capped;
        };
        
        const finalBreakdown = applyClippingCaps(breakdown);
        
        // 🎯 HELPER: Detecta se True Peak está crítico (para tooltip de Loudness)
        const isTruePeakCritical = () => {
            const tp = analysis?.technicalData?.truePeakDbtp;
            const gates = analysis?.scores?._gatesTriggered || [];
            
            // Verificar se há gate crítico de True Peak
            const hasCriticalGate = gates.some(g => 
                g.type === 'TRUE_PEAK_CRITICAL' || 
                g.type === 'CLIPPING_SEVERE'
            );
            
            // Ou verificar se TP > 0 dBTP
            return hasCriticalGate || (Number.isFinite(tp) && tp > 0);
        };
        // Função para renderizar score com barra de progresso + TOOLTIP + CORES DINÂMICAS
        const renderScoreWithProgress = (label, value, defaultColor = '#00ffff', tooltipKey = null) => {
            const numValue = parseFloat(value) || 0;
            
            // Indicar se o valor foi capeado (comparar com breakdown original)
            const labelKey = label.toLowerCase().replace('faixa dinâmica', 'dynamics').replace('técnico', 'technical').replace('loudness', 'loudness').replace('frequência', 'frequency').replace('stereo', 'stereo').replace('dinâmica', 'dynamics').replace('estéreo', 'stereo');
            const wasCapped = isClippedState && breakdown[labelKey] && Number.isFinite(breakdown[labelKey]) && 
                             breakdown[labelKey] !== value;
            const cappedIndicator = wasCapped ? ' 🔴' : '';
            
            // 🎯 COR DINÂMICA BASEADA NO VALOR (restaurando comportamento antigo)
            let scoreColor = defaultColor;
            if (Number.isFinite(numValue)) {
                if (numValue >= 80) scoreColor = '#00ff92'; // Verde para scores altos
                else if (numValue >= 60) scoreColor = '#ffd700'; // Amarelo para scores médios
                else if (numValue >= 40) scoreColor = '#ff9500'; // Laranja para scores baixos
                else scoreColor = '#ff3366'; // Vermelho para scores muito baixos
            }
            
            // 🎯 TOOLTIP: Buscar no TOOLTIP_REGISTRY usando tooltipKey
            const tooltipData = tooltipKey ? getTooltip(tooltipKey) : null;
            
            // 🎯 Se não houver tooltip válido, ESCONDER o ícone (não usar fallback TODO visível)
            let tooltipIconHtml = '';
            if (tooltipData && tooltipData.body) {
                // Lógica especial para Loudness: verificar se True Peak está crítico
                let finalTooltipBody = tooltipData.body;
                let finalTooltipVariant = tooltipData.variant || 'default';
                
                if (tooltipKey === 'loudness' && isTruePeakCritical()) {
                    finalTooltipVariant = 'warning';
                    finalTooltipBody = tooltipData.body + ' ⚠️ ATENÇÃO: True Peak crítico detectado (> 0 dBTP ou gates ativos). Isso limita o score mesmo com LUFS correto.';
                }
                
                tooltipIconHtml = `<span class="metric-info-icon" 
                    data-tooltip-title="${tooltipData.title}" 
                    data-tooltip-body="${finalTooltipBody}" 
                    data-tooltip-variant="${finalTooltipVariant}"
                    style="margin-left: 4px; cursor: pointer;">ℹ️</span>`;
            }
            
            // 🎯 VALOR NÃO DISPONÍVEL
            if (value == null || !Number.isFinite(numValue)) {
                return `<div class="data-row metric-with-progress">
                    <span class="label">
                        <div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                            <span>${label}:</span>${tooltipIconHtml}
                        </div>
                    </span>
                    <div class="metric-value-progress">
                        <span class="value" style="color: #666; font-weight: normal;">—</span>
                        <div class="progress-bar-mini">
                            <div class="progress-fill-mini" style="width: 0%; background: transparent;"></div>
                        </div>
                    </div>
                </div>`;
            }
            
            // 🎯 VALOR DISPONÍVEL: Renderizar com cor dinâmica + tooltip + barra (SEM /100)
            const displayValue = Math.round(numValue);
            
            return `<div class="data-row metric-with-progress">
                <span class="label">
                    <div class="metric-label-container" style="display: inline-flex; align-items: center; gap: 2px;">
                        <span>${label}${cappedIndicator}:</span>${tooltipIconHtml}
                    </div>
                </span>
                <div class="metric-value-progress">
                    <span class="value" style="color: ${scoreColor}; font-weight: bold;">${displayValue}</span>
                    <div class="progress-bar-mini">
                        <div class="progress-fill-mini" style="width: ${Math.min(Math.max(numValue, 0), 100)}%; background: ${scoreColor};"></div>
                    </div>
                </div>
            </div>`;
        };
        
        // ═══════════════════════════════════════════════════════════════
        // 🎯 RENDERIZAR SCORE FINAL NO TOPO - VISUAL FUTURISTA
        // ═══════════════════════════════════════════════════════════════
        
        /**
         * Renderiza o score final no container dedicado no topo da análise
         * V3.4: Agora mostra "bruto vs penalizado" quando gates são aplicados
         * @param {Object} scores - Objeto contendo todos os scores
         */
        function renderFinalScoreAtTop(scores) {
            console.log('[RENDER_FINAL_SCORE] ✅ Iniciada');
            console.log('[RENDER_FINAL_SCORE] scores:', scores);
            
            if (!scores || !Number.isFinite(scores.final)) {
                console.warn('[RENDER_FINAL_SCORE] ⚠️ Retorno antecipado - Score final não disponível');
                console.warn('[AUDITORIA_CONDICAO] ⚠️ Retorno antecipado em: renderFinalScoreAtTop - !scores || !Number.isFinite(scores.final)');
                return;
            }
            
            const container = document.getElementById('final-score-display');
            if (!container) {
                console.error('[RENDER_FINAL_SCORE] ⚠️ Retorno antecipado - Container #final-score-display não encontrado');
                console.warn('[AUDITORIA_CONDICAO] ⚠️ Retorno antecipado em: renderFinalScoreAtTop - !container');
                return;
            }
            
            console.log('[RENDER_FINAL_SCORE] ✅ Container encontrado, renderizando...');
            
            const finalScore = Math.round(scores.final);
            const finalRaw = scores.finalRaw ? Math.round(scores.finalRaw) : null;
            const wasGatePenalized = finalRaw && finalRaw > finalScore;
            const gatePenaltyAmount = wasGatePenalized ? finalRaw - finalScore : 0;
            const gatesTriggered = scores._gatesTriggered || [];
            
            const percent = Math.min(Math.max(finalScore, 0), 100);
            
            // Determinar mensagem de status baseada no score
            let statusMessage = '';
            let statusClass = '';
            
            if (finalScore >= 90) {
                statusMessage = '✨ Excelente! Pronto para lançamento';
                statusClass = 'status-excellent';
            } else if (finalScore >= 75) {
                statusMessage = '✅ Ótimo! Qualidade profissional';
                statusClass = 'status-good';
            } else if (finalScore >= 60) {
                statusMessage = '⚠️ Bom, mas pode melhorar';
                statusClass = 'status-warning';
            } else if (finalScore >= 40) {
                statusMessage = '🔧 Precisa de ajustes';
                statusClass = 'status-warning';
            } else {
                statusMessage = '🚨 Necessita correções importantes';
                statusClass = 'status-poor';
            }
            
            // V4.0: UI Limpa - Removidos textos técnicos (gate/cap/penalty)
            // Informações técnicas agora ficam apenas no console para debug
            if (wasGatePenalized) {
                console.log('[RENDER_FINAL_SCORE] 🔧 Gate aplicado (info técnica):', {
                    bruto: finalRaw,
                    final: finalScore,
                    penalidade: gatePenaltyAmount,
                    gates: gatesTriggered.map(g => g.type)
                });
            }
            
            // 🎯 BUSCAR TOOLTIP DO REGISTRY
            const scoreTooltipData = getTooltip('scoreFinal');
            const scoreTooltipTitle = scoreTooltipData?.title || 'Score Final';
            const scoreTooltipBody = scoreTooltipData?.body || 'Média ponderada de todos os subscores. Reflete a qualidade técnica geral do áudio.';
            
            // Renderizar HTML do score final - UI LIMPA (SEM TOOLTIP)
            container.innerHTML = `
                <div class="score-final-label">🏆 SCORE FINAL</div>
                <div class="score-final-value">0</div>
                <div class="score-final-bar-container">
                    <div class="score-final-bar">
                        <div class="score-final-bar-fill" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-final-status ${statusClass}">${statusMessage}</div>
                <div id="diagnostic-container" class="diagnostic-container"></div>
            `;
            
            // Animar contagem do score (impacto visual) - inicia após pequeno delay
            setTimeout(() => {
                animateFinalScore(finalScore);
            }, 100);
            
            console.log('[RENDER_FINAL_SCORE] ✅ Finalizada');
        }
        
        /**
         * Anima a contagem do score final de 0 até o valor final
         * @param {number} targetScore - Score final a ser exibido
         */
        function animateFinalScore(targetScore) {
            const el = document.querySelector('.score-final-value');
            const barFill = document.querySelector('.score-final-bar-fill');
            if (!el) return;
            
            let currentScore = 0;
            const duration = 2500; // 2.5 segundos (mais lento e dramático)
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out cubic - mais suave)
                const eased = 1 - Math.pow(1 - progress, 3);
                currentScore = targetScore * eased;
                
                // Atualizar número
                el.textContent = Math.floor(currentScore);
                
                // Animar barra junto (se existir)
                if (barFill) {
                    const currentPercent = Math.min(Math.max(currentScore, 0), 100);
                    barFill.style.width = `${currentPercent}%`;
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    el.textContent = targetScore; // Garantir valor final exato
                    if (barFill) {
                        const finalPercent = Math.min(Math.max(targetScore, 0), 100);
                        barFill.style.width = `${finalPercent}%`;
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 🧠 DIAGNÓSTICO SONORO INTELIGENTE - RENDERIZAÇÃO UI
        // ═══════════════════════════════════════════════════════════════
        
        /**
         * Renderiza o diagnóstico semântico abaixo do score final
         * @param {Object} scoreResult - Resultado de computeScoreV3
         * @param {Object} analysisMeta - Metadados da análise
         */
        function renderDiagnostic(scoreResult, analysisMeta = {}) {
            console.log('[RENDER_DIAGNOSTIC] 🧠 Iniciando renderização do diagnóstico');
            
            const container = document.getElementById('diagnostic-container');
            if (!container) {
                console.warn('[RENDER_DIAGNOSTIC] ⚠️ Container #diagnostic-container não encontrado');
                return;
            }
            
            // Construir contexto semântico
            const diagnostic = window.buildDiagnosticContext(scoreResult, analysisMeta);
            
            if (!diagnostic || !diagnostic.context?.valid) {
                console.warn('[RENDER_DIAGNOSTIC] ⚠️ Diagnóstico inválido');
                container.innerHTML = '';
                return;
            }
            
            // ═══════════════════════════════════════════════════════════════
            // V5.0: VEREDITO SONORO - APENAS TEXTO ÚNICO DA IA
            // Design premium, clean, sem listas ou badges
            // ═══════════════════════════════════════════════════════════════
            let finalText = '';
            if (window.generateFinalDiagnosticText) {
                finalText = window.generateFinalDiagnosticText(diagnostic);
            }
            
            if (!finalText) {
                container.innerHTML = '';
                return;
            }
            
            // 🎯 BUSCAR TOOLTIP DO REGISTRY
            const diagnosticTooltipData = getTooltip('diagnostico');
            const diagnosticTooltipTitle = diagnosticTooltipData?.title || 'Diagnóstico';
            const diagnosticTooltipBody = diagnosticTooltipData?.body || 'Classificação qualitativa baseada no score final.';
            
            // Renderizar APENAS o texto único - design minimalista premium (SEM TOOLTIP)
            container.innerHTML = `
                <div class="verdict-text">${finalText}</div>
            `;
            
            console.log('[RENDER_DIAGNOSTIC] ✅ Veredito sonoro renderizado');
        }
        
        // Expor função para uso externo
        window.renderDiagnostic = renderDiagnostic;
        
        // ═══════════════════════════════════════════════════════════════
        
        // 🎯 RENDERIZAR SCORES DO NOVO SISTEMA
        const renderNewScores = () => {
            // Verificar se temos scores calculados
            const scores = analysis.scores;
            
            // ═════════════════════════════════════════════════════════════════
            // 🔍 TAREFA 2: AUDITORIA DE LEITURA DE SCORES NA UI
            // ═════════════════════════════════════════════════════════════════
            console.group('🎨 [AUDIT-RENDER] LEITURA DE SCORES NA UI');
            console.log('[AUDIT-RENDER] analysis.scores recebido pela UI:', scores);
            console.log('[AUDIT-RENDER] scores existe?', !!scores);
            console.log('[AUDIT-RENDER] scores.loudness:', scores?.loudness);
            console.log('[AUDIT-RENDER] scores.dinamica:', scores?.dinamica);
            console.log('[AUDIT-RENDER] scores.estereo:', scores?.estereo);
            console.log('[AUDIT-RENDER] scores.frequencia:', scores?.frequencia);
            console.log('[AUDIT-RENDER] scores.tecnico:', scores?.tecnico);
            console.log('[AUDIT-RENDER] scores.subscores:', scores?.subscores);
            console.groupEnd();
            
            if (!scores) {
                console.warn('⚠️ [AUDIT-RENDER] SCORES AUSENTES - renderizando fallback');
                return `<div class="data-row">
                    <span class="label">Sistema de Scoring:</span>
                    <span class="value">Não disponível</span>
                </div>`;
            }
            
            // ═════════════════════════════════════════════════════════════════
            // 🔧 TAREFA 3: NORMALIZAÇÃO DE ESTRUTURA DE SCORES
            // ═════════════════════════════════════════════════════════════════
            // Adaptar estrutura retornada por calculateAnalysisScores para UI
            const rawScores = scores || {};
            const subs = rawScores.subscores || rawScores;
            
            const normalizedScores = {
                loudness: subs.loudness ?? rawScores.loudness ?? subs.lufs ?? null,
                dinamica: subs.dinamica ?? subs.dynamics ?? rawScores.dinamica ?? rawScores.dynamics ?? null,
                estereo: subs.estereo ?? subs.stereo ?? rawScores.estereo ?? rawScores.stereo ?? null,
                frequencia: subs.frequencia ?? subs.frequency ?? rawScores.frequencia ?? rawScores.frequency ?? null,
                tecnico: subs.tecnico ?? subs.technical ?? rawScores.tecnico ?? rawScores.technical ?? null,
                final: rawScores.final ?? rawScores.composite ?? rawScores.score ?? null,
                breakdown: rawScores.breakdown ?? null
            };
            
            console.group('✅ [AUDIT-RENDER] SCORES NORMALIZADOS');
            console.log('[AUDIT-RENDER] normalizedScores.loudness:', normalizedScores.loudness);
            console.log('[AUDIT-RENDER] normalizedScores.dinamica:', normalizedScores.dinamica);
            console.log('[AUDIT-RENDER] normalizedScores.estereo:', normalizedScores.estereo);
            console.log('[AUDIT-RENDER] normalizedScores.frequencia:', normalizedScores.frequencia);
            console.log('[AUDIT-RENDER] normalizedScores.tecnico:', normalizedScores.tecnico);
            console.log('[AUDIT-RENDER] normalizedScores.final:', normalizedScores.final);
            
            // 🔍 TAREFA 4: VALIDAÇÃO FINAL - Contagem de valores null
            const nullCount = Object.values(normalizedScores).filter(v => v === null).length;
            const validCount = Object.values(normalizedScores).filter(v => Number.isFinite(v)).length;
            console.log('📊 [AUDIT-RENDER] VALIDAÇÃO:', {
                total: Object.keys(normalizedScores).length,
                validos: validCount,
                nulos: nullCount,
                status: nullCount === 0 ? '✅ TODOS PREENCHIDOS' : `⚠️ ${nullCount} NULOS`
            });
            console.groupEnd();
            
            // 🎯 Score final REMOVIDO daqui - será renderizado no topo
            // ❌ NÃO INCLUIR O SCORE FINAL AQUI - ele tem seu próprio container no topo
            
            // ✅ Sub-scores permanecem no mesmo lugar (dentro do card Scores & Diagnóstico)
            // 🎯 USANDO renderScoreWithProgress que já tem suporte a tooltips + CORES DINÂMICAS
            const subScoresHtml = `
                ${renderScoreWithProgress('Loudness', normalizedScores.loudness, '#ff3366', 'loudness')}
                ${renderScoreWithProgress('Frequência', normalizedScores.frequencia, '#00ffff', 'frequency')}
                ${renderScoreWithProgress('Estéreo', normalizedScores.estereo, '#ff6b6b', 'stereo')}
                ${renderScoreWithProgress('Dinâmica', normalizedScores.dinamica, '#ffd700', 'dynamic')}
                ${renderScoreWithProgress('Técnico', normalizedScores.tecnico, '#00ff92', 'technical')}
            `;
            
            return subScoresHtml;
        };
        
        const scoreRows = renderNewScores();

        // 🔹 Função utilitária: Remove nós de texto vazios (whitespace) dentro dos cards
        function normalizeCardWhitespace(root = document) {
            const cards = root.querySelectorAll('.cards-grid .card');
            cards.forEach((card) => {
                // Remove nós de texto que sejam apenas whitespace (espaços/linhas)
                const toRemove = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        toRemove.push(n);
                    }
                });
                toRemove.forEach((n) => n.parentNode.removeChild(n));
            });
        }

        // 🔹 Alias para compatibilidade com nomenclatura alternativa
        function stripEmptyTextNodesInCards(root = document) {
            root.querySelectorAll('.cards-grid .card').forEach((card) => {
                const garbage = [];
                card.childNodes.forEach((n) => {
                    if (n.nodeType === Node.TEXT_NODE && !/\S/.test(n.nodeValue || '')) {
                        garbage.push(n);
                    }
                });
                garbage.forEach((n) => n.remove());
            });
        }

        // =========================================================================
        // 🚨 AUDITORIA CRÍTICA: PONTO DE RENDERIZAÇÃO DE CARDS
        // =========================================================================
        console.groupCollapsed('[AUDITORIA_RENDERIZACAO] 🎨 RENDERIZAÇÃO DE CARDS');
        console.log('[RENDER_CARDS] ✅ INÍCIO - Prestes a renderizar cards');
        console.log('[RENDER_CARDS] Modo:', analysis?.mode);
        console.log('[RENDER_CARDS] Contém analysis.scores?', !!analysis?.scores);
        console.log('[RENDER_CARDS] Contém analysis.technicalData?', !!analysis?.technicalData);
        console.log('[RENDER_CARDS] technicalData disponível no DOM?', !!document.getElementById('modalTechnicalData'));
        console.log('[RENDER_CARDS] scoreKpi length:', scoreKpi?.length || 0);
        console.log('[RENDER_CARDS] col1 length:', col1?.length || 0);
        console.log('[RENDER_CARDS] col2 length:', col2?.length || 0);
        console.groupEnd();
        
        // [AUDIT-FLOW-CHECK] Confirmar que chegou na renderização de cards
        console.log('[AUDIT-FLOW-CHECK] ✅ Renderizando cards - modo:', analysis?.mode);
        
        // =========================================================================
        // 🚨 AUDITORIA: RENDERIZAR SCORE FINAL NO TOPO
        // =========================================================================
        console.log('[RENDER_SCORE_TOP] ✅ Chamando renderFinalScoreAtTop');
        console.log('[RENDER_SCORE_TOP] analysis.scores:', analysis?.scores);
        
        // 🎯 RENDERIZAR SCORE FINAL NO TOPO (ISOLADO)
        renderFinalScoreAtTop(analysis.scores);
        
        console.log('[RENDER_SCORE_TOP] ✅ renderFinalScoreAtTop FINALIZADO');
        
        // =========================================================================
        // 🧠 V4.0: RENDERIZAR DIAGNÓSTICO SONORO INTELIGENTE
        // =========================================================================
        // O diagnóstico é renderizado após a animação do score começar
        setTimeout(() => {
            if (analysis.scores && window.buildDiagnosticContext) {
                console.log('[RENDER_DIAGNOSTIC] 🧠 Iniciando construção do diagnóstico');
                
                // 🔍 LOG TEMPORÁRIO - AUDITORIA TEXTO IA
                console.group('🔍 [AUDIT-AI-TEXT] Verificação de dados para diagnóstico');
                console.log('analysis.scores:', analysis.scores);
                console.log('analysis.scores.metricEvaluations existe?', !!analysis.scores.metricEvaluations);
                console.log('analysis.scores.subscores:', analysis.scores.subscores);
                console.log('analysis.scores._frequencyDetails:', analysis.scores._frequencyDetails);
                console.groupEnd();
                
                // Construir metadados da análise para contexto
                const analysisMeta = {
                    mode: analysis.mode || 'streaming',
                    genre: analysis.genre || analysis.genreName || null,
                    reference: analysis.referenceName || analysis.reference?.name || null
                };
                
                // Renderizar diagnóstico
                renderDiagnostic(analysis.scores, analysisMeta);
            } else {
                console.warn('[RENDER_DIAGNOSTIC] ⚠️ Não foi possível renderizar diagnóstico:', {
                    hasScores: !!analysis.scores,
                    hasBuildDiagnosticContext: !!window.buildDiagnosticContext
                });
            }
        }, 500); // Delay para sincronizar com animação do score

        console.log('[RENDER_CARDS] ✅ Atribuindo HTML ao technicalData.innerHTML');
        technicalData.innerHTML = `
            <div class="kpi-row">${scoreKpi}${timeKpi}</div>
            ${renderSmartSummary(analysis)}
            <div class="cards-grid">
                <div class="card">
                    <div class="card-title">MÉTRICAS PRINCIPAIS</div>
                    ${col1Html}
                </div>
                <div class="card">
                    <div class="card-title">ANÁLISE DE FREQUÊNCIAS</div>
                    ${col2}
                </div>
                <div class="card">
                    <div class="card-title">MÉTRICAS AVANÇADAS</div>
                    ${advancedMetricsCard()}
                </div>
                <div class="card">
                    <div class="card-title">SCORES & DIAGNÓSTICO</div>
                    ${scoreRows}
                    ${col3}
                </div>
                <!-- Card "Problemas Técnicos" removido conforme solicitado -->
                <!-- 
                <div class="card card-span-2">
                    <div class="card-title">⚠️ Problemas Técnicos</div>
                    ${techProblems()}
                </div>
                -->
            </div>`;
        
        // 🔍 VALIDAÇÃO PÓS-RENDER: Detectar métricas sem tooltip (DEV apenas)
        if (isDev) {
            setTimeout(() => {
                const allRows = technicalData.querySelectorAll('.data-row[data-metric-key]');
                const missingTooltips = [];
                
                allRows.forEach(row => {
                    const metricKey = row.getAttribute('data-metric-key');
                    const hasIcon = row.querySelector('.metric-info-icon[data-tooltip-body]');
                    
                    if (!hasIcon && metricKey) {
                        const label = row.querySelector('.label')?.textContent.trim() || 'Unknown';
                        missingTooltips.push({
                            metricKey,
                            label,
                            element: row
                        });
                    }
                });
                
                if (missingTooltips.length > 0) {
                    console.group('⚠️ [TOOLTIP-VALIDATION] Métricas sem tooltip detectadas');
                    console.warn(`${missingTooltips.length} métrica(s) renderizadas sem tooltip:`);
                    console.table(missingTooltips.map(m => ({
                        metricKey: m.metricKey,
                        label: m.label
                    })));
                    console.log('📝 Adicione essas keys no TOOLTIP_REGISTRY para 100% de cobertura.');
                    console.groupEnd();
                } else {
                    console.log('✅ [TOOLTIP-VALIDATION] 100% de cobertura - todas as métricas têm tooltips!');
                }
            }, 100);
        }
        
        // =========================================================================
        // 🚨 AUDITORIA: CONFIRMAR RENDERIZAÇÃO NO DOM
        // =========================================================================
        console.log('[RENDER_CARDS] ✅ HTML atribuído ao technicalData.innerHTML');
        console.log('[RENDER_CARDS] Tamanho do HTML:', technicalData.innerHTML.length);
        console.log('[RENDER_CARDS] Primeiros 200 chars:', technicalData.innerHTML.substring(0, 200));
    
        // 🔹 Sanitizar DOM: Remove nós de texto vazios que criam espaço extra
        normalizeCardWhitespace(technicalData);
        stripEmptyTextNodesInCards(technicalData);
        
        // =========================================================================
        // 🚨 AUDITORIA: VERIFICAR DOM APÓS SANITIZAÇÃO
        // =========================================================================
        setTimeout(() => {
            console.groupCollapsed('[AUDITORIA_DOM] 🔍 VERIFICAÇÃO DO DOM');
            console.log('[AUDITORIA_DOM] Cards:', document.querySelectorAll('.cards-grid .card').length);
            console.log('[AUDITORIA_DOM] Sugestões:', document.querySelectorAll('.suggestion-card').length);
            console.log('[AUDITORIA_DOM] Score containers:', document.querySelectorAll('.score-card, .final-score-display').length);
            console.log('[AUDITORIA_DOM] technicalData.innerHTML length:', document.getElementById('modalTechnicalData')?.innerHTML?.length || 0);
            console.groupEnd();
        }, 1000);
    
        // 🎯 CORRIGIDO: Só renderizar referências se NÃO estiver em modo comparação de faixas
        // O displayModalResults() já trata comparação via renderTrackComparisonTable()
        
        // 🔥 FLAG DE CONTROLE: Impedir dupla renderização em modo gênero
        let genreRenderComplete = false;
        
        try { 
            // ========================================
            // 🔥 MODO GÊNERO: RENDERIZAÇÃO ISOLADA
            // ========================================
            // ✅ RESTAURADO: Fluxo original que sempre funcionou
            if (analysis?.mode === "genre") {
                console.log('%c[GENRE-MODE] 🎯 MODO GÊNERO DETECTADO - RENDERIZAÇÃO DIRETA', 'color:#FF6B6B;font-weight:bold;font-size:14px;');
                console.log('[GENRE-MODE] analysis.mode:', analysis.mode);
                console.log('[GENRE-MODE] analysis.genre:', analysis.genre || analysis.metadata?.genre);
                console.log('[GENRE-MODE] window.__activeRefData:', !!window.__activeRefData);
                console.log('[GENRE-MODE] window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
                console.log('[GENRE-MODE] analysis.bands:', analysis.bands ? Object.keys(analysis.bands).length + ' bandas' : 'N/A');
                console.log('[GENRE-MODE] ════════════════════════════════════════');
                
                // ✅ CHAMAR FUNÇÃO DE RENDERIZAÇÃO DE GÊNERO
                renderGenreView(analysis);
                
                // 🔥 MARCAR FLAG: Gênero foi renderizado, NÃO renderizar A/B depois
                genreRenderComplete = true;
                
                console.log('%c[GENRE-MODE] ✅ RENDERIZAÇÃO CONCLUÍDA', 'color:#00FF88;font-weight:bold;');
                return;
            }
            
            // ========================================
            // 🎯 MODO REFERÊNCIA: PREPARAR DADOS PARA COMPARAÇÃO A/B
            // ========================================
            // ✅ RESTAURADO: Fluxo original de referência mantido intacto
            const isSecondTrack = (
                analysis.mode === 'reference' &&
                window.__REFERENCE_JOB_ID__ !== null &&
                window.__REFERENCE_JOB_ID__ !== undefined
            );
            
            const mode = analysis?.mode || currentAnalysisMode;
            const state = window.__soundyState || {};
            
            // 🎯 CORREÇÃO: Declarar mustBeReference ANTES de usar (previne ReferenceError)
            const mustBeReference = (
                mode === 'reference' ||
                isSecondTrack ||
                hasActiveReferenceContext() ||
                SOUNDY_MODE_ENGINE?.isReferenceCompare?.()
            );
            
            console.log('🔍 [RENDER-FLOW] Verificando modo e decisão de renderização:', {
                'analysis.mode': analysis.mode,
                'analysis.isReferenceBase': analysis.isReferenceBase,
                'currentAnalysisMode': window.currentAnalysisMode,
                isSecondTrack,
                mustBeReference,
                hasReferenceAnalysisData: !!window.referenceAnalysisData,
                '__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
                stateRenderMode: state.render?.mode
            });
            
            console.log('[VERIFY_RENDER_MODE]', {
                mode: state.render?.mode || 'undefined',
                usingReferenceBands: !!(state.reference?.analysis?.bands || analysis?.referenceAnalysis?.bands),
                usingGenreTargets: !!window.__activeRefData?.bands,
                genreTargetsKeys: window.__activeRefData?.bands ? Object.keys(window.__activeRefData.bands) : [],
                referenceBandsKeys: state.reference?.analysis?.bands ? Object.keys(state.reference.analysis.bands) : []
            });
            
            console.log('🎵 [REFERENCE-MODE] ═══════════════════════════════════════');
            console.log('🎵 [REFERENCE-MODE] MODO REFERÊNCIA DETECTADO');
            console.log('🎵 [REFERENCE-MODE] analysis.mode:', analysis.mode);
            console.log('🎵 [REFERENCE-MODE] analysis.isReferenceBase:', analysis.isReferenceBase);
            console.log('🎵 [REFERENCE-MODE] isSecondTrack:', isSecondTrack);
            console.log('🎵 [REFERENCE-MODE] ═══════════════════════════════════════');
            
            // 🎯 Usar helper getCompareMode (NUNCA ctx.mode como fallback)
            const compareMode = getCompareMode(analysis);
            
            console.log(`📊 [RENDER-FLOW] Preparando renderReferenceComparisons() - compareMode: ${compareMode}`);
            console.log('[RENDER-FLOW] mustBeReference:', mustBeReference);
            console.log('[RENDER-FLOW] __REFERENCE_JOB_ID__:', window.__REFERENCE_JOB_ID__);
            console.log('[RENDER-FLOW] referenceAnalysisData.bands:', !!window.referenceAnalysisData?.bands);
            
            // Preparar objeto ctx com clones profundos para evitar contaminação
            const userClone = (typeof structuredClone === 'function') 
                ? structuredClone(analysis) 
                : JSON.parse(JSON.stringify(analysis));
            
            const refClone = window.referenceAnalysisData 
                ? ((typeof structuredClone === 'function') 
                    ? structuredClone(window.referenceAnalysisData) 
                    : JSON.parse(JSON.stringify(window.referenceAnalysisData)))
                : null;
            
            const renderOpts = {
                mode: compareMode,
                user: userClone,
                ref: refClone,
                // Compatibilidade com código legado
                analysis: analysis,
                userAnalysis: state.userAnalysis || state.reference?.userAnalysis || userClone,
                referenceAnalysis: state.referenceAnalysis || state.reference?.referenceAnalysis || refClone
            };
            
            console.log('[RENDER-OPTS] ✅ Dados preparados:', {
                mode: renderOpts.mode,
                hasUser: !!renderOpts.user,
                hasRef: !!renderOpts.ref,
                userBands: !!renderOpts.user?.bands,
                refBands: !!renderOpts.ref?.bands
            });
            
            // 🔍 [AUDIT-BANDS-BEFORE] Log ANTES da chamada de renderReferenceComparisons
            try {
                const refBands = renderOpts.referenceAnalysis?.bands || renderOpts.referenceAnalysis?.technicalData?.spectral_balance;
                const userBands = renderOpts.userAnalysis?.bands || renderOpts.userAnalysis?.technicalData?.spectral_balance;
                console.log('[AUDIT-BANDS-BEFORE]', {
                    hasRefBands: !!refBands,
                    hasUserBands: !!userBands,
                    refBandsType: typeof refBands,
                    userBandsType: typeof userBands,
                    refBandsKeys: refBands ? Object.keys(refBands) : [],
                    userBandsKeys: userBands ? Object.keys(userBands) : [],
                    refBandsPreview: refBands ? Object.keys(refBands).slice(0, 3) : 'N/A',
                    userBandsPreview: userBands ? Object.keys(userBands).slice(0, 3) : 'N/A',
                    renderOptsKeys: Object.keys(renderOpts)
                });
            } catch (err) {
                console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-BEFORE', err);
            }
            
            // ✅ [BANDS-FIX] Nunca espera bandas no DOM - trabalha direto nos objetos
            // Se os objetos existem, seguimos — processamento é nos dados, não no DOM
            const ensureBandsReady = (userFull, refFull) => {
                return !!(userFull && refFull);
            };

            // 🔥 PROTEÇÃO: NÃO renderizar A/B se gênero já foi renderizado
            if (genreRenderComplete) {
                console.log('[GENRE-PROTECTION] ✅ Modo gênero já renderizado - BLOQUEANDO renderização A/B');
            } else if (ensureBandsReady(renderOpts?.userAnalysis, renderOpts?.referenceAnalysis)) {
                renderReferenceComparisons(renderOpts);
            } else {
                console.warn('[BANDS-FIX] ⚠️ Objetos ausentes para comparação A/B, pulando render de referência');
            }
        } catch(e){ 
            console.error('❌ [RENDER-FLOW] ERRO em renderReferenceComparisons:', e);
            console.error('❌ Stack trace:', e.stack);
        }    
        try { if (window.CAIAR_ENABLED) injectValidationControls(); } catch(e){ console.warn('validation controls fail', e); }
        
        // 🔍 Verificação de debug: Detecta whitespace restante
        if (window.DEBUG_ANALYZER) {
            document.querySelectorAll('.cards-grid .card').forEach((card, i) => {
                const ghosts = [...card.childNodes].filter(n => n.nodeType === 3 && !/\S/.test(n.nodeValue || ''));
                if (ghosts.length) console.warn(`Card #${i+1}: whitespace nodes restantes`, ghosts);
            });
        }
        
        __dbg('📊 Resultados exibidos no modal');
        
        // ✅ LOG FINAL DE CONFIRMAÇÃO
        console.log('[DISPLAY_MODAL_RESULTS] ✅✅✅ FUNÇÃO FINALIZADA COM SUCESSO ✅✅✅');
        console.log('[DISPLAY_MODAL_RESULTS] Modo:', analysis?.mode);
        console.log('[DISPLAY_MODAL_RESULTS] Self-compare?', state?.render?.isSelfCompare || false);
        console.log('[DISPLAY_MODAL_RESULTS] Renderização completa: cards, scores, tabela A/B, sugestões');
    }

    // === Controles de Validação (Suite Objetiva + Subjetiva) ===
    function injectValidationControls(){
        if (document.getElementById('validationControlsBar')) return;
        const host = document.getElementById('modalTechnicalData');
        if (!host) return;
        const bar = document.createElement('div');
        bar.id='validationControlsBar';
        bar.style.cssText='margin-top:14px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;background:#0f1826;padding:10px 12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;font-size:12px;';
        bar.innerHTML = `
            <strong style="letter-spacing:.5px;color:#9fc9ff;font-weight:600;">Validação Auditiva</strong>
            <button id="runValidationSuiteBtn" style="background:#10365a;color:#fff;border:1px solid #1e4d7a;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;">Rodar Suite (10)</button>
            <button id="openSubjectiveFormBtn" style="background:#1c2c44;color:#d6e7ff;border:1px solid #284362;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Subjetivo 1–5</button>
            <button id="downloadValidationReportBtn" style="background:#224d37;color:#c5ffe9;border:1px solid #2f6e4e;padding:6px 10px;font-size:12px;border-radius:6px;cursor:pointer;" disabled>Baixar Relatório</button>
            <span id="validationStatusMsg" style="margin-left:auto;font-size:11px;opacity:.75;">Pronto</span>
        `;
        host.prepend(bar);
        // Handlers
        const btnRun = bar.querySelector('#runValidationSuiteBtn');
        const btnForm = bar.querySelector('#openSubjectiveFormBtn');
        const btnDownload = bar.querySelector('#downloadValidationReportBtn');
        const statusEl = bar.querySelector('#validationStatusMsg');
        btnRun.onclick = async ()=>{
            btnRun.disabled = true; btnRun.textContent = 'Rodando...'; statusEl.textContent = 'Executando suite...';
            try {
                const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`);
                const summary = await mod.runValidationSuite({});
                statusEl.textContent = summary? `Cobertura média Δ ${(summary.avgDelta*100).toFixed(1)}%` : 'Sem dados';
                btnRun.textContent = 'Suite OK';
                btnForm.disabled = false; btnDownload.disabled = false;
                // Área dinâmica para formulário
                ensureValidationPanel();
            } catch(err){ console.error('Erro suite validação', err); statusEl.textContent='Erro'; btnRun.textContent='Erro'; btnRun.disabled=false; }
        };
        btnForm.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); ensureValidationPanel(); mod.renderSubjectiveForm('validationPanelInner'); statusEl.textContent='Formulário subjetivo aberto'; } catch(e){ console.warn(e); }
        };
        btnDownload.onclick = async ()=>{
            try { const mod = await import(`../lib/audio/validation/validation-suite.js?c=${Date.now()}`); const rep = mod.generateValidationReport(); if(rep){ downloadObjectAsJson(rep, 'prodai_validation_report.json'); statusEl.textContent = rep?.subjective?.pctImproved!=null? `Subj ${(rep.subjective.pctImproved*100).toFixed(0)}%`:'Relatório gerado'; } } catch(e){ console.warn(e); }
        };
    }

    function ensureValidationPanel(){
        if (document.getElementById('validationPanel')) return;
        const container = document.createElement('div');
        container.id='validationPanel';
        container.style.cssText='margin-top:12px;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:#0d141f;padding:10px 12px;';
        container.innerHTML = `<div style="font-size:12px;font-weight:600;letter-spacing:.5px;color:#9fc9ff;margin-bottom:6px;">Resultados da Validação</div><div id='validationPanelInner' style='font-size:11px;'></div>`;
        const host = document.getElementById('modalTechnicalData');
        if (host) host.appendChild(container);
        // estilos mínimos tabela subjetiva
        if (!document.getElementById('validationStyles')){
            const st=document.createElement('style'); st.id='validationStyles'; st.textContent=`
                .subjective-table{border-collapse:collapse;width:100%;margin-top:6px;font-size:11px;}
                .subjective-table th,.subjective-table td{border:1px solid rgba(255,255,255,.08);padding:4px 6px;text-align:center;}
                .subjective-table th{background:#132132;color:#c9e4ff;font-weight:500;letter-spacing:.4px;}
                .subjective-table select{min-width:42px;}
            `; document.head.appendChild(st);
        }
    }

    function downloadObjectAsJson(obj, filename){
        try { const blob = new Blob([JSON.stringify(obj,null,2)], {type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 250); } catch(e){ console.warn('download json fail', e); }
    }

// ===== Painel Resumo Inteligente (top 3 problemas + top 3 ações) =====
function renderSmartSummary(analysis){
    try {
        if (!(typeof window !== 'undefined' && window.CAIAR_ENABLED) || !analysis) return '';
        // Garantir plano explain (caso ainda não anexado)
        if (!analysis.caiarExplainPlan && window.audioAnalyzer && typeof analysis === 'object') {
            try {
                // se módulo ainda não carregado, importar dinamicamente
                if (!window.__CAIAR_EXPLAIN_LOADING__) {
                    window.__CAIAR_EXPLAIN_LOADING__ = import('/lib/audio/features/caiar-explain.js').then(mod=>{
                        if (mod && typeof mod.generateExplainPlan === 'function') mod.generateExplainPlan(analysis);
                    }).catch(()=>null);
                }
            } catch {}
        }
        const problems = Array.isArray(analysis.problems) ? analysis.problems.slice(0,3) : [];
        // Selecionar ações: usar passos do plano explain se existir, senão derivar das sugestões
        let steps = (analysis.caiarExplainPlan && Array.isArray(analysis.caiarExplainPlan.passos)) ? analysis.caiarExplainPlan.passos.slice(0,6) : [];
        if (steps.length === 0) {
            const sugg = Array.isArray(analysis.suggestions) ? analysis.suggestions.slice() : [];
            // Ordenar por prioridade DECRESCENTE (maior prioridade = menor valor numérico = vem primeiro)
            sugg.sort((a,b)=> (b.priority||999)-(a.priority||999));
            steps = sugg.slice(0,6).map((s,i)=>({
                ordem:i+1,
                titulo:s.message||'Ação',
                acao:s.action||'',
                porque:s.details||s.rationale? JSON.stringify(s.rationale):'Otimização recomendada',
                condicao:s.condition||s.condicao||'Aplicar quando perceptível',
                origem:s.source||s.type,
                stem:s.targetStem||null,
                parametroPrincipal: s.freqHz? (Math.round(s.freqHz)+' Hz'): (s.band||null)
            }));
        }
        const topActions = steps.slice(0,3);
        const actionItems = topActions.map(a=>{
            const stem = a.stem ? `<span class="ss-stem">${a.stem}</span>` : '';
            const param = a.parametroPrincipal ? `<span class="ss-param">${a.parametroPrincipal}</span>` : '';
            const cond = a.condicao ? `<span class="ss-cond">${a.condicao}</span>` : '';
            const whyId = 'why_'+Math.random().toString(36).slice(2);
            return `<div class="ss-action-item">
                <div class="ss-line-main">
                    <span class="ss-title">${a.titulo}</span>
                    ${stem}
                    ${param}
                </div>
                <div class="ss-line-meta">
                    ${cond}
                    <button type="button" class="ss-why-btn" data-why-target="${whyId}">Por que?</button>
                </div>
                <div class="ss-why" id="${whyId}">${a.porque || 'Melhora coerência sonora.'}</div>
            </div>`;
        }).join('');
        const problemItems = problems.map(p=>`<div class="ss-prob-item"><span class="ss-prob-msg">${p.message||''}</span></div>`).join('');
        // Expand/Collapse container
        const html = `<div class="smart-summary-card" id="smartSummaryCard">
            <div class="ss-header">
                <div class="ss-title-block">⚡ Resumo Inteligente</div>
                <button type="button" class="ss-toggle" data-expanded="true">Colapsar</button>
            </div>
            <div class="ss-content" data-collapsible="body">
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 Problemas</div>
                    ${problemItems || '<div class="ss-empty">Nenhum problema crítico</div>'}
                </div>
                <div class="ss-section">
                    <div class="ss-section-title">Top 3 Ações</div>
                    ${actionItems || '<div class="ss-empty">Nenhuma ação prioritária</div>'}
                </div>
                <div class="ss-hint">Execute as ações na ordem. Tempo de entendimento < 30s.</div>
            </div>
        </div>`;
        // Injetar estilos apenas uma vez
        if (!document.getElementById('smartSummaryStyles')) {
            const st = document.createElement('style');
            st.id = 'smartSummaryStyles';
            st.textContent = `
            .smart-summary-card{margin:12px 0 4px 0;padding:14px 16px;border:1px solid rgba(255,255,255,.08);border-radius:14px;background:linear-gradient(145deg,#0f1623,#101b2e);box-shadow:0 4px 14px -4px rgba(0,0,0,.55),0 0 0 1px rgba(255,255,255,0.03);font-size:13px;}
            .smart-summary-card .ss-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;}
            .smart-summary-card .ss-title-block{font-weight:600;letter-spacing:.5px;color:#e5f1ff;font-size:13px;}
            .smart-summary-card .ss-toggle{background:#18263a;color:#d2e6ff;border:1px solid #24364e;border-radius:8px;padding:4px 10px;font-size:11px;cursor:pointer;letter-spacing:.4px;transition:background .25s,border-color .25s;}
            .smart-summary-card .ss-toggle:hover{background:#203148;}
            .smart-summary-card .ss-section{margin-top:10px;}
            .smart-summary-card .ss-section-title{font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.7px;color:#86b4ff;margin-bottom:6px;}
            .smart-summary-card .ss-prob-item{background:rgba(255,90,90,.08);border:1px solid rgba(255,90,90,.25);padding:6px 8px;border-radius:8px;margin-bottom:6px;line-height:1.3;}
            .smart-summary-card .ss-prob-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-action-item{background:#152132;border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;margin-bottom:8px;}
            .smart-summary-card .ss-action-item:last-child{margin-bottom:0;}
            .smart-summary-card .ss-line-main{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:4px;}
            .smart-summary-card .ss-title{font-weight:600;color:#fff;font-size:13px;}
            .smart-summary-card .ss-stem{background:#24364e;color:#9ac9ff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-param{background:#1c2c44;color:#d6ecff;padding:2px 6px;font-size:10px;border-radius:6px;letter-spacing:.4px;}
            .smart-summary-card .ss-cond{font-size:10px;background:#223347;color:#cfe8ff;padding:2px 6px;border-radius:6px;letter-spacing:.3px;}
            .smart-summary-card .ss-line-meta{display:flex;align-items:center;gap:10px;}
            .smart-summary-card .ss-why-btn{background:none;border:0;color:#53b4ff;font-size:11px;cursor:pointer;padding:0 2px;}
            .smart-summary-card .ss-why{display:none;margin-top:6px;font-size:11px;line-height:1.4;background:#101c2b;padding:6px 8px;border:1px solid rgba(255,255,255,.05);border-radius:8px;color:#c7d8eb;}
            .smart-summary-card .ss-why.open{display:block;}
            .smart-summary-card .ss-hint{margin-top:10px;font-size:10px;opacity:.55;letter-spacing:.4px;}
            .smart-summary-card .ss-empty{opacity:.6;font-size:12px;padding:4px 2px;}
            .smart-summary-card[data-collapsed='true'] .ss-content{display:none;}
            @media (max-width:560px){.smart-summary-card{padding:12px 12px;} .smart-summary-card .ss-title{font-size:12px;} }
            `;
            document.head.appendChild(st);
            // Delegated listeners
            document.addEventListener('click', (e)=>{
                const btn = e.target.closest('.ss-toggle');
                if (btn){
                    const card = btn.closest('.smart-summary-card');
                    const expanded = btn.getAttribute('data-expanded') === 'true';
                    btn.setAttribute('data-expanded', expanded? 'false':'true');
                    btn.textContent = expanded? 'Expandir':'Colapsar';
                    if (expanded) card.setAttribute('data-collapsed','true'); else card.removeAttribute('data-collapsed');
                }
                const why = e.target.closest('.ss-why-btn');
                if (why){
                    const id = why.getAttribute('data-why-target');
                    const block = document.getElementById(id);
                    if (block){ block.classList.toggle('open'); }
                }
            }, { passive:true });
        }
        return html;
    } catch (e) { console.warn('smart summary fail', e); return ''; }
}

// 🎯 HELPER: Detectar se modo reference está ativo (correção definitiva)
function isReferenceCompareActive(analysis, state) {
    const hasRefJob = !!(state?.referenceJobId || analysis?.referenceComparison?.baseJobId);
    const hasRefBands = !!(
        analysis?.referenceComparison ||
        analysis?.spectralBands?.reference ||
        analysis?.bands // já normalizado com centralização
    );
    const isSecondTrack = analysis?.mode === 'reference' && state?.isSecondTrack === true;

    return (isSecondTrack && hasRefJob) || (analysis?.mode === 'reference' && hasRefBands);
}

// 🎯 HELPER: Calcular centro de um range {min, max}
function centerOfRange(range) {
    if (!range || typeof range.min !== 'number' || typeof range.max !== 'number') return null;
    return (range.min + range.max) / 2;
}

// 🎯 HELPER: Formatar target (range ou valor) para exibição
function formatTarget(rangeOrValue) {
    if (typeof rangeOrValue === 'number') return `${rangeOrValue.toFixed(1)} dB`;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        return `${rangeOrValue.min.toFixed(1)} a ${rangeOrValue.max.toFixed(1)} dB`;
    }
    return '—';
}

// 🎯 HELPER: Derivar tolerância de um range ou valor
function deriveTolerance(rangeOrValue, fallback = 2.0) {
    if (typeof rangeOrValue === 'number') return fallback;
    if (rangeOrValue && typeof rangeOrValue.min === 'number' && typeof rangeOrValue.max === 'number') {
        // 1/4 da largura do range, limitado entre 0.8 e 4.5
        const span = Math.abs(rangeOrValue.max - rangeOrValue.min);
        return Math.max(0.8, Math.min(4.5, span * 0.25));
    }
    return fallback;
}

// 🎯 HELPER: Computar se tem dados necessários para referenceComparisonMetrics
/**
 * 🎯 FUNÇÃO CRÍTICA: Obter métricas de comparação ativas (modo referência OU gênero)
 * 
 * Esta função resolve o bug onde modo gênero não detectava targets carregados.
 * 
 * REGRAS:
 * 1. Modo referência: usa analysis.referenceComparisonMetrics (vem do backend)
 * 2. Modo gênero: usa window.__activeRefData / window.PROD_AI_REF_DATA[genre] (carregado no front)
 * 3. Nunca quebra comportamento de modo referência existente
 * 
 * @param {Object} normalizedResult - Análise normalizada
 * @returns {Object|null} - Métricas de comparação ou null
 */
function getActiveReferenceComparisonMetrics(normalizedResult) {
    // 🎯 DETECÇÃO CORRETA DE MODO: Verificar genreTargets VÁLIDOS, não apenas mode='genre'
    const mode = normalizedResult?.mode || window.currentAnalysisMode || 'genre';
    const hasValidGenreTargets = normalizedResult?.data?.genreTargets && 
                                  Object.keys(normalizedResult.data.genreTargets).length > 0;
    const isRealGenreMode = mode === 'genre' && hasValidGenreTargets;
    const hasRefContext = hasActiveReferenceContext();
    
    console.group('🔍 [REF-METRICS] getActiveReferenceComparisonMetrics');
    console.log('mode:', mode);
    console.log('hasValidGenreTargets:', hasValidGenreTargets);
    console.log('isRealGenreMode:', isRealGenreMode);
    console.log('hasActiveReferenceContext():', hasRefContext);

    // 1️⃣ MODO REFERÊNCIA: usa o que veio do backend OU constrói de FirstAnalysisStore
    if (mode === 'reference' || hasRefContext) {
        if (normalizedResult?.referenceComparisonMetrics) {
            console.log('✅ [REF-METRICS] Usando referenceComparisonMetrics do backend');
            console.log('   - Fonte: backend');
            console.log('   - Tem bands:', !!normalizedResult.referenceComparisonMetrics.bands);
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        // 🔨 Construir a partir de FirstAnalysisStore se disponível
        if (window.FirstAnalysisStore?.has?.()) {
            const firstAnalysis = window.FirstAnalysisStore.get();
            console.log('✅ [REF-METRICS] Construindo a partir de FirstAnalysisStore');
            console.log('   - Fonte: FirstAnalysisStore');
            console.log('   - Tem technicalData:', !!firstAnalysis?.technicalData);
            console.groupEnd();
            return {
                bands: firstAnalysis?.technicalData?.spectral_balance || firstAnalysis?.bands,
                lufs: firstAnalysis?.technicalData?.lufsIntegrated,
                truePeak: firstAnalysis?.technicalData?.truePeakDbtp,
                dynamicRange: firstAnalysis?.technicalData?.dynamicRange,
                _isReferenceMode: true
            };
        }
    }

    // 2️⃣ MODO GÊNERO REAL: 🎯 Usar analysis.data.genreTargets
    if (isRealGenreMode) {
        console.log('🎯 [GENRE-TARGETS] Extraindo targets da análise (FONTE OFICIAL)');
        
        // 🎯 PRIORIDADE 1: analysis.data.genreTargets (BACKEND OFICIAL)
        const genreTargets = extractGenreTargetsFromAnalysis(normalizedResult);
        if (genreTargets) {
            console.log('✅ [GENRE-FIX] Usando analysis.data.genreTargets (modo genre - FONTE OFICIAL)');
            console.log('   - Fonte: analysis.data.genreTargets');
            console.log('   - Tem bands:', !!genreTargets.bands);
            console.log('   - Keys:', Object.keys(genreTargets));
            console.groupEnd();
            return genreTargets.referenceComparisonMetrics || genreTargets;
        }
        
        // 🎯 PRIORIDADE 2 (FALLBACK): window.__activeRefData (global universal)
        if (window.__activeRefData) {
            console.warn('⚠️ [GENRE-FIX] FALLBACK: Usando window.__activeRefData (analysis.data.genreTargets não disponível)');
            console.log('   - Fonte: window.__activeRefData (FALLBACK)');
            console.log('   - Tem bands:', !!window.__activeRefData.bands);
            console.log('   - Tem referenceComparisonMetrics:', !!window.__activeRefData.referenceComparisonMetrics);
            console.groupEnd();
            return window.__activeRefData.referenceComparisonMetrics || window.__activeRefData;
        }
        
        // 🎯 PRIORIDADE 3 (FALLBACK): window.PROD_AI_REF_DATA[genre] (dicionário por gênero)
        if (genre && window.PROD_AI_REF_DATA && window.PROD_AI_REF_DATA[genre]) {
            console.warn('⚠️ [GENRE-FIX] FALLBACK: Usando PROD_AI_REF_DATA[genre] (analysis.data.genreTargets não disponível)');
            console.log('   - Fonte: window.PROD_AI_REF_DATA[' + genre + '] (FALLBACK)');
            console.log('   - Tem bands:', !!window.PROD_AI_REF_DATA[genre].bands);
            console.groupEnd();
            const genreData = window.PROD_AI_REF_DATA[genre];
            return genreData.referenceComparisonMetrics || genreData;
        }
        
        // 🎯 PRIORIDADE 4 (FALLBACK): Fallback para analysis.referenceComparisonMetrics (se existir)
        if (normalizedResult?.referenceComparisonMetrics) {
            console.warn('⚠️ [GENRE-FIX] FALLBACK: Usando analysis.referenceComparisonMetrics (último recurso)');
            console.log('   - Fonte: analysis.referenceComparisonMetrics (FALLBACK)');
            console.groupEnd();
            return normalizedResult.referenceComparisonMetrics;
        }
        
        console.error('❌ [GENRE-FIX] CRÍTICO: Nenhum target de gênero encontrado!');
        console.error('   - analysis.data.genreTargets:', !!normalizedResult?.data?.genreTargets);
        console.error('   - window.__activeRefData:', !!window.__activeRefData);
        console.error('   - window.PROD_AI_REF_DATA:', !!window.PROD_AI_REF_DATA);
        console.error('   - Genre:', genre);
        console.groupEnd();
        return null;
    }

    // 3️⃣ FALLBACK: tentar analysis.referenceComparisonMetrics
    if (normalizedResult?.referenceComparisonMetrics) {
        console.log('✅ [GENRE-FIX] Usando analysis.referenceComparisonMetrics (fallback genérico)');
        console.groupEnd();
        return normalizedResult.referenceComparisonMetrics;
    }

    console.warn('❌ [GENRE-FIX] Nenhuma métrica de comparação disponível');
    console.groupEnd();
    return null;
}

function computeHasReferenceComparisonMetrics(analysis) {
    // 🎯 DETECÇÃO CORRETA: Verificar se é REALMENTE modo gênero (com targets válidos)
    const hasValidGenreTargets = analysis?.data?.genreTargets && 
                                  Object.keys(analysis.data.genreTargets).length > 0;
    const isRealGenreMode = analysis?.mode === 'genre' && hasValidGenreTargets;
    const hasRefContext = hasActiveReferenceContext();
    
    // Se for modo gênero REAL, não tem referenceComparisonMetrics
    if (isRealGenreMode && !hasRefContext) {
        console.log('[REF-METRICS] Modo gênero REAL (mode=genre + genreTargets válidos) - sem referenceComparisonMetrics');
        return false;
    }
    
    // 🎯 VERIFICAR MÚLTIPLAS FONTES
    const comparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasComparisonRows = window.__REFERENCE_COMPARISON_ROWS__?.length > 0;
    const hasFirstStore = window.FirstAnalysisStore?.has?.();
    
    const hasMetrics = !!(comparisonMetrics || (hasRefContext && (hasComparisonRows || hasFirstStore)));
    
    console.log('[REF-METRICS] computeHasReferenceComparisonMetrics:', {
        hasMetrics,
        mode: analysis?.mode,
        isRealGenreMode,
        hasRefContext,
        hasComparisonRows,
        hasFirstStore,
        hasComparisonMetrics: !!comparisonMetrics
    });
    
    return hasMetrics;
}

// --- BEGIN: band target resolver (mode-aware) ---
const BAND_NORMALIZATION_MAP = {
    // normaliza chaves heterogêneas para um vocabulário comum
    low_bass: 'bass',
    upper_bass: 'bass',
    low_mid: 'lowMid',
    high_mid: 'highMid',
    brilho: 'air',
    presenca: 'presence',
    // deixe iguais as que já batem:
    sub: 'sub',
    bass: 'bass',
    lowMid: 'lowMid',
    mid: 'mid',
    highMid: 'highMid',
    presence: 'presence',
    air: 'air'
};

const IGNORE_BANDS = new Set(['totalPercentage', '_status', 'total', 'metadata']);

// tenta extrair número: aceita { value }, { db }, { rms_db }, { energy_db }, número puro etc.
function pickNumeric(val) {
    if (val == null) return null;
    if (typeof val === 'number' && Number.isFinite(val)) return val;
    if (typeof val === 'object') {
        if (typeof val.value === 'number' && Number.isFinite(val.value)) return val.value;
        if (typeof val.db === 'number' && Number.isFinite(val.db)) return val.db;
        if (typeof val.rms_db === 'number' && Number.isFinite(val.rms_db)) return val.rms_db;
        if (typeof val.energy_db === 'number' && Number.isFinite(val.energy_db)) return val.energy_db;
    }
    return null;
}

function normalizeBandKey(k) {
    return BAND_NORMALIZATION_MAP[k] || k;
}

function getReferenceBandValue(refBands, bandKey) {
    const k = normalizeBandKey(bandKey);
    const v = refBands?.[k];
    return pickNumeric(v);
}

function getGenreTargetRange(genreTargets, bandKey) {
    const k = normalizeBandKey(bandKey);
    // Suporta {min,max} ou [min,max], e fallback para target/±tol
    const range = genreTargets?.[k];
    if (!range) return null;

    if (Array.isArray(range) && range.length === 2) {
        return { min: range[0], max: range[1], tol: Math.abs(range[1] - range[0]) / 4 || null };
    }
    if (typeof range === 'object') {
        if (typeof range.min === 'number' && typeof range.max === 'number') {
            return { min: range.min, max: range.max, tol: (range.tol ?? (Math.abs(range.max - range.min) / 4)) || null };
        }
        if (typeof range.target_db === 'number' && typeof range.tol_db === 'number') {
            return { min: range.target_db - range.tol_db, max: range.target_db + range.tol_db, tol: range.tol_db };
        }
        if (typeof range.target === 'number' && typeof range.tol === 'number') {
            return { min: range.target - range.tol, max: range.target + range.tol, tol: range.tol };
        }
    }
    return null;
}

function formatDb(n) {
    return (typeof n === 'number' && Number.isFinite(n)) ? `${n.toFixed(1)}dB` : '—';
}
// --- END: band target resolver (mode-aware) ---

// 🧠 NOVA PROTEÇÃO UNIVERSAL — Referência real > gênero
function resolveTargetMetric(analysis, key, fallback) {
    // 1️⃣ Busca no objeto da análise de referência (segunda faixa)
    if (analysis?.referenceAnalysis?.technicalData?.[key] !== undefined) {
        console.log(`🎯 [RESOLVE] ${key} encontrado em referenceAnalysis:`, analysis.referenceAnalysis.technicalData[key]);
        return analysis.referenceAnalysis.technicalData[key];
    }
    
    // 2️⃣ Busca no objeto da própria análise (se comparando com si mesma)
    if (analysis?.technicalData?.[key] !== undefined) {
        console.log(`🎯 [RESOLVE] ${key} encontrado em technicalData:`, analysis.technicalData[key]);
        return analysis.technicalData[key];
    }
    
    // 3️⃣ Busca no gênero (estrutura antiga)
    const targetKey = `${key}_target`;
    if (analysis?.referenceComparison?.[targetKey] !== undefined) {
        console.log(`🎯 [RESOLVE] ${key} encontrado em referenceComparison.${targetKey}:`, analysis.referenceComparison[targetKey]);
        return analysis.referenceComparison[targetKey];
    }
    
    // 4️⃣ Fallback seguro
    console.log(`🛡️ [RESOLVE] ${key} usando fallback:`, fallback);
    return fallback ?? 0;
}

// 🧮 PARTE 3.1: Função de normalização para estrutura de referência
function normalizeReferenceShape(a) {
  if (!a) return {};
  return {
    fileName: a.fileName || a.metadata?.fileName || "Faixa desconhecida",
    bands: a.bands || a.spectralBands,
    lufsIntegrated: a.loudness?.integrated ?? a.lufsIntegrated,
    truePeakDbtp: a.truePeak?.dbtp ?? a.truePeakDbtp,
    dynamicRange: a.dynamics?.dr ?? a.dynamicRange,
    lra: a.loudness?.range ?? a.lra,
    crestFactor: a.dynamics?.crest ?? a.crestFactor
  };
}

// 🔒 Global render lock para evitar ReferenceError
if (typeof window.comparisonLock === "undefined") {
    window.comparisonLock = false;
    console.log("[LOCK-INIT] comparisonLock inicializado como false");
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎯 BUILD COMPARISON ROWS - TABELA A/B COM DELTA
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/**
 * Constrói linhas de comparação side-by-side entre duas músicas (A vs B)
 * @param {Object} metricsA - Métricas da primeira música (base/referência)
 * @param {Object} metricsB - Métricas da segunda música (comparação)
 * @returns {Array} Array de objetos {key, label, aValue, bValue, delta, unit, status}
 */
/**
 * 🎯 Helper: Extrai métricas de analysis.metrics OU technicalData
 */
function pickFromTechnicalData(technicalData) {
    if (!technicalData) return {};
    return {
        lufsIntegrated: technicalData.lufsIntegrated,
        truePeakDbtp: technicalData.truePeakDbtp,
        dynamicRange: technicalData.dynamicRange,
        lra: technicalData.lra,
        rmsLeft: technicalData.rmsLeft,
        crestFactor: technicalData.crestFactor,
        stereoCorrelation: technicalData.stereoCorrelation
    };
}

function buildComparisonRows(metricsA, metricsB) {
    console.log('[AB-TABLE] 🔨 Construindo tabela de comparação A vs B');
    
    if (!metricsA || !metricsB) {
        console.error('[AB-TABLE] ❌ Métricas ausentes:', { hasA: !!metricsA, hasB: !!metricsB });
        return [];
    }
    
    // 🎯 CORREÇÃO #2: Extrair de metrics OU technicalData
    const userMetrics = metricsA.metrics ?? pickFromTechnicalData(metricsA.technicalData ?? metricsA);
    const refMetrics = metricsB.metrics ?? pickFromTechnicalData(metricsB.technicalData ?? metricsB);
    
    console.log('[AB-TABLE] 📊 Métricas extraídas:', {
        userKeys: Object.keys(userMetrics),
        refKeys: Object.keys(refMetrics),
        userLufs: userMetrics.lufsIntegrated,
        refLufs: refMetrics.lufsIntegrated
    });
    
    // Validar que temos pelo menos 1 métrica válida
    const userHasMetrics = Object.values(userMetrics).some(v => v != null);
    const refHasMetrics = Object.values(refMetrics).some(v => v != null);
    
    if (!userHasMetrics || !refHasMetrics) {
        console.error('[AB-TABLE] ❌ Nenhuma métrica válida encontrada:', { userHasMetrics, refHasMetrics });
        return [];
    }
    
    // Definir mapeamento de métricas (key, label, unit, path)
    const metricsMappings = [
        {
            key: 'lufs',
            label: 'LUFS Integrado',
            unit: 'LUFS',
            pathA: ['lufsIntegrated'],
            pathB: ['lufsIntegrated'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false // menor é pior (mais negativo)
        },
        {
            key: 'truePeak',
            label: 'True Peak',
            unit: 'dBTP',
            pathA: ['truePeakDbtp'],
            pathB: ['truePeakDbtp'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: true // maior é pior (clipping)
        },
        {
            key: 'dynamicRange',
            label: 'Dynamic Range',
            unit: 'dB',
            pathA: ['dynamicRange'],
            pathB: ['dynamicRange'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false // maior é melhor
        },
        {
            key: 'lra',
            label: 'LRA (Loudness Range)',
            unit: 'LU',
            pathA: ['lra'],
            pathB: ['lra'],
            format: (v) => v?.toFixed(1) || 'N/A',
            inverse: false
        },
        {
            key: 'rms',
            label: 'RMS',
            unit: 'dBFS',
            pathA: ['technicalData', 'rmsLeft'], // Usar left como referência
            pathB: ['technicalData', 'rmsLeft'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: false
        },
        {
            key: 'crestFactor',
            label: 'Crest Factor',
            unit: 'dB',
            pathA: ['technicalData', 'crestFactor'],
            pathB: ['technicalData', 'crestFactor'],
            format: (v) => v?.toFixed(2) || 'N/A',
            inverse: false
        },
        {
            key: 'stereoCorrelation',
            label: 'Correlação Estéreo',
            unit: '',
            pathA: ['technicalData', 'stereoCorrelation'],
            pathB: ['technicalData', 'stereoCorrelation'],
            format: (v) => v?.toFixed(3) || 'N/A',
            inverse: false // maior é melhor (até 1.0)
        }
    ];
    
    const rows = [];
    
    for (const mapping of metricsMappings) {
        // Extrair valor de A percorrendo path (agora de userMetrics)
        let valueA = userMetrics;
        for (const key of mapping.pathA) {
            valueA = valueA?.[key];
        }
        
        // Extrair valor de B percorrendo path (agora de refMetrics)
        let valueB = refMetrics;
        for (const key of mapping.pathB) {
            valueB = valueB?.[key];
        }
        
        // Formatar valores
        const aFormatted = mapping.format(valueA);
        const bFormatted = mapping.format(valueB);
        
        // Calcular delta (B - A)
        let delta = null;
        let deltaFormatted = 'N/A';
        let status = 'neutral';
        
        if (typeof valueA === 'number' && typeof valueB === 'number') {
            delta = valueB - valueA;
            deltaFormatted = delta >= 0 ? `+${delta.toFixed(2)}` : delta.toFixed(2);
            
            // Determinar status (melhor/pior/neutro)
            const threshold = 0.5; // Threshold para considerar diferença significativa
            if (Math.abs(delta) < threshold) {
                status = 'neutral';
            } else if (mapping.inverse) {
                // Para métricas inversas (true peak), menor delta é melhor
                status = delta < 0 ? 'better' : 'worse';
            } else {
                // Para métricas normais (LUFS, DR), maior delta é melhor
                status = delta > 0 ? 'better' : 'worse';
            }
        }
        
        rows.push({
            key: mapping.key,
            label: mapping.label,
            aValue: aFormatted,
            bValue: bFormatted,
            delta: deltaFormatted,
            unit: mapping.unit,
            status: status
        });
    }
    
    console.log('[AB-TABLE] ✅ Tabela construída com', rows.length, 'linhas');
    console.table(rows);
    
    return rows;
}

// --- BEGIN: deterministic mode gate ---
function renderReferenceComparisons(ctx) {
    // ========================================
    // 🎯 PASSO 0A: DECLARAÇÃO LOCAL DE `analysis` (FIX: ReferenceError)
    // ========================================
    // ✅ Corrige crash "ReferenceError: analysis is not defined"
    // Extrai `analysis` do contexto recebido com múltiplos fallbacks
    const analysis = ctx?.analysis || 
                     ctx?.analysisResult || 
                     ctx?.currentAnalysis || 
                     { 
                         userAnalysis: ctx?.userAnalysis, 
                         referenceAnalysis: ctx?.referenceAnalysis 
                     };
    
    console.log('[REF-RENDER-FIX] ✅ Variable analysis declarada:', {
        hasAnalysis: !!analysis,
        hasUserAnalysis: !!analysis?.userAnalysis,
        hasReferenceAnalysis: !!analysis?.referenceAnalysis,
        source: ctx?.analysis ? 'ctx.analysis' : 
                ctx?.analysisResult ? 'ctx.analysisResult' : 
                ctx?.currentAnalysis ? 'ctx.currentAnalysis' : 'constructed'
    });
    
    // ========================================
    // 🛡️ TRY/CATCH WRAPPER: Proteção contra crashes na renderização
    // ========================================
    try {
        console.log('[REF-RENDER-SAFE] Iniciando renderização protegida');
    
    // ========================================
    // 🎯 PASSO 0B: GUARD - DETECÇÃO ROBUSTA DE MODO REFERÊNCIA
    // ========================================
    const hasRefContext = hasActiveReferenceContext();
    const isModeEngineRef = SOUNDY_MODE_ENGINE.isReferenceCompare();
    const isCurrentModeRef = window.currentAnalysisMode === 'reference';
    
    // 🎯 Extrair compareMode usando helper (NUNCA ctx.mode)
    const compareMode = getCompareMode(ctx);
    
    // 🔍 LOG DE DEBUG: Estado completo do gate
    const refJobIdForLog = window.__REFERENCE_JOB_ID__ || window.__soundyState?.referenceJobId;
    const currJobIdForLog = window.__CURRENT_JOB_ID__ || ctx?.userAnalysis?.jobId;
    
    console.group('[REF-RENDER-GATE] 🔍 Validação de Modo');
    console.log('hasActiveReferenceContext():', hasRefContext);
    console.log('SOUNDY_MODE_ENGINE.isReferenceCompare():', isModeEngineRef);
    console.log('window.currentAnalysisMode:', window.currentAnalysisMode, '→ isRef:', isCurrentModeRef);
    console.log('compareMode:', compareMode, '(fonte: getCompareMode helper)');
    console.log('JobIds:', { refJobId: refJobIdForLog, currJobId: currJobIdForLog, areDifferent: refJobIdForLog !== currJobIdForLog });
    console.groupEnd();
    
    // ✅ Permitir renderização se QUALQUER condição indicar modo reference
    if (!hasRefContext && !isModeEngineRef && !isCurrentModeRef) {
        console.log('[RENDER-REF] ⏭️ Nenhum indicador de modo referência - abortando');
        return;
    }
    
    // 🛡️ GUARD: Validar se é realmente modo gênero (não apenas genre='default' falso positivo)
    const analysisCheck = ctx?.userAnalysis || ctx?.user;
    const hasValidGenreTargets = analysisCheck?.data?.genreTargets && 
                                  Object.keys(analysisCheck.data.genreTargets).length > 0;
    const isExplicitGenreMode = analysisCheck?.mode === 'genre' && hasValidGenreTargets;
    
    if (isExplicitGenreMode) {
        console.log('[RENDER-REF] 🎯 Modo gênero REAL detectado (mode=genre + genreTargets válidos) - abortando');
        return;
    }
    
    console.log('[RENDER-REF] ✅ Modo referência confirmado - prosseguindo com renderização');
    
    // ========================================
    // 🎯 PASSO 1: VALIDAR DADOS DO STORE SE DISPONÍVEL (MODO REFERENCE)
    // ========================================
    console.group('🎯 [RENDER-REF] VALIDAÇÃO DE FONTE DE DADOS');
    
    if (ctx?._useStoreData) {
        console.log('✅ [STORE-MODE] Renderização usando dados do store isolado');
        console.log('   - userAnalysis.jobId:', ctx.userAnalysis?.jobId);
        console.log('   - referenceAnalysis.jobId:', ctx.referenceAnalysis?.jobId);
        
        // Validação de integridade do store
        if (window.SoundyAI_Store?.first && window.SoundyAI_Store?.second) {
            console.table({
                refJobId: window.SoundyAI_Store.first?.jobId,
                currJobId: window.SoundyAI_Store.second?.jobId,
                refName: window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName,
                currName: window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName,
                sameJob: window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId,
                sameName: (window.SoundyAI_Store.first?.fileName || window.SoundyAI_Store.first?.metadata?.fileName) === 
                          (window.SoundyAI_Store.second?.fileName || window.SoundyAI_Store.second?.metadata?.fileName)
            });
            
            // 🚨 VALIDAÇÃO CRÍTICA: Store NÃO pode ter jobIds iguais
            if (window.SoundyAI_Store.first?.jobId === window.SoundyAI_Store.second?.jobId) {
                console.error('🚨 [STORE-ERROR] STORE CONTAMINADO!');
                console.error('   - Store tem jobIds idênticos');
                console.trace();
                console.groupEnd();
                alert('ERRO: Store contaminado detectado. Por favor, recarregue a página.');
                return;
            }
            
            console.log('✅ [STORE-VALIDATED] Store validado - dados isolados confirmados');
        } else {
            console.warn('⚠️ [STORE-WARN] Store não está completo');
            console.log('   - Caindo para modo legado');
        }
    } else {
        console.log('⚠️ [LEGACY-MODE] Renderização usando sistema legado');
        console.log('   - Dados não vêm do store isolado');
    }
    
    console.groupEnd();
    
    // ========================================
    // 🚨 VALIDAÇÃO CRÍTICA NO INÍCIO: Tentar recuperar jobIds corretos se necessário
    // ========================================
    let userJobId = ctx?.userAnalysis?.jobId || ctx?.user?.jobId;
    let refJobId = ctx?.referenceAnalysis?.jobId || ctx?.ref?.jobId;
    
    console.group('🎯 [RENDER-REF] Iniciando renderização com validação');
    console.log('   userJobId recebido:', userJobId);
    console.log('   refJobId recebido:', refJobId);
    console.log('   São iguais?', userJobId === refJobId);
    
    // Se recebeu jobIds iguais, TENTA RECUPERAR os corretos
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('❌ [RENDER-REF] ERRO: Recebeu jobIds iguais!');
        console.error('   Tentando recuperar jobIds corretos com getCorrectJobId()...');
        
        // RECUPERA os jobIds corretos
        const recoveredCurrentJobId = getCorrectJobId('current');
        const recoveredReferenceJobId = getCorrectJobId('reference');
        
        console.log('🔄 [RENDER-REF] JobIds recuperados:');
        console.log('   Novo userJobId (current):', recoveredCurrentJobId);
        console.log('   Novo refJobId (reference):', recoveredReferenceJobId);
        console.log('   Recuperados são diferentes?', recoveredCurrentJobId !== recoveredReferenceJobId);
        
        // Se AINDA forem iguais, ABORTA
        if (recoveredCurrentJobId === recoveredReferenceJobId) {
            console.error('❌ [RENDER-REF] FALHA NA RECUPERAÇÃO!');
            console.error('   Mesmo após getCorrectJobId(), os jobIds são iguais');
            console.trace();
            console.groupEnd();
            alert('ERRO: Não foi possível carregar a comparação. Os jobIds são iguais. Recarregue a página.');
            return;
        }
        
        console.log('✅ [RENDER-REF] JobIds recuperados com sucesso!');
        console.log('   Atualizando userJobId e refJobId no contexto...');
        
        // Atualizar jobIds no contexto
        userJobId = recoveredCurrentJobId;
        refJobId = recoveredReferenceJobId;
        
        // Atualizar também no ctx se possível
        if (ctx?.userAnalysis) ctx.userAnalysis.jobId = userJobId;
        if (ctx?.referenceAnalysis) ctx.referenceAnalysis.jobId = refJobId;
        if (ctx?.user) ctx.user.jobId = userJobId;
        if (ctx?.ref) ctx.ref.jobId = refJobId;
    } else {
        console.log('✅ [RENDER-REF] JobIds já são diferentes - continuando normalmente');
    }
    
    console.groupEnd();
    
    // ========================================
    // 🚨 VALIDAÇÃO CRÍTICA: NUNCA COMPARAR MESMA MÚSICA (validação original mantida)
    // ========================================
    console.group('🚨 [RENDER-VALIDATION] Validação crítica de jobIds');
    console.log('   - userJobId (após possível recuperação):', userJobId);
    console.log('   - refJobId (após possível recuperação):', refJobId);
    console.log('   - São iguais?', userJobId === refJobId);
    
    // VALIDAÇÃO CRÍTICA: Se jobIds são iguais, ABORTAR renderização
    if (userJobId && refJobId && userJobId === refJobId) {
        console.error('❌ [RENDER] ERRO CRÍTICO: Tentando comparar mesma música!');
        console.error('   userJobId:', userJobId);
        console.error('   refJobId:', refJobId);
        console.trace();
        
        // Tenta recuperar o jobId correto da segunda música
        const recoveredJobId = getCorrectJobId('current'); // Segunda música
        const firstJobId = getCorrectJobId('reference'); // Primeira música
        
        console.log('🔄 [RENDER] Tentando recuperar jobIds corretos:');
        console.log('   - Recovered currentJobId:', recoveredJobId);
        console.log('   - Recovered referenceJobId:', firstJobId);
        
        if (recoveredJobId && firstJobId && recoveredJobId !== firstJobId) {
            console.warn('⚠️ [RENDER] JobIds recuperados - reconstruindo ctx');
            // Reconstruir ctx com jobIds corretos
            // Por ora, ABORTAR para evitar renderização incorreta
            alert('ERRO: Não foi possível carregar a comparação corretamente. Por favor, recarregue a página e tente novamente.');
            console.groupEnd();
            return;
        } else {
            console.error('❌ [RENDER] Não foi possível recuperar jobIds corretos');
            alert('ERRO CRÍTICO: Comparação inválida detectada. Recarregue a página.');
            console.groupEnd();
            return;
        }
    }
    
    console.log('✅ [RENDER-VALIDATION] JobIds são diferentes - continuando renderização');
    console.groupEnd();
    
    // ========================================
    // ✅ CORREÇÃO 3: Padronização de chamada e validação de ctx
    // ========================================
    // Normalizar ctx para aceitar objeto { mode, user, ref }
    const mode = ctx?.mode || window.currentAnalysisMode || 'genre';
    const user = ctx?.user || ctx?.userAnalysis || window._lastUserAnalysis || {};
    const refData = ctx?.ref || ctx?.referenceAnalysis || window.referenceAnalysisData || {};

    // HARD-GUARD: sem bands? não renderiza A/B para evitar self-compare
    if (mode === 'reference') {
        if (!refData?.bands || !user?.bands) {
            console.warn('[A/B-SKIP] bands ausentes (user/ref). Evitando self-compare.');
            console.warn('[SUG-AUDIT][REFERENCE] ⚠️ Modo reference mas sem bandas - pode afetar suggestions');
            return;
        }
        
        // ✅ AUDITORIA: Verificar se suggestions estão presentes
        console.log('[SUG-AUDIT][REFERENCE] Dados recebidos:', {
            userHasSuggestions: Array.isArray(user?.suggestions),
            userSuggestionsLength: user?.suggestions?.length || 0,
            refHasSuggestions: Array.isArray(refData?.suggestions),
            refSuggestionsLength: refData?.suggestions?.length || 0
        });
    }

    // Atualizar opts para compatibilidade com código existente
    const opts = {
        mode: mode,
        userAnalysis: user,
        referenceAnalysis: refData,
        ...ctx // Mesclar propriedades adicionais de ctx
    };

    // ========================================
    // 🛡️ BLOQUEIO DEFINITIVO DE SELF-COMPARE POR CONTEÚDO
    // ========================================
    // Recuperar faixas do FirstAnalysisStore usando papéis (USER/REF)
    const userFromStoreRaw = FirstAnalysisStore.getUser();
    const refFromStoreRaw = FirstAnalysisStore.getRef();
    
    // 🎯 HIDRATAR E NORMALIZAR: Garantir shape consistente (dupla proteção)
    const userFromStore = normalizeAnalysis(userFromStoreRaw);
    const refFromStore = normalizeAnalysis(refFromStoreRaw);
    
    console.log('[HYDRATE] 🔄 Dados normalizados do store:', {
        userHasBands: !!userFromStore?.bands,
        refHasBands: !!refFromStore?.bands,
        userHasMetrics: !!userFromStore?.metrics,
        refHasMetrics: !!refFromStore?.metrics
    });
    
    // 🔍 NOVA VALIDAÇÃO: Verificar métricas A/B ao invés de bands
    const userMetricsCheck = extractABMetrics(userFromStore);
    const refMetricsCheck = extractABMetrics(refFromStore);
    
    console.log('[AB-DATA] user metrics extraction ok?', userMetricsCheck.ok, userMetricsCheck.debugShape);
    console.log('[AB-DATA] ref metrics extraction ok?', refMetricsCheck.ok, refMetricsCheck.debugShape);
    
    if (!userMetricsCheck.ok || !refMetricsCheck.ok) {
        console.warn('[AB-BLOCK] ⚠️ Métricas A/B ausentes no store - tentando hidratar...');
        
        // 🎯 TENTATIVA DE HIDRATAÇÃO: Recuperar da análise atual se disponível
        if (!refMetricsCheck.ok && window.referenceAnalysisData) {
            const refFromWindow = extractABMetrics(window.referenceAnalysisData);
            if (refFromWindow.ok) {
                console.log('[AB-HYDRATE] 🔄 Hidratando refFromStore com window.referenceAnalysisData');
                const hydratedRef = {
                    ...refFromStore,
                    bands: extractBands(window.referenceAnalysisData),
                    metrics: refFromWindow.metrics,
                    technicalData: refFromWindow.technicalData,
                    jobId: window.referenceAnalysisData.jobId || window.__REFERENCE_JOB_ID__
                };
                FirstAnalysisStore.setRef(hydratedRef);
            }
        }
        
        if (!userMetricsCheck.ok && ctx?.userAnalysis) {
            const userFromCtx = extractABMetrics(ctx.userAnalysis);
            if (userFromCtx.ok) {
                console.log('[AB-HYDRATE] 🔄 Hidratando userFromStore com ctx.userAnalysis');
                const hydratedUser = {
                    ...userFromStore,
                    bands: extractBands(ctx.userAnalysis),
                    metrics: userFromCtx.metrics,
                    technicalData: userFromCtx.technicalData,
                    jobId: ctx.userAnalysis.jobId
                };
                FirstAnalysisStore.setUser(hydratedUser);
            }
        }
        
        // Re-verificar após hidratação
        const reCheckUser = FirstAnalysisStore.getUser();
        const reCheckRef = FirstAnalysisStore.getRef();
        const reCheckUserMetrics = extractABMetrics(reCheckUser);
        const reCheckRefMetrics = extractABMetrics(reCheckRef);
        
        if (!reCheckUserMetrics.ok || !reCheckRefMetrics.ok) {
            console.error('[AB-BLOCK] ❌ Hidratação falhou - abortando A/B');
            console.error('[AB-DATA] user recheck:', reCheckUserMetrics.debugShape);
            console.error('[AB-DATA] ref recheck:', reCheckRefMetrics.debugShape);
            return;
        }
        
        console.log('[AB-HYDRATE] ✅ Hidratação bem-sucedida');
    }
    
    // Detectar self-compare por múltiplos critérios de conteúdo
    const samePointer = userFromStore === refFromStore;
    const sameJobId = userFromStore?.jobId && refFromStore?.jobId && userFromStore.jobId === refFromStore.jobId;
    const sameFile = userFromStore?.metadata?.fileKey && refFromStore?.metadata?.fileKey && 
                     userFromStore.metadata.fileKey === refFromStore.metadata.fileKey;
    const sameHash = userFromStore?.objectId?.hash && refFromStore?.objectId?.hash && 
                     userFromStore.objectId.hash === refFromStore.objectId.hash;
    
    if (samePointer || sameJobId || sameFile || sameHash) {
        console.error('[AB-BLOCK] ❌ Self-compare detectado - abortando tabela A/B:', {
            samePointer,
            sameJobId: sameJobId ? `${userFromStore.jobId}` : false,
            sameFile: sameFile ? `${userFromStore.metadata.fileKey}` : false,
            sameHash: sameHash ? `${userFromStore.objectId.hash}` : false,
            userVid: window.CacheIndex.USER,
            refVid: window.CacheIndex.REF,
            userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
            refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName
        });
        return; // Aborta renderização A/B
    }
    
    // ✅ Validação passou - são faixas diferentes
    console.log('[AB-SAFETY] ✅ Faixas validadas como diferentes:', {
        userVid: window.CacheIndex.USER,
        refVid: window.CacheIndex.REF,
        userFile: userFromStore?.fileName || userFromStore?.metadata?.fileName,
        refFile: refFromStore?.fileName || refFromStore?.metadata?.fileName,
        userJobId: userFromStore?.jobId,
        refJobId: refFromStore?.jobId
    });
    
    // 🎯 [STORE-PRIORITY-FIX] PRIORIDADE ABSOLUTA: SoundyAI_Store > FirstAnalysisStore
    console.log('🎯 [STORE-PRIORITY-FIX] Verificando prioridade de fonte de dados...');
    
    // Verificar se SoundyAI_Store tem ambas análises
    const storeHasBoth = window.SoundyAI_Store?.first && window.SoundyAI_Store?.second;
    
    let finalUserAnalysis, finalReferenceAnalysis;
    
    if (storeHasBoth) {
        console.log('✅ [STORE-PRIORITY-FIX] Usando SoundyAI_Store (prioridade máxima)');
        finalUserAnalysis = window.SoundyAI_Store.first;
        finalReferenceAnalysis = window.SoundyAI_Store.second;
        
        console.table({
            'Fonte': 'SoundyAI_Store',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId,
            'User LUFS': finalUserAnalysis?.technicalData?.lufsIntegrated,
            'Ref LUFS': finalReferenceAnalysis?.technicalData?.lufsIntegrated,
            'User DR': finalUserAnalysis?.technicalData?.dynamicRange,
            'Ref DR': finalReferenceAnalysis?.technicalData?.dynamicRange,
            'User TruePeak': finalUserAnalysis?.technicalData?.truePeakDbtp,
            'Ref TruePeak': finalReferenceAnalysis?.technicalData?.truePeakDbtp
        });
    } else {
        console.warn('⚠️ [STORE-PRIORITY-FIX] SoundyAI_Store incompleto, usando FirstAnalysisStore (fallback)');
        finalUserAnalysis = userFromStore;
        finalReferenceAnalysis = refFromStore;
        
        console.table({
            'Fonte': 'FirstAnalysisStore (fallback)',
            'User JobId': finalUserAnalysis?.jobId,
            'Ref JobId': finalReferenceAnalysis?.jobId
        });
    }
    
    // Usar as faixas priorizadas (SoundyAI_Store > FirstAnalysisStore)
    opts.userAnalysis = finalUserAnalysis;
    opts.referenceAnalysis = finalReferenceAnalysis;
    
    // ========================================
    // 🔧 DETECÇÃO SEGURA DE SELF-COMPARE (APÓS AB-SAFETY)
    // ========================================
    // Agora que temos os dados validados, detectar self-compare com critérios rigorosos
    const refAnalysis = opts.referenceAnalysis;
    const currAnalysis = opts.userAnalysis;
    
    const sameJob = !!(refAnalysis?.jobId && currAnalysis?.jobId && refAnalysis.jobId === currAnalysis.jobId);
    const sameVid = !!(refAnalysis?.vid && currAnalysis?.vid && refAnalysis.vid === currAnalysis.vid);
    const sameFileName = !!(refAnalysis?.fileName && currAnalysis?.fileName && refAnalysis.fileName === currAnalysis.fileName);
    const refVid = window.CacheIndex?.REF;
    const userVid = window.CacheIndex?.USER;
    
    // Só marca como selfCompare se TODAS as checagens coincidirem
    let selfCompare = false;
    if (sameJob && sameVid && sameFileName) {
        selfCompare = true;
        console.warn('[REF-GUARD] ⚠️ Self-compare detectado (todos critérios):', { sameJob, sameVid, sameFileName });
    }
    
    // ✅ REVALIDAÇÃO: Limpar flag se for falso positivo
    // Se VIDs ou files são diferentes, não pode ser self-compare
    if (selfCompare && (userVid !== refVid || 
        (refAnalysis?.fileName || refAnalysis?.metadata?.fileName) !== (currAnalysis?.fileName || currAnalysis?.metadata?.fileName))) {
        console.warn('[REF-GUARD] ❎ Corrigido selfCompare falso-positivo após AB-SAFETY:', {
            userVid,
            refVid,
            userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
            refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
        });
        selfCompare = false;
    }
    
    // Marcar no opts para uso posterior
    opts.isSelfCompare = selfCompare;
    
    console.log('[SELF-COMPARE-FINAL] Decisão final:', {
        selfCompare,
        sameJob,
        sameVid,
        sameFileName,
        userVid,
        refVid,
        userFile: currAnalysis?.fileName || currAnalysis?.metadata?.fileName,
        refFile: refAnalysis?.fileName || refAnalysis?.metadata?.fileName
    });
    
    // ==== STEP 3/6: refHardGuards() simplificado ====
    const guardResult = (function refHardGuards(){
        const s = window.__soundyState || {};
        
        if (!opts.userAnalysis || !opts.referenceAnalysis) {
            console.error("[REF-PATCH] Faltam dados pra A/B");
            return { abort: true, reason: 'missing-data' };
        }

        opts.usedReferenceAnalysis = true;

        if (window.__refRenderInProgress) {
            console.warn("[REF-PATCH] Render A/B em progresso — ignorando duplicado");
            return { abort: true, reason: 'render-in-progress' };
        }
        window.__refRenderInProgress = true;
        
        return { abort: false };
    })();
    
    // ✅ STEP 3/6: Tratar retorno de refHardGuards()
    if (guardResult && guardResult.abort) {
        console.warn(`[REF-GUARD] Abortando renderReferenceComparisons: ${guardResult.reason}`);
        return;
    }
    
    // � [AUDIT-BANDS-IN-RENDER] Log NO INÍCIO da função renderReferenceComparisons
    try {
        const refBandsInRender = opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance;
        const userBandsInRender = opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance;
        console.log('[AUDIT-BANDS-IN-RENDER]', {
            receivedRefBands: refBandsInRender,
            receivedUserBands: userBandsInRender,
            typeofRefBands: typeof refBandsInRender,
            typeofUserBands: typeof userBandsInRender,
            refBandsKeys: refBandsInRender ? Object.keys(refBandsInRender) : [],
            userBandsKeys: userBandsInRender ? Object.keys(userBandsInRender) : [],
            optsKeys: Object.keys(opts),
            hasUserAnalysis: !!opts.userAnalysis,
            hasReferenceAnalysis: !!opts.referenceAnalysis
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-RENDER', err);
    }
    
    // �🔒 PROTEÇÃO ANTI-DUPLICAÇÃO: Detectar se faixas são idênticas
    if (opts.userAnalysis?.fileName && opts.referenceAnalysis?.fileName &&
        opts.userAnalysis.fileName === opts.referenceAnalysis.fileName) {
        console.error("❌ [REF-DUPE] Detecção de duplicação — referência sobrescrita!");
        console.table({
            userTrack: opts.userAnalysis?.fileName,
            refTrack: opts.referenceAnalysis?.fileName,
        });
        return; // aborta renderização duplicada
    }
    
    // 🧩 Controle seguro de renderização
    if (window.comparisonLock) {
        console.warn("[LOCK] Renderização de comparação ignorada (lock ativo)");
        return;
    }
    
    // [AUDIT-FLOW] Log ANTES do lock
    console.log("[AUDIT-FLOW] 🔍 ANTES do lock:", {
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    window.comparisonLock = true;
    console.log("[LOCK] comparisonLock ativado");
    
    // [AUDIT-FLOW] Log DEPOIS do lock
    console.log("[AUDIT-FLOW] 🔍 DEPOIS do lock:", {
        comparisonLock: window.comparisonLock,
        userAnalysis: !!opts.userAnalysis,
        referenceAnalysis: !!opts.referenceAnalysis,
        userBands: opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance,
        refBands: opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance,
        hasUserBands: !!(opts.userAnalysis?.bands || opts.userAnalysis?.technicalData?.spectral_balance),
        hasRefBands: !!(opts.referenceAnalysis?.bands || opts.referenceAnalysis?.technicalData?.spectral_balance)
    });
    
    // 🔧 PARTE 2: Proteção em renderReferenceComparisons
    const globalState = window.__soundyState || {};
    const refStateCheck = globalState?.reference || {};
    const userCheck = refStateCheck.userAnalysis || opts.userAnalysis;
    const refCheck = refStateCheck.referenceAnalysis || opts.referenceAnalysis;

    if (!userCheck || !refCheck) {
        console.warn("[REF-COMP] Faltam dados de referência ou usuário, usando fallback seguro");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (fallback)");
        return renderGenreComparisonSafe?.();
    }

    const userTrackCheck = userCheck.fileName || userCheck.metadata?.fileName || "Faixa 1 (usuário)";
    const refTrackCheck = refCheck.fileName || refCheck.metadata?.fileName || "Faixa 2 (referência)";
    const userBandsCheck = userCheck.bands || userCheck.technicalData?.spectral_balance || {};
    const refBandsCheck = refCheck.bands || refCheck.technicalData?.spectral_balance || {};

    const userBandsCountCheck = userBandsCheck ? Object.keys(userBandsCheck).length : 0;
    const refBandsCountCheck = refBandsCheck ? Object.keys(refBandsCheck).length : 0;
    
    if (refBandsCountCheck === 0) {
        console.warn("[REF-COMP] referenceBands ausentes - fallback para valores brutos");
    }

    console.log("[REF-COMP] Dados validados:", { 
        userTrackCheck, 
        refTrackCheck, 
        userBandsCount: userBandsCountCheck, 
        refBandsCount: refBandsCountCheck,
        userBandsKeys: userBandsCheck ? Object.keys(userBandsCheck) : [],
        refBandsKeys: refBandsCheck ? Object.keys(refBandsCheck) : []
    });
    
    // 🎯 GARANTIR QUE CONTAINER EXISTE ANTES DE RENDERIZAR
    const container = ensureReferenceContainer();
    if (!container) {
        console.error('[RENDER-REF] ❌ Não foi possível criar/localizar container #referenceComparisons');
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (container indisponível)");
        
        // Tentar criar mensagem de erro em local alternativo
        const modalContent = document.getElementById('audioAnalysisResults');
        if (modalContent) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.cssText = 'padding: 20px; margin: 20px 0; background: #2a1a1a; border: 2px solid #ff4444; border-radius: 8px; color: #ff6666;';
            errorDiv.innerHTML = '<strong>❌ Erro:</strong> Não foi possível renderizar tabela de comparação A/B (container ausente).';
            modalContent.insertBefore(errorDiv, modalContent.firstChild);
        }
        return;
    }
    
    // 🔧 CORREÇÃO CRÍTICA: Removido __REF_RENDER_LOCK__ que bloqueava segunda chamada legítima
    // A validação de dados abaixo é suficiente para prevenir renders incompletos
    console.log("[LOCK-FIX] ✅ Permitindo render com validação de dados (lock duplicado removido)");
    
    // Aceita opts ou analysis (backward compatibility)
    const finalAnalysis = opts.analysis || opts;
    let comparisonData = opts?.comparisonData || {};
    
    const refBandsReal =
        comparisonData?.refBands ||
        comparisonData?.referenceAnalysis?.bands ||
        comparisonData?.referenceAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.referenceAnalysis?.bands ||
        window.__soundyState?.reference?.referenceAnalysis?.technicalData?.spectral_balance;

    const userBandsReal =
        comparisonData?.userBands ||
        comparisonData?.userAnalysis?.bands ||
        comparisonData?.userAnalysis?.technicalData?.spectral_balance ||
        window.__soundyState?.reference?.userAnalysis?.bands ||
        window.__soundyState?.reference?.userAnalysis?.technicalData?.spectral_balance;

    console.log('[VALIDATION-FIX] Verificando bandas:', {
        refBandsRealKeys: refBandsReal ? Object.keys(refBandsReal) : null,
        userBandsRealKeys: userBandsReal ? Object.keys(userBandsReal) : null,
    });

    if (!refBandsReal || !userBandsReal) {
        console.error('[VALIDATION-FIX] ❌ Falha crítica: bandas não detectadas no momento do render.');
        console.error('comparisonData:', comparisonData);
        console.error('window.__soundyState:', window.__soundyState);
        window.comparisonLock = false;
        if (typeof displayModalResultsError === 'function') {
            return displayModalResultsError('Erro na análise por referência (bandas não detectadas).');
        }
        return;
    }

    // ✅ Substitui o fallback antigo
    comparisonData.refBands = refBandsReal;
    comparisonData.userBands = userBandsReal;
    console.log('[VALIDATION-FIX] ✅ Bandas restauradas para renderização A/B');
    
    // 🧠 [SAFE_REF_V3] PATCH DEFINITIVO - Construir estrutura segura ANTES de qualquer acesso
    console.groupCollapsed("🧠 [SAFE_REF_V3]");
    console.log("📦 opts recebido:", opts);
    
    // 🔐 Obter state global
    const stateV3 = window.__soundyState || {};
    
    // 🔐 Obter análises primeiro
    const ua = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
    const ra = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
    
    // 🔐 Construir comparação segura com múltiplas fontes
    let comparisonBase = 
        opts?.comparisonData || 
        window?.comparisonData || 
        window?.lastComparisonData || 
        {};
    
    // 🎯 SEMÂNTICA CORRETA:
    // - userTrack = 1ª faixa (SUA MÚSICA/ATUAL) = userAnalysis
    // - referenceTrack = 2ª faixa (REFERÊNCIA/ALVO) = referenceAnalysis
    let comparisonSafe;
    
    if (!comparisonBase.userTrack || !comparisonBase.referenceTrack) {
        console.warn("⚠️ [SAFE_REF_V3] comparisonData incompleto — tentando reconstruir via análises");
        
        comparisonSafe = {
            userTrack: ua?.metadata?.fileName || ua?.fileName || "1ª Faixa (Sua Música/Atual)",
            referenceTrack: ra?.metadata?.fileName || ra?.fileName || "2ª Faixa (Referência/Alvo)",
            userBands: 
                ua?.technicalData?.spectral_balance || 
                ua?.bands || 
                ua?.spectralBands || 
                null,
            refBands: 
                ra?.technicalData?.spectral_balance || 
                ra?.bands || 
                ra?.spectralBands || 
                null,
        };
    } else {
        comparisonSafe = comparisonBase;
    }
    
    // 🔍 [AUDIT-BANDS-SAFE-V3] Log APÓS construção de comparisonSafe
    try {
        console.log('[AUDIT-BANDS-SAFE-V3]', {
            comparisonSafeUserBands: comparisonSafe.userBands,
            comparisonSafeRefBands: comparisonSafe.refBands,
            typeofUserBands: typeof comparisonSafe.userBands,
            typeofRefBands: typeof comparisonSafe.refBands,
            userBandsKeys: comparisonSafe.userBands ? Object.keys(comparisonSafe.userBands) : [],
            refBandsKeys: comparisonSafe.refBands ? Object.keys(comparisonSafe.refBands) : [],
            sourceUA: ua ? 'opts.userAnalysis ou state.reference.userAnalysis' : 'N/A',
            sourceRA: ra ? 'opts.referenceAnalysis ou state.reference.referenceAnalysis' : 'N/A',
            uaBands: ua?.technicalData?.spectral_balance || ua?.bands || ua?.spectralBands,
            raBands: ra?.technicalData?.spectral_balance || ra?.bands || ra?.spectralBands
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-SAFE-V3', err);
    }
    
    // Guardar globalmente (backup)
    window.lastComparisonData = comparisonSafe;
    
    // 🧩 Substituir opts.comparisonData quebrado
    opts.comparisonData = comparisonSafe;
    
    // 🔒 Fallback hard caso ainda venha undefined
    if (!comparisonSafe.referenceTrack) {
        comparisonSafe.referenceTrack = 
            opts?.referenceAnalysis?.metadata?.fileName || 
            opts?.referenceAnalysis?.fileName ||
            stateV3?.reference?.referenceAnalysis?.metadata?.fileName || 
            "2ª Faixa (Referência/Alvo)";
    }
    if (!comparisonSafe.userTrack) {
        comparisonSafe.userTrack = 
            opts?.userAnalysis?.metadata?.fileName || 
            opts?.userAnalysis?.fileName ||
            stateV3?.reference?.userAnalysis?.metadata?.fileName || 
            "1ª Faixa (Sua Música/Atual)";
    }
    
    console.log("✅ [SAFE_REF_V3] Estrutura final reconstruída:", comparisonSafe);
    console.groupEnd();
    

    //  [PATCH V5] SCOPE GUARD DEFINITIVO - Sincronização final antes de usar dados
    console.groupCollapsed(" [REF_FIX_V5]");
    let userTrack, referenceTrack;
    try {
        //  Verifica e sincroniza escopo de comparisonData
        // 🎯 SEMÂNTICA CORRETA:
        // - userTrack = 1ª faixa (SUA MÚSICA/ATUAL) = userAnalysis
        // - referenceTrack = 2ª faixa (REFERÊNCIA/ALVO) = referenceAnalysis
        let comparisonData =
            opts?.comparisonData ||
            window?.comparisonData ||
            window?.lastComparisonData ||
            stateV3?.reference?.comparisonData ||
            comparisonSafe || // Usar comparisonSafe do Patch V3 como fallback
            {
                userTrack:
                    opts?.userAnalysis?.metadata?.fileName ||
                    opts?.userAnalysis?.fileName ||
                    stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                    "Sua Música (Atual)",
                referenceTrack:
                    opts?.referenceAnalysis?.metadata?.fileName ||
                    opts?.referenceAnalysis?.fileName ||
                    stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                    "Faixa de Referência (Alvo)",
                userBands:
                    opts?.userAnalysis?.technicalData?.spectral_balance ||
                    opts?.userAnalysis?.bands ||
                    stateV3?.reference?.userAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.userAnalysis?.bands ||
                    {},
                refBands:
                    opts?.referenceAnalysis?.technicalData?.spectral_balance ||
                    opts?.referenceAnalysis?.bands ||
                    stateV3?.reference?.referenceAnalysis?.technicalData?.spectral_balance ||
                    stateV3?.reference?.referenceAnalysis?.bands ||
                    {},
            };

        // 🧩 FIX: Preservar bandas válidas antes da redeclaração
        if (comparisonData) {
            // Se já houver bandas válidas em comparisonSafe, preservar
            if (!comparisonData.refBands && comparisonSafe?.refBands) {
                comparisonData.refBands = comparisonSafe.refBands;
            }
            if (!comparisonData.userBands && comparisonSafe?.userBands) {
                comparisonData.userBands = comparisonSafe.userBands;
            }
            
            // Fallback adicional para opts se comparisonData ainda vazio
            if (!comparisonData.refBands && opts?.referenceAnalysis) {
                comparisonData.refBands =
                    opts.referenceAnalysis.bands ||
                    opts.referenceAnalysis.technicalData?.spectral_balance ||
                    window.__lastRefBands ||
                    {};
            }
            if (!comparisonData.userBands && opts?.userAnalysis) {
                comparisonData.userBands =
                    opts.userAnalysis.bands ||
                    opts.userAnalysis.technicalData?.spectral_balance ||
                    window.__lastUserBands ||
                    {};
            }
        }

        //  Atualiza referências globais
        window.comparisonData = comparisonData;
        window.lastComparisonData = comparisonData;
        opts.comparisonData = comparisonData;

        //  Cria variáveis locais seguras com fallback robusto
        // 🎯 SEMÂNTICA CORRETA DOS NOMES:
        userTrack = comparisonData?.userTrack || "Sua Música (Atual)";
        referenceTrack = comparisonData?.referenceTrack || "Faixa de Referência (Alvo)";
        
        // ⚡ Fallback em cascata para garantir bandas válidas (incluindo persistência global)
        const localRefBands =
            window.__lastRefBands ||
            comparisonData?.refBands ||
            comparisonSafe?.refBands ||
            opts?.referenceAnalysis?.bands ||
            opts?.referenceAnalysis?.technicalData?.spectral_balance ||
            {};
        
        const localUserBands =
            window.__lastUserBands ||
            comparisonData?.userBands ||
            comparisonSafe?.userBands ||
            opts?.userAnalysis?.bands ||
            opts?.userAnalysis?.technicalData?.spectral_balance ||
            {};
        
        // [REF-COMP] ✅ Persistir bandas globalmente para uso posterior
        if (localRefBands && Object.keys(localRefBands).length > 0) window.__lastRefBands = localRefBands;
        if (localUserBands && Object.keys(localUserBands).length > 0) window.__lastUserBands = localUserBands;
        
        console.log('[REF-COMP][BANDS-FINAL-FIX] Estado de bandas após fallback:', {
            hasRefBands: !!localRefBands && Object.keys(localRefBands).length > 0,
            hasUserBands: !!localUserBands && Object.keys(localUserBands).length > 0,
            refKeys: localRefBands ? Object.keys(localRefBands) : [],
            userKeys: localUserBands ? Object.keys(localUserBands) : []
        });

        // 🔍 [AUDIT-REDECLARE] Log APÓS redeclaração de variáveis
        try {
            console.log('[AUDIT-REDECLARE]', {
                refBandsCheck: localRefBands,
                userBandsCheck: localUserBands,
                typeofRefBands: typeof localRefBands,
                typeofUserBands: typeof localUserBands,
                refBandsKeys: localRefBands ? Object.keys(localRefBands) : [],
                userBandsKeys: localUserBands ? Object.keys(localUserBands) : [],
                refBandsIsEmpty: !localRefBands || Object.keys(localRefBands).length === 0,
                userBandsIsEmpty: !localUserBands || Object.keys(localUserBands).length === 0,
                comparisonDataRefBands: comparisonData?.refBands,
                comparisonDataUserBands: comparisonData?.userBands
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'AUDIT-REDECLARE', err);
        }

        console.log(" [REF_FIX_V5] Estrutura estabilizada:", {
            userTrack,
            referenceTrack,
            userBands: !!Object.keys(localUserBands || {}).length,
            refBands: !!Object.keys(localRefBands || {}).length,
        });

        //  Abortagem segura se algo vier undefined
        if (!referenceTrack || !userTrack) {
            console.error(" [REF_FIX_V5] referenceTrack ou userTrack ausentes!");
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (track ausente)");
            console.groupEnd();
            return;
        }

        //  Reatribui localmente para garantir escopo
        opts.referenceTrack = referenceTrack;
        opts.userTrack = userTrack;
        comparisonData.referenceTrack = referenceTrack;
        comparisonData.userTrack = userTrack;
    } catch (err) {
        console.error(" [REF_FIX_V5] Erro crítico de escopo:", err);
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (erro crítico)");
        console.groupEnd();
        return;
    }
    console.groupEnd();
    
    // 🧮 PARTE 3.2: Validação e normalização de análises
    const sRef = stateV3?.reference || {};
    const userAnalysis = opts.userAnalysis ?? sRef.userAnalysis;
    const referenceAnalysis = opts.referenceAnalysis ?? sRef.referenceAnalysis;

    if (!userAnalysis || !referenceAnalysis) {
        console.warn("[REF-COMP] Faltam análises; usando fallback controlado.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (análises ausentes)");
        return renderGenreComparisonSafe?.();
    }

    // 🎯 SEMÂNTICA CORRETA DOS NOMES:
    // - userAnalysis = 1ª faixa = SUA MÚSICA (atual)
    // - referenceAnalysis = 2ª faixa = REFERÊNCIA (alvo a alcançar)
    const userTrackNormalized = userAnalysis.fileName || userAnalysis.metadata?.fileName || sRef.userTrack || "Sua Música (Atual)";
    const refTrackNormalized = referenceAnalysis.fileName || referenceAnalysis.metadata?.fileName || sRef.referenceTrack || "Faixa de Referência (Alvo)";
    
    // 🔍 AUDITORIA ANTI-DUPLICAÇÃO: Verificar se as faixas são distintas
    console.log('🔍 [AUDIT_REF_MODE ✅] ═══════════════════════════════════════');
    console.log('🔍 [AUDIT_REF_MODE ✅] Validação de faixas distintas:');
    console.log('🔍 [AUDIT_REF_MODE ✅]   userTrack (SUA MÚSICA):', userTrackNormalized);
    console.log('🔍 [AUDIT_REF_MODE ✅]   referenceTrack (REFERÊNCIA):', refTrackNormalized);
    console.log('🔍 [AUDIT_REF_MODE ✅]   São idênticas?', userTrackNormalized === refTrackNormalized ? '⚠️ SIM - VERIFICAR FLUXO!' : '✅ NÃO');
    console.log('🔍 [AUDIT_REF_MODE ✅]   userAnalysis jobId:', userAnalysis?.jobId);
    console.log('🔍 [AUDIT_REF_MODE ✅]   referenceAnalysis jobId:', referenceAnalysis?.jobId);
    console.log('🔍 [AUDIT_REF_MODE ✅]   JobIds idênticos?', userAnalysis?.jobId === referenceAnalysis?.jobId ? '⚠️ SIM - VERIFICAR!' : '✅ NÃO');
    console.log('🔍 [AUDIT_REF_MODE ✅] ═══════════════════════════════════════');
    
    if (userTrackNormalized === refTrackNormalized) {
        console.warn("⚠️ [REF-COMP] As duas faixas têm o mesmo nome — verifique o fluxo de atribuição!");
        console.warn("⚠️ [REF-COMP] Dados recebidos:", {
            userAnalysis: userAnalysis,
            referenceAnalysis: referenceAnalysis
        });
    }
    
    // Evita leitura em escopos errados - ABORT se referenceTrack undefined
    if (!referenceTrack) {
        console.error("🚨 [SAFE_REF_V3] referenceTrack ainda undefined! Abortando render seguro.");
        window.comparisonLock = false;
        console.log("[LOCK] comparisonLock liberado (referenceTrack undefined)");
        return;
    }
    
    // ✅ LOG PARA CONFIRMAÇÃO FINAL
    console.log("[REF-COMPARE ✅] Direção correta confirmada: PRIMEIRA = sua música (atual), SEGUNDA = referência (alvo)");
    
    // [AUDIT-FLOW] Log de rastreamento PRÉ-EXTRAÇÃO
    console.log("[AUDIT-FLOW] 🔍 PRÉ-EXTRAÇÃO de bandas:", {
        'analysis.userAnalysis?.bands': analysis.userAnalysis?.bands,
        'opts.userAnalysis?.bands': opts.userAnalysis?.bands,
        'opts.userAnalysis?.technicalData?.spectral_balance': opts.userAnalysis?.technicalData?.spectral_balance,
        'analysis.referenceAnalysis?.bands': analysis.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.bands': opts.referenceAnalysis?.bands,
        'opts.referenceAnalysis?.technicalData?.spectral_balance': opts.referenceAnalysis?.technicalData?.spectral_balance
    });
    
    // ✅ CORREÇÃO V3: Extração unificada de bandas espectrais (aceita arrays e objetos)
    let userBandsLocal =
        analysis.userAnalysis?.bands ||
        opts.userAnalysis?.bands ||
        opts.userAnalysis?.technicalData?.spectral_balance ||
        analysis.bands ||
        analysis.referenceComparison?.userBands ||
        null;

    let refBandsLocal =
        analysis.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.bands ||
        opts.referenceAnalysis?.technicalData?.spectral_balance ||
        analysis.referenceComparison?.refBands ||
        null;
    
    // [AUDIT-FLOW] Log PÓS-EXTRAÇÃO
    console.log("[AUDIT-FLOW] 🔍 PÓS-EXTRAÇÃO de bandas:", {
        userBandsLocal,
        refBandsLocal,
        userBandsLocalType: userBandsLocal ? (Array.isArray(userBandsLocal) ? 'Array' : 'Object') : 'null',
        refBandsLocalType: refBandsLocal ? (Array.isArray(refBandsLocal) ? 'Array' : 'Object') : 'null'
    });
    
    // � LOG DE DEBUG: Mostrar o que foi encontrado
    console.log("[REF-COMP] 🔍 Extração inicial de bandas:", {
        userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? `Array(${userBandsLocal.length})` : `Object(${Object.keys(userBandsLocal).length})`) : 'null',
        refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? `Array(${refBandsLocal.length})` : `Object(${Object.keys(refBandsLocal).length})`) : 'null',
        sourceUser: userBandsLocal ? 'encontrado' : 'null',
        sourceRef: refBandsLocal ? 'encontrado' : 'null'
    });

    // ✅ Validação: Aceitar tanto arrays quanto objetos
    const hasUserBands = userBandsLocal && (
        (Array.isArray(userBandsLocal) && userBandsLocal.length > 0) ||
        (typeof userBandsLocal === 'object' && Object.keys(userBandsLocal).length > 0)
    );
    
    const hasRefBands = refBandsLocal && (
        (Array.isArray(refBandsLocal) && refBandsLocal.length > 0) ||
        (typeof refBandsLocal === 'object' && Object.keys(refBandsLocal).length > 0)
    );

    // 🚨 Proteção aprimorada com fallback global
    if (!hasUserBands || !hasRefBands) {
        console.warn("[REF-COMP] ⚠️ Bandas ausentes na estrutura principal - tentando fallback global");
        
        const globalUser = window.__soundyState?.previousAnalysis?.bands || 
                          window.__soundyState?.previousAnalysis?.technicalData?.spectral_balance ||
                          window.__soundyState?.userAnalysis?.bands || 
                          null;
        const globalRef = window.__soundyState?.referenceAnalysis?.bands || 
                         window.__soundyState?.referenceAnalysis?.technicalData?.spectral_balance ||
                         window.__soundyState?.reference?.analysis?.bands || 
                         null;
        
        const hasGlobalUser = globalUser && (
            (Array.isArray(globalUser) && globalUser.length > 0) ||
            (typeof globalUser === 'object' && Object.keys(globalUser).length > 0)
        );
        
        const hasGlobalRef = globalRef && (
            (Array.isArray(globalRef) && globalRef.length > 0) ||
            (typeof globalRef === 'object' && Object.keys(globalRef).length > 0)
        );
        
        console.log("[REF-COMP] 🔍 Fallback global:", {
            globalUser: globalUser ? (Array.isArray(globalUser) ? `Array(${globalUser.length})` : `Object(${Object.keys(globalUser).length})`) : 'null',
            globalRef: globalRef ? (Array.isArray(globalRef) ? `Array(${globalRef.length})` : `Object(${Object.keys(globalRef).length})`) : 'null',
            hasGlobalUser,
            hasGlobalRef,
            hasPreviousAnalysis: !!window.__soundyState?.previousAnalysis,
            hasReferenceAnalysis: !!window.__soundyState?.referenceAnalysis
        });
        
        if (!hasGlobalUser || !hasGlobalRef) {
            console.error("[REF-COMP] ❌ Nenhum dado válido encontrado - abortando render");
            console.table({
                userBandsLocal: userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0,
                refBandsLocal: refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0,
                globalUser: globalUser ? (Array.isArray(globalUser) ? globalUser.length : Object.keys(globalUser).length) : 0,
                globalRef: globalRef ? (Array.isArray(globalRef) ? globalRef.length : Object.keys(globalRef).length) : 0,
                hasUserAnalysis: !!analysis.userAnalysis,
                hasReferenceAnalysis: !!analysis.referenceAnalysis,
                soundyStateKeys: Object.keys(window.__soundyState || {})
            });
            window.comparisonLock = false;
            console.log("[LOCK] comparisonLock liberado (sem dados válidos)");
            console.groupEnd();
            return;
        }
        
        // Aplicar fallback
        userBandsLocal = globalUser;
        refBandsLocal = globalRef;
        
        console.log("[REF-COMP] ✅ Fallback global aplicado com sucesso");
    }

    // Atualizar variáveis globais
    userBands = userBandsLocal;
    refBands = refBandsLocal;
    
    // 🎯 HOTFIX: Declarar detectedRenderMode ANTES de usar (evitar TDZ)
    const detectedRenderMode = opts.mode || stateV3?.render?.mode || 
                                (stateV3.reference?.isSecondTrack === true ? 'reference' : 'genre');
    
    // 🎯 PATCH CRÍTICO A: Persistir bandas em estrutura canônica para subscore
    if (detectedRenderMode === 'reference' && userBandsLocal && refBandsLocal) {
        stateV3.reference = stateV3.reference || {};
        stateV3.reference.bands = {
            userBands: userBandsLocal,
            refBands: refBandsLocal
        };
        
        // 🎯 PATCH CRÍTICO C: Compatibilidade - preencher stateV3.reference.analysis.bands
        stateV3.reference.analysis = stateV3.reference.analysis || {};
        stateV3.reference.analysis.bands = refBandsLocal;
        
        window.__soundyState = stateV3;
        
        console.log('[FREQ-FIX] ✅ Bandas persistidas em stateV3.reference:', {
            userBandsKeys: Object.keys(userBandsLocal),
            refBandsKeys: Object.keys(refBandsLocal),
            stateV3RefBands: !!stateV3.reference.bands,
            stateV3RefAnalysisBands: !!stateV3.reference.analysis.bands
        });
    }
    
    // [AUDIT-FLOW] Log após atribuição final
    console.log("[AUDIT-FLOW] 🔍 Após atribuição final:", {
        userBands,
        refBands,
        userBandsIsValid: !!(userBandsLocal && (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length)),
        refBandsIsValid: !!(refBandsLocal && (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length))
    });
    
    // ✅ LOG FINAL CONSOLIDADO
    const userBandsCount = userBandsLocal ? (Array.isArray(userBandsLocal) ? userBandsLocal.length : Object.keys(userBandsLocal).length) : 0;
    const refBandsCount = refBandsLocal ? (Array.isArray(refBandsLocal) ? refBandsLocal.length : Object.keys(refBandsLocal).length) : 0;
    
    console.log("[REF-COMP] ✅ Bandas detectadas:", {
        userBands: userBandsCount,
        refBands: refBandsCount,
        userBandsType: userBands ? (Array.isArray(userBands) ? 'Array' : 'Object') : 'null',
        refBandsType: refBands ? (Array.isArray(refBands) ? 'Array' : 'Object') : 'null',
        source: hasUserBands && hasRefBands ? 'analysis-principal' : 'fallback-global'
    });
    
    console.log("✅ [SAFE_REF_V3] Tracks resolvidas:", { 
        userTrack, 
        referenceTrack, 
        userBands: !!userBands, 
        refBands: !!refBands,
        userBandsCount,
        refBandsCount
    });
    
    // 🧠 SAFEGUARD FINAL: Verificação crítica antes de qualquer renderização
    if (opts?.mode === "reference") {
        // SAFEGUARD: garantir que spectral_balance exista na estrutura
        if (opts?.referenceAnalysis && !opts?.referenceAnalysis?.technicalData?.spectral_balance) {
            console.warn("⚠️ [SAFEGUARD] spectral_balance ausente em referenceAnalysis — aplicando patch.");
            if (!opts.referenceAnalysis.technicalData) opts.referenceAnalysis.technicalData = {};
            opts.referenceAnalysis.technicalData.spectral_balance = refBands;
        }
        
        if (opts?.userAnalysis && !opts?.userAnalysis?.technicalData?.spectral_balance) {
            console.warn("⚠️ [SAFEGUARD] spectral_balance ausente em userAnalysis — aplicando patch.");
            if (!opts.userAnalysis.technicalData) opts.userAnalysis.technicalData = {};
            opts.userAnalysis.technicalData.spectral_balance = userBands;
        }
    }
    
    // 🎯 CORREÇÃO CRÍTICA: Fonte da verdade vem do caller - NÃO usar fallback 'genre'
    // Reusar stateV3 já declarado no patch V3 acima
    
    // 🚨 PRIORIDADE DE DETECÇÃO DO MODO (sem fallback automático para genre):
    // 1. opts.mode (passado explicitamente pelo caller)
    // 2. stateV3.render.mode (já configurado anteriormente)
    // 3. stateV3.reference.isSecondTrack = true → forçar 'reference'
    // 4. Último recurso: 'genre'
    let explicitMode = opts.mode || stateV3?.render?.mode;
    
    // 🎯 Se segunda faixa está ativa, FORÇAR modo reference
    if (stateV3.reference?.isSecondTrack === true && !explicitMode) {
        explicitMode = 'reference';
        console.log('🔥 [MODE-OVERRIDE] Segunda faixa detectada - forçando modo reference');
    }
    
    // Fallback final apenas se realmente necessário
    if (!explicitMode) {
        explicitMode = 'genre';
        console.warn('⚠️ [MODE-FALLBACK] Nenhum modo detectado - usando genre como fallback');
    }
    
    const isReferenceMode = (opts?.mode === 'reference') 
        || (stateV3?.render?.mode === 'reference') 
        || (stateV3?.reference?.isSecondTrack === true && !opts?.mode);
    
    if (isReferenceMode) console.log('[REF-FLOW] renderReferenceComparisons in reference mode');
    
    const isReference = explicitMode === 'reference';
    
    // Salvar modo no estado (NÃO sobrescrever se já for reference)
    stateV3.render = stateV3.render || {};
    if (stateV3.render.mode !== 'reference' || explicitMode === 'reference') {
        stateV3.render.mode = explicitMode;
    }
    window.__soundyState = stateV3;
    
    // (Opcional) Log assertivo
    console.log('[RENDER-REF] MODO SELECIONADO:', explicitMode.toUpperCase());
    console.log('[ASSERT] mode=', explicitMode, 'isSecondTrack=', stateV3?.reference?.isSecondTrack, 'refJobId=', stateV3?.reference?.jobId);
    console.log('[ASSERT] opts.mode=', opts.mode, 'stateV3.render.mode=', stateV3.render.mode);
    
    // 🚨 CRÍTICO: NÃO reavaliar "se tem ref" para mudar o modo
    // O modo é determinístico e vem do caller
    let renderMode = explicitMode;
    
    // 🛡️ [AUDIT-FIX] VALIDAÇÃO CRÍTICA: garantir que renderMode seja válido
    if (renderMode !== 'reference' && renderMode !== 'genre') {
        console.error('🚨 [AUDIT-FIX] renderMode INVÁLIDO detectado:', renderMode);
        console.error('🚨 [AUDIT-FIX] explicitMode:', explicitMode);
        console.error('🚨 [AUDIT-FIX] opts.mode:', opts.mode);
        console.error('🚨 [AUDIT-FIX] stateV3.render.mode:', stateV3?.render?.mode);
        
        // Tentar recuperar modo correto
        if (opts.mode === 'reference' || stateV3?.render?.mode === 'reference' || stateV3?.reference?.isSecondTrack) {
            renderMode = 'reference';
            console.warn('⚠️ [AUDIT-FIX] Forçando renderMode = "reference"');
        } else {
            renderMode = 'genre';
            console.warn('⚠️ [AUDIT-FIX] Forçando renderMode = "genre" (fallback)');
        }
    }
    
    console.log('📊 [AUDIT-FIX] renderMode VALIDADO:', renderMode, '(válido:', renderMode === 'reference' || renderMode === 'genre', ')');
    
    // 🎯 PATCH 5: Asserts de validação de modo (NÃO ABORTAM, apenas logam)
    if (renderMode === 'reference') {
        if (!stateV3?.reference?.analysis?.bands) {
            console.warn('⚠️ [ASSERT-MAIN] Modo reference sem stateV3.reference.analysis.bands - pode usar fallback');
        }
        if (!stateV3?.reference?.isSecondTrack) {
            console.warn('⚠️ [ASSERT-MAIN] Modo reference sem flag isSecondTrack');
        }
        if (!stateV3?.reference?.analysis) {
            console.warn('⚠️ [CRITICAL] Modo reference configurado mas sem dados de referência no stateV3!');
            console.warn('⚠️ stateV3.reference:', stateV3?.reference);
        }
    } else if (renderMode === 'genre') {
        if (!window.__activeRefData?.bands) {
            console.warn('⚠️ [ASSERT-MAIN] Modo genre sem __activeRefData.bands - tentando fallback');
            console.warn('⚠️ __activeRefData:', window.__activeRefData);
        }
    }
    console.log('✅ [PATCH-5] Asserts de modo executados:', { renderMode, hasRefBands: !!(stateV3?.reference?.analysis?.bands), hasGenreBands: !!(window.__activeRefData?.bands) });
    
    // 🚨 REMOVIDO: Detecção legacy automática (causava auto-switch indevido)
    // O modo agora é determinístico e vem do caller via opts.mode
    // NÃO tentar "adivinhar" o modo baseado em analysis.mode ou estruturas
    
    // 🎯 CORREÇÃO: Definir hasNewStructure e hasOldStructure ANTES de usar
    const hasNewStructure = !!(analysis?.referenceAnalysis?.technicalData || analysis?.metrics);
    const hasOldStructure = !!(analysis?.referenceComparison && !hasNewStructure);
    
    let ref, titleText, userMetrics;
    
    // 🔍 [AUDITORIA_REF] Log de detecção crítica
    console.log('[AUDITORIA_REF] Detecção de modo:', {
        'analysis.mode': analysis.mode,
        'isReferenceMode': isReferenceMode,
        'hasNewStructure': hasNewStructure,
        'hasOldStructure': hasOldStructure,
        'window.__REFERENCE_JOB_ID__': window.__REFERENCE_JOB_ID__,
        'referenceAnalysisData': !!window.referenceAnalysisData
    });
    
    // 🎯 USAR renderMode PARA DECIDIR O FLUXO (não isReferenceMode)
    if (renderMode === 'reference') {
        console.log('[AUDITORIA_REF] Modo referência detectado – exibindo comparação A/B entre faixas');
        
        // 🔥 PRIORIDADE MÁXIMA: Usar nova estrutura corrigida (userAnalysis/referenceAnalysis)
        if (opts.userAnalysis && opts.referenceAnalysis) {
            console.log('🔥 [REF-CORRECTED] ═══════════════════════════════════════');
            console.log('🔥 [REF-CORRECTED] Usando estrutura corrigida: opts.userAnalysis + opts.referenceAnalysis');
            console.log('🔥 [REF-CORRECTED] userAnalysis existe:', !!opts.userAnalysis);
            console.log('🔥 [REF-CORRECTED] referenceAnalysis existe:', !!opts.referenceAnalysis);
            console.log('🔥 [REF-CORRECTED] userAnalysis.technicalData:', !!opts.userAnalysis.technicalData);
            console.log('🔥 [REF-CORRECTED] referenceAnalysis.technicalData:', !!opts.referenceAnalysis.technicalData);
            console.log('🔥 [REF-CORRECTED] ═══════════════════════════════════════');
            
            const userTech = opts.userAnalysis.technicalData || {};
            const refTech = opts.referenceAnalysis.technicalData || {};
            
            // 🔍 DIAGNÓSTICO: Verificar estrutura das bandas
            console.log('🔍 [DIAGNÓSTICO] userTech.spectral_balance:', userTech.spectral_balance);
            console.log('🔍 [DIAGNÓSTICO] refTech.spectral_balance:', refTech.spectral_balance);
            console.log('🔍 [DIAGNÓSTICO] userTech.bandEnergies:', userTech.bandEnergies);
            console.log('🔍 [DIAGNÓSTICO] refTech.bandEnergies:', refTech.bandEnergies);
            console.log('🔍 [DIAGNÓSTICO] userTech.bands:', userTech.bands);
            console.log('🔍 [DIAGNÓSTICO] refTech.bands:', refTech.bands);
            
            userMetrics = userTech;
            ref = {
                // Valores BRUTOS da segunda faixa (referência/alvo)
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.spectral_balance ?? refTech.bandEnergies ?? refTech.bands ?? null
            };
            
            // 🎯 SEMÂNTICA CORRETA NO TÍTULO:
            // 1ª faixa = sua música (atual) | 2ª faixa = referência (alvo)
            const userFileName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || 'Sua Música';
            const refFileName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || 'Referência';
            titleText = `� Comparação da sua faixa com a referência:\nAtual: ${userFileName}\nReferência: ${refFileName}`;
            
            console.log('✅ [REF-CORRECTED] ═══════════════════════════════════════');
            console.log('✅ [REF-CORRECTED] Dados A/B extraídos corretamente:');
            console.log('✅ [REF-CORRECTED]   SUA MÚSICA (1ª):', opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName);
            console.log('✅ [REF-CORRECTED]   Bandas:', Object.keys(userMetrics.spectral_balance || {}));
            console.log('✅ [REF-CORRECTED]   LUFS:', userMetrics.lufsIntegrated);
            console.log('✅ [REF-CORRECTED]   REFERÊNCIA (2ª):', opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName);
            console.log('✅ [REF-CORRECTED]   Bandas:', Object.keys(ref.bands || {}));
            console.log('✅ [REF-CORRECTED]   LUFS:', ref.lufs_target);
            console.log('✅ [REF-CORRECTED]   Tabela: ESQUERDA=sua música, DIREITA=referência');
            console.log('✅ [REF-CORRECTED] ═══════════════════════════════════════');
            
            // 🎯 LOG ASSERT_REF_FLOW
            console.log("[ASSERT_REF_FLOW ✅]", {
                mode: 'reference',
                userTrack: opts.userAnalysis?.fileName || opts.userAnalysis?.metadata?.fileName,
                referenceTrack: opts.referenceAnalysis?.fileName || opts.referenceAnalysis?.metadata?.fileName,
                userBands: Object.keys(userMetrics.spectral_balance || {}),
                refBands: Object.keys(ref.bands || {}),
                userLUFS: userMetrics.lufsIntegrated,
                refLUFS: ref.lufs_target
            });
        }
        // 🎯 PRIORIDADE 0 (FALLBACK): analysis.referenceAnalysis (estrutura antiga)
        else if (analysis.referenceAnalysis && analysis.referenceAnalysis.technicalData) {
            console.log('✅ [REF-COMP] Usando real reference analysis as target (primeira faixa)');
            
            const refTech = analysis.referenceAnalysis.technicalData;
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: refTech.lufsIntegrated ?? refTech.lufs_integrated,
                true_peak_target: refTech.truePeakDbtp ?? refTech.true_peak_dbtp,
                dr_target: refTech.dynamicRange ?? refTech.dynamic_range,
                lra_target: refTech.lra,
                stereo_target: refTech.stereoCorrelation ?? refTech.stereo_correlation,
                stereo_width_target: refTech.stereoWidth ?? refTech.stereo_width,
                spectral_centroid_target: refTech.spectralCentroidHz ?? refTech.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refTech.bandEnergies ?? refTech.spectral_balance ?? refTech.bands ?? null
            };
            
            titleText = `🎵 ${analysis.referenceAnalysis.fileName || analysis.referenceAnalysis.metadata?.fileName || 'Faixa Base'}`;
            
            console.log('📊 [REF-COMP] baseBands/refBands resolved from referenceAnalysis:', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                hasBands: !!ref.bands,
                bandsKeys: ref.bands ? Object.keys(ref.bands) : []
            });
            console.log('✅ [REF-COMP] Using real reference analysis as target');
        }
        // 🎯 PRIORIDADE 1 (FALLBACK): analysis.referenceBands (estrutura centralizada)
        else if (analysis.referenceBands && analysis.mode === 'reference') {
            console.log('✅ [RENDER-REF] Usando analysis.referenceBands (estrutura centralizada)');
            
            userMetrics = analysis.technicalData || {};
            
            ref = {
                lufs_target: analysis.referenceBands.lufsIntegrated || analysis.referenceBands.lufs_integrated,
                true_peak_target: analysis.referenceBands.truePeakDbtp || analysis.referenceBands.true_peak_dbtp,
                dr_target: analysis.referenceBands.dynamicRange || analysis.referenceBands.dynamic_range,
                lra_target: analysis.referenceBands.lra,
                stereo_target: analysis.referenceBands.stereoCorrelation || analysis.referenceBands.stereo_correlation,
                stereo_width_target: analysis.referenceBands.stereoWidth || analysis.referenceBands.stereo_width,
                spectral_centroid_target: analysis.referenceBands.spectralCentroidHz || analysis.referenceBands.spectral_centroid,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: analysis.referenceBands.spectral_balance || analysis.referenceBands.bands || null
            };
            
            titleText = `🎵 Faixa de Referência`;
            
            console.log('📊 [RENDER-REF] Referência (referenceBands):', {
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: ref.bands
            });
        }
        // ===== PRIORIDADE 2: NOVA ESTRUTURA (userTrack/referenceTrack) =====
        else if (hasNewStructure) {
            // 🧠 [PATCH V4] REFERENCE SCOPE LOCK FIX - Estabilizar escopo antes de render
            try {
                console.groupCollapsed("🧠 [REF_SCOPE_LOCK]");
                console.log("📦 Contexto atual antes do render:", { opts, stateV3 });

                // 🔒 Buscar dados de comparação em todos os escopos possíveis
                let comparisonLock =
                    opts?.comparisonData ||
                    window?.lastComparisonData ||
                    stateV3?.reference?.comparisonData ||
                    {
                        userTrack:
                            opts?.userAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                            "Faixa do Usuário",
                        referenceTrack:
                            opts?.referenceAnalysis?.metadata?.fileName ||
                            stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                            "Faixa de Referência",
                        userBands:
                            opts?.userAnalysis?.bands ||
                            stateV3?.reference?.userAnalysis?.bands ||
                            {},
                        refBands:
                            opts?.referenceAnalysis?.bands ||
                            stateV3?.reference?.referenceAnalysis?.bands ||
                            {},
                    };

                // 🔐 Corrigir se ainda estiver faltando algo
                if (!comparisonLock.referenceTrack) {
                    comparisonLock.referenceTrack =
                        opts?.referenceAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.referenceAnalysis?.metadata?.fileName ||
                        "Faixa de Referência";
                }
                if (!comparisonLock.userTrack) {
                    comparisonLock.userTrack =
                        opts?.userAnalysis?.metadata?.fileName ||
                        stateV3?.reference?.userAnalysis?.metadata?.fileName ||
                        "Faixa do Usuário";
                }

                // 🔒 Salvar globalmente para persistir escopo
                window.lastComparisonData = comparisonLock;

                console.log("✅ [REF_SCOPE_LOCK] Estrutura estabilizada:", comparisonLock);
                console.groupEnd();

                // 🧩 Reatribuir variáveis seguras locais
                const userTrackLock = comparisonLock.userTrack;
                const referenceTrackLock = comparisonLock.referenceTrack;
                const userBandsLock = comparisonLock.userBands;
                const refBandsLock = comparisonLock.refBands;

                // Se ainda não tiver bandas, abortar render seguro
                if (!refBandsLock || Object.keys(refBandsLock).length === 0) {
                    console.error(
                        "🚨 [REF_SCOPE_LOCK] refBands ausente, abortando renderização segura."
                    );
                    window.__REF_RENDER_LOCK__ = false;
                    window.comparisonLock = false;
                    console.log("[LOCK] comparisonLock liberado (refBands ausente)");
                    return;
                }

                // ✅ Reaplicar no escopo principal
                opts.comparisonData = comparisonLock;
                window.comparisonData = comparisonLock;
            } catch (err) {
                console.error("💥 [REF_SCOPE_LOCK] Erro crítico ao reestabelecer escopo:", err);
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (erro escopo)");
                return;
            }
            
            console.log('✅ [RENDER-REF] Usando NOVA estrutura (userTrack/referenceTrack)');
            
            // 🧩 Fix final do modal A/B - usar dados corretos de comparisonLock
            const refFile = 
                comparisonLock?.refFile ||
                comparisonLock?.referenceTrack ||
                opts?.referenceAnalysis?.fileName ||
                opts?.referenceAnalysis?.metadata?.fileName ||
                stateV3?.reference?.referenceAnalysis?.fileName ||
                "Faixa de referência";

            const userFile = 
                comparisonLock?.userFile ||
                comparisonLock?.userTrack ||
                opts?.userAnalysis?.fileName ||
                opts?.userAnalysis?.metadata?.fileName ||
                stateV3?.reference?.userAnalysis?.fileName ||
                "Faixa do usuário";

            console.log("[REF-FIX-FINAL] referenceTrackName resolvido:", refFile);
            console.log("[REF-FIX-FINAL] userTrackName resolvido:", userFile);
            
            // Extrair métricas de opts ou stateV3
            const refAnalysis = opts?.referenceAnalysis || stateV3?.reference?.referenceAnalysis;
            const userAnalysisData = opts?.userAnalysis || stateV3?.reference?.userAnalysis;
            
            if (!refAnalysis || !userAnalysisData) {
                console.error("💥 [REF-FIX-FINAL] Análises não encontradas, abortando");
                window.comparisonLock = false;
                console.log("[LOCK] comparisonLock liberado (análises não encontradas)");
                return;
            }
            
            const refMetrics = refAnalysis.metrics || refAnalysis;
            userMetrics = userAnalysisData.metrics || userAnalysisData;
            
            ref = {
                lufs_target: refMetrics.lufs || refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.peak || refMetrics.truePeakDbtp,
                dr_target: refMetrics.dr || refMetrics.dynamicRange,
                lra_target: refMetrics.lra,
                stereo_target: refMetrics.stereoCorrelation,
                stereo_width_target: refMetrics.stereoWidth,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: refAnalysis.bands || comparisonLock?.refBands || {}
            };
            
            titleText = `🎵 ${refFile}`;
            
            console.log('📊 [RENDER-REF] Referência:', {
                fileName: refFile,
                lufs: ref.lufs_target,
                dr: ref.dr_target,
                peak: ref.true_peak_target,
                bands: Object.keys(ref.bands || {}).length
            });
            console.log('📊 [RENDER-REF] Usuário:', {
                fileName: userFile,
                lufs: userMetrics.lufs || userMetrics.lufsIntegrated,
                dr: userMetrics.dr || userMetrics.dynamicRange
            });
        }
        // ===== ESTRUTURA ANTIGA (retrocompatibilidade) =====
        else if (hasOldStructure) {
            console.log('⚠️ [RENDER-REF] Usando estrutura ANTIGA (referenceMetrics) - considerar migração');
            
            const refMetrics = analysis.referenceComparison.referenceMetrics;
            ref = {
                lufs_target: refMetrics.lufsIntegrated,
                true_peak_target: refMetrics.truePeakDbtp,
                dr_target: refMetrics.dynamicRange,
                lra_target: refMetrics.lra || 6,
                stereo_target: refMetrics.stereoCorrelation,
                spectral_centroid_target: refMetrics.spectralCentroidHz,
                tol_lufs: 0.5,
                tol_true_peak: 0.3,
                tol_dr: 1.0,
                tol_lra: 1.0,
                tol_stereo: 0.08,
                tol_spectral: 300,
                bands: null
            };
            titleText = "🎵 Faixa de Referência";
            
            console.log('🎯 [RENDER-REF] Usando métricas de referência real:', refMetrics);
        }
    } else if (renderMode === 'genre') {
        // ===== MODO GÊNERO =====
        // 🎯 SÓ LOGA "MODO GÊNERO" SE REALMENTE FOR GENRE
        console.log('🎵 [RENDER-REF] MODO GÊNERO');
        
        // 🎯 LOG DE VERIFICAÇÃO: Garantir que targets de gênero sejam usados
        console.log('[TARGET-RESOLVE] Modo GENRE confirmado - buscando targets de gênero:', {
            hasWindowActiveRefData: !!window.__activeRefData,
            hasProdAiRefData: !!window.PROD_AI_REF_DATA,
            genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
        });
        
        // 🎯 CORREÇÃO: Fallback seguro para __activeRefData com múltiplas tentativas
        let __activeRefData = window.__activeRefData;
        
        // Tentativa 1: Usar dados globais
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('⚠️ [GENRE-MODE] __activeRefData não disponível, tentando PROD_AI_REF_DATA...');
            __activeRefData = window.PROD_AI_REF_DATA;
        }
        
        // Tentativa 2: Usar dados do analysis
        if (!__activeRefData || !__activeRefData.bands) {
            console.warn('⚠️ [GENRE-MODE] PROD_AI_REF_DATA não disponível, tentando analysis...');
            __activeRefData = analysis?.referenceComparison 
                || analysis?.genreTargets 
                || state?.genreTargets;
        }
        
        // Tentativa 3: Criar estrutura mínima
        if (!__activeRefData || !__activeRefData.bands) {
            console.error('❌ [GENRE-MODE] NENHUMA FONTE DE DADOS DE GÊNERO ENCONTRADA!');
            console.error('❌ Debug:', {
                hasWindowActiveRefData: !!window.__activeRefData,
                hasProdAiRefData: !!window.PROD_AI_REF_DATA,
                hasAnalysisRefComparison: !!analysis?.referenceComparison,
                genre: window.__activeRefGenre || window.PROD_AI_REF_GENRE
            });
            
            container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;opacity:.6">
                <strong style="color:#ff6b6b;">⚠️ Referências de gênero não carregadas</strong><br>
                <span style="font-size:11px;">Tente recarregar a página ou selecionar outro gênero</span>
            </div>`; 
            return; 
        }
        
        // 🚨 CORREÇÃO CRÍTICA: NÃO usar referenceComparisonMetrics no modo genre
        // Apenas usar targets de gênero
        ref = __activeRefData;
        titleText = window.PROD_AI_REF_GENRE || window.__activeRefGenre || 'Gênero Musical';
        userMetrics = analysis.technicalData || {};
        
        console.log('✅ [GENRE-MODE] Usando targets de gênero:', {
            genre: titleText,
            hasBands: !!ref.bands,
            bandsCount: ref.bands ? Object.keys(ref.bands).length : 0,
            bandsList: ref.bands ? Object.keys(ref.bands) : [],
            source: window.__activeRefData ? 'window.__activeRefData' : (window.PROD_AI_REF_DATA ? 'PROD_AI_REF_DATA' : 'analysis')
        });
    } else {
        // 🛡️ [AUDIT-FIX] FALLBACK SEGURO: não destruir conteúdo válido existente
        console.error('🚨 [AUDIT-FIX] MODO INDETERMINADO - renderMode:', renderMode);
        console.error('🚨 [AUDIT-FIX] Dados de diagnóstico:', {
            explicitMode,
            'opts.mode': opts.mode,
            'stateV3.render.mode': stateV3?.render?.mode,
            'stateV3.reference.isSecondTrack': stateV3?.reference?.isSecondTrack,
            'container.innerHTML.length': container.innerHTML.length,
            'containerHasTable': !!container.querySelector('table')
        });
        
        // Não sobrescrever se container já tem tabela válida
        const hasExistingTable = container.querySelector('table');
        if (hasExistingTable) {
            console.warn('⚠️ [AUDIT-FIX] Container já tem tabela válida - preservando conteúdo');
            return;
        }
        
        // Se não tem tabela, mostrar erro mas sem quebrar modal
        container.innerHTML = `<div class="card" style="margin-top:12px;padding:16px;text-align:center;background:rgba(255,165,0,.1);border:1px solid rgba(255,165,0,.3);">
            <strong style="color:#ffa500;">⚠️ Erro de configuração</strong><br>
            <span style="font-size:11px;color:#ffb366;">Modo de análise não identificado (renderMode: ${renderMode})</span><br>
            <span style="font-size:10px;color:#888;margin-top:8px;display:block;">Por favor, recarregue a página ou tente novamente.</span>
        </div>`;
        return;
    }
    
    // 🎯 SOBRESCREVER com referenceComparisonMetrics APENAS se modo for 'reference'
    if (renderMode === 'reference' && referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('🎯 [RENDER-REF] MODO REFERÊNCIA — COMPARAÇÃO ENTRE FAIXAS ATIVADA');
        console.log('✅ [RENDER-REF] Sobrescrevendo com referenceComparisonMetrics');
        
        const targetMetrics = referenceComparisonMetrics.reference;
        userMetrics = referenceComparisonMetrics.user;
        
        ref = {
            lufs_target: targetMetrics.lufsIntegrated || targetMetrics.lufs_integrated,
            true_peak_target: targetMetrics.truePeakDbtp || targetMetrics.true_peak_dbtp,
            dr_target: targetMetrics.dynamicRange || targetMetrics.dynamic_range,
            lra_target: targetMetrics.lra,
            stereo_target: targetMetrics.stereoCorrelation || targetMetrics.stereo_correlation,
            stereo_width_target: targetMetrics.stereoWidth || targetMetrics.stereo_width,
            spectral_centroid_target: targetMetrics.spectralCentroidHz || targetMetrics.spectral_centroid,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300,
            bands: targetMetrics.spectral_balance || null
        };
        
        // 🎯 SEMÂNTICA CORRETA: referenceFull = 2ª faixa (referência/alvo)
        const userFileName = referenceComparisonMetrics.userFull?.metadata?.fileName || referenceComparisonMetrics.userFull?.fileName || 'Sua Música';
        const refFileName = referenceComparisonMetrics.referenceFull?.metadata?.fileName || referenceComparisonMetrics.referenceFull?.fileName || 'Referência';
        titleText = `🎧 Comparação da sua faixa com a referência:\nAtual: ${userFileName}\nReferência: ${refFileName}`;
        
        // 🎯 ASSERT CRÍTICO: Verificar se bands estão disponíveis no modo reference
        console.log('[ASSERT_REF_DATA]', ref.bands ? '✅ Reference bands loaded' : '❌ Missing bands');
        if (!ref.bands) {
            console.error('🚨 [CRITICAL] Modo reference sem bandas! Bloqueando fallback de gênero.');
            console.error('🚨 Debug:', {
                hasTargetMetrics: !!targetMetrics,
                targetMetricsKeys: targetMetrics ? Object.keys(targetMetrics) : [],
                hasSpectralBalance: !!targetMetrics?.spectral_balance,
                hasReferenceComparisonMetrics: !!referenceComparisonMetrics,
                referenceFullKeys: referenceComparisonMetrics.referenceFull ? Object.keys(referenceComparisonMetrics.referenceFull) : []
            });
        }
    } else if (renderMode === 'genre' && referenceComparisonMetrics) {
        // 🚨 LOG DE SEGURANÇA: Confirmar que modo genre NÃO usa referenceComparisonMetrics
        console.log('✅ [GENRE-MODE] referenceComparisonMetrics IGNORADO no modo gênero (correto)');
    }
    
    // 🎯 Priorizar userMetrics (nova estrutura) sobre technicalData (legado)
    const tech = userMetrics || analysis.technicalData || {};
    
    console.log('📊 [RENDER-REF] Fonte de métricas do usuário:', userMetrics ? 'userMetrics (nova estrutura)' : 'technicalData (legado)');
    console.log('📊 [RENDER-REF] Modo final confirmado:', renderMode);
    console.log('📊 [RENDER-REF] ref.bands disponível:', !!ref?.bands, 'keys:', ref?.bands ? Object.keys(ref.bands).length : 0);
    
    // Mapeamento de métricas - RESTAURAR TABELA COMPLETA
    const rows = [];
    const addedLabels = new Set(); // 🎯 Controle de duplicação por nome
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '—';
    const pushRow = (label, val, target, tol, unit='') => {
        // ✅ Epsilon para comparações float precisas
        const EPS = 1e-6;
        
        // 🎯 PREVENÇÃO DE DUPLICATAS: evitar bandas com mesmo nome
        if (addedLabels.has(label)) {
            console.warn(`⚠️ Duplicata evitada: ${label}`);
            return;
        }
        addedLabels.add(label);
        // Usar sistema de enhancement se disponível
        const enhancedLabel = (typeof window !== 'undefined' && window.enhanceRowLabel) 
            ? window.enhanceRowLabel(label, label.toLowerCase().replace(/[^a-z]/g, '')) 
            : label;
            
        // Tratar target null ou NaN como N/A explicitamente
        const targetIsNA = (target == null || target === '' || (typeof target==='number' && !Number.isFinite(target)));
        if (!Number.isFinite(val) && targetIsNA) return; // nada útil
        if (targetIsNA) {
            rows.push(`<tr>
                <td>${enhancedLabel}</td>
                <td>${Number.isFinite(val)?nf(val)+unit:'—'}</td>
                <td colspan="2" style="opacity:.55">N/A</td>
            </tr>`);
            return;
        }
        // 🎯 CORRIGIDO: Cálculo de diferença usando centerOfRange para ranges
        let diff = null;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max) && Number.isFinite(val)) {
            // Target é um range: usar centro do range para cálculo de delta
            const targetForDelta = centerOfRange(target);
            if (typeof targetForDelta === 'number' && Number.isFinite(targetForDelta)) {
                diff = val - targetForDelta;
            } else {
                // Fallback: distância para o range
                const minNorm = Math.min(target.min, target.max);
                const maxNorm = Math.max(target.min, target.max);
                
                if (val >= minNorm - EPS && val <= maxNorm + EPS) {
                    diff = 0; // Dentro do range
                } else if (val < minNorm) {
                    diff = val - minNorm;
                } else {
                    diff = val - maxNorm;
                }
            }
        } else if (Number.isFinite(val) && Number.isFinite(target)) {
            // Target fixo: diferença tradicional
            diff = val - target;
        } else {
            // 🎯 Sem crash se target não for válido
            diff = null;
        }
        
        // ✅ Sistema de 3 cores com epsilon
        let diffCell;
        if (!Number.isFinite(diff)) {
            // Sem dados válidos → vermelho
            diffCell = '<td class="warn" style="text-align: center; padding: 8px;"><div style="font-size: 12px; font-weight: 600;">Corrigir</div></td>';
        } else if (tol === 0) {
            // Lógica para bandas espectrais (tol=0)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= EPS) {
                // ✅ DENTRO DO RANGE → Verde
                cssClass = 'ok';
                statusText = 'Ideal';
            } else if (absDiff <= 1.0 + EPS) {
                // ⚠️ Fora por até 1dB → Amarelo
                cssClass = 'yellow';
                statusText = 'Ajuste leve';
            } else if (absDiff <= 3.0 + EPS) {
                // ⚠️ Fora por até 3dB → Amarelo (era laranja)
                cssClass = 'yellow';
                statusText = 'Ajustar';
            } else {
                // ❌ Fora por >3dB → Vermelho
                cssClass = 'warn';
                statusText = 'Corrigir';
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else if (!Number.isFinite(tol) || tol < 0) {
            // Fallback: tolerância padrão com epsilon
            const defaultTol = 1.0;
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            console.warn(`⚠️ [TOLERANCE_FALLBACK] Métrica "${label}" sem tolerância válida (tol=${tol}). Usando tolerância padrão: ${defaultTol}`);
            
            if (absDiff <= defaultTol + EPS) {
                // ✅ ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / defaultTol;
                if (multiplicador <= 2 + EPS) {
                    // ⚠️ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // ❌ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        } else {
            // Lógica padrão com epsilon (LUFS, TP, DR, etc.)
            const absDiff = Math.abs(diff);
            let cssClass, statusText;
            
            if (absDiff <= tol + EPS) {
                // ✅ ZONA IDEAL
                cssClass = 'ok';
                statusText = 'Ideal';
            } else {
                const multiplicador = absDiff / tol;
                if (multiplicador <= 2 + EPS) {
                    // ⚠️ ZONA AJUSTAR
                    cssClass = 'yellow';
                    statusText = 'Ajuste leve';
                } else {
                    // ❌ ZONA CORRIGIR
                    cssClass = 'warn';
                    statusText = 'Corrigir';
                }
            }
            
            diffCell = `<td class="${cssClass}" style="text-align: center; padding: 8px;">
                <div style="font-size: 12px; font-weight: 600;">${statusText}</div>
            </td>`;
        }
        
        // 🎯 NOVO: Renderização híbrida para targets fixos e ranges
        let targetDisplay;
        
        if (typeof target === 'object' && target !== null && 
            Number.isFinite(target.min) && Number.isFinite(target.max)) {
            // Target é um range: exibir "min dB a max dB"
            targetDisplay = `${nf(target.min)}${unit} a ${nf(target.max)}${unit}`;
        } else if (Number.isFinite(target)) {
            // Target é um valor fixo: exibir "valor dB"
            targetDisplay = `${nf(target)}${unit}`;
        } else {
            // Target não definido
            targetDisplay = 'N/A';
        }
        
        // Adicionar tolerância se disponível (apenas para targets fixos)
        const tolDisplay = (typeof target !== 'object' && tol != null) ? 
            `<span class="tol">±${nf(tol,2)}</span>` : '';
        
        rows.push(`<tr>
            <td>${enhancedLabel}</td>
            <td>${Number.isFinite(val)?nf(val)+unit:'—'}</td>
            <td>${targetDisplay}${tolDisplay}</td>
            ${diffCell}
        </tr>`);
    };
    // 🎯 CENTRALIZAÇÃO DAS MÉTRICAS - Função de acesso para comparação por referência
    const getMetricForRef = (metricPath, fallbackPath = null) => {
        // Prioridade: analysis.metrics > tech (technicalData) > fallback
        const centralizedValue = analysis.metrics && getNestedValue(analysis.metrics, metricPath);
        if (Number.isFinite(centralizedValue)) {
            // Log temporário para validação
            if (typeof window !== 'undefined' && window.METRICS_REF_VALIDATION !== false) {
                const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
                if (Number.isFinite(legacyValue) && Math.abs(centralizedValue - legacyValue) > 0.01) {
                    console.warn(`🎯 REF_METRIC_DIFF: ${metricPath} centralized=${centralizedValue} vs legacy=${legacyValue}`);
                }
            }
            return centralizedValue;
        }
        
        // Fallback para technicalData legado
        const legacyValue = fallbackPath ? getNestedValue(tech, fallbackPath) : getNestedValue(tech, metricPath);
        return Number.isFinite(legacyValue) ? legacyValue : null;
    };
    
    const getNestedValue = (obj, path) => {
        return path.split('.').reduce((current, key) => current?.[key], obj);
    };
    
    // 🎯 CENTRALIZAÇÃO DAS MÉTRICAS - Função de acesso para comparação por referência
    // Usar somente métricas reais (sem fallback para RMS/Peak, que têm unidades e conceitos distintos)
    // Função para obter o valor LUFS integrado usando métricas centralizadas
    const getLufsIntegratedValue = () => {
        return getMetricForRef('lufs_integrated', 'lufsIntegrated');
    };
    
    // 🧠 NOVA PROTEÇÃO UNIVERSAL — Usa resolveTargetMetric para buscar referência real > gênero
    const lufsTarget = resolveTargetMetric(analysis, "lufsIntegrated", -14);
    const tpTarget = resolveTargetMetric(analysis, "truePeakDbtp", -1);
    const drTarget = resolveTargetMetric(analysis, "dynamicRange", 8);
    const lraTarget = resolveTargetMetric(analysis, "lra", 6);
    const stereoTarget = resolveTargetMetric(analysis, "stereoCorrelation", 0.1);
    const spectralTarget = resolveTargetMetric(analysis, "spectralCentroidHz", null);
    
    // Tolerâncias ainda vêm de ref (ou padrão)
    const tolLufs = (ref && ref.tol_lufs !== undefined) ? ref.tol_lufs : 0.5;
    const tolTp = (ref && ref.tol_true_peak !== undefined) ? ref.tol_true_peak : 0.3;
    const tolDr = (ref && ref.tol_dr !== undefined) ? ref.tol_dr : 1.0;
    const tolLra = (ref && ref.tol_lra !== undefined) ? ref.tol_lra : 1.0;
    const tolStereo = (ref && ref.tol_stereo !== undefined) ? ref.tol_stereo : 0.08;
    const tolSpectral = (ref && ref.tol_spectral !== undefined) ? ref.tol_spectral : 300;
    
    console.log('🧠 [RESOLVE-TARGETS] Targets universais resolvidos:', { 
        lufsTarget, tpTarget, drTarget, lraTarget, stereoTarget, spectralTarget 
    });
    
    // ADICIONAR TODAS AS MÉTRICAS PRINCIPAIS
    pushRow('Loudness Integrado (LUFS)', getLufsIntegratedValue(), lufsTarget, tolLufs, ' LUFS');
    pushRow('Pico Real (dBTP)', getMetricForRef('true_peak_dbtp', 'truePeakDbtp'), tpTarget, tolTp, ' dBTP');
    pushRow('DR', getMetricForRef('dynamic_range', 'dynamicRange'), drTarget, tolDr, '');
    pushRow('Faixa de Loudness – LRA (LU)', getMetricForRef('lra'), lraTarget, tolLra, ' LU');
    pushRow('Stereo Corr.', getMetricForRef('stereo_correlation', 'stereoCorrelation'), stereoTarget, tolStereo, '');
    
    // 🎯 ADICIONAR SPECTRAL CENTROID SE MODO REFERÊNCIA (usa resolveTargetMetric)
    if (isReferenceMode && spectralTarget !== null) {
        pushRow('Centro Espectral (Hz)', getMetricForRef('spectral_centroid', 'spectralCentroidHz'), 
                spectralTarget, tolSpectral, ' Hz');
    }
    
    // Bandas detalhadas Fase 2: usar métricas centralizadas para bandas
    const centralizedBands = analysis.metrics?.bands;
    const legacyBandEnergies = tech.bandEnergies || null;
    
    // 🔍 DEBUG: Verificar estado das bandas e mapeamento
    console.log('🔍 [DEBUG_BANDS] Verificando bandas espectrais:', {
        MODE: renderMode.toUpperCase(),
        MODE_SOURCE: renderMode === 'genre' ? 'GENRE TARGETS' : 'REFERENCE ANALYSIS',
        hasCentralizedBands: !!centralizedBands,
        centralizedBandsKeys: centralizedBands ? Object.keys(centralizedBands) : [],
        hasLegacyBands: !!legacyBandEnergies,
        legacyBandsKeys: legacyBandEnergies ? Object.keys(legacyBandEnergies) : [],
        hasRefBands: !!ref.bands,
        refBandsKeys: ref.bands ? Object.keys(ref.bands) : [],
        refBandsSource: renderMode === 'genre' ? 'FROM __activeRefData (genre)' : 'FROM referenceAnalysis or referenceComparisonMetrics'
    });
    
    // 🎯 MAPEAMENTO CORRIGIDO: Bandas Calculadas → Bandas de Referência
    const bandMappingCalcToRef = {
        // Banda calculada: chave na referência
        'sub': 'sub',
        'bass': 'low_bass',
        'lowMid': 'low_mid', 
        'mid': 'mid',
        'highMid': 'high_mid',
        'presence': 'presenca',
        'air': 'brilho',
        // Variações adicionais
        'low_bass': 'low_bass',
        'low_mid': 'low_mid',
        'high_mid': 'high_mid',
        'presenca': 'presenca',
        'brilho': 'brilho'
    };
    
    // 🎯 MAPEAMENTO REVERSO: Bandas de Referência → Bandas Calculadas
    const bandMappingRefToCalc = {
        'sub': 'sub',
        'low_bass': 'bass',
        'upper_bass': 'bass', // 🎯 NOVO: upper_bass → bass
        'low_mid': 'lowMid',
        'mid': 'mid',
        'high_mid': 'highMid',
        'presenca': 'presence',
        'brilho': 'air'
    };
    
    // 🎯 ALIAS DE BANDAS: Nomes alternativos para busca
    const bandAliases = {
        'bass': ['low_bass', 'upper_bass'],
        'lowMid': ['low_mid'],
        'highMid': ['high_mid'],
        'presence': ['presenca'],
        'air': ['brilho']
    };
    
    // 🎯 NOVA LÓGICA: Priorizar bandas da nova estrutura em modo reference
    let bandsToUse, referenceBands;
    
    if (isReferenceMode && hasNewStructure && ref.bands) {
        // Usar bandas da referenceTrack.metrics.spectral_balance
        console.log('✅ [RENDER-BANDS] Usando bandas da NOVA estrutura (referenceTrack)');
        referenceBands = ref.bands;
        bandsToUse = tech.spectral_balance || centralizedBands || legacyBandEnergies;
    } else {
        // Modo legado ou gênero
        bandsToUse = centralizedBands && Object.keys(centralizedBands).length > 0 ? centralizedBands : legacyBandEnergies;
        referenceBands = isReferenceMode && analysis.referenceComparison?.comparison?.spectralBands;
    }
    
    // 🎯 RENDERIZAÇÃO DE BANDAS EM MODO REFERENCE
    if (isReferenceMode && hasNewStructure && ref.bands && bandsToUse) {
        console.log('✅ [RENDER-REF-BANDS] Renderizando bandas com NOVA estrutura');
        
        const bandNames = {
            sub: 'Sub (20–60Hz)',
            bass: 'Bass (60–150Hz)',
            lowMid: 'Low-Mid (150–500Hz)',
            mid: 'Mid (500–2kHz)',
            highMid: 'High-Mid (2–5kHz)',
            presence: 'Presence (5–10kHz)',
            air: 'Air (10–20kHz)'
        };
        
        // Iterar pelas bandas padrão
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            // Pegar valores do usuário
            const userBand = bandsToUse[band];
            const userValue = userBand?.percentage || userBand?.energy_db;
            
            // Pegar valores da referência
            const refBand = ref.bands[band];
            const refValue = refBand?.percentage || refBand?.energy_db;
            
            if (Number.isFinite(userValue) && Number.isFinite(refValue)) {
                pushRow(
                    bandNames[band] || band,
                    userValue,
                    refValue,
                    3.0, // Tolerância de 3% para bandas
                    '%'
                );
                
                console.log(`📊 [BAND-${band}] User: ${userValue.toFixed(1)}% | Ref: ${refValue.toFixed(1)}%`);
            }
        });
    }
    // 🎯 RENDERIZAÇÃO DE BANDAS COM ESTRUTURA ANTIGA (referenceComparison.comparison.spectralBands)
    else if (referenceBands && typeof referenceBands === 'object') {
        console.log('⚠️ [RENDER-REF-BANDS] Usando bandas de referenceComparison (estrutura antiga)');
        
        const bandNames = {
            sub: 'Sub (20–60Hz)',
            bass: 'Bass (60–150Hz)',
            lowMid: 'Low-Mid (150–500Hz)',
            mid: 'Mid (500–2kHz)',
            highMid: 'High-Mid (2–5kHz)',
            presence: 'Presence (5–10kHz)',
            air: 'Air (10–20kHz)'
        };
        
        ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'].forEach(band => {
            if (referenceBands[band]) {
                const data = referenceBands[band];
                pushRow(
                    bandNames[band] || band,
                    data.user,
                    data.reference,
                    3.0,
                    data.unit
                );
            }
        });
    } 
    // 🎵 RENDERIZAÇÃO DE BANDAS EM MODO GÊNERO
    else if (bandsToUse && ref.bands) {
        const normMap = (analysis?.technicalData?.refBandTargetsNormalized?.mapping) || null;
        const showNorm = (typeof window !== 'undefined' && window.SHOW_NORMALIZED_REF_TARGETS === true && normMap);
        
        // Mapeamento de nomes amigáveis para as bandas com ranges de frequência
        const bandDisplayNames = {
            sub: 'Sub (20–60Hz)',
            bass: 'Bass (60–150Hz)', 
            lowMid: 'Low-Mid (150–500Hz)',
            mid: 'Mid (500–2kHz)',
            highMid: 'High-Mid (2–5kHz)',
            presence: 'Presence (5–10kHz)',
            air: 'Air (10–20kHz)',
            brilho: 'Air (10–20kHz)'
        };
        
        // 🎯 PROCESSAMENTO CORRIGIDO: Iterar por bandas de referência e mapear para dados calculados
        console.log('🔄 Processando bandas com mapeamento corrigido...');
        
        // 🛡️ FALLBACK: Verificar se ref.bands existe antes de iterar
        if (!ref.bands || typeof ref.bands !== 'object') {
            console.warn('⚠️ [REF-COMP] Fallback triggered (missing bands) - ref.bands não existe');
            ref.bands = {}; // Criar objeto vazio para evitar erro
        }
        
        for (const [refBandKey, refBand] of Object.entries(ref.bands)) {
            // Encontrar a banda calculada correspondente
            const calcBandKey = bandMappingRefToCalc[refBandKey] || refBandKey;
            let bLocal = null;
            
            console.log(`🔍 [BANDS] Processando: ${refBandKey} → ${calcBandKey}`);
            
            // 🎯 NOVO: Busca melhorada com sistema de alias
            const searchBandData = (bandKey) => {
                // Buscar diretamente
                if (centralizedBands && centralizedBands[bandKey]) {
                    return { rms_db: centralizedBands[bandKey].energy_db, source: 'centralized' };
                }
                if (legacyBandEnergies && legacyBandEnergies[bandKey]) {
                    return { ...legacyBandEnergies[bandKey], source: 'legacy' };
                }
                
                // Buscar por alias
                if (bandAliases[bandKey]) {
                    for (const alias of bandAliases[bandKey]) {
                        if (centralizedBands && centralizedBands[alias]) {
                            console.log(`🔄 [ALIAS] ${bandKey} → ${alias} (centralized)`);
                            return { rms_db: centralizedBands[alias].energy_db, source: 'centralized-alias' };
                        }
                        if (legacyBandEnergies && legacyBandEnergies[alias]) {
                            console.log(`🔄 [ALIAS] ${bandKey} → ${alias} (legacy)`);
                            return { ...legacyBandEnergies[alias], source: 'legacy-alias' };
                        }
                    }
                }
                
                return null;
            };
            
            // Buscar dados da banda
            bLocal = searchBandData(calcBandKey);
            
            // Se não encontrou, tentar busca direta pela chave de referência
            if (!bLocal) {
                bLocal = searchBandData(refBandKey);
                if (bLocal) {
                    console.log(`⚠️ [BANDS] Fallback para chave de referência: ${refBandKey}`);
                }
            }
            
            // 🎯 TRATAMENTO SILENCIOSO: Ignorar bandas não encontradas sem erro
            if (!bLocal || !Number.isFinite(bLocal.rms_db)) {
                console.log(`🔇 [BANDS] Ignorando banda inexistente: ${refBandKey} / ${calcBandKey}`);
                continue; // Pular silenciosamente
            }
            
            // Banda encontrada - processar normalmente
            console.log(`✅ [BANDS] Encontrado ${refBandKey}: ${bLocal.rms_db}dB (${bLocal.source})`);
            
            // Log de validação entre sistemas
            if (typeof window !== 'undefined' && window.METRICS_BANDS_VALIDATION !== false && 
                bLocal.source === 'centralized' && legacyBandEnergies?.[calcBandKey]) {
                const legacyValue = legacyBandEnergies[calcBandKey].rms_db;
                if (Number.isFinite(legacyValue) && Math.abs(bLocal.rms_db - legacyValue) > 0.01) {
                    console.warn(`🎯 BAND_DIFF: ${calcBandKey} centralized=${bLocal.rms_db} vs legacy=${legacyValue}`);
                }
            }
            
            // 🎯 NOVO: Determinar target e tolerância com helpers
            let tgt = null;
            let tolerance = null;
            
            // Prioridade 1: target_range (usar helpers para formatação e tolerância)
            if (refBand.target_range && typeof refBand.target_range === 'object' &&
                Number.isFinite(refBand.target_range.min) && Number.isFinite(refBand.target_range.max)) {
                tgt = refBand.target_range;
                // ✅ CORRIGIDO: Usar deriveTolerance() ao invés de 0
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`🎯 [BANDS-FORMAT] Usando target_range para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            // Prioridade 2: target_db fixo
            else if (!refBand._target_na && Number.isFinite(refBand.target_db)) {
                tgt = refBand.target_db;
                // ✅ CORRIGIDO: Usar deriveTolerance() com fallback
                tolerance = deriveTolerance(tgt, 2.0);
                console.log(`🎯 [BANDS-FORMAT] Usando target_db fixo para ${refBandKey}: ${formatTarget(tgt)}, tol: ${tolerance.toFixed(2)}`);
            }
            
            // Prioridade 3: Targets normalizados (se habilitado)
            if (showNorm && normMap && Number.isFinite(normMap[refBandKey])) {
                tgt = normMap[refBandKey];
                console.log(`🎯 [BANDS] Sobrescrevendo com target normalizado para ${refBandKey}: ${tgt}`);
            }
            
            // Nome para exibição
            const displayName = bandDisplayNames[calcBandKey] || bandDisplayNames[refBandKey] || refBandKey;
            
            // ✅ CORRIGIDO: Usar centerOfRange para cálculo de delta
            const targetCenter = centerOfRange(tgt) ?? tgt ?? null;
            console.log(`📊 [BANDS] Adicionando: ${displayName}, valor: ${bLocal.rms_db}dB, target: ${formatTarget(tgt)}, tol: ${tolerance}`);
            
            // 🎯 Passar targetCenter (número) para cálculo correto de delta em pushRow
            pushRow(displayName, bLocal.rms_db, tgt, tolerance, ' dB');
        }
        
        // 🎯 PROCESSAMENTO DE BANDAS EXTRAS: Bandas calculadas que não estão na referência
        console.log('🔄 Verificando bandas extras não mapeadas...');
        
        if (bandsToUse) {
            Object.keys(bandsToUse).forEach(calcBandKey => {
                // Filtrar chaves inválidas (totais, metadados etc.)
                if (calcBandKey === '_status' || 
                    calcBandKey === 'totalPercentage' || 
                    calcBandKey === 'totalpercentage' ||
                    calcBandKey === 'metadata' ||
                    calcBandKey === 'total' ||
                    calcBandKey.toLowerCase().includes('total')) {
                    return; // Pular esta banda
                }
                
                // Verificar se esta banda já foi processada
                const refBandKey = bandMappingCalcToRef[calcBandKey];
                const alreadyProcessed = refBandKey && ref.bands[refBandKey];
                
                if (!alreadyProcessed) {
                    console.log(`🔍 Processando banda extra: ${calcBandKey}`);
                    
                    const bandData = bandsToUse[calcBandKey];
                    let energyDb = null;
                    
                    if (typeof bandData === 'object' && Number.isFinite(bandData.energy_db)) {
                        energyDb = bandData.energy_db;
                    } else if (typeof bandData === 'object' && Number.isFinite(bandData.rms_db)) {
                        energyDb = bandData.rms_db;
                    } else if (Number.isFinite(bandData)) {
                        energyDb = bandData;
                    }
                    
                    if (Number.isFinite(energyDb)) {
                        const displayName = bandDisplayNames[calcBandKey] || 
                                          `${calcBandKey.charAt(0).toUpperCase() + calcBandKey.slice(1)} (Nova Banda)`;
                        
                        // Tentar buscar referência direta por chave
                        const directRefData = ref.bands?.[calcBandKey];
                        let target = null;
                        let tolerance = null;
                        
                        // [BANDS-TOL-0] Suporte híbrido: target_range ou target_db (SEM TOLERÂNCIA)
                        if (directRefData?.target_range && typeof directRefData.target_range === 'object' &&
                            Number.isFinite(directRefData.target_range.min) && Number.isFinite(directRefData.target_range.max)) {
                            target = directRefData.target_range;
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        } else if (Number.isFinite(directRefData?.target_db)) {
                            target = { min: directRefData.target_db, max: directRefData.target_db };
                            tolerance = 0; // [BANDS-TOL-0] Sempre 0 para bandas
                        }
                        
                        console.log(`📊 Adicionando banda extra: ${displayName}, valor: ${energyDb}dB, target: ${target || 'N/A'}`);
                        pushRow(displayName, energyDb, target, tolerance, ' dB');
                        
                        if (!target) {
                            console.warn(`⚠️ Banda sem referência: ${calcBandKey} (valor: ${energyDb}dB)`);
                        }
                    }
                }
            });
        }
    } else {
        // Fallback melhorado: buscar todas as bandas espectrais disponíveis
        const spectralBands = tech.spectral_balance || 
                            tech.spectralBands || 
                            analysis.metrics?.bands || {};
        
        // 🎯 MAPEAMENTO COMPLETO com correção de nomes
        const bandMap = {
            sub: { refKey: 'sub', name: 'Sub (20–60Hz)', range: '20–60Hz' },
            bass: { refKey: 'low_bass', name: 'Bass (60–150Hz)', range: '60–150Hz' },
            lowMid: { refKey: 'low_mid', name: 'Low-Mid (150–500Hz)', range: '150–500Hz' },
            mid: { refKey: 'mid', name: 'Mid (500–2kHz)', range: '500–2000Hz' },
            highMid: { refKey: 'high_mid', name: 'High-Mid (2–5kHz)', range: '2000–5000Hz' },
            presence: { refKey: 'presenca', name: 'Presence (5–10kHz)', range: '5000–10000Hz' },
            air: { refKey: 'brilho', name: 'Air (10–20kHz)', range: '10000–20000Hz' }
        };
        
        // 🎯 NOVO PROCESSAMENTO MODE-AWARE com resolver
        console.log('🔄 Processando bandas espectrais (mode-aware resolver)...', {
            renderMode,
            hasRefBands: !!ref?.bands,
            refBandsKeys: ref?.bands ? Object.keys(ref.bands) : [],
            spectralBandsKeys: Object.keys(spectralBands),
            stateRefAnalysis: !!stateV3?.reference?.analysis?.bands
        });
        
        if (spectralBands && Object.keys(spectralBands).length > 0) {
            // 🎯 PATCH B: Extração de bandas mode-aware com bloqueio de fallback
            // isReferenceMode já definido no escopo superior
            
            let refBands = null;
            let userBands = null;
            
            if (isReferenceMode) {
                // 2ª faixa: referência/alvo
                const refTech = opts?.referenceAnalysis?.technicalData
                             || stateV3?.referenceAnalysis?.technicalData
                             || stateV3?.reference?.referenceAnalysis?.technicalData
                             || referenceComparisonMetrics?.target
                             || referenceComparisonMetrics?.userFull?.technicalData /* legado confuso */ 
                             || null;
                
                // 1ª faixa: base/origem
                const userTech = opts?.userAnalysis?.technicalData
                              || stateV3?.userAnalysis?.technicalData
                              || stateV3?.reference?.userAnalysis?.technicalData
                              || referenceComparisonMetrics?.analyzed
                              || referenceComparisonMetrics?.referenceFull?.technicalData /* legado confuso */
                              || null;
                
                // 🔍 EXTRAÇÃO DE refBands com fallback seguro (NUNCA usar ranges de gênero)
                refBands = refTech?.spectral_balance ||
                          opts?.referenceAnalysis?.bands ||
                          opts?.referenceAnalysis?.frequencyBands ||
                          stateV3?.referenceAnalysis?.bands ||
                          stateV3?.referenceAnalysis?.frequencyBands ||
                          null;
                
                userBands = userTech?.spectral_balance || null;
                
                console.log('[REF-FLOW] bands sources', {
                    userBands: !!userBands, 
                    refBands: !!refBands,
                    userBandsKeys: userBands ? Object.keys(userBands).slice(0, 5) : [],
                    refBandsKeys: refBands ? Object.keys(refBands).slice(0, 5) : []
                });
                
                if (!refBands) {
                    console.error("🚨 [REF-ERROR] Nenhum dado de bandas encontrado na referência.");
                    console.error('[CRITICAL] Reference mode sem bandas da 2ª faixa! Abortando render.');
                    console.error('[CRITICAL] Proibido fallback de gênero no reference mode');
                    if (container) {
                        container.innerHTML = '<div style="color:red;">❌ Erro: bandas de referência não disponíveis</div>';
                    }
                    return;
                }
                
                console.log("✅ [AUDIT_REF_FIX] referenceAnalysis spectral_balance pronto:", refBands);
            } else {
                // GENRE: aqui SIM usa ranges de __activeRefData
                refBands  = (__activeRefData && __activeRefData.bands) || null;
                userBands = (analysis?.technicalData?.spectral_balance) || spectralBands || null;
            }
            
            // Conjunto para rastrear bandas já processadas
            const processedBandKeys = new Set();
            
            // 🎯 Iterar por todas as bandas do usuário
            const bandsToIterate = userBands || spectralBands;
            for (const rawKey of Object.keys(bandsToIterate)) {
                if (IGNORE_BANDS.has(rawKey) || processedBandKeys.has(rawKey)) continue;
                
                const bandKey = normalizeBandKey(rawKey);
                const userVal = pickNumeric(bandsToIterate[rawKey]);
                
                if (userVal === null) continue; // Sem valor do usuário
                
                let targetDisplay = '—';
                let valueDisplay = '—';
                let deltaDisplay = '—';
                let targetValue = null;
                let tolDisplay = null;
                
                if (isReferenceMode) {
                    const refVal = getReferenceBandValue(refBands, bandKey); // retorna número (dB) ou null
                    const userValCalc = getReferenceBandValue(userBands, bandKey);
                    
                    if (refVal == null) {
                        console.warn('[REF-FLOW] Banda sem valor na 2ª faixa:', bandKey);
                        targetDisplay = '—';
                        targetValue = null;
                    } else {
                        targetDisplay = formatDb(refVal);
                        targetValue = refVal;
                    }
                    
                    valueDisplay = (userValCalc == null) ? '—' : formatDb(userValCalc);
                    deltaDisplay = (userValCalc == null || refVal == null) ? '—' : formatDb(userValCalc - refVal);
                    tolDisplay = 0; // Sem tolerância em comparação direta
                    
                } else {
                    // GENRE: range do JSON de gênero
                    const r = getGenreTargetRange(refBands, bandKey);
                    if (r) {
                        targetDisplay = `${formatDb(r.min)} a ${formatDb(r.max)}`;
                        targetValue = { min: r.min, max: r.max };
                        tolDisplay = r.tol;
                    } else {
                        targetDisplay = '—';
                        targetValue = null;
                    }
                    valueDisplay = formatDb(userVal);
                    deltaDisplay = '—'; // (delta numérico não se aplica a range)
                }
                
                // 🎯 Adicionar linha na tabela
                const label = bandMap[bandKey]?.name || `${bandKey.toUpperCase()}`;
                pushRow(label, userVal, targetValue, tolDisplay, ' dB');
                processedBandKeys.add(rawKey);
                processedBandKeys.add(bandKey);
            }
            
            console.log(`✅ [BANDS-PROCESSED] ${processedBandKeys.size} bandas processadas no modo ${renderMode}`);
        } else {
            // Fallback para tonalBalance simplificado (mantido para compatibilidade)
            const tb = tech.tonalBalance || {};
            const legacyBandMap = { sub:'sub', low:'low_bass', mid:'mid', high:'brilho' };
            Object.entries(legacyBandMap).forEach(([tbKey, refBand]) => {
                const bData = tb[tbKey];
                const refBandData = ref.bands?.[refBand];
                if (bData && refBandData && Number.isFinite(bData.rms_db)) {
                    console.log(`📊 Banda legacy: ${tbKey.toUpperCase()}, valor: ${bData.rms_db}dB, target: ${refBandData.target_db}dB`);
                    pushRow(`${tbKey.toUpperCase()}`, bData.rms_db, refBandData.target_db, refBandData.tol_db, ' dB');
                }
            });
        }
    }
    
    // 🎯 LOG DE RESUMO: Bandas processadas com sucesso
    const bandasDisponiveis = ref.bands ? Object.keys(ref.bands).length : 0;
    const bandasProcessadas = rows.length - 5; // Subtrair métricas básicas (LUFS, Peak, DR, LRA, Stereo)
    
    console.log('📊 [BANDS] Resumo do processamento de bandas:', {
        bandas_na_referencia: bandasDisponiveis,
        bandas_processadas: Math.max(0, bandasProcessadas),
        metricas_totais: rows.length,
        centralized_bands_ok: !!centralizedBands,
        legacy_bands_ok: !!legacyBandEnergies,
        modo_referencia: isReferenceMode
    });
    
    // 🎯 [A/B-TABLE-FIX] CORREÇÃO CRÍTICA: Renderizar tabela A/B com 2 colunas independentes
    // Modo REFERENCE: Extrair métricas de userAnalysis (1ª faixa) e referenceAnalysis (2ª faixa)
    
    let abTableHTML = '';
    
    if (isReferenceMode && opts.userAnalysis && opts.referenceAnalysis) {
        console.log('🎯 [A/B-TABLE-FIX] Renderizando tabela A/B com 2 colunas independentes');
        
        const userTech = opts.userAnalysis.technicalData || {};
        const refTech = opts.referenceAnalysis.technicalData || {};
        
        // 🎯 ASSERT CRÍTICO: Garantir que métricas são DIFERENTES
        if (userTech.lufsIntegrated === refTech.lufsIntegrated &&
            userTech.dynamicRange === refTech.dynamicRange &&
            userTech.truePeakDbtp === refTech.truePeakDbtp) {
            console.error('❌ [A/B-TABLE-FIX] ERRO CRÍTICO: user/ref metrics IDÊNTICAS - DOM duplicado ou fonte errada!');
            console.table({
                'User LUFS': userTech.lufsIntegrated,
                'Ref LUFS': refTech.lufsIntegrated,
                'User DR': userTech.dynamicRange,
                'Ref DR': refTech.dynamicRange,
                'User Peak': userTech.truePeakDbtp,
                'Ref Peak': refTech.truePeakDbtp
            });
            container.innerHTML = '<div class="card" style="margin-top:12px;"><div style="color:red;padding:20px;">❌ ERRO: Métricas idênticas detectadas. Recarregue a página.</div></div>';
            return;
        }
        
        // Helper format
        const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '—';
        
        // 🎯 Helper para calcular status e cor baseado na diferença
        const getStatusAndColor = (diff, tolerance = 0.5) => {
            if (!Number.isFinite(diff)) {
                return { class: '', text: 'N/A', color: 'rgba(255,255,255,0.3)' };
            }
            
            const absDiff = Math.abs(diff);
            
            // Lógica adaptativa baseada no tipo de métrica
            if (absDiff <= tolerance) {
                // ✅ IDEAL
                return { 
                    class: 'ok', 
                    text: 'Ideal',
                    icon: '✅'
                };
            } else if (absDiff <= tolerance * 6) {
                // ⚠️ AJUSTE LEVE
                return { 
                    class: 'yellow', 
                    text: 'Ajuste leve',
                    icon: '⚠️'
                };
            } else {
                // ❌ CORRIGIR
                return { 
                    class: 'warn', 
                    text: 'Corrigir',
                    icon: '❌'
                };
            }
        };
        
        // Construir linhas A/B com Delta e Status
        const abRows = [];
        
        const addABRow = (label, userVal, refVal, unit = '', dataMetric = '', tolerance = 0.5) => {
            const dataAttr = dataMetric ? ` data-metric="${dataMetric}"` : '';
            
            // Calcular diferença (Faixa 1 - Faixa 2)
            let delta = null;
            let deltaText = '—';
            
            if (Number.isFinite(userVal) && Number.isFinite(refVal)) {
                delta = userVal - refVal;
                const sign = delta > 0 ? '+' : '';
                deltaText = `${sign}${nf(delta)}${unit}`;
            }
            
            // Obter status e classe CSS
            const status = getStatusAndColor(delta, tolerance);
            
            abRows.push(`<tr${dataAttr}>
                <td class="metric-name">${label}</td>
                <td class="ab-user"${dataAttr}>${Number.isFinite(userVal) ? nf(userVal) + unit : '—'}</td>
                <td class="ab-ref"${dataAttr}>${Number.isFinite(refVal) ? nf(refVal) + unit : '—'}</td>
                <td class="delta-col">${deltaText}</td>
                <td class="status-col ${status.class}">
                    <div class="diff-cell-content">
                        <span class="diff-value">${status.icon}</span>
                        <span class="diff-status">${status.text}</span>
                    </div>
                </td>
            </tr>`);
        };
        
        // ===== MÉTRICAS PRINCIPAIS =====
        addABRow('Loudness (LUFS Integrado)', userTech.lufsIntegrated, refTech.lufsIntegrated, ' LUFS', 'lufs', 0.5);
        addABRow('True Peak (dBTP)', userTech.truePeakDbtp, refTech.truePeakDbtp, ' dBTP', 'truepeak', 0.3);
        addABRow('Dynamic Range (dB)', userTech.dynamicRange, refTech.dynamicRange, ' dB', 'dr', 1.0);
        addABRow('LRA (LU)', userTech.lra, refTech.lra, ' LU', 'lra', 1.0);
        addABRow('Stereo Corr.', userTech.stereoCorrelation, refTech.stereoCorrelation, '', 'stereo', 0.08);
        
        // ===== BANDAS ESPECTRAIS =====
        const userBands = userTech.spectral_balance || {};
        const refBands = refTech.spectral_balance || {};
        
        const bandNames = {
            sub: 'Sub (20-60Hz)',
            bass: 'Bass (60-150Hz)',
            lowMid: 'Low-Mid (150-500Hz)',
            mid: 'Mid (500-2kHz)',
            highMid: 'High-Mid (2-5kHz)',
            presence: 'Presence (5-10kHz)',
            air: 'Air (10-20kHz)'
        };
        
        Object.entries(bandNames).forEach(([key, name]) => {
            const userVal = userBands[key]?.energy_db ?? userBands[key]?.percentage ?? userBands[key];
            const refVal = refBands[key]?.energy_db ?? refBands[key]?.percentage ?? refBands[key];
            if (Number.isFinite(userVal) || Number.isFinite(refVal)) {
                addABRow(name, userVal, refVal, ' dB', `band-${key}`, 1.0);
            }
        });
        
        // Nomes das faixas
        const userName = opts.userAnalysis.fileName || opts.userAnalysis.metadata?.fileName || '1ª Faixa';
        const refName = opts.referenceAnalysis.fileName || opts.referenceAnalysis.metadata?.fileName || '2ª Faixa';
        
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title" style="
                background: linear-gradient(90deg, #7F00FF, #00FFFF);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                font-size: clamp(15px, 1.3vw, 18px);
                font-weight: 700;
                margin-bottom: 12px;
            ">🎵 COMPARAÇÃO A/B ENTRE FAIXAS</div>
            
            <!-- Header com nomes das faixas - Compacto e elegante -->
            <div class="ab-header" style="
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 10px; 
                padding: 10px; 
                background: linear-gradient(90deg, rgba(127, 0, 255, 0.08), rgba(0, 255, 255, 0.08));
                border-radius: 8px; 
                margin-bottom: 10px;
                border: 1px solid rgba(127, 0, 255, 0.12);
            ">
                <div class="track-name user-track" style="
                    padding: 8px 10px;
                    background: rgba(82, 247, 173, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #52f7ad;
                    box-shadow: 0 2px 6px rgba(82, 247, 173, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">🎧</span>
                        <span>SUA FAIXA</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${userName}</div>
                </div>
                <div class="track-name ref-track" style="
                    padding: 8px 10px;
                    background: rgba(255, 206, 77, 0.08);
                    border-radius: 6px;
                    border-left: 2px solid #ffce4d;
                    box-shadow: 0 2px 6px rgba(255, 206, 77, 0.12);
                ">
                    <div style="
                        font-size: 9px; 
                        opacity: 0.7; 
                        margin-bottom: 5px; 
                        text-transform: uppercase; 
                        letter-spacing: 0.8px; 
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    ">
                        <span style="font-size: 13px;">🎚️</span>
                        <span>REFERÊNCIA</span>
                    </div>
                    <div style="
                        font-weight: 600; 
                        font-size: clamp(11.5px, 1vw, 13px); 
                        line-height: 1.3; 
                        word-break: break-word;
                        color: rgba(255, 255, 255, 0.9);
                    ">${refName}</div>
                </div>
            </div>
            
            <!-- Tabela de comparação - Refinada e compacta -->
            <table class="ref-compare-table ab-compare-table" style="width: 100%;">
                <thead>
                    <tr>
                        <th style="text-align: left; padding-left: 12px;">Métrica</th>
                        <th class="ab-user-header">FAIXA 1</th>
                        <th class="ab-ref-header">FAIXA 2</th>
                        <th>Δ</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody id="ab-comparison-body">${abRows.join('')}</tbody>
            </table>
        </div>`;
        
        // 🎯 LOG DE VALIDAÇÃO PÓS-RENDER
        console.group('🎯 [A/B-TABLE-VALIDATION] Validação pós-renderização');
        console.log('USER LUFS:', userTech.lufsIntegrated);
        console.log('REF LUFS:', refTech.lufsIntegrated);
        console.log('USER DR:', userTech.dynamicRange);
        console.log('REF DR:', refTech.dynamicRange);
        console.log('USER TruePeak:', userTech.truePeakDbtp);
        console.log('REF TruePeak:', refTech.truePeakDbtp);
        console.groupEnd();
        
    } else {
        // Modo GENRE ou fallback: usar tabela antiga
        console.warn('⚠️ [A/B-TABLE-FIX] Modo GENRE ou dados incompletos - usando tabela de referência padrão');
        abTableHTML = `<div class="card" style="margin-top:12px;">
            <div class="card-title">COMPARAÇÃO DE REFERÊNCIA (${titleText})</div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>Métrica</th><th>Valor</th><th>Alvo</th><th>Δ</th>
                </tr></thead>
                <tbody>${rows.join('') || '<tr><td colspan="4" style="opacity:.6">Sem métricas disponíveis</td></tr>'}</tbody>
            </table>
        </div>`;
    }
    
    // 🎯 RENDERIZAR TABELA NO DOM COM PROTEÇÃO DE ERRO
    try {
        container.innerHTML = abTableHTML;
        
        // 🔍 LOGS OBRIGATÓRIOS DE VERIFICAÇÃO
        console.log('[AB-RENDER] container exists?', !!container);
        console.log('[AB-RENDER] rows count:', rows.length);
        console.log('[AB-RENDER] inserted?', container.innerHTML.length > 0);
        console.log('[RENDER-REF] ✅ HTML da tabela A/B inserido no DOM:', {
            htmlLength: abTableHTML.length,
            containerHasContent: container.innerHTML.length > 0,
            containerId: container.id,
            rowsGenerated: rows.length
        });
    } catch (err) {
        console.error('[RENDER-REF] ❌ Erro ao inserir HTML da tabela A/B:', err);
        console.log('[AB-RENDER] inserted?', false);
        container.innerHTML = `<div class="error-message" style="padding: 20px; color: #ff4444; background: #1a1a1f; border-radius: 8px;">
            ❌ Erro ao renderizar tabela de comparação A/B: ${err.message}
        </div>`;
    }
    
    // 🎯 FORÇAR VISIBILIDADE DA TABELA EM AMBOS OS MODOS
    console.log('[UI_RENDER] Forçando renderização da tabela comparativa');
    const tableEl = document.getElementById('referenceComparisons');
    if (tableEl) {
        tableEl.classList.remove('hidden');
        tableEl.style.display = ''; // Limpa inline display:none
        tableEl.style.visibility = 'visible';
        tableEl.style.opacity = '1';
        console.log('✅ [RENDER-REF] Tabela forçada para visível (mode:', renderMode, ')');
        
        // 🎯 [DOM-VALIDATION] ASSERT CRÍTICO: Verificar que elementos A/B são DISTINTOS
        if (isReferenceMode) {
            setTimeout(() => {
                const userLufsEl = document.querySelector('.ab-user[data-metric="lufs"]');
                const refLufsEl = document.querySelector('.ab-ref[data-metric="lufs"]');
                
                console.group('🎯 [DOM-VALIDATION] Verificação de elementos A/B');
                console.log('User LUFS Element:', userLufsEl);
                console.log('Ref LUFS Element:', refLufsEl);
                console.log('São o mesmo elemento?', userLufsEl === refLufsEl);
                console.log('User LUFS innerHTML:', userLufsEl?.innerHTML);
                console.log('Ref LUFS innerHTML:', refLufsEl?.innerHTML);
                
                if (userLufsEl === refLufsEl) {
                    console.error('❌ [DOM-VALIDATION] ERRO CRÍTICO: Elementos .ab-user e .ab-ref são o MESMO objeto!');
                } else if (!userLufsEl || !refLufsEl) {
                    console.error('❌ [DOM-VALIDATION] ERRO: Elementos não encontrados no DOM!');
                } else {
                    console.log('✅ [DOM-VALIDATION] Elementos A/B são DISTINTOS e independentes');
                }
                console.groupEnd();
            }, 100);
        }
        
        // 🔍 VERIFICAÇÃO FINAL DE VISIBILIDADE (PATCH SENIOR)
        setTimeout(() => {
            const finalCheck = document.querySelector('#referenceComparisons');
            if (finalCheck) {
                const rect = finalCheck.getBoundingClientRect();
                const computed = window.getComputedStyle(finalCheck);
                
                console.log('[DOM-FINAL-CHECK] 🔍 Estado do container #referenceComparisons:', {
                    exists: true,
                    hasContent: finalCheck.innerHTML.length > 0,
                    childrenCount: finalCheck.children.length,
                    display: computed.display,
                    visibility: computed.visibility,
                    opacity: computed.opacity,
                    width: rect.width,
                    height: rect.height,
                    isVisible: rect.width > 0 && rect.height > 0 && computed.display !== 'none'
                });
                
                // 🛡️ FORÇAR VISIBILIDADE se necessário
                if (computed.display === 'none' || computed.visibility === 'hidden' || computed.opacity === '0') {
                    console.warn('[DOM-FINAL-CHECK] ⚠️ Container oculto - FORÇANDO VISIBILIDADE');
                    finalCheck.style.display = 'block';
                    finalCheck.style.visibility = 'visible';
                    finalCheck.style.opacity = '1';
                }
            } else {
                console.error('[DOM-FINAL-CHECK] ❌ #referenceComparisons NÃO EXISTE NO DOM!');
                
                // 🚨 DIAGNÓSTICO COMPLETO
                console.group('[DOM-DIAGNOSTIC] 🔬 Diagnóstico completo do DOM');
                console.log('audioAnalysisResults existe?', !!document.getElementById('audioAnalysisResults'));
                console.log('modalTechnicalData existe?', !!document.getElementById('modalTechnicalData'));
                console.log('Todos os elementos do modal:', {
                    results: document.getElementById('audioAnalysisResults')?.innerHTML?.length || 0,
                    technical: document.getElementById('modalTechnicalData')?.innerHTML?.length || 0,
                    children: document.getElementById('audioAnalysisResults')?.children?.length || 0
                });
                console.groupEnd();
            }
        }, 500);

    } else {
        console.error('❌ [RENDER-REF] Elemento #referenceComparisons NÃO encontrado no DOM!');
    }
    
    // 🎯 Verificar se wrapper/parent também está visível
    const wrapper = tableEl?.parentElement;
    if (wrapper) {
        wrapper.classList.remove('hidden');
        wrapper.classList.add('visible');
        wrapper.style.display = '';
    }
    
    // 🛡️ PASSO 3: VERIFICAÇÃO FINAL
    console.log('🎯 [AUDITORIA_REF] Comparação de referência renderizada com sucesso');
    console.log('🎯 [AUDITORIA_REF] Targets usados:', {
        lufs: lufsTarget,
        truePeak: tpTarget,
        dr: drTarget,
        lra: lraTarget,
        stereo: stereoTarget,
        totalRows: rows.length
    });
    
    // 🎯 LOG FINAL DE SUCESSO COMPLETO
    console.log('✅ [REF-COMP] renderReferenceComparisons SUCCESS', {
        mode: renderMode,
        usedReferenceAnalysis: !!analysis.referenceAnalysis,
        bandsResolved: ref.bands ? Object.keys(ref.bands).length : 0,
        rowsGenerated: rows.length,
        titleDisplayed: titleText,
        tableVisible: renderMode === 'reference'
    });
    
    // 🎯 TRANSIÇÃO DE ESTADO FINAL: REF_B_DONE → REF_AB_RENDERED
    console.log('%c[REF-FLOW] 🎯 TRANSIÇÃO FINAL: REF_B_DONE → REF_AB_RENDERED', 'color:#00FF88;font-weight:bold;font-size:16px;');
    console.log('[REF-FLOW] ✅ Fluxo A/B COMPLETADO COM SUCESSO!');
    console.log('[REF-FLOW] Estado final:', {
        stage: 'REF_AB_RENDERED',
        tableRendered: true,
        comparisonComplete: true,
        rowsDisplayed: rows.length,
        currentMode: window.currentAnalysisMode
    });
    
    // 🎯 LOG FINAL DE VERIFICAÇÃO (conforme solicitado)
    console.log('[FINAL-CHECK] renderReferenceComparisons concluído com', {
        mode: renderMode,
        bands: Object.keys(ref?.bands || {}),
        bandsCount: Object.keys(ref?.bands || {}).length,
        tableVisible: !!document.querySelector('#referenceComparisons'),
        tableHasContent: rows.length > 0,
        userMetricsLoaded: !!userMetrics,
        refMetricsLoaded: !!ref,
        titleText: titleText
    });
    
    // ✅ DESBLOQUEIO DO MODAL - Finalizar loading e exibir resultados
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (loading) {
        loading.style.display = 'none';
        console.log('[MODAL-FIX] ✅ Loading ocultado');
    }
    
    if (results) {
        results.style.display = 'block';
        console.log('[MODAL-FIX] ✅ Resultados exibidos');
    }
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        console.log('[MODAL-FIX] ✅ Upload area ocultada');
    }
    
    console.log('[MODAL-FIX] ✅ Loading encerrado com sucesso - modal desbloqueado');
    
    // Estilos injetados uma vez com indicadores visuais melhorados
    if (!document.getElementById('refCompareStyles')) {
        const style = document.createElement('style');
        style.id = 'refCompareStyles';
        style.textContent = `
        .ref-compare-table{width:100%;border-collapse:collapse;font-size:11px;}
        .ref-compare-table th{font-weight:500;padding:4px 6px;border-bottom:1px solid rgba(255,255,255,.12);font-size:11px;color:#fff;letter-spacing:.3px;}
        .ref-compare-table th:first-child{text-align:left;}
        .ref-compare-table th:not(:first-child){text-align:center;}
        .ref-compare-table td{padding:5px 6px;border-bottom:1px solid rgba(255,255,255,.06);color:#f5f7fa;} 
        .ref-compare-table td:first-child{text-align:left;}
        .ref-compare-table td:not(:first-child){text-align:center;}
        .ref-compare-table tr:last-child td{border-bottom:0;} 
        .ref-compare-table td.ok{color:#52f7ad;font-weight:600;} 
        .ref-compare-table td.ok::before{content:'✅ ';margin-right:2px;}
        .ref-compare-table td.yellow{color:#ffce4d;font-weight:600;} 
        .ref-compare-table td.yellow::before{content:'⚠️ ';margin-right:2px;}
        .ref-compare-table td.warn{color:#ff7b7b;font-weight:600;} 
        .ref-compare-table td.warn::before{content:'❌ ';margin-right:2px;}
        .ref-compare-table .tol{opacity:.7;margin-left:4px;font-size:10px;color:#b8c2d6;} 
        .ref-compare-table tbody tr:hover td{background:rgba(255,255,255,.04);} 
        `;
        document.head.appendChild(style);
    }
    
    // 🎯 ESTILOS DA TABELA CLÁSSICA DE GÊNERO
    if (!document.getElementById('classicGenreStyles')) {
        const genreStyle = document.createElement('style');
        genreStyle.id = 'classicGenreStyles';
        genreStyle.textContent = `
        .classic-genre-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .classic-genre-table th {
            font-weight: 600;
            padding: 6px 8px;
            border-bottom: 2px solid rgba(255,255,255,.15);
            font-size: 11px;
            color: #fff;
            text-align: left;
            letter-spacing: .5px;
            background: rgba(0,0,0,.2);
        }
        .classic-genre-table tbody tr {
            transition: background .2s ease;
        }
        .classic-genre-table tbody tr:hover {
            background: rgba(255,255,255,.05);
        }
        .classic-genre-table td {
            padding: 7px 8px;
            border-bottom: 1px solid rgba(255,255,255,.08);
            font-size: 11px;
        }
        .classic-genre-table tr:last-child td {
            border-bottom: 0;
        }
        
        /* 🎯 CORES DE SEVERIDADE */
        .classic-genre-table .genre-row.ok {
            background: rgba(82, 247, 173, .05);
        }
        .classic-genre-table .genre-row.ok:hover {
            background: rgba(82, 247, 173, .12);
        }
        .classic-genre-table .genre-row.caution {
            background: rgba(255, 206, 77, .08);
        }
        .classic-genre-table .genre-row.caution:hover {
            background: rgba(255, 206, 77, .15);
        }
        .classic-genre-table .genre-row.warning {
            background: rgba(255, 165, 0, .1);
        }
        .classic-genre-table .genre-row.warning:hover {
            background: rgba(255, 165, 0, .18);
        }
        .classic-genre-table .genre-row.critical {
            background: rgba(255, 82, 82, .12);
        }
        .classic-genre-table .genre-row.critical:hover {
            background: rgba(255, 82, 82, .2);
        }
        
        /* 🎯 COLUNAS ESPECÍFICAS */
        .classic-genre-table .metric-name {
            font-weight: 500;
            color: #e1e8f0;
        }
        .classic-genre-table .metric-value {
            font-weight: 600;
            color: #52f7ad;
            text-align: center;
        }
        .classic-genre-table .metric-target {
            color: #9ca9ba;
            text-align: center;
            font-size: 10px;
        }
        .classic-genre-table .metric-diff {
            text-align: center;
            font-weight: 600;
        }
        .classic-genre-table .metric-diff.positive {
            color: #ff8a80;
        }
        .classic-genre-table .metric-diff.negative {
            color: #80d8ff;
        }
        .classic-genre-table .metric-severity {
            text-align: center;
            font-weight: 700;
            font-size: 10px;
            letter-spacing: .8px;
        }
        .classic-genre-table .metric-severity.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-severity.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-severity.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-severity.critical {
            color: #ff5252;
        }
        .classic-genre-table .metric-action {
            text-align: center;
            font-size: 10px;
            font-weight: 500;
        }
        .classic-genre-table .metric-action.ok {
            color: #52f7ad;
        }
        .classic-genre-table .metric-action.caution {
            color: #ffce4d;
        }
        .classic-genre-table .metric-action.warning {
            color: #ffa500;
        }
        .classic-genre-table .metric-action.critical {
            color: #ff5252;
        }
        `;
        document.head.appendChild(genreStyle);
    }
    
    // Garantir que o CSS do priority-banner esteja disponível no modal
    if (!document.getElementById('priorityBannerStyles')) {
        const priorityStyle = document.createElement('style');
        priorityStyle.id = 'priorityBannerStyles';
        priorityStyle.textContent = `
        .priority-banner {
            display: flex !important;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            font-weight: 700;
            background: linear-gradient(90deg, #ff006a, #ff9800) !important;
            color: #fff !important;
            margin-bottom: 10px;
            box-shadow: 0 0 15px rgba(255, 0, 106, 0.3);
            animation: pulsePriority 1.5s infinite alternate;
            position: relative;
            z-index: 10;
        }
        
        .priority-icon {
            font-size: 20px;
            line-height: 1;
        }
        
        @keyframes pulsePriority {
            from { opacity: 0.8; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1.02); }
        }
        `;
        document.head.appendChild(priorityStyle);
    }
    
    // 🔓 CORREÇÃO CRÍTICA: Liberar comparisonLock ao final da renderização
    window.comparisonLock = false;
    console.log('[FIX-AUDIT] ✅ comparisonLock liberado após renderização completa');
    console.log('[FIX-AUDIT] ✅ RenderReferenceComparisons auditado e restaurado com sucesso');
    console.log('[FIX-AUDIT] ✅ userBands e refBands preservadas');
    console.log('[FIX-AUDIT] ✅ Render completo no modo reference');
    console.log('[FIX-AUDIT] ✅ Cards e sugestões renderizados após comparação');
    console.groupEnd(); // Fecha [SAFE_RENDER_REF]
    
    // ==== PATCH 2 FINAL: Validação e limpeza ====
    if (opts.usedReferenceAnalysis !== true) {
        console.error("[REF-PATCH] usedReferenceAnalysis caiu pra false — bug de wiring");
        throw new Error("Reference not used");
    }
    window.__refRenderInProgress = false;
    
    // ========================================
    // 🛡️ FIM DO TRY/CATCH WRAPPER
    // ========================================
    } catch (error) {
        console.error('❌ [REF-RENDER-ERROR] Erro durante renderização:', error);
        console.error('❌ [REF-RENDER-ERROR] Stack:', error.stack);
        
        // Liberar locks para evitar travamento
        window.comparisonLock = false;
        window.__refRenderInProgress = false;
        
        // Exibir mensagem amigável ao usuário
        const container = document.getElementById('referenceComparisons');
        if (container) {
            container.innerHTML = `
                <div class="card" style="margin-top:12px;padding:16px;text-align:center;background:rgba(255,82,82,.1);border:1px solid rgba(255,82,82,.3);">
                    <strong style="color:#ff5252;">⚠️ Erro ao renderizar comparação</strong><br>
                    <span style="font-size:11px;color:#ffb3b3;">Ocorreu um erro ao exibir os resultados. Por favor, tente novamente.</span><br>
                    <span style="font-size:10px;color:#888;margin-top:8px;display:block;">Erro: ${error.message}</span>
                </div>
            `;
        }
        
        // Liberar modal para evitar travamento
        const loading = document.getElementById('audioAnalysisLoading');
        const results = document.getElementById('audioAnalysisResults');
        if (loading) loading.style.display = 'none';
        if (results) results.style.display = 'block';
        
        console.log('[REF-RENDER-SAFE] ✅ Erro capturado e tratado com segurança');
    }
}

// 🔒 CÓPIA IMUTÁVEL DA FUNÇÃO ORIGINAL displayModalResults
// Esta cópia garante que interceptadores sempre tenham acesso à função original
if (!window.__displayModalResultsOriginal) {
    console.log('[FIX] 🔒 Criando cópia imutável de displayModalResults');
    window.__displayModalResultsOriginal = displayModalResults;
    Object.freeze(window.__displayModalResultsOriginal);
    console.log('[FIX] ✅ Cópia imutável criada: window.__displayModalResultsOriginal');
}

/**
 * 🎯 RENDERIZAÇÃO DE COMPARAÇÃO ENTRE DUAS FAIXAS
 * Exibe tabela comparativa lado a lado: Faixa 1 (referência) vs Faixa 2 (usuário)
 * @param {Object} referenceAnalysis - Dados da primeira faixa (referência)
 * @param {Object} currentAnalysis - Dados da segunda faixa (usuário)
 */
function renderTrackComparisonTable(baseAnalysis, referenceAnalysis) {
    // 🎯 PARÂMETROS CORRIGIDOS:
    // baseAnalysis = primeira faixa (alvo/base da comparação)
    // referenceAnalysis = segunda faixa (atual/sendo comparada)
    
    console.log('🎯 [TRACK-COMPARE] Renderizando tabela comparativa entre faixas');
    console.log('📊 [TRACK-COMPARE] Base (1ª faixa - ALVO):', baseAnalysis);
    console.log('📊 [TRACK-COMPARE] Atual (2ª faixa - COMPARADA):', referenceAnalysis);
    
    // 🎯 Definir modo reference no estado
    const state = window.__soundyState || {};
    state.render = state.render || {};
    state.render.mode = 'reference';
    console.log('✅ [TRACK-COMPARE] Modo definido como reference no estado');
    
    // 🎯 LOG AUDIT-MODE-FLOW (conforme solicitado)
    console.log('[AUDIT-MODE-FLOW]', {
        mode: state.render.mode,
        isSecondTrack: state.reference?.isSecondTrack,
        refJobId: state.reference?.jobId,
        hasRefAnalysis: !!state.reference?.analysis
    });
    
    const container = document.getElementById('referenceComparisons');
    if (!container) {
        console.error('❌ Container referenceComparisons não encontrado');
        return;
    }
    
    // 🔥 CORREÇÃO: Usar dados DIRETOS do backend (sem reconstrução)
    // ref = primeira faixa (BASE/ALVO)
    // curr = segunda faixa (ATUAL/COMPARADA)
    const ref = baseAnalysis; // ✅ LEITURA DIRETA
    const curr = referenceAnalysis; // ✅ LEITURA DIRETA
    
    const refTech = ref.technicalData || {};
    const currTech = curr.technicalData || {};
    
    // Helper para comparar valores e calcular status
    const nf = (n, d=2) => Number.isFinite(n) ? n.toFixed(d) : '—';
    const calcDiffPercent = (curr, ref) => {
        if (!Number.isFinite(curr) || !Number.isFinite(ref) || ref === 0) return null;
        return ((curr - ref) / Math.abs(ref)) * 100;
    };
    
    const getStatus = (diffPercent, tolerance = 10) => {
        if (diffPercent === null) return { class: '', text: 'N/A' };
        const absDiff = Math.abs(diffPercent);
        if (absDiff <= tolerance) return { class: 'ok', text: '✅ Ideal' };
        if (absDiff <= tolerance * 2) return { class: 'yellow', text: '⚠️ Ajuste leve' };
        return { class: 'warn', text: '❌ Corrigir' };
    };
    
    // Construir linhas da tabela
    const rows = [];
    
    // Função auxiliar para adicionar linha
    const addRow = (label, currVal, refVal, unit = '', tolerance = 10) => {
        const diffPercent = calcDiffPercent(currVal, refVal);
        const status = getStatus(diffPercent, tolerance);
        const diffText = diffPercent !== null ? `${diffPercent > 0 ? '+' : ''}${nf(diffPercent, 1)}%` : '—';
        
        rows.push(`<tr>
            <td>${label}</td>
            <td>${Number.isFinite(currVal) ? nf(currVal) + unit : '—'}</td>
            <td>${Number.isFinite(refVal) ? nf(refVal) + unit : '—'}</td>
            <td>${diffText}</td>
            <td class="${status.class}">${status.text}</td>
        </tr>`);
    };
    
    // ===== MÉTRICAS PRINCIPAIS =====
    addRow('Loudness (LUFS Integrado)', currTech.lufsIntegrated || currTech.lufs_integrated, 
           refTech.lufsIntegrated || refTech.lufs_integrated, ' LUFS', 5);
    
    addRow('True Peak (dBTP)', currTech.truePeakDbtp || currTech.true_peak_dbtp,
           refTech.truePeakDbtp || refTech.true_peak_dbtp, ' dBTP', 10);
    
    addRow('Dynamic Range (dB)', currTech.dynamicRange || currTech.dynamic_range,
           refTech.dynamicRange || refTech.dynamic_range, ' dB', 15);
    
    addRow('LRA (LU)', currTech.lra, refTech.lra, ' LU', 15);
    
    addRow('Stereo Correlation', currTech.stereoCorrelation || currTech.stereo_correlation,
           refTech.stereoCorrelation || refTech.stereo_correlation, '', 8);
    
    addRow('Spectral Centroid (Hz)', currTech.spectralCentroidHz || currTech.spectral_centroid,
           refTech.spectralCentroidHz || refTech.spectral_centroid, ' Hz', 10);
    
    // ===== BANDAS ESPECTRAIS =====
    const currBands = currTech.spectral_balance || {};
    const refBands = refTech.spectral_balance || {};
    
    const bandNames = {
        sub: 'Sub (20-60Hz)',
        bass: 'Bass (60-150Hz)',
        lowMid: 'Low-Mid (150-500Hz)',
        mid: 'Mid (500-2kHz)',
        highMid: 'High-Mid (2-5kHz)',
        presence: 'Presence (5-10kHz)',
        air: 'Air (10-20kHz)'
    };
    
    Object.entries(bandNames).forEach(([key, name]) => {
        const currVal = currBands[key]?.percentage;
        const refVal = refBands[key]?.percentage;
        if (Number.isFinite(currVal) && Number.isFinite(refVal)) {
            addRow(name, currVal, refVal, '%', 10);
        }
    });
    
    // Calcular scores comparativos
    const refScore = ref.score || 0;
    const currScore = curr.score || 0;
    const scoreDiff = currScore - refScore;
    
    // 🎯 FIX: Extrair nomes reais das faixas COM fallback robusto
    // Helper para remover extensão de arquivo
    const removeExtension = (filename) => {
        if (!filename) return null;
        return filename.replace(/\.[^/.]+$/, '');
    };
    
    // Extrair nome da primeira faixa (BASE/ALVO) - múltiplas fontes
    const refFileName = removeExtension(
        ref.metadata?.fileName || 
        ref.fileName || 
        window.SoundyAI_Store?.first?.fileName ||
        window.SoundyAI_Store?.first?.metadata?.fileName ||
        window.__soundyState?.reference?.userAnalysis?.fileName ||
        window.__soundyState?.reference?.userAnalysis?.metadata?.fileName
    ) || 'Faixa 1';
    
    // Extrair nome da segunda faixa (ATUAL/COMPARADA) - múltiplas fontes
    const currFileName = removeExtension(
        curr.metadata?.fileName || 
        curr.fileName || 
        window.SoundyAI_Store?.second?.fileName ||
        window.SoundyAI_Store?.second?.metadata?.fileName ||
        window.__soundyState?.reference?.referenceAnalysis?.fileName ||
        window.__soundyState?.reference?.referenceAnalysis?.metadata?.fileName
    ) || 'Faixa 2';
    
    console.log('🎯 [TRACK-NAMES-FIX] Nomes extraídos:', { refFileName, currFileName });
    
    // Montar HTML da tabela
    // 🎯 LABELS DINÂMICOS: Primeira faixa = BASE/ALVO, Segunda faixa = ATUAL
    container.innerHTML = `
        <div class="card" style="margin-top:12px;">
            <div class="card-title">🎵 COMPARAÇÃO ENTRE FAIXAS (Modo Reference)</div>
            <div style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 12px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA BASE (1ª - ALVO)</div>
                        <div style="font-weight: 600; font-size: 14px;" title="${refFileName}">
                            ${refFileName}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: #52f7ad;">${nf(refScore, 0)}</span>
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 11px; opacity: 0.7; margin-bottom: 4px;">FAIXA DE REFERÊNCIA (2ª - ATUAL)</div>
                        <div style="font-weight: 600; font-size: 14px;" title="${currFileName}">
                            ${currFileName}
                        </div>
                        <div style="font-size: 12px; margin-top: 4px;">
                            Score: <span style="color: ${scoreDiff >= 0 ? '#52f7ad' : '#ff7b7b'};">${nf(currScore, 0)}</span>
                            <span style="opacity: 0.7; margin-left: 4px;">(${scoreDiff > 0 ? '+' : ''}${nf(scoreDiff, 0)})</span>
                        </div>
                    </div>
                </div>
            </div>
            <table class="ref-compare-table">
                <thead><tr>
                    <th>Métrica</th>
                    <th>FAIXA 1</th>
                    <th>FAIXA 2</th>
                    <th>Diferença (%)</th>
                    <th>Status</th>
                </tr></thead>
                <tbody>${rows.join('')}</tbody>
            </table>
        </div>
    `;
    
    // 🎯 AUDIT_REF_FIX: Log final de confirmação do fluxo A/B
    // 🔒 GUARD: Só executar logs de referência se viewMode === "reference"
    if (getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('✅ [TRACK-COMPARE] Tabela comparativa renderizada com sucesso');
        console.log('[REFERENCE-A/B FIXED ✅] Comparação A/B entre faixas concluída');
        console.log('[AUDIT_REF_FIX] Tabela exibindo valores brutos da segunda faixa (referência real)');
        console.log('[MODE LOCKED] reference - renderização completa sem alteração de modo');
        
        // 🎉 LOG FINAL DE AUDITORIA
        console.log("✅ [REFERENCE-A/B FIXED] Comparação renderizada sem erros.");
        console.log("✅ [AUDITORIA_FINAL_RENDER_REF] Render concluído com sucesso.");
    } else {
        console.log('[REFERENCE-GUARD] 🚫 Logs de referência bloqueados (viewMode:', getViewMode(), ')');
    }
    
    // 🎯 VALIDAÇÃO FINAL PÓS-FIX
    const validationData = {
        userTrack: ref.metadata?.fileName || ref.fileName || 'Primeira Faixa',
        refTrack: curr.metadata?.fileName || curr.fileName || 'Segunda Faixa',
        userLUFS: ref.technicalData?.lufsIntegrated || ref.technicalData?.lufs_integrated || 'N/A',
        refLUFS: curr.technicalData?.lufsIntegrated || curr.technicalData?.lufs_integrated || 'N/A',
        userDR: ref.technicalData?.dynamicRange || ref.technicalData?.dynamic_range || 'N/A',
        refDR: curr.technicalData?.dynamicRange || curr.technicalData?.dynamic_range || 'N/A',
        userPeak: ref.technicalData?.truePeakDbtp || ref.technicalData?.true_peak_dbtp || 'N/A',
        refPeak: curr.technicalData?.truePeakDbtp || curr.technicalData?.true_peak_dbtp || 'N/A',
        render: 'concluído sem erros'
    };
    
    console.log('✅ [VALIDAÇÃO-FINAL] Modal Reference OK:', validationData);
    
    // ✅ Libera lock após renderização
    window.comparisonLock = false;
    console.log("[LOCK] comparisonLock liberado");
    
    // 🚫 OCULTAR BOTÃO "PLANO DE CORREÇÃO" NO MODO REFERÊNCIA
    const btnCorrectionPlan = document.getElementById('btnGenerateCorrectionPlan');
    if (btnCorrectionPlan) {
        btnCorrectionPlan.style.display = 'none';
        console.log('[REFERENCE-UI] 🔒 Botão "Plano de Correção" ocultado no modo referência');
    }
    
    console.groupEnd();
}

// 🎯 ===== SISTEMA DE SCORING AVANÇADO =====
// Sistema completo de pontuação por categorias com adaptação por gênero

// 1. PESOS POR GÊNERO (ATUALIZADOS CONFORME ESPECIFICAÇÃO)
const GENRE_SCORING_WEIGHTS = {
    // Funk Mandela - Foco em Loudness e Dinâmica
    'funk_mandela': {
        loudness: 0.32,    // Loudness crítico no funk
        dinamica: 0.23,    // Dinâmica importante
        frequencia: 0.20,  // Frequência equilibrada
        estereo: 0.15,     // Estéreo moderado
        tecnico: 0.10      // Técnico básico
    },
    
    // Funk Automotivo (similar ao Mandela)
    'funk_automotivo': {
        loudness: 0.32,
        dinamica: 0.23,
        frequencia: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Trap/Trance - Foco em Loudness e Frequência
    'trap': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // Frequência crítica
        estereo: 0.20,     // Estéreo importante
        dinamica: 0.15,    // Dinâmica moderada
        tecnico: 0.10      // Técnico básico
    },
    
    'trance': {
        loudness: 0.25,    // Loudness importante
        frequencia: 0.30,  // Frequência crítica
        estereo: 0.20,     // Estéreo importante
        dinamica: 0.15,    // Dinâmica moderada
        tecnico: 0.10      // Técnico básico
    },
    
    // Eletrônico - Foco em Frequência e Estéreo
    'eletronico': {
        frequencia: 0.30,  // Frequência crítica
        estereo: 0.25,     // Estéreo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // Dinâmica moderada
        tecnico: 0.10      // Técnico básico
    },
    
    // Funk Bruxaria - Similar ao Eletrônico
    'funk_bruxaria': {
        frequencia: 0.30,  // Frequência crítica
        estereo: 0.25,     // Estéreo importante
        loudness: 0.20,    // Loudness moderado
        dinamica: 0.15,    // Dinâmica moderada
        tecnico: 0.10      // Técnico básico
    },
    
    // Hip Hop - Balanceado entre Frequência e Dinâmica
    'hip_hop': {
        frequencia: 0.30,
        dinamica: 0.25,
        loudness: 0.20,
        estereo: 0.15,
        tecnico: 0.10
    },
    
    // Pesos padrão (fallback) - Distribuição equilibrada
    'default': {
        loudness: 0.25,
        frequencia: 0.25,
        dinamica: 0.20,
        estereo: 0.15,
        tecnico: 0.15
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 FONTE ÚNICA DA VERDADE: Usar targets normalizados do backend
// ═══════════════════════════════════════════════════════════════════════════

// 🚨 TRUE_PEAK_HARD_CAP já definida no início do arquivo (linha ~10)
// NÃO redefinir aqui para evitar erro de declaração duplicada

/**
 * 🎯 getNormalizedTargetsFromAnalysis - Extrai targets normalizados do resultado do backend
 * 
 * PRIORIDADE (FONTE ÚNICA DA VERDADE):
 * 1. analysis.data.targetProfile (NOVO - estrutura completa com tp_min, tp_max, etc)
 * 2. analysis.data.referenceTargetsNormalized (formato anterior)
 * 3. Fallback: retornar null (frontend usará getMetricBounds como último recurso)
 * 
 * ❌ PROIBIDO: Fallbacks para PROD_AI_REF_DATA, __activeRefData, etc.
 * 
 * @param {Object} analysis - Objeto de análise retornado pelo backend
 * @returns {Object|null} Targets normalizados { metrics: {...}, bands: {...}, preCalculatedSeverities: {...} }
 */
function getNormalizedTargetsFromAnalysis(analysis) {
    // 🎯 PRIORIDADE 1: targetProfile (NOVO - estrutura completa)
    if (analysis?.data?.targetProfile) {
        console.log('[NORMALIZED-TARGETS] ✅ Usando targetProfile do backend (FONTE ÚNICA)');
        console.log('[NORMALIZED-TARGETS] Genre:', analysis.data.targetProfile._genre);
        
        // Converter targetProfile para formato compatível com código existente
        const tp = analysis.data.targetProfile;
        return {
            metrics: {
                lufs: tp.lufs ? { ...tp.lufs, target: tp.lufs.target } : null,
                truePeak: tp.truePeak ? { 
                    min: tp.truePeak.tp_min,
                    max: tp.truePeak.tp_max,
                    target: tp.truePeak.tp_target,
                    warnFrom: tp.truePeak.tp_warn_from,
                    hardCap: tp.truePeak.tp_max
                } : null,
                dr: tp.dr ? { ...tp.dr, target: tp.dr.target } : null,
                lra: tp.lra,
                stereo: tp.stereo
            },
            bands: tp.bands,
            preCalculatedSeverities: tp.preCalculatedSeverities,
            _source: 'targetProfile',
            _genre: tp._genre
        };
    }
    
    // 🎯 PRIORIDADE 2: referenceTargetsNormalized (formato anterior)
    if (analysis?.data?.referenceTargetsNormalized) {
        console.log('[NORMALIZED-TARGETS] ✅ Usando referenceTargetsNormalized do backend');
        return {
            ...analysis.data.referenceTargetsNormalized,
            _source: 'referenceTargetsNormalized'
        };
    }
    
    // 🔄 FALLBACK: Se backend não enviou, retornar null (frontend usará getMetricBounds)
    // ❌ REMOVIDO: Fallbacks para PROD_AI_REF_DATA, __activeRefData, etc.
    console.log('[NORMALIZED-TARGETS] ⚠️ Backend não enviou targetProfile nem referenceTargetsNormalized');
    return null;
}

/**
 * ═══════════════════════════════════════════════════════════════════════════════
 * 🎯 evaluateMetricFromTargetProfile - FUNÇÃO CENTRALIZADA DE AVALIAÇÃO
 * 
 * Esta função DEVE ser usada por:
 *   1) Tabela de comparação (status, ação)
 *   2) Score (pontuação)
 *   3) Builder de sugestões (severidade, delta)
 * 
 * GARANTE: mesma avaliação em todos os lugares, sem divergências.
 * ═══════════════════════════════════════════════════════════════════════════════
 * 
 * @param {string} metricKey - 'truePeak', 'lufs', 'dr', 'stereo'
 * @param {number} value - Valor medido
 * @param {Object} targetProfile - Objeto targetProfile do backend
 * @returns {Object} { severity, severityClass, action, diff, isCritical, isWithinRange }
 */
function evaluateMetricFromTargetProfile(metricKey, value, targetProfile) {
    if (!Number.isFinite(value)) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    if (!targetProfile) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem targets', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // 🎯 PRIORIDADE 1: Usar severidade pré-calculada do backend
    const preCalc = targetProfile.preCalculatedSeverities?.[metricKey] 
                 || targetProfile.preCalculatedSeverities?.metrics?.[metricKey];
    if (preCalc) {
        return {
            severity: preCalc.severity,
            severityClass: preCalc.severity === 'CRÍTICA' ? 'critical' : 
                          preCalc.severity === 'ALTA' ? 'high' :
                          preCalc.severity === 'ATENÇÃO' ? 'caution' : 'ok',
            action: preCalc.action,
            diff: preCalc.delta || 0,
            isCritical: preCalc.isCritical || preCalc.severity === 'CRÍTICA',
            isWithinRange: preCalc.severity === 'OK'
        };
    }
    
    // 🔄 FALLBACK: Calcular localmente usando targetProfile
    const metric = targetProfile[metricKey] || targetProfile.metrics?.[metricKey];
    if (!metric) {
        return { severity: 'N/A', severityClass: 'na', action: 'Métrica não encontrada', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // 🚨 REGRA ESPECIAL TRUE PEAK: valor > 0 dBTP = SEMPRE CRÍTICA
    // 🔧 FIX: Ação usa deltaToTarget (não hardCap) para consistência com coluna "Diferença"
    if (metricKey === 'truePeak') {
        const tpMax = metric.tp_max ?? metric.max ?? TRUE_PEAK_HARD_CAP;
        const tpTarget = metric.tp_target ?? metric.target ?? -1.0;  // ✅ SSOT: target do gênero
        
        if (value > tpMax) {
            const deltaToTarget = value - tpTarget;  // ✅ SSOT: sempre usa target do gênero
            return {
                severity: 'CRÍTICA',
                severityClass: 'critical',
                action: `🔴 CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dBTP`,
                diff: deltaToTarget,
                isCritical: true,
                isWithinRange: false
            };
        }
        
        // Verificar warn_from
        // 🔧 FIX: Ação usa deltaToTarget (não warnFrom) para consistência com coluna "Diferença"
        const warnFrom = metric.tp_warn_from ?? metric.warnFrom;
        if (warnFrom != null && value > warnFrom) {
            const deltaToTarget = value - tpTarget;  // ✅ SSOT: sempre usa target do gênero
            return {
                severity: 'ALTA',
                severityClass: 'high',
                action: `⚠️ Próximo do limite. Reduzir ${deltaToTarget.toFixed(2)} dBTP`,
                diff: deltaToTarget,
                isCritical: false,
                isWithinRange: false
            };
        }
        
        // Verificar se está abaixo do mínimo
        const tpMin = metric.tp_min ?? metric.min ?? -3;
        if (value < tpMin) {
            return {
                severity: 'ATENÇÃO',
                severityClass: 'caution',
                action: `ℹ️ Muito baixo. Pode aumentar até ${(tpMin - value).toFixed(1)} dBTP`,
                diff: value - tpMin,
                isCritical: false,
                isWithinRange: false
            };
        }
        
        // OK: Dentro do range
        return { severity: 'OK', severityClass: 'ok', action: '✅ Dentro do padrão', diff: 0, isCritical: false, isWithinRange: true };
    }
    
    // 🎯 OUTRAS MÉTRICAS: Lógica padrão de range [min, max]
    const min = metric.min;
    const max = metric.max;
    const target = metric.target;
    
    if (min == null || max == null) {
        return { severity: 'N/A', severityClass: 'na', action: 'Range não definido', diff: 0, isCritical: false, isWithinRange: false };
    }
    
    // OK: Dentro do range
    if (value >= min && value <= max) {
        return { severity: 'OK', severityClass: 'ok', action: '✅ Dentro do padrão', diff: 0, isCritical: false, isWithinRange: true };
    }
    
    // Fora do range: calcular distância
    const tolerance = (max - min) / 2;
    let diff, absDelta;
    
    if (value < min) {
        diff = value - min; // negativo
        absDelta = min - value;
    } else {
        diff = value - max; // positivo
        absDelta = value - max;
    }
    
    const actionVerb = diff > 0 ? 'Reduzir' : 'Aumentar';
    const unit = metricKey === 'lufs' ? 'LUFS' : metricKey === 'dr' ? 'dB' : '';
    
    if (absDelta <= tolerance) {
        return {
            severity: 'ATENÇÃO',
            severityClass: 'caution',
            action: `⚠️ ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: false,
            isWithinRange: false
        };
    } else if (absDelta <= tolerance * 2) {
        return {
            severity: 'ALTA',
            severityClass: 'high',
            action: `🟡 ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: false,
            isWithinRange: false
        };
    } else {
        return {
            severity: 'CRÍTICA',
            severityClass: 'critical',
            action: `🔴 ${actionVerb} ${absDelta.toFixed(1)} ${unit}`,
            diff,
            isCritical: true,
            isWithinRange: false
        };
    }
}

// Expor globalmente para uso em outros scripts
window.evaluateMetricFromTargetProfile = evaluateMetricFromTargetProfile;

/**
 * 🎯 getSeverityFromNormalized - Obtém severidade pré-calculada do backend
 * 
 * @param {Object} normalizedTargets - Targets normalizados do backend
 * @param {string} metricKey - Chave da métrica ('lufs', 'truePeak', 'dr', 'stereo')
 * @returns {Object|null} { severity, delta, action }
 */
function getSeverityFromNormalized(normalizedTargets, metricKey) {
    if (!normalizedTargets?.preCalculatedSeverities) {
        return null;
    }
    
    // 🎯 NOVA ESTRUTURA: preCalculatedSeverities.metrics.{metricKey}
    if (normalizedTargets.preCalculatedSeverities.metrics?.[metricKey]) {
        return normalizedTargets.preCalculatedSeverities.metrics[metricKey];
    }
    
    // 🔄 FALLBACK: Estrutura antiga (preCalculatedSeverities.{metricKey})
    return normalizedTargets.preCalculatedSeverities[metricKey] || null;
}

/**
 * 🎯 getBandSeverityFromNormalized - Obtém severidade pré-calculada de banda do backend
 * 
 * @param {Object} normalizedTargets - Targets normalizados do backend
 * @param {string} bandKey - Chave da banda ('sub', 'bass', 'lowMid', etc)
 * @returns {Object|null} { severity, delta, action }
 */
function getBandSeverityFromNormalized(normalizedTargets, bandKey) {
    if (!normalizedTargets?.preCalculatedSeverities?.bands) {
        return null;
    }
    return normalizedTargets.preCalculatedSeverities.bands[bandKey] || null;
}

/**
 * 🎯 calculateTruePeakSeverityLocal - Calcula severidade de True Peak localmente
 * 
 * REGRA OBRIGATÓRIA: truePeak > 0 dBTP = SEMPRE CRÍTICA
 * 
 * @param {number} value - Valor de True Peak em dBTP
 * @param {Object} targets - Targets (normalizados ou legados)
 * @returns {Object} { severity, severityClass, action, diff, isCritical }
 */
function calculateTruePeakSeverityLocal(value, targets) {
    if (!Number.isFinite(value)) {
        return { severity: 'N/A', severityClass: 'na', action: 'Sem dados', diff: 0 };
    }
    
    // ✅ SSOT: Extrair target do gênero PRIMEIRO
    let tpTarget = -1.0; // fallback padrão
    if (targets?.metrics?.truePeak?.target != null) {
        tpTarget = targets.metrics.truePeak.target;
    } else if (targets?.truePeak?.target != null) {
        tpTarget = targets.truePeak.target;
    } else if (targets?.true_peak_target != null) {
        tpTarget = targets.true_peak_target;
    }
    
    // 🚨 REGRA ABSOLUTA: True Peak > 0 dBTP = CRÍTICA
    // 🔧 FIX: Ação usa deltaToTarget (não hardCap) para consistência com coluna "Diferença"
    if (value > TRUE_PEAK_HARD_CAP) {
        const deltaToTarget = value - tpTarget;  // ✅ SSOT: sempre usa target do gênero
        return {
            severity: 'CRÍTICA',
            severityClass: 'critical',
            action: `🔴 CLIPPING! Reduzir ${deltaToTarget.toFixed(2)} dB`,
            diff: deltaToTarget,
            isCritical: true
        };
    }
    
    // Extrair bounds dos targets
    let min, max, warnFrom;
    
    // Tentar extrair do formato normalizado (backend)
    if (targets?.metrics?.truePeak) {
        const tp = targets.metrics.truePeak;
        min = tp.min;
        max = Math.min(tp.max, TRUE_PEAK_HARD_CAP); // Garantir hard cap
        warnFrom = tp.warnFrom;
    } 
    // Fallback: formato legado
    else if (targets?.truePeak) {
        min = targets.truePeak.min ?? (targets.truePeak.target - targets.truePeak.tolerance);
        max = Math.min(targets.truePeak.max ?? 0, TRUE_PEAK_HARD_CAP);
        warnFrom = targets.truePeak.warnFrom;
    }
    // Fallback: campos flat (true_peak_min, etc)
    else {
        const tpTarget = targets?.true_peak_target ?? -1.0;
        const tpTol = targets?.tol_true_peak ?? 0.5;
        min = targets?.true_peak_min ?? (tpTarget - tpTol);
        max = Math.min(targets?.true_peak_max ?? 0, TRUE_PEAK_HARD_CAP);
        warnFrom = targets?.true_peak_warn_from;
    }
    
    // ATENÇÃO: Na zona de warning
    // 🔧 FIX: Ação usa deltaToTarget (não warnFrom) para consistência com coluna "Diferença"
    if (warnFrom !== null && warnFrom !== undefined && value > warnFrom) {
        const deltaToTarget = value - tpTarget;  // ✅ SSOT: sempre usa target do gênero
        return {
            severity: 'ATENÇÃO',
            severityClass: 'caution',
            action: `⚠️ Próximo do limite. Reduzir ${deltaToTarget.toFixed(2)} dB`,
            diff: deltaToTarget
        };
    }
    
    // ATENÇÃO: Abaixo do mínimo
    if (min !== undefined && value < min) {
        const delta = min - value;
        return {
            severity: 'ATENÇÃO',
            severityClass: 'caution',
            action: `⚠️ Muito baixo. Pode aumentar até ${delta.toFixed(1)} dB`,
            diff: -delta
        };
    }
    
    // OK: Dentro do range ou aceitável
    return { severity: 'OK', severityClass: 'ok', action: '✅ Dentro do padrão', diff: 0 };
}

// Expor funções globalmente
if (typeof window !== 'undefined') {
    window.getNormalizedTargetsFromAnalysis = getNormalizedTargetsFromAnalysis;
    window.getSeverityFromNormalized = getSeverityFromNormalized;
    window.getBandSeverityFromNormalized = getBandSeverityFromNormalized;
    window.calculateTruePeakSeverityLocal = calculateTruePeakSeverityLocal;
    window.TRUE_PEAK_HARD_CAP = TRUE_PEAK_HARD_CAP;
}

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 SISTEMA DE BOUNDS MIN/MAX PARA MÉTRICAS (NOVO - SUPORTE A RANGE ASSIMÉTRICO)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * 🔧 getMetricBounds - Obtém os limites [min, max] de uma métrica
 * 
 * PRIORIDADE:
 * 1. Se existir ${metricKey}_min e ${metricKey}_max (ambos finitos) → usar eles
 * 2. Senão, usar ${metricKey}_target ± tol_${metricKey} (fallback legado)
 * 
 * @param {Object} refData - Dados de referência do gênero
 * @param {string} metricKey - Chave da métrica (ex: 'lufs', 'true_peak', 'dr')
 * @returns {Object} { min, max, target, mode: 'minmax' | 'tolerance', warnFrom?: number }
 */
function getMetricBounds(refData, metricKey) {
    if (!refData) {
        console.warn(`[METRIC-BOUNDS] refData é null/undefined para ${metricKey}`);
        return null;
    }
    
    // Construir nomes das propriedades
    const minKey = `${metricKey}_min`;
    const maxKey = `${metricKey}_max`;
    const targetKey = `${metricKey}_target`;
    const tolKey = `tol_${metricKey}`;
    const warnFromKey = `${metricKey}_warn_from`;
    
    const minValue = refData[minKey];
    const maxValue = refData[maxKey];
    const targetValue = refData[targetKey];
    const tolerance = refData[tolKey];
    const warnFrom = refData[warnFromKey];
    
    // PRIORIDADE 1: min/max explícitos
    if (Number.isFinite(minValue) && Number.isFinite(maxValue)) {
        const bounds = {
            min: minValue,
            max: maxValue,
            target: Number.isFinite(targetValue) ? targetValue : (minValue + maxValue) / 2,
            mode: 'minmax'
        };
        
        // Adicionar warn_from se existir (útil para True Peak)
        if (Number.isFinite(warnFrom)) {
            bounds.warnFrom = warnFrom;
        }
        
        console.log(`[METRIC-BOUNDS] ${metricKey}: usando min/max explícitos [${bounds.min}, ${bounds.max}]`, bounds);
        return bounds;
    }
    
    // PRIORIDADE 2: target ± tolerance (fallback legado)
    if (Number.isFinite(targetValue) && Number.isFinite(tolerance) && tolerance > 0) {
        const bounds = {
            min: targetValue - tolerance,
            max: targetValue + tolerance,
            target: targetValue,
            mode: 'tolerance'
        };
        
        console.log(`[METRIC-BOUNDS] ${metricKey}: usando target ± tolerance [${bounds.min}, ${bounds.max}]`, bounds);
        return bounds;
    }
    
    console.warn(`[METRIC-BOUNDS] ${metricKey}: nenhum bound válido encontrado`, {
        minKey, minValue,
        maxKey, maxValue,
        targetKey, targetValue,
        tolKey, tolerance
    });
    return null;
}

/**
 * 🎯 calculateMetricScoreWithBounds - Calcula score usando min/max (range assimétrico)
 * 
 * REGRAS:
 * - Valor dentro de [min, max] → 100 pontos
 * - Valor fora do range → penalização proporcional à distância
 * - Para True Peak: valor > max (0 dBTP) → score muito baixo (CRÍTICO)
 * 
 * @param {number} actualValue - Valor medido
 * @param {Object} bounds - { min, max, target, mode, warnFrom? }
 * @param {Object} options - { isCriticalAboveMax?: boolean, metricKey?: string }
 * @returns {Object} { score: number, status: 'OK'|'WARNING'|'CRITICAL', delta: number }
 */
function calculateMetricScoreWithBounds(actualValue, bounds, options = {}) {
    if (!Number.isFinite(actualValue) || !bounds) {
        return { score: null, status: 'UNKNOWN', delta: 0 };
    }
    
    const { min, max, target, warnFrom } = bounds;
    const { isCriticalAboveMax = false, metricKey = 'unknown' } = options;
    
    // Calcular delta em relação ao range
    let delta = 0;
    let status = 'OK';
    let score = 100;
    
    // Valor dentro do range → OK (100 pontos)
    if (actualValue >= min && actualValue <= max) {
        // Verificar se está na zona de warning (para True Peak)
        if (Number.isFinite(warnFrom) && actualValue >= warnFrom) {
            status = 'WARNING';
            // Pequena penalização para valores na zona de aviso
            const warnRange = max - warnFrom;
            const distFromWarn = actualValue - warnFrom;
            const warnPenalty = Math.min(15, (distFromWarn / warnRange) * 15);
            score = Math.round(100 - warnPenalty);
        } else {
            status = 'OK';
            score = 100;
        }
        
        console.log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} está dentro de [${min}, ${max}] → ${score}% (${status})`);
        return { score, status, delta: 0 };
    }
    
    // Valor ACIMA do máximo
    if (actualValue > max) {
        delta = actualValue - max;
        
        // True Peak acima de 0 dBTP é CRÍTICO
        if (isCriticalAboveMax || metricKey === 'true_peak') {
            status = 'CRITICAL';
            // Penalização severa para True Peak acima do limite
            const criticalPenalty = Math.min(80, delta * 40); // -40 pontos por dB acima
            score = Math.max(0, Math.round(100 - criticalPenalty));
            console.log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} ACIMA de max=${max} → CRÍTICO (${score}%)`);
        } else {
            // Penalização normal para outras métricas
            const rangeWidth = max - min;
            const tolerance = rangeWidth > 0 ? rangeWidth / 2 : 1;
            const ratio = delta / tolerance;
            
            if (ratio <= 1) {
                status = 'WARNING';
                score = Math.round(100 - (ratio * 20));
            } else if (ratio <= 2) {
                status = 'WARNING';
                score = Math.round(80 - ((ratio - 1) * 30));
            } else {
                status = 'CRITICAL';
                score = Math.max(20, Math.round(50 - ((ratio - 2) * 15)));
            }
            console.log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} acima de max=${max} (delta=${delta.toFixed(2)}) → ${score}% (${status})`);
        }
        
        return { score, status, delta };
    }
    
    // Valor ABAIXO do mínimo
    if (actualValue < min) {
        delta = min - actualValue;
        const rangeWidth = max - min;
        const tolerance = rangeWidth > 0 ? rangeWidth / 2 : 1;
        const ratio = delta / tolerance;
        
        if (ratio <= 1) {
            status = 'WARNING';
            score = Math.round(100 - (ratio * 20));
        } else if (ratio <= 2) {
            status = 'WARNING';
            score = Math.round(80 - ((ratio - 1) * 30));
        } else {
            status = 'CRITICAL';
            score = Math.max(20, Math.round(50 - ((ratio - 2) * 15)));
        }
        
        console.log(`[SCORE-BOUNDS] ${metricKey}: ${actualValue} abaixo de min=${min} (delta=${delta.toFixed(2)}) → ${score}% (${status})`);
        return { score, status, delta: -delta };
    }
    
    return { score, status, delta };
}

/**
 * 🎯 calculateMetricScoreAuto - Wrapper que escolhe automaticamente entre bounds e tolerance
 * 
 * @param {number} actualValue - Valor medido
 * @param {Object} refData - Dados de referência do gênero
 * @param {string} metricKey - Chave da métrica (ex: 'lufs', 'true_peak', 'dr')
 * @param {Object} options - Opções adicionais
 * @returns {number|null} Score (0-100) ou null se inválido
 */
function calculateMetricScoreAuto(actualValue, refData, metricKey, options = {}) {
    const bounds = getMetricBounds(refData, metricKey);
    
    if (bounds) {
        const result = calculateMetricScoreWithBounds(actualValue, bounds, { 
            ...options, 
            metricKey,
            isCriticalAboveMax: metricKey === 'true_peak'
        });
        return result.score;
    }
    
    // Fallback para cálculo antigo se não conseguir extrair bounds
    console.warn(`[SCORE-AUTO] ${metricKey}: usando fallback calculateMetricScore`);
    const targetKey = `${metricKey}_target`;
    const tolKey = `tol_${metricKey}`;
    return calculateMetricScore(actualValue, refData[targetKey], refData[tolKey]);
}

// Expor funções globalmente para uso em outros módulos
if (typeof window !== 'undefined') {
    window.getMetricBounds = getMetricBounds;
    window.calculateMetricScoreWithBounds = calculateMetricScoreWithBounds;
    window.calculateMetricScoreAuto = calculateMetricScoreAuto;
}

// ═══════════════════════════════════════════════════════════════════════════

// 2. FUNÇÃO PARA CALCULAR SCORE DE UMA MÉTRICA (VERSÃO MENOS PUNITIVA - LEGADO)
function calculateMetricScore(actualValue, targetValue, tolerance) {
    // Verificar se temos valores válidos
    if (!Number.isFinite(actualValue) || !Number.isFinite(targetValue) || !Number.isFinite(tolerance) || tolerance <= 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff: 'N/A (validação falhou)',
                tolerance,
                result: null,
                condition: 'validação falhou',
                reason: !Number.isFinite(actualValue) ? 'actualValue inválido' : 
                        !Number.isFinite(targetValue) ? 'targetValue inválido' : 
                        !Number.isFinite(tolerance) ? 'tolerance inválido' : 
                        'tolerance <= 0'
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (validação)', err);
        }
        return null; // Métrica inválida
    }
    
    const diff = Math.abs(actualValue - targetValue);
    
    // 🎯 DENTRO DA TOLERÂNCIA = 100 pontos
    if (diff <= tolerance) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateMetricScore',
                value: actualValue,
                target: targetValue,
                diff,
                tolerance,
                result: 100,
                condition: 'diff <= tolerance',
                ratio: diff / tolerance
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateMetricScore (dentro tolerância)', err);
        }
        return 100;
    }
    
    // 🎯 CURVA DE PENALIZAÇÃO MAIS JUSTA - GRADUAL E MENOS PUNITIVA
    // Δ até 1.5x tolerância → ~80
    // Δ até 2x tolerância → ~60  
    // Δ até 3x tolerância → ~40
    // Δ acima de 3x tolerância → ~20 (nunca zerar)
    
    const ratio = diff / tolerance;
    let result;
    
    if (ratio <= 1.5) {
        // Entre 1x e 1.5x tolerância: decaimento suave de 100 para 80
        result = Math.round(100 - ((ratio - 1) * 40)); // 100 - (0.5 * 40) = 80 no máximo
    } else if (ratio <= 2.0) {
        // Entre 1.5x e 2x tolerância: de 80 para 60
        result = Math.round(80 - ((ratio - 1.5) * 40)); // 80 - (0.5 * 40) = 60 no máximo
    } else if (ratio <= 3.0) {
        // Entre 2x e 3x tolerância: de 60 para 40
        result = Math.round(60 - ((ratio - 2) * 20)); // 60 - (1 * 20) = 40 no máximo
    } else {
        // Acima de 3x tolerância: 20 (nunca zerar totalmente)
        result = 20;
    }
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateMetricScore',
            value: actualValue,
            target: targetValue,
            diff,
            tolerance,
            result,
            condition: 'diff > tolerance',
            ratio,
            penaltyLevel: ratio <= 1.5 ? '1-1.5x' : ratio <= 2.0 ? '1.5-2x' : ratio <= 3.0 ? '2-3x' : '>3x'
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateMetricScore (penalização)', err);
    }
    
    return result;
}

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 V3.7 UNIFIED SCORING ENGINE - SINGLE SOURCE OF TRUTH
// ═══════════════════════════════════════════════════════════════════════════

/**
 * 🎯 TIPO DE MÉTRICA: Define como avaliar cada métrica
 * 
 * CEILING: truePeak, samplePeak, clipping
 *   - target = valor ideal (ex: -1.0 dBTP)
 *   - max = hard cap absoluto (ex: 0 dBTP)
 *   - Qualquer value > target é penalizado
 *   - value > max é CRÍTICO SEVERO
 * 
 * BANDPASS: lufs, dr, lra, crest, correlation, width, bandas
 *   - target = valor ideal no centro
 *   - score 100 apenas no target, decai conforme distância
 *   - range [min, max] define zona aceitável (score >= 85)
 */
const METRIC_TYPE = {
    truePeak: 'CEILING',
    samplePeak: 'CEILING',
    clipping: 'CEILING',
    dcOffset: 'CEILING',
    lufs: 'BANDPASS',
    rms: 'BANDPASS',
    dr: 'BANDPASS',
    lra: 'BANDPASS',
    crest: 'BANDPASS',
    correlation: 'BANDPASS',
    width: 'BANDPASS',
    // Bandas são BANDPASS
    sub: 'BANDPASS',
    bass: 'BANDPASS',
    lowMid: 'BANDPASS',
    mid: 'BANDPASS',
    highMid: 'BANDPASS',
    air: 'BANDPASS',
    presence: 'BANDPASS'
};

/**
 * 📊 FUNÇÃO CANÔNICA: evaluateMetric V3.7
 * 
 * Esta é a ÚNICA função que deve ser usada para avaliar métricas em:
 * - Tabela (buildMetricRows)
 * - Subscores
 * - Gates
 * - Sugestões
 * 
 * REGRAS V3.7:
 * 1. CEILING (truePeak, clipping): target é TETO. value > target = penalizado
 * 2. BANDPASS (lufs, dr, bandas): target é CENTRO. distância do target = penalizado
 * 3. Para CEILING: max é hard cap (ex: 0 dBTP), mas target (-1 dBTP) é o ideal
 * 4. Severidade baseada na distância do TARGET (não do range)
 * 
 * @param {string} metricKey - Chave da métrica (lufs, truePeak, sub, etc)
 * @param {number} measuredValue - Valor medido na análise
 * @param {Object} targetSpec - { target, min, max, tol, type? }
 * @returns {Object} { score, severity, diff, reason, deviationRatio, status }
 */
window.evaluateMetric = function evaluateMetric(metricKey, measuredValue, targetSpec) {
    // 🛡️ Guard: valores inválidos
    if (!Number.isFinite(measuredValue) || !targetSpec) {
        return { 
            score: null, 
            severity: 'N/A', 
            diff: 0, 
            reason: 'Dados insuficientes',
            deviationRatio: 0,
            status: 'N/A'
        };
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 🎯 STREAMING MODE — VALIDAÇÃO TÉCNICA RÍGIDA (v2026-01-19 STRICT)
    // ═══════════════════════════════════════════════════════════════════
    // Verifica se está em MODO STREAMING (não soundDestination)
    // Se sim, usa validação técnica RÍGIDA (não progressiva)
    // Aplicação: SOMENTE analysis.mode === 'streaming'
    // Não afeta: genre, pista, club, mastering
    
    const currentAnalysis = window.latestAnalysisData || window.currentAnalysis || {};
    const analysisMode = currentAnalysis.mode || 
                        (currentAnalysis.data && currentAnalysis.data.mode);
    
    // ⚠️ IMPORTANTE: usar analysis.mode, NÃO soundDestination
    // soundDestination é metadado, mode é tipo de análise
    if (analysisMode === 'streaming') {
        // LUFS em modo streaming → usar validação técnica RÍGIDA
        if (metricKey === 'lufs' && window.calculateStreamingLufsScoreStrict) {
            const streamingResult = window.calculateStreamingLufsScoreStrict(measuredValue);
            // Converter para formato compatível com evaluateMetric
            return {
                score: streamingResult.score,
                severity: streamingResult.severity,
                diff: streamingResult.measuredLufs - streamingResult.targetLufs,
                reason: streamingResult.reason,
                deviationRatio: Math.abs(streamingResult.measuredLufs - streamingResult.targetLufs) / 1.0, // 1.0 LU = tolerância streaming RÍGIDA
                status: streamingResult.severity,
                metricKey: 'lufs',
                measuredValue: streamingResult.measuredLufs,
                metricType: 'BANDPASS_STREAMING_STRICT',
                targetSpec: { target: -14.0, min: -15.0, max: -13.0, tol: 1.0 },
                streamingZone: streamingResult.zone,
                conformance: streamingResult.conformance
            };
        }
        
        // True Peak em modo streaming → usar validação técnica RÍGIDA
        if (metricKey === 'truePeak' && window.calculateStreamingTruePeakScoreStrict) {
            const streamingResult = window.calculateStreamingTruePeakScoreStrict(measuredValue);
            // Converter para formato compatível com evaluateMetric
            return {
                score: streamingResult.score,
                severity: streamingResult.severity,
                diff: streamingResult.measuredTp - streamingResult.targetTp,
                reason: streamingResult.reason,
                deviationRatio: Math.abs(streamingResult.measuredTp - streamingResult.targetTp) / 1.0, // 1.0 dB = tolerância streaming RÍGIDA
                status: streamingResult.severity,
                metricKey: 'truePeak',
                measuredValue: streamingResult.measuredTp,
                metricType: 'CEILING_STREAMING_STRICT',
                targetSpec: { target: -1.0, max: 0.0, tol: 1.0 },
                streamingZone: streamingResult.zone,
                conformance: streamingResult.conformance
            };
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 🎯 LÓGICA GENÉRICA (para outros modos e métricas)
    // ═══════════════════════════════════════════════════════════════════
    
    // Normalizar targetSpec
    const target = targetSpec.target ?? targetSpec.target_db ?? null;
    const min = targetSpec.min ?? targetSpec.min_db ?? targetSpec.target_range?.min ?? null;
    const max = targetSpec.max ?? targetSpec.max_db ?? targetSpec.target_range?.max ?? null;
    const tol = targetSpec.tol ?? targetSpec.tol_db ?? targetSpec.tolerance ?? 1.0;
    
    // Determinar tipo da métrica
    const metricType = targetSpec.type || METRIC_TYPE[metricKey] || 'BANDPASS';
    
    let diff = 0;
    let deviationRatio = 0;
    let score = 100;
    let severity = 'OK';
    let reason = '✅ Dentro do padrão';
    
    // ═══════════════════════════════════════════════════════════════════
    // CEILING METRICS (truePeak, samplePeak, clipping)
    // ═══════════════════════════════════════════════════════════════════
    if (metricType === 'CEILING') {
        // Para CEILING: target é o TETO IDEAL, max é HARD CAP
        const effectiveTarget = target ?? max ?? 0;
        const hardCap = max ?? 0;
        
        // Calcular diferença do TARGET (não do hard cap)
        diff = measuredValue - effectiveTarget;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 🎯 CORREÇÃO V2026-01-19: JANELA BILATERAL PARA TRUE PEAK
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // PROBLEMA ANTERIOR: valores abaixo do target recebiam score 100
        // CORREÇÃO: definir janela aceitável bilateral
        //
        // Para True Peak (target -1.0 dBTP):
        // • ZONA IDEAL: [-2.0, -0.8] → score alto (85-100)
        // • ACIMA (clipping): > -0.8 → penalizar progressivamente
        // • ABAIXO (conservador): < -2.0 → penalizar progressivamente
        //
        // Exemplos corrigidos:
        // - TP -1.0 → score 100 ✅
        // - TP -1.8 → score 90 ✅
        // - TP -2.2 → score 75 ✅ (antes era 100 ❌)
        // - TP -3.4 → score 45 ✅ (antes era 100 ❌)
        // - TP -5.0 → score 25 ✅ (antes era 100 ❌)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // Definir janela aceitável (zona ideal)
        const idealMin = effectiveTarget - 1.0; // Ex: -1.0 - 1.0 = -2.0 dBTP
        const idealMax = effectiveTarget + 0.2; // Ex: -1.0 + 0.2 = -0.8 dBTP
        
        // CASO 1: Valor na ZONA IDEAL [idealMin, idealMax]
        if (measuredValue >= idealMin && measuredValue <= idealMax) {
            // Score alto proporcional à distância do target
            const distFromTarget = Math.abs(measuredValue - effectiveTarget);
            const zoneSize = 1.2; // idealMax - idealMin = 1.2 dB
            const normalizedDist = distFromTarget / zoneSize;
            
            score = Math.round(100 - (normalizedDist * 15)); // 100 → 85
            score = Math.max(85, Math.min(100, score));
            severity = 'OK';
            reason = '✅ Dentro do padrão';
            deviationRatio = normalizedDist;
            
        // CASO 2: Valor ACIMA da zona ideal (clipping / próximo ao limite)
        } else if (measuredValue > idealMax) {
            // Penalizar progressivamente até o hardCap
            const excessAboveIdeal = measuredValue - idealMax;
            
            if (measuredValue > hardCap) {
                // Acima do hard cap = CRÍTICO SEVERO
                const excessFromCap = measuredValue - hardCap;
                deviationRatio = (excessFromCap / tol) + 3; // Força ratio > 3
                score = Math.max(20, 35 - (excessFromCap * 15));
                severity = 'CRÍTICA';
                reason = `🔴 Reduzir ${diff.toFixed(2)} (ACIMA DO LIMITE!)`;
            } else if (excessAboveIdeal <= 0.3) {
                // Ligeiramente acima da zona ideal (até +0.3 dB)
                score = Math.round(85 - (excessAboveIdeal * 50)); // 85 → 70
                severity = 'ATENÇÃO';
                reason = `⚠️ Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            } else if (excessAboveIdeal <= 0.8) {
                // Moderadamente acima (0.3 a 0.8 dB)
                score = Math.round(70 - ((excessAboveIdeal - 0.3) * 40)); // 70 → 50
                severity = 'ALTA';
                reason = `🟡 Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            } else {
                // Muito acima (> 0.8 dB da zona ideal)
                score = Math.round(50 - ((excessAboveIdeal - 0.8) * 30)); // 50 → 20
                severity = 'CRÍTICA';
                reason = `🔴 Reduzir ${diff.toFixed(2)}`;
                deviationRatio = excessAboveIdeal / tol;
            }
            
        // CASO 3: Valor ABAIXO da zona ideal (headroom excessivo)
        } else { // measuredValue < idealMin
            // 🚨 CORREÇÃO CRÍTICA: penalizar conservadorismo excessivo
            const excessBelowIdeal = idealMin - measuredValue; // Ex: -2.0 - (-3.4) = 1.4 dB
            
            if (excessBelowIdeal <= 0.3) {
                // Ligeiramente abaixo (até -0.3 dB)
                score = Math.round(85 - (excessBelowIdeal * 40)); // 85 → 73
                severity = 'ATENÇÃO';
                reason = `⚠️ Master conservadora. Considere aumentar ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            } else if (excessBelowIdeal <= 1.0) {
                // Moderadamente abaixo (-0.3 a -1.0 dB)
                score = Math.round(73 - ((excessBelowIdeal - 0.3) * 30)); // 73 → 52
                severity = 'ALTA';
                reason = `🟡 Headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB. Aumentar`;
                deviationRatio = excessBelowIdeal / tol;
            } else if (excessBelowIdeal <= 2.0) {
                // Muito abaixo (-1.0 a -2.0 dB)
                score = Math.round(52 - ((excessBelowIdeal - 1.0) * 20)); // 52 → 32
                severity = 'CRÍTICA';
                reason = `🔴 ERRO TÉCNICO: headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            } else {
                // Extremamente abaixo (> -2.0 dB)
                score = Math.max(20, Math.round(32 - ((excessBelowIdeal - 2.0) * 8))); // 32 → 20
                severity = 'CRÍTICA';
                reason = `🔴 ERRO TÉCNICO SEVERO: headroom excessivo de ${excessBelowIdeal.toFixed(1)} dB`;
                deviationRatio = excessBelowIdeal / tol;
            }
        }
        
        return {
            score: Math.round(Math.max(20, Math.min(100, score))),
            severity,
            diff,
            reason,
            deviationRatio: Math.round(deviationRatio * 100) / 100,
            status: severity,
            metricKey,
            measuredValue,
            metricType,
            targetSpec: { target: effectiveTarget, max: hardCap, tol }
        };
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // BANDPASS METRICS (lufs, dr, lra, bandas, etc)
    // Score 100 no target, decai conforme distância
    // ═══════════════════════════════════════════════════════════════════
    
    // Determinar target efetivo
    const effectiveTarget = target ?? (min !== null && max !== null ? (min + max) / 2 : null);
    
    if (effectiveTarget === null) {
        return { 
            score: null, 
            severity: 'N/A', 
            diff: 0, 
            reason: 'Sem referência',
            deviationRatio: 0,
            status: 'N/A'
        };
    }
    
    // Calcular diferença do target
    diff = measuredValue - effectiveTarget;
    const absDiff = Math.abs(diff);
    
    // Verificar se está dentro do range [min, max]
    const hasRange = min !== null && max !== null;
    const inRange = hasRange && measuredValue >= min && measuredValue <= max;
    
    // ═══════════════════════════════════════════════════════════════════
    // V4.0: CURVA DE PENALIZAÇÃO BANDPASS REVISADA
    // - Score 100 APENAS se valor == target (não mais 50% tolerância)
    // - Considera range [min, max] como fator de severidade
    // - Severidade alinhada com tabela visual
    // ═══════════════════════════════════════════════════════════════════
    
    // Calcular distância normalizada pelo range (se disponível)
    let rangeSize = tol * 2; // Default: 2x tolerância = range total
    if (hasRange) {
        rangeSize = max - min;
    }
    
    // Distância normalizada: 0 = no target, 1 = na borda do range, >1 = fora do range
    const normalizedDistance = rangeSize > 0 ? absDiff / (rangeSize / 2) : (absDiff / tol);
    
    // Fora do range = SEMPRE CRÍTICA
    if (hasRange && !inRange) {
        // Calcular quanto fora do range
        const distanceFromRange = measuredValue < min ? (min - measuredValue) : (measuredValue - max);
        const rangeExcess = distanceFromRange / tol;
        
        if (rangeExcess >= 1.5) {
            // Muito fora do range = CRÍTICA severa
            score = Math.max(20, Math.round(40 - (rangeExcess * 8)));
            severity = 'CRÍTICA';
        } else if (rangeExcess >= 0.5) {
            // Moderadamente fora = CRÍTICA
            score = Math.round(55 - (rangeExcess * 15));
            severity = 'CRÍTICA';
        } else {
            // Ligeiramente fora = ALTA
            score = Math.round(70 - (rangeExcess * 20));
            severity = 'ALTA';
        }
        
        
        // 🎯 CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            const realisticAction = buildRealisticAction(absDiff, direction, '🔴');
            reason = realisticAction + ' (fora do range)';
        } else {
            reason = diff > 0 
                ? `🔴 Reduzir ${absDiff.toFixed(1)} (fora do range)` 
                : `🔴 Aumentar ${absDiff.toFixed(1)} (fora do range)`;
        }
            
        return {
            score: Math.round(Math.max(20, Math.min(100, score))),
            severity,
            diff,
            reason,
            deviationRatio: Math.round(normalizedDistance * 100) / 100,
            status: severity,
            metricKey,
            measuredValue,
            metricType,
            targetSpec: { target: effectiveTarget, min, max, tol },
            value: measuredValue,
            target: effectiveTarget
        };
    }
    
    // Dentro do range - calcular score baseado na distância do target
    // V4.0: Curva mais rigorosa que a anterior
    
    if (normalizedDistance <= 0.15) {
        // Muito próximo do target (≤15% do range) = OK perfeito
        score = 100;
        severity = 'OK';
        reason = '✅ Dentro do padrão';
    } else if (normalizedDistance <= 0.4) {
        // Próximo do target (15-40% do range) = OK com pequena ressalva
        score = Math.round(100 - (normalizedDistance - 0.15) * 20); // 100 → 95
        severity = 'OK';
        reason = '✅ Dentro do padrão';
    } else if (normalizedDistance <= 0.7) {
        // Moderado (40-70% do range) = ATENÇÃO
        score = Math.round(95 - ((normalizedDistance - 0.4) * 40)); // 95 → 83
        severity = 'ATENÇÃO';
        // 🎯 CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, '⚠️');
        } else {
            reason = diff > 0 
                ? `⚠️ Reduzir ${absDiff.toFixed(1)}` 
                : `⚠️ Aumentar ${absDiff.toFixed(1)}`;
        }
    } else if (normalizedDistance <= 1.0) {
        // Perto da borda (70-100% do range) = ALTA
        score = Math.round(83 - ((normalizedDistance - 0.7) * 43)); // 83 → 70
        severity = 'ALTA';
        // 🎯 CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, '🟡');
        } else {
            reason = diff > 0 
                ? `🟡 Reduzir ${absDiff.toFixed(1)}` 
                : `🟡 Aumentar ${absDiff.toFixed(1)}`;
        }
    } else {
        // Na borda ou ligeiramente fora = CRÍTICA (mas ainda "dentro" por arredondamento)
        score = Math.max(55, Math.round(70 - ((normalizedDistance - 1) * 25)));
        severity = 'CRÍTICA';
        // 🎯 CONTROLE DE REALISMO: Aplicar APENAS para bandas espectrais
        if (isSpectralBand(metricKey)) {
            const direction = diff > 0 ? 'decrease' : 'increase';
            reason = buildRealisticAction(absDiff, direction, '🔴');
        } else {
            reason = diff > 0 
                ? `🔴 Reduzir ${absDiff.toFixed(1)}` 
                : `🔴 Aumentar ${absDiff.toFixed(1)}`;
        }
    }
    
    return {
        score: Math.round(Math.max(20, Math.min(100, score))),
        severity,
        diff,
        reason,
        deviationRatio: Math.round(normalizedDistance * 100) / 100,
        status: severity,
        metricKey,
        measuredValue,
        metricType,
        targetSpec: { target: effectiveTarget, min, max, tol },
        value: measuredValue,
        target: effectiveTarget
    };
};

// Alias global
window.SOUNDY_evaluateMetric = window.evaluateMetric;

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 STREAMING SCORING — VALIDAÇÃO TÉCNICA RÍGIDA (v2026-01-19 STRICT)
// ═══════════════════════════════════════════════════════════════════════════
//
// ⚠️ ERRO CONCEITUAL CORRIGIDO:
// - Streaming NÃO é "otimização progressiva"
// - Streaming É "conformidade técnica"
// - Tolerância: ±1.0 dB (não ±1.5 ou ±2.0)
// - Fora da tolerância = score BAIXO (não progressivo)
//
// APLICAÇÃO:
// - SOMENTE quando analysis.mode === 'streaming'
// - NÃO afeta genre, pista, club, mastering
//
// PADRÕES TÉCNICOS:
// - Spotify: -14 LUFS ± 1 dB, True Peak < -1 dBTP
// - Apple Music: -16 LUFS, True Peak < -1 dBTP (mas aceita -14 ±1)
// - YouTube: -14 LUFS ± 1 dB, True Peak < -1 dBTP
// ═══════════════════════════════════════════════════════════════════════════

/**
 * 🎧 calculateStreamingLufsScoreStrict — Validação técnica RÍGIDA para LUFS em streaming
 * 
 * REGRAS TÉCNICAS (não progressivas):
 * - Target fixo: -14.0 LUFS
 * - Tolerância máxima: ±1.0 dB
 * 
 * ZONA VERDE [-15.0, -13.0]:
 *   → Score: 90-100
 *   → Status: CONFORME PADRÃO STREAMING
 * 
 * ZONA AMARELA [-16.0, -15.0] ou [-13.0, -12.0]:
 *   → Score: 60-80
 *   → Status: FORA DO PADRÃO (margem de segurança)
 * 
 * ZONA VERMELHA < -16.0 ou > -12.0:
 *   → Score: ≤40
 *   → Status: FORA DO PADRÃO STREAMING
 * 
 * @param {number} lufs - LUFS Integrado medido
 * @returns {{score: number, severity: string, reason: string, zone: string, conformance: string}}
 */
window.calculateStreamingLufsScoreStrict = function(lufs) {
    if (!Number.isFinite(lufs)) {
        return { 
            score: null, 
            severity: 'N/A', 
            reason: 'Valor inválido', 
            zone: 'unknown',
            conformance: 'N/A'
        };
    }
    
    const TARGET = -14.0;
    let score, severity, reason, zone, conformance;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA VERDE: -15.0 a -13.0 LUFS (±1.0 dB do target)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if (lufs >= -15.0 && lufs <= -13.0) {
        zone = 'VERDE';
        conformance = 'CONFORME';
        
        // Score alto dentro da zona verde (90-100)
        const distFromTarget = Math.abs(lufs - TARGET);
        score = Math.round(100 - (distFromTarget * 10)); // -14.0 = 100, -15.0 ou -13.0 = 90
        score = Math.max(90, Math.min(100, score));
        
        severity = 'OK';
        
        if (score >= 98) {
            reason = '✅ Conformidade total para streaming';
        } else {
            reason = `✅ Dentro do padrão streaming (${distFromTarget.toFixed(1)} LU do ideal)`;
        }
        
        return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA AMARELA: [-16.0, -15.0) ou (-13.0, -12.0]
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if ((lufs >= -16.0 && lufs < -15.0) || (lufs > -13.0 && lufs <= -12.0)) {
        zone = 'AMARELA';
        conformance = 'FORA DO PADRÃO';
        
        // Score médio/baixo (60-80)
        const distFromEdge = lufs > -13.0 
            ? Math.abs(lufs - (-13.0))  // Distância da borda superior
            : Math.abs(lufs - (-15.0)); // Distância da borda inferior
        
        score = Math.round(80 - (distFromEdge * 20)); // 80 → 60
        score = Math.max(60, Math.min(80, score));
        
        severity = 'ALTA';
        
        if (lufs > -13.0) {
            reason = `🟡 FORA DO PADRÃO STREAMING (${(lufs - TARGET).toFixed(1)} LU acima). Reduzir urgentemente`;
        } else {
            reason = `🟡 FORA DO PADRÃO STREAMING (${Math.abs(lufs - TARGET).toFixed(1)} LU abaixo). Aumentar urgentemente`;
        }
        
        return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA VERMELHA: < -16.0 ou > -12.0
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    zone = 'VERMELHA';
    conformance = 'NÃO CONFORME';
    
    const distFromLimit = lufs > -12.0 
        ? Math.abs(lufs - (-12.0))
        : Math.abs(lufs - (-16.0));
    
    // Score baixo (≤40)
    score = Math.max(20, Math.round(40 - (distFromLimit * 10)));
    severity = 'CRÍTICA';
    
    if (lufs > -12.0) {
        reason = `🔴 NÃO CONFORME STREAMING (${(lufs - TARGET).toFixed(1)} LU acima). CORRIGIR`;
    } else {
        reason = `🔴 NÃO CONFORME STREAMING (${Math.abs(lufs - TARGET).toFixed(1)} LU abaixo). CORRIGIR`;
    }
    
    return { score, severity, reason, zone, conformance, measuredLufs: lufs, targetLufs: TARGET };
};

/**
 * 🔊 calculateStreamingTruePeakScoreStrict — Validação técnica RÍGIDA para True Peak em streaming
 * 
 * REGRAS TÉCNICAS (não progressivas):
 * - Target fixo: -1.0 dBTP
 * - Tolerância máxima: ±1.0 dB
 * 
 * ZONA VERDE [-2.0, 0.0]:
 *   → Score: 85-100
 *   → Status: CONFORME PADRÃO STREAMING
 * 
 * ZONA AMARELA [-3.0, -2.0) ou (0.0, +1.0]:
 *   → Score: 60-80
 *   → Status: FORA DO PADRÃO (margem)
 * 
 * ZONA VERMELHA < -3.0 ou > +1.0:
 *   → Score: ≤40
 *   → Status: NÃO CONFORME (erro técnico)
 * 
 * INTERPRETAÇÃO:
 * - TP muito baixo (< -3.0) = master conservadora demais (erro técnico)
 * - TP alto (> 0.0) = risco de clipping
 * - Ambos penalizam score técnico
 * 
 * @param {number} tp - True Peak em dBTP
 * @returns {{score: number, severity: string, reason: string, zone: string, conformance: string}}
 */
window.calculateStreamingTruePeakScoreStrict = function(tp) {
    if (!Number.isFinite(tp)) {
        return { 
            score: null, 
            severity: 'N/A', 
            reason: 'Valor inválido', 
            zone: 'unknown',
            conformance: 'N/A'
        };
    }
    
    const TARGET = -1.0;
    let score, severity, reason, zone, conformance;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // CLIPPING SEVERO: > +1.0 dBTP
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if (tp > 1.0) {
        zone = 'VERMELHA';
        conformance = 'CLIPPING SEVERO';
        score = Math.max(20, Math.round(30 - (tp * 10)));
        severity = 'CRÍTICA';
        reason = `🔴 CLIPPING SEVERO! Reduzir ${(tp - TARGET).toFixed(2)} dB URGENTEMENTE`;
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA VERDE: -2.0 a -0.8 dBTP (zona ideal rigorosa)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if (tp >= -2.0 && tp <= -0.8) {
        zone = 'VERDE';
        conformance = 'CONFORME';
        
        // Score alto dentro da zona verde (90-100)
        const distFromTarget = Math.abs(tp - TARGET);
        score = Math.round(100 - (distFromTarget * 10)); // -1.0 = 100, -2.0 = 90, -0.8 = 98
        score = Math.max(90, Math.min(100, score));
        
        severity = 'OK';
        if (score >= 98) {
            reason = '✅ True Peak ideal para streaming';
        } else {
            reason = `✅ Dentro do padrão streaming (${distFromTarget.toFixed(2)} dB do ideal)`;
        }
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA AMARELA: [-3.0, -2.0) ou (-0.8, +1.0]
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    if ((tp >= -3.0 && tp < -2.0) || (tp > -0.8 && tp <= 1.0)) {
        zone = 'AMARELA';
        conformance = 'FORA DO PADRÃO';
        
        // Score médio/baixo (60-85)
        let score;
        
        if (tp > -0.8) {
            // Acima da zona verde (clipping)
            const distFromEdge = Math.abs(tp - (-0.8));
            score = Math.round(85 - (distFromEdge * 15)); // 85 → 60
        } else {
            // Abaixo da zona verde (conservador)
            const distFromEdge = Math.abs(tp - (-2.0));
            score = Math.round(85 - (distFromEdge * 20)); // 85 → 65
        }
        
        score = Math.max(60, Math.min(85, score));
        severity = 'ALTA';
        
        if (tp > -0.8) {
            reason = `🟡 FORA DO PADRÃO (próximo ao clipping). Reduzir ${(tp - TARGET).toFixed(1)} dB`;
        } else {
            reason = `🟡 FORA DO PADRÃO (headroom excessivo). Aumentar ${Math.abs(tp - TARGET).toFixed(1)} dB`;
        }
        
        return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ZONA VERMELHA: < -3.0 dBTP (erro técnico - conservador demais)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    zone = 'VERMELHA';
    conformance = 'ERRO TÉCNICO';
    
    const distFromLimit = Math.abs(tp - (-3.0));
    
    // Score baixo (≤40)
    score = Math.max(20, Math.round(40 - (distFromLimit * 10)));
    severity = 'CRÍTICA';
    reason = `🔴 ERRO TÉCNICO (headroom excessivo de ${Math.abs(tp - TARGET).toFixed(1)} dB). CORRIGIR`;
    
    return { score, severity, reason, zone, conformance, measuredTp: tp, targetTp: TARGET };
};

/**
 * 🎯 Helper: Converte resultado de evaluateMetric para formato da tabela
 * Usado pelo buildMetricRows para garantir Single Source of Truth
 */
window.evaluateMetricForTable = function(metricKey, measuredValue, targetSpec) {
    const result = window.evaluateMetric(metricKey, measuredValue, targetSpec);
    
    // Mapear severity para severityClass (formato da tabela)
    const SEVERITY_CLASS_MAP = {
        'OK': 'ok',
        'ATENÇÃO': 'caution',
        'ALTA': 'warning',
        'CRÍTICA': 'critical',
        'N/A': 'na'
    };
    
    return {
        severity: result.severity,
        severityClass: SEVERITY_CLASS_MAP[result.severity] || 'na',
        action: result.reason,
        diff: result.diff,
        score: result.score,
        deviationRatio: result.deviationRatio
    };
};

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 V3.7 METRIC → SUBSCORE MAPPING
// ═══════════════════════════════════════════════════════════════════════════
const METRIC_TO_SUBSCORE_V37 = {
    // LOUDNESS
    lufs: 'loudness',
    rms: 'loudness',
    lufsIntegrated: 'loudness',
    
    // TECHNICAL
    truePeak: 'technical',
    samplePeak: 'technical',
    clipping: 'technical',
    dcOffset: 'technical',
    
    // DYNAMICS
    dr: 'dynamics',
    dynamicRange: 'dynamics',
    crest: 'dynamics',
    crestFactor: 'dynamics',
    lra: 'dynamics',
    
    // STEREO
    correlation: 'stereo',
    stereoCorrelation: 'stereo',
    width: 'stereo',
    stereoWidth: 'stereo',
    
    // FREQUENCY (bandas)
    sub: 'frequency',
    bass: 'frequency',
    lowMid: 'frequency',
    mid: 'frequency',
    highMid: 'frequency',
    air: 'frequency',
    presence: 'frequency'
};

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 V3.6 GATES CONFIG - Aplicados aos SUBSCORES
// ═══════════════════════════════════════════════════════════════════════════
const SUBSCORE_GATES = {
    technical: {
        // Gate: True Peak > limit → cap subscore técnico
        truePeak: {
            condition: (value, limit) => value > limit,
            calcCap: (value, limit) => {
                const excess = value - limit;
                // Cap proporcional: 1dB acima = cap 75%, 2dB = cap 55%, etc
                return Math.max(35, 95 - (excess * 20));
            },
            severity: (value, limit) => {
                const excess = value - limit;
                return excess > 1.0 ? 'CRÍTICA' : excess > 0.5 ? 'ALTA' : 'MODERADA';
            }
        },
        // Gate: Clipping > 0.5% → cap subscore técnico
        clipping: {
            condition: (value) => value > 0.5,
            calcCap: (value) => {
                return Math.max(30, 80 - (value - 0.5) * 10);
            },
            severity: (value) => value > 5 ? 'CRÍTICA' : value > 2 ? 'ALTA' : 'MODERADA'
        }
    },
    loudness: {
        // Gate: LUFS muito acima do max → cap subscore loudness
        lufs: {
            condition: (value, limit) => value > limit,
            calcCap: (value, limit) => {
                const excess = value - limit;
                return Math.max(50, 95 - (excess * 7.5));
            },
            severity: (value, limit) => {
                const excess = value - limit;
                return excess > 4 ? 'CRÍTICA' : excess > 2 ? 'ALTA' : 'MODERADA';
            }
        }
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// 🎯 V3.6 MAIN SCORING FUNCTION
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Módulo unificado para cálculo de scores V3.6.
 * 
 * PRINCÍPIOS:
 * 1. TODAS as métricas passam por evaluateMetric (SINGLE SOURCE OF TRUTH)
 * 2. Subscores = média dos metricScores do grupo
 * 3. Gates aplicados aos SUBSCORES (não ao final)
 * 4. Score final = média ponderada dos subscores (já com gates aplicados)
 * 
 * @param {Object} analysis - Objeto de análise completo (technicalData, metrics, etc)
 * @param {Object} targets - Targets do modo (streaming/pista/reference)
 * @param {string} mode - 'streaming', 'pista', ou 'reference'
 * @returns {Object} { raw, final, subscores, subScoresRaw, gatesTriggered, metricEvaluations, debug }
 */
window.computeScoreV3 = function computeScoreV3(analysis, targets, mode = 'streaming') {
    const DEBUG = true;
    
    if (DEBUG) {
        console.group('🎯 [computeScoreV3.6] SINGLE SOURCE OF TRUTH');
        console.log('📊 mode:', mode);
        console.log('📊 targets keys:', targets ? Object.keys(targets) : 'null');
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 1. EXTRAIR VALORES MEDIDOS
    // ═══════════════════════════════════════════════════════════════════
    const tech = analysis?.technicalData || analysis?.metrics || {};
    const measured = {
        // Loudness
        lufs: tech.lufsIntegrated ?? tech.lufs_integrated ?? null,
        rms: tech.rms ?? tech.rms_db ?? null,
        
        // Technical
        truePeak: tech.truePeakDbtp ?? tech.true_peak_dbtp ?? null,
        samplePeak: tech.samplePeak ?? tech.sample_peak ?? tech.peak_dbfs ?? null,
        clipping: (tech.clippingPct ?? tech.clipping_pct ?? tech.clipping ?? 0) * 100,
        dcOffset: Math.abs(tech.dcOffset ?? tech.dc_offset ?? 0) * 100,
        
        // Dynamics
        dr: tech.dynamicRange ?? tech.dynamic_range ?? null,
        crest: tech.crestFactor ?? tech.crest_factor ?? null,
        lra: tech.lra ?? null,
        
        // Stereo
        correlation: tech.stereoCorrelation ?? tech.stereo_correlation ?? null,
        width: tech.stereoWidth ?? tech.stereo_width ?? null,
        
        // Frequency bands
        bands: tech.bands ?? tech.spectral_balance ?? {}
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // 2. DEFINIR TARGETS (MODE + PASSADOS)
    // ═══════════════════════════════════════════════════════════════════
    const MODE_TARGETS = {
        streaming: {
            lufs: { target: -14, min: -16, max: -12, tol: 1.0 },
            truePeak: { target: -1.0, min: -3.0, max: -1.0, tol: 0.25 },
            rms: { target: -18, min: -24, max: -12, tol: 2.0 },
            dr: { target: 8, min: 6, max: 12, tol: 1.5 },
            lra: { target: 7, min: 5, max: 10, tol: 2.0 },
            crest: { target: 12, min: 8, max: 16, tol: 2.0 },
            correlation: { target: 0.9, min: 0.5, max: 1.0, tol: 0.1 },
            width: { target: 0.7, min: 0.3, max: 1.0, tol: 0.15 },
            clipping: { target: 0, min: 0, max: 0.1, tol: 0.05 },
            dcOffset: { target: 0, min: 0, max: 1.0, tol: 0.5 },
            samplePeak: { target: -1.0, min: -6.0, max: 0.0, tol: 0.5 }
        },
        pista: {
            lufs: { target: -9, min: -12, max: -6, tol: 1.5 },
            truePeak: { target: -0.3, min: -1.5, max: 0.0, tol: 0.3 },
            rms: { target: -14, min: -20, max: -8, tol: 2.0 },
            dr: { target: 6, min: 4, max: 10, tol: 1.5 },
            lra: { target: 5, min: 3, max: 8, tol: 2.0 },
            crest: { target: 10, min: 6, max: 14, tol: 2.0 },
            correlation: { target: 0.85, min: 0.4, max: 1.0, tol: 0.15 },
            width: { target: 0.8, min: 0.4, max: 1.0, tol: 0.15 },
            clipping: { target: 0, min: 0, max: 0.5, tol: 0.2 },
            dcOffset: { target: 0, min: 0, max: 2.0, tol: 1.0 },
            samplePeak: { target: -0.5, min: -4.0, max: 0.0, tol: 0.5 }
        }
    };
    
    const modeTargets = MODE_TARGETS[mode] || MODE_TARGETS.streaming;
    const finalTargets = { ...modeTargets };
    
    // Sobrescrever com targets passados (prioridade para dados do gênero/referência)
    if (targets) {
        // LUFS
        if (targets.lufs_target !== undefined) {
            finalTargets.lufs = {
                target: targets.lufs_target,
                min: targets.lufs_min ?? (targets.lufs_target - (targets.tol_lufs || 1.0)),
                max: targets.lufs_max ?? (targets.lufs_target + (targets.tol_lufs || 1.0)),
                tol: targets.tol_lufs || 1.0
            };
        }
        
        // True Peak - CEILING metric
        if (targets.true_peak_target !== undefined) {
            finalTargets.truePeak = {
                target: targets.true_peak_target, // ESTE é o valor ideal
                min: targets.true_peak_min ?? -3.0,
                max: Math.min(0.0, targets.true_peak_max ?? 0.0), // Hard cap 0 dBTP
                tol: targets.tol_true_peak || 0.5,
                type: 'CEILING'
            };
        }
        
        // DR
        if (targets.dr_target !== undefined) {
            finalTargets.dr = {
                target: targets.dr_target,
                min: targets.dr_min ?? (targets.dr_target - (targets.tol_dr || 1.5)),
                max: targets.dr_max ?? (targets.dr_target + (targets.tol_dr || 1.5)),
                tol: targets.tol_dr || 1.5
            };
        }
        
        // LRA - CORRIGIDO: incluir lra_target
        if (targets.lra_target !== undefined) {
            finalTargets.lra = {
                target: targets.lra_target,
                min: targets.lra_min ?? (targets.lra_target - (targets.tol_lra || 2.0)),
                max: targets.lra_max ?? (targets.lra_target + (targets.tol_lra || 2.0)),
                tol: targets.tol_lra || 2.0
            };
        }
        
        // Stereo Correlation
        if (targets.stereo_target !== undefined || targets.correlation_target !== undefined) {
            const stereoTarget = targets.stereo_target ?? targets.correlation_target;
            finalTargets.correlation = {
                target: stereoTarget,
                min: targets.stereo_min ?? 0.5,
                max: 1.0,
                tol: targets.tol_stereo || 0.1
            };
        }
        
        // Bandas
        if (targets.bands) {
            finalTargets.bands = targets.bands;
        }
    }
    
    // � CRÍTICO: OVERRIDE DE STREAMING - APLICAR DEPOIS DOS TARGETS DE GÊNERO
    // Este override DEVE acontecer DEPOIS que targets do gênero foram aplicados
    // e ANTES de avaliar as métricas, garantindo que o subscore use o target correto
    const soundDest = analysis?.soundDestination || 'pista';
    
    if (soundDest === 'streaming') {
        console.error('\n╔═══════════════════════════════════════════════════════════╗');
        console.error('║  📡 FRONTEND: APLICANDO OVERRIDE STREAMING FINAL         ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        console.error('[STREAMING-OVERRIDE] ANTES: lufs.target =', finalTargets.lufs?.target);
        
        // Override LUFS para padrão de streaming
        finalTargets.lufs = {
            target: -14,
            min: -16,
            max: -12,
            tol: 1.0
        };
        
        // Override True Peak para padrão de streaming
        finalTargets.truePeak = {
            target: -1.0,
            min: -3.0,
            max: -1.0,
            tol: 0.25,
            type: 'CEILING'
        };
        
        console.error('[STREAMING-OVERRIDE] DEPOIS: lufs.target =', finalTargets.lufs.target);
        console.error('[STREAMING-OVERRIDE] soundDestination:', soundDest);
        console.error('\n');
    }
    
    // 🔍 DEBUG: Log para verificar targets usados vs tabela
    if (DEBUG) {
        console.log('📊 finalTargets (usados no score):', {
            truePeak: finalTargets.truePeak,
            lufs: finalTargets.lufs,
            lra: finalTargets.lra,
            dr: finalTargets.dr
        });
        console.log('📊 targets passados:', {
            true_peak_target: targets?.true_peak_target,
            lufs_target: targets?.lufs_target,
            lra_target: targets?.lra_target,
            dr_target: targets?.dr_target
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 3. AVALIAR TODAS AS MÉTRICAS COM evaluateMetric (SINGLE SOURCE)
    // ═══════════════════════════════════════════════════════════════════
    const metricEvaluations = {};
    
    // 🎯 LOG CRÍTICO: Verificar target usado na avaliação de LUFS
    console.error('╔═══════════════════════════════════════════════════════════╗');
    console.error('║  🎯 AVALIANDO LUFS PARA SUBSCORE                         ║');
    console.error('╚═══════════════════════════════════════════════════════════╝');
    console.error('[LUFS-EVAL] LUFS medido:', measured.lufs);
    console.error('[LUFS-EVAL] Target usado:', finalTargets.lufs.target);
    console.error('[LUFS-EVAL] Diff (LU):', Math.abs(measured.lufs - finalTargets.lufs.target).toFixed(2));
    console.error('[LUFS-EVAL] soundDestination:', soundDest);
    console.error('\n');
    
    // Loudness
    metricEvaluations.lufs = window.evaluateMetric('lufs', measured.lufs, finalTargets.lufs);
    metricEvaluations.rms = window.evaluateMetric('rms', measured.rms, finalTargets.rms);
    
    // Technical
    metricEvaluations.truePeak = window.evaluateMetric('truePeak', measured.truePeak, finalTargets.truePeak);
    metricEvaluations.samplePeak = window.evaluateMetric('samplePeak', measured.samplePeak, finalTargets.samplePeak);
    metricEvaluations.clipping = window.evaluateMetric('clipping', measured.clipping, finalTargets.clipping);
    metricEvaluations.dcOffset = window.evaluateMetric('dcOffset', measured.dcOffset, finalTargets.dcOffset);
    
    // Dynamics
    metricEvaluations.dr = window.evaluateMetric('dr', measured.dr, finalTargets.dr);
    metricEvaluations.crest = window.evaluateMetric('crest', measured.crest, finalTargets.crest);
    metricEvaluations.lra = window.evaluateMetric('lra', measured.lra, finalTargets.lra);
    
    // Stereo
    metricEvaluations.correlation = window.evaluateMetric('correlation', measured.correlation, finalTargets.correlation);
    metricEvaluations.width = window.evaluateMetric('width', measured.width, finalTargets.width);
    
    // ═══════════════════════════════════════════════════════════════════
    // V4.1: MAPEAMENTO COMPLETO DE BANDAS - CORRIGE BUG CRÍTICO
    // JSON de gênero usa: sub, low_bass, upper_bass, low_mid, mid, high_mid, brilho, presenca
    // Backend envia: sub, bass, lowMid, mid, highMid, presence, air
    // ═══════════════════════════════════════════════════════════════════
    
    // Mapeamento: chave canônica → possíveis chaves no JSON
    const BAND_MAPPING = {
        sub: ['sub'],
        bass: ['bass', 'low_bass', 'upper_bass'],
        lowMid: ['lowMid', 'low_mid'],
        mid: ['mid'],
        highMid: ['highMid', 'high_mid'],
        presence: ['presence', 'presenca'],
        air: ['air', 'brilho', 'brilliance']
    };
    
    // TODAS as bandas do JSON que precisam ser processadas
    const ALL_JSON_BANDS = ['sub', 'low_bass', 'upper_bass', 'low_mid', 'mid', 'high_mid', 'brilho', 'presenca'];
    
    const bandTargets = finalTargets.bands || {};
    
    // Processar TODAS as bandas do JSON de targets, não apenas as canonizadas
    for (const jsonBandKey of ALL_JSON_BANDS) {
        const targetDef = bandTargets[jsonBandKey];
        
        if (!targetDef) {
            if (DEBUG) {
                console.log(`📊 [BANDS] Banda ${jsonBandKey} não encontrada nos targets`);
            }
            continue;
        }
        
        // Mapear chave do JSON para chave canônica para buscar valor medido
        let canonicalKey = jsonBandKey;
        let userValue = null;
        
        // Mapeamento reverso: JSON key → canonical key
        const REVERSE_MAP = {
            'low_bass': 'bass',
            'upper_bass': 'bass', // Combina com bass
            'low_mid': 'lowMid',
            'high_mid': 'highMid',
            'brilho': 'air',
            'presenca': 'presence'
        };
        
        canonicalKey = REVERSE_MAP[jsonBandKey] || jsonBandKey;
        
        // Buscar valor medido
        userValue = measured.bands?.[jsonBandKey]?.energy_db 
                 ?? measured.bands?.[jsonBandKey]
                 ?? measured.bands?.[canonicalKey]?.energy_db 
                 ?? measured.bands?.[canonicalKey];
        
        if (userValue === null || userValue === undefined) {
            if (DEBUG) {
                console.log(`📊 [BANDS] Valor não encontrado para ${jsonBandKey} (canonical: ${canonicalKey})`);
            }
            continue;
        }
        
        // Construir target normalizado
        const normalizedTarget = {
            target: targetDef.target_db ?? targetDef.target,
            min: targetDef.target_range?.min ?? targetDef.min_db,
            max: targetDef.target_range?.max ?? targetDef.max_db,
            tol: targetDef.tol_db || 2.5 // Usar tolerância do JSON
        };
        
        // Se não tem min/max explícito, calcular do target
        if (normalizedTarget.min === undefined) {
            normalizedTarget.min = (normalizedTarget.target ?? 0) - normalizedTarget.tol;
        }
        if (normalizedTarget.max === undefined) {
            normalizedTarget.max = (normalizedTarget.target ?? 0) + normalizedTarget.tol;
        }
        
        // Avaliar a banda
        const evaluation = window.evaluateMetric(jsonBandKey, userValue, normalizedTarget);
        
        // Armazenar com chave canônica para o resto do sistema
        // Se já existe (ex: low_bass e upper_bass → bass), usar o PIOR score
        const existingEval = metricEvaluations[canonicalKey];
        if (existingEval && existingEval.score !== null) {
            // Manter o pior score entre as bandas combinadas
            if (evaluation.score !== null && evaluation.score < existingEval.score) {
                metricEvaluations[canonicalKey] = evaluation;
                if (DEBUG) {
                    console.log(`📊 [BANDS] ${canonicalKey} atualizado: ${existingEval.score} → ${evaluation.score} (${jsonBandKey} é pior)`);
                }
            }
        } else {
            metricEvaluations[canonicalKey] = evaluation;
        }
        
        // Também armazenar com a chave original do JSON para referência
        metricEvaluations[`_json_${jsonBandKey}`] = evaluation;
        
        if (DEBUG) {
            console.log(`📊 [BANDS] ${jsonBandKey} → ${canonicalKey}: valor=${userValue?.toFixed(1)}, target=${normalizedTarget.target?.toFixed(1)}, score=${evaluation.score}, severity=${evaluation.severity}`);
        }
    }
    
    // Garantir que temos as chaves canônicas para o cálculo de frequência
    const BAND_KEYS = ['sub', 'bass', 'lowMid', 'mid', 'highMid', 'presence', 'air'];
    
    if (DEBUG) {
        console.log('📊 Metric Evaluations (evaluateMetric):', metricEvaluations);
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 4. CALCULAR SUBSCORES RAW (médias por grupo)
    // ═══════════════════════════════════════════════════════════════════
    function avgValidScores(keys) {
        const valid = keys
            .map(k => metricEvaluations[k]?.score)
            .filter(s => s !== null && s !== undefined);
        if (valid.length === 0) return null;
        return Math.round(valid.reduce((sum, s) => sum + s, 0) / valid.length);
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🎵 V4.0: CÁLCULO DE SUBSCORE DE FREQUÊNCIA - COERENTE COM TABELA
    // Princípios:
    // 1. Score individual por banda baseado em evaluateMetric (SINGLE SOURCE)
    // 2. Pesos PERCEPTIVOS (High Mid/Presença = fadiga auditiva)
    // 3. NUNCA permitir score alto se qualquer banda está CRÍTICA
    // 4. Score final = f(pior banda, média ponderada)
    // ═══════════════════════════════════════════════════════════════════════════
    function calculateFrequencySubscore() {
        // 🎯 V4.0: PESOS PERCEPTIVOS (baseado em impacto auditivo real)
        // - High Mid (2-4kHz): onde ouvimos fadiga, estridência = MAIOR PESO
        // - Presença (4-8kHz): clareza, sibilância = PESO ALTO
        // - Sub/Bass: importante, mas menos sensível perceptivamente
        const BAND_WEIGHTS = {
            sub: 0.12,      // 12% - fundação, menos sensível
            bass: 0.14,     // 14% - corpo, moderado  
            lowMid: 0.12,   // 12% - "muddiness"
            mid: 0.16,      // 16% - presença vocal/instrumental
            highMid: 0.20,  // 20% - FADIGA AUDITIVA (maior peso)
            presence: 0.14, // 14% - clareza/sibilância
            air: 0.12       // 12% - brilho/ar
        };
        
        // Coletar avaliações válidas
        const bandEvals = {};
        let totalWeight = 0;
        let weightedSum = 0;
        let bandsWithScore = 0;
        
        // Contadores de severidade para gates
        let criticalCount = 0;
        let highCount = 0;
        let attentionCount = 0;
        
        // 🎯 V4.0: Rastrear pior banda (para gate baseado no mínimo)
        let worstScore = 100;
        let worstBand = null;
        let worstSeverity = 'OK';
        
        // Log detalhado
        const bandDetails = [];
        
        for (const bandKey of BAND_KEYS) {
            const eval_ = metricEvaluations[bandKey];
            const weight = BAND_WEIGHTS[bandKey] || (1 / BAND_KEYS.length);
            
            if (eval_ && eval_.score !== null && eval_.score !== undefined) {
                bandEvals[bandKey] = eval_;
                weightedSum += eval_.score * weight;
                totalWeight += weight;
                bandsWithScore++;
                
                // Contar severidades
                if (eval_.severity === 'CRÍTICA') criticalCount++;
                else if (eval_.severity === 'ALTA') highCount++;
                else if (eval_.severity === 'ATENÇÃO') attentionCount++;
                
                // Rastrear pior banda
                if (eval_.score < worstScore) {
                    worstScore = eval_.score;
                    worstBand = bandKey;
                    worstSeverity = eval_.severity;
                }
                
                bandDetails.push({
                    band: bandKey,
                    score: eval_.score,
                    severity: eval_.severity,
                    weight: weight,
                    contribution: (eval_.score * weight).toFixed(2)
                });
            }
        }
        
        if (totalWeight === 0 || bandsWithScore === 0) {
            if (DEBUG) {
                console.log('📊 [FREQ-SUBSCORE] Nenhuma banda válida');
            }
            return null;
        }
        
        // Score base ponderado
        const weightedAvg = Math.round(weightedSum / totalWeight);
        
        // ═══════════════════════════════════════════════════════════════════
        // 🚨 V4.0: CÁLCULO DO SCORE FINAL - NUNCA IGNORAR ERROS CRÍTICOS
        // Fórmula: score = 0.6 * média_ponderada + 0.4 * pior_banda
        // Isso garante que erros críticos SEMPRE puxem o score para baixo
        // ═══════════════════════════════════════════════════════════════════
        let rawScore = Math.round(0.6 * weightedAvg + 0.4 * worstScore);
        
        // ═══════════════════════════════════════════════════════════════════
        // 🚨 V4.0: GATES DE SANIDADE MAIS AGRESSIVOS
        // ═══════════════════════════════════════════════════════════════════
        let appliedCap = null;
        let capReason = null;
        
        // Regra 0: QUALQUER banda CRÍTICA → cap no máximo score dessa banda + 10
        if (criticalCount >= 1 && worstSeverity === 'CRÍTICA') {
            const criticalCap = Math.min(worstScore + 10, 65);
            if (appliedCap === null || criticalCap < appliedCap) {
                appliedCap = criticalCap;
                capReason = `1+ banda CRÍTICA (${worstBand}: ${worstScore})`;
            }
        }
        
        // Regra 1: 3+ bandas CRÍTICAS → cap 45 (muito grave)
        if (criticalCount >= 3) {
            const cap = 45;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${criticalCount} bandas CRÍTICAS`;
            }
        }
        // Regra 2: 2 bandas CRÍTICAS → cap 55
        else if (criticalCount >= 2) {
            const cap = 55;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${criticalCount} bandas CRÍTICAS`;
            }
        }
        
        // Regra 3: 3+ bandas ALTA → cap 70
        if (highCount >= 3) {
            const cap = 70;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} bandas ALTA`;
            }
        }
        // Regra 4: 2 bandas ALTA → cap 78
        else if (highCount >= 2) {
            const cap = 78;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} bandas ALTA`;
            }
        }
        // Regra 5: 1 banda ALTA → cap 85
        else if (highCount >= 1) {
            const cap = 85;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${highCount} banda ALTA`;
            }
        }
        
        // Regra 6: 3+ bandas ATENÇÃO → cap 88
        if (attentionCount >= 3) {
            const cap = 88;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${attentionCount} bandas ATENÇÃO`;
            }
        }
        // Regra 7: 2 bandas ATENÇÃO → cap 92
        else if (attentionCount >= 2) {
            const cap = 92;
            if (appliedCap === null || cap < appliedCap) {
                appliedCap = cap;
                capReason = `${attentionCount} bandas ATENÇÃO`;
            }
        }
        
        // Aplicar cap se necessário
        const finalScore = appliedCap !== null ? Math.min(rawScore, appliedCap) : rawScore;
        
        // Log detalhado
        if (DEBUG) {
            console.log('═══════════════════════════════════════════════════════════');
            console.log('📊 [FREQ-SUBSCORE V4.0] Cálculo Detalhado');
            console.log('═══════════════════════════════════════════════════════════');
            console.table(bandDetails);
            console.log('📊 Contagem de severidades:', {
                CRÍTICA: criticalCount,
                ALTA: highCount,
                ATENÇÃO: attentionCount,
                OK: bandsWithScore - criticalCount - highCount - attentionCount
            });
            console.log('📊 Pior banda:', worstBand, '→', worstScore, `(${worstSeverity})`);
            console.log('📊 Média ponderada:', weightedAvg);
            console.log('📊 Score RAW (0.6*avg + 0.4*worst):', rawScore);
            if (appliedCap !== null) {
                console.log(`🚨 GATE APLICADO: Cap ${appliedCap} (${capReason})`);
            }
            console.log('📊 Score FINAL:', finalScore);
            console.log('═══════════════════════════════════════════════════════════');
        }
        
        return {
            score: finalScore,
            rawScore,
            weightedAvg,
            worstScore,
            worstBand,
            worstSeverity,
            appliedCap,
            capReason,
            criticalCount,
            highCount,
            attentionCount,
            bandDetails
        };
    }
    
    // Calcular subscore de frequência com o novo sistema
    const freqResult = calculateFrequencySubscore();
    
    // ═══════════════════════════════════════════════════════════════════
    // 🎯 STREAMING MODE — SUBSCORES DIRETOS (NÃO usar média)
    // ═══════════════════════════════════════════════════════════════════
    // CORREÇÃO CRÍTICA: Em modo streaming, LUFS e TRUE PEAK já passaram
    // pelas funções Strict que retornam o score FINAL correto.
    // NÃO devemos fazer média com RMS, nem normalizar depois!
    
    const analysisMode = analysis?.mode || 'genre';
    let loudnessSubscore = null;
    let technicalSubscore = null;
    
    if (analysisMode === 'streaming') {
        console.error('╔═══════════════════════════════════════════════════════════╗');
        console.error('║  🎯 STREAMING MODE — SUBSCORES DIRETOS                   ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        
        // LOUDNESS: usar SOMENTE LUFS score (sem média com RMS)
        loudnessSubscore = metricEvaluations.lufs?.score ?? null;
        
        console.error('[STREAMING-SUBSCORE] Loudness subscore DIRETO:', loudnessSubscore);
        console.error('[STREAMING-SUBSCORE] LUFS score usado:', metricEvaluations.lufs?.score);
        console.error('[STREAMING-SUBSCORE] LUFS severity:', metricEvaluations.lufs?.severity);
        console.error('[STREAMING-SUBSCORE] LUFS zone:', metricEvaluations.lufs?.streamingZone);
        console.error('[STREAMING-SUBSCORE] LUFS conformance:', metricEvaluations.lufs?.conformance);
        console.error('\n');
        
        // TECHNICAL: usar SOMENTE TRUE PEAK score (sem média com outras métricas)
        technicalSubscore = metricEvaluations.truePeak?.score ?? null;
        
        console.error('[STREAMING-SUBSCORE] Technical subscore DIRETO:', technicalSubscore);
        console.error('[STREAMING-SUBSCORE] True Peak score usado:', metricEvaluations.truePeak?.score);
        console.error('[STREAMING-SUBSCORE] True Peak severity:', metricEvaluations.truePeak?.severity);
        console.error('[STREAMING-SUBSCORE] True Peak zone:', metricEvaluations.truePeak?.streamingZone);
        console.error('[STREAMING-SUBSCORE] True Peak conformance:', metricEvaluations.truePeak?.conformance);
        console.error('\n');
    } else {
        // OUTROS MODOS: usar média como sempre foi
        loudnessSubscore = avgValidScores(['lufs', 'rms']);
        technicalSubscore = avgValidScores(['truePeak', 'samplePeak', 'clipping', 'dcOffset']);
    }
    
    const subScoresRaw = {
        loudness: loudnessSubscore,
        technical: technicalSubscore,
        dynamics: avgValidScores(['dr', 'crest', 'lra']),
        stereo: avgValidScores(['correlation', 'width']),
        frequency: freqResult?.score ?? null,
        // Metadados extras do frequency para debug
        _frequencyDetails: freqResult
    };
    
    // 🚨 LOG CRÍTICO: Subscore RAW de loudness ANTES dos gates
    console.error('╔═══════════════════════════════════════════════════════════╗');
    console.error('║  📊 SUBSCORE RAW DE LOUDNESS CALCULADO                   ║');
    console.error('╚═══════════════════════════════════════════════════════════╝');
    console.error('[LOUDNESS-SUBSCORE] Analysis mode:', analysisMode);
    console.error('[LOUDNESS-SUBSCORE] Subscore RAW:', subScoresRaw.loudness);
    console.error('[LOUDNESS-SUBSCORE] LUFS score:', metricEvaluations.lufs?.score);
    console.error('[LOUDNESS-SUBSCORE] RMS score:', metricEvaluations.rms?.score);
    console.error('[LOUDNESS-SUBSCORE] LUFS medido:', measured.lufs);
    console.error('[LOUDNESS-SUBSCORE] LUFS target:', finalTargets.lufs.target);
    console.error('[LOUDNESS-SUBSCORE] Diff (LU):', Math.abs(measured.lufs - finalTargets.lufs.target).toFixed(2));
    console.error('[LOUDNESS-SUBSCORE] soundDestination:', soundDest);
    console.error('\n');
    
    if (DEBUG) {
        console.log('📊 SubScores RAW:', subScoresRaw);
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 5. APLICAR GATES AOS SUBSCORES (baseado na severidade de evaluateMetric)
    // ═══════════════════════════════════════════════════════════════════
    const gatesTriggered = [];
    const subscores = { ...subScoresRaw };
    
    // 🎯 Gate #1: True Peak - Se evaluateMetric retornou CRÍTICA ou ALTA
    const tpEval = metricEvaluations.truePeak;
    if (tpEval && (tpEval.severity === 'CRÍTICA' || tpEval.severity === 'ALTA')) {
        // Cap baseado no score da avaliação
        const cap = Math.min(tpEval.score + 5, 65); // Cap máximo 65 para True Peak problemático
        
        if (subscores.technical !== null && subscores.technical > cap) {
            const oldValue = subscores.technical;
            subscores.technical = Math.round(cap);
            gatesTriggered.push({
                type: 'TRUE_PEAK_GATE',
                subscore: 'technical',
                value: measured.truePeak,
                target: finalTargets.truePeak.target,
                evalScore: tpEval.score,
                evalSeverity: tpEval.severity,
                cap,
                oldValue,
                newValue: subscores.technical,
                reason: tpEval.reason
            });
        }
    }
    
    // 🎯 Gate #2: Clipping > 0.5% → cap Technical subscore
    if (measured.clipping > 0.5) {
        const cap = Math.max(30, 80 - (measured.clipping - 0.5) * 10);
        const severity = measured.clipping > 5 ? 'CRÍTICA' : measured.clipping > 2 ? 'ALTA' : 'MODERADA';
        
        if (subscores.technical !== null && subscores.technical > cap) {
            const oldValue = subscores.technical;
            subscores.technical = Math.round(cap);
            gatesTriggered.push({
                type: 'CLIPPING_GATE',
                subscore: 'technical',
                value: measured.clipping,
                limit: 0.5,
                cap,
                oldValue,
                newValue: subscores.technical,
                severity
            });
        }
    }
    
    // 🎯 Gate #3: LUFS excessivo - Se evaluateMetric retornou CRÍTICA
    // 🚨 EXCEÇÃO CRÍTICA: NÃO aplicar em STREAMING
    // Em streaming, o target já é -14 LUFS (mais baixo) e o range de tolerância resolve o problema
    // Aplicar gate em streaming causaria penalização dupla e incorreta
    const lufsEval = metricEvaluations.lufs;
    // soundDest já foi declarado no topo - não redeclarar aqui
    
    if (lufsEval && lufsEval.severity === 'CRÍTICA' && soundDest !== 'streaming') {
        console.error('╔═══════════════════════════════════════════════════════════╗');
        console.error('║  🚫 LUFS_GATE: Aplicando penalização (modo pista)        ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        console.error('[LUFS_GATE] soundDestination:', soundDest);
        console.error('[LUFS_GATE] LUFS medido:', measured.lufs);
        console.error('[LUFS_GATE] Target:', finalTargets.lufs.target);
        console.error('[LUFS_GATE] Severidade:', lufsEval.severity);
        console.error('\n');
        
        const cap = Math.min(lufsEval.score + 5, 67);
        
        if (subscores.loudness !== null && subscores.loudness > cap) {
            const oldValue = subscores.loudness;
            subscores.loudness = Math.round(cap);
            gatesTriggered.push({
                type: 'LUFS_GATE',
                subscore: 'loudness',
                value: measured.lufs,
                target: finalTargets.lufs.target,
                evalScore: lufsEval.score,
                evalSeverity: lufsEval.severity,
                cap,
                oldValue,
                newValue: subscores.loudness,
                reason: lufsEval.reason
            });
        }
    } else if (lufsEval && lufsEval.severity === 'CRÍTICA' && soundDest === 'streaming') {
        // 🎯 Log quando gate é BLOQUEADO em streaming
        console.error('╔═══════════════════════════════════════════════════════════╗');
        console.error('║  ✅ LUFS_GATE: BLOQUEADO (modo streaming)                ║');
        console.error('╚═══════════════════════════════════════════════════════════╝');
        console.error('[LUFS_GATE] soundDestination:', soundDest);
        console.error('[LUFS_GATE] LUFS medido:', measured.lufs);
        console.error('[LUFS_GATE] Target streaming:', finalTargets.lufs.target);
        console.error('[LUFS_GATE] Subscore mantido:', subscores.loudness);
        console.error('[LUFS_GATE] Gate NÃO aplicado - target streaming já é adequado');
        console.error('\n');
    }
    
    // 🎯 Gate #4: FREQUENCY - Bandas com severidade alta
    // Este gate aplica cap adicional se os gates internos do calculateFrequencySubscore não foram suficientes
    if (freqResult && (freqResult.criticalCount > 0 || freqResult.highCount >= 2)) {
        const oldValue = subscores.frequency;
        // Se já aplicamos cap interno, o gate externo só registra
        // Se não, aplicamos um cap de segurança
        const internalCap = freqResult.appliedCap;
        
        // Gate externo: garantir coerência com subscores.frequency
        if (internalCap !== null && oldValue !== freqResult.score) {
            // Houve alguma inconsistência - forçar o valor correto
            subscores.frequency = freqResult.score;
        }
        
        gatesTriggered.push({
            type: 'FREQUENCY_GATE',
            subscore: 'frequency',
            criticalCount: freqResult.criticalCount,
            highCount: freqResult.highCount,
            attentionCount: freqResult.attentionCount,
            rawScore: freqResult.rawScore,
            appliedCap: freqResult.appliedCap,
            capReason: freqResult.capReason,
            oldValue: freqResult.rawScore,
            newValue: freqResult.score,
            bandDetails: freqResult.bandDetails
        });
    }
    
    if (DEBUG) {
        console.log('📊 Gates Triggered:', gatesTriggered);
        console.log('📊 SubScores AFTER GATES:', subscores);
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 6. CALCULAR SCORE FINAL (média ponderada dos subscores COM GATES)
    // ═══════════════════════════════════════════════════════════════════
    const WEIGHTS = {
        loudness: 0.25,
        technical: 0.25,
        dynamics: 0.20,
        stereo: 0.15,
        frequency: 0.15
    };
    
    let weightedSum = 0;
    let totalWeight = 0;
    
    for (const [key, weight] of Object.entries(WEIGHTS)) {
        if (subscores[key] !== null) {
            weightedSum += subscores[key] * weight;
            totalWeight += weight;
        }
    }
    
    // Raw = média dos subscores SEM gates
    let rawSum = 0;
    let rawWeight = 0;
    for (const [key, weight] of Object.entries(WEIGHTS)) {
        if (subScoresRaw[key] !== null) {
            rawSum += subScoresRaw[key] * weight;
            rawWeight += weight;
        }
    }
    const raw = rawWeight > 0 ? Math.round(rawSum / rawWeight) : 50;
    
    // Final = média dos subscores COM gates aplicados
    const final = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 50;
    
    if (DEBUG) {
        console.log('📊 Score RAW (sem gates):', raw);
        console.log('📊 Score FINAL (com gates nos subscores):', final);
        console.groupEnd();
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // 7. RETORNAR DEBUG ESTRUTURADO
    // ═══════════════════════════════════════════════════════════════════
    return {
        raw,
        final,
        subscores,           // Com gates aplicados
        subScoresRaw,        // Sem gates (para debug)
        gatesTriggered,      // Detalhes de cada gate
        metricEvaluations,   // Cada métrica avaliada por evaluateMetric
        _frequencyDetails: freqResult, // Detalhes do cálculo de frequência V3.7.1
        // Compatibilidade com formato antigo
        gatePenalty: raw - final,
        gateReasons: gatesTriggered,
        metricScores: metricEvaluations, // Alias
        debug: {
            mode,
            measured,
            targets: finalTargets,
            weights: WEIGHTS,
            totalWeight,
            version: 'V3.7.1-FREQ-WEIGHTED'
        }
    };
};

// Alias para compatibilidade
window.calculateScoreV3 = window.computeScoreV3;

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 DIAGNÓSTICO SONORO INTELIGENTE V1.0
// Função que transforma métricas técnicas em contexto semântico para IA/UI
// ═══════════════════════════════════════════════════════════════════════════════
/**
 * Constrói contexto diagnóstico semântico a partir dos resultados de computeScoreV3
 * @param {Object} scoreResult - Resultado de computeScoreV3 (metricEvaluations, subscores, etc)
 * @param {Object} analysisMeta - Metadados da análise (modo, gênero, referência, etc)
 * @returns {Object} { problems: [], strengths: [], context: {} }
 */
window.buildDiagnosticContext = function(scoreResult, analysisMeta = {}) {
    const DEBUG = true;
    
    if (DEBUG) {
        console.group('🧠 [buildDiagnosticContext V1.0] Construindo contexto semântico');
        console.log('📊 scoreResult keys:', Object.keys(scoreResult || {}));
        console.log('📊 analysisMeta:', analysisMeta);
    }
    
    if (!scoreResult || !scoreResult.metricEvaluations) {
        console.warn('⚠️ [buildDiagnosticContext] Dados insuficientes');
        if (DEBUG) console.groupEnd();
        return { problems: [], strengths: [], context: { valid: false } };
    }
    
    const evals = scoreResult.metricEvaluations;
    const subscores = scoreResult.subscores || {};
    const gatesTriggered = scoreResult.gatesTriggered || [];
    const freqDetails = scoreResult._frequencyDetails || {};
    
    // ═══════════════════════════════════════════════════════════════════
    // MAPEAMENTO SEMÂNTICO DE MÉTRICAS
    // ═══════════════════════════════════════════════════════════════════
    const METRIC_SEMANTICS = {
        // Loudness
        lufs: {
            name: 'Volume Integrado (LUFS)',
            category: 'loudness',
            problemTemplates: {
                high: 'Áudio está muito alto ({value} LUFS vs target {target} LUFS). Pode sofrer limitação em plataformas de streaming.',
                low: 'Áudio está muito baixo ({value} LUFS vs target {target} LUFS). Pode parecer fraco comparado a outras faixas.',
                critical: 'Volume está extremamente fora do padrão ({value} LUFS vs target {target} LUFS). Requer ajuste urgente de loudness.'
            },
            strengthTemplate: 'Volume integrado adequado ({value} LUFS), otimizado para {mode}.'
        },
        rms: {
            name: 'RMS Médio',
            category: 'loudness',
            problemTemplates: {
                high: 'RMS muito alto ({value} dB), indicando possível over-compression.',
                low: 'RMS baixo demais ({value} dB), áudio pode parecer muito quieto.',
                critical: 'RMS drasticamente fora do esperado ({value} dB).'
            },
            strengthTemplate: 'Nível RMS balanceado ({value} dB).'
        },
        
        // Technical
        truePeak: {
            name: 'True Peak',
            category: 'technical',
            highReliability: true,
            problemTemplates: {
                high: 'True Peak excede o limite seguro ({value} dBTP). Causará distorção após codec lossy.',
                critical: 'True Peak CRÍTICO ({value} dBTP). Áudio vai distorcer em qualquer plataforma.'
            },
            strengthTemplate: 'True Peak dentro do limite seguro ({value} dBTP).'
        },
        clipping: {
            name: 'Clipping Digital',
            category: 'technical',
            highReliability: true,
            problemTemplates: {
                high: 'Detectado clipping ({value}%). Pode causar distorção audível.',
                critical: 'Clipping excessivo ({value}%). Distorção severa no áudio.'
            },
            strengthTemplate: 'Sem clipping digital detectado.'
        },
        dcOffset: {
            name: 'DC Offset',
            category: 'technical',
            problemTemplates: {
                high: 'DC Offset detectado ({value}%). Pode reduzir headroom disponível.',
                critical: 'DC Offset significativo ({value}%). Requer correção.'
            },
            strengthTemplate: 'DC Offset negligível.'
        },
        
        // Dynamics
        dr: {
            name: 'Dynamic Range',
            category: 'dynamics',
            problemTemplates: {
                high: 'Dynamic Range muito alto ({value} dB). Pode soar inconsistente em volumes diferentes.',
                low: 'Dynamic Range muito baixo ({value} dB). Áudio pode soar comprimido/sem vida.',
                critical: 'Dynamic Range extremo ({value} dB vs esperado {target} dB). Verificar compressão/limiting.'
            },
            strengthTemplate: 'Dynamic Range adequado para {mode} ({value} dB).'
        },
        lra: {
            name: 'Loudness Range (LRA)',
            category: 'dynamics',
            problemTemplates: {
                high: 'LRA muito amplo ({value} LU). Partes podem parecer muito mais altas/baixas.',
                low: 'LRA muito estreito ({value} LU). Pode indicar over-limiting.',
                critical: 'LRA fora dos padrões ({value} LU).'
            },
            strengthTemplate: 'Loudness Range equilibrado ({value} LU).'
        },
        crest: {
            name: 'Crest Factor',
            category: 'dynamics',
            problemTemplates: {
                high: 'Crest Factor alto ({value} dB). Transients podem não estar bem controlados.',
                low: 'Crest Factor baixo ({value} dB). Possível over-compression.',
                critical: 'Crest Factor extremo ({value} dB).'
            },
            strengthTemplate: 'Crest Factor adequado ({value} dB).'
        },
        
        // Stereo
        correlation: {
            name: 'Correlação Estéreo',
            category: 'stereo',
            highReliability: true,
            problemTemplates: {
                low: 'Correlação estéreo baixa ({value}). Pode haver problemas de fase ou cancelamento em mono.',
                critical: 'Correlação muito baixa ({value}). Possível inversão de fase ou problemas graves de compatibilidade mono.'
            },
            strengthTemplate: 'Correlação estéreo saudável ({value}).'
        },
        width: {
            name: 'Largura Estéreo',
            category: 'stereo',
            problemTemplates: {
                high: 'Estéreo muito largo ({value}). Pode parecer "falso" ou ter problemas em mono.',
                low: 'Estéreo estreito demais ({value}). Mix pode parecer "fechado".',
                critical: 'Largura estéreo extrema ({value}).'
            },
            strengthTemplate: 'Largura estéreo apropriada ({value}).'
        },
        
        // Frequency Bands
        sub: { name: 'Sub-graves (20-60Hz)', category: 'frequency' },
        bass: { name: 'Graves (60-250Hz)', category: 'frequency' },
        lowMid: { name: 'Médio-graves (250-500Hz)', category: 'frequency' },
        mid: { name: 'Médios (500-2kHz)', category: 'frequency' },
        highMid: { name: 'Médio-agudos (2-4kHz)', category: 'frequency' },
        presence: { name: 'Presença (4-8kHz)', category: 'frequency' },
        air: { name: 'Air (8-20kHz)', category: 'frequency' }
    };
    
    const BAND_PROBLEM_TEMPLATE = {
        high: '{name} com excesso ({value} dB vs target {target} dB). Pode causar {effect}.',
        low: '{name} com déficit ({value} dB vs target {target} dB). Pode causar {effect}.',
        critical: '{name} criticamente fora do range ({value} dB). Requer EQ corretiva urgente.'
    };
    
    const BAND_EFFECTS = {
        sub: { high: 'peso excessivo ou rumble', low: 'falta de peso/fundação' },
        bass: { high: 'mixagem "muddy" ou embolada', low: 'mix fina/sem corpo' },
        lowMid: { high: 'mixagem "boxy" ou abafada', low: 'falta de corpo nos instrumentos' },
        mid: { high: 'som "nasal" ou fatigante', low: 'falta de presença e clareza' },
        highMid: { high: 'som agressivo/estridente', low: 'falta de definição/corte' },
        presence: { high: 'sibilância excessiva', low: 'som apagado/distante' },
        air: { high: 'ruído/aspereza no high-end', low: 'falta de brilho/abertura' }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // CONSTRUIR ARRAYS DE PROBLEMAS E PONTOS FORTES
    // ═══════════════════════════════════════════════════════════════════
    const problems = [];
    const strengths = [];
    
    // Processar cada métrica avaliada
    for (const [metricKey, evaluation] of Object.entries(evals)) {
        if (!evaluation || evaluation.score === null) continue;
        
        const semantic = METRIC_SEMANTICS[metricKey];
        if (!semantic) continue;
        
        const { severity, score, deviation, value, target } = evaluation;
        const mode = analysisMeta.mode || 'streaming';
        
        // Determinar se é PROBLEMA ou PONTO FORTE
        if (severity === 'CRÍTICA' || severity === 'ALTA' || severity === 'ATENÇÃO') {
            // É um problema
            let problemText = '';
            const direction = deviation > 0 ? 'high' : 'low';
            
            // Para bandas de frequência
            if (semantic.category === 'frequency') {
                const template = severity === 'CRÍTICA' 
                    ? BAND_PROBLEM_TEMPLATE.critical 
                    : BAND_PROBLEM_TEMPLATE[direction];
                const effect = BAND_EFFECTS[metricKey]?.[direction] || 'problemas de balanço';
                
                problemText = template
                    .replace('{name}', semantic.name)
                    .replace('{value}', value?.toFixed?.(1) ?? '?')
                    .replace('{target}', target?.toFixed?.(1) ?? '?')
                    .replace('{effect}', effect);
            } else {
                // Para outras métricas
                const templates = semantic.problemTemplates || {};
                const templateKey = severity === 'CRÍTICA' ? 'critical' : direction;
                const template = templates[templateKey] || templates.high || templates.low || `${semantic.name} fora do ideal ({value}).`;
                
                problemText = template
                    .replace('{value}', typeof value === 'number' ? value.toFixed(1) : String(value))
                    .replace('{target}', typeof target === 'number' ? target.toFixed(1) : String(target))
                    .replace('{mode}', mode);
            }
            
            problems.push({
                metric: metricKey,
                name: semantic.name,
                category: semantic.category,
                severity,
                score,
                deviation,
                text: problemText,
                value,
                target,
                isHighReliability: semantic.highReliability === true
            });
        } else if (severity === 'OK' && score >= 90) {
            // É um ponto forte
            const template = semantic.strengthTemplate || `${semantic.name} está bom.`;
            const strengthText = template
                .replace('{value}', typeof value === 'number' ? value.toFixed(1) : String(value))
                .replace('{target}', typeof target === 'number' ? target.toFixed(1) : String(target))
                .replace('{mode}', mode);
            
            strengths.push({
                metric: metricKey,
                name: semantic.name,
                category: semantic.category,
                score,
                text: strengthText,
                value,
                isHighReliability: semantic.highReliability === true
            });
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // ORDENAR PROBLEMAS POR PRIORIDADE
    // ═══════════════════════════════════════════════════════════════════
    const SEVERITY_ORDER = { 'CRÍTICA': 0, 'ALTA': 1, 'ATENÇÃO': 2 };
    const CATEGORY_ORDER = { 'technical': 0, 'loudness': 1, 'dynamics': 2, 'stereo': 3, 'frequency': 4 };
    
    problems.sort((a, b) => {
        // 1. Priorizar alta confiabilidade
        if (a.isHighReliability && !b.isHighReliability) return -1;
        if (!a.isHighReliability && b.isHighReliability) return 1;
        
        // 2. Por severidade
        const sevA = SEVERITY_ORDER[a.severity] ?? 99;
        const sevB = SEVERITY_ORDER[b.severity] ?? 99;
        if (sevA !== sevB) return sevA - sevB;
        
        // 3. Por categoria
        const catA = CATEGORY_ORDER[a.category] ?? 99;
        const catB = CATEGORY_ORDER[b.category] ?? 99;
        return catA - catB;
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // CONSTRUIR CONTEXTO GERAL
    // ═══════════════════════════════════════════════════════════════════
    const context = {
        valid: true,
        finalScore: scoreResult.final,
        rawScore: scoreResult.raw,
        mode: analysisMeta.mode || 'streaming',
        genre: analysisMeta.genre || null,
        reference: analysisMeta.reference || null,
        
        // Resumos por categoria
        subscoresSummary: {
            loudness: { score: subscores.loudness, status: getStatusFromScore(subscores.loudness) },
            technical: { score: subscores.technical, status: getStatusFromScore(subscores.technical) },
            dynamics: { score: subscores.dynamics, status: getStatusFromScore(subscores.dynamics) },
            stereo: { score: subscores.stereo, status: getStatusFromScore(subscores.stereo) },
            frequency: { score: subscores.frequency, status: getStatusFromScore(subscores.frequency) }
        },
        
        // Estatísticas
        stats: {
            totalProblems: problems.length,
            criticalProblems: problems.filter(p => p.severity === 'CRÍTICA').length,
            highProblems: problems.filter(p => p.severity === 'ALTA').length,
            attentionProblems: problems.filter(p => p.severity === 'ATENÇÃO').length,
            totalStrengths: strengths.length,
            gatesApplied: gatesTriggered.length
        },
        
        // Gates em linguagem humana
        gatesSummary: gatesTriggered.map(g => {
            if (g.type === 'TRUE_PEAK_GATE') return `True Peak excessivo limitou o score técnico`;
            if (g.type === 'CLIPPING_GATE') return `Clipping detectado limitou o score técnico`;
            if (g.type === 'LUFS_GATE') return `Volume extremo limitou o score de loudness`;
            if (g.type === 'FREQUENCY_GATE') return `Bandas críticas limitaram o score de frequência`;
            return `Gate ${g.type} aplicado`;
        })
    };
    
    // Função helper para status
    function getStatusFromScore(score) {
        if (score === null) return 'indisponível';
        if (score >= 90) return 'excelente';
        if (score >= 75) return 'bom';
        if (score >= 60) return 'regular';
        if (score >= 40) return 'precisa melhorar';
        return 'crítico';
    }
    
    if (DEBUG) {
        console.log('📊 Problems encontrados:', problems.length);
        console.log('📊 Strengths encontrados:', strengths.length);
        console.log('📊 Context:', context);
        console.groupEnd();
    }
    
    return { problems, strengths, context };
};

// ═══════════════════════════════════════════════════════════════════════════════
// 🧠 V7.0: VEREDITO SONORO INTELIGENTE - ULTRA PREMIUM
// Engenharia de áudio + Física do som + Psicoacústica + Neurociência
// Estrutura: 1) Técnico+Físico | 2) Psicoacústico/Neural | 3) Correção+Benefício
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * Gera veredito sonoro inteligente - 3 frases combinando engenharia, física e neurociência
 * @param {Object} diagnostic - Resultado de buildDiagnosticContext
 * @returns {string} Texto de 3 frases em linguagem técnica + perceptiva
 */
window.generateFinalDiagnosticText = function(diagnostic) {
    if (!diagnostic || !diagnostic.context?.valid) {
        return null;
    }
    
    const { problems, strengths, context } = diagnostic;
    const { finalScore, stats, subscoresSummary } = context;
    
    // ═══════════════════════════════════════════════════════════════════
    // V7.0: VEREDITO SONORO INTELIGENTE
    // Estrutura obrigatória de 3 frases:
    // 1. Diagnóstico técnico + consequência física no sistema de som
    // 2. Impacto psicoacústico no ouvido e cérebro humano
    // 3. Direcionamento de correção + benefício perceptivo
    // ═══════════════════════════════════════════════════════════════════
    
    // Identificar problemas principais
    const criticalProblems = problems.filter(p => p.severity === 'CRÍTICA');
    const highProblems = problems.filter(p => p.severity === 'ALTA');
    const topProblems = [...criticalProblems, ...highProblems].slice(0, 3);
    
    // Mapear categorias para impactos físicos + neurais
    const AUDIO_SCIENCE = {
        technical: {
            techPhysical: 'clipping ou saturação que gera harmônicos indesejados, forçando falantes a reproduzir frequências distorcidas',
            psychoacoustic: 'o ouvido humano percebe aspereza e o cérebro interpreta como agressão sonora, ativando fadiga e desconforto imediatos',
            correction: 'controle de picos e limitação restaurarão a integridade do sinal e permitirão escuta prolongada sem irritação'
        },
        loudness: {
            techPhysical: 'intensidade fora do padrão de distribuição que causa excursão irregular nos transdutores e inconsistência em sistemas PA',
            psychoacoustic: 'o sistema auditivo é forçado a recalibrar ganho constantemente, gerando fadiga subliminar e perda de atenção',
            correction: 'calibração de loudness garantirá consistência entre plataformas e uma experiência de escuta equilibrada e confortável'
        },
        dynamics: {
            techPhysical: 'compressão excessiva que achata transientes e remove a micro-dinâmica essencial para definição em caixas de som',
            psychoacoustic: 'o cérebro perde referências de profundidade e espacialidade, reduzindo o engajamento emocional com a música',
            correction: 'preservação de dinâmica devolverá impacto aos transientes e reconectará o ouvinte à energia natural da faixa'
        },
        stereo: {
            techPhysical: 'problemas de correlação estéreo que causam cancelamento de fase em sistemas mono e imagem instável em PA',
            psychoacoustic: 'o processamento binaural do cérebro não consegue posicionar fontes no espaço, gerando confusão e desconforto espacial',
            correction: 'correção de coerência estéreo restaurará a espacialidade natural e garantirá compatibilidade em qualquer sistema'
        },
        frequency: {
            techPhysical: 'desequilíbrio espectral que sobrecarrega regiões específicas dos falantes, causando perda de definição e tradução inconsistente',
            psychoacoustic: 'o córtex auditivo recebe informação incompleta, induzindo fadiga neural acelerada e tendência à rejeição da música',
            correction: 'balanço tonal adequado permitirá tradução fiel em qualquer sistema e uma experiência de escuta fluida e agradável'
        }
    };
    
    // ═══════════════════════════════════════════════════════════════════
    // SCORE EXCELENTE (90+) - Conforto máximo
    // ═══════════════════════════════════════════════════════════════════
    if (finalScore >= 90 && stats.criticalProblems === 0) {
        return 'Sua faixa apresenta balanço espectral e dinâmica que garantem reprodução fiel em qualquer sistema de som, de fones a PA profissional. O ouvido humano processa o material sem esforço, e o cérebro mantém engajamento atencional elevado durante toda a escuta. A masterização está pronta para distribuição com excelência técnica e perceptiva.';
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SCORE BOM (75-89) - Refinamentos pontuais
    // ═══════════════════════════════════════════════════════════════════
    if (finalScore >= 75 && stats.criticalProblems === 0) {
        const worstCategory = Object.entries(subscoresSummary)
            .filter(([_, v]) => v.score !== null && v.score < 85)
            .sort((a, b) => a[1].score - b[1].score)[0];
        
        if (worstCategory) {
            const science = AUDIO_SCIENCE[worstCategory[0]];
            if (science) {
                return `Sua faixa está próxima do ideal, mas apresenta ${science.techPhysical}. Em escutas prolongadas, ${science.psychoacoustic}. ${science.correction.charAt(0).toUpperCase() + science.correction.slice(1)}.`;
            }
        }
        return 'Sua faixa apresenta qualidade sólida com pequenas irregularidades que podem causar leve inconsistência em sistemas de alta fidelidade. O cérebro processa bem o material, mas escutas repetidas podem induzir fadiga sutil. Refinamentos pontuais elevarão o conforto auditivo ao padrão profissional.';
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SCORE MÉDIO (60-74) - Ajustes necessários
    // ═══════════════════════════════════════════════════════════════════
    if (finalScore >= 60) {
        const problemCategories = [...new Set(topProblems.map(p => p.category))].slice(0, 2);
        
        if (problemCategories.length >= 1) {
            const science = AUDIO_SCIENCE[problemCategories[0]];
            if (science) {
                return `Sua faixa apresenta ${science.techPhysical}. Isso faz com que ${science.psychoacoustic}. ${science.correction.charAt(0).toUpperCase() + science.correction.slice(1)}.`;
            }
        }
        
        return 'Sua faixa apresenta desequilíbrios que comprometem a tradução entre sistemas de som e causam fadiga em escutas prolongadas. O cérebro tende a desviar atenção de fontes sonoras que exigem esforço cognitivo excessivo. Ajustes no balanço espectral e dinâmica reduzirão a fadiga e aumentarão o engajamento do ouvinte.';
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // SCORE BAIXO (<60) - Intervenção necessária
    // ═══════════════════════════════════════════════════════════════════
    const criticalCategories = [...new Set(criticalProblems.map(p => p.category))];
    
    if (criticalCategories.includes('technical')) {
        return 'Sua faixa apresenta distorção severa que gera harmônicos nocivos, forçando falantes a operar fora de sua linearidade e causando artefatos audíveis em qualquer sistema. O ouvido humano identifica isso como ruído agressivo, e o cérebro ativa mecanismos de proteção que impossibilitam escuta confortável. Revisão completa do controle de picos é imprescindível para viabilizar a distribuição.';
    }
    
    if (criticalCategories.includes('frequency')) {
        return 'Sua faixa apresenta desequilíbrio espectral severo que sobrecarrega regiões dos falantes, causando perda de definição e tradução inconsistente entre sistemas. O córtex auditivo recebe informação assimétrica, gerando fadiga neural acelerada e tendência instintiva à rejeição da música. Correção profunda no balanço tonal é necessária para viabilizar uma experiência de escuta aceitável.';
    }
    
    if (criticalCategories.includes('loudness')) {
        return 'Sua faixa apresenta intensidade drasticamente fora do padrão, causando excursão excessiva em falantes e normalização agressiva nas plataformas de streaming. O sistema auditivo é forçado a operar em zona de desconforto, ativando fadiga defensiva que reduz drasticamente o tempo de escuta tolerável. Calibração de loudness é essencial antes de qualquer distribuição.';
    }
    
    return 'Sua faixa apresenta múltiplos problemas técnicos que comprometem a reprodução em sistemas de som e causam fadiga auditiva significativa. O cérebro não consegue processar o material de forma relaxada, induzindo desengajamento e rejeição perceptiva precoces. Revisão integral de mixagem e masterização é necessária para garantir uma experiência de escuta profissional.';
};

// ═══════════════════════════════════════════════════════════════════════════
// 🧪 TEST FUNCTION V3.6: Testa cenários com novo sistema de gates nos subscores
// Execute no console: window.__testScoreV3Scenarios()
// ═══════════════════════════════════════════════════════════════════════════
window.__testScoreV3Scenarios = function() {
    console.log('\n');
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('🧪 TESTE V3.6: SINGLE SOURCE OF TRUTH - GATES NOS SUBSCORES');
    console.log('═══════════════════════════════════════════════════════════════');
    
    // CENÁRIO A: True Peak CRÍTICO (+2.0 dBTP)
    console.log('\n📋 CENÁRIO A: True Peak CRÍTICO (+2.0 dBTP)');
    console.log('─────────────────────────────────────────────');
    console.log('Esperado: Gate capeia Technical subscore, não o final');
    const scenarioA = {
        technicalData: {
            lufsIntegrated: -14.0,    // OK
            truePeakDbtp: 2.0,        // CRÍTICO! > 0 dBTP (+3 dB acima do max)
            dynamicRange: 8.0,        // OK
            crestFactor: 12.0,        // OK
            lra: 7.0,                 // OK
            stereoCorrelation: 0.9,   // OK
            stereoWidth: 0.7,         // OK
            clippingPct: 0.001,       // OK
            dcOffset: 0.0,            // OK
            bands: {
                sub: { energy_db: -28.0 },   // OK
                bass: { energy_db: -22.0 },  // OK
                mid: { energy_db: -18.0 },   // OK
            }
        }
    };
    
    const resultA = window.computeScoreV3(scenarioA, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0 },
            bass: { target_db: -22.0, tol_db: 3.0 },
            mid: { target_db: -18.0, tol_db: 3.0 }
        }
    }, 'streaming');
    
    console.log('📊 RESULTADO CENÁRIO A:');
    console.log('   Valores medidos:', { truePeak: 2.0, lufs: -14.0, dr: 8.0 });
    console.log('   Raw Score (sem gates):', resultA.raw);
    console.log('   Final Score (com gates):', resultA.final);
    console.log('   SubScores RAW:', resultA.subScoresRaw);
    console.log('   SubScores APÓS GATES:', resultA.subscores);
    console.log('   Gates Triggered:', resultA.gatesTriggered);
    console.log('   evaluateMetric(truePeak):', resultA.metricEvaluations?.truePeak);
    
    // Verificação: Technical subscore deve ter sido capeado
    const passA1 = resultA.subscores.technical < resultA.subScoresRaw.technical;
    const passA2 = resultA.gatesTriggered.some(g => g.type === 'TRUE_PEAK_GATE');
    const passA3 = resultA.metricEvaluations?.truePeak?.severity === 'CRÍTICA';
    console.log(passA1 ? '✅ Technical foi capeado' : '❌ Technical NÃO foi capeado');
    console.log(passA2 ? '✅ TRUE_PEAK_GATE foi triggered' : '❌ TRUE_PEAK_GATE NÃO foi triggered');
    console.log(passA3 ? '✅ Severidade truePeak = CRÍTICA' : '❌ Severidade truePeak != CRÍTICA');
    const passA = passA1 && passA2 && passA3;
    
    // CENÁRIO B: Sub/Bass CRÍTICOS (muito fora do range)
    console.log('\n📋 CENÁRIO B: Sub/Bass CRÍTICOS (muito fora do range)');
    console.log('────────────────────────────────────────────────────────');
    console.log('Esperado: Frequency subscore baixo, sem gates (problema nas métricas)');
    const scenarioB = {
        technicalData: {
            lufsIntegrated: -14.0,    // OK
            truePeakDbtp: -1.0,       // OK
            dynamicRange: 8.0,        // OK
            crestFactor: 12.0,        // OK
            lra: 7.0,                 // OK
            stereoCorrelation: 0.9,   // OK
            stereoWidth: 0.7,         // OK
            clippingPct: 0.001,       // OK
            dcOffset: 0.0,            // OK
            bands: {
                sub: { energy_db: -15.0 },   // CRÍTICO! +10 dB acima do max (-25)
                bass: { energy_db: -10.0 },  // CRÍTICO! +9 dB acima do max (-19)
                mid: { energy_db: -18.0 },   // OK
            }
        }
    };
    
    const resultB = window.computeScoreV3(scenarioB, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0, target_range: { min: -31.0, max: -25.0 } },
            bass: { target_db: -22.0, tol_db: 3.0, target_range: { min: -25.0, max: -19.0 } },
            mid: { target_db: -18.0, tol_db: 3.0, target_range: { min: -21.0, max: -15.0 } }
        }
    }, 'streaming');
    
    console.log('📊 RESULTADO CENÁRIO B:');
    console.log('   Valores medidos (bands):', { sub: -15.0, bass: -10.0, mid: -18.0 });
    console.log('   Raw Score:', resultB.raw);
    console.log('   Final Score:', resultB.final);
    console.log('   SubScores:', resultB.subscores);
    console.log('   Frequency Score:', resultB.subscores.frequency);
    console.log('   evaluateMetric(sub):', resultB.metricEvaluations?.sub);
    console.log('   evaluateMetric(bass):', resultB.metricEvaluations?.bass);
    console.log('   Gates Triggered:', resultB.gatesTriggered?.length || 0);
    
    // Verificação: Frequency subscore deve refletir a severidade das bandas
    const passB1 = resultB.subscores.frequency !== null && resultB.subscores.frequency <= 40;
    const passB2 = resultB.metricEvaluations?.sub?.severity === 'CRÍTICA';
    const passB3 = resultB.metricEvaluations?.bass?.severity === 'CRÍTICA';
    console.log(passB1 ? '✅ Frequency ≤ 40 (bandas críticas)' : '❌ Frequency > 40');
    console.log(passB2 ? '✅ Sub severidade = CRÍTICA' : '❌ Sub severidade != CRÍTICA');
    console.log(passB3 ? '✅ Bass severidade = CRÍTICA' : '❌ Bass severidade != CRÍTICA');
    const passB = passB1 && passB2 && passB3;
    
    // CENÁRIO C: Tudo OK
    console.log('\n📋 CENÁRIO C: Todas métricas OK');
    console.log('───────────────────────────────');
    const scenarioC = {
        technicalData: {
            lufsIntegrated: -14.0,
            truePeakDbtp: -1.5,
            dynamicRange: 8.0,
            crestFactor: 12.0,
            lra: 7.0,
            stereoCorrelation: 0.9,
            stereoWidth: 0.7,
            clippingPct: 0.0,
            dcOffset: 0.0,
            bands: {
                sub: { energy_db: -28.0 },
                bass: { energy_db: -22.0 },
                mid: { energy_db: -18.0 }
            }
        }
    };
    
    const resultC = window.computeScoreV3(scenarioC, {
        lufs_target: -14.0, tol_lufs: 1.0,
        true_peak_target: -1.0, tol_true_peak: 0.25,
        dr_target: 8.0, tol_dr: 1.5,
        bands: {
            sub: { target_db: -28.0, tol_db: 3.0 },
            bass: { target_db: -22.0, tol_db: 3.0 },
            mid: { target_db: -18.0, tol_db: 3.0 }
        }
    }, 'streaming');
    
    console.log('📊 RESULTADO CENÁRIO C:');
    console.log('   Raw Score:', resultC.raw);
    console.log('   Final Score:', resultC.final);
    console.log('   SubScores:', resultC.subscores);
    console.log('   Gates:', resultC.gatesTriggered?.length || 0);
    
    const passC = resultC.final >= 85 && resultC.gatesTriggered?.length === 0;
    console.log(passC ? '✅ Score alto sem gates' : '❌ Score baixo ou com gates');
    
    // RESUMO FINAL
    console.log('\n═══════════════════════════════════════════════════════════════');
    const allPassed = passA && passB && passC;
    console.log(allPassed ? '🎉 TODOS OS TESTES PASSARAM!' : '⚠️ ALGUNS TESTES FALHARAM');
    console.log('─────────────────────────────────────────────────────────────');
    console.log('  Cenário A (True Peak crítico):', passA ? '✅' : '❌');
    console.log('  Cenário B (Sub/Bass críticos):', passB ? '✅' : '❌');
    console.log('  Cenário C (Tudo OK):', passC ? '✅' : '❌');
    console.log('═══════════════════════════════════════════════════════════════');
    
    return { 
        scenarioA: { result: resultA, passed: passA },
        scenarioB: { result: resultB, passed: passB },
        scenarioC: { result: resultC, passed: passC },
        allPassed
    };
};

console.log('🧪 [V3.6] Função de teste disponível: window.__testScoreV3Scenarios()');
console.log('📊 [V3.6] Função canônica disponível: window.evaluateMetric(metricKey, value, targetSpec)');

// 3. CALCULAR SCORE DE LOUDNESS (LUFS, True Peak, Crest Factor)
// 🔄 ATUALIZADO: Agora usa getMetricBounds para suportar min/max assimétrico
function calculateLoudnessScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // ═══════════════════════════════════════════════════════════════════════
    // 📊 LUFS Integrado (métrica principal de loudness) - AGORA COM MIN/MAX
    // ═══════════════════════════════════════════════════════════════════════
    const lufsValue = metrics.lufs_integrated || tech.lufsIntegrated;
    if (Number.isFinite(lufsValue)) {
        const lufsBounds = getMetricBounds(refData, 'lufs');
        
        if (lufsBounds) {
            // Usar novo sistema de bounds (min/max)
            const result = calculateMetricScoreWithBounds(lufsValue, lufsBounds, { metricKey: 'lufs' });
            if (result.score !== null) {
                scores.push(result.score);
                console.log(`📊 LUFS: ${lufsValue.toFixed(1)} dB dentro de [${lufsBounds.min.toFixed(1)}, ${lufsBounds.max.toFixed(1)}] = ${result.score}% (${result.status})`);
            }
        } else if (Number.isFinite(refData.lufs_target) && Number.isFinite(refData.tol_lufs)) {
            // Fallback para sistema legado (target ± tol)
            const score = calculateMetricScore(lufsValue, refData.lufs_target, refData.tol_lufs);
            if (score !== null) {
                scores.push(score);
                console.log(`📊 LUFS: ${lufsValue} vs ${refData.lufs_target} (±${refData.tol_lufs}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 📊 TRUE PEAK - CRÍTICO: NUNCA > 0 dBTP - AGORA COM MIN/MAX
    // ═══════════════════════════════════════════════════════════════════════
    const truePeakValue = metrics.true_peak_dbtp || tech.truePeakDbtp;
    if (Number.isFinite(truePeakValue)) {
        const tpBounds = getMetricBounds(refData, 'true_peak');
        
        if (tpBounds) {
            // 🚨 REGRA CRÍTICA: True Peak > 0 dBTP = SEMPRE CRÍTICO
            // Forçar max = 0 mesmo que o JSON tenha outro valor
            const safeBounds = {
                ...tpBounds,
                max: Math.min(tpBounds.max, 0.0) // NUNCA > 0
            };
            
            const result = calculateMetricScoreWithBounds(truePeakValue, safeBounds, { 
                metricKey: 'true_peak',
                isCriticalAboveMax: true // True Peak acima do max é sempre crítico
            });
            
            if (result.score !== null) {
                scores.push(result.score);
                const statusEmoji = result.status === 'CRITICAL' ? '🚨' : result.status === 'WARNING' ? '⚠️' : '✅';
                console.log(`📊 True Peak: ${truePeakValue.toFixed(1)} dBTP dentro de [${safeBounds.min.toFixed(1)}, ${safeBounds.max.toFixed(1)}] = ${result.score}% ${statusEmoji} (${result.status})`);
            }
        } else if (Number.isFinite(refData.true_peak_target) && Number.isFinite(refData.tol_true_peak)) {
            // Fallback para sistema legado
            const score = calculateMetricScore(truePeakValue, refData.true_peak_target, refData.tol_true_peak);
            if (score !== null) {
                scores.push(score);
                console.log(`📊 True Peak: ${truePeakValue} vs ${refData.true_peak_target} (±${refData.tol_true_peak}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 📊 Crest Factor (dinâmica de picos) - Mantém sistema legado
    // ═══════════════════════════════════════════════════════════════════════
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Crest Factor: ${crestValue} vs ${refData.crest_target} (±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar média dos scores válidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateLoudnessScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`🔊 Score Loudness Final: ${result}% (média de ${scores.length} métricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateLoudnessScore',
            value: { lufs: metrics.lufs_integrated || tech.lufsIntegrated, truePeak: metrics.true_peak_dbtp || tech.truePeakDbtp, crest: tech.crestFactor || metrics.crest_factor },
            target: { lufs: refData.lufs_target, truePeak: refData.true_peak_target, crest: refData.crest_target },
            diff: 'ver logs individuais',
            tolerance: { lufs: refData.tol_lufs, truePeak: refData.tol_true_peak, crest: refData.tol_crest },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateLoudnessScore (final)', err);
    }
    
    return result;
}

// 4. CALCULAR SCORE DE DINÂMICA (LRA, DR, Crest Consistency, Fator de Crista)
// 🔄 ATUALIZADO: Agora usa getMetricBounds para suportar min/max assimétrico
function calculateDynamicsScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // ═══════════════════════════════════════════════════════════════════════
    // 📊 Dynamic Range (DR) - métrica principal de dinâmica - AGORA COM MIN/MAX
    // ═══════════════════════════════════════════════════════════════════════
    const drValue = metrics.dynamic_range || tech.dynamicRange;
    if (Number.isFinite(drValue)) {
        const drBounds = getMetricBounds(refData, 'dr');
        
        if (drBounds) {
            // Usar novo sistema de bounds (min/max)
            const result = calculateMetricScoreWithBounds(drValue, drBounds, { metricKey: 'dr' });
            if (result.score !== null) {
                scores.push(result.score);
                console.log(`📊 Dynamic Range: ${drValue.toFixed(1)} dB dentro de [${drBounds.min.toFixed(1)}, ${drBounds.max.toFixed(1)}] = ${result.score}% (${result.status})`);
            }
        } else if (Number.isFinite(refData.dr_target) && Number.isFinite(refData.tol_dr)) {
            // Fallback para sistema legado
            const score = calculateMetricScore(drValue, refData.dr_target, refData.tol_dr);
            if (score !== null) {
                scores.push(score);
                console.log(`📊 Dynamic Range: ${drValue} vs ${refData.dr_target} (±${refData.tol_dr}) = ${score}% [LEGADO]`);
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // 📊 LRA (Loudness Range) - variação de loudness
    // ═══════════════════════════════════════════════════════════════════════
    const lraValue = metrics.lra || tech.lra;
    if (Number.isFinite(lraValue) && Number.isFinite(refData.lra_target) && Number.isFinite(refData.tol_lra)) {
        const score = calculateMetricScore(lraValue, refData.lra_target, refData.tol_lra);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 LRA: ${lraValue} vs ${refData.lra_target} (±${refData.tol_lra}) = ${score}%`);
        }
    }
    
    // Crest Factor (já incluído em Loudness, mas importante para dinâmica também)
    const crestValue = tech.crestFactor || metrics.crest_factor;
    if (Number.isFinite(crestValue) && refData.crest_target && Number.isFinite(refData.crest_target)) {
        const tolerance = refData.tol_crest || 2.0;
        const score = calculateMetricScore(crestValue, refData.crest_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Crest Factor (Dinâmica): ${crestValue} vs ${refData.crest_target} (±${tolerance}) = ${score}%`);
        }
    }
    
    // Compressão detectada (se disponível)
    const compressionRatio = tech.compressionRatio;
    if (Number.isFinite(compressionRatio) && refData.compression_target && Number.isFinite(refData.compression_target)) {
        const tolerance = refData.tol_compression || 1.0;
        const score = calculateMetricScore(compressionRatio, refData.compression_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Compressão: ${compressionRatio} vs ${refData.compression_target} (±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar média dos scores válidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateDynamicsScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`📊 Score Dinâmica Final: ${result}% (média de ${scores.length} métricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateDynamicsScore',
            value: { dr: metrics.dynamic_range || tech.dynamicRange, lra: metrics.lra || tech.lra, crest: tech.crestFactor || metrics.crest_factor, compression: tech.compressionRatio },
            target: { dr: refData.dr_target, lra: refData.lra_target, crest: refData.crest_target, compression: refData.compression_target },
            diff: 'ver logs individuais',
            tolerance: { dr: refData.tol_dr, lra: refData.tol_lra, crest: refData.tol_crest, compression: refData.tol_compression },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateDynamicsScore (final)', err);
    }
    
    return result;
}

// 5. CALCULAR SCORE DE ESTÉREO (Largura, Correlação, Balanço L/R)
function calculateStereoScore(analysis, refData) {
    if (!analysis || !refData) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    // Correlação Estéreo (principal métrica de estéreo)
    const stereoValue = metrics.stereo_correlation || tech.stereoCorrelation;
    if (Number.isFinite(stereoValue) && Number.isFinite(refData.stereo_target) && Number.isFinite(refData.tol_stereo)) {
        const score = calculateMetricScore(stereoValue, refData.stereo_target, refData.tol_stereo);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Correlação Estéreo: ${stereoValue} vs ${refData.stereo_target} (±${refData.tol_stereo}) = ${score}%`);
        }
    }
    
    // Largura Estéreo (Width)
    const widthValue = tech.stereoWidth || metrics.stereo_width;
    if (Number.isFinite(widthValue) && refData.width_target && Number.isFinite(refData.width_target)) {
        const tolerance = refData.tol_width || 0.2;
        const score = calculateMetricScore(widthValue, refData.width_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Largura Estéreo: ${widthValue} vs ${refData.width_target} (±${tolerance}) = ${score}%`);
        }
    }
    
    // Balanço L/R (se disponível)
    const balanceValue = tech.stereoBalance || metrics.stereo_balance;
    if (Number.isFinite(balanceValue)) {
        // Balanço ideal é 0 (perfeitamente centrado)
        const balanceTarget = refData.balance_target || 0.0;
        const balanceTolerance = refData.tol_balance || 0.1; // 10% de tolerância
        const score = calculateMetricScore(balanceValue, balanceTarget, balanceTolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Balanço L/R: ${balanceValue} vs ${balanceTarget} (±${balanceTolerance}) = ${score}%`);
        }
    }
    
    // Separação de canais (se disponível)
    const separationValue = tech.channelSeparation || metrics.channel_separation;
    if (Number.isFinite(separationValue) && refData.separation_target && Number.isFinite(refData.separation_target)) {
        const tolerance = refData.tol_separation || 5.0;
        const score = calculateMetricScore(separationValue, refData.separation_target, tolerance);
        if (score !== null) {
            scores.push(score);
            console.log(`📊 Separação de Canais: ${separationValue} vs ${refData.separation_target} (±${tolerance}) = ${score}%`);
        }
    }
    
    // Retornar média dos scores válidos
    if (scores.length === 0) {
        try {
            console.log('[AUDIT-SCORE]', {
                func: 'calculateStereoScore',
                value: 'N/A',
                target: 'N/A',
                diff: 'N/A',
                tolerance: 'N/A',
                result: null,
                condition: 'no valid scores',
                scoresCount: 0
            });
        } catch (err) {
            console.warn('[AUDIT-ERROR]', 'calculateStereoScore (no scores)', err);
        }
        return null;
    }
    
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    console.log(`🎧 Score Estéreo Final: ${result}% (média de ${scores.length} métricas)`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateStereoScore',
            value: { correlation: metrics.stereo_correlation || tech.stereoCorrelation, width: tech.stereoWidth || metrics.stereo_width, balance: tech.stereoBalance || metrics.stereo_balance, separation: tech.channelSeparation || metrics.channel_separation },
            target: { correlation: refData.stereo_target, width: refData.width_target, balance: refData.balance_target, separation: refData.separation_target },
            diff: 'ver logs individuais',
            tolerance: { correlation: refData.tol_stereo, width: refData.tol_width, balance: refData.tol_balance, separation: refData.tol_separation },
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateStereoScore (final)', err);
    }
    
    return result;
}

// 6A. CALCULAR SCORE DE FREQUÊNCIA EM MODO REFERENCE (COMPARAÇÃO DIRETA A vs B)
// 🎯 HELPER: Extrair bandas de qualquer analysis object (normaliza estruturas variadas)
function extractBandsFromAnalysis(analysis) {
    if (!analysis) return { bands: null, source: 'null-analysis' };
    
    // Prioridade de leitura:
    // 1) analysis.bands (formato direto)
    // 2) analysis.technicalData.bands (caminho principal)
    // 3) analysis.technicalData.spectralBands (array)
    // 4) analysis.technicalData.spectral_balance (legado)
    // 5) analysis.metrics.bands (centralizado)
    
    let rawBands = null;
    let source = 'unknown';
    
    if (analysis.bands && Object.keys(analysis.bands).length > 0) {
        rawBands = analysis.bands;
        source = 'analysis.bands';
    } else if (analysis.technicalData?.bands && Object.keys(analysis.technicalData.bands).length > 0) {
        rawBands = analysis.technicalData.bands;
        source = 'technicalData.bands';
    } else if (analysis.technicalData?.spectralBands) {
        rawBands = analysis.technicalData.spectralBands;
        source = 'technicalData.spectralBands';
    } else if (analysis.technicalData?.spectral_balance && Object.keys(analysis.technicalData.spectral_balance).length > 0) {
        rawBands = analysis.technicalData.spectral_balance;
        source = 'technicalData.spectral_balance';
    } else if (analysis.metrics?.bands && Object.keys(analysis.metrics.bands).length > 0) {
        rawBands = analysis.metrics.bands;
        source = 'metrics.bands';
    }
    
    if (!rawBands) {
        return { bands: null, source: 'not-found' };
    }
    
    // 🎯 NORMALIZAR: Se for array, converter para map {sub:{energy_db}, bass:{}, ...}
    if (Array.isArray(rawBands)) {
        const normalized = {};
        for (const band of rawBands) {
            if (!band || !band.name) continue;
            
            // Normalizar nome da banda (remover espaços, lowercasing)
            const key = band.name.toLowerCase().replace(/\s+/g, '');
            
            // Extrair energia (aceitar energy_db, energyDb, db, energy)
            const energy = band.energy_db ?? band.energyDb ?? band.db ?? band.energy;
            
            if (Number.isFinite(energy)) {
                normalized[key] = { energy_db: energy };
            }
        }
        
        console.log('[EXTRACT-BANDS] 🔄 Normalizado array → map:', {
            source,
            originalLength: rawBands.length,
            normalizedKeys: Object.keys(normalized)
        });
        
        return { bands: normalized, source: source + ' (normalized-from-array)' };
    }
    
    // 🎯 Já é objeto: garantir que tem energy_db em cada banda
    const normalized = {};
    for (const [key, value] of Object.entries(rawBands)) {
        if (typeof value === 'object' && value !== null) {
            // Já tem estrutura {energy_db: number} ou similar
            const energy = value.energy_db ?? value.energyDb ?? value.db ?? value.energy ?? value.rms_db ?? value.value;
            if (Number.isFinite(energy)) {
                normalized[key] = { energy_db: energy };
            }
        } else if (Number.isFinite(value)) {
            // É um número direto: banda: -24.5
            normalized[key] = { energy_db: value };
        }
    }
    
    console.log('[EXTRACT-BANDS] ✅ Extraído:', {
        source,
        keysFound: Object.keys(normalized),
        sampleValues: Object.keys(normalized).slice(0, 3).map(k => `${k}:${normalized[k].energy_db.toFixed(1)}dB`)
    });
    
    return { bands: normalized, source };
}

function calculateFrequencyScoreReference(bandsA, bandsB) {
    console.log('[FREQ-SCORE-REF] 🎵 Calculando score de frequência em modo reference (A vs B) - VERSÃO CORRIGIDA');
    
    if (!bandsA || !bandsB) {
        console.warn('[FREQ-SCORE-REF] ⚠️ Bandas ausentes:', { hasA: !!bandsA, hasB: !!bandsB });
        return null;
    }
    
    // 8 bandas principais + aliases (incluindo low_bass, upper_bass)
    const bandKeys = ['sub', 'low_bass', 'upper_bass', 'bass', 'low_mid', 'lowMid', 'mid', 'high_mid', 'highMid', 'presence', 'presenca', 'air', 'brilho'];
    const aliases = {
        'low_bass': 'bass',
        'upper_bass': 'bass',
        'low_mid': 'lowMid',
        'high_mid': 'highMid',
        'brilho': 'air',
        'presenca': 'presence'
    };
    
    const bandsData = [];
    const processedKeys = new Set();
    
    for (const key of bandKeys) {
        // Pular se já processamos essa banda (evitar duplicatas com aliases)
        const canonicalKey = aliases[key] || key;
        if (processedKeys.has(canonicalKey)) continue;
        
        // Buscar banda em A
        let valueA = null;
        if (bandsA[key] !== undefined) {
            valueA = typeof bandsA[key] === 'object' ? 
                     (bandsA[key].energy_db ?? bandsA[key].rms_db ?? bandsA[key].value) : 
                     bandsA[key];
        }
        
        // Buscar banda em B (com aliases)
        let valueB = null;
        if (bandsB[key] !== undefined) {
            valueB = typeof bandsB[key] === 'object' ? 
                     (bandsB[key].energy_db ?? bandsB[key].rms_db ?? bandsB[key].value) : 
                     bandsB[key];
        }
        
        if (Number.isFinite(valueA) && Number.isFinite(valueB)) {
            const absDelta = Math.abs(valueA - valueB);
            
            // 🎯 CALCULAR SEVERIDADE (mesma lógica de buildComparativeAISuggestions)
            let severity = 'OK';
            if (absDelta >= 4.0) {
                severity = 'CRÍTICA';
            } else if (absDelta >= 2.5) {
                severity = 'ALTA';
            } else if (absDelta >= 1.5) {
                severity = 'ATENÇÃO';
            }
            
            bandsData.push({
                key: canonicalKey,
                valueA,
                valueB,
                delta: absDelta,
                severity
            });
            
            processedKeys.add(canonicalKey);
            
            console.log(`[FREQ-SCORE-REF] ${key}: A=${valueA.toFixed(2)}dB, B=${valueB.toFixed(2)}dB, Δ=${absDelta.toFixed(2)}dB → ${severity}`);
        }
    }
    
    if (bandsData.length === 0) {
        console.warn('[FREQ-SCORE-REF] ⚠️ Nenhuma banda válida encontrada');
        return null;
    }
    
    // 🎯 NOVO CÁLCULO BASEADO EM SEVERIDADES
    // Penalidades proporcionais:
    // CRÍTICA → -20 pontos
    // ALTA → -10 pontos
    // ATENÇÃO → -5 pontos
    // OK → 0 pontos
    
    const baseScore = 100;
    const penaltyMap = {
        'CRÍTICA': 20,
        'ALTA': 10,
        'ATENÇÃO': 5,
        'OK': 0
    };
    
    const severityCounts = {
        'CRÍTICA': 0,
        'ALTA': 0,
        'ATENÇÃO': 0,
        'OK': 0
    };
    
    let totalPenalty = 0;
    
    for (const band of bandsData) {
        const penalty = penaltyMap[band.severity] || 0;
        totalPenalty += penalty;
        severityCounts[band.severity]++;
    }
    
    // Normalizar penalidade: cada banda pode contribuir no máximo 20 pontos de penalidade
    // Score = 100 - (totalPenalty * (100 / (bandsCount * 20)))
    // Isso garante que:
    // - Todas OK → 100
    // - Todas CRÍTICA → ~0
    // - Mix de severidades → intermediário
    const maxPossiblePenalty = bandsData.length * 20;
    const normalizedPenalty = (totalPenalty / maxPossiblePenalty) * 100;
    const rawScore = baseScore - normalizedPenalty;
    const score = Math.max(0, Math.min(100, Math.round(rawScore)));
    
    console.log(`[FREQ-SCORE-REF] 📊 Estatísticas:`, {
        totalBandas: bandsData.length,
        criticas: severityCounts['CRÍTICA'],
        altas: severityCounts['ALTA'],
        atencoes: severityCounts['ATENÇÃO'],
        ok: severityCounts['OK'],
        totalPenalty,
        maxPossiblePenalty,
        normalizedPenalty: normalizedPenalty.toFixed(2),
        scoreFinal: score
    });
    
    console.log(`[FREQ-SCORE-REF] ✅ Score corrigido: ${score}% (anterior seria ~${Math.round(100 - (bandsData.reduce((sum, b) => sum + b.delta, 0) / bandsData.length * 10))}% com cálculo antigo)`);
    
    return score;
}

// 6B. CALCULAR SCORE DE FREQUÊNCIA (BANDAS ESPECTRAIS)
function calculateFrequencyScore(analysis, refData) {
    if (!analysis || !refData || !refData.bands) return null;
    
    // 🎯 CASCATA COMPLETA DE FALLBACKS (confirmada segura em CONFIRMACAO_MIGRACAO_TECHNICALDATA_BANDS.md)
    // Prioridade 1: technicalData.bands (caminho principal - SEMPRE existe)
    // Prioridade 2: metrics.bands (compatibilidade - pode não existir)
    // Prioridade 3: technicalData.spectral_balance (fonte real - alias de bands)
    // Prioridade 4: technicalData.bandEnergies (legado)
    const technicalBands = analysis.technicalData?.bands;
    const centralizedBands = analysis.metrics?.bands;
    const spectralBalance = analysis.technicalData?.spectral_balance;
    const legacyBandEnergies = analysis.technicalData?.bandEnergies;

    const bandsToUse = 
        (technicalBands && Object.keys(technicalBands).length > 0) ? technicalBands :
        (centralizedBands && Object.keys(centralizedBands).length > 0) ? centralizedBands :
        (spectralBalance && Object.keys(spectralBalance).length > 0) ? spectralBalance :
        legacyBandEnergies;

    console.log('[FREQ-SCORE] 🎵 Fonte de bandas:', 
        technicalBands ? '✅ technicalData.bands (prioridade 1)' : 
        centralizedBands ? '⚠️ metrics.bands (fallback 2)' : 
        spectralBalance ? '⚠️ spectral_balance (fallback 3)' : 
        '⚠️ bandEnergies (fallback 4 - legado)');
    
    console.log('[FREQ-SCORE] 🎵 Bandas disponíveis:', bandsToUse ? Object.keys(bandsToUse) : 'NENHUMA');
    
    if (!bandsToUse) return null;
    
    const scores = [];
    const isReferenceMode = refData._isReferenceMode === true;
    const hasRefContext = hasActiveReferenceContext();
    
    console.log('🎵 Calculando Score de Frequência...', {
        mode: isReferenceMode ? 'REFERENCE (valores diretos)' : 'GENRE (target_range)',
        bandsAvailable: Object.keys(refData.bands),
        hasRefContext
    });
    
    // 🎯 MODO REFERENCE: Usar comparação direta A vs B
    if (isReferenceMode && hasRefContext) {
        console.log('[FREQ-SCORE] 🔄 Modo reference detectado - extraindo bandas de análises');
        
        // 🎯 HOTFIX B: Helper local para extrair bandas (aceita technicalData.bands e spectralBands)
        const extractBandsLocal = (analysis, label) => {
            if (!analysis) return { bandsMap: null, source: 'null-analysis' };
            
            // Prioridades:
            // 1. technicalData.bands (objeto com {sub:{energy_db}, bass:{}, ...})
            // 2. technicalData.spectralBands (array com [{name, energy_db}, ...])
            // 3. bands direto (fallback)
            const techBands = analysis.technicalData?.bands;
            const spectralBands = analysis.technicalData?.spectralBands;
            const directBands = analysis.bands;
            
            let rawBands = null;
            let source = 'unknown';
            
            if (techBands && typeof techBands === 'object' && Object.keys(techBands).length > 0) {
                rawBands = techBands;
                source = 'technicalData.bands';
            } else if (spectralBands && Array.isArray(spectralBands) && spectralBands.length > 0) {
                // Converter array [{name, energy_db}] para map {sub: {energy_db}}
                rawBands = {};
                for (const band of spectralBands) {
                    if (band && band.name) {
                        const key = band.name.toLowerCase().replace(/\s+/g, '');
                        const energy = band.energy_db ?? band.energyDb ?? band.db ?? band.energy;
                        if (Number.isFinite(energy)) {
                            rawBands[key] = { energy_db: energy };
                        }
                    }
                }
                source = 'technicalData.spectralBands (array→map)';
            } else if (directBands && typeof directBands === 'object' && Object.keys(directBands).length > 0) {
                rawBands = directBands;
                source = 'analysis.bands';
            }
            
            if (!rawBands) {
                console.warn(`[FREQ-SCORE] ⚠️ ${label}: Nenhuma banda encontrada`);
                return { bandsMap: null, source: 'not-found' };
            }
            
            // Normalizar para garantir energy_db
            const normalized = {};
            for (const [key, value] of Object.entries(rawBands)) {
                if (typeof value === 'object' && value !== null) {
                    const energy = value.energy_db ?? value.energyDb ?? value.db ?? value.energy ?? value.rms_db;
                    if (Number.isFinite(energy)) {
                        normalized[key] = { energy_db: energy };
                    }
                } else if (Number.isFinite(value)) {
                    normalized[key] = { energy_db: value };
                }
            }
            
            console.log(`[FREQ-SCORE] ✅ ${label}: ${Object.keys(normalized).length} bandas de ${source}`);
            return { bandsMap: normalized, source };
        };
        
        // 🎯 HOTFIX B: Tentar usar stateV3.reference.bands primeiro (cache), senão extrair
        const stateV3 = window.__soundyState || {};
        let userBandsA = null;
        let refBandsB = null;
        
        if (stateV3?.reference?.bands?.userBands && stateV3?.reference?.bands?.refBands) {
            console.log('[FREQ-SCORE] ✅ Usando bandas CACHEADAS de stateV3.reference.bands');
            userBandsA = stateV3.reference.bands.userBands;
            refBandsB = stateV3.reference.bands.refBands;
        } else {
            console.log('[FREQ-SCORE] ⚠️ Cache ausente - extraindo bandas diretamente de análises');
            
            const userAnalysisRef = stateV3?.reference?.userAnalysis || analysis;
            const refAnalysisRef = stateV3?.reference?.referenceAnalysis || refData._referenceAnalysisFull;
            
            const extractedA = extractBandsLocal(userAnalysisRef, 'userAnalysis');
            const extractedB = extractBandsLocal(refAnalysisRef, 'referenceAnalysis');
            
            userBandsA = extractedA.bandsMap;
            refBandsB = extractedB.bandsMap;
            
            // 🎯 CACHEAR para próximas chamadas
            if (userBandsA && refBandsB) {
                stateV3.reference = stateV3.reference || {};
                stateV3.reference.bands = {
                    userBands: userBandsA,
                    refBands: refBandsB
                };
                stateV3.reference.analysis = stateV3.reference.analysis || {};
                stateV3.reference.analysis.bands = refBandsB;
                window.__soundyState = stateV3;
                console.log('[FREQ-SCORE] ✅ Bandas cacheadas em stateV3.reference.bands');
            }
        }
        
        // 🛡️ GUARDRAILS
        if (!userBandsA || !refBandsB) {
            console.error('[FREQ-SCORE] ❌ ERRO: Bandas ausentes após extração!');
            console.error('[FREQ-SCORE] userBandsA:', !!userBandsA, 'refBandsB:', !!refBandsB);
            return null;
        }
        
        // 🛡️ GUARDRAIL: Validar âncoras B
        const anchorKeysB = ['sub', 'bass', 'mid'].filter(k => {
            const val = refBandsB[k]?.energy_db ?? refBandsB[k];
            return Number.isFinite(val);
        });
        
        if (anchorKeysB.length === 0) {
            console.error('[FREQ-SCORE] ❌ ERRO: refBands B sem âncoras válidas (sub/bass/mid)!');
            console.error('[FREQ-SCORE] refBands B keys:', Object.keys(refBandsB));
            return null;
        }
        
        // 🛡️ GUARDRAIL: Detectar same reference
        if (userBandsA === refBandsB) {
            console.error('[FREQ-SCORE] ❌ ERRO: userBands === refBands (same object reference)!');
            return null;
        }
        
        // 🛡️ GUARDRAIL: Detectar valores idênticos (warning apenas)
        let identicalCount = 0;
        for (const key of ['sub', 'bass', 'mid']) {
            const valA = userBandsA[key]?.energy_db ?? userBandsA[key];
            const valB = refBandsB[key]?.energy_db ?? refBandsB[key];
            if (Number.isFinite(valA) && Number.isFinite(valB) && Math.abs(valA - valB) < 0.001) {
                identicalCount++;
            }
        }
        
        if (identicalCount === 3) {
            console.warn('[FREQ-SCORE] ⚠️ SUSPEITO: sub/bass/mid idênticas entre A e B!');
        }
        
        console.log('[FREQ-SCORE-AUDIT] 🔍 Âncoras validadas:', {
            subA: userBandsA.sub?.energy_db ?? userBandsA.sub,
            subB: refBandsB.sub?.energy_db ?? refBandsB.sub,
            bassA: userBandsA.bass?.energy_db ?? userBandsA.bass,
            bassB: refBandsB.bass?.energy_db ?? refBandsB.bass
        });
        
        return calculateFrequencyScoreReference(userBandsA, refBandsB);
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🎯 V3.3: USO DO SISTEMA DE ALIASES CENTRALIZADO
    // ═══════════════════════════════════════════════════════════════════════════
    const BKA = window.BandKeyAliases || {
        // Fallback inline caso o módulo não carregue
        CANONICAL_KEYS: ['sub', 'bass', 'low_mid', 'mid', 'high_mid', 'presence', 'brilho'],
        META_KEYS: ['totalPercentage', '_status', 'status', 'timestamp'],
        normalizeBandKey: (key) => {
            if (!key) return null;
            const aliases = {
                'sub': ['sub', 'sub_bass', 'subBass'],
                'bass': ['bass', 'low_bass', 'lowBass'],
                'low_mid': ['low_mid', 'lowMid', 'low-mid'],
                'mid': ['mid', 'mids'],
                'high_mid': ['high_mid', 'highMid', 'high-mid'],
                'presence': ['presence', 'presenca'],
                'brilho': ['brilho', 'air', 'brilliance', 'highs']
            };
            const lk = key.toLowerCase();
            for (const [canon, arr] of Object.entries(aliases)) {
                if (arr.some(a => a.toLowerCase() === lk)) return canon;
            }
            return null;
        },
        extractEnergyDb: (val) => {
            if (typeof val === 'number') return val;
            if (val?.energy_db !== undefined) return val.energy_db;
            if (val?.energyDb !== undefined) return val.energyDb;
            if (val?.db !== undefined) return val.db;
            if (val?.rms_db !== undefined) return val.rms_db;
            return null;
        },
        isMetaKey: (key) => ['totalPercentage', '_status', 'status', 'timestamp', '_source'].includes(key)
    };
    
    // Diagnóstico inicial
    const userBandsRaw = bandsToUse || {};
    const refBandsRaw = refData.bands || {};
    
    console.group('🎵 [FREQ-SCORE-V3.3] Calculando Score de Frequência');
    console.log('📊 Bandas do usuário (raw):', Object.keys(userBandsRaw));
    console.log('📊 Bandas de referência (raw):', Object.keys(refBandsRaw));
    
    // Mapear bandas com diagnóstico
    const bandsUsedForScore = [];
    const bandsIgnoredNoTarget = [];
    const bandsIgnoredNoUserValue = [];
    const targetsFoundPerBand = {};
    
    // Processar cada banda canônica
    BKA.CANONICAL_KEYS.forEach(canonical => {
        // Tentar encontrar valor do usuário
        let userValue = null;
        let userSource = null;
        
        // Buscar com aliases
        for (const key of Object.keys(userBandsRaw)) {
            if (BKA.normalizeBandKey(key) === canonical) {
                userValue = BKA.extractEnergyDb(userBandsRaw[key]);
                userSource = key;
                break;
            }
        }
        
        // Buscar target de referência
        let targetDb = null;
        let tolDb = null;
        let refSource = null;
        
        for (const key of Object.keys(refBandsRaw)) {
            if (BKA.normalizeBandKey(key) === canonical) {
                const refVal = refBandsRaw[key];
                refSource = key;
                
                if (typeof refVal === 'number') {
                    targetDb = refVal;
                    tolDb = 3.0;
                } else if (refVal?.target_range?.min !== undefined && refVal?.target_range?.max !== undefined) {
                    targetDb = (refVal.target_range.min + refVal.target_range.max) / 2;
                    tolDb = (refVal.target_range.max - refVal.target_range.min) / 2;
                } else if (refVal?.target_db !== undefined) {
                    targetDb = refVal.target_db;
                    tolDb = refVal.tol_db ?? 3.0;
                } else {
                    targetDb = BKA.extractEnergyDb(refVal);
                    tolDb = 3.0;
                }
                break;
            }
        }
        
        targetsFoundPerBand[canonical] = {
            userValue,
            userSource,
            targetDb,
            tolDb,
            refSource,
            hasMatch: userValue !== null && targetDb !== null
        };
        
        // Calcular score se temos ambos valores
        if (userValue !== null && targetDb !== null) {
            const score = calculateMetricScore(userValue, targetDb, tolDb);
            if (score !== null) {
                scores.push(score);
                bandsUsedForScore.push(canonical);
                console.log(`✅ ${canonical.toUpperCase()}: ${userValue.toFixed(1)}dB vs ${targetDb.toFixed(1)}dB (±${tolDb.toFixed(1)}) = ${score}%`);
            }
        } else if (userValue === null) {
            bandsIgnoredNoUserValue.push(canonical);
            console.log(`🔇 ${canonical.toUpperCase()}: SEM VALOR DO USUÁRIO (source tentada: ${userSource || 'nenhuma'})`);
        } else if (targetDb === null) {
            bandsIgnoredNoTarget.push(canonical);
            console.log(`⚠️ ${canonical.toUpperCase()}: SEM TARGET DE REFERÊNCIA (userValue=${userValue?.toFixed(1)}dB)`);
        }
    });
    
    // Log de diagnóstico completo
    console.log('📋 RESUMO:', {
        bandsUsedForScore,
        bandsUsedCount: bandsUsedForScore.length,
        bandsIgnoredNoTarget,
        bandsIgnoredNoUserValue,
        targetsFoundPerBand
    });
    console.groupEnd();
    
    // Se não encontrou scores válidos, retornar null
    if (scores.length === 0) {
        console.warn('[FREQ-SCORE-V3.3] ⚠️ Nenhuma banda válida para calcular score');
        return null;
    }
    
    // Média aritmética simples das bandas válidas
    const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    const result = Math.round(average);
    
    console.log(`🎵 Score Frequência Final: ${result}% (média de ${scores.length} bandas)`);
    console.log(`🎵 Scores individuais: [${scores.join(', ')}]`);
    console.log(`🎵 Bandas usadas: [${bandsUsedForScore.join(', ')}]`);
    
    return result;
}

// 7. CALCULAR SCORE TÉCNICO
// 7. CALCULAR SCORE TÉCNICO (Clipping, DC Offset, THD)
function calculateTechnicalScore(analysis, refData) {
    if (!analysis) return null;
    
    const tech = analysis.technicalData || {};
    const metrics = analysis.metrics || {};
    const scores = [];
    
    console.log('🔧 Calculando Score Técnico...');
    
    // 1. CLIPPING - Deve ser próximo de 0% (PENALIZAÇÃO FORTE PARA PROBLEMAS CRÍTICOS)
    const clippingValue = tech.clipping || metrics.clipping || 0;
    if (Number.isFinite(clippingValue)) {
        let clippingScore = 100;
        
        if (clippingValue <= 0.001) { // ≤ 0.1% = perfeito
            clippingScore = 100;
        } else if (clippingValue <= 0.005) { // ≤ 0.5% = bom
            clippingScore = 80;
        } else if (clippingValue <= 0.01) { // ≤ 1% = aceitável
            clippingScore = 60;
        } else if (clippingValue <= 0.02) { // ≤ 2% = problemático
            clippingScore = 40;
        } else { // > 2% = crítico
            clippingScore = 20;
        }
        
        scores.push(clippingScore);
        console.log(`🔧 Clipping: ${(clippingValue * 100).toFixed(3)}% = ${clippingScore}%`);
    }
    
    // 2. DC OFFSET - Deve ser próximo de 0
    const dcOffsetValue = Math.abs(tech.dcOffset || metrics.dc_offset || 0);
    if (Number.isFinite(dcOffsetValue)) {
        let dcScore = 100;
        
        if (dcOffsetValue <= 0.001) { // ≤ 0.1% = perfeito
            dcScore = 100;
        } else if (dcOffsetValue <= 0.005) { // ≤ 0.5% = bom
            dcScore = 80;
        } else if (dcOffsetValue <= 0.01) { // ≤ 1% = aceitável
            dcScore = 60;
        } else if (dcOffsetValue <= 0.02) { // ≤ 2% = problemático
            dcScore = 40;
        } else { // > 2% = crítico
            dcScore = 20;
        }
        
        scores.push(dcScore);
        console.log(`🔧 DC Offset: ${dcOffsetValue.toFixed(4)} = ${dcScore}%`);
    }
    
    // 3. THD (Total Harmonic Distortion) - Deve ser baixo
    const thdValue = tech.thd || metrics.thd || 0;
    if (Number.isFinite(thdValue)) {
        let thdScore = 100;
        
        if (thdValue <= 0.001) { // ≤ 0.1% = perfeito
            thdScore = 100;
        } else if (thdValue <= 0.005) { // ≤ 0.5% = bom
            thdScore = 80;
        } else if (thdValue <= 0.01) { // ≤ 1% = aceitável
            thdScore = 60;
        } else if (thdValue <= 0.02) { // ≤ 2% = problemático
            thdScore = 40;
        } else { // > 2% = crítico
            thdScore = 20;
        }
        
        scores.push(thdScore);
        console.log(`🔧 THD: ${(thdValue * 100).toFixed(3)}% = ${thdScore}%`);
    }
    
    // 4. PROBLEMAS DETECTADOS (Issues) - PENALIZAÇÃO GRADUAL
    const issues = analysis.issues || [];
    let issuesScore = 100;
    
    issues.forEach(issue => {
        switch (issue.severity) {
            case 'critical':
                issuesScore = Math.max(20, issuesScore - 30); // Não zerar, mínimo 20
                console.log(`🔧 Issue CRÍTICO: ${issue.description} (-30%)`);
                break;
            case 'high':
                issuesScore = Math.max(40, issuesScore - 20); // Mínimo 40
                console.log(`🔧 Issue ALTO: ${issue.description} (-20%)`);
                break;
            case 'medium':
                issuesScore = Math.max(60, issuesScore - 10); // Mínimo 60
                console.log(`🔧 Issue MÉDIO: ${issue.description} (-10%)`);
                break;
            case 'low':
                issuesScore = Math.max(80, issuesScore - 5); // Mínimo 80
                console.log(`🔧 Issue BAIXO: ${issue.description} (-5%)`);
                break;
        }
    });
    
    if (issues.length > 0) {
        scores.push(issuesScore);
        console.log(`🔧 Issues Gerais: ${issuesScore}% (${issues.length} problemas)`);
    }
    
    // 🎯 NOVA VALIDAÇÃO TRUE PEAK (CORREÇÃO CRÍTICA)
    const truePeak = tech.truePeakDbtp || metrics.truePeakDbtp;
    let truePeakScore = 100; // Score padrão se não houver dados
    let hasTruePeakData = false;
    
    if (Number.isFinite(truePeak)) {
        hasTruePeakData = true;
        console.log(`🔧 True Peak: ${truePeak.toFixed(2)} dBTP`);
        
        if (truePeak <= -1.5) { // Excelente
            truePeakScore = 100;
            console.log(`🔧 True Peak EXCELENTE: ${truePeakScore}%`);
        } else if (truePeak <= -1.0) { // Ideal
            truePeakScore = 90;
            console.log(`🔧 True Peak IDEAL: ${truePeakScore}%`);
        } else if (truePeak <= -0.5) { // Bom
            truePeakScore = 80;
            console.log(`🔧 True Peak BOM: ${truePeakScore}%`);
        } else if (truePeak <= 0.0) { // Aceitável
            truePeakScore = 70;
            console.log(`🔧 True Peak ACEITÁVEL: ${truePeakScore}%`);
        } else if (truePeak <= 0.5) { // Problemático
            truePeakScore = 40;
            console.log(`🔧 True Peak PROBLEMÁTICO: ${truePeakScore}%`);
        } else { // Crítico
            truePeakScore = 20;
            console.log(`🔧 True Peak CRÍTICO: ${truePeakScore}%`);
        }
        
        scores.push(truePeakScore);
    }
    
    // Se não temos métricas técnicas específicas, usar apenas issues
    if (scores.length === 0) {
        const result = Math.max(20, Math.round(issuesScore)); // Nunca zerar
        console.log(`🔧 Score Técnico Final (apenas issues): ${result}%`);
        return result;
    }
    
    // Média normalizada de todas as métricas técnicas (0-100)
    let average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    let result = Math.max(20, Math.round(average)); // Nunca zerar completamente
    
    // 🎯 V3.4: REMOVIDO HARD CAP DUPLICADO - O gate proporcional no V3-GATE já cuida disso
    // Antes havia dupla punição: score técnico baixo + gate final capando novamente
    // Agora: score técnico reflete a qualidade, gate final aplica cap proporcional se necessário
    
    console.log(`🔧 Score Técnico Final: ${result}% (média de ${scores.length} métricas${hasTruePeakData ? ', True Peak incluído' : ''})`);
    
    try {
        console.log('[AUDIT-SCORE]', {
            func: 'calculateTechnicalScore',
            value: { clipping: tech.clipping || metrics.clipping, dcOffset: tech.dcOffset || metrics.dc_offset, thd: tech.thd || metrics.thd, truePeak: truePeak, issues: issues.length },
            target: 'valores ideais (0 para clipping/dc/thd, <0 para truePeak)',
            diff: 'N/A (avaliação por faixas)',
            tolerance: 'N/A',
            result,
            condition: 'average of ' + scores.length + ' metrics',
            individualScores: scores,
            average,
            hasTruePeakData
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateTechnicalScore (final)', err);
    }
    
    return result;
}

// 8. FUNÇÃO PRINCIPAL: CALCULAR TODOS OS SCORES
function calculateAnalysisScores(analysis, refData, genre = null) {
    console.log('🎯 Calculando scores da análise...', { genre });
    
    // 🎯 [FLOW-FIX] Métricas recebidas dentro de calculateAnalysisScores
    console.log("[FLOW-FIX] Métricas recebidas dentro de calculateAnalysisScores:", {
        loudness: analysis.loudness,
        metrics: analysis.metrics,
        technicalData: analysis.technicalData
    });
    
    // 🎯 [GENRE-FIX] Targets finais entregues ao score
    console.log("[GENRE-FIX] Targets finais entregues ao score:", {
        lufs_target: refData?.lufs_target,
        true_peak_target: refData?.true_peak_target,
        dr_target: refData?.dr_target,
        stereo_target: refData?.stereo_target,
        lra_target: refData?.lra_target,
        bands: refData?.bands ? Object.keys(refData.bands) : null,
        bandsCount: refData?.bands ? Object.keys(refData.bands).length : 0
    });
    
    // 🎯 MODO GÊNERO: Detectar se é modo gênero e se há targets carregados
    const isGenreMode = SOUNDY_MODE_ENGINE.isGenre();
    
    // 🎯 MODO GÊNERO: Extrair targets de gênero de referenceComparison
    let genreTargetBands = null;
    let genreTargetMetrics = null;
    
    if (isGenreMode && analysis?.referenceComparison) {
        const refComp = analysis.referenceComparison;
        
        // Buscar em múltiplos locais possíveis (estrutura varia entre JSONs)
        const genreKeyLookup = genre || analysis.genre || analysis.genreId;
        const genreData = genreKeyLookup ? refComp[genreKeyLookup] : null;
        
        // 🎯 CORREÇÃO CRÍTICA: Extrair bandas do ROOT primeiro
        if (genreData?.bands) {
            genreTargetBands = genreData.bands;
            console.log('✅ [GENRE-TARGETS] Usando bands do ROOT (correto):', Object.keys(genreTargetBands));
        } else if (genreData?.legacy_compatibility?.bands) {
            genreTargetBands = genreData.legacy_compatibility.bands;
            console.log('⚠️ [GENRE-TARGETS] Usando legacy_compatibility.bands (fallback):', Object.keys(genreTargetBands));
        } else if (genreData?.hybrid_processing?.spectral_bands) {
            genreTargetBands = genreData.hybrid_processing.spectral_bands;
            console.log('⚠️ [GENRE-TARGETS] Usando hybrid_processing.spectral_bands (fallback):', Object.keys(genreTargetBands));
        } else if (refComp.bands) {
            genreTargetBands = refComp.bands;
            console.log('⚠️ [GENRE-TARGETS] Usando bands direto do refComp (fallback):', Object.keys(genreTargetBands));
        }
        
        // 🎯 CORREÇÃO CRÍTICA: Extrair métricas escalares do ROOT primeiro
        if (genreData && genreData.lufs_target !== undefined) {
            // ROOT tem targets válidos (estrutura correta V2)
            genreTargetMetrics = {
                lufs_target: genreData.lufs_target,
                true_peak_target: genreData.true_peak_target,
                dr_target: genreData.dr_target,
                lra_target: genreData.lra_target,
                stereo_target: genreData.stereo_target,
                tol_lufs: genreData.tol_lufs || 1.0,
                tol_true_peak: genreData.tol_true_peak || 0.25,
                tol_dr: genreData.tol_dr || 1.25,
                tol_lra: genreData.tol_lra || 2.5,
                tol_stereo: genreData.tol_stereo || 0.065
            };
            console.log('✅ [GENRE-TARGETS] Métricas extraídas do ROOT (correto):', {
                lufs: genreTargetMetrics.lufs_target,
                peak: genreTargetMetrics.true_peak_target,
                dr: genreTargetMetrics.dr_target,
                stereo: genreTargetMetrics.stereo_target
            });
        } else if (genreData?.legacy_compatibility) {
            // Fallback: legacy_compatibility (estrutura antiga)
            const lc = genreData.legacy_compatibility;
            genreTargetMetrics = {
                lufs_target: lc.lufs_target,
                true_peak_target: lc.true_peak_target,
                dr_target: lc.dr_target,
                lra_target: lc.lra_target,
                stereo_target: lc.stereo_target,
                tol_lufs: lc.tol_lufs || 1.0,
                tol_true_peak: lc.tol_true_peak || 0.25,
                tol_dr: lc.tol_dr || 1.25,
                tol_lra: lc.tol_lra || 2.5,
                tol_stereo: lc.tol_stereo || 0.065
            };
            console.log('⚠️ [GENRE-TARGETS] Métricas extraídas de legacy_compatibility (fallback)');
        } else if (genreData?.hybrid_processing?.original_metrics) {
            // Fallback 2: hybrid_processing (estrutura híbrida)
            const om = genreData.hybrid_processing.original_metrics;
            genreTargetMetrics = {
                lufs_target: om.lufs_integrated,
                true_peak_target: om.true_peak_dbtp,
                dr_target: om.dynamic_range,
                lra_target: om.lra,
                stereo_target: om.stereo_correlation,
                tol_lufs: 1.0,
                tol_true_peak: 0.25,
                tol_dr: 1.25,
                tol_lra: 2.5,
                tol_stereo: 0.065
            };
            console.log('⚠️ [GENRE-TARGETS] Métricas extraídas de hybrid_processing.original_metrics (fallback)');
        }
        
        // 🎯 INJETAR targets de gênero em refData se disponíveis
        if (genreTargetBands && Object.keys(genreTargetBands).length > 0) {
            console.log('✅ [GENRE-TARGETS] Injetando bandas de gênero em refData');
            refData = {
                ...refData,
                bands: genreTargetBands,
                _isReferenceMode: false, // NÃO é modo A/B
                _isGenreMode: true,
                _genreTargetsLoaded: true
            };
            
            // Mesclar métricas se disponíveis
            if (genreTargetMetrics) {
                refData = { ...refData, ...genreTargetMetrics };
            }
        } else {
            console.warn('⚠️ [GENRE-TARGETS] Targets de gênero não encontrados em referenceComparison');
        }
    }
    
    // 🔍 [AUDIT-BANDS-IN-CALC] Log NO INÍCIO do cálculo de scores
    try {
        const refBandsInCalc = refData?.bands || refData?._referenceBands;
        const userBandsInCalc = analysis?.bands || analysis?.technicalData?.spectral_balance || analysis?.metrics?.bands;
        console.log('[AUDIT-BANDS-IN-CALC]', {
            calcHasRefBands: !!refBandsInCalc,
            calcHasUserBands: !!userBandsInCalc,
            refBandsType: typeof refBandsInCalc,
            userBandsType: typeof userBandsInCalc,
            refBandsKeys: refBandsInCalc ? Object.keys(refBandsInCalc) : [],
            userBandsKeys: userBandsInCalc ? Object.keys(userBandsInCalc) : [],
            refBandsSample: refBandsInCalc ? Object.keys(refBandsInCalc).slice(0, 3) : 'undefined',
            userBandsSample: userBandsInCalc ? Object.keys(userBandsInCalc).slice(0, 3) : 'undefined',
            refDataKeys: refData ? Object.keys(refData) : [],
            isReferenceMode: refData?._isReferenceMode,
            isGenreMode: isGenreMode,
            genreTargetsLoaded: refData?._genreTargetsLoaded
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'AUDIT-BANDS-IN-CALC', err);
    }
    
    if (!analysis || !refData) {
        console.warn('⚠️ Dados insuficientes para calcular scores');
        return null;
    }
    
    // Determinar genreKey
    const genreKey = genre ? genre.toLowerCase().replace(/\s+/g, '_') : null;
    
    // ═══════════════════════════════════════════════════════════════════
    // 🎯 V3.5: USAR NOVO SISTEMA UNIFICADO computeScoreV3
    // ═══════════════════════════════════════════════════════════════════
    const mode = window.__soundyState?.render?.mode || 'streaming';
    
    // 🚨 CRÍTICO: soundDestination É A FONTE ÚNICA DA VERDADE PARA TARGETS DE LUFS
    // Deve ser pego de: analysis.soundDestination > window.__SOUNDY_ANALYSIS_MODE__ > 'pista'
    const effectiveSoundDestination = analysis?.soundDestination 
        || window.__SOUNDY_ANALYSIS_MODE__ 
        || getSoundDestinationMode?.() 
        || 'pista';
    
    console.error('╔═══════════════════════════════════════════════════════════╗');
    console.error('║  🎯 CALCULANDO SCORES - soundDestination                  ║');
    console.error('╚═══════════════════════════════════════════════════════════╝');
    console.error('[SCORE-CALC] analysis.soundDestination:', analysis?.soundDestination);
    console.error('[SCORE-CALC] window.__SOUNDY_ANALYSIS_MODE__:', window.__SOUNDY_ANALYSIS_MODE__);
    console.error('[SCORE-CALC] effectiveSoundDestination:', effectiveSoundDestination);
    console.error('\n');
    
    // 🚨 INJETAR soundDestination NO ANALYSIS ANTES DE PASSAR PARA computeScoreV3
    // Isso garante que a função de scoring use o valor correto
    const analysisWithSoundDest = {
        ...analysis,
        soundDestination: effectiveSoundDestination
    };
    
    // Preparar targets no formato esperado pelo computeScoreV3
    const targetsForV3 = {
        lufs_target: refData.lufs_target,
        lufs_min: refData.lufs_min,
        lufs_max: refData.lufs_max,
        tol_lufs: refData.tol_lufs,
        true_peak_target: refData.true_peak_target,
        true_peak_min: refData.true_peak_min,
        true_peak_max: refData.true_peak_max,
        tol_true_peak: refData.tol_true_peak,
        dr_target: refData.dr_target,
        dr_min: refData.dr_min,
        dr_max: refData.dr_max,
        tol_dr: refData.tol_dr,
        bands: refData.bands
    };
    
    // Usar novo sistema unificado - PASSAR analysisWithSoundDest em vez de analysis
    const v3Result = window.computeScoreV3(analysisWithSoundDest, targetsForV3, mode);
    
    if (v3Result) {
        console.log('✅ [V3.5] Score calculado pelo sistema unificado:', v3Result);
        
        // Mapear resultado V3 para formato esperado pelo sistema antigo
        // 🎯 V4.1: INCLUIR metricEvaluations PARA buildDiagnosticContext
        const result = {
            final: v3Result.final,
            finalRaw: v3Result.raw,
            loudness: v3Result.subscores.loudness,
            dinamica: v3Result.subscores.dynamics,
            frequencia: v3Result.subscores.frequency,
            estereo: v3Result.subscores.stereo,
            tecnico: v3Result.subscores.technical,
            weights: v3Result.debug.weights,
            genre: genreKey,
            _v3Result: v3Result, // Resultado completo para debug
            _gatesTriggered: v3Result.gateReasons,
            _gatePenalty: v3Result.gatePenalty,
            metricScores: v3Result.metricScores,
            // 🎯 V4.1: Dados necessários para buildDiagnosticContext
            metricEvaluations: v3Result.metricEvaluations,
            subscores: v3Result.subscores,
            gatesTriggered: v3Result.gatesTriggered,
            _frequencyDetails: v3Result._frequencyDetails
        };
        
        // 🎯 LOG DE AUDITORIA: Verificar subscores após correção
        console.log('[AUDIT-SCORES-V3.5] Subscores unificados:', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            estereo: result.estereo,
            frequencia: result.frequencia,
            tecnico: result.tecnico,
            raw: v3Result.raw,
            final: result.final,
            gatePenalty: v3Result.gatePenalty,
            gateReasons: v3Result.gateReasons.map(g => g.type)
        });
        
        return result;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // FALLBACK: Sistema antigo se V3 falhar
    // ═══════════════════════════════════════════════════════════════════
    console.warn('[V3.5] ⚠️ computeScoreV3 retornou null, usando sistema antigo');
    
    // Calcular sub-scores (sistema antigo)
    const loudnessScore = calculateLoudnessScore(analysis, refData);
    const dynamicsScore = calculateDynamicsScore(analysis, refData);
    const stereoScore = calculateStereoScore(analysis, refData);
    const frequencyScore = calculateFrequencyScore(analysis, refData);
    const technicalScore = calculateTechnicalScore(analysis, refData);
    
    console.log('📊 Sub-scores calculados (sistema antigo):', {
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        estereo: stereoScore,
        frequencia: frequencyScore,
        tecnico: technicalScore
    });
    
    // Determinar pesos por gênero (genreKey já definido anteriormente)
    if (!genreKey) {
        console.warn('[GET-BAND-LABEL] Gênero não fornecido, usando label genérico');
    }
    const weights = GENRE_SCORING_WEIGHTS[genreKey] || GENRE_SCORING_WEIGHTS['default'];
    
    console.log('⚖️ Pesos aplicados:', weights);
    
    // CORREÇÃO: Calcular score final com valores contínuos
    let weightedSum = 0;
    let totalWeight = 0;
    
    // Somar apenas os scores que existem, ajustando os pesos dinamicamente
    if (loudnessScore !== null) {
        weightedSum += loudnessScore * weights.loudness;
        totalWeight += weights.loudness;
    }
    
    if (dynamicsScore !== null) {
        weightedSum += dynamicsScore * weights.dinamica;
        totalWeight += weights.dinamica;
    }
    
    if (stereoScore !== null) {
        weightedSum += stereoScore * weights.estereo;
        totalWeight += weights.estereo;
    }
    
    if (frequencyScore !== null) {
        weightedSum += frequencyScore * weights.frequencia;
        totalWeight += weights.frequencia;
    }
    
    if (technicalScore !== null) {
        weightedSum += technicalScore * weights.tecnico;
        totalWeight += weights.tecnico;
    }
    
    // Calcular score final normalizado (permite valores contínuos como 67.3, depois arredonda)
    let finalScore = null;
    if (totalWeight > 0) {
        const rawFinalScore = weightedSum / totalWeight;
        finalScore = Math.round(rawFinalScore); // Só arredondar no final
    }
    
    const result = {
        final: finalScore,
        loudness: loudnessScore,
        dinamica: dynamicsScore,
        frequencia: frequencyScore,
        estereo: stereoScore,
        tecnico: technicalScore,
        weights: weights,
        genre: genreKey
    };
    
    // 🎯 LOG DE AUDITORIA: Verificar subscores após correção
    console.log('[AUDIT-SCORES-FIX] Subscores depois da correção:', {
        loudness: result.loudness,
        dinamica: result.dinamica,
        estereo: result.estereo,
        frequencia: result.frequencia,
        tecnico: result.tecnico,
        final: result.final
    });
    
    console.log('🎯 Score final calculado:', result);
    
    // 🎯 AUDIT_REF_FIX: Log final de confirmação do fluxo A/B
    // 🔒 GUARD: Só executar logs de referência se viewMode === "reference"
    if (refData._isReferenceMode === true && getViewMode() === "reference" && canRunReferenceUI({ mode: 'reference', referenceComparison: true })) {
        console.log('[REFERENCE-A/B FIXED ✅] Comparação A/B concluída com sucesso');
        console.log('[AUDIT_REF_FIX] Bands carregadas da segunda música (referência real)');
        console.log('[AUDIT_REF_FIX] ReferenceComparison gerado com dados A/B corretos');
    }
    
    // 🎯 AUDIT LOG FINAL
    try {
        console.log('[AUDIT-FINAL-SCORES]', {
            loudness: result.loudness,
            dinamica: result.dinamica,
            frequencia: result.frequencia,
            estereo: result.estereo,
            tecnico: result.tecnico,
            finalScore: result.final,
            weights: result.weights,
            genre: result.genre,
            weightedCalculation: {
                loudness: result.loudness !== null ? (result.loudness * result.weights.loudness) : 'N/A',
                dinamica: result.dinamica !== null ? (result.dinamica * result.weights.dinamica) : 'N/A',
                frequencia: result.frequencia !== null ? (result.frequencia * result.weights.frequencia) : 'N/A',
                estereo: result.estereo !== null ? (result.estereo * result.weights.estereo) : 'N/A',
                tecnico: result.tecnico !== null ? (result.tecnico * result.weights.tecnico) : 'N/A'
            },
            isReferenceMode: refData._isReferenceMode === true
        });
    } catch (err) {
        console.warn('[AUDIT-ERROR]', 'calculateAnalysisScores (final)', err);
    }
    
    return result;
}

// Recalcular apenas as sugestões baseadas em referência (sem reprocessar o áudio)
function updateReferenceSuggestions(analysis) {
    // 🎯 CORREÇÃO CRÍTICA: Usar getActiveReferenceComparisonMetrics() para detectar targets corretamente
    const activeComparisonMetrics = getActiveReferenceComparisonMetrics(analysis);
    const hasActiveComparisonMetrics = !!activeComparisonMetrics;
    
    console.log('🔍 [DEBUG-REF] updateReferenceSuggestions chamado:', {
        hasAnalysis: !!analysis,
        hasTechnicalData: !!analysis?.technicalData,
        hasActiveRefData: !!__activeRefData,
        hasReferenceComparisonMetrics: hasActiveComparisonMetrics, // ✅ CORRIGIDO: usa função nova
        hasReferenceComparisonMetricsOLD: !!referenceComparisonMetrics, // ❌ ANTIGO (para comparação)
        activeRefGenre: __activeRefGenre,
        activeRefDataKeys: __activeRefData ? Object.keys(__activeRefData) : null,
        currentGenre: window.PROD_AI_REF_GENRE,
        mode: analysis?.mode,
        activeComparisonMetricsSource: activeComparisonMetrics ? 'detected' : 'none'
    });
    
    if (!analysis || !analysis.technicalData) {
        console.warn('🚨 [DEBUG-REF] analysis ou technicalData ausentes');
        return;
    }
    
    // 🎯 PRIORIDADE: Se temos comparação entre faixas, usar referenceComparisonMetrics
    let targetMetrics = null;
    
    if (referenceComparisonMetrics && referenceComparisonMetrics.reference) {
        console.log('✅ [SUGGESTIONS] Usando referenceComparisonMetrics para sugestões (comparação entre faixas)');
        
        // Construir targetMetrics no formato esperado
        const refMetrics = referenceComparisonMetrics.reference;
        targetMetrics = {
            lufs_target: refMetrics.lufsIntegrated || refMetrics.lufs_integrated,
            true_peak_target: refMetrics.truePeakDbtp || refMetrics.true_peak_dbtp,
            dr_target: refMetrics.dynamicRange || refMetrics.dynamic_range,
            lra_target: refMetrics.lra,
            stereo_target: refMetrics.stereoCorrelation || refMetrics.stereo_correlation,
            spectral_centroid_target: refMetrics.spectralCentroidHz || refMetrics.spectral_centroid,
            bands: refMetrics.spectral_balance || null,
            tol_lufs: 0.5,
            tol_true_peak: 0.3,
            tol_dr: 1.0,
            tol_lra: 1.0,
            tol_stereo: 0.08,
            tol_spectral: 300
        };
        
        console.log('📊 [SUGGESTIONS] Target metrics (2ª faixa):', {
            lufs: targetMetrics.lufs_target,
            peak: targetMetrics.true_peak_target,
            dr: targetMetrics.dr_target
        });
        
        // Usar targetMetrics como __activeRefData temporariamente para compatibilidade
        __activeRefData = targetMetrics;
    }
    
    if (!__activeRefData) {
        console.warn('🚨 [DEBUG-REF] __activeRefData está null - tentando carregar gênero atual');
        
        // Tentar carregar dados de referência do gênero atual
        if (window.PROD_AI_REF_GENRE) {
            console.log('🔄 [DEBUG-REF] Tentando carregar dados para gênero:', window.PROD_AI_REF_GENRE);
            loadReferenceData(window.PROD_AI_REF_GENRE).then(() => {
                console.log('✅ [DEBUG-REF] Dados carregados, reprocessando sugestões');
                updateReferenceSuggestions(analysis);
            }).catch(err => {
                console.error('❌ [DEBUG-REF] Erro ao carregar dados:', err);
            });
        } else {
            // Tentar com dados de referência padrão embutidos
            console.log('🔄 [DEBUG-REF] Usando dados de referência embutidos');
            
            // Verificar se existem dados embutidos para o gênero detectado nos scores
            if (analysis.scores && analysis.scores.genre) {
                const detectedGenre = analysis.scores.genre;
                console.log('🎯 [DEBUG-REF] Gênero detectado nos scores:', detectedGenre);
                
                // Usar dados embutidos se disponíveis
                const embeddedRefs = {
                    eletrofunk: {
                        lufs_target: -8.3,
                        true_peak_target: -1,
                        dr_target: 10.1,
                        lra_target: 8.4,
                        stereo_target: 0.12,
                        bands: {
                            low_bass: { target_db: 13.3, tol_db: 2.36 },
                            low_mid: { target_db: 8.8, tol_db: 2.07 },
                            mid: { target_db: 2.5, tol_db: 1.81 },
                            high_mid: { target_db: -6.7, tol_db: 1.52 },
                            presenca: { target_db: -22.7, tol_db: 3.47 },
                            brilho: { target_db: -13.1, tol_db: 2.38 }
                        }
                    }
                };
                
                if (embeddedRefs[detectedGenre]) {
                    console.log('✅ [DEBUG-REF] Usando dados embutidos para', detectedGenre);
                    __activeRefData = embeddedRefs[detectedGenre];
                    __activeRefGenre = detectedGenre;
                    // Continuar com o processamento
                } else {
                    console.warn('❌ [DEBUG-REF] Gênero não suportado nos dados embutidos:', detectedGenre);
                    return;
                }
            } else {
                console.warn('❌ [DEBUG-REF] Nenhuma estratégia de recuperação disponível');
                return;
            }
        }
        
        // Se chegou até aqui sem return, __activeRefData foi definido pelos dados embutidos
        if (!__activeRefData) {
            return;
        }
    }
    
    // 🛡️ PROTEÇÃO: Evitar duplicação - resetar flag se chamado via applyGenreSelection
    if (analysis._suggestionsGenerated) {
        console.log('🎯 [SUGGESTIONS] Recalculando sugestões para novo gênero (resetando flag)');
        analysis._suggestionsGenerated = false;
    }
    
    // 🎯 SISTEMA MELHORADO: Usar Enhanced Suggestion Engine quando disponível
    if (typeof window !== 'undefined' && window.enhancedSuggestionEngine && window.USE_ENHANCED_SUGGESTIONS !== false) {
        try {
            console.log('🎯 Usando Enhanced Suggestion Engine...');
            
            // 🎯 INTERCEPT CRÍTICO: Usar reference targets se modo for reference
            const state = window.__soundyState || {};
            let targetDataForEngine = __activeRefData;
            
            if (state.render?.mode === 'reference') {
                // Buscar dados da primeira faixa (referência) para usar como target
                const referenceBands = state.reference?.analysis?.technicalData?.spectral_balance
                    || state.reference?.analysis?.bands
                    || referenceComparisonMetrics?.referenceFull?.technicalData?.spectral_balance
                    || null;
                
                if (referenceBands) {
                    console.log('� [ENGINE-INTERCEPT] Modo reference detectado - usando bandas da primeira faixa como target');
                    targetDataForEngine = {
                        ...(__activeRefData || {}),
                        bands: referenceBands,
                        _isReferenceMode: true,
                        _referenceSource: 'first_track'
                    };
                } else {
                    console.warn('⚠️ [ENGINE-INTERCEPT] Modo reference mas sem bandas - usando genreTargets (fallback)');
                }
            }
            
            console.log('�🔍 [DEBUG-ENGINE] Dados sendo passados para Enhanced Engine:', {
                mode: state.render?.mode,
                isReferenceMode: state.render?.mode === 'reference',
                analysis: {
                    hasTechnicalData: !!analysis.technicalData,
                    technicalDataKeys: analysis.technicalData ? Object.keys(analysis.technicalData) : null,
                    hasSuggestions: !!analysis.suggestions,
                    suggestionsCount: analysis.suggestions?.length || 0
                },
                targetDataForEngine: {
                    isNull: targetDataForEngine === null,
                    isUndefined: targetDataForEngine === undefined,
                    type: typeof targetDataForEngine,
                    keys: targetDataForEngine ? Object.keys(targetDataForEngine) : null,
                    structure: targetDataForEngine ? 'present' : 'missing',
                    hasBands: !!targetDataForEngine?.bands,
                    isReferenceMode: targetDataForEngine?._isReferenceMode
                }
            });
            
            // 🔥 PROTEÇÃO: Preservar technicalData e genreTargets ANTES do enhancedSuggestionEngine
            const __engineProtected = {
                technicalData: structuredClone(analysis.technicalData || {}),
                genreTargets: structuredClone(analysis.data?.genreTargets || null),
                metadata: structuredClone(analysis.metadata || {}),
                score: analysis.score,
                classification: analysis.classification
            };
            console.log('[ENGINE-PROTECT] 🛡️ Dados protegidos antes de processAnalysis:', {
                techKeys: Object.keys(__engineProtected.technicalData).length,
                hasGT: !!__engineProtected.genreTargets
            });
            
            const enhancedAnalysis = window.enhancedSuggestionEngine.processAnalysis(analysis, targetDataForEngine);
            
            // 🔥 RESTAURAÇÃO: Restaurar dados protegidos DEPOIS do enhancedSuggestionEngine
            if (__engineProtected.technicalData && Object.keys(__engineProtected.technicalData).length > 0) {
                enhancedAnalysis.technicalData = structuredClone(__engineProtected.technicalData);
                console.log('[ENGINE-PROTECT] ✅ technicalData restaurado após processAnalysis');
            }
            if (__engineProtected.genreTargets) {
                if (!enhancedAnalysis.data) enhancedAnalysis.data = {};
                enhancedAnalysis.data.genreTargets = structuredClone(__engineProtected.genreTargets);
                console.log('[ENGINE-PROTECT] ✅ genreTargets restaurado após processAnalysis');
            }
            if (Object.keys(__engineProtected.metadata).length > 0) {
                enhancedAnalysis.metadata = structuredClone(__engineProtected.metadata);
            }
            if (__engineProtected.score !== null && __engineProtected.score !== undefined) {
                enhancedAnalysis.score = __engineProtected.score;
            }
            if (__engineProtected.classification) {
                enhancedAnalysis.classification = __engineProtected.classification;
            }
            
            // Substituir analysis pelo resultado protegido
            analysis = enhancedAnalysis;
            
            // 🎯 PATCH 1: PRESERVAR sugestões backend SEM sobrescrever
            // Guardar sugestões originais (backend) separadamente
            const backendOriginalSuggestions = Array.isArray(analysis.suggestions) ? analysis.suggestions : [];
            analysis.backendSuggestions = backendOriginalSuggestions; // Sugestões originais do backend
            
            // Enhanced Engine cria campo SEPARADO - NÃO sobrescreve analysis.suggestions
            analysis.enhancedSuggestions = enhancedAnalysis.suggestions; // Sugestões recalculadas
            
            // ✅ analysis.suggestions permanece com valores BACKEND (não sobrescrever)
            // Cards agora podem escolher qual usar verificando genreTargets
            
            // Adicionar métricas melhoradas à análise
            if (enhancedAnalysis.enhancedMetrics) {
                analysis.enhancedMetrics = enhancedAnalysis.enhancedMetrics;
            }
            
            // Adicionar log de auditoria
            if (enhancedAnalysis.auditLog) {
                analysis.auditLog = enhancedAnalysis.auditLog;
            }
            
            console.log(`🎯 [SUGGESTIONS] Backend suggestions (antigas): ${existingSuggestions.length} guardadas em backendSuggestions`);
            console.log(`🎯 [SUGGESTIONS] Enhanced Engine (NOVAS): ${enhancedAnalysis.suggestions.length} sugestões`);
            console.log(`🎯 [SUGGESTIONS] Total final (SEM MIXING): ${analysis.suggestions.length} sugestões`);
            console.log(`✅ [FIX-CONSISTENCY] Cards e tabela agora usarão OS MESMOS targets/deltas`);
            
            // 🤖 NOVA CAMADA DE IA: Pós-processamento inteligente de sugestões (Enhanced Engine)
            if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
                try {
                    console.log('🤖 [AI-LAYER] Enriquecendo sugestões do Enhanced Engine...');
                    
                    // Preparar contexto para IA
                    const aiContext = {
                        technicalData: analysis.technicalData,
                        genre: __activeRefGenre || analysis.genre,
                        referenceData: __activeRefData,
                        problems: analysis.problems,
                        enhancedMetrics: enhancedAnalysis.enhancedMetrics
                    };
                    
                    // Chamar IA de forma assíncrona
                    window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                        .then(enhancedSuggestions => {
                            if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                                // ✅ aplicar ordem garantida após IA
                                enhancedSuggestions = window.enhancedSuggestionEngine
                                    .enforceOrderedSuggestions(enhancedSuggestions);

                                analysis.suggestions = enhancedSuggestions;
                                analysis._aiEnhanced = true;
                                analysis._aiTimestamp = new Date().toISOString();
                                analysis._aiSource = 'enhanced_engine';
                                
                                console.log(`🤖 [AI-LAYER] ✅ Enhanced Engine + IA: ${enhancedSuggestions.length} sugestões`);
                                
                                // 🚀 FORÇA EXIBIÇÃO: Sempre mostrar interface IA
                                if (window.aiUIController) {
                                    console.log(`🚀 [FORCE-AI-UI] Forçando exibição da interface IA com ${enhancedSuggestions.length} sugestões`);
                                    window.aiUIController.checkForAISuggestions(analysis);
                                }
                                
                                // Re-renderizar se modal visível
                                if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                                    displayModalResults(analysis);
                                }
                            }
                        })
                        .catch(error => {
                            console.warn('🤖 [AI-LAYER] ❌ Erro na IA do Enhanced Engine:', error);
                            
                            // 🚀 FORÇA EXIBIÇÃO: Mostrar interface IA mesmo em caso de erro
                            setTimeout(() => {
                                if (window.aiUIController && analysis.suggestions) {
                                    console.log(`🚀 [AI-UI-FORCE-ERROR] Forçando interface IA aparecer após erro com ${analysis.suggestions.length} sugestões`);
                                    window.aiUIController.checkForAISuggestions(analysis, true); // force = true
                                } else {
                                    console.warn('⚠️ [AI-UI-FORCE-ERROR] aiUIController não encontrado ou sem sugestões');
                                }
                            }, 100);
                        });
                } catch (error) {
                    console.warn('🤖 [AI-LAYER] ❌ Erro na integração IA Enhanced Engine:', error);
                }
            }
            
            return;
            
        } catch (error) {
            console.warn('🚨 Erro no Enhanced Suggestion Engine, usando fallback:', error);
            // Continuar com sistema legado em caso de erro
        }
    }
    
    // 🔄 SISTEMA LEGADO (fallback) - APENAS PARA SCORES, NÃO DEVE ALTERAR SUGESTÕES
    console.log('🔄 [FALLBACK] Sistema legado ativado - usando apenas para calcular scores');
    
    // IMPORTANTE: NÃO modificar analysis.suggestions aqui para não interferir com Enhanced Engine
    // Apenas calcular scores se necessário
    if (!analysis.scores && __activeRefData && analysis.technicalData) {
        try {
            analysis.scores = this.calculateFallbackScores(analysis.technicalData, __activeRefData);
            console.log('✅ [FALLBACK] Scores calculados pelo sistema legado');
        } catch (error) {
            console.warn('⚠️ [FALLBACK] Erro ao calcular scores legados:', error);
        }
    }
    
    console.log('🎯 [FALLBACK] Sistema legado concluído sem alterar sugestões');
    
    return; // ❌ SISTEMA LEGADO DESATIVADO - Enhanced Engine deve ser usado para sugestões
    
    // 🤖 NOVA CAMADA DE IA: Pós-processamento inteligente de sugestões
    // PONTO DE INTEGRAÇÃO SEGURO: Após geração de todas as sugestões
    if (typeof window !== 'undefined' && window.AI_SUGGESTION_LAYER_ENABLED && window.aiSuggestionLayer) {
        try {
            console.log('🤖 [AI-LAYER] Iniciando enriquecimento inteligente das sugestões...');
            
            // Preparar contexto para IA
            const aiContext = {
                technicalData: analysis.technicalData,
                genre: __activeRefGenre || analysis.genre,
                referenceData: __activeRefData,
                problems: analysis.problems
            };
            
            // Chamar IA de forma assíncrona com fallback
            window.aiSuggestionLayer.process(analysis.suggestions, aiContext)
                .then(enhancedSuggestions => {
                    if (enhancedSuggestions && enhancedSuggestions.length > 0) {
                        // ✅ aplicar ordem garantida após IA
                        enhancedSuggestions = window.enhancedSuggestionEngine
                            .enforceOrderedSuggestions(enhancedSuggestions);

                        analysis.suggestions = enhancedSuggestions;
                        console.log(`🤖 [AI-LAYER] ✅ ${enhancedSuggestions.length} sugestões enriquecidas com IA`);
                        
                        // Marcar que IA foi aplicada
                        analysis._aiEnhanced = true;
                        analysis._aiTimestamp = new Date().toISOString();
                        
                        // Re-renderizar modal se estiver visível
                        if (document.getElementById('audioAnalysisModal')?.style.display !== 'none') {
                            console.log('🎨 [AI-LAYER] Re-renderizando modal com sugestões IA');
                            displayModalResults(analysis);
                        }
                    } else {
                        console.warn('🤖 [AI-LAYER] ⚠️ IA retornou resultado vazio, mantendo sugestões originais');
                    }
                })
                .catch(error => {
                    console.warn('🤖 [AI-LAYER] ❌ Erro na camada de IA, mantendo sugestões originais:', error);
                    // Sistema continua funcionando normalmente com sugestões originais
                });
                
        } catch (error) {
            console.warn('🤖 [AI-LAYER] ❌ Erro na inicialização da IA, sistema continua normal:', error);
        }
    } else {
        console.log('🤖 [AI-LAYER] Sistema de IA desabilitado ou não disponível');
    }
    
    // 🛡️ Marcar que sugestões foram geradas (proteção contra duplicação)
    analysis._suggestionsGenerated = true;
}

/**
 * 🔢 Calcular scores básicos quando Enhanced Engine não está disponível
 * @param {Object} technicalData - Dados técnicos da análise
 * @param {Object} referenceData - Dados de referência
 * @returns {Object} Scores calculados
 */
function calculateFallbackScores(technicalData, referenceData) {
    const scores = {};
    
    try {
        // Score LUFS
        if (Number.isFinite(technicalData.lufsIntegrated) && Number.isFinite(referenceData.lufs_target)) {
            const delta = Math.abs(technicalData.lufsIntegrated - referenceData.lufs_target);
            const tolerance = referenceData.tol_lufs || 2.0;
            scores.lufs = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score True Peak
        if (Number.isFinite(technicalData.truePeakDbtp)) {
            if (technicalData.truePeakDbtp > 0) {
                scores.truePeak = 0; // Crítico
            } else if (technicalData.truePeakDbtp > -1.0) {
                scores.truePeak = 5; // Aceitável mas não ideal
            } else {
                scores.truePeak = 10; // Ideal
            }
        }
        
        // Score DR
        if (Number.isFinite(technicalData.dynamicRange) && Number.isFinite(referenceData.dr_target)) {
            const delta = Math.abs(technicalData.dynamicRange - referenceData.dr_target);
            const tolerance = referenceData.tol_dr || 2.0;
            scores.dr = Math.max(0, Math.min(10, 10 - (delta / tolerance) * 2));
        }
        
        // Score geral (média dos scores disponíveis)
        const availableScores = Object.values(scores).filter(s => Number.isFinite(s));
        if (availableScores.length > 0) {
            scores.overall = availableScores.reduce((sum, score) => sum + score, 0) / availableScores.length;
        }
        
        console.log('📊 [FALLBACK] Scores calculados:', scores);
        return scores;
        
    } catch (error) {
        console.error('❌ [FALLBACK] Erro ao calcular scores:', error);
        return {};
    }
}

// 🎨 Estilos do seletor de gênero (injeção única, não quebra CSS existente)
function injectRefGenreStyles() {
    if (document.getElementById('refGenreEnhancedStyles')) return; // já injetado
    const style = document.createElement('style');
    style.id = 'refGenreEnhancedStyles';
    style.textContent = `
    #audioRefGenreContainer{position:relative;gap:10px;padding:6px 10px 4px 10px;border:1px solid rgba(255,255,255,.06);background:linear-gradient(145deg,#0c111b,#0d1321);border-radius:10px;box-shadow:0 2px 6px -2px rgba(0,0,0,.6),0 0 0 1px rgba(255,255,255,0.02);}
    #audioRefGenreContainer label{font-weight:500;letter-spacing:.3px;color:#9fb3d9;margin-right:4px;}
    #audioRefGenreSelect{appearance:none;-webkit-appearance:none;-moz-appearance:none;position:relative;padding:6px 32px 6px 12px;font-size:12px;line-height:1.2;background:rgba(20,32,54,.7);color:#f4f7fb;border:1px solid #1e2b40;border-radius:8px;cursor:pointer;font-family:inherit;transition:border .25s, background .25s, box-shadow .25s;min-width:140px;}
    #audioRefGenreSelect:hover{background:rgba(28,44,76,.85);}
    #audioRefGenreSelect:focus{outline:none;border-color:#249dff;box-shadow:0 0 0 2px rgba(36,157,255,.3);}
    #audioRefGenreSelect:active{transform:translateY(1px);} 
    #audioRefGenreContainer::after{content:"";position:absolute;top:13px;left: calc(10px + 140px);pointer-events:none;}
    #audioRefGenreContainer .select-wrap{position:relative;}
    /* Seta custom */
    #audioRefGenreContainer .select-wrap:after{content:"";position:absolute;right:12px;top:50%;width:7px;height:7px;border-right:2px solid #9fb3d9;border-bottom:2px solid #9fb3d9;transform:translateY(-60%) rotate(45deg);pointer-events:none;transition:transform .25s,border-color .25s;}
    #audioRefGenreSelect:focus + .arrow, #audioRefGenreContainer .select-wrap:focus-within:after{border-color:#53c2ff;}
    #audioRefStatus{font-size:11px;font-weight:500;letter-spacing:.4px;padding:4px 10px;border-radius:7px;background:#0d6efd;color:#fff;display:inline-flex;align-items:center;gap:6px;box-shadow:0 0 0 1px rgba(255,255,255,.06),0 2px 4px -1px rgba(0,0,0,.7);}
    #audioRefStatus::before{content:"";width:7px;height:7px;border-radius:50%;background:#3df29b;box-shadow:0 0 0 3px rgba(61,242,155,.25);} 
    #audioRefGenreContainer.dark #audioRefStatus{background:#14324f;}
    @media (max-width:600px){#audioRefGenreContainer{padding:6px 8px 4px 8px;gap:6px;}#audioRefGenreSelect{min-width:120px;padding:6px 28px 6px 10px;}}
    `;
    // Wrap opcional para setinha sem mexer HTML: inserir span ao redor do select
    const select = document.getElementById('audioRefGenreSelect');
    if (select && !select.parentElement.classList.contains('select-wrap')) {
        const wrap = document.createElement('div');
        wrap.className = 'select-wrap';
        wrap.style.position = 'relative';
        select.parentNode.insertBefore(wrap, select);
        wrap.appendChild(select);
    }
    document.head.appendChild(style);
}

// 🎨 Estilos do Modal de Gênero Musical - Glassmorphism + Glitch
function injectGenreModalStyles() {
    if (document.getElementById('genreModalStyles')) return; // já injetado
    const style = document.createElement('style');
    style.id = 'genreModalStyles';
    style.textContent = `
    /* 🎵 Novo Modal de Gênero Musical - Glassmorphism */
    .genre-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        z-index: 10000;
        opacity: 1;
        transition: opacity 0.3s ease;
    }

    .genre-modal.hidden {
        display: none;
        opacity: 0;
    }

    .genre-modal-container {
        max-width: 720px;
        width: 90%;
        max-height: 90vh;
        background: radial-gradient(
    circle at 20% 20%, 
    rgba(93, 21, 134, 0.85) 0%,       /* Roxo vibrante no canto */
    rgba(0, 0, 0, 0.95) 60%,          /* Preto no centro */
    rgba(0, 102, 255, 0.4) 100%       /* Azul elétrico nas bordas */
);
backdrop-filter: blur(8px);
box-shadow: 0 0 30px rgba(93, 21, 134, 0.4),
            0 0 60px rgba(0, 102, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        padding: 40px 32px 32px 32px;
        text-align: center;
        position: relative;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        box-shadow: 
            0 20px 40px rgba(91, 11, 156, 0.49),
            0 0 0 1px rgba(255, 255, 255, 0.05),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        transform: scale(1);
        transition: transform 0.2s ease;
        overflow: hidden;
    }

    /* LINHAS NEURAIS VANTA - FUNDO TECH */
    .genre-modal-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            repeating-linear-gradient(
                0deg,
                transparent,
                transparent 40px,
                rgba(106, 154, 255, 0.03) 40px,
                rgba(106, 154, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                90deg,
                transparent,
                transparent 40px,
                rgba(106, 0, 255, 0.03) 40px,
                rgba(106, 0, 255, 0.03) 41px
            ),
            repeating-linear-gradient(
                45deg,
                transparent,
                transparent 60px,
                rgba(0, 212, 255, 0.02) 60px,
                rgba(0, 212, 255, 0.02) 61px
            );
        opacity: 0.6;
        animation: neural-grid-genre 15s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    /* Partículas flutuantes */
    .genre-modal-container::after {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background-image: 
            radial-gradient(circle, rgba(106, 0, 255, 0.15) 1px, transparent 1px),
            radial-gradient(circle, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
        background-size: 50px 50px, 80px 80px;
        background-position: 0 0, 25px 25px;
        animation: particles-float-genre 20s linear infinite;
        pointer-events: none;
        z-index: 1;
    }

    @keyframes neural-grid-genre {
        0% {
            transform: translate(0, 0);
            opacity: 0.6;
        }
        50% {
            opacity: 0.4;
        }
        100% {
            transform: translate(40px, 40px);
            opacity: 0.6;
        }
    }

    @keyframes particles-float-genre {
        0% {
            transform: translate(0, 0) rotate(0deg);
        }
        100% {
            transform: translate(50px, 50px) rotate(360deg);
        }
    }

    /* Garante que conteúdo fica acima do fundo neural */
    .genre-modal-container > * {
        position: relative;
        z-index: 5;
    }

    /* Título com efeito glitch - Paleta roxo escuro + azul ciano */
    .genre-modal-title {
        font-family: 'Orbitron', 'Rajdhani', 'Montserrat Alternates', sans-serif;
        font-size: 2.2rem;
        font-weight: 700;
        text-transform: uppercase;
        color: #ffffff;
        margin-bottom: 12px;
        position: relative;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 
            0 0 12px rgba(0, 212, 255, 0.4),
            0 0 24px rgba(108, 0, 162, 0.2),
            0 0 40px rgba(0, 212, 255, 0.15);
    }

    .genre-modal-title.glitch::before,
    .genre-modal-title.glitch::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.85;
        pointer-events: none;
    }

    /* PARTE SUPERIOR — Roxo escuro */
    .genre-modal-title.glitch::before {
        color: #6c00a2;
        animation: glitch-1 2s infinite alternate-reverse;
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }

    /* PARTE INFERIOR — Azul ciano */
    .genre-modal-title.glitch::after {
        color: #00d4ff;
        animation: glitch-2 3s infinite alternate-reverse;
        clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }

    @keyframes glitch-1 {
        0% { transform: translateX(-2px); }
        100% { transform: translateX(2px); }
    }

    @keyframes glitch-2 {
        0% { transform: translateX(2px); }
        100% { transform: translateX(-2px); }
    }

    .genre-modal-subtitle {
        color: rgba(255, 255, 255, 0.7);
        font-size: 1rem;
        margin-bottom: 32px;
        font-weight: 400;
    }

    /* Grid de gêneros */
    .genre-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 32px;
    }

    /* 🔧 CORREÇÃO FLASH BRANCO: Estado inicial explícito */
    .genre-card {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 20px 16px;
        
        /* Estado base: exatamente o visual glass atual */
        background: rgba(255, 255, 255, 0.05);
        background-color: transparent; /* Evita herdar branco do user-agent */
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        color: #ffffff;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        
        /* ❌ NÃO animar background - só transform, box-shadow, border-color, opacity */
        transition: 
            transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
            opacity 0.25s ease;
        
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        
        /* Zera estilos nativos se for <button> */
        -webkit-appearance: none;
        appearance: none;
    }

    /* Prepaint: cards invisíveis enquanto CSS assenta */
    .genre-modal.prepaint .genre-card {
        opacity: 0;
    }

    .genre-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255, 255, 255, 0.1), 
            transparent);
        transition: left 0.6s ease;
    }

    .genre-card:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(36, 157, 255, 0.4);
        transform: scale(1.05) translateY(-2px);
        box-shadow: 
            0 10px 25px rgba(0, 0, 0, 0.4),
            0 0 0 1px rgba(36, 157, 255, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .genre-card:hover::before {
        left: 100%;
    }

    .genre-card:active {
        transform: scale(0.98) translateY(1px);
    }

    .genre-icon {
        font-size: 2rem;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
    }

    .genre-name {
        font-weight: 700;
        letter-spacing: 0.5px;
    }

    /* Botão fechar */
    .genre-modal-close {
        background: rgba(255, 255, 255, 0.08);
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.8);
        padding: 12px 24px;
        border-radius: 12px;
        font-size: 0.9rem;
        cursor: pointer;
        /* ❌ NÃO animar background */
        transition: 
            border-color 0.2s ease,
            color 0.2s ease,
            opacity 0.2s ease;
        font-weight: 500;
        -webkit-appearance: none;
        appearance: none;
    }

    .genre-modal-close:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #ffffff;
        border-color: rgba(255, 255, 255, 0.4);
    }

    /* Responsividade */
    @media (max-width: 768px) {
        .genre-modal-container {
            width: 95%;
            padding: 32px 20px 24px 20px;
        }

        .genre-modal-title {
            font-size: 1.8rem;
        }

        .genre-grid {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
        }

        .genre-card {
            padding: 16px 12px;
            gap: 8px;
        }

        .genre-icon {
            font-size: 1.5rem;
        }

        .genre-name {
            font-size: 0.85rem;
        }
    }

    @media (max-width: 480px) {
        .genre-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        
        .genre-card {
            padding: 14px 10px;
        }
    }
    `;
    document.head.appendChild(style);
}

// 🤖 Enviar análise para chat
window.sendModalAnalysisToChat = async function sendModalAnalysisToChat() {
    // 🔒 GUARD: Bloquear funcionalidade premium em modo reduced
    // ✅ Prioridade 1: Sistema centralizado de capabilities
    if (window.PlanCapabilities && window.PlanCapabilities.shouldBlockAiHelp()) {
        console.log('🔒 [PREMIUM-GUARD] Funcionalidade "Pedir Ajuda à IA" bloqueada');
        console.log('📊 [PREMIUM-GUARD] Contexto:', window.PlanCapabilities.getCurrentContext());
        
        // ✅ Abrir modal de upgrade (com classe visible para CSS)
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            console.log('✅ [PREMIUM-GUARD] Modal de upgrade aberto (AI)');
        } else {
            console.error('❌ [PREMIUM-GUARD] Modal upgradeModal não encontrado no DOM');
        }
        return; // ✅ BLOQUEIO: Não executa função real
    }
    
    // ✅ Prioridade 2: Fallback para APP_MODE (compatibilidade)
    if (window.APP_MODE === 'reduced') {
        console.log('🔒 [PREMIUM-GUARD] Funcionalidade "Pedir Ajuda à IA" bloqueada (fallback APP_MODE)');
        
        // ✅ Abrir modal de upgrade
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            console.log('✅ [PREMIUM-GUARD] Modal de upgrade aberto (AI - fallback)');
        } else {
            console.error('❌ [PREMIUM-GUARD] Modal upgradeModal não encontrado no DOM');
        }
        return; // ✅ BLOQUEIO: Não executa função real
    }
    
    __dbg('🎯 BOTÃO CLICADO: Pedir Ajuda à IA');
    
    if (!currentModalAnalysis) {
        alert('Nenhuma análise disponível');
        __dbg('❌ Erro: currentModalAnalysis não existe');
        return;
    }
    
    __dbg('🤖 Enviando análise para chat...', currentModalAnalysis);
    
    try {
        // Gerar prompt personalizado baseado nos problemas encontrados
        const prompt = window.audioAnalyzer.generateAIPrompt(currentModalAnalysis);
        const message = `🎵 Analisei meu áudio e preciso de ajuda para melhorar. Aqui estão os dados técnicos:\n\n${prompt}`;
        
        __dbg('📝 Prompt gerado:', message.substring(0, 200) + '...');
        
        // Tentar diferentes formas de integrar com o chat
        let messageSent = false;
        
        // Método 1: Usar diretamente o ProdAI Chatbot quando disponível
        if (window.prodAIChatbot) {
            __dbg('🎯 Tentando enviar via ProdAI Chatbot...');
            try {
                // Se o chat ainda não está ativo, ativar com a mensagem
                if (!window.prodAIChatbot.isActive && typeof window.prodAIChatbot.activateChat === 'function') {
                    __dbg('🚀 Chat inativo. Ativando com a primeira mensagem...');
                    await window.prodAIChatbot.activateChat(message);
                    showTemporaryFeedback('🎵 Análise enviada para o chat!');
                    closeAudioModal();
                    messageSent = true;
                } else if (typeof window.prodAIChatbot.sendMessage === 'function') {
                    // Chat já ativo: preencher input ativo e enviar
                    const activeInput = document.getElementById('chatbotActiveInput');
                    if (activeInput) {
                        activeInput.value = message;
                        activeInput.focus();
                        activeInput.dispatchEvent(new Event('input', { bubbles: true }));
                        await window.prodAIChatbot.sendMessage();
                        showTemporaryFeedback('🎵 Análise enviada para o chat!');
                        closeAudioModal();
                        messageSent = true;
                    }
                }
            } catch (err) {
                __dwrn('⚠️ Falha ao usar ProdAIChatbot direto, tentando fallback...', err);
            }
        }
        // Método 2: Inserir diretamente no input e simular envio
        else {
            __dbg('🎯 Tentando método alternativo...');
            
            const input = document.getElementById('chatbotActiveInput') || document.getElementById('chatbotMainInput');
            const sendBtn = document.getElementById('chatbotActiveSendBtn') || document.getElementById('chatbotSendButton');
            
            __dbg('🔍 Elementos encontrados:', { input: !!input, sendBtn: !!sendBtn });
            
            if (input && sendBtn) {
                input.value = message;
                input.focus();
                
                // Disparar eventos para simular interação do usuário
                input.dispatchEvent(new Event('input', { bubbles: true }));
                input.dispatchEvent(new Event('change', { bubbles: true }));
                
                // Aguardar um pouco e clicar no botão
                setTimeout(() => {
                    sendBtn.click();
                    __dbg('✅ Botão clicado');
                    showTemporaryFeedback('🎵 Análise enviada para o chat!');
                    closeAudioModal();
                }, 500);
                
                messageSent = true;
            }
        }
        
        if (!messageSent) {
            __dbg('❌ Não foi possível enviar automaticamente, copiando para clipboard...');
            
            // Fallback: copiar para clipboard
            await navigator.clipboard.writeText(message);
            showTemporaryFeedback('📋 Análise copiada! Cole no chat manualmente.');
            __dbg('📋 Mensagem copiada para clipboard como fallback');
        }
        
    } catch (error) {
        console.error('❌ Erro ao enviar análise para chat:', error);
        showTemporaryFeedback('❌ Erro ao enviar análise. Tente novamente.');
    }
}

// 📄 GERAR RELATÓRIO PDF PREMIUM PARA MODO REFERÊNCIA (2 PÁGINAS FIXAS)
async function generateReferenceReportPDF() {
    console.log('[REF-PDF] 🚀 Iniciando geração de PDF Premium (2 páginas fixas)...');
    
    // Verificar dependências
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('⚙️ Carregando bibliotecas...');
        console.warn('[REF-PDF] ⚠️ Aguardando carregamento de jsPDF/html2canvas...');
        setTimeout(() => generateReferenceReportPDF(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('⚙️ Gerando relatório premium...');
        
        // 🎯 OBTER DADOS DAS DUAS FAIXAS
        const store = window.SoundyAI_Store || {};
        const firstAnalysis = store.first || window.__soundyState?.reference?.userAnalysis || FirstAnalysisStore?.getUser();
        const secondAnalysis = store.second || window.__soundyState?.reference?.referenceAnalysis || FirstAnalysisStore?.getRef();
        
        if (!firstAnalysis || !secondAnalysis) {
            alert('❌ Dados de comparação não encontrados.\n\nAs duas faixas precisam estar analisadas.');
            console.error('[REF-PDF] Dados insuficientes:', { 
                hasFirst: !!firstAnalysis, 
                hasSecond: !!secondAnalysis 
            });
            return;
        }
        
        // 🎯 OBTER SUGESTÕES DO REFERENCE MODE
        const abSuggestions = window.PRE_UPDATE_REFERENCE_SUGGESTIONS_DATA || [];
        console.log('[REF-PDF] 📊 Sugestões carregadas:', abSuggestions.length);
        
        // Helper para remover extensão
        const removeExtension = (filename) => {
            if (!filename) return 'Faixa';
            return filename.replace(/\.[^/.]+$/, '');
        };
        
        // Extrair nomes das faixas
        const trackAName = removeExtension(
            firstAnalysis.metadata?.fileName || 
            firstAnalysis.fileName || 
            'Faixa Analisada'
        );
        const trackBName = removeExtension(
            secondAnalysis.metadata?.fileName || 
            secondAnalysis.fileName || 
            'Faixa Referência'
        );
        
        console.log('[REF-PDF] 📊 Faixas:', { trackAName, trackBName });
        
        // Extrair métricas técnicas
        const techA = firstAnalysis.technicalData || {};
        const techB = secondAnalysis.technicalData || {};
        
        // Função helper para formatar valores
        const nf = (v, d = 2) => {
            if (v === null || v === undefined || isNaN(v)) return '—';
            return Number(v).toFixed(d);
        };
        
        // Calcular diferenças
        const calcDelta = (a, b) => {
            if (!Number.isFinite(a) || !Number.isFinite(b)) return { diff: '—', severity: 'OK' };
            const diff = a - b;
            const absDiff = Math.abs(diff);
            let severity = 'OK';
            if (absDiff >= 3) severity = 'CRÍTICA';
            else if (absDiff >= 2) severity = 'ALTA';
            else if (absDiff >= 1) severity = 'ATENÇÃO';
            return { diff: (diff > 0 ? '+' : '') + diff.toFixed(1), severity };
        };
        
        const getSeverityColor = (sev) => {
            if (sev === 'CRÍTICA') return '#ff4444';
            if (sev === 'ALTA') return '#ff9800';
            if (sev === 'ATENÇÃO') return '#ffc107';
            return '#52f7ad';
        };
        
        // Métricas principais com severidade
        const metrics = [
            { 
                label: 'LUFS Integrado', 
                valueA: techA.lufsIntegrated || techA.lufs_integrated, 
                valueB: techB.lufsIntegrated || techB.lufs_integrated, 
                unit: ' LUFS',
                action: 'Ajustar loudness'
            },
            { 
                label: 'True Peak', 
                valueA: techA.truePeakDbtp || techA.true_peak_dbtp, 
                valueB: techB.truePeakDbtp || techB.true_peak_dbtp, 
                unit: ' dBTP',
                action: 'Ajustar limitação'
            },
            { 
                label: 'Dynamic Range', 
                valueA: techA.dynamicRange || techA.dynamic_range, 
                valueB: techB.dynamicRange || techB.dynamic_range, 
                unit: ' dB',
                action: 'Ajustar compressão'
            },
            { 
                label: 'LRA', 
                valueA: techA.lra, 
                valueB: techB.lra, 
                unit: ' LU',
                action: 'Controlar dinâmica'
            },
            { 
                label: 'Stereo Correlation', 
                valueA: techA.stereoCorrelation || techA.stereo_correlation, 
                valueB: techB.stereoCorrelation || techB.stereo_correlation, 
                unit: '',
                action: 'Ajustar imagem estéreo'
            }
        ].map(m => {
            const delta = calcDelta(m.valueA, m.valueB);
            return { ...m, delta: delta.diff, severity: delta.severity };
        });
        
        // Bandas espectrais com severidade
        const bandsA = techA.spectral_balance || {};
        const bandsB = techB.spectral_balance || {};
        const bandsList = [
            { key: 'sub', label: 'Sub Bass', range: '20-60Hz', icon: '🔊' },
            { key: 'low_bass', label: 'Bass', range: '60-120Hz', icon: '🎸' },
            { key: 'upper_bass', label: 'Upper Bass', range: '120-250Hz', icon: '🎸' },
            { key: 'low_mid', label: 'Low-Mid', range: '250-500Hz', icon: '🎹' },
            { key: 'mid', label: 'Mid', range: '500-2kHz', icon: '🎤' },
            { key: 'high_mid', label: 'High-Mid', range: '2-5kHz', icon: '✨' },
            { key: 'presence', label: 'Presence', range: '5-10kHz', icon: '🔔' },
            { key: 'air', label: 'Air/Brilho', range: '10-20kHz', icon: '💫' }
        ].map(b => {
            const valA = bandsA[b.key]?.energy_db ?? bandsA[b.key]?.rms_db ?? bandsA[b.key];
            const valB = bandsB[b.key]?.energy_db ?? bandsB[b.key]?.rms_db ?? bandsB[b.key];
            const delta = calcDelta(valA, valB);
            return { 
                ...b, 
                valueA: valA, 
                valueB: valB, 
                delta: delta.diff, 
                severity: delta.severity,
                action: delta.severity === 'OK' ? 'Dentro do padrão' : `Ajustar ${delta.diff} dB`
            };
        });
        
        // Calcular score geral (simplificado)
        const allItems = [...metrics, ...bandsList];
        const okCount = allItems.filter(i => i.severity === 'OK').length;
        const score = Math.round((okCount / allItems.length) * 100);
        let scoreLabel = '🔧 Necessita Ajustes';
        if (score >= 90) scoreLabel = '🏆 Excelente';
        else if (score >= 75) scoreLabel = '⭐ Ótimo';
        else if (score >= 60) scoreLabel = '👍 Bom';
        
        // Top 3 problemas e top 3 ok
        const problems = allItems.filter(i => i.severity !== 'OK').sort((a, b) => {
            const order = { 'CRÍTICA': 0, 'ALTA': 1, 'ATENÇÃO': 2 };
            return order[a.severity] - order[b.severity];
        });
        const topProblems = problems.slice(0, 3);
        const okItems = allItems.filter(i => i.severity === 'OK').slice(0, 3);
        
        // Data e hora
        const date = new Date().toLocaleDateString('pt-BR');
        const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        
        // 🎨 GERAR HTML PÁGINA 1: RESUMO & COMPARAÇÃO
        const page1HTML = `
<div class="pdf-page-1" style="width: 794px; height: 1123px; background: #0a0f1a; color: #e0e6f0; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">
    
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 25px; padding-bottom: 20px; border-bottom: 2px solid rgba(139, 92, 246, 0.3);">
        <div>
            <h1 style="margin: 0; font-size: 32px; font-weight: 700; background: linear-gradient(135deg, #8B5CF6, #3B82F6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">SoundyAI</h1>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #9ca3af;">Relatório • Modo Referência</p>
        </div>
        <div style="text-align: right;">
            <p style="margin: 0; font-size: 14px; color: #e0e6f0;">${date}</p>
            <p style="margin: 3px 0 0 0; font-size: 12px; color: #9ca3af;">${time}</p>
        </div>
    </div>
    
    <!-- Score Hero -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border-radius: 16px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h2 style="margin: 0; font-size: 56px; font-weight: 700; color: white;">${score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h2>
                <p style="margin: 8px 0 0 0; font-size: 18px; color: rgba(255,255,255,0.95);">${scoreLabel}</p>
            </div>
            <div style="font-size: 64px;">🎵</div>
        </div>
    </div>
    
    <!-- Principais Problemas & Pontos OK -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
        <div style="background: rgba(255, 68, 68, 0.1); border: 1px solid rgba(255, 68, 68, 0.3); border-radius: 10px; padding: 15px;">
            <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff4444;">⚠️ Principais Problemas</h3>
            <ul style="margin: 0; padding-left: 18px; font-size: 11px; line-height: 1.6; color: #e0e6f0;">
                ${topProblems.map(p => `<li>${p.label}: ${p.delta}</li>`).join('') || '<li>Nenhum problema crítico</li>'}
            </ul>
        </div>
        <div style="background: rgba(82, 247, 173, 0.1); border: 1px solid rgba(82, 247, 173, 0.3); border-radius: 10px; padding: 15px;">
            <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #52f7ad;">✅ Pontos OK</h3>
            <ul style="margin: 0; padding-left: 18px; font-size: 11px; line-height: 1.6; color: #e0e6f0;">
                ${okItems.map(i => `<li>${i.label}</li>`).join('') || '<li>—</li>'}
            </ul>
        </div>
    </div>
    
    <!-- Comparação -->
    <div style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); border-radius: 10px; padding: 15px; margin-bottom: 20px;">
        <h3 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #8B5CF6;">🎧 Comparação</h3>
        <div style="display: flex; gap: 15px; font-size: 12px;">
            <div style="flex: 1; background: rgba(82, 247, 173, 0.05); border-radius: 8px; padding: 10px;">
                <p style="margin: 0; font-size: 10px; color: #52f7ad; text-transform: uppercase;">Faixa A (Analisada)</p>
                <p style="margin: 5px 0 0 0; font-weight: 600; color: #fff;">${trackAName}</p>
            </div>
            <div style="flex: 1; background: rgba(111, 235, 239, 0.05); border-radius: 8px; padding: 10px;">
                <p style="margin: 0; font-size: 10px; color: #6FEBEF; text-transform: uppercase;">Faixa B (Referência)</p>
                <p style="margin: 5px 0 0 0; font-weight: 600; color: #fff;">${trackBName}</p>
            </div>
        </div>
    </div>
    
    <!-- Tabela Completa: Métricas + Bandas -->
    <div style="margin-bottom: 20px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #8B5CF6;">📊 Métricas & Bandas</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 10px;">
            <thead>
                <tr style="background: rgba(139, 92, 246, 0.1);">
                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Métrica</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Valor</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Alvo</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Diferença</th>
                    <th style="padding: 8px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Severidade</th>
                    <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1); color: #9ca3af;">Ação</th>
                </tr>
            </thead>
            <tbody>
                <!-- Métricas -->
                ${metrics.map(m => `
                <tr>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #e0e6f0;">${m.label}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(m.valueA)}${m.unit}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(m.valueB)}${m.unit}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #ffc107;">${m.delta}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center;">
                        <span style="padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(m.severity)}22; color: ${getSeverityColor(m.severity)};">${m.severity}</span>
                    </td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #9ca3af; font-size: 9px;">${m.action}</td>
                </tr>
                `).join('')}
                <!-- Bandas -->
                ${bandsList.map(b => `
                <tr>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #e0e6f0;">${b.icon} ${b.label} <span style="font-size: 8px; color: #6b7280;">${b.range}</span></td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(b.valueA, 1)} dB</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #fff;">${nf(b.valueB, 1)} dB</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center; color: #ffc107;">${b.delta}</td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); text-align: center;">
                        <span style="padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(b.severity)}22; color: ${getSeverityColor(b.severity)};">${b.severity}</span>
                    </td>
                    <td style="padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.03); color: #9ca3af; font-size: 9px;">${b.action}</td>
                </tr>
                `).join('')}
            </tbody>
        </table>
    </div>
    
    <!-- Rodapé Página 1 -->
    <div style="position: absolute; bottom: 25px; left: 40px; right: 40px; text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 11px; color: #8B5CF6; font-weight: 600;">SoundyAI</p>
        <p style="margin: 3px 0 0 0; font-size: 9px; color: #6b7280;">Página 1/2 | Gerado automaticamente em ${date}</p>
    </div>
    
</div>
        `;
        
        // 🎨 GERAR HTML PÁGINA 2: PLANO DE CORREÇÃO
        const criticalItems = allItems.filter(i => i.severity === 'CRÍTICA');
        const highItems = allItems.filter(i => i.severity === 'ALTA');
        const warningItems = allItems.filter(i => i.severity === 'ATENÇÃO');
        const okItemsAll = allItems.filter(i => i.severity === 'OK');
        
        const renderSuggestionCard = (item, index) => `
        <div style="background: rgba(255,255,255,0.03); border-left: 3px solid ${getSeverityColor(item.severity)}; border-radius: 8px; padding: 12px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <h4 style="margin: 0; font-size: 12px; font-weight: 600; color: #fff;">${item.label}${item.range ? ` (${item.range})` : ''}</h4>
                <span style="padding: 2px 8px; border-radius: 4px; font-size: 9px; font-weight: 600; background: ${getSeverityColor(item.severity)}22; color: ${getSeverityColor(item.severity)};">${item.severity}</span>
            </div>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #9ca3af;"><strong>Problema:</strong> Diferença de ${item.delta} detectada</p>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #9ca3af;"><strong>Meta:</strong> ${nf(item.valueB)}${item.unit || ' dB'}</p>
            <p style="margin: 0 0 6px 0; font-size: 10px; color: #52f7ad;"><strong>Ação:</strong> ${item.action}</p>
            <p style="margin: 0; font-size: 9px; color: #6b7280;"><strong>Impacto:</strong> ${item.severity === 'CRÍTICA' ? 'Essencial para qualidade profissional' : item.severity === 'ALTA' ? 'Melhora significativa esperada' : 'Refinamento para maior proximidade'}</p>
        </div>
        `;
        
        const page2HTML = `
<div class="pdf-page-2" style="width: 794px; height: 1123px; background: #0a0f1a; color: #e0e6f0; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">
    
    <!-- Header -->
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid rgba(139, 92, 246, 0.3);">
        <div>
            <h1 style="margin: 0; font-size: 28px; font-weight: 700; background: linear-gradient(135deg, #8B5CF6, #3B82F6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">SoundyAI</h1>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #9ca3af;">Plano de Correção</p>
        </div>
        <div style="text-align: right;">
            <p style="margin: 0; font-size: 12px; color: #e0e6f0;">${trackAName}</p>
            <p style="margin: 3px 0 0 0; font-size: 10px; color: #6b7280;">Página 2/2</p>
        </div>
    </div>
    
    <!-- Título -->
    <h2 style="margin: 0 0 15px 0; font-size: 18px; font-weight: 600; color: #8B5CF6;">🛠️ Plano de Correção (Passo a Passo)</h2>
    
    <!-- Seção CRÍTICAS -->
    ${criticalItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff4444;">🚨 CRÍTICAS (Corrigir Primeiro)</h3>
        ${criticalItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- Seção ALTAS -->
    ${highItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ff9800;">⚠️ ALTAS</h3>
        ${highItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- Seção ATENÇÃO -->
    ${warningItems.length > 0 ? `
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; font-weight: 600; color: #ffc107;">⚡ ATENÇÃO</h3>
        ${warningItems.map((item, i) => renderSuggestionCard(item, i)).join('')}
    </div>
    ` : ''}
    
    <!-- Seção OK (resumida) -->
    ${okItemsAll.length > 0 ? `
    <div style="background: rgba(82, 247, 173, 0.05); border: 1px solid rgba(82, 247, 173, 0.2); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
        <h3 style="margin: 0 0 8px 0; font-size: 13px; font-weight: 600; color: #52f7ad;">✅ Itens Dentro do Padrão</h3>
        <p style="margin: 0; font-size: 10px; color: #9ca3af; line-height: 1.5;">${okItemsAll.map(i => i.label).join(' • ')}</p>
    </div>
    ` : ''}
    
    <!-- Rodapé Página 2 -->
    <div style="position: absolute; bottom: 25px; left: 40px; right: 40px; text-align: center; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 11px; color: #8B5CF6; font-weight: 600;">SoundyAI © 2025</p>
        <p style="margin: 3px 0 0 0; font-size: 9px; color: #6b7280;">Inteligência Artificial para Produtores Musicais | soundy.ai</p>
    </div>
    
</div>
        `;
        
        // 🎯 RENDERIZAR E CAPTURAR PÁGINAS SEPARADAMENTE
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template não encontrado');
        }
        
        // Função helper para capturar uma página
        async function capturePage(html, pageName) {
            container.innerHTML = html;
            const elemento = container.firstElementChild;
            
            // Forçar visibilidade temporária
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.style.zIndex = '-1';
            
            await new Promise(r => setTimeout(r, 300));
            
            console.log(`[REF-PDF] 📸 Capturando ${pageName}...`);
            
            // Capturar com html2canvas
            const canvas = await html2canvas(elemento, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                backgroundColor: '#0a0f1a',
                useCORS: true,
                scale: 2
            });
            
            console.log(`[REF-PDF] ✅ ${pageName} capturada:`, canvas.width, 'x', canvas.height);
            
            return canvas;
        }
        
        // Capturar Página 1
        const canvas1 = await capturePage(page1HTML, 'Página 1');
        
        // Capturar Página 2
        const canvas2 = await capturePage(page2HTML, 'Página 2');
        
        // Gerar PDF com 2 páginas
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        // Adicionar Página 1
        const imgData1 = canvas1.toDataURL('image/png');
        pdf.addImage(imgData1, 'PNG', 0, 0, pageWidth, pageHeight);
        
        // Adicionar Página 2
        pdf.addPage();
        const imgData2 = canvas2.toDataURL('image/png');
        pdf.addImage(imgData2, 'PNG', 0, 0, pageWidth, pageHeight);
        
        // Sanitizar nomes para o arquivo
        const sanitize = (str) => (str || 'faixa').replace(/[^a-z0-9]/gi, '_').substring(0, 30);
        const fileName = `SoundyAI_Referencia_${sanitize(trackAName)}_vs_${sanitize(trackBName)}.pdf`;
        
        pdf.save(fileName);
        
        // Limpar container
        container.style.display = 'none';
        container.innerHTML = '';
        
        console.log('[REF-PDF] ✅ Relatório Premium gerado (2 páginas):', fileName);
        console.log('[REF-PDF] 📊 Estatísticas:', {
            totalItems: allItems.length,
            criticas: criticalItems.length,
            altas: highItems.length,
            atenção: warningItems.length,
            ok: okItemsAll.length,
            score: score
        });
        
        showTemporaryFeedback('✅ Relatório Premium (2 páginas) baixado!');
        
    } catch (error) {
        console.error('[REF-PDF] ❌ Erro ao gerar relatório:', error);
        showTemporaryFeedback('❌ Erro ao gerar PDF');
        alert(`Erro ao gerar relatório:\n\n${error.message}`);
    }
}

// � Mostrar feedback temporário
// (definição duplicada de showTemporaryFeedback removida — mantida a versão consolidada abaixo)

// 📄 Baixar relatório do modal (IMPLEMENTAÇÃO ROBUSTA COM VALIDAÇÃO)
async function downloadModalAnalysis() {
    // 🔒 GUARD: Bloquear funcionalidade premium em modo reduced
    // ✅ Prioridade 1: Sistema centralizado de capabilities
    if (window.PlanCapabilities && window.PlanCapabilities.shouldBlockPdf()) {
        console.log('🔒 [PREMIUM-GUARD] Funcionalidade "Baixar Relatório" bloqueada');
        console.log('📊 [PREMIUM-GUARD] Contexto:', window.PlanCapabilities.getCurrentContext());
        
        // ✅ Abrir modal de upgrade (com classe visible para CSS)
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            console.log('✅ [PREMIUM-GUARD] Modal de upgrade aberto (PDF)');
        } else {
            console.error('❌ [PREMIUM-GUARD] Modal upgradeModal não encontrado no DOM');
        }
        return; // ✅ BLOQUEIO: Não executa função real
    }
    
    // ✅ Prioridade 2: Fallback para APP_MODE (compatibilidade)
    if (window.APP_MODE === 'reduced') {
        console.log('🔒 [PREMIUM-GUARD] Funcionalidade "Baixar Relatório" bloqueada (fallback APP_MODE)');
        
        // ✅ Abrir modal de upgrade
        const modal = document.getElementById('upgradeModal');
        if (modal) {
            modal.classList.add('visible');
            const upgradeBtn = modal.querySelector('.upgrade-modal-cta');
            if (upgradeBtn) {
                upgradeBtn.onclick = () => window.location.href = '/planos.html';
            }
            const closeBtn = modal.querySelector('.upgrade-modal-close');
            if (closeBtn) {
                closeBtn.onclick = () => modal.classList.remove('visible');
            }
            console.log('✅ [PREMIUM-GUARD] Modal de upgrade aberto (PDF - fallback)');
        } else {
            console.error('❌ [PREMIUM-GUARD] Modal upgradeModal não encontrado no DOM');
        }
        return; // ✅ BLOQUEIO: Não executa função real
    }
    
    // 🎯 FIX CRÍTICO: Verificar modo REFERENCE primeiro (antes de validar analysis)
    // No modo reference, os dados estão em SoundyAI_Store, não em analysis
    const currentPdfMode = window.currentAnalysisMode || 'genre';
    if (currentPdfMode === 'reference') {
        console.log('[PDF-ROUTER] 🔀 Modo referência detectado - redirecionando para generateReferenceReportPDF()');
        return generateReferenceReportPDF();
    }
    
    // 1️⃣ VALIDAÇÃO: Verificar se análise está disponível no alias global (só para modo gênero)
    const analysis = window.__soundyAI?.analysis || currentModalAnalysis;
    
    if (!analysis) {
        alert('❌ Nenhuma análise disponível.\n\nFaça uma análise antes de gerar o relatório.');
        console.error('[PDF-ERROR] Análise não encontrada em window.__soundyAI.analysis ou currentModalAnalysis');
        return;
    }
    
    // 🔍 AUDITORIA: Mapear estrutura completa do objeto analysis
    console.log('🔍 [AUDIT-PDF] ============ INÍCIO DA AUDITORIA ============');
    console.log('🔍 [AUDIT-PDF] Analysis root keys:', Object.keys(analysis));
    console.log('🔍 [AUDIT-PDF] Fontes detectadas:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        userBands: analysis.user?.bands,
        diagnostics: analysis.diagnostics,
        problems: analysis.problems,
        _diagnostic: analysis._diagnostic,
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        score: analysis.score,
        userScore: analysis.user?.score
    });
    
    // 🔍 AUDITORIA: Comparar com valores da UI (modal Paperline)
    console.log('🔍 [AUDIT-UI] Valores exibidos na UI:', {
        score: document.querySelector('.score-final-value')?.dataset?.value || document.querySelector('.score-final-value')?.textContent,
        bandSub: document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent,
        bandBass: document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent,
        bandMid: document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent,
        bandHigh: document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent
    });
    
    console.log('📄 [PDF-START] Iniciando geração de relatório PDF...');
    console.log('📄 [PDF-SOURCE] Fonte de dados:', {
        usingGlobalAlias: !!window.__soundyAI?.analysis,
        usingCurrentModal: !!currentModalAnalysis,
        fileName: analysis.fileName || analysis.metadata?.fileName,
        hasLoudness: !!(analysis.loudness || analysis.lufsIntegrated),
        hasTruePeak: !!(analysis.truePeak || analysis.truePeakDbtp)
    });
    
    // 2️⃣ VALIDAÇÃO: Verificar dependências
    if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
        showTemporaryFeedback('⚙️ Carregando bibliotecas...');
        console.warn('⚠️ [PDF-WAIT] Aguardando carregamento de jsPDF/html2canvas...');
        
        // Retry após 1s
        setTimeout(() => downloadModalAnalysis(), 1000);
        return;
    }
    
    try {
        showTemporaryFeedback('⚙️ Gerando relatório PDF...');
        
        // 3️⃣ VALIDAÇÃO CONTRA UI: Comparar dados do relatório com a UI
        validateAnalysisDataAgainstUI(analysis);
        
        // 4️⃣ NORMALIZAR: Extrair e formatar dados
        const normalizedData = normalizeAnalysisDataForPDF(analysis);
        
        // 5️⃣ GERAR HTML: Template profissional
        const reportHTML = generateReportHTML(normalizedData);
        
        // 6️⃣ PREPARAR CONTAINER: Inserir e tornar visível
        const container = document.getElementById('pdf-report-template');
        if (!container) {
            throw new Error('Container #pdf-report-template não encontrado no DOM');
        }
        
        container.innerHTML = reportHTML;
        const elemento = container.firstElementChild;
        if (!elemento) {
            throw new Error('Template HTML não foi renderizado corretamente');
        }
        
        // Salvar estilos originais
        const originalStyles = {
            display: container.style.display,
            visibility: container.style.visibility,
            position: container.style.position,
            left: container.style.left,
            top: container.style.top,
            zIndex: container.style.zIndex
        };
        
        // ✅ PROPORÇÃO FIXA A4: 794x1123 px (resolução base vertical)
        const A4_WIDTH = 794;
        const A4_HEIGHT = 1123;
        const A4_RATIO = A4_HEIGHT / A4_WIDTH; // 1.414 (proporção A4)
        
        // Forçar visibilidade temporária com proporção A4 fixa
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.position = 'fixed';
        container.style.left = '50%';
        container.style.top = '0';
        container.style.transform = 'translateX(-50%)'; // Centralizar horizontalmente
        container.style.zIndex = '9999';
        container.style.width = `${A4_WIDTH}px`; // Largura fixa A4
        container.style.height = 'auto';
        container.style.margin = '0 auto';
        
        console.log('📊 [PDF-RENDER] Container preparado com proporção A4:', {
            baseWidth: A4_WIDTH,
            baseHeight: A4_HEIGHT,
            ratio: A4_RATIO,
            containerWidth: elemento.offsetWidth,
            containerHeight: elemento.offsetHeight,
            isVisible: elemento.offsetWidth > 0 && elemento.offsetHeight > 0
        });
        
        // 7️⃣ AGUARDAR RENDERIZAÇÃO: 250ms base + scroll + 150ms
        await new Promise(r => setTimeout(r, 250));
        elemento.scrollIntoView({ behavior: 'instant', block: 'start' });
        await new Promise(r => setTimeout(r, 150));
        
        // ✅ 8️⃣ CAPTURAR PÁGINAS SEPARADAMENTE com proporção fixa A4
        console.log('📸 [PDF-CAPTURE] Iniciando captura em 2 páginas lógicas com proporção A4 fixa...');
        
        // ✅ PROPORÇÃO FIXA: Sempre usar 794px (A4) com scale 2 (alta qualidade)
        // NÃO depende de viewport - garante consistência desktop/mobile
        const CAPTURE_WIDTH = A4_WIDTH; // 794px
        const CAPTURE_SCALE = 2; // Alta qualidade (1588px efetivos)
        const CAPTURE_BG = '#0a0a0f'; // Fundo escuro profissional
        
        console.log('� [PDF-A4-FIXED]', {
            captureWidth: CAPTURE_WIDTH,
            captureScale: CAPTURE_SCALE,
            backgroundColor: CAPTURE_BG,
            effectiveWidth: CAPTURE_WIDTH * CAPTURE_SCALE,
            note: 'Proporção A4 fixa (não depende de viewport)'
        });
        
        const section1 = elemento.querySelector('.pdf-section-metrics');
        const section2 = elemento.querySelector('.pdf-section-diagnostics');
        
        if (!section1 || !section2) {
            throw new Error('❌ Seções PDF não encontradas. Verifique as classes .pdf-section-metrics e .pdf-section-diagnostics');
        }
        
        console.log('� [PDF-CAPTURE] Capturando Página 1 (Métricas)...');
        // ✅ Função genérica e segura de captura A4 com wrapper virtual
        async function renderSectionToPDF(element, sectionName) {
            const wrapper = document.createElement('div');
            const isMobile = window.innerWidth < 768;
            wrapper.style.width = '794px';
            wrapper.style.height = '1123px';
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'flex-start';
            wrapper.style.justifyContent = 'center';
            wrapper.style.background = '#0a0a0f';
            wrapper.style.padding = '0';  // ✅ Zero padding no wrapper
            wrapper.style.position = 'fixed';
            wrapper.style.left = '-9999px';
            wrapper.style.top = '0';
            wrapper.style.zIndex = '-1';
            wrapper.style.overflow = 'hidden';
            
            // Clona o conteúdo e aplica padding no clone (não no wrapper)
            const clone = element.cloneNode(true);
            clone.style.padding = isMobile ? '10px' : '20px';  // ✅ Padding no conteúdo
            clone.style.boxSizing = 'border-box';
            clone.style.width = '100%';
            clone.style.height = '100%';
            wrapper.appendChild(clone);
            document.body.appendChild(wrapper);
            
            // Aguarda renderização
            await new Promise(r => setTimeout(r, 150));
            
            console.log(`📐 [PDF-WRAPPER] ${sectionName}:`, {
                declared: { width: '794px', height: '1123px' },
                computed: {
                    offsetWidth: wrapper.offsetWidth,
                    offsetHeight: wrapper.offsetHeight,
                    clientWidth: wrapper.clientWidth,
                    clientHeight: wrapper.clientHeight
                },
                usableArea: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    lostHeight: 1123 - wrapper.clientHeight
                },
                padding: isMobile ? '10px (clone)' : '20px (clone)',
                note: 'Padding aplicado no clone, não no wrapper'
            });
            
            // Captura com parâmetros fixos A4
            const canvas = await html2canvas(wrapper, {
                width: 794,
                height: 1123,
                windowWidth: 794,
                windowHeight: 1123,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: '#0a0a0f',
                useCORS: true,
                allowTaint: true,
                logging: false,
                scale: 2
            });
            
            document.body.removeChild(wrapper);
            
            const ratio = (canvas.height / canvas.width).toFixed(3);
            const expectedRatio = (1123 / 794).toFixed(3);
            console.log(`🖼️ [PDF-CANVAS] ${sectionName}:`, {
                canvasSize: { width: canvas.width, height: canvas.height },
                ratio,
                expectedRatio,
                match: ratio === expectedRatio ? '✅' : '⚠️'
            });
            
            return canvas;
        }
        
        const canvas1 = await renderSectionToPDF(section1, 'Métricas');
        
        const canvas2 = await renderSectionToPDF(section2, 'Diagnóstico');
        
        console.log('✅ [PDF-CANVAS] Páginas capturadas:', {
            page1: { width: canvas1.width, height: canvas1.height },
            page2: { width: canvas2.width, height: canvas2.height }
        });
        
        if (canvas1.width === 0 || canvas1.height === 0 || canvas2.width === 0 || canvas2.height === 0) {
            throw new Error('Canvas vazio - verifique se as seções estão visíveis');
        }
        
        // ✅ Validação final de proporção A4
        const ratio1 = (canvas1.height / canvas1.width).toFixed(3);
        const ratio2 = (canvas2.height / canvas2.width).toFixed(3);
        const expectedRatio = (1123 / 794).toFixed(3);
        
        console.log('[PDF] Proporção A4 preservada com sucesso (' + expectedRatio + ')');
        console.log('[PDF] Canvas1: ' + canvas1.width + 'x' + canvas1.height + ' | Canvas2: ' + canvas2.width + 'x' + canvas2.height);
        console.log('[PDF] Exportação concluída sem achatamento ✔️');
        
        // ✅ 9️⃣ GERAR PDF COM PROPORÇÃO A4 E MARGENS (centralização perfeita mobile)
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'p' });
        
        const pageWidth = pdf.internal.pageSize.getWidth(); // 210mm
        const pageHeight = pdf.internal.pageSize.getHeight(); // 297mm
        
        // ✅ Zero margens para ambos dispositivos (100% fill A4)
        const SIDE_MARGIN_MM = 0;
        const TOP_MARGIN_MM = 0;
        const BOTTOM_MARGIN_MM = 0;
        
        console.log('� [PDF-A4-FORMAT]', {
            pageWidth,
            pageHeight,
            margins: 'ZERO (100% fill)',
            format: 'A4 Portrait (210x297mm)'
        });
        
        // ✅ Função unificada: preencher 100% A4 (desktop e mobile)
        function addCanvasAsA4PageCentered(cnv, sectionName) {
            // Começar pela altura (preencher verticalmente)
            let imgHeight = pageHeight; // 297mm
            let imgWidth = (cnv.width * imgHeight) / cnv.height;
            
            // Se largura ultrapassar, reajustar por largura
            if (imgWidth > pageWidth) {
                imgWidth = pageWidth; // 210mm
                imgHeight = (cnv.height * imgWidth) / cnv.width;
            }
            
            // Posição absoluta no canto (sem margens)
            const x = 0;
            const y = 0;
            
            const fillPercentage = ((imgHeight / pageHeight) * 100).toFixed(1);
            
            console.log(`📄 [PDF-BUILD] ${sectionName}:`, {
                canvasSize: { width: cnv.width, height: cnv.height },
                pageSize: { width: pageWidth, height: pageHeight },
                imgWidth: imgWidth.toFixed(2),
                imgHeight: imgHeight.toFixed(2),
                position: { x, y },
                fillPercentage: `${fillPercentage}%`,
                margins: 'ZERO (100% fill)'
            });
            
            const imgData = cnv.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
        }
        
        // Página 1 (Métricas)
        addCanvasAsA4PageCentered(canvas1, 'Página 1 (Métricas)');
        
        // Página 2 (Diagnóstico/Recomendações)
        pdf.addPage();
        addCanvasAsA4PageCentered(canvas2, 'Página 2 (Diagnóstico)');
        
        // 🔟 DOWNLOAD: Nome descritivo com data
        const cleanFileName = (normalizedData.fileName || 'audio')
            .replace(/\.[^/.]+$/, '')
            .replace(/[^a-z0-9_-]/gi, '_');
        const dateStr = new Date().toISOString().split('T')[0];
        const fileName = `Relatorio_SoundyAI_${cleanFileName}_${dateStr}.pdf`;
        
        pdf.save(fileName);
        
        console.log('✅ [PDF-SUCCESS] Relatório gerado:', fileName);
        showTemporaryFeedback('✅ Relatório PDF baixado com sucesso!');
        
        // RESTAURAR: Estilos originais
        Object.assign(container.style, originalStyles);
        
        // 🔒 GUARD: Não limpar container se estiver em modo reference (apagaria tabela A/B!)
        const currentMode = window.currentAnalysisMode || window.__soundyState?.render?.mode;
        if (currentMode !== 'reference') {
            setTimeout(() => container.innerHTML = '', 100);
            console.log('[PDF-CLEANUP] Container limpo (modo não-reference)');
        } else {
            console.log('[PDF-CLEANUP] ⚠️ Container PRESERVADO (modo reference ativo)');
        }
        
    } catch (error) {
        console.error('❌ [PDF-ERROR] Erro ao gerar relatório:', error);
        console.error('❌ [PDF-ERROR] Stack:', error.stack);
        showTemporaryFeedback('❌ Erro ao gerar PDF');
        alert(`Erro ao gerar relatório PDF:\n\n${error.message}\n\nVerifique o console para mais detalhes.`);
    }
}


// 🔍 VALIDAÇÃO: Comparar dados do relatório com a UI
function validateAnalysisDataAgainstUI(analysis) {
    console.log('🔍 [PDF-VALIDATE] Iniciando validação contra UI...');
    console.log('🧠 [PDF-AUDIT] Análise Global:', analysis);
    
    const assertEqual = (label, pdfValue, uiSelector, tolerance = 0.01) => {
        const uiElement = document.querySelector(uiSelector);
        if (!uiElement) {
            console.warn(`⚠️ [PDF-VALIDATE] Elemento UI não encontrado: ${uiSelector}`);
            return;
        }
        
        let uiValue = uiElement.dataset?.value || 
                     uiElement.getAttribute('data-value') ||
                     parseFloat(uiElement.textContent.replace(/[^0-9.-]/g, ''));
        
        if (isNaN(uiValue)) {
            console.warn(`⚠️ [PDF-VALIDATE] Valor UI não numérico em ${uiSelector}`);
            return;
        }
        
        if (pdfValue == null || isNaN(pdfValue)) {
            console.warn(`⚠️ [PDF-VALIDATE] Valor PDF ausente para ${label}`);
            return;
        }
        
        const diff = Math.abs(Number(pdfValue) - Number(uiValue));
        const ok = diff < tolerance;
        
        if (!ok) {
            console.warn(`🚨 [PDF-VALIDATE] DIVERGÊNCIA em ${label}:`, {
                pdf: pdfValue,
                ui: uiValue,
                diferenca: diff.toFixed(3)
            });
        } else {
            console.log(`✅ [PDF-VALIDATE] ${label}: OK (diff=${diff.toFixed(4)})`);
        }
    };
    
    try {
        const lufsValue = analysis.lufsIntegrated || analysis.loudness?.integrated || analysis.technicalData?.lufsIntegrated;
        if (lufsValue) assertEqual('LUFS Integrado', lufsValue, '[data-metric="lufs-integrated"]', 0.1);
        
        const truePeakValue = analysis.truePeakDbtp || analysis.truePeak?.maxDbtp || analysis.technicalData?.truePeakDbtp;
        if (truePeakValue) assertEqual('True Peak', truePeakValue, '[data-metric="true-peak"]', 0.1);
        
        const drValue = analysis.dynamicRange || analysis.dynamics?.range || analysis.technicalData?.dynamicRange;
        if (drValue) assertEqual('Dynamic Range', drValue, '[data-metric="dynamic-range"]', 0.5);
        
        // 🎯 VALIDAÇÃO CRÍTICA DE SCORE: Comparar TODAS as fontes
        console.log('🎯 [PDF-VALIDATE-SCORE] ============ VALIDAÇÃO CRÍTICA DE SCORE ============');
        console.log('🎯 [PDF-VALIDATE-SCORE] Fontes disponíveis no objeto analysis:', {
            'analysis.score': analysis.score,
            'analysis.scores.final': analysis.scores?.final,
            'analysis.scoring.final': analysis.scoring?.final,
            'analysis.user.score': analysis.user?.score
        });
        
        // Extrair score da UI
        const uiScoreElement = document.querySelector('.score-final-value');
        let scoreUI = null;
        if (uiScoreElement) {
            const rawValue = uiScoreElement.dataset?.value || uiScoreElement.textContent || '';
            scoreUI = parseFloat(rawValue.replace(/[^0-9.-]/g, ''));
            if (isNaN(scoreUI)) scoreUI = null;
        }
        
        console.log('🎯 [PDF-VALIDATE-SCORE] Score na UI:', scoreUI);
        
        // Validar se todas as fontes estão alinhadas
        const scoreSources = [
            { name: 'analysis.score', value: analysis.score },
            { name: 'analysis.scores.final', value: analysis.scores?.final },
            { name: 'analysis.scoring.final', value: analysis.scoring?.final },
            { name: 'UI (.score-final-value)', value: scoreUI }
        ];
        
        const validScores = scoreSources.filter(s => Number.isFinite(s.value) && s.value >= 0 && s.value <= 100);
        
        if (validScores.length === 0) {
            console.error('❌ [PDF-VALIDATE-SCORE] NENHUM score válido encontrado!');
        } else if (validScores.length === 1) {
            console.log('✅ [PDF-VALIDATE-SCORE] Apenas 1 fonte de score disponível:', validScores[0].name, '=', validScores[0].value);
        } else {
            // Verificar divergências entre fontes
            const scoreValues = validScores.map(s => Math.round(s.value));
            const uniqueScores = [...new Set(scoreValues)];
            
            if (uniqueScores.length === 1) {
                console.log('✅ [PDF-VALIDATE-SCORE] TODAS as fontes estão SINCRONIZADAS:', uniqueScores[0]);
                validScores.forEach(s => {
                    console.log(`  ✅ ${s.name}: ${s.value}`);
                });
            } else {
                console.error('🚨 [PDF-VALIDATE-SCORE] DIVERGÊNCIA DETECTADA ENTRE FONTES:');
                validScores.forEach(s => {
                    console.error(`  ⚠️ ${s.name}: ${s.value}`);
                });
                console.error('🚨 [PDF-VALIDATE-SCORE] Scores únicos encontrados:', uniqueScores);
                console.error('🚨 [PDF-VALIDATE-SCORE] ATENÇÃO: Esta divergência pode causar relatórios incorretos!');
            }
        }
        
        console.log('🎯 [PDF-VALIDATE-SCORE] ============ FIM DA VALIDAÇÃO ============');
        
        console.log('✅ [PDF-VALIDATE] Validação concluída');
    } catch (error) {
        console.error('❌ [PDF-VALIDATE] Erro na validação:', error);
    }
}

// 🎯 Normalizar dados da análise para formato compatível com PDF (NOVA VERSÃO ROBUSTA)
function normalizeAnalysisDataForPDF(analysis) {
    console.log('📊 [PDF-NORMALIZE] ============ INÍCIO DA NORMALIZAÇÃO ============');
    console.log('📊 [PDF-NORMALIZE] Estrutura recebida:', {
        keys: Object.keys(analysis),
        fileName: analysis.fileName || analysis.metadata?.fileName,
        score: analysis.score,
        hasLufsRoot: !!analysis.lufsIntegrated,
        hasTruePeakRoot: !!analysis.truePeakDbtp,
        hasDRRoot: !!analysis.dynamicRange,
        hasBands: !!(analysis.bands || analysis.spectralBands)
    });
    
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return '—';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    const extract = (...paths) => {
        for (const path of paths) {
            if (typeof path === 'function') {
                const val = path();
                if (Number.isFinite(val)) return val;
            } else if (Number.isFinite(path)) {
                return path;
            }
        }
        return null;
    };
    
    const lufsIntegrated = extract(analysis.lufsIntegrated, analysis.loudness?.integrated, analysis.technicalData?.lufsIntegrated);
    const lufsShortTerm = extract(analysis.avgLoudness, analysis.loudness?.shortTerm, analysis.technicalData?.avgLoudness);
    const lufsMomentary = extract(lufsShortTerm, analysis.loudness?.momentary);
    const lra = extract(analysis.lra, analysis.loudness?.lra, analysis.technicalData?.lra);
    
    console.log('🎧 [PDF-NORMALIZE] Loudness extraído:', { integrated: lufsIntegrated, shortTerm: lufsShortTerm, momentary: lufsMomentary, lra });
    
    const truePeakDbtp = extract(analysis.truePeakDbtp, analysis.truePeak?.maxDbtp, analysis.technicalData?.truePeakDbtp);
    const clippingSamples = extract(analysis.truePeak?.clipping?.samples, analysis.clipping?.samples, 0);
    const clippingPercentage = extract(analysis.truePeak?.clipping?.percentage, analysis.clipping?.percentage, 0);
    
    console.log('⚙️ [PDF-NORMALIZE] True Peak extraído:', { maxDbtp: truePeakDbtp, clipping: { samples: clippingSamples, percentage: clippingPercentage }});
    
    const dynamicRange = extract(analysis.dynamicRange, analysis.dynamics?.range, analysis.technicalData?.dynamicRange);
    const crestFactor = extract(analysis.crestFactor, analysis.dynamics?.crest, analysis.technicalData?.crestFactor);
    
    console.log('🎚️ [PDF-NORMALIZE] Dinâmica extraída:', { range: dynamicRange, crest: crestFactor });
    
    const stereoWidth = extract(analysis.stereo?.width, analysis.stereoWidth, analysis.technicalData?.stereoWidth);
    const stereoCorrelation = extract(analysis.stereoCorrelation, analysis.stereo?.correlation, analysis.technicalData?.stereoCorrelation);
    const monoCompatibility = extract(analysis.stereo?.monoCompatibility, analysis.monoCompatibility);
    
    console.log('🎛️ [PDF-NORMALIZE] Stereo extraído:', { width: stereoWidth, correlation: stereoCorrelation, monoCompatibility });
    
    // 🔍 AUDITORIA: Mapear todas as fontes possíveis de bandas espectrais
    console.log('📈 [AUDIT-FREQ] Bandas disponíveis em analysis:', {
        bands: analysis.bands,
        spectralBands: analysis.spectralBands,
        spectral: analysis.spectral,
        spectralBands_nested: analysis.spectral?.bands,
        userBands: analysis.user?.bands,
        userSpectralBands: analysis.user?.spectralBands,
        userSpectral: analysis.user?.spectral
    });
    
    // ✅ FREQUÊNCIAS — corrigindo campos energy_db, percentage e range
    const bandsSrc = analysis.bands || analysis.spectralBands || analysis.spectral?.bands || {};
    const extractBand = (band) => {
      if (!band) return { db: '—', pct: '—', range: '' };
      if (typeof band === 'number') return { db: band.toFixed(1), pct: '—', range: '' };
      const db = band.energy_db ?? band.rms_db ?? band.value ?? null;
      const pct = band.percentage ?? band.percent ?? null;
      const range = band.range ?? '';
      return {
        db: db !== null ? db.toFixed(1) : '—',
        pct: pct !== null ? pct.toFixed(1) + '%' : '—',
        range
      };
    };

    // Formata todas as bandas principais
    const spectral = {
      sub:  extractBand(bandsSrc.sub),
      bass: extractBand(bandsSrc.bass),
      lowMid: extractBand(bandsSrc.lowMid),
      mid:  extractBand(bandsSrc.mid),
      highMid: extractBand(bandsSrc.highMid),
      presence: extractBand(bandsSrc.presence),
      air: extractBand(bandsSrc.air)
    };

    console.log('� [PDF-FIX] Bandas espectrais resolvidas:', spectral);
    
    // ✅ SCORE SINCRONIZADO COM A UI
    let score = analysis.scoring?.final 
             ?? analysis.user?.score 
             ?? analysis.scores?.final 
             ?? analysis.score 
             ?? 0;

    const uiScoreEl = document.querySelector('.score-final-value');
    if (uiScoreEl) {
      const scoreUI = parseFloat(uiScoreEl.dataset?.value || uiScoreEl.textContent || '0');
      if (!isNaN(scoreUI) && scoreUI > 0 && Math.abs(score - scoreUI) > 1) {
        console.warn('⚙️ [PDF-FIX] Score ajustado com base na UI:', { old: score, new: scoreUI });
        score = scoreUI;
      }
    } else {
      console.warn('⚠️ [PDF-FIX] Elemento de score na UI não encontrado, mantendo score:', score);
    }
    
    score = Math.round(score);
    const classification = analysis.classification || analysis.scoring?.classification || getClassificationFromScore(score);
    const fileName = analysis.fileName || analysis.metadata?.fileName || analysis.fileKey?.split('/').pop() || 'audio_sem_nome.wav';
    const duration = extract(analysis.duration, analysis.metadata?.duration, 0);
    const sampleRate = extract(analysis.sampleRate, analysis.metadata?.sampleRate, 44100);
    const channels = extract(analysis.channels, analysis.metadata?.channels, 2);
    
    // 🔍 AUDITORIA: Mapear todas as fontes possíveis de diagnósticos
    console.log('🩺 [AUDIT-DIAG] Diagnóstico disponível em analysis:', {
        problems: analysis.problems,
        diagnostics: analysis.diagnostics,
        _diagnostic: analysis._diagnostic,
        userProblems: analysis.user?.problems,
        userDiagnostics: analysis.user?.diagnostics,
        problemsType: Array.isArray(analysis.problems) ? 'array' : typeof analysis.problems,
        diagnosticsType: Array.isArray(analysis.diagnostics) ? 'array' : typeof analysis.diagnostics
    });
    
    // ✅ DIAGNÓSTICO AUTOMÁTICO
    let diagnostics = [];

    if (analysis.diagnostics?.problems?.length > 0) {
      diagnostics = analysis.diagnostics.problems.map(p => p.message || p);
    } 
    else if (analysis.diagnostics?.suggestions?.length > 0) {
      diagnostics = analysis.diagnostics.suggestions.map(s => 
        `⚠️ ${s.message || s.type || 'Sugestão'} — ${s.why || s.action || ''}`
      );
    } 
    else {
      diagnostics = ['✅ Nenhum problema detectado'];
    }

    console.log('🩺 [PDF-FIX] Diagnóstico enriquecido:', diagnostics);
    
    // 🔍 AUDITORIA: Mapear todas as fontes possíveis de sugestões
    console.log('💡 [AUDIT-SUG] Sugestões detectadas em analysis:', {
        suggestions: analysis.suggestions,
        suggestionsAdvanced: analysis.suggestionsAdvanced,
        recommendations: analysis.recommendations,
        aiSuggestions: analysis.ai?.suggestions,
        aiSuggestionsEnriched: analysis.ai?.suggestions?.enriched,
        userSuggestions: analysis.user?.suggestions,
        userSuggestionsAdvanced: analysis.user?.suggestionsAdvanced,
        _suggestionsGenerated: analysis._suggestionsGenerated,
        suggestionsType: Array.isArray(analysis.suggestions) ? `array[${analysis.suggestions?.length}]` : typeof analysis.suggestions,
        advancedType: Array.isArray(analysis.suggestionsAdvanced) ? `array[${analysis.suggestionsAdvanced?.length}]` : typeof analysis.suggestionsAdvanced
    });
    
    // ✅ SUGESTÕES ENRIQUECIDAS
    let suggestions = [];

    if (analysis.diagnostics?.suggestions?.length > 0) {
      suggestions = analysis.diagnostics.suggestions.map(s => {
        const title = s.message || s.type || 'Ajuste recomendado';
        const action = s.action ? ` → ${s.action}` : '';
        const why = s.why ? ` (${s.why})` : '';
        return `${title}${action}${why}`;
      });
    } else if (Array.isArray(analysis.suggestions)) {
      suggestions = analysis.suggestions.map(s => 
        typeof s === 'string' ? s : s.message || s.type || 'Sugestão'
      );
    }

    console.log('💡 [PDF-FIX] Sugestões enriquecidas:', suggestions);
    
    // Normalizar para 'recommendations' (compatibilidade com retorno)
    const recommendations = suggestions.length > 0 ? suggestions : ['✅ Análise completa'];
    
    const normalizedResult = {
        score,
        classification,
        fileName,
        duration,
        sampleRate,
        channels,
        bitDepth: analysis.bitDepth || analysis.metadata?.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(lufsIntegrated, 1),
            shortTerm: formatValue(lufsShortTerm, 1),
            momentary: formatValue(lufsMomentary, 1),
            lra: formatValue(lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeakDbtp, 2),
            clipping: { samples: clippingSamples || 0, percentage: formatValue(clippingPercentage, 2) }
        },
        dynamics: {
            range: formatValue(dynamicRange, 1),
            crest: formatValue(crestFactor, 1)
        },
        spectral: spectral,
        stereo: {
            width: formatValue(stereoWidth * 100, 1),
            correlation: formatValue(stereoCorrelation, 2),
            monoCompatibility: formatValue(monoCompatibility * 100, 1)
        },
        diagnostics: diagnostics.length > 0 ? diagnostics : ['✅ Nenhum problema detectado'],
        recommendations: recommendations.length > 0 ? recommendations : ['✅ Análise completa']
    };
    
    // 🔍 AUDITORIA: Resumo final comparativo
    console.log('📊 [AUDIT-PDF-SUMMARY] Resumo da Auditoria:', {
        hasFrequencies: !!(spectral.sub !== '—' || spectral.bass !== '—' || spectral.mid !== '—' || spectral.high !== '—'),
        frequenciesValues: spectral,
        hasDiagnostics: diagnostics.length > 0 && diagnostics[0] !== '✅ Nenhum problema detectado',
        diagnosticsCount: diagnostics.length,
        hasSuggestions: recommendations.length > 0 && recommendations[0] !== '✅ Análise completa',
        suggestionsCount: recommendations.length,
        suggestionsEnriched: analysis._suggestionsGenerated === true,
        score: score,
        scoreSource: analysis.score ? 'analysis.score' : (analysis.user?.score ? 'analysis.user.score' : 'scoreUI')
    });
    
    // 🔍 AUDITORIA: Comparar dados normalizados com valores da UI
    const uiSub = document.querySelector('[data-metric="band-sub"]')?.dataset?.value || document.querySelector('[data-metric="band-sub"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiBass = document.querySelector('[data-metric="band-bass"]')?.dataset?.value || document.querySelector('[data-metric="band-bass"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiMid = document.querySelector('[data-metric="band-mid"]')?.dataset?.value || document.querySelector('[data-metric="band-mid"]')?.textContent?.replace(/[^0-9.-]/g, '');
    const uiHigh = document.querySelector('[data-metric="band-high"]')?.dataset?.value || document.querySelector('[data-metric="band-high"]')?.textContent?.replace(/[^0-9.-]/g, '');
    
    console.log('🎚 [AUDIT-FREQ-COMPARE] Comparação UI vs PDF:', {
        sub: { ui: uiSub, pdf: spectral.sub, match: parseFloat(uiSub) === parseFloat(spectral.sub) },
        bass: { ui: uiBass, pdf: spectral.bass, match: parseFloat(uiBass) === parseFloat(spectral.bass) },
        mid: { ui: uiMid, pdf: spectral.mid, match: parseFloat(uiMid) === parseFloat(spectral.mid) },
        high: { ui: uiHigh, pdf: spectral.high, match: parseFloat(uiHigh) === parseFloat(spectral.high) }
    });
    
    console.log('✅ [PDF-NORMALIZE] Resultado normalizado:', normalizedResult);
    console.log('📊 [PDF-NORMALIZE] ============ FIM DA NORMALIZAÇÃO ============');
    
    return normalizedResult;
}

// � Normalizar dados da análise para formato compatível com PDF
function normalizeAnalysisData(analysis) {
    // 🔍 DIAGNÓSTICO: Log completo da estrutura recebida
    console.log('📊 [PDF-NORMALIZE] ============ INÍCIO DA NORMALIZAÇÃO ============');
    console.log('📊 [PDF-NORMALIZE] Análise completa recebida:', analysis);
    console.log('📊 [PDF-NORMALIZE] Chaves disponíveis:', Object.keys(analysis));
    
    // 🔧 CORREÇÃO: Dados podem estar na raiz, em metrics, ou em tech
    const metrics = analysis.metrics || {};
    const tech = analysis.tech || analysis.technicalData || {};
    
    console.log('🔍 [PDF-NORMALIZE] Origem dos dados:', {
        hasMetrics: !!analysis.metrics,
        hasTech: !!analysis.tech,
        hasTechnicalData: !!analysis.technicalData,
        hasRootData: !!(analysis.loudness || analysis.truePeak || analysis.lufsIntegrated),
        metricsKeys: Object.keys(metrics),
        techKeys: Object.keys(tech)
    });
    
    // 🔧 CORREÇÃO: Loudness pode estar em múltiplos lugares
    const loudness = metrics.loudness || tech.loudness || analysis.loudness || {
        // Fallback para propriedades na raiz
        integrated: analysis.lufsIntegrated,
        shortTerm: analysis.avgLoudness,
        momentary: analysis.avgLoudness,
        lra: analysis.lra
    };
    console.log('🎧 [PDF-NORMALIZE] Loudness extraído:', {
        source: metrics.loudness ? 'metrics' : (tech.loudness ? 'tech' : (analysis.loudness ? 'analysis.loudness' : 'raiz')),
        data: loudness,
        integrated: loudness.integrated,
        shortTerm: loudness.shortTerm,
        momentary: loudness.momentary,
        lra: loudness.lra
    });
    
    // 🔧 CORREÇÃO: True Peak pode estar em múltiplos lugares
    const truePeak = metrics.truePeak || tech.truePeak || analysis.truePeak || {
        // Fallback para propriedades na raiz
        maxDbtp: analysis.truePeakDbtp,
        clipping: { samples: 0, percentage: 0 }
    };
    console.log('⚙️ [PDF-NORMALIZE] True Peak extraído:', {
        source: metrics.truePeak ? 'metrics' : (tech.truePeak ? 'tech' : (analysis.truePeak ? 'analysis.truePeak' : 'raiz')),
        data: truePeak,
        maxDbtp: truePeak.maxDbtp,
        clipping: truePeak.clipping
    });
    
    // 🔧 CORREÇÃO: Dinâmica pode estar em múltiplos lugares
    const dynamics = metrics.dynamics || tech.dynamics || analysis.dynamics || {
        // Fallback para propriedades na raiz
        range: analysis.dynamicRange,
        crest: analysis.crestFactor
    };
    console.log('🎚️ [PDF-NORMALIZE] Dynamics extraído:', {
        source: metrics.dynamics ? 'metrics' : (tech.dynamics ? 'tech' : (analysis.dynamics ? 'analysis.dynamics' : 'raiz')),
        data: dynamics,
        range: dynamics.range,
        crest: dynamics.crest
    });
    
    // 🔧 CORREÇÃO: Espectro pode estar em múltiplos lugares
    const spectral = metrics.spectral || tech.spectral || analysis.spectral || {};
    const bands = spectral.bands || analysis.spectralBands || analysis.bands || {};
    console.log('📈 [PDF-NORMALIZE] Spectral extraído:', {
        source: metrics.spectral ? 'metrics' : (tech.spectral ? 'tech' : (analysis.spectral ? 'analysis.spectral' : (analysis.bands ? 'analysis.bands' : 'vazio'))),
        spectral: spectral,
        bands: bands,
        bandsKeys: Object.keys(bands)
    });
    
    // 🔧 CORREÇÃO: Stereo pode estar em múltiplos lugares
    const stereo = metrics.stereo || tech.stereo || analysis.stereo || {};
    console.log('🎛️ [PDF-NORMALIZE] Stereo extraído:', {
        source: metrics.stereo ? 'metrics' : (tech.stereo ? 'tech' : (analysis.stereo ? 'analysis.stereo' : 'vazio')),
        data: stereo,
        width: stereo.width,
        correlation: stereo.correlation,
        monoCompatibility: stereo.monoCompatibility
    });
    
    // Score e classificação
    const score = analysis.qualityOverall || analysis.score || 0;
    const classification = analysis.classification || getClassificationFromScore(score);
    
    // Diagnósticos e recomendações
    const problems = analysis.problems || [];
    const suggestions = analysis.suggestions || [];
    const diagnostics = problems.length > 0 
        ? problems.map(p => p.message || p) 
        : ['✅ Nenhum problema crítico detectado'];
    const recommendations = suggestions.length > 0 
        ? suggestions.map(s => s.message || s.action || s) 
        : ['✅ Análise completa realizada com sucesso'];
    
    // Formatação segura de valores
    const formatValue = (val, decimals = 1, unit = '') => {
        if (val === null || val === undefined || isNaN(val)) return 'N/A';
        return `${Number(val).toFixed(decimals)}${unit}`;
    };
    
    // Log do resultado final normalizado
    const normalizedResult = {
        score: Math.round(score),
        classification,
        fileName: analysis.fileName || 'audio_sem_nome.wav',
        duration: analysis.duration || 0,
        sampleRate: analysis.sampleRate || 44100,
        channels: analysis.channels || 2,
        bitDepth: analysis.bitDepth || 'N/A',
        loudness: {
            integrated: formatValue(loudness.integrated, 1),
            shortTerm: formatValue(loudness.shortTerm, 1),
            momentary: formatValue(loudness.momentary, 1),
            lra: formatValue(loudness.lra, 1)
        },
        truePeak: {
            maxDbtp: formatValue(truePeak.maxDbtp, 2),
            clipping: {
                samples: truePeak.clipping?.samples || 0,
                percentage: formatValue(truePeak.clipping?.percentage, 2)
            }
        },
        dynamics: {
            range: formatValue(dynamics.range, 1),
            crest: formatValue(dynamics.crest, 1)
        },
        spectral: {
            sub: formatValue(bands.sub || bands.subBass, 1),
            bass: formatValue(bands.bass, 1),
            mid: formatValue(bands.mid || bands.midrange, 1),
            high: formatValue(bands.presence || bands.high || bands.treble, 1)
        },
        stereo: {
            width: formatValue(stereo.width, 1),
            correlation: formatValue(stereo.correlation, 2),
            monoCompatibility: formatValue(stereo.monoCompatibility, 1)
        },
        diagnostics,
        recommendations
    };
    
    console.log('✅ [PDF-NORMALIZE] Resultado final normalizado:', normalizedResult);
    console.log('📊 [PDF-NORMALIZE] ============ FIM DA NORMALIZAÇÃO ============');
    
    return normalizedResult;
}

// 🏆 Classificação baseada em score
function getClassificationFromScore(score) {
    // 🎯 USAR EXATAMENTE OS MESMOS TEXTOS DO MODAL DA PÁGINA PRINCIPAL
    // (renderFinalScoreAtTop - linha 19055)
    if (score >= 90) {
        return '✨ Excelente! Pronto para lançamento';
    }
    if (score >= 75) {
        return '✅ Ótimo! Qualidade profissional';
    }
    if (score >= 60) {
        return '⚠️ Bom, mas pode melhorar';
    }
    if (score >= 40) {
        return '🔧 Precisa de ajustes';
    }
    return '🚨 Necessita correções importantes';
}

// 🎨 Gerar HTML profissional do relatório para PDF
function generateReportHTML(data) {
    // 🔍 AUDITORIA: Verificar dados recebidos para geração do HTML
    console.log('📝 [AUDIT-HTML] ============ INÍCIO DA GERAÇÃO DO HTML ============');
    console.log('📝 [AUDIT-HTML] Dados recebidos:', {
        score: data.score,
        classification: data.classification,
        spectral: data.spectral,
        diagnostics: data.diagnostics,
        recommendations: data.recommendations,
        hasSpectralData: !!(data.spectral && (data.spectral.sub !== '—' || data.spectral.bass !== '—')),
        hasDiagnostics: data.diagnostics?.length > 0,
        hasRecommendations: data.recommendations?.length > 0
    });
    
    const date = new Date().toLocaleDateString('pt-BR');
    const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    
    // Formatar duração
    const minutes = Math.floor(data.duration / 60);
    const seconds = Math.floor(data.duration % 60);
    const durationStr = `${minutes}:${String(seconds).padStart(2, '0')}`;
    
    return `
<div id="report-pdf-container" style="background: #0B0C14;">
    
    <!-- Estilos para otimização desktop do PDF -->
    <style>
        /* Ajustes apenas para desktop (viewport >= 768px) */
        @media (min-width: 768px) {
            .frequency-spectrum-container {
                margin-top: -10px !important;
                margin-bottom: 20px !important;
            }
            
            .frequency-spectrum-cards {
                transform: scale(0.95);
                transform-origin: top center;
                margin-bottom: -10px;
            }
            
            .freq-card {
                height: 75px !important;
                padding: 10px !important;
            }
            
            /* Ajustes de rodapé e recomendações (página 2) */
            .pdf-section-diagnostics .pdf-footer {
                margin-top: 25px !important;
                padding-bottom: 10px;
                position: relative;
                bottom: 0;
            }
            
            .pdf-section-recommendations {
                transform: scale(0.97);
                transform-origin: top center;
            }
        }
        
        /* Mobile mantém estilos originais (< 768px) */
        @media (max-width: 767px) {
            .frequency-spectrum-container {
                margin-top: 0 !important;
            }
            
            .frequency-spectrum-cards {
                transform: none;
            }
            
            .freq-card {
                height: auto !important;
            }
        }
    </style>
    
    <!-- ✅ PÁGINA 1: MÉTRICAS PRINCIPAIS -->
    <div class="pdf-section-metrics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 32px; font-weight: 700; letter-spacing: -0.5px;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 14px; color: #AAA;">Inteligência Artificial para Produtores Musicais</p>
            </div>
            <div style="text-align: right;">
                <h2 style="color: #8B5CF6; margin: 0; font-size: 24px; font-weight: 600;">Relatório de Análise</h2>
                <p style="font-size: 12px; color: #AAA; margin: 5px 0 0 0;">${date} às ${time}</p>
            </div>
        </div>

        <!-- Score Card -->
    <div style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); padding: 20px 30px; border-radius: 12px; color: white; margin-bottom: 30px; box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="margin: 0; font-size: 48px; font-weight: 700;">${data.score}<span style="font-size: 32px; opacity: 0.8;">/100</span></h1>
                <p style="margin: 8px 0 0 0; font-size: 18px; opacity: 0.95; font-weight: 500;">SCORE FINAL</p>
            </div>
            <div style="font-size: 64px; opacity: 0.9;">🎵</div>
        </div>
    </div>

    <!-- Informações do Arquivo -->
    <div style="background: rgba(255,255,255,0.05); padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid #8B5CF6;">
        <p style="margin: 0; font-size: 12px; color: #AAA; text-transform: uppercase; letter-spacing: 0.5px;">ARQUIVO ANALISADO</p>
        <p style="margin: 8px 0 0 0; font-size: 16px; font-weight: 600; color: #FFF;">${data.fileName}</p>
        <p style="margin: 5px 0 0 0; font-size: 13px; color: #999;">
            ⏱️ ${durationStr} min &nbsp;|&nbsp; 🎚️ ${data.sampleRate}Hz &nbsp;|&nbsp; 🔊 ${data.channels === 2 ? 'Stereo' : data.channels + ' canais'}
        </p>
    </div>

    <!-- Grid de Métricas -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
        
        <!-- Loudness Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">🎧</span> Loudness
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Integrado:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.integrated} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Curto Prazo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.shortTerm} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Momentâneo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.momentary} LUFS</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">LRA:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.loudness.lra} LU</span>
                </div>
            </div>
        </div>

        <!-- True Peak Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">⚙️</span> True Peak
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Pico Real:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.truePeak.maxDbtp} dBTP</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Clipping (samples):</span>
                    <span style="font-weight: 600; color: ${data.truePeak.clipping.samples > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.samples}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Clipping (%):</span>
                    <span style="font-weight: 600; color: ${parseFloat(data.truePeak.clipping.percentage) > 0 ? '#FF7B7B' : '#52F7AD'};">${data.truePeak.clipping.percentage}%</span>
                </div>
            </div>
        </div>

        <!-- Dinâmica Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">🎚️</span> Dinâmica
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Dynamic Range:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.range} dB</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Crest Factor:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.dynamics.crest}</span>
                </div>
            </div>
        </div>

        <!-- Stereo Card -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">🎛️</span> Stereo
            </h3>
            <div style="font-size: 13px; line-height: 2;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Largura Stereo:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.width}%</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="color: #AAA;">Correlação:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.correlation}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: #AAA;">Compat. Mono:</span>
                    <span style="font-weight: 600; color: #FFF;">${data.stereo.monoCompatibility}%</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Espectro de Frequências -->
    <div class="frequency-spectrum-container" style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 25px; border: 1px solid rgba(139, 92, 246, 0.2);">
        <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
            <span style="margin-right: 10px; font-size: 22px;">📈</span> Espectro de Frequências
        </h3>
        <div class="frequency-spectrum-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; font-size: 13px;">
            ${(() => {
                const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 768;
                const cardPadding = isDesktop ? '10px' : '12px';
                const fontSizeLarge = isDesktop ? '14px' : '18px';
                const marginTop = isDesktop ? '5px' : '8px';
                
                const renderBand = (label, band, range) => {
                    if (!band || !band.db) return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #AAA; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">—</p>
                        </div>
                    `;
                    return `
                        <div class="freq-card" style="text-align: center; padding: ${cardPadding}; background: rgba(139, 92, 246, 0.1); border-radius: 8px; height: ${isDesktop ? '75px' : 'auto'};">
                            <p style="margin: 0; color: #8B5CF6; font-size: 10px; text-transform: uppercase; font-weight: 600;">${label}</p>
                            <p style="margin: 0; color: #666; font-size: 9px;">${range}</p>
                            <p style="margin: ${marginTop} 0 0 0; font-weight: 700; font-size: ${fontSizeLarge}; color: #FFF;">${band.db} dB</p>
                        </div>
                    `;
                };
                
                return [
                    renderBand('SUB', data.spectral.sub, '20-60Hz'),
                    renderBand('GRAVE', data.spectral.bass, '60-150Hz'),
                    renderBand('LOW MID', data.spectral.lowMid, '150-500Hz'),
                    renderBand('MÉDIO', data.spectral.mid, '500-2kHz'),
                    renderBand('HIGH MID', data.spectral.highMid, '2-5kHz'),
                    renderBand('PRESENCE', data.spectral.presence, '5-10kHz'),
                    renderBand('AR', data.spectral.air, '10-20kHz')
                ].join('');
            })()}
        </div>
    </div>

    <!-- Rodapé da Página 1 -->
    <div style="text-align: center; padding-top: 40px; margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1);">
        <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">SoundyAI © 2025</p>
        <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">Página 1/2 | Métricas Principais</p>
    </div>

    </div>
    <!-- FIM DA PÁGINA 1 -->

    <!-- ✅ PÁGINA 2: DIAGNÓSTICO E RECOMENDAÇÕES -->
    <div class="pdf-section-diagnostics" style="width: 794px; min-height: 1123px; background: #0B0C14; color: #EAEAEA; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 40px; box-sizing: border-box; position: relative;">

        <!-- Header Simplificado (Página 2) -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px; border-bottom: 2px solid rgba(139, 92, 246, 0.3); padding-bottom: 20px;">
            <div>
                <h1 style="color: #8B5CF6; margin: 0; font-size: 28px; font-weight: 700;">SoundyAI</h1>
                <p style="margin: 5px 0 0 0; font-size: 13px; color: #AAA;">Diagnóstico e Recomendações da IA</p>
            </div>
            <div style="text-align: right;">
                <p style="font-size: 14px; color: #AAA; margin: 0;">${data.fileName}</p>
                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">Página 2/2</p>
            </div>
        </div>

        <!-- Diagnóstico -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">🧠</span> Diagnóstico Automático
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.diagnostics.map(d => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">•</span> ${d}
                </li>`).join('')}
            </ul>
        </div>

        <!-- Recomendações -->
        <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; margin-bottom: 50px; border: 1px solid rgba(139, 92, 246, 0.2);">
            <h3 style="color: #8B5CF6; margin: 0 0 15px 0; font-size: 18px; font-weight: 600; display: flex; align-items: center;">
                <span style="margin-right: 10px; font-size: 22px;">💡</span> Recomendações da IA
            </h3>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 13px; line-height: 1.9;">
                ${data.recommendations.map(r => `<li style="margin-bottom: 8px; padding-left: 20px; position: relative; color: #DDD;">
                    <span style="position: absolute; left: 0; color: #8B5CF6;">•</span> ${r}
                </li>`).join('')}
            </ul>
        </div>

        <!-- Rodapé Final -->
        <div style="position: absolute; bottom: 30px; left: 40px; right: 40px; text-align: center; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
            <p style="margin: 0; font-size: 13px; color: #8B5CF6; font-weight: 600;">
                SoundyAI © 2025
            </p>
            <p style="margin: 5px 0 0 0; font-size: 11px; color: #666;">
                Inteligência Artificial para Produtores Musicais | Relatório gerado automaticamente
            </p>
        </div>

    </div>
    <!-- FIM DA PÁGINA 2 -->

</div>
    `;
}

// �📋 Gerar relatório detalhado (LEGACY - mantido para compatibilidade)
function generateDetailedReport(analysis) {
    const now = new Date();
    let report = `🎵 PROD.AI - RELATÓRIO DE ANÁLISE DE ÁUDIO\n`;
    report += `${'='.repeat(50)}\n\n`;
    report += `📅 Data: ${now.toLocaleString('pt-BR')}\n`;
    report += `🔬 Análise realizada com tecnologia Web Audio API\n\n`;
    
    report += `📊 DADOS TÉCNICOS PRINCIPAIS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `Peak Level: ${analysis.technicalData.peak.toFixed(2)} dB\n`;
    report += `RMS Level: ${analysis.technicalData.rms.toFixed(2)} dB\n`;
    report += `Dynamic Range: ${analysis.technicalData.dynamicRange.toFixed(2)} dB\n`;
    report += `Duration: ${analysis.duration.toFixed(2)} seconds\n`;
    report += `Sample Rate: ${analysis.sampleRate || 'N/A'} Hz\n`;
    report += `Channels: ${analysis.channels || 'N/A'}\n\n`;
    
    if (analysis.technicalData?.dominantFrequencies?.length > 0) {
        report += `🎯 FREQUÊNCIAS DOMINANTES:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.technicalData.dominantFrequencies.slice(0, 10).forEach((freq, i) => {
            report += `${i + 1}. ${Math.round(freq.frequency)} Hz (${freq.occurrences} ocorrências)\n`;
        });
        report += `\n`;
    }
    
    if (analysis.problems.length > 0) {
        report += `🚨 PROBLEMAS DETECTADOS:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.problems.forEach((problem, i) => {
            report += `${i + 1}. PROBLEMA: ${problem.message}\n`;
            report += `   SOLUÇÃO: ${problem.solution}\n`;
            report += `   SEVERIDADE: ${problem.severity}\n\n`;
        });
    }
    
    if (analysis.suggestions.length > 0) {
        report += `💡 SUGESTÕES DE MELHORIA:\n`;
        report += `${'-'.repeat(30)}\n`;
        analysis.suggestions.forEach((suggestion, i) => {
            report += `${i + 1}. ${suggestion.message}\n`;
            report += `   AÇÃO: ${suggestion.action}\n`;
            report += `   TIPO: ${suggestion.type}\n\n`;
        });
    }
    
    report += `📝 OBSERVAÇÕES TÉCNICAS:\n`;
    report += `${'-'.repeat(30)}\n`;
    report += `• Esta análise foi realizada usando Web Audio API\n`;
    report += `• Para análises mais avançadas, considere usar ferramentas profissionais\n`;
    report += `• Valores de referência: RMS ideal para streaming: -14 LUFS\n`;
    report += `• Peak ideal: máximo -1 dB para evitar clipping\n`;
    report += `• Dynamic range ideal: entre 8-15 dB para música popular\n\n`;
    
    report += `🎵 Gerado por PROD.AI - Seu mentor de produção musical\n`;
    report += `📱 Para mais análises: prod-ai-teste.vercel.app\n`;
    
    return report;
}

// 💬 Mostrar feedback temporário
function showTemporaryFeedback(message) {
    // Criar elemento de feedback
    const feedback = document.createElement('div');
    feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #00d4ff, #0096cc);
        color: #000;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10001;
        animation: slideInRight 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    `;
    feedback.textContent = message;
    
    // Adicionar animação CSS
    if (!document.getElementById('feedbackStyles')) {
        const style = document.createElement('style');
        style.id = 'feedbackStyles';
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.body.appendChild(feedback);
    
    // Remover após 3 segundos
    setTimeout(() => {
        feedback.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.parentNode.removeChild(feedback);
            }
        }, 300);
    }, 3000);
}

__dbg('🎵 Audio Analyzer Integration Script carregado!');

// Inicializar quando a página carregar
document.addEventListener('DOMContentLoaded', function() {
    __dbg('🎵 DOM carregado, inicializando Audio Analyzer...');
    initializeAudioAnalyzerIntegration();
});

// Fallback: se o DOM já estiver carregado
if (document.readyState !== 'loading') {
    // se DOM já pronto, inicializar uma vez
    initializeAudioAnalyzerIntegration();
}

// Utilitário opcional: testar consistência das métricas com reanálises repetidas do mesmo arquivo
// Uso (dev): window.__testConsistency(file, 3).then(console.log)
if (typeof window !== 'undefined' && !window.__testConsistency) {
    window.__testConsistency = async function(file, runs = 3) {
        const out = { runs: [], deltas: {} };
        for (let i = 0; i < runs; i++) {
            const t0 = performance.now();
            // 🆔 CORREÇÃO: Adicionar runId para funções de teste de consistência
            const testOptions = prepareAnalysisOptions({}, `consistency_${i+1}`);
            const res = await window.audioAnalyzer.analyzeAudioFile(file, testOptions);
            const t1 = performance.now();
            out.runs.push({
                idx: i+1,
                lufs: res?.technicalData?.lufsIntegrated ?? res?.metrics?.lufs ?? null,
                truePeakDbtp: res?.technicalData?.truePeakDbtp ?? res?.metrics?.truePeakDbtp ?? null,
                dr: res?.technicalData?.dynamicRange ?? res?.metrics?.dynamicRange ?? null,
                lra: res?.technicalData?.lra ?? null,
                processingMs: res?.processingMs ?? (t1 - t0)
            });
        }
        // calcular deltas
        const vals = (key) => out.runs.map(r => r[key]).filter(v => Number.isFinite(v));
        const stats = (arr) => arr.length ? { min: Math.min(...arr), max: Math.max(...arr), spread: Math.max(...arr)-Math.min(...arr) } : null;
        out.deltas.lufs = stats(vals('lufs'));
        out.deltas.truePeakDbtp = stats(vals('truePeakDbtp'));
        out.deltas.dr = stats(vals('dr'));
        out.deltas.lra = stats(vals('lra'));
        return out;
    };
}

// 🎯 FINAL: Display Reference Results
window.displayReferenceResults = function(referenceResults) {
    window.logReferenceEvent('displaying_reference_results', {
        baseline_source: referenceResults.baseline_source,
        has_suggestions: referenceResults.referenceSuggestions?.length > 0
    });
    
    try {
        const { comparisonData, referenceSuggestions, baseline_source } = referenceResults;
        
        if (baseline_source !== 'reference') {
            throw new Error(`Invalid baseline source: ${baseline_source}. Expected 'reference'`);
        }
        
        if (!comparisonData) {
            throw new Error('Missing comparison data in reference results');
        }

        const results = document.getElementById('results');
        if (!results) {
            throw new Error('Results container not found');
        }

        // Exibir seção de comparação
        displayComparisonSection(comparisonData, referenceSuggestions || []);
        
        // Se há sugestões, exibir
        if (referenceSuggestions && referenceSuggestions.length > 0) {
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = referenceSuggestions.map(suggestion => 
                    `<div class="suggestion-item">
                        <h4>${suggestion.category}</h4>
                        <p>${suggestion.text}</p>
                        <div class="suggestion-details">
                            <small>Diferença: ${suggestion.difference} | Threshold: ${suggestion.threshold}</small>
                        </div>
                    </div>`
                ).join('');
            }
        } else {
            // Audio idêntico - mostrar mensagem de sucesso
            const suggestionsList = document.getElementById('suggestions-list');
            if (suggestionsList) {
                suggestionsList.innerHTML = `
                    <div class="no-suggestions">
                        <h3>✅ Análise de Referência Concluída</h3>
                        <p>Os áudios são altamente similares. Diferenças dentro da tolerância aceitável.</p>
                    </div>
                `;
            }
        }
        
        window.logReferenceEvent('reference_results_displayed_successfully');
        
    } catch (error) {
        console.error('Error displaying reference results:', error);
        window.logReferenceEvent('reference_display_error', { 
            error: error.message,
            baseline_source: referenceResults.baseline_source 
        });
        
        // Fallback display
        const results = document.getElementById('results');
        if (results) {
            // 🛡️ PRESERVAR #referenceComparisons antes de limpar
            const refContainer = document.getElementById('referenceComparisons');
            const refHTML = refContainer ? refContainer.outerHTML : '';
            
            results.innerHTML = `
                <div class="error-display">
                    <h3>❌ Erro na Exibição dos Resultados</h3>
                    <p>Erro: ${error.message}</p>
                    <p>Baseline Source: ${referenceResults.baseline_source}</p>
                </div>
            `;
            
            // 🛡️ RESTAURAR #referenceComparisons após limpar
            if (refHTML) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = refHTML;
                results.appendChild(tempDiv.firstElementChild);
                console.log('[FALLBACK-ERROR] ✅ #referenceComparisons preservado durante erro');
            }
        }
    }
};

// =============== FUNÇÕES DE NORMALIZAÇÃO DE DADOS ===============

/**
 * 🎯 GERADOR DE SUGESTÕES BÁSICAS
 * Gera sugestões baseadas nas métricas técnicas (fallback se backend não enviar)
 * 
 * @param {Object} data - Dados normalizados da análise
 * @returns {Array} - Array de sugestões estruturadas
 */
function generateBasicSuggestions(data) {
    const suggestions = [];
    const technicalData = data.technicalData || {};
    
    console.log('[SUG-AUDIT] 🔍 generateBasicSuggestions INÍCIO:', {
        hasTechnicalData: !!technicalData,
        hasLufs: technicalData.lufsIntegrated != null,
        hasTruePeak: technicalData.truePeakDbtp != null,
        hasDR: technicalData.dynamicRange != null,
        hasLRA: technicalData.lra != null,
        hasBands: !!(technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands)
    });
    
    // Regra 1: LUFS Integrado
    if (technicalData.lufsIntegrated != null) {
        const lufs = technicalData.lufsIntegrated;
        const ideal = -10.5; // Padrão para streaming
        const delta = Math.abs(lufs - ideal);
        
        if (delta > 1.0) {
            suggestions.push({
                type: 'loudness',
                category: 'loudness',
                message: `LUFS Integrado está em ${lufs.toFixed(1)} dB quando deveria estar próximo de ${ideal.toFixed(1)} dB`,
                action: delta > 3 ? `Ajustar loudness em ${(ideal - lufs).toFixed(1)} dB via limitador` : `Refinar loudness final`,
                priority: delta > 3 ? 'crítica' : 'alta',
                band: 'full_spectrum',
                delta: (ideal - lufs).toFixed(1)
            });
        }
    }
    
    // Regra 2: True Peak
    if (technicalData.truePeakDbtp != null) {
        const tp = technicalData.truePeakDbtp;
        if (tp > -1.0) {
            suggestions.push({
                type: 'clipping',
                category: 'mastering',
                message: `True Peak em ${tp.toFixed(2)} dBTP está acima do limite seguro de -1.0 dBTP (risco de clipping em conversão)`,
                action: `Aplicar limitador com ceiling em -1.0 dBTP ou reduzir gain em ${(tp + 1.0).toFixed(2)} dB`,
                priority: 'crítica',
                band: 'full_spectrum',
                delta: (tp + 1.0).toFixed(2)
            });
        }
    }
    
    // Regra 3: Dynamic Range
    if (technicalData.dynamicRange != null) {
        const dr = technicalData.dynamicRange;
        const minDR = 6.0;
        
        if (dr < minDR) {
            suggestions.push({
                type: 'dynamics',
                category: 'mastering',
                message: `Dynamic Range está em ${dr.toFixed(1)} dB quando deveria estar acima de ${minDR.toFixed(1)} dB (mix muito comprimido)`,
                action: `Reduzir compressão/limitação para recuperar ${(minDR - dr).toFixed(1)} dB de dinâmica`,
                priority: 'alta',
                band: 'full_spectrum',
                delta: (minDR - dr).toFixed(1)
            });
        }
    }
    
    // Regra 4: LRA (Loudness Range)
    if (technicalData.lra != null) {
        const lra = technicalData.lra;
        const minLRA = 3.0; // Mínimo recomendado para evitar fadiga auditiva
        const maxLRA = 15.0; // Máximo para manter consistência
        
        if (lra < minLRA) {
            suggestions.push({
                type: 'lra_low',
                category: 'dynamics',
                message: `LRA (Loudness Range) está em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (mix sem variação dinâmica)`,
                action: `Aumentar variação dinâmica em ${(minLRA - lra).toFixed(1)} LU via automação ou compressão seletiva`,
                priority: 'média',
                band: 'full_spectrum',
                delta: (minLRA - lra).toFixed(1)
            });
        } else if (lra > maxLRA) {
            suggestions.push({
                type: 'lra_high',
                category: 'dynamics',
                message: `LRA (Loudness Range) está em ${lra.toFixed(1)} LU quando deveria estar entre ${minLRA} e ${maxLRA} LU (variação dinâmica excessiva)`,
                action: `Reduzir variação dinâmica em ${(lra - maxLRA).toFixed(1)} LU via compressão multibanda`,
                priority: 'média',
                band: 'full_spectrum',
                delta: (lra - maxLRA).toFixed(1)
            });
        }
    }
    
    // Regras 5-11: Bandas Espectrais (7 bandas)
    const bands = technicalData.bandEnergies || technicalData.spectral_balance || technicalData.bands || {};
    
    if (Object.keys(bands).length > 0) {
        const idealRanges = {
            sub: { min: -38, max: -28, name: 'Sub (20-60Hz)' },
            bass: { min: -31, max: -25, name: 'Bass (60-150Hz)' },
            lowMid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' },
            low_mid: { min: -28, max: -22, name: 'Low-Mid (150-500Hz)' }, // Alias
            mid: { min: -23, max: -17, name: 'Mid (500Hz-2kHz)' },
            highMid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' },
            high_mid: { min: -20, max: -14, name: 'High-Mid (2-5kHz)' }, // Alias
            presence: { min: -23, max: -17, name: 'Presence (5-10kHz)' },
            air: { min: -30, max: -24, name: 'Air (10-20kHz)' }
        };
        
        for (const [band, ideal] of Object.entries(idealRanges)) {
            const bandData = bands[band];
            if (bandData && typeof bandData.energy_db === 'number') {
                const value = bandData.energy_db;
                
                if (value < ideal.min) {
                    const delta = ideal.min - value;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} está em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB abaixo do mínimo)`,
                        action: `Aumentar ${ideal.name} em +${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'média',
                        band: band,
                        delta: `+${delta.toFixed(1)}`
                    });
                } else if (value > ideal.max) {
                    const delta = value - ideal.max;
                    suggestions.push({
                        type: 'eq',
                        category: 'eq',
                        message: `${ideal.name} está em ${value.toFixed(1)} dB quando deveria estar entre ${ideal.min} e ${ideal.max} dB (${delta.toFixed(1)} dB acima do máximo)`,
                        action: `Reduzir ${ideal.name} em -${delta.toFixed(1)} dB via EQ`,
                        priority: delta > 3 ? 'alta' : 'média',
                        band: band,
                        delta: `-${delta.toFixed(1)}`
                    });
                }
            }
        }
    }
    
    console.log(`[SUG-AUDIT] ✅ generateBasicSuggestions FIM: ${suggestions.length} sugestões geradas`);
    suggestions.forEach((sug, i) => {
        console.log(`[SUG-AUDIT] Sugestão ${i + 1}/${suggestions.length}:`, {
            type: sug.type,
            category: sug.category,
            message: sug.message.substring(0, 60) + '...',
            priority: sug.priority
        });
    });
    
    return suggestions;
}

/**
 * 🔧 FUNÇÃO CORRIGIDA: Normalizar dados do backend (compatível com JSON antigo e novo)
 * Mapeia a resposta do backend para o formato que o front-end espera
 * ✅ Compatível com JSON antigo e novo (pré/pós Redis)
 */
function normalizeBackendAnalysisData(result) {
    // 🔥 PROTEÇÃO CRÍTICA: Preservar technicalData e genreTargets ANTES de qualquer manipulação
    const __protected = {
        technicalData: structuredClone(result?.technicalData || result?.data?.technicalData || {}),
        genreTargets: structuredClone(result?.data?.genreTargets || result?.genreTargets || null),
        metadata: structuredClone(result?.metadata || {}),
        score: result?.score ?? null,
        classification: result?.classification ?? null
    };
    
    console.log('[NORMALIZE] 🛡️ PROTEÇÃO ATIVADA - Dados preservados:', {
        technicalDataKeys: Object.keys(__protected.technicalData).length,
        hasGenreTargets: !!__protected.genreTargets,
        genreTargetsKeys: __protected.genreTargets ? Object.keys(__protected.genreTargets) : null,
        hasMetadata: Object.keys(__protected.metadata).length > 0,
        score: __protected.score,
        classification: __protected.classification
    });
    
    // ✅ STEP 5/6: Blindagem total — clonar entrada para evitar mutação de objetos compartilhados
    if (result && typeof result === 'object') {
        console.log('[NORMALIZE] 🛡️ Clonando entrada para evitar contaminação');
        result = JSON.parse(JSON.stringify(result));
    }
    // �️ PROTEÇÃO: Detectar normalização duplicada
    if (result?.__normalized === true) {
        console.warn('[NORMALIZE] ⚠️ Objeto já foi normalizado anteriormente - retornando clone');
        console.warn('[NORMALIZE] jobId:', result?.jobId, 'fileName:', result?.metadata?.fileName);
        // Retornar clone profundo para evitar mutação
        return deepCloneSafe(result);
    }
    
    // �🔍 AUDITORIA: Capturar estado ANTES de normalização
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ⚙️ normalizeBackendAnalysisData - ENTRADA');
    console.log('📊 result (antes de normalizar):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result,
        hasMetadata: !!result?.metadata,
        hasTechnicalData: !!result?.technicalData,
        alreadyNormalized: result?.__normalized === true
    });
    console.groupEnd();
    
    console.log("[BACKEND RESULT] Received analysis with data:", result);
    
    // 🎯 PROTEÇÃO CRÍTICA: Preservar modo reference se segunda faixa está ativa
    const state = window.__soundyState || {};
    if (state.reference?.isSecondTrack && state.render?.mode !== 'reference') {
        console.warn('[FIX] Corrigindo mode: reference forçado (segunda faixa ativa)');
        state.render = state.render || {};
        state.render.mode = 'reference';
        window.__soundyState = state;
    }
    
    // ✅ Compatível com JSON antigo e novo (pré/pós Redis)
    const data = result?.data ?? result;
    const src = data.metrics || data.technicalData || data.loudness || data.spectral || data;

    if (!src) {
        console.error("[NORMALIZE] ❌ Nenhuma fonte de dados encontrada:", result);
        throw new Error("source is not defined");
    }

    console.log("[NORMALIZE] Source data extracted:", src);
    console.log("[NORMALIZE] Full data structure:", data);
    
    // 🎯 CRÍTICO: Preservar data.genre e data.genreTargets (FONTE OFICIAL DO BACKEND)
    console.log("[NORMALIZE] 🎵 Preservando genre do backend:", {
        'data.genre': data.genre,
        'result.data.genre': result?.data?.genre,
        'hasGenreTargets': !!(data.genreTargets || result?.data?.genreTargets)
    });
    
    // 🎯 CORREÇÃO #3: targets em reference mode
    // Se mode=reference e targets=null, normalizar para [] (não bloquear pipeline)
    if (backendMode === 'reference' && !data.genreTargets && !result?.data?.genreTargets) {
        console.log('[NORMALIZE] 🔧 Modo reference sem targets - normalizando para []');
        data.genreTargets = [];
    }

    const loudness = src.loudness || data.loudness || data.technicalData?.loudness || {};
    const dynamics = src.dynamics || data.dynamics || data.technicalData?.dynamics || {};
    const truePeak = src.truePeak || data.truePeak || data.technicalData?.truePeak || {};
    const energy = src.energy || data.energy || data.technicalData?.energy || {};
    const bands = src.bands || src.spectralBands || data.technicalData?.bands || data.technicalData?.spectralBands || data.spectralBands || {};

    // 🎯 CRÍTICO: Genre e mode no nível RAIZ (prioridade máxima para leitura)
    const backendGenre = result?.genre || 
                         data.genre || 
                         result?.data?.genre || 
                         result?.metadata?.genre ||
                         null;
    
    const backendMode = result?.mode || 
                        data.mode || 
                        'genre';
    
    // 🚨 RESTAURAÇÃO DE GÊNERO: Se backend retornou null E modo é genre, restaurar preservado
    const preservedGenre = window.__CURRENT_SELECTED_GENRE || window.__PRESERVED_GENRE__;
    const finalGenre = (backendMode === 'genre' && (!backendGenre || backendGenre === null))
                        ? preservedGenre
                        : backendGenre;
    
    if (backendMode === 'genre' && (!backendGenre || backendGenre === null) && preservedGenre) {
        console.warn('[NORMALIZE] ⚠️ Backend retornou genre NULL em modo genre!');
        console.warn('[NORMALIZE] 🔄 RESTAURANDO genre preservado:', preservedGenre);
        console.log('[GENRE-BEFORE-RESTORE]', { backendGenre, preservedGenre, finalGenre });
    }
    
    // 🎯 CORREÇÃO #1: Criar metrics NO TOP-LEVEL a partir de technicalData
    const metricsFromTechnicalData = {
        lufs: src.lufsIntegrated ?? loudness.integrated ?? null,
        truePeak: src.truePeakDbtp ?? truePeak.maxDbtp ?? null,
        dynamicRange: src.dynamicRange ?? dynamics.range ?? null,
        lra: src.lra ?? loudness.range ?? null,
        rms: src.avgLoudness ?? src.rmsLeft ?? null,
        crestFactor: src.crestFactor ?? dynamics.crest ?? null,
        stereoCorrelation: src.stereoCorrelation ?? null
    };
    
    console.log('[NORMALIZE] 📊 Metrics extraídas de technicalData:', metricsFromTechnicalData);

    const normalized = {
        // Preservar estrutura original
        ...data,
        
        genre: finalGenre,
        mode: backendMode,
        
        // 🎯 NOVO: Garantir metrics no top-level (FONTE ÚNICA)
        metrics: metricsFromTechnicalData,
        
        // 🎯 CRÍTICO: Garantir que data.genre venha da FONTE CORRETA
        // 🔥 CORREÇÃO DEFINITIVA: SPREAD PRIMEIRO, DEPOIS SOBRESCREVER com valores corretos
        data: {
            // PRIMEIRO: Spread para preservar outros dados
            ...(data.data || {}),
            
            // DEPOIS: FORÇAR genre e genreTargets (NUNCA podem ser sobrescritos!)
            genre: result?.genre || 
                   data.genre || 
                   result?.data?.genre || 
                   null,
            
            // 🔥 CORREÇÃO FASE 2: Priorizar data.data.genreTargets (onde backend realmente envia)
            // Backend monta: { data: { genreTargets: {...} } }
            // Ordem correta: data.data > result.data > __protected > null
            genreTargets: data.data?.genreTargets ||     // ✅ PRIORIDADE 1: Onde backend envia
                         result?.data?.genreTargets ||   // ✅ PRIORIDADE 2: Fallback estrutura alternativa
                         __protected.genreTargets ||     // ✅ PRIORIDADE 3: Backup protegido no início
                         null
        },
        
        // 🔍 AUDITORIA CRÍTICA: Verificar se spread contaminou genre
        __genreAudit: {
            preSpreadGenre: result?.genre || data.genre || null,
            dataDataGenre: data.data?.genre || null,
            spreadContamination: !!(data.data?.genre === null && (result?.genre || data.genre)),
            timestamp: new Date().toISOString()
        },
        
        // 🎯 Métricas normalizadas (RMS e LUFS separados)
        avgLoudness: energy.rms ?? 
                    src.avgLoudness ?? 
                    src.rms ??
                    data.technicalData?.avgLoudness ?? 
                    data.technicalData?.rms ??
                    data.energy?.rms ??
                    null,
        
        lufsIntegrated: loudness.integratedLUFS ?? 
                       loudness.integrated ?? 
                       src.lufsIntegrated ?? 
                       data.technicalData?.lufsIntegrated ?? 
                       data.loudness?.integrated ?? 
                       null,
                       
        lra: loudness.lra ?? 
             src.lra ?? 
             data.technicalData?.lra ?? 
             data.loudness?.lra ?? 
             null,
             
        truePeakDbtp: truePeak.maxDbtp ?? 
                     src.truePeakDbtp ?? 
                     data.technicalData?.truePeakDbtp ?? 
                     null,
                     
        dynamicRange: dynamics.range ?? 
                     src.dynamicRange ?? 
                     data.technicalData?.dynamicRange ?? 
                     null,
                     
        crestFactor: dynamics.crest ?? 
                    src.crestFactor ?? 
                    src.crest_factor ??
                    data.technicalData?.crestFactor ?? 
                    null,
                     
        bands: bands,
        
        // 🎯 Preservar estruturas aninhadas originais para fallback
        loudness: data.loudness || loudness,
        dynamics: data.dynamics || dynamics,
        truePeak: data.truePeak || truePeak,
        energy: data.energy || energy,
        
        // Estruturas técnicas
        technicalData: {
            // 🔥 CORREÇÃO CRÍTICA: NÃO reconstruir technicalData - usar APENAS o que veio do backend
            // O backend JÁ envia technicalData completo com todas as métricas
            // Qualquer reconstrução aqui DESTRÓI os dados originais
            ...(data.technicalData || {}),
            
            // ⚠️ FALLBACK MÍNIMO: Apenas se technicalData vier vazio (não deveria acontecer)
            // Estes fallbacks SÓ serão usados se o campo não existir no technicalData original
        },
        
        // 🎯 CRITICAL FIX: Adicionar objeto metrics com nomenclatura snake_case
        // Isso garante compatibilidade com calculateLoudnessScore/Dynamics/Stereo
        metrics: {
            lufs_integrated: loudness.integratedLUFS ?? 
                            loudness.integrated ?? 
                            src.lufsIntegrated ?? 
                            data.technicalData?.lufsIntegrated ?? 
                            data.loudness?.integrated ?? 
                            null,
            
            true_peak_dbtp: truePeak.maxDbtp ?? 
                           src.truePeakDbtp ?? 
                           data.technicalData?.truePeakDbtp ?? 
                           null,
            
            dynamic_range: dynamics.range ?? 
                          src.dynamicRange ?? 
                          data.technicalData?.dynamicRange ?? 
                          null,
            
            lra: loudness.lra ?? 
                src.lra ?? 
                data.technicalData?.lra ?? 
                data.loudness?.lra ?? 
                null,
            
            stereo_correlation: src.stereoCorrelation ?? 
                               data.technicalData?.stereoCorrelation ??
                               data.stereoCorrelation ??
                               null,
            
            stereo_width: src.stereoWidth ??
                         data.technicalData?.stereoWidth ??
                         data.stereoWidth ??
                         null,
            
            crest_factor: dynamics.crest ?? 
                         src.crestFactor ?? 
                         src.crest_factor ??
                         data.technicalData?.crestFactor ?? 
                         null
        },
        
        metadata: data.metadata ?? {},
        
        // Preservar outros campos importantes
        problems: data.problems || [],
        // ✅ PATCH CRÍTICO: Preservar suggestions do backend SEMPRE
        // Não usar || [] pois isso sobrescreve array vazio vindo do backend
        suggestions: Array.isArray(data.suggestions) ? data.suggestions : [],
        duration: data.duration || null,
        sampleRate: data.sampleRate || null,
        channels: data.channels || null,
        score: data.score || null,
        classification: data.classification || null
    };

    // ✅ AUDITORIA CRÍTICA PRÉ-GERAÇÃO: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] PRÉ-NORMALIZAÇÃO data.suggestions:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        willPreserve: Array.isArray(data.suggestions) && data.suggestions.length > 0
    });

    // ✅ GARANTIR SUGESTÕES BÁSICAS SE BACKEND NÃO ENVIOU
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Entrada:`, {
        hasSuggestions: Array.isArray(normalized.suggestions),
        suggestionsLength: normalized.suggestions?.length || 0,
        source: 'backend'
    });
    
    if (!normalized.suggestions || normalized.suggestions.length === 0) {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Gerando sugestões básicas no frontend...`);
        normalized.suggestions = generateBasicSuggestions(normalized);
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > ✅ ${normalized.suggestions.length} sugestões básicas geradas no frontend`);
    } else {
        console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > ✅ ${normalized.suggestions.length} sugestões vindas do backend (preservadas)`);
    }
    
    console.log(`[SUG-AUDIT] normalizeBackendAnalysisData > Saída:`, {
        suggestionsLength: normalized.suggestions.length,
        sampleFirst: normalized.suggestions[0]?.message?.substring(0, 50) + '...'
    });

    console.log("✅ [NORMALIZE] Parsed data:", normalized);
    console.log("✅ [NORMALIZE] Normalized metrics:", {
        avgLoudness: normalized.technicalData.avgLoudness,
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        crestFactor: normalized.technicalData.crestFactor,
        bands: normalized.technicalData.bandEnergies || normalized.technicalData.spectral_balance
    });
    
    // ✅ PATCH: garantir estrutura spectral_balance
    if (!normalized.technicalData.spectral_balance) {
        const sourceBands = result?.analysis?.bands || 
                           data?.bands || 
                           data?.frequencyBands || 
                           result?.bands ||
                           src?.spectral_balance ||
                           null;
        
        if (sourceBands) {
            normalized.technicalData.spectral_balance = sourceBands;
            console.log("✅ [NORMALIZER] spectral_balance restaurado automaticamente");
        } else {
            console.warn("⚠️ [NORMALIZER] Nenhum dado de bandas detectado — criando estrutura vazia");
            normalized.technicalData.spectral_balance = {
                sub: 0,
                bass: 0,
                low_mid: 0,
                mid: 0,
                high_mid: 0,
                presence: 0,
                air: 0
            };
        }
    }
    
    // �� LOGS ESPECÍFICOS DAS MÉTRICAS PRINCIPAIS (AUDITORIA COMPLETA RMS + LUFS)
    console.log('[AUDITORIA-RMS-LUFS] RMS:', normalized.technicalData.avgLoudness, 'LUFS:', normalized.technicalData.lufsIntegrated);
    
    // ✅ AUDITORIA CRÍTICA: Verificar se suggestions vieram do backend
    console.log('[SUG-AUDIT][CRITICAL] data.suggestions FROM BACKEND:', {
        exists: data.suggestions !== undefined,
        isArray: Array.isArray(data.suggestions),
        length: data.suggestions?.length || 0,
        type: typeof data.suggestions,
        sample: data.suggestions?.[0]
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > RMS=', normalized.technicalData.avgLoudness, {
        'energy.rms': energy.rms,
        'src.avgLoudness': src.avgLoudness,
        'src.rms': src.rms,
        'technicalData.avgLoudness': data.technicalData?.avgLoudness,
        'technicalData.rms': data.technicalData?.rms
    });
    
    console.log('[AUDITORIA-RMS-LUFS] normalizeBackendAnalysisData > LUFS=', normalized.technicalData.lufsIntegrated, {
        'loudness.integrated': loudness.integrated,
        'loudness.integratedLUFS': loudness.integratedLUFS,
        'src.lufsIntegrated': src.lufsIntegrated,
        'technicalData.lufsIntegrated': data.technicalData?.lufsIntegrated
    });
    
    // 🔥 FASE 2 - LOG DE VALIDAÇÃO: Confirmar que genreTargets foi preservado
    console.log('[FASE2-VALIDATION] 🎯 genreTargets após normalização:', {
        exists: !!normalized.data?.genreTargets,
        keys: normalized.data?.genreTargets ? Object.keys(normalized.data.genreTargets) : null,
        hasBands: !!normalized.data?.genreTargets?.bands,
        bandKeys: normalized.data?.genreTargets?.bands ? Object.keys(normalized.data.genreTargets.bands) : null,
        source: data.data?.genreTargets ? 'data.data' : 
                result?.data?.genreTargets ? 'result.data' : 
                __protected.genreTargets ? '__protected' : 'none'
    });
    
    console.log('[METRICS-FIX] normalizeBackendAnalysisData > CREST=', normalized.technicalData.crestFactor, {
        'dynamics.crest': dynamics.crest,
        'src.crestFactor': src.crestFactor,
        'src.crest_factor': src.crest_factor,
        'technicalData.crestFactor': data.technicalData?.crestFactor
    });

    // 🎯 CRÍTICO: Injetar genreReference no formato EXATO que o frontend espera
    const activeRef = window.__activeRefData;
    if (activeRef) {
        // Formato para o frontend (tabela de comparação)
        normalized.genreReference = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        // Compatibilidade com o Suggestion Engine
        normalized.data = normalized.data || {};
        normalized.data.genreTargets = {
            spectral_bands: activeRef.hybrid_processing?.spectral_bands || null,
            lufs: activeRef.targets_lufs || activeRef.targets?.lufs || null,
            true_peak: activeRef.targets_truePeak || activeRef.targets?.truePeak || null
        };
        
        console.log('[GENRE-REFERENCE-INJECT] ✅ genreReference injetado para frontend:', {
            hasSpectralBands: !!normalized.genreReference.spectral_bands,
            hasLufs: !!normalized.genreReference.lufs,
            hasTruePeak: !!normalized.genreReference.true_peak,
            bandCount: normalized.genreReference.spectral_bands ? Object.keys(normalized.genreReference.spectral_bands).length : 0
        });
    } else {
        console.warn('[GENRE-REFERENCE-INJECT] ⚠️ window.__activeRefData não disponível - tabela de comparação pode não renderizar');
    }

    // �️ MARCAR: Flag para prevenir normalização duplicada
    normalized.__normalized = true;
    normalized.__normalizedAt = Date.now();
    console.log('[NORMALIZE] ✅ Objeto marcado como normalizado:', normalized.jobId);

    // �🔍 AUDITORIA: Estado APÓS normalização
    console.groupCollapsed('[AUDITORIA_STATE_FLOW] ✅ normalizeBackendAnalysisData - SAÍDA');
    console.log('📊 normalized (resultado):', {
        jobId: normalized?.jobId,
        fileName: normalized?.metadata?.fileName || normalized?.fileName,
        lufs: normalized?.technicalData?.lufsIntegrated,
        objectId: normalized,
        sameAsInput: normalized === result
    });
    console.log('📊 result (input original - VERIFICAR SE MUDOU):', {
        jobId: result?.jobId,
        fileName: result?.metadata?.fileName || result?.fileName,
        lufs: result?.technicalData?.lufsIntegrated,
        objectId: result
    });
    console.log('⚠️ VERIFICAÇÃO DE MUTAÇÃO:');
    console.log('  normalized === result?', normalized === result);
    console.log('  normalized.technicalData === result.technicalData?', normalized.technicalData === result.technicalData);
    console.log('  normalized.metadata === result.metadata?', normalized.metadata === result.metadata);
    if (normalized.technicalData === result.technicalData) {
        console.warn('🚨 MUTAÇÃO DETECTADA: technicalData compartilha referência!');
    }
    if (normalized.metadata === result.metadata) {
        console.warn('🚨 MUTAÇÃO DETECTADA: metadata compartilha referência!');
    }
    console.groupEnd();

    // ========================================
    // 🔒 BLINDAGEM CRÍTICA: Quebrar compartilhamento de ponteiros
    // ========================================
    if (normalized && normalized.metadata) {
      // quebra compartilhamento de ponteiro
      normalized.metadata = { ...normalized.metadata };
    }
    if (normalized && normalized.technicalData) {
      normalized.technicalData = { ...normalized.technicalData };
    }
    if (normalized && normalized.bands) {
      normalized.bands = cloneDeepSafe(normalized.bands);
    }

    // 🔥 RESTAURAÇÃO CRÍTICA: Restaurar dados protegidos do backend
    console.log('[NORMALIZE] 🛡️ RESTAURANDO dados protegidos do backend');
    
    if (__protected.technicalData && Object.keys(__protected.technicalData).length > 0) {
        console.log('[NORMALIZE] ✅ Restaurando technicalData original:', Object.keys(__protected.technicalData).length, 'campos');
        normalized.technicalData = structuredClone(__protected.technicalData);
    } else {
        console.warn('[NORMALIZE] ⚠️ technicalData estava vazio na entrada - mantendo reconstruído');
    }
    
    if (__protected.genreTargets) {
        if (!normalized.data) normalized.data = {};
        console.log('[NORMALIZE] ✅ Restaurando genreTargets original:', Object.keys(__protected.genreTargets));
        normalized.data.genreTargets = structuredClone(__protected.genreTargets);
    } else {
        console.warn('[NORMALIZE] ⚠️ genreTargets estava ausente na entrada');
    }
    
    if (Object.keys(__protected.metadata).length > 0) {
        console.log('[NORMALIZE] ✅ Restaurando metadata original');
        normalized.metadata = structuredClone(__protected.metadata);
    }
    
    if (__protected.score !== null) {
        console.log('[NORMALIZE] ✅ Restaurando score original:', __protected.score);
        normalized.score = __protected.score;
    }
    
    if (__protected.classification !== null) {
        console.log('[NORMALIZE] ✅ Restaurando classification original:', __protected.classification);
        normalized.classification = __protected.classification;
    }

    // ========================================
    // 🔒 RETORNO FINAL: Clone profundo para garantir isolamento total
    // ========================================
    const normalizedOut = cloneDeepSafe(normalized);
    Object.defineProperty(normalizedOut, 'sameAsInput', { value: false, enumerable: false });
    return normalizedOut;
}

// =============== FUNÇÕES AUXILIARES ===============

// ================================================================
// 🧪 TESTE DE PARIDADE V3.7: Validar CEILING vs BANDPASS
// Garante que evaluateMetric() retorna severidades corretas
// ================================================================
function testScoreV37Parity() {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('🧪 [V3.7 PARITY TEST] Iniciando testes de paridade CEILING/BANDPASS');
    console.log('═══════════════════════════════════════════════════════════');
    
    const results = [];
    
    // ============================================================
    // CASO A: True Peak DENTRO do target (-1.2 < -1.0) => OK
    // ============================================================
    const caseA = {
        name: 'True Peak OK (abaixo do target)',
        metricKey: 'truePeak',
        measuredValue: -1.2,
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'OK',
        expectedScoreMin: 90 // Score deve ser alto
    };
    
    // ============================================================
    // CASO B: True Peak ACIMA do target (0.5 > -1.0) => CRÍTICA
    // ESTE É O BUG CRÍTICO QUE ESTAVA ACONTECENDO
    // ============================================================
    const caseB = {
        name: 'True Peak CRÍTICA (acima do target, abaixo de max)',
        metricKey: 'truePeak',
        measuredValue: 0.5, // +1.5 dB acima do target
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'CRÍTICA',
        expectedScoreMax: 50 // Score deve ser baixo
    };
    
    // ============================================================
    // CASO C: True Peak MUITO ACIMA (2.0 > 0.0 max) => CRÍTICA HARD
    // ============================================================
    const caseC = {
        name: 'True Peak CRÍTICA HARD (acima do max)',
        metricKey: 'truePeak',
        measuredValue: 2.0, // +2 dB acima do max!
        targetSpec: { target: -1.0, min: -3.0, max: 0.0, tol: 0.5 },
        expectedSeverity: 'CRÍTICA',
        expectedScoreMax: 20 // Score deve ser muito baixo
    };
    
    // ============================================================
    // CASO D: LUFS BANDPASS no target exato => OK
    // ============================================================
    const caseD = {
        name: 'LUFS OK (no target)',
        metricKey: 'lufs',
        measuredValue: -14.0,
        targetSpec: { target: -14.0, min: -16.0, max: -12.0, tol: 1.0 },
        expectedSeverity: 'OK',
        expectedScoreMin: 95
    };
    
    // ============================================================
    // CASO E: LUFS BANDPASS fora do range => CRÍTICA
    // ============================================================
    const caseE = {
        name: 'LUFS CRÍTICA (fora do range)',
        metricKey: 'lufs',
        measuredValue: -8.0, // +6 dB acima do target
        targetSpec: { target: -14.0, min: -16.0, max: -12.0, tol: 1.0 },
        expectedSeverity: 'CRÍTICA',
        expectedScoreMax: 40
    };
    
    // ============================================================
    // CASO F: LRA BANDPASS moderadamente fora => ATENÇÃO
    // ============================================================
    const caseF = {
        name: 'LRA ATENÇÃO (moderadamente fora)',
        metricKey: 'lra',
        measuredValue: 6.5, // +2.5 dB acima do target
        targetSpec: { target: 4.0, min: 2.0, max: 6.0, tol: 1.0 },
        expectedSeverity: 'ATENÇÃO',
        expectedScoreMin: 50,
        expectedScoreMax: 85
    };
    
    const testCases = [caseA, caseB, caseC, caseD, caseE, caseF];
    
    let passed = 0;
    let failed = 0;
    
    for (const tc of testCases) {
        const result = evaluateMetric(tc.metricKey, tc.measuredValue, tc.targetSpec);
        
        const severityOK = result.severity === tc.expectedSeverity;
        const scoreOK = (tc.expectedScoreMin === undefined || result.score >= tc.expectedScoreMin) &&
                       (tc.expectedScoreMax === undefined || result.score <= tc.expectedScoreMax);
        
        const testPassed = severityOK && scoreOK;
        
        if (testPassed) {
            passed++;
            console.log(`✅ ${tc.name}`);
            console.log(`   value=${tc.measuredValue}, target=${tc.targetSpec.target}`);
            console.log(`   score=${result.score.toFixed(1)}, severity=${result.severity}`);
        } else {
            failed++;
            console.error(`❌ ${tc.name} FALHOU!`);
            console.error(`   value=${tc.measuredValue}, target=${tc.targetSpec.target}`);
            console.error(`   score=${result.score.toFixed(1)} (esperado: ${tc.expectedScoreMin ?? '?'}-${tc.expectedScoreMax ?? '?'})`);
            console.error(`   severity=${result.severity} (esperado: ${tc.expectedSeverity})`);
        }
        
        results.push({
            ...tc,
            actualScore: result.score,
            actualSeverity: result.severity,
            passed: testPassed
        });
    }
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log(`🧪 RESULTADO: ${passed}/${testCases.length} testes passaram`);
    if (failed > 0) {
        console.error(`❌ ${failed} testes FALHARAM - VERIFICAR evaluateMetric V3.7!`);
    } else {
        console.log('✅ Todos os testes passaram - CEILING/BANDPASS funcionando!');
    }
    console.log('═══════════════════════════════════════════════════════════');
    
    return { passed, failed, results };
}

// Expor para console
if (typeof window !== 'undefined') {
    window.testScoreV37Parity = testScoreV37Parity;
}

// ================================================================
// 🧪 TESTE DE SUBSCORE DE FREQUÊNCIA V3.7.1
// Valida cálculo ponderado e gates de sanidade
// ================================================================
function testFrequencySubscoreV371() {
    console.log('═══════════════════════════════════════════════════════════');
    console.log('🧪 [FREQ-TEST V3.7.1] Testando Subscore de Frequência');
    console.log('═══════════════════════════════════════════════════════════');
    
    const testCases = [
        // CASO A: Todas as bandas OK
        {
            name: 'Todas bandas OK',
            bands: {
                sub: { energy_db: -22.0 },   // target -22, diff=0
                bass: { energy_db: -18.0 },  // target -18, diff=0
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 95,
            expectedScoreMax: 100,
            expectedCap: null
        },
        // CASO B: 1 banda CRÍTICA (sub +10dB)
        {
            name: '1 banda CRÍTICA (sub)',
            bands: {
                sub: { energy_db: -12.0 },   // target -22, diff=+10 → CRÍTICA!
                bass: { energy_db: -18.0 },
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 50,
            expectedScoreMax: 85, // Cap por 1 CRÍTICA
            expectedCap: 85
        },
        // CASO C: 2 bandas CRÍTICAS (sub e bass)
        {
            name: '2 bandas CRÍTICAS (sub + bass)',
            bands: {
                sub: { energy_db: -12.0 },   // +10dB → CRÍTICA
                bass: { energy_db: -8.0 },   // +10dB → CRÍTICA
                lowMid: { energy_db: -16.0 },
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 40,
            expectedScoreMax: 70, // Cap por 2 CRÍTICAS
            expectedCap: 70
        },
        // CASO D: 3 bandas CRÍTICAS
        {
            name: '3 bandas CRÍTICAS',
            bands: {
                sub: { energy_db: -12.0 },   // +10dB → CRÍTICA
                bass: { energy_db: -8.0 },   // +10dB → CRÍTICA
                lowMid: { energy_db: -6.0 }, // +10dB → CRÍTICA
                mid: { energy_db: -14.0 },
                highMid: { energy_db: -18.0 },
                presence: { energy_db: -22.0 },
                air: { energy_db: -26.0 }
            },
            targets: {
                bands: {
                    sub: { target_db: -22.0, tol_db: 3.0 },
                    bass: { target_db: -18.0, tol_db: 3.0 },
                    lowMid: { target_db: -16.0, tol_db: 3.0 },
                    mid: { target_db: -14.0, tol_db: 3.0 },
                    highMid: { target_db: -18.0, tol_db: 3.0 },
                    presence: { target_db: -22.0, tol_db: 3.0 },
                    air: { target_db: -26.0, tol_db: 3.0 }
                }
            },
            expectedScoreMin: 30,
            expectedScoreMax: 55, // Cap por 3+ CRÍTICAS
            expectedCap: 55
        }
    ];
    
    let passed = 0;
    let failed = 0;
    const results = [];
    
    for (const tc of testCases) {
        // Construir análise fake
        const analysis = {
            technicalData: {
                lufsIntegrated: -14.0,
                truePeakDbtp: -1.0,
                dynamicRange: 8.0,
                crestFactor: 12.0,
                lra: 7.0,
                stereoCorrelation: 0.9,
                stereoWidth: 0.7,
                clippingPct: 0.001,
                dcOffset: 0.0,
                bands: tc.bands
            }
        };
        
        const targets = {
            lufs_target: -14.0, tol_lufs: 1.0,
            true_peak_target: -1.0, tol_true_peak: 0.25,
            dr_target: 8.0, tol_dr: 1.5,
            ...tc.targets
        };
        
        const result = window.computeScoreV3(analysis, targets, 'streaming');
        const freqScore = result.subscores?.frequency;
        const freqDetails = result._frequencyDetails || result.subScoresRaw?._frequencyDetails;
        
        // Verificar score
        const scoreOK = (freqScore !== null) &&
                       (freqScore >= tc.expectedScoreMin) &&
                       (freqScore <= tc.expectedScoreMax);
        
        // Verificar cap (se esperado)
        const capOK = tc.expectedCap === null || 
                     (freqDetails?.appliedCap === tc.expectedCap);
        
        const testPassed = scoreOK && capOK;
        
        if (testPassed) {
            passed++;
            console.log(`✅ ${tc.name}`);
            console.log(`   Score: ${freqScore} (esperado: ${tc.expectedScoreMin}-${tc.expectedScoreMax})`);
            if (tc.expectedCap) console.log(`   Cap: ${freqDetails?.appliedCap} (esperado: ${tc.expectedCap})`);
        } else {
            failed++;
            console.error(`❌ ${tc.name} FALHOU!`);
            console.error(`   Score: ${freqScore} (esperado: ${tc.expectedScoreMin}-${tc.expectedScoreMax})`);
            console.error(`   Cap: ${freqDetails?.appliedCap} (esperado: ${tc.expectedCap})`);
            console.error(`   Details:`, freqDetails);
        }
        
        results.push({
            ...tc,
            actualScore: freqScore,
            actualCap: freqDetails?.appliedCap,
            passed: testPassed
        });
    }
    
    console.log('═══════════════════════════════════════════════════════════');
    console.log(`🧪 RESULTADO FREQ V3.7.1: ${passed}/${testCases.length} testes passaram`);
    if (failed > 0) {
        console.error(`❌ ${failed} testes FALHARAM!`);
    } else {
        console.log('✅ Todos os testes passaram - Sistema de frequência validado!');
    }
    console.log('═══════════════════════════════════════════════════════════');
    
    return { passed, failed, results };
}

// Expor para console
if (typeof window !== 'undefined') {
    window.testFrequencySubscoreV371 = testFrequencySubscoreV371;
}

// 🧪 TESTE AUTOMÁTICO: Validar normalização com JSON real
function testNormalizationCompatibility() {
    console.log("🧪 [TEST] Iniciando teste automático de compatibilidade...");
    
    // Teste 1: Formato antigo (pré-Redis)
    const oldFormat = {
        data: {
            metrics: {
                lufsIntegrated: -11.15,
                lra: 0.8,
                dynamicRange: 10.28
            },
            technicalData: {
                truePeakDbtp: -0.2,
                bands: {
                    bass: -12.5,
                    mid: -10.8,
                    treble: -15.2
                }
            }
        }
    };
    
    // Teste 2: Formato novo (pós-Redis)
    const newFormat = {
        score: 100,
        classification: "Referência Mundial",
        loudness: { integrated: -11.15, lra: 0.8 },
        truePeak: { maxDbtp: -0.2 },
        dynamics: { range: 10.28 },
        spectralBands: {
            bass: -12.5,
            mid: -10.8,
            treble: -15.2
        },
        metadata: { duration: 180 }
    };
    
    // Teste 3: Formato híbrido
    const hybridFormat = {
        metrics: { lufsIntegrated: -11.15 },
        loudness: { integrated: -12.0 },
        technicalData: { lra: 0.8, truePeakDbtp: -0.2 }
    };
    
    try {
        // 🔥 CORREÇÃO: Usar dados DIRETOS (testes sem reconstrução)
        const normalized1 = oldFormat; // ✅ LEITURA DIRETA
        console.log("✅ [TEST] Formato antigo DIRETO:", {
            lufs: normalized1.technicalData?.lufsIntegrated,
            lra: normalized1.technicalData?.lra,
            truePeak: normalized1.technicalData?.truePeakDbtp,
            dr: normalized1.technicalData?.dynamicRange
        });
        
        // 🔥 CORREÇÃO: Usar dados DIRETOS (testes sem reconstrução)
        const normalized2 = newFormat; // ✅ LEITURA DIRETA
        console.log("✅ [TEST] Formato novo DIRETO:", {
            lufs: normalized2.technicalData?.lufsIntegrated,
            lra: normalized2.technicalData?.lra,
            truePeak: normalized2.technicalData?.truePeakDbtp,
            dr: normalized2.technicalData?.dynamicRange
        });
        
        // 🔥 CORREÇÃO: Usar dados DIRETOS (testes sem reconstrução)
        const normalized3 = hybridFormat; // ✅ LEITURA DIRETA
        console.log("✅ [TEST] Formato híbrido normalizado:", {
            lufs: normalized3.technicalData.lufsIntegrated,
            lra: normalized3.technicalData.lra,
            truePeak: normalized3.technicalData.truePeakDbtp,
            dr: normalized3.technicalData.dynamicRange
        });
        
        // ✅ Validação de estrutura
        const isValidStructure = (norm) => {
            return norm.technicalData && 
                   typeof norm.technicalData.lufsIntegrated !== 'undefined' &&
                   typeof norm.technicalData.lra !== 'undefined' &&
                   typeof norm.technicalData.truePeakDbtp !== 'undefined';
        };
        
        if (isValidStructure(normalized1) && isValidStructure(normalized2) && isValidStructure(normalized3)) {
            console.log("✅ [TEST] Todos os formatos passaram na validação!");
            console.log("✅ [TEST] Sistema de normalização está funcionando corretamente");
            return true;
        } else {
            console.error("❌ [TEST] Falha na validação de estrutura");
            return false;
        }
        
    } catch (error) {
        console.error("❌ [TEST] Erro no teste de normalização:", error);
        return false;
    }
}

// 🚀 Executar teste automático quando o arquivo carregar
if (typeof window !== 'undefined') {
    window.addEventListener('load', () => {
        setTimeout(() => {
            testNormalizationCompatibility();
        }, 1000);
    });
}

// 🎯 FUNÇÃO: Aplicar correção de fallback ao score
    
    tech.lufsShortTerm = getRealValue('lufsShortTerm', 'lufs_short_term') ||
                        (backendData.loudness?.shortTerm && Number.isFinite(backendData.loudness.shortTerm) ? backendData.loudness.shortTerm : null);
    
    tech.lufsMomentary = getRealValue('lufsMomentary', 'lufs_momentary') ||
                        (backendData.loudness?.momentary && Number.isFinite(backendData.loudness.momentary) ? backendData.loudness.momentary : null);
    
    // LRA - CORRIGIR MAPEAMENTO PARA ESTRUTURA REAL: loudness.lra + technicalData.lra
    tech.lra = getRealValue('lra', 'loudnessRange', 'lra_tolerance', 'loudness_range') ||
              (backendData.loudness?.lra && Number.isFinite(backendData.loudness.lra) ? backendData.loudness.lra : null) ||
              (backendData.technicalData?.lra && Number.isFinite(backendData.technicalData.lra) ? backendData.technicalData.lra : null);
    
    console.log('📊 [NORMALIZE] Métricas mapeadas (apenas reais):', {
        peak: tech.peak,
        rms: tech.rms,
        dynamicRange: tech.dynamicRange,
        crestFactor: tech.crestFactor,
        truePeakDbtp: tech.truePeakDbtp,
        lufsIntegrated: tech.lufsIntegrated,
        lufsShortTerm: tech.lufsShortTerm,
        lufsMomentary: tech.lufsMomentary,
        lra: tech.lra
    });
    
    // 🎯 LOG ESPECÍFICO PARA AUDITORIA: LRA com estrutura real
    if (tech.lra !== null) {
        console.log('✅ [LRA] SUCESSO: LRA mapeado corretamente =', tech.lra);
    } else {
        console.warn('❌ [LRA] PROBLEMA: LRA não foi encontrado no backend data');
        console.log('🔍 [LRA] Debug - possíveis caminhos verificados:', {
            'backendData.loudness.lra': backendData.loudness?.lra,
            'backendData.technicalData.lra': backendData.technicalData?.lra,
            'source (technicalData)': source.lra || source.loudnessRange,
            'loudnessObject': backendData.loudness,
            'technicalDataObject': backendData.technicalData
        });
    }
    
    // Headroom - APENAS VALORES REAIS
    tech.headroomDb = getRealValue('headroomDb', 'headroom_db');
    tech.headroomTruePeakDb = getRealValue('headroomTruePeakDb');
    
    // Stereo - CORRIGIR MAPEAMENTO PARA NOVA ESTRUTURA
    tech.stereoCorrelation = getRealValue('stereoCorrelation', 'stereo_correlation') ||
                            (backendData.stereo?.correlation && Number.isFinite(backendData.stereo.correlation) ? backendData.stereo.correlation : null);
    
    tech.stereoWidth = getRealValue('stereoWidth', 'stereo_width') ||
                      (backendData.stereo?.width && Number.isFinite(backendData.stereo.width) ? backendData.stereo.width : null);
    
    tech.balanceLR = getRealValue('balanceLR', 'balance_lr') ||
                    (backendData.stereo?.balance && Number.isFinite(backendData.stereo.balance) ? backendData.stereo.balance : null);
    
    // Spectral - APENAS VALORES REAIS
    tech.spectralCentroid = getRealValue('spectralCentroid', 'spectral_centroid');
    tech.spectralRolloff = getRealValue('spectralRolloff', 'spectral_rolloff');
    tech.zeroCrossingRate = getRealValue('zeroCrossingRate', 'zero_crossing_rate');
    tech.spectralFlux = getRealValue('spectralFlux', 'spectral_flux');
    tech.spectralFlatness = getRealValue('spectralFlatness', 'spectral_flatness');
    
    // Problemas técnicos - APENAS VALORES REAIS
    tech.clippingSamples = getRealValue('clippingSamples', 'clipping_samples');
    tech.clippingPct = getRealValue('clippingPct', 'clipping_pct');
    tech.dcOffset = getRealValue('dcOffset', 'dc_offset');
    tech.thdPercent = getRealValue('thdPercent', 'thd_percent');
    
    // Sample peaks por canal - APENAS VALORES REAIS
    tech.samplePeakLeftDb = getRealValue('samplePeakLeftDb', 'sample_peak_left_db');
    tech.samplePeakRightDb = getRealValue('samplePeakRightDb', 'sample_peak_right_db');
    
    // ===== NOVAS MÉTRICAS IMPLEMENTADAS =====
    
    // Spectral Bandwidth e outras métricas espectrais
    tech.spectralBandwidth = getRealValue('spectralBandwidth', 'spectral_bandwidth');
    tech.spectralBandwidthHz = tech.spectralBandwidth; // Alias
    tech.spectralSpread = getRealValue('spectralSpread', 'spectral_spread');
    tech.spectralCrest = getRealValue('spectralCrest', 'spectral_crest');
    tech.spectralSkewness = getRealValue('spectralSkewness', 'spectral_skewness');
    tech.spectralKurtosis = getRealValue('spectralKurtosis', 'spectral_kurtosis');
    
    // 🎵 SPECTRAL BALANCE - Mapear dados espectrais REAIS do backend
    if (source.spectral_balance || source.spectralBalance || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        
        const spectralSource = source.spectral_balance || source.spectralBalance || source.bands || 
                              backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        
        console.log('🔍 [SPECTRAL] Fonte espectral detectada:', spectralSource);
        
        // Função específica para dados espectrais
        const getSpectralValue = (...paths) => {
            for (const path of paths) {
                const value = path.split('.').reduce((obj, key) => obj?.[key], spectralSource);
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            return null;
        };
        
        // Se spectral_balance é string (ex: "balanced"), mapear para objeto
        if (typeof spectralSource === 'string') {
            tech.spectral_balance = {
                description: spectralSource,
                status: spectralSource
            };
            console.log('📊 [NORMALIZE] Spectral balance (string):', tech.spectral_balance);
        } else {
            tech.spectral_balance = {
                sub: getSpectralValue('sub', 'subBass', 'sub_bass'),
                bass: getSpectralValue('bass', 'low_bass', 'lowBass'),  // Normalizar para 'bass'
                lowMid: getSpectralValue('lowMid', 'low_mid', 'lowmid'),
                mid: getSpectralValue('mid', 'mids', 'middle'),
                highMid: getSpectralValue('highMid', 'high_mid', 'highmid'),
                presence: getSpectralValue('presence', 'presenca'),
                air: getSpectralValue('air', 'brilho', 'treble', 'high')
            };
            console.log('📊 [NORMALIZE] Spectral balance mapeado:', tech.spectral_balance);
        }
        
        // 🎯 LOG ESPECÍFICO PARA AUDITORIA: BANDAS ESPECTRAIS
        const bandasDetectadas = typeof tech.spectral_balance === 'object' && tech.spectral_balance.description ? 
            [`description: ${tech.spectral_balance.description}`] :
            Object.entries(tech.spectral_balance)
                .filter(([key, value]) => value !== null && key !== 'description' && key !== 'status')
                .map(([key, value]) => `${key}: ${value}`);
        
        if (bandasDetectadas.length > 0) {
            console.log(`✅ [BANDAS] SUCESSO: ${bandasDetectadas.length} bandas mapeadas:`, bandasDetectadas.join(', '));
        } else {
            console.warn('❌ [BANDAS] PROBLEMA: Nenhuma banda espectral foi mapeada');
            console.log('🔍 [BANDAS] Debug - caminhos verificados:', {
                'source.spectral_balance': source.spectral_balance,
                'source.spectralBalance': source.spectralBalance, 
                'source.bands': source.bands,
                'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
                'backendData.technicalData.bands': backendData.technicalData?.bands,
                'spectralSource': spectralSource
            });
        }
    } else {
        // Não definir se não há dados reais
        tech.spectral_balance = null;
        console.log('⚠️ [NORMALIZE] Nenhum dado espectral real encontrado');
        console.log('🔍 [NORMALIZE] Debug espectral - caminhos verificados:', {
            'source.spectral_balance': source.spectral_balance,
            'source.spectralBalance': source.spectralBalance,
            'source.bands': source.bands,
            'backendData.technicalData.spectralBands': backendData.technicalData?.spectralBands,
            'backendData.technicalData.bands': backendData.technicalData?.bands
        });
    }
    
    // 🎶 BAND ENERGIES - Mapear energias das bandas de frequência REAIS do backend
    if (source.bandEnergies || source.band_energies || source.bands || 
        backendData.technicalData?.spectralBands || backendData.technicalData?.bands) {
        const bandsSource = source.bandEnergies || source.band_energies || source.bands || 
                          backendData.technicalData?.spectralBands || backendData.technicalData?.bands || {};
        tech.bandEnergies = {};
        
        // Mapear bandas conhecidas - APENAS VALORES REAIS
        const bandMapping = {
            'sub': 'sub',
            'subBass': 'sub', 
            'sub_bass': 'sub',
            'low_bass': 'bass',  // Normalizar para 'bass'
            'lowBass': 'bass',
            'bass': 'bass',
            'upper_bass': 'bass',
            'upperBass': 'bass',
            'low_mid': 'lowMid',  // Normalizar para 'lowMid'
            'lowMid': 'lowMid',
            'lowmid': 'lowMid',
            'mid': 'mid',
            'mids': 'mid',
            'middle': 'mid',
            'high_mid': 'highMid',  // Normalizar para 'highMid'
            'highMid': 'highMid',
            'highmid': 'highMid',
            'upper_mid': 'highMid',
            'upperMid': 'highMid',
            'brilho': 'air',  // Normalizar para 'air'
            'brilliance': 'air',
            'air': 'air',
            'treble': 'air',
            'high': 'air',
            'presenca': 'presence',  // Normalizar para 'presence'
            'presence': 'presence'
        };
        
        Object.entries(bandMapping).forEach(([sourceKey, targetKey]) => {
            const bandData = bandsSource[sourceKey];
            if (bandData && typeof bandData === 'object') {
                // Pegar apenas valores reais, sem fallbacks
                const rms_db = Number.isFinite(bandData.rms_db) ? bandData.rms_db : 
                              Number.isFinite(bandData.energy_db) ? bandData.energy_db :
                              Number.isFinite(bandData.level) ? bandData.level : null;
                              
                const peak_db = Number.isFinite(bandData.peak_db) ? bandData.peak_db : null;
                const frequency_range = bandData.frequency_range || bandData.range || null;
                
                // Só adicionar se tiver pelo menos um valor real
                if (rms_db !== null || peak_db !== null) {
                    tech.bandEnergies[targetKey] = {
                        rms_db: rms_db,
                        peak_db: peak_db,
                        frequency_range: frequency_range
                    };
                }
            }
        });
        
        console.log('📊 [NORMALIZE] Band energies mapeadas (apenas reais):', tech.bandEnergies);
        
        // Se não conseguiu mapear nenhuma banda real, deixar null
        if (Object.keys(tech.bandEnergies).length === 0) {
            tech.bandEnergies = null;
            console.log('⚠️ [NORMALIZE] Nenhuma banda real encontrada - bandEnergies = null');
        }
    } else {
        tech.bandEnergies = null;
        console.log('⚠️ [NORMALIZE] Dados de bandas não encontrados - bandEnergies = null');
    }
    
    // 🎼 TONAL BALANCE - Estrutura simplificada para compatibilidade APENAS COM VALORES REAIS
    if (tech.bandEnergies && Object.keys(tech.bandEnergies).length > 0) {
        tech.tonalBalance = {
            sub: tech.bandEnergies.sub || null,
            low: tech.bandEnergies.low_bass || null,
            mid: tech.bandEnergies.mid || null,
            high: tech.bandEnergies.brilho || null
        };
        console.log('📊 [NORMALIZE] Tonal balance baseado em bandEnergies reais:', tech.tonalBalance);
    } else {
        tech.tonalBalance = null;
        console.log('⚠️ [NORMALIZE] Nenhuma banda real para tonal balance - tonalBalance = null');
    }
    
    // 🎯 FREQUÊNCIAS DOMINANTES - Estrutura completa com detailed
    if (source.dominantFrequencies || source.dominant_frequencies) {
        const rawData = source.dominantFrequencies || source.dominant_frequencies;
        
        // Se for string/número simples, converter para structured format
        if (typeof rawData === 'string' || typeof rawData === 'number') {
            tech.dominantFrequencies = {
                value: rawData,
                unit: 'Hz'
            };
        } else if (rawData && typeof rawData === 'object') {
            // Se for object com detailed
            tech.dominantFrequencies = {
                value: rawData.value || rawData.primary || null,
                unit: rawData.unit || 'Hz',
                detailed: rawData.detailed || {
                    primary: rawData.primary || rawData.value || null,
                    secondary: rawData.secondary || null,
                    peaks: rawData.peaks || []
                }
            };
        } else {
            tech.dominantFrequencies = null;
        }
        console.log('📊 [NORMALIZE] Frequências dominantes estruturadas:', tech.dominantFrequencies);
    } else {
        tech.dominantFrequencies = null;
        console.log('⚠️ [NORMALIZE] Frequências dominantes não encontradas - dominantFrequencies = null');
    }
    
    // 🔄 DC OFFSET - Estrutura completa com canais L/R
    if (source.dcOffset || source.dc_offset) {
        const rawDcData = source.dcOffset || source.dc_offset;
        
        // Se for número simples, converter para structured format
        if (typeof rawDcData === 'number') {
            tech.dcOffset = {
                value: rawDcData,
                unit: 'dB',
                detailed: {
                    L: rawDcData,
                    R: rawDcData,
                    severity: Math.abs(rawDcData) > 0.1 ? 'High' : Math.abs(rawDcData) > 0.01 ? 'Medium' : 'Low'
                }
            };
        } else if (rawDcData && typeof rawDcData === 'object') {
            // Se for object com detailed
            tech.dcOffset = {
                value: rawDcData.value || (rawDcData.detailed ? Math.max(Math.abs(rawDcData.detailed.L || 0), Math.abs(rawDcData.detailed.R || 0)) : null),
                unit: rawDcData.unit || 'dB',
                detailed: rawDcData.detailed || {
                    L: rawDcData.L || rawDcData.left || rawDcData.value || 0,
                    R: rawDcData.R || rawDcData.right || rawDcData.value || 0,
                    severity: rawDcData.severity || 'Low'
                }
            };
        } else {
            tech.dcOffset = null;
        }
        console.log('📊 [NORMALIZE] DC Offset estruturado:', tech.dcOffset);
    } else {
        tech.dcOffset = null;
        console.log('⚠️ [NORMALIZE] DC Offset não encontrado - dcOffset = null');
    }
    
    // 📊 SPECTRAL UNIFORMITY - Estrutura detalhada
    if (source.spectralUniformity || source.spectral_uniformity) {
        const rawSpectralData = source.spectralUniformity || source.spectral_uniformity;
        
        // Se for número simples, converter para structured format
        if (typeof rawSpectralData === 'number') {
            tech.spectralUniformity = {
                value: rawSpectralData,
                unit: 'ratio',
                detailed: {
                    variance: rawSpectralData,
                    distribution: rawSpectralData > 0.8 ? 'Uniform' : rawSpectralData > 0.5 ? 'Moderate' : 'Irregular',
                    analysis: rawSpectralData > 0.7 ? 'Well-balanced frequency distribution' : 'Uneven spectral content'
                }
            };
        } else if (rawSpectralData && typeof rawSpectralData === 'object') {
            // Se for object com detailed
            tech.spectralUniformity = {
                value: rawSpectralData.value || rawSpectralData.variance || null,
                unit: rawSpectralData.unit || 'ratio',
                detailed: rawSpectralData.detailed || {
                    variance: rawSpectralData.variance || rawSpectralData.value || null,
                    distribution: rawSpectralData.distribution || 'Unknown',
                    analysis: rawSpectralData.analysis || 'Spectral analysis pending'
                }
            };
        } else {
            tech.spectralUniformity = null;
        }
        console.log('📊 [NORMALIZE] Spectral Uniformity estruturado:', tech.spectralUniformity);
    } else {
        tech.spectralUniformity = null;
        console.log('⚠️ [NORMALIZE] Spectral Uniformity não encontrado - spectralUniformity = null');
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // 🔢 SCORES E QUALIDADE - PRIORIZAÇÃO: comparisonResult.score > backendData.score
    // 
    // comparisonResult.score é calculado pelo pipeline único (compareWithTargets)
    // e garante consistência com tabela e sugestões
    // ═══════════════════════════════════════════════════════════════════════════
    const comparisonScore = backendData.comparisonResult?.score;
    if (comparisonScore && Number.isFinite(comparisonScore.total)) {
        normalized.qualityOverall = comparisonScore.total;
        normalized.classification = comparisonScore.classification;
        normalized.qualityBreakdown = comparisonScore.breakdown || null;
        console.log('🎯 [NORMALIZE] Score do comparisonResult (FONTE ÚNICA):', {
            total: comparisonScore.total,
            classification: comparisonScore.classification,
            breakdown: comparisonScore.breakdown
        });
    } else if (backendData.score && Number.isFinite(backendData.score)) {
        normalized.qualityOverall = backendData.score;
        console.log('⚠️ [NORMALIZE] Score legado (backendData.score):', backendData.score);
        
        if (backendData.qualityBreakdown && typeof backendData.qualityBreakdown === 'object') {
            normalized.qualityBreakdown = backendData.qualityBreakdown;
            console.log('📊 [NORMALIZE] Quality breakdown real encontrado:', normalized.qualityBreakdown);
        } else {
            normalized.qualityBreakdown = null;
            console.log('⚠️ [NORMALIZE] Quality breakdown não encontrado - qualityBreakdown = null');
        }
    } else {
        normalized.qualityOverall = null;
        normalized.qualityBreakdown = null;
        console.warn('⚠️ [NORMALIZE] Nenhum score disponível');
    }
    
    // 📊 DADOS AUXILIARES DO NOVO FORMATO
    if (backendData.metadata) {
        normalized.processingMs = backendData.metadata.processingTime || backendData.performance?.workerTotalTimeMs || null;
        normalized.fileName = backendData.metadata.fileName || null;
        normalized.fileSize = backendData.metadata.fileSize || null;
        normalized.buildVersion = backendData.metadata.buildVersion || null;
        normalized.pipelineVersion = backendData.metadata.pipelineVersion || null;
    }
    
    if (backendData.classification) {
        normalized.classification = backendData.classification;
    }
    
    // 🎯 DADOS DE SCORING DETALHADOS
    if (backendData.scoring) {
        normalized.scoring = backendData.scoring;
        console.log('📊 [NORMALIZE] Dados de scoring encontrados:', backendData.scoring);
    }
    
    // 🚨 PROBLEMAS/SUGESTÕES DO NOVO ANALYZER - Integrar com structure completa
    if (source.problemsAnalysis || source.problems_analysis) {
        const problemsData = source.problemsAnalysis || source.problems_analysis;
        
        // Adicionar problemas do analyzer
        if (problemsData.problems && Array.isArray(problemsData.problems)) {
            problemsData.problems.forEach(problem => {
                normalized.problems.push({
                    type: problem.type || 'analysis',
                    message: problem.message || problem.description || 'Problema detectado',
                    solution: problem.solution || problem.recommendation || 'Verificar configurações',
                    severity: problem.severity || 'medium',
                    source: 'problems_analyzer'
                });
            });
        }
        
        // Adicionar sugestões do analyzer
        if (problemsData.suggestions && Array.isArray(problemsData.suggestions)) {
            problemsData.suggestions.forEach(suggestion => {
                normalized.suggestions.push({
                    type: suggestion.type || 'optimization',
                    message: suggestion.message || suggestion.description || 'Sugestão de melhoria',
                    action: suggestion.action || suggestion.recommendation || 'Aplicar otimização',
                    details: suggestion.details || suggestion.context || 'Detalhes não disponíveis',
                    source: 'problems_analyzer'
                });
            });
        }
        
        console.log('📊 [NORMALIZE] Problems/Suggestions do analyzer integrados:', {
            problemsAdded: problemsData.problems?.length || 0,
            suggestionsAdded: problemsData.suggestions?.length || 0
        });
    }
    
    // 🚨 PROBLEMAS - Garantir que existam alguns problemas/sugestões para exibir
    if (normalized.problems.length === 0) {
        // Detectar problemas básicos baseados nas métricas - APENAS SE VALORES EXISTEM
        if (Number.isFinite(tech.clippingSamples) && tech.clippingSamples > 0) {
            normalized.problems.push({
                type: 'clipping',
                message: `Clipping detectado (${tech.clippingSamples} samples)`,
                solution: 'Reduzir o ganho geral ou usar limitador',
                severity: 'high'
            });
        }
        
        if (tech.dcOffset && tech.dcOffset.detailed) {
            const maxDcOffset = Math.max(Math.abs(tech.dcOffset.detailed.L || 0), Math.abs(tech.dcOffset.detailed.R || 0));
            if (maxDcOffset > 0.01) {
                normalized.problems.push({
                    type: 'dc_offset', 
                    message: `DC Offset detectado (L: ${tech.dcOffset.detailed.L?.toFixed(4) || 'N/A'}, R: ${tech.dcOffset.detailed.R?.toFixed(4) || 'N/A'})`,
                    solution: 'Aplicar filtro DC remove',
                    severity: tech.dcOffset.detailed.severity === 'High' ? 'high' : 'medium'
                });
            }
        } else if (Number.isFinite(tech.dcOffset) && Math.abs(tech.dcOffset) > 0.01) {
            normalized.problems.push({
                type: 'dc_offset', 
                message: `DC Offset detectado (${tech.dcOffset.toFixed(4)})`,
                solution: 'Aplicar filtro DC remove',
                severity: 'medium'
            });
        }
        
        if (Number.isFinite(tech.thdPercent) && tech.thdPercent > 1) {
            normalized.problems.push({
                type: 'thd',
                message: `THD elevado (${tech.thdPercent.toFixed(2)}%)`,
                solution: 'Verificar saturação e distorção',
                severity: 'medium'
            });
        }
    }
    
    // 💡 SUGESTÕES - Garantir algumas sugestões básicas - APENAS SE VALORES EXISTEM
    console.log('[SUGGESTIONS-GEN] 🔍 Verificando geração de sugestões básicas...');
    console.log('[SUGGESTIONS-GEN] normalized.suggestions.length =', normalized.suggestions.length);
    console.log('[SUGGESTIONS-GEN] Métricas disponíveis:', {
        dynamicRange: tech.dynamicRange,
        stereoCorrelation: tech.stereoCorrelation,
        lufsIntegrated: tech.lufsIntegrated,
        truePeakDbtp: tech.truePeakDbtp
    });
    
    if (normalized.suggestions.length === 0) {
        console.log('[SUGGESTIONS-GEN] ⚠️ Nenhuma sugestão do backend - gerando sugestões básicas...');
        
        if (Number.isFinite(tech.dynamicRange) && tech.dynamicRange < 8) {
            normalized.suggestions.push({
                type: 'dynamics',
                message: 'Faixa dinâmica baixa detectada',
                action: 'Considerar reduzir compressão/limitação',
                details: `DR atual: ${tech.dynamicRange.toFixed(1)}dB`
            });
            console.log('[SUGGESTIONS-GEN] ✅ Sugestão de DR adicionada');
        }
        
        if (Number.isFinite(tech.stereoCorrelation) && tech.stereoCorrelation > 0.9) {
            normalized.suggestions.push({
                type: 'stereo',
                message: 'Imagem estéreo muito estreita',
                action: 'Aumentar espacialização estéreo',
                details: `Correlação: ${tech.stereoCorrelation.toFixed(3)}`
            });
            console.log('[SUGGESTIONS-GEN] ✅ Sugestão de correlação estéreo adicionada');
        }
        
        if (Number.isFinite(tech.lufsIntegrated) && tech.lufsIntegrated < -30) {
            normalized.suggestions.push({
                type: 'loudness',
                message: 'Loudness muito baixo',
                action: 'Aumentar volume geral',
                details: `LUFS atual: ${tech.lufsIntegrated.toFixed(1)}`
            });
            console.log('[SUGGESTIONS-GEN] ✅ Sugestão de loudness baixo adicionada');
        }
        
        // 🆕 NOVAS SUGESTÕES BASEADAS EM MÉTRICAS COMUNS
        if (Number.isFinite(tech.truePeakDbtp) && tech.truePeakDbtp > -1.0) {
            normalized.suggestions.push({
                type: 'true_peak',
                message: 'True Peak muito próximo de 0 dBFS',
                action: 'Reduzir True Peak para -1.0 dBTP para evitar clipping em conversões',
                details: `True Peak atual: ${tech.truePeakDbtp.toFixed(2)} dBTP`
            });
            console.log('[SUGGESTIONS-GEN] ✅ Sugestão de True Peak adicionada');
        }
        
        if (Number.isFinite(tech.lra) && tech.lra < 3) {
            normalized.suggestions.push({
                type: 'lra',
                message: 'Loudness Range (LRA) muito baixo',
                action: 'Mix muito comprimido - considerar reduzir compressão para mais dinâmica',
                details: `LRA atual: ${tech.lra.toFixed(1)} LU`
            });
            console.log('[SUGGESTIONS-GEN] ✅ Sugestão de LRA adicionada');
        }
        
        // Sugestões baseadas em bandas de frequência (se disponíveis)
        if (tech.spectral_balance || tech.bandEnergies) {
            const bands = tech.spectral_balance || tech.bandEnergies;
            if (bands.bass != null && bands.bass < -6) {
                normalized.suggestions.push({
                    type: 'frequency_bass',
                    message: 'Pouca energia em graves (bass)',
                    action: 'Considerar aumentar frequências baixas (60-250 Hz)',
                    details: `Bass: ${bands.bass.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] ✅ Sugestão de bass baixo adicionada');
            }
            
            if (bands.presence != null && bands.presence < -8) {
                normalized.suggestions.push({
                    type: 'frequency_presence',
                    message: 'Pouca energia em presença (presence)',
                    action: 'Aumentar clareza vocal e definição (2-6 kHz)',
                    details: `Presence: ${bands.presence.toFixed(1)} dB`
                });
                console.log('[SUGGESTIONS-GEN] ✅ Sugestão de presence baixo adicionada');
            }
        }
        
        // Sugestões baseadas nas novas métricas
        if (tech.spectralUniformity && tech.spectralUniformity.detailed) {
            const uniformity = tech.spectralUniformity.value || tech.spectralUniformity.detailed.variance;
            if (Number.isFinite(uniformity) && uniformity < 0.5) {
                normalized.suggestions.push({
                    type: 'spectral_balance',
                    message: 'Distribuição espectral irregular detectada',
                    action: 'Considerar equalização para melhor balanceamento',
                    details: `Uniformidade: ${uniformity.toFixed(3)}, ${tech.spectralUniformity.detailed.distribution || 'Análise pendente'}`
                });
                console.log('[SUGGESTIONS-GEN] ✅ Sugestão de uniformidade espectral adicionada');
            }
        }
        
        if (tech.dominantFrequencies && tech.dominantFrequencies.detailed) {
            const primary = tech.dominantFrequencies.detailed.primary;
            if (Number.isFinite(primary)) {
                if (primary < 80) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'Frequência dominante muito baixa',
                        action: 'Verificar filtro high-pass ou conteúdo sub-bass excessivo',
                        details: `Freq. primária: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] ✅ Sugestão de frequência baixa adicionada');
                } else if (primary > 8000) {
                    normalized.suggestions.push({
                        type: 'frequency_focus',
                        message: 'Frequência dominante muito alta',
                        action: 'Verificar conteúdo excessivo de agudos',
                        details: `Freq. primária: ${primary.toFixed(1)} Hz`
                    });
                    console.log('[SUGGESTIONS-GEN] ✅ Sugestão de frequência alta adicionada');
                }
            }
        }
        
        // 🚨 FALLBACK CRÍTICO: Sempre ter pelo menos uma sugestão
        if (normalized.suggestions.length === 0) {
            console.warn('[SUGGESTIONS-GEN] ⚠️ Nenhuma sugestão gerada - criando fallback genérico');
            normalized.suggestions.push({
                type: 'general',
                message: 'Análise completa realizada',
                action: 'Suas métricas de áudio foram analisadas com sucesso',
                details: 'Revise os cards de métricas acima para mais detalhes'
            });
        }
        
        console.log('[SUGGESTIONS-GEN] ✅ Total de sugestões geradas:', normalized.suggestions.length);
    } else {
        console.log('[SUGGESTIONS-GEN] ✅ Backend enviou', normalized.suggestions.length, 'sugestões');
    }
    
    console.log('✅ [NORMALIZE] Normalização concluída:', {
        hasTechnicalData: !!normalized.technicalData,
        hasSpectralBalance: !!normalized.technicalData.spectral_balance,
        hasBandEnergies: !!normalized.technicalData.bandEnergies,
        // Novas métricas detalhadas
        hasDominantFreqs: !!normalized.technicalData.dominantFrequencies,
        hasDcOffset: !!normalized.technicalData.dcOffset,
        hasSpectralUniformity: !!normalized.technicalData.spectralUniformity,
        dominantFreqsStructure: normalized.technicalData.dominantFrequencies ? 'structured' : 'missing',
        dcOffsetStructure: normalized.technicalData.dcOffset ? 'structured' : 'missing',
        spectralUniformityStructure: normalized.technicalData.spectralUniformity ? 'structured' : 'missing',
        problemsCount: normalized.problems.length,
        suggestionsCount: normalized.suggestions.length,
        qualityScore: normalized.qualityOverall
    });
    
    // 🎯 LOG DE RESUMO: Métricas normalizadas com sucesso
    const normalizedMetrics = Object.keys(normalized.technicalData).filter(key => 
        Number.isFinite(normalized.technicalData[key])
    );
    
    console.log('📊 [NORMALIZE] Resumo da normalização:', {
        metricas_normalizadas: normalizedMetrics.length,
        metricas_disponiveis: normalizedMetrics,
        spectral_balance_ok: !!normalized.technicalData.spectral_balance,
        bandas_disponiveis: normalized.technicalData.bandEnergies ? 
            Object.keys(normalized.technicalData.bandEnergies).length : 0,
        problemas_detectados: normalized.problems.length,
        sugestoes_iniciais: normalized.suggestions.length
    });
    
    // 🎯 LOG FINAL PARA DEBUG UI
    console.log("✅ [UI_FIX] Normalized metrics:", {
        lufsIntegrated: normalized.technicalData.lufsIntegrated,
        lra: normalized.technicalData.lra,
        truePeakDbtp: normalized.technicalData.truePeakDbtp,
        dynamicRange: normalized.technicalData.dynamicRange,
        spectral_balance: normalized.technicalData.spectral_balance,
        bandEnergies: normalized.technicalData.bandEnergies ? Object.keys(normalized.technicalData.bandEnergies) : null
    });
    
// =============== FUNÇÕES UTILITÁRIAS DO MODAL ===============

// 📁 Ocultar área de upload do modal
function hideUploadArea() {
    __dbg('📁 Ocultando área de upload...');
    const uploadArea = document.getElementById('audioUploadArea');
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('✅ Upload area ocultada');
    } else {
        __dbg('❌ Elemento audioUploadArea não encontrado!');
    }
}

// 🔄 Mostrar loading de análise
function showAnalysisLoading() {
    __dbg('🔄 Exibindo loading de análise...');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    const connectionHint = document.getElementById('audioConnectionHint');
    
    if (results) {
        results.style.display = 'none';
        __dbg('✅ Results area ocultada');
    }
    
    // 🎯 Garantir que a dica de conexão inicia oculta
    if (connectionHint) {
        connectionHint.style.display = 'none';
    }
    
    if (loading) {
        loading.style.display = 'block';
        __dbg('✅ Loading area exibida');
    } else {
        __dbg('❌ Elemento audioAnalysisLoading não encontrado!');
    }
}

// ⏹️ Ocultar loading de análise
function hideAnalysisLoading() {
    __dbg('⏹️ Ocultando loading de análise...');
    const loading = document.getElementById('audioAnalysisLoading');
    if (loading) {
        loading.style.display = 'none';
        __dbg('✅ Loading area ocultada');
    } else {
        __dbg('❌ Elemento audioAnalysisLoading não encontrado!');
    }
}

// 📊 Mostrar resultados da análise
function showAnalysisResults() {
    __dbg('📊 Exibindo resultados da análise...');
    const uploadArea = document.getElementById('audioUploadArea');
    const loading = document.getElementById('audioAnalysisLoading');
    const results = document.getElementById('audioAnalysisResults');
    
    if (uploadArea) {
        uploadArea.style.display = 'none';
        __dbg('✅ Upload area ocultada');
    }
    
    if (loading) {
        loading.style.display = 'none';
        __dbg('✅ Loading area ocultada');
    }
    
    if (results) {
        results.style.display = 'block';
        __dbg('✅ Results area exibida');
    } else {
        __dbg('❌ Elemento audioAnalysisResults não encontrado!');
    }
}

// 🎨 INJETAR ESTILOS CSS PARA STATUS DE TRUE PEAK
function injectTruePeakStatusStyles() {
    if (document.getElementById('truePeakStatusStyles')) return; // já injetado
    
    const style = document.createElement('style');
    style.id = 'truePeakStatusStyles';
    style.textContent = `
        /* Status do True Peak */
        .status-excellent {
            color: #00ff88 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(0, 255, 136, 0.3);
        }
        
        .status-ideal {
            color: #28a745 !important;
            font-weight: 600;
        }
        
        .status-good {
            color: #17a2b8 !important;
            font-weight: 600;
        }
        
        .status-warning {
            color: #ffc107 !important;
            font-weight: 600;
            text-shadow: 0 0 2px rgba(255, 193, 7, 0.3);
        }
        
        .status-critical {
            color: #dc3545 !important;
            font-weight: 700;
            text-shadow: 0 0 3px rgba(220, 53, 69, 0.4);
            animation: criticalPulse 2s infinite;
        }
        
        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Responsive para mobile */
        @media (max-width: 600px) {
            .status-excellent,
            .status-ideal,
            .status-good,
            .status-warning,
            .status-critical {
                font-size: 11px;
                font-weight: 600;
            }
        }
    `;
    
    document.head.appendChild(style);
    console.log('🎨 Estilos CSS do True Peak injetados');
}

// Injetar estilos automaticamente quando o DOM carregar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', injectTruePeakStatusStyles);
} else {
    injectTruePeakStatusStyles();
}

// 🎯 SISTEMA DE TOOLTIPS REMOVIDO - Agora usa tooltip-manager.js global
// O sistema antigo com showMetricTooltip/hideMetricTooltip foi substituído por event delegation
// Tooltips agora funcionam via data-tooltip-title e data-tooltip-body em qualquer elemento

// 🧩 CORREÇÃO #7: Logs de debug automáticos para validação
console.log("%c[SYSTEM CHECK] 🔍 Debug ativo para validação de fluxos genre/reference", "color:#7f00ff;font-weight:bold;");

// ========================================
// 🚨 SISTEMA DE MONITORAMENTO CONTÍNUO DE JOBID
// ========================================
/**
 * Monitora se os jobIds permanecem diferentes em modo reference
 * Detecta e corrige contaminação automaticamente
 */
(function startJobIdMonitor() {
    let monitorInterval = null;
    
    function checkJobIdIntegrity() {
        const mode = window.currentAnalysisMode || localStorage.getItem('currentAnalysisMode');
        
        if (mode === 'reference') {
            const current = window.__CURRENT_JOB_ID__;
            const reference = window.__REFERENCE_JOB_ID__;
            
            // Validação crítica
            if (current && reference && current === reference) {
                console.error('🚨 [MONITOR] CONTAMINAÇÃO DETECTADA!');
                console.error('   currentJobId:', current);
                console.error('   referenceJobId:', reference);
                console.error('   Ambos são IGUAIS - isso NÃO deveria acontecer!');
                console.trace();
                
                // Tenta recuperar do sessionStorage
                const recoveredJobId = sessionStorage.getItem('currentJobId');
                if (recoveredJobId && recoveredJobId !== reference) {
                    window.__CURRENT_JOB_ID__ = recoveredJobId;
                    console.log('✅ [MONITOR] JobId recuperado do sessionStorage:', recoveredJobId);
                    console.log('✅ [MONITOR] Contaminação corrigida automaticamente');
                } else {
                    console.error('❌ [MONITOR] Não foi possível recuperar currentJobId do sessionStorage');
                    console.error('❌ [MONITOR] Sistema pode estar em estado inconsistente');
                }
            }
        }
    }
    
    // Inicia monitoramento quando entrar em modo reference
    window.addEventListener('analysisMode', (e) => {
        if (e.detail?.mode === 'reference' && !monitorInterval) {
            console.log('🔍 [MONITOR] Iniciando monitoramento de jobIds (intervalo: 1s)');
            monitorInterval = setInterval(checkJobIdIntegrity, 1000);
        } else if (e.detail?.mode !== 'reference' && monitorInterval) {
            console.log('🔍 [MONITOR] Parando monitoramento de jobIds');
            clearInterval(monitorInterval);
            monitorInterval = null;
        }
    });
    
    // Inicia imediatamente se já estiver em modo reference
    if (window.currentAnalysisMode === 'reference') {
        console.log('🔍 [MONITOR] Modo reference detectado - iniciando monitoramento');
        monitorInterval = setInterval(checkJobIdIntegrity, 1000);
    }
    
    console.log('✅ [MONITOR] Sistema de monitoramento de jobIds ativado');
})();

window.addEventListener("beforeunload", () => {
    console.log("🧹 [CLEANUP] Encerrando sessão de análise e limpando estado.");
});

// 🎯 PATCH DEFINITIVO: Carregar correção da tabela de referência
(function loadReferenceTablePatch() {
    console.log('📦 [INTEGRATION] Carregando patch definitivo da tabela de referência...');
    
    // Tentar carregar o patch definitivo
    const script = document.createElement('script');
    script.src = 'patch-tabela-referencia-final.js';
    script.onload = function() {
        console.log('✅ [INTEGRATION] Patch definitivo carregado com sucesso');
    };
    script.onerror = function() {
        console.warn('⚠️ [INTEGRATION] Não foi possível carregar patch-tabela-referencia-final.js');
        console.log('💡 [INTEGRATION] A correção já foi aplicada diretamente no código');
    };
    
    document.head.appendChild(script);
})();

// ═══════════════════════════════════════════════════════════════════════════
// 🧪 V3.4 TEST BLOCK: TESTES DO SCORE ENGINE COM CAPS PROPORCIONAIS
// ═══════════════════════════════════════════════════════════════════════════
/**
 * Testes para validar o sistema de gates proporcionais V3.4
 * Execute no console: window.__testV34GatesProportional()
 */
window.__testV34GatesProportional = function() {
    console.log('\n');
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('🧪 V3.4 TEST BLOCK: GATES PROPORCIONAIS');
    console.log('═══════════════════════════════════════════════════════════════');
    
    // Funções de cap (cópia local para teste)
    function calculateTruePeakCap(tp, max) {
        if (tp === null || tp <= max) return 100;
        const excess = tp - max;
        return Math.max(35, Math.round(95 - (excess * 20)));
    }
    
    function calculateLufsCap(lufsValue, max) {
        if (lufsValue === null || lufsValue <= max) return 100;
        const excess = lufsValue - max;
        return Math.max(50, Math.round(95 - (excess * 7.5)));
    }
    
    const tests = [
        // Cenário 1: TP OK (-2.0 dBTP, limite -1.0)
        {
            name: 'TP OK',
            tp: -2.0,
            tpMax: -1.0,
            expectedCap: 100,
            description: 'True Peak abaixo do limite'
        },
        // Cenário 2: TP levemente acima (-0.5 dBTP, limite -1.0)
        {
            name: 'TP Leve',
            tp: -0.5,
            tpMax: -1.0,
            expectedCapRange: [83, 87], // 95 - 0.5*20 = 85 (±2)
            description: 'True Peak +0.5 dB acima'
        },
        // Cenário 3: TP positivo pequeno (+0.3 dBTP)
        {
            name: 'TP Positivo Pequeno',
            tp: 0.3,
            tpMax: -1.0,
            expectedCapRange: [65, 75], // 95 - 1.3*20 = 69 (±5)
            description: 'True Peak +1.3 dB acima (leve clipping)'
        },
        // Cenário 4: TP positivo alto (+2.0 dBTP)
        {
            name: 'TP Positivo Alto',
            tp: 2.0,
            tpMax: -1.0,
            expectedCapRange: [35, 45], // 95 - 3*20 = 35 (mínimo)
            description: 'True Peak +3 dB acima (clipping severo)'
        },
        // Cenário 5: LUFS OK (-14 LUFS, limite -12)
        {
            name: 'LUFS OK',
            lufs: -14,
            lufsMax: -12,
            expectedCap: 100,
            description: 'LUFS abaixo do limite'
        },
        // Cenário 6: LUFS +2 LU acima
        {
            name: 'LUFS +2 LU',
            lufs: -10,
            lufsMax: -12,
            expectedCapRange: [78, 82], // 95 - 2*7.5 = 80 (±2)
            description: 'LUFS +2 LU acima'
        },
        // Cenário 7: LUFS +6 LU acima (loudness war)
        {
            name: 'LUFS +6 LU',
            lufs: -6,
            lufsMax: -12,
            expectedCap: 50, // Mínimo
            description: 'LUFS +6 LU acima (loudness war)'
        }
    ];
    
    let passed = 0;
    let failed = 0;
    
    tests.forEach((test, i) => {
        let actualCap;
        let isPass = false;
        
        if (test.tp !== undefined) {
            actualCap = calculateTruePeakCap(test.tp, test.tpMax);
        } else if (test.lufs !== undefined) {
            actualCap = calculateLufsCap(test.lufs, test.lufsMax);
        }
        
        if (test.expectedCap !== undefined) {
            isPass = actualCap === test.expectedCap;
        } else if (test.expectedCapRange) {
            isPass = actualCap >= test.expectedCapRange[0] && actualCap <= test.expectedCapRange[1];
        }
        
        const icon = isPass ? '✅' : '❌';
        const expected = test.expectedCap ?? `${test.expectedCapRange[0]}-${test.expectedCapRange[1]}`;
        
        console.log(`${icon} ${i+1}. ${test.name}: Cap=${actualCap}% (esperado: ${expected}%)`);
        console.log(`   └─ ${test.description}`);
        
        if (isPass) passed++; else failed++;
    });
    
    console.log('───────────────────────────────────────────────────────────────');
    console.log(`📊 RESULTADO: ${passed}/${tests.length} testes passaram`);
    
    if (failed === 0) {
        console.log('🎉 TODOS OS TESTES PASSARAM! V3.4 funcionando corretamente.');
    } else {
        console.error(`⚠️ ${failed} teste(s) falharam. Verifique a implementação.`);
    }
    
    console.log('═══════════════════════════════════════════════════════════════');
    console.log('\n');
    
    return { passed, failed, total: tests.length };
};

// Auto-log para confirmar disponibilidade
console.log('🧪 [V3.4] Função de teste disponível: window.__testV34GatesProportional()');

// ═══════════════════════════════════════════════════════════════════════════════
// 🚀 PLANO DE CORREÇÃO COMPLETO - Função Global de Injeção
// Posiciona o botão FORA da seção de sugestões, após o aiHelperText
// ═══════════════════════════════════════════════════════════════════════════════

/**
 * 🔧 Detecta a categoria de uma métrica pelo nome
 * Usa METRIC_CATEGORY_MAP definido no topo do arquivo
 */
function detectMetricCategory(metricName) {
    if (!metricName) return 'other';
    
    const normalized = metricName.toLowerCase();
    
    // Tentar match exato primeiro
    for (const [key, category] of Object.entries(METRIC_CATEGORY_MAP)) {
        if (normalized.includes(key.toLowerCase())) {
            return category;
        }
    }
    
    // Detecção por padrão de frequência (Hz, kHz)
    if (normalized.includes('hz') || normalized.includes('khz')) {
        return 'frequency';
    }
    
    // Detecção por padrão de loudness
    if (normalized.includes('db') || normalized.includes('lufs')) {
        return 'loudness';
    }
    
    return 'other';
}

/**
 * 📋 PLANO DE CORREÇÃO - Apenas registra event listener
 * O botão já existe no HTML do modal (index.html)
 */
window.injectCorrectionPlanButtonOutside = function() {
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    if (!btn) {
        console.warn('[CORRECTION-PLAN] ⚠️ Botão #btnGenerateCorrectionPlan não encontrado no DOM');
        return;
    }
    
    // Verificar se já tem listener registrado
    if (btn.dataset.listenerAttached === 'true') {
        console.log('[CORRECTION-PLAN] ✅ Listener já registrado - skip');
        return;
    }
    
    // Registrar event listener
    btn.addEventListener('click', handleGenerateCorrectionPlan);
    btn.dataset.listenerAttached = 'true';
    
    console.log('[CORRECTION-PLAN] ✅ Event listener registrado no botão');
};

/**
 * 🎨 Estilos do botão - já definidos no index.html <style>
 * Mantido apenas para compatibilidade com chamadas externas
 */
function injectCorrectionPlanStyles() {
    // Estilos já estão no index.html - nada a fazer
    console.log('[CORRECTION-PLAN] ℹ️ Estilos já carregados via HTML');
}

/**
 * 🆕 Extrai problemas diretamente da tabela de métricas no DOM
 * VERSÃO REFATORADA com categorização e validação robusta
 */
function extractProblemsFromTableDOM() {
    console.log('[CORRECTION-PLAN] 🔍 Extraindo problemas da tabela DOM...');
    
    const problems = [];
    const categorizedProblems = {
        loudness: [],
        frequency: [],
        dynamics: [],
        stereo: [],
        other: []
    };
    
    // Buscar a tabela de comparação de gênero
    const table = document.querySelector('.classic-genre-table');
    
    if (!table) {
        console.warn('[CORRECTION-PLAN] ⚠️ Tabela .classic-genre-table não encontrada');
        return problems;
    }
    
    // Iterar sobre as linhas do tbody
    const rows = table.querySelectorAll('tbody tr');
    
    console.log('[CORRECTION-PLAN] 📋 Linhas encontradas na tabela:', rows.length);
    
    rows.forEach((row, index) => {
        const cells = row.querySelectorAll('td');
        
        if (cells.length < 6) {
            console.warn(`[CORRECTION-PLAN] ⚠️ Linha ${index} tem menos de 6 células, ignorando`);
            return;
        }
        
        // Extrair dados das células
        // Estrutura: Métrica | Valor | Alvo | Diferença | Severidade | Ação
        const metric = cells[0]?.textContent?.trim() || '';
        const value = cells[1]?.textContent?.trim() || '';
        const target = cells[2]?.textContent?.trim() || '';
        const diff = cells[3]?.textContent?.trim() || '';
        const severityEl = cells[4];
        const action = cells[5]?.textContent?.trim() || '';
        
        // Validar dados essenciais - NUNCA aceitar undefined
        if (!metric || metric === 'undefined' || !value || value === 'undefined') {
            console.warn(`[CORRECTION-PLAN] ⚠️ Linha ${index} tem dados inválidos (metric: ${metric}, value: ${value})`);
            return;
        }
        
        // Extrair severidade (pode estar em span ou texto direto)
        let severity = severityEl?.textContent?.trim() || '';
        const severitySpan = severityEl?.querySelector('.metric-severity');
        if (severitySpan) {
            severity = severitySpan.textContent?.trim() || severity;
        }
        
        // Verificar se a linha tem classe de status
        const rowClass = row.className || '';
        if (!severity || severity === '') {
            if (rowClass.includes('critical')) severity = 'CRÍTICA';
            else if (rowClass.includes('warning')) severity = 'ATENÇÃO';
            else if (rowClass.includes('caution')) severity = 'ATENÇÃO';
            else if (rowClass.includes('ok')) severity = 'OK';
        }
        
        // 🛡️ USAR NORMALIZESEVERITY - NUNCA .toUpperCase() direto
        const normalizedSeverity = normalizeSeverity(severity);
        
        // 🛡️ USAR ISPROBLEMATICSEVERITY - Lógica centralizada
        const isProblematic = isProblematicSeverity(severity);
        
        // Detectar categoria da métrica
        const category = detectMetricCategory(metric);
        
        // Criar objeto de problema
        const problem = {
            id: metric.toLowerCase().replace(/[^a-z0-9]/g, '_'),
            metric: metric,
            value: value,
            target: target,
            difference: diff,
            severity: normalizedSeverity, // Já normalizado
            action: action,
            category: category,
            isProblematic: isProblematic,
            description: action || `${metric} está fora do padrão: ${value} (alvo: ${target})`
        };
        
        // Adicionar a lista geral (incluindo OKs para debug)
        problems.push(problem);
        
        // Categorizar apenas problemas reais
        if (isProblematic && categorizedProblems[category]) {
            categorizedProblems[category].push(problem);
        }
    });
    
    // Log de diagnóstico detalhado
    console.log('[CORRECTION-PLAN] 📊 Problemas por categoria:', {
        loudness: categorizedProblems.loudness.length,
        frequency: categorizedProblems.frequency.length,
        dynamics: categorizedProblems.dynamics.length,
        stereo: categorizedProblems.stereo.length,
        total: problems.filter(p => p.isProblematic).length
    });
    
    // Retornar apenas problemas reais (CRÍTICA ou ATENÇÃO)
    const realProblems = problems.filter(p => p.isProblematic);
    
    // Salvar categorização para uso posterior
    window.__CORRECTION_PLAN_CATEGORIES__ = categorizedProblems;
    
    console.log('[CORRECTION-PLAN] ✅ Total de problemas reais extraídos:', realProblems.length);
    
    return realProblems;
}

/**
 * 🆕 Gera um resumo estruturado dos problemas para enviar à API
 * Agrupa por categoria e formata para o prompt da IA
 */
function buildProblemsSummary(problems) {
    const categories = window.__CORRECTION_PLAN_CATEGORIES__ || {
        loudness: [],
        frequency: [],
        dynamics: [],
        stereo: [],
        other: []
    };
    
    const summary = {
        hasLoudnessProblems: categories.loudness.length > 0,
        hasFrequencyProblems: categories.frequency.length > 0,
        hasDynamicsProblems: categories.dynamics.length > 0,
        hasStereoProblems: categories.stereo.length > 0,
        
        loudnessProblems: categories.loudness.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        frequencyProblems: categories.frequency.map(p => ({
            band: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        dynamicsProblems: categories.dynamics.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        stereoProblems: categories.stereo.map(p => ({
            metric: p.metric,
            value: p.value,
            target: p.target,
            diff: p.difference,
            severity: p.severity
        })),
        
        totalProblems: problems.length,
        // 🛡️ USAR NORMALIZESEVERITY - Blindagem contra undefined/objeto
        criticalCount: problems.filter(p => p && normalizeSeverity(p.severity).includes('CRÍT')).length,
        attentionCount: problems.filter(p => p && normalizeSeverity(p.severity).includes('ATEN')).length
    };
    
    return summary;
}

/**
 * 🔥 Handler para gerar o Plano de Correção (função global)
 */
async function handleGenerateCorrectionPlan() {
    console.log('[CORRECTION-PLAN] 🚀 handleGenerateCorrectionPlan() INICIADO!');
    
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    if (!btn) {
        console.error('[CORRECTION-PLAN] ❌ Botão não encontrado');
        return;
    }
    
    console.log('[CORRECTION-PLAN] ✅ Botão encontrado:', btn);
    
    // Obter análise atual
    const analysis = window.__CURRENT_ANALYSIS__ || 
                     window.currentModalAnalysis || 
                     window.__soundyAI?.analysis;
    
    console.log('[CORRECTION-PLAN] 📊 Análise encontrada:', !!analysis, {
        __CURRENT_ANALYSIS__: !!window.__CURRENT_ANALYSIS__,
        currentModalAnalysis: !!window.currentModalAnalysis,
        __soundyAI_analysis: !!window.__soundyAI?.analysis
    });
    
    if (!analysis) {
        showCorrectionPlanError('Nenhuma análise encontrada. Analise uma música primeiro.');
        return;
    }
    
    // Verificar autenticação Firebase (múltiplos caminhos)
    const firebaseAuth = window.firebase?.auth?.() || window.auth;
    const user = firebaseAuth?.currentUser;
    
    console.log('[CORRECTION-PLAN] 🔐 Auth check:', {
        hasFirebaseAuth: !!firebaseAuth,
        hasUser: !!user,
        userEmail: user?.email
    });
    
    if (!user) {
        showCorrectionPlanError('Você precisa estar logado para gerar um plano.');
        return;
    }
    
    // Estado de loading
    const originalContent = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = `
        <span class="cta-loading">
            <span class="cta-spinner"></span>
            <span>Gerando...</span>
        </span>
    `;
    
    // Limpar erro anterior
    const existingError = document.querySelector('.correction-plan-error');
    if (existingError) existingError.remove();
    
    try {
        // Obter token
        const token = typeof user.getIdToken === 'function' 
            ? await user.getIdToken() 
            : user.accessToken;
        
        if (!token) {
            throw new Error('Não foi possível obter token de autenticação');
        }
        
        // Preparar payload
        // 🔧 FIX v5: PARIDADE TOTAL - Usar EXATAMENTE os mesmos problemas da análise
        // NUNCA extrair do DOM - isso pode descartar problemas
        let problemsToSend = [];
        let problemSource = '';
        
        // 🎯 FONTE 1: analysis.problems (fonte primária)
        if (analysis.problems && analysis.problems.length > 0) {
            problemsToSend = analysis.problems;
            problemSource = 'analysis.problems';
            console.log('[CORRECTION-PLAN] ✅ Usando analysis.problems:', problemsToSend.length);
        }
        // 🎯 FONTE 2: analysis.suggestions (fallback)
        else if (analysis.suggestions && analysis.suggestions.length > 0) {
            const suggestions = analysis.suggestions;
            problemsToSend = suggestions
                .filter(s => s.severity !== 'ok' && s.severity !== 'info') // Apenas problemas reais
                .map(s => ({
                    id: s.metric || s.metricName || s.name || 'unknown',
                    metric: s.metric || s.metricName || s.name || 'unknown',
                    value: s.currentValue || s.value || s.measured || 'N/A',
                    target: s.targetValue || s.target || s.ideal || 'N/A',
                    severity: s.severity || s.priority || 'medium',
                    category: detectMetricCategory(s.metric || s.metricName || s.name || ''),
                    description: s.problem || s.description || s.title || '',
                    action: s.action || s.recommendation || ''
                }));
            problemSource = 'analysis.suggestions (filtrado)';
            console.log('[CORRECTION-PLAN] ✅ Usando analysis.suggestions filtrado:', problemsToSend.length);
        }
        // 🎯 FONTE 3: Extrair da tabela DOM (último recurso)
        else {
            problemsToSend = extractProblemsFromTableDOM();
            problemSource = 'table-dom (fallback)';
            console.log('[CORRECTION-PLAN] ⚠️ Usando table-dom como fallback:', problemsToSend.length);
        }
        
        // 🛡️ VALIDAÇÃO CRÍTICA: Verificar se True Peak está presente quando deveria
        const hasTruePeakIssue = analysis.technicalData?.truePeakDbtp != null && 
                                 analysis.technicalData.truePeakDbtp > -1.0; // Threshold de problema
        
        const hasTruePeakInProblems = problemsToSend.some(p => 
            p.metric && (
                p.metric.toLowerCase().includes('true peak') ||
                p.metric.toLowerCase().includes('truepeak') ||
                p.metric.toLowerCase().includes('pico real') ||
                p.id?.toLowerCase().includes('truepeak')
            )
        );
        
        if (hasTruePeakIssue && !hasTruePeakInProblems) {
            console.warn('[CORRECTION-PLAN] ⚠️ TRUE PEAK DETECTADO MAS AUSENTE! Injetando manualmente...');
            
            // Injetar True Peak manualmente
            const truePeakProblem = {
                id: 'truepeak_missing',
                metric: 'True Peak',
                value: `${analysis.technicalData.truePeakDbtp.toFixed(2)} dBTP`,
                target: '-1.0 dBTP',
                severity: analysis.technicalData.truePeakDbtp > 0 ? 'CRÍTICA' : 'ATENÇÃO',
                category: 'dynamics',
                description: analysis.technicalData.truePeakDbtp > 0 
                    ? 'Pico real acima de 0 dBTP - risco de clipping digital'
                    : 'Pico real acima do ideal - pode causar distorção em conversões',
                action: 'Aplicar limiting com True Peak Detection ativado'
            };
            
            problemsToSend.push(truePeakProblem);
            console.log('[CORRECTION-PLAN] ✅ True Peak injetado:', truePeakProblem);
        }
        
        // 🛡️ VALIDAÇÃO ADICIONAL: Garantir outros problemas técnicos críticos
        const tech = analysis.technicalData || {};
        
        // Verificar LUFS Integrado
        const hasLufsIssue = tech.lufsIntegrated != null && 
                            (tech.lufsIntegrated < -20 || tech.lufsIntegrated > -8);
        const hasLufsInProblems = problemsToSend.some(p => 
            p.metric?.toLowerCase().includes('lufs') || p.id?.toLowerCase().includes('lufs')
        );
        
        if (hasLufsIssue && !hasLufsInProblems) {
            console.warn('[CORRECTION-PLAN] ⚠️ LUFS fora do padrão mas ausente! Injetando...');
            problemsToSend.push({
                id: 'lufs_missing',
                metric: 'LUFS Integrado',
                value: `${tech.lufsIntegrated.toFixed(2)} LUFS`,
                target: '-14 LUFS (streaming)',
                severity: tech.lufsIntegrated < -20 ? 'CRÍTICA' : 'ATENÇÃO',
                category: 'loudness',
                description: tech.lufsIntegrated < -20 
                    ? 'Loudness muito baixo - áudio será rejeitado em plataformas'
                    : 'Loudness acima do ideal - causará normalização',
                action: 'Ajustar gain para atingir -14 LUFS integrado'
            });
        }
        
        // Verificar Dynamic Range
        const hasDRIssue = tech.dynamicRange != null && 
                          (tech.dynamicRange < 4 || tech.dynamicRange > 20);
        const hasDRInProblems = problemsToSend.some(p => 
            p.metric?.toLowerCase().includes('dynamic range') || 
            p.metric?.toLowerCase().includes('dr ') ||
            p.id?.toLowerCase().includes('dynamicrange')
        );
        
        if (hasDRIssue && !hasDRInProblems) {
            console.warn('[CORRECTION-PLAN] ⚠️ Dynamic Range problemático mas ausente! Injetando...');
            problemsToSend.push({
                id: 'dr_missing',
                metric: 'Dynamic Range',
                value: `${tech.dynamicRange.toFixed(1)} dB`,
                target: '8-12 dB (ideal)',
                severity: tech.dynamicRange < 4 ? 'CRÍTICA' : 'ATENÇÃO',
                category: 'dynamics',
                description: tech.dynamicRange < 4
                    ? 'Dinâmica muito comprimida - som "achatado"'
                    : 'Dinâmica excessiva - pode soar inconsistente',
                action: tech.dynamicRange < 4
                    ? 'Reduzir compressão/limiting excessivo'
                    : 'Aplicar compressão para controlar dinâmica'
            });
        }
        
        console.log('[CORRECTION-PLAN] 📊 Total após validações:', problemsToSend.length, 'problemas');
        
        // 🆕 Construir resumo categorizado para melhor processamento pela IA
        const problemsSummary = buildProblemsSummary(problemsToSend);
        
        console.log('[CORRECTION-PLAN] 📊 Problemas extraídos:', problemsToSend.length, 'fonte:', problemSource);
        console.log('[CORRECTION-PLAN] 📊 Resumo por categoria:', {
            loudness: problemsSummary.loudnessProblems.length,
            frequency: problemsSummary.frequencyProblems.length,
            dynamics: problemsSummary.dynamicsProblems.length,
            stereo: problemsSummary.stereoProblems.length
        });
        
        // 🔍 LOG DETALHADO: Listar TODOS os problemas encontrados
        console.group('[CORRECTION-PLAN] 📋 LISTA COMPLETA DE PROBLEMAS');
        problemsToSend.forEach((p, i) => {
            console.log(`${i + 1}. ${p.metric || p.id}`, {
                value: p.value,
                target: p.target,
                severity: p.severity,
                category: p.category
            });
        });
        console.groupEnd();
        
        // 🎯 ASSERT FINAL: Confirmar que temos problemas suficientes
        if (problemsToSend.length === 0) {
            console.error('[CORRECTION-PLAN] ❌ ERRO CRÍTICO: Nenhum problema encontrado!');
            console.error('[CORRECTION-PLAN] analysis.problems:', analysis.problems?.length || 0);
            console.error('[CORRECTION-PLAN] analysis.suggestions:', analysis.suggestions?.length || 0);
            console.error('[CORRECTION-PLAN] technicalData:', !!analysis.technicalData);
            
            showCorrectionPlanError('Nenhum problema detectado na análise. Analise novamente.');
            btn.disabled = false;
            btn.innerHTML = originalContent;
            return;
        }
        
        const payload = {
            analysisId: analysis.jobId || analysis.id,
            technicalData: analysis.technicalData || {},
            suggestions: analysis.suggestions || analysis.aiSuggestions || [],
            problems: problemsToSend,
            problemsSummary: problemsSummary, // 🆕 Resumo categorizado
            metadata: {
                fileName: analysis.metadata?.fileName || analysis.fileName || 'Sem nome',
                genre: analysis.genre || analysis.metadata?.genre || 'generic',
                daw: getUserDAWForPlan(),
                level: getUserLevelForPlan()
            },
            scores: analysis.scores || { final: analysis.score }
        };
        
        console.log('[CORRECTION-PLAN] 📤 Enviando para API:', {
            analysisId: payload.analysisId,
            genre: payload.metadata.genre,
            daw: payload.metadata.daw,
            level: payload.metadata.level,
            suggestionsCount: payload.suggestions.length,
            problemsCount: payload.problems.length
        });
        
        // URL da API - mesmo domínio (rota no server.js principal)
        const apiUrl = '/api/correction-plan';
        console.log('[CORRECTION-PLAN] 🎯 URL:', apiUrl);
        
        // Chamar API
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(payload)
        });
        
        // 🔍 DEBUG: Capturar resposta bruta ANTES de parsear
        const responseText = await response.text();
        console.log('[CORRECTION-PLAN] 📥 Status:', response.status);
        console.log('[CORRECTION-PLAN] 📥 Headers:', Object.fromEntries(response.headers.entries()));
        console.log('[CORRECTION-PLAN] 📥 Resposta bruta (primeiros 500 chars):', responseText.substring(0, 500));
        
        // Verificar se é HTML (erro do servidor)
        if (responseText.trim().startsWith('<!DOCTYPE') || responseText.trim().startsWith('<html')) {
            console.error('[CORRECTION-PLAN] ❌ Servidor retornou HTML em vez de JSON!');
            throw new Error('Servidor retornou página de erro. A rota /api/correction-plan pode não existir.');
        }
        
        // Parsear JSON manualmente
        let result;
        try {
            result = JSON.parse(responseText);
        } catch (parseError) {
            console.error('[CORRECTION-PLAN] ❌ Erro ao parsear JSON:', parseError);
            console.error('[CORRECTION-PLAN] Resposta completa:', responseText);
            throw new Error('Resposta inválida do servidor (não é JSON válido)');
        }
        
        if (!response.ok) {
            throw new Error(result.error || result.message || 'Erro ao gerar plano');
        }
        
        if (!result.success || !result.planId) {
            throw new Error('Resposta inválida da API');
        }
        
        console.log('[CORRECTION-PLAN] ✅ Plano gerado com sucesso:', {
            planId: result.planId,
            stepsCount: result.stepsCount,
            cached: result.cached
        });
        
        // 🔧 FIX: Abrir em NOVA ABA de forma que não seja bloqueado
        const planUrl = `/plano.html?id=${result.planId}`;
        
        // Tentar abrir nova aba
        const newWindow = window.open(planUrl, '_blank');
        
        // Se foi bloqueado, mostrar link clicável
        if (!newWindow || newWindow.closed || typeof newWindow.closed === 'undefined') {
            console.log('[CORRECTION-PLAN] ⚠️ Popup bloqueado, mostrando link');
            
            // Restaurar botão
            btn.disabled = false;
            btn.innerHTML = originalContent;
            
            // Mostrar link clicável
            const linkContainer = document.createElement('div');
            linkContainer.className = 'correction-plan-success';
            linkContainer.innerHTML = `
                <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 16px 20px; border-radius: 12px; margin-top: 12px; text-align: center;">
                    <p style="color: white; margin: 0 0 10px 0; font-weight: 600;">✅ Plano gerado com sucesso!</p>
                    <a href="${planUrl}" target="_blank" style="display: inline-block; background: white; color: #059669; padding: 10px 24px; border-radius: 8px; text-decoration: none; font-weight: 600;">
                        🚀 Abrir Plano de Correção
                    </a>
                </div>
            `;
            btn.parentElement.appendChild(linkContainer);
            
            // Remover após 30 segundos
            setTimeout(() => linkContainer.remove(), 30000);
        } else {
            // Restaurar botão
            btn.disabled = false;
            btn.innerHTML = originalContent;
        }
        
    } catch (error) {
        console.error('[CORRECTION-PLAN] ❌ Erro:', error);
        
        // Restaurar botão
        btn.disabled = false;
        btn.innerHTML = originalContent;
        
        // Mostrar erro apropriado
        let errorMessage = error.message;
        
        if (error.message.includes('rate limit') || error.message.includes('limite')) {
            errorMessage = 'Você atingiu o limite de requisições. Aguarde alguns minutos.';
        } else if (error.message.includes('monthly limit') || error.message.includes('mensal')) {
            errorMessage = 'Limite mensal atingido. Faça upgrade do seu plano para mais planos.';
        } else if (error.message.includes('401') || error.message.includes('auth')) {
            errorMessage = 'Sessão expirada. Faça login novamente.';
        }
        
        showCorrectionPlanError(errorMessage);
    }
}

/**
 * 🛠️ Obtém a DAW do usuário
 */
function getUserDAWForPlan() {
    const profile = window.__USER_PROFILE__ || 
                    JSON.parse(localStorage.getItem('soundy_user_profile') || '{}');
    if (profile.daw) return profile.daw;
    
    const interview = JSON.parse(localStorage.getItem('soundy_interview') || '{}');
    if (interview.daw) return interview.daw;
    
    return 'generic';
}

/**
 * 🛠️ Obtém o nível do usuário
 */
function getUserLevelForPlan() {
    const profile = window.__USER_PROFILE__ || 
                    JSON.parse(localStorage.getItem('soundy_user_profile') || '{}');
    if (profile.level) return profile.level;
    
    const interview = JSON.parse(localStorage.getItem('soundy_interview') || '{}');
    if (interview.level) return interview.level;
    
    return 'intermediario';
}

/**
 * ❌ Exibe erro no container de ações
 */
function showCorrectionPlanError(message) {
    const actionsContainer = document.querySelector('.analysis-actions');
    if (!actionsContainer) return;
    
    // Remover erro anterior se existir
    const existing = actionsContainer.querySelector('.correction-plan-error');
    if (existing) existing.remove();
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'correction-plan-error';
    errorDiv.textContent = `❌ ${message}`;
    
    // Inserir erro no final do container
    actionsContainer.appendChild(errorDiv);
    
    // Auto-remover após 5 segundos
    setTimeout(() => errorDiv.remove(), 5000);
}

// Expor funções globalmente para serem chamadas por outros scripts
window.injectCorrectionPlanStyles = injectCorrectionPlanStyles;
window.handleGenerateCorrectionPlan = handleGenerateCorrectionPlan;
window.getUserDAWForPlan = getUserDAWForPlan;
window.getUserLevelForPlan = getUserLevelForPlan;
window.showCorrectionPlanError = showCorrectionPlanError;

// 📋 AUTO-REGISTRO: Observer para registrar event listener quando modal fica visível
(function setupCorrectionPlanAutoAttach() {
    const btn = document.getElementById('btnGenerateCorrectionPlan');
    
    // Se o botão existir, registrar listener imediatamente
    if (btn && btn.dataset.listenerAttached !== 'true') {
        btn.addEventListener('click', handleGenerateCorrectionPlan);
        btn.dataset.listenerAttached = 'true';
        console.log('[CORRECTION-PLAN] ✅ Event listener registrado na inicialização');
    }
    
    // Observer para detectar quando o modal de resultados fica visível
    const audioResults = document.getElementById('audioAnalysisResults');
    if (audioResults) {
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                    const isVisible = audioResults.style.display !== 'none';
                    if (isVisible) {
                        // Modal ficou visível - registrar listener se necessário
                        const planBtn = document.getElementById('btnGenerateCorrectionPlan');
                        if (planBtn && planBtn.dataset.listenerAttached !== 'true') {
                            planBtn.addEventListener('click', handleGenerateCorrectionPlan);
                            planBtn.dataset.listenerAttached = 'true';
                            console.log('[CORRECTION-PLAN] ✅ Event listener registrado via MutationObserver');
                        }
                    }
                }
            }
        });
        
        observer.observe(audioResults, { attributes: true, attributeFilter: ['style'] });
        console.log('[CORRECTION-PLAN] 👀 MutationObserver ativo em #audioAnalysisResults');
    }
})();

console.log('🚀 [CORRECTION-PLAN] Sistema de Plano de Correção Completo carregado');
