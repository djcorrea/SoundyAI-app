<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste - Auditoria Completa True Peak</title>
</head>
<body>
    <h1>ğŸ” Teste - Auditoria Completa para True Peak</h1>
    <p>Abra o console (F12) e observe os logs detalhados:</p>
    
    <div id="log-container">
        <h3>ğŸ¯ Problemas Identificados e Corrigidos:</h3>
        <ol>
            <li>âœ… <strong>Prioridade correta:</strong> s.message agora tem prioridade 1</li>
            <li>âœ… <strong>Fallback UI:</strong> createSuggestionCard usa message quando blocos especÃ­ficos nÃ£o existem</li>
            <li>âœ… <strong>Title/Message sync:</strong> title = message quando title estÃ¡ vazio</li>
            <li>âœ… <strong>True Peak no topo:</strong> ordenaÃ§Ã£o mantida</li>
            <li>âœ… <strong>Logs detalhados:</strong> rastreamento completo do merge</li>
        </ol>
    </div>

    <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px;">
        <h4>ğŸ§ª CenÃ¡rios de Teste:</h4>
        <button onclick="testDirectAIMessage()">ğŸ¯ s.message direto da IA</button>
        <button onclick="testTruePeakPriority()">âš¡ True Peak prioritÃ¡rio</button>
        <button onclick="testUIFallback()">ğŸ–¥ï¸ Fallback UI</button>
        <button onclick="testCompleteFlow()">ğŸš€ Fluxo completo</button>
        <button onclick="testValidationChecklist()">âœ… Checklist de validaÃ§Ã£o</button>
        <button onclick="console.clear()">ğŸ§¹ Limpar Console</button>
    </div>

    <div id="result-display" style="margin: 20px 0; padding: 15px; background: #e7f3ff; border-radius: 5px;">
        <h4>ğŸ“Š Resultado do Ãšltimo Teste:</h4>
        <div id="result-content">Nenhum teste executado ainda.</div>
    </div>

    <script>
        // FunÃ§Ã£o de merge corrigida com prioridade correta
        function testCorrectedMerge(validSuggestions, enhancedSuggestions) {
            return enhancedSuggestions.map((s, i) => {
                const original = validSuggestions[i] || {};
                const meta = s.metadata || {};
                const content = meta.content || {};
                const inner = meta.inner || {};
                const originalData = meta.originalData || {};
                const data = meta.data || {};
                const enriched = meta.enriched || {};

                // Busca recursiva ampla - PRIORIDADE CORRETA
                const resolvedMessage =
                    s.message ||                           // ğŸ¯ PRIORIDADE 1: Resposta direta da IA
                    original.message ||                    // ğŸ“‹ PRIORIDADE 2: SugestÃ£o original  
                    meta.message ||                        // ğŸ” metadata.message
                    (meta.original && meta.original.message) || // âš¡ metadata.original.message
                    (meta.enriched && meta.enriched.message) || // âœ¨ metadata.enriched.message
                    data.message ||                        // ğŸ“Š metadata.data.message
                    originalData.message ||                // ğŸ—‚ï¸ metadata.originalData.message
                    (content.original && content.original.message) || // ğŸ—ï¸ metadata.content.original.message
                    (content.enriched && content.enriched.message) || // ğŸ¨ metadata.content.enriched.message
                    (inner.original && inner.original.message) ||     // ğŸ  metadata.inner.original.message
                    (inner.enriched && inner.enriched.message) ||     // ğŸ’ metadata.inner.enriched.message
                    (original.original && typeof original.original === "string" ? original.original : null);

                const resolvedAction =
                    s.action ||                           // ğŸ¯ PRIORIDADE 1: Action direta da IA
                    original.action ||                    // ğŸ“‹ PRIORIDADE 2: Action original
                    meta.action ||                        // ğŸ” metadata.action
                    (meta.original && meta.original.action) || // âš¡ metadata.original.action
                    (meta.enriched && meta.enriched.action) || // âœ¨ metadata.enriched.action
                    data.action ||                        // ğŸ“Š metadata.data.action
                    originalData.action ||                // ğŸ—‚ï¸ metadata.originalData.action
                    (content.original && content.original.action) || // ğŸ—ï¸ metadata.content.original.action
                    (content.enriched && content.enriched.action) || // ğŸ¨ metadata.content.enriched.action
                    (inner.original && inner.original.action) ||     // ğŸ  metadata.inner.original.action
                    (inner.enriched && inner.enriched.action) ||     // ğŸ’ metadata.inner.enriched.action
                    (original.originalAction && typeof original.originalAction === "string" ? original.originalAction : null);

                return {
                    ai_enhanced: true,
                    ...original,
                    ...s,
                    hasOriginalMessage: !!resolvedMessage,
                    messageSource: resolvedMessage ? "restored" : "fallback",
                    message: resolvedMessage || "âš ï¸ Mensagem perdida na integraÃ§Ã£o.",
                    title: resolvedMessage || "âš ï¸ Mensagem perdida na integraÃ§Ã£o.",
                    action: resolvedAction,
                    priority: s.priority || original.priority || 1,
                    confidence: s.confidence || original.confidence || 0.9,
                };
            });
        }

        // FunÃ§Ã£o de UI com fallback
        function simulateUIRendering(suggestions) {
            // Aplicar correÃ§Ã£o title/message
            suggestions.forEach((s) => {
                if (!s.title && s.message) {
                    s.title = s.message;
                }
            });

            // Simular createSuggestionCard
            return suggestions.map(suggestion => {
                const blocks = {
                    problem: suggestion.problema || suggestion.blocks?.problem || (suggestion.message && suggestion.message.includes("True Peak") ? suggestion.message : null),
                    cause: suggestion.causa || suggestion.blocks?.cause,
                    solution: suggestion.solucao || suggestion.blocks?.solution || suggestion.action,
                    tip: suggestion.dica_extra || suggestion.blocks?.tip,
                    plugin: suggestion.plugin || suggestion.blocks?.plugin,
                    result: suggestion.resultado || suggestion.blocks?.result
                };
                
                // FALLBACK CRÃTICO: Se nÃ£o hÃ¡ blocos especÃ­ficos, usar message/title como problema principal
                if (!blocks.problem && !blocks.solution && !blocks.cause) {
                    blocks.problem = suggestion.message || suggestion.title || "âš ï¸ ConteÃºdo nÃ£o disponÃ­vel";
                    if (suggestion.action) {
                        blocks.solution = suggestion.action;
                    }
                }

                return {
                    ...suggestion,
                    renderedBlocks: blocks,
                    willDisplay: !!(blocks.problem || blocks.solution),
                    fallbackUsed: !!(!suggestion.problema && !suggestion.blocks?.problem && suggestion.message)
                };
            });
        }

        function displayResult(scenarioName, results, successCriteria) {
            const div = document.getElementById('result-content');
            
            div.innerHTML = `
                <div><strong>CenÃ¡rio:</strong> ${scenarioName}</div>
                <div><strong>CritÃ©rios de sucesso:</strong> ${successCriteria}</div>
                <div><strong>Resultados:</strong></div>
                <ul>
                    ${results.map(r => `<li>${r.success ? 'âœ…' : 'âŒ'} ${r.description}</li>`).join('')}
                </ul>
                <div style="margin-top: 10px;"><strong>Status geral:</strong> ${results.every(r => r.success) ? 'âœ… TODOS OS TESTES PASSARAM' : 'âŒ ALGUNS TESTES FALHARAM'}</div>
            `;
        }

        function testDirectAIMessage() {
            log('ğŸ¯ CenÃ¡rio: s.message direto da IA (prioridade 1)');
            
            const validSuggestions = [{
                message: "Mensagem original que deveria ser ignorada",
                priority: 2
            }];
            
            const enhancedSuggestions = [{
                message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (1.2 dBTP â†’ -1.0 dBTP)",
                action: "Aplicar FabFilter Pro-L2 com threshold em -1.0 dB",
                priority: 1,
                metadata: {
                    original: {
                        message: "Esta mensagem deveria ser ignorada"
                    }
                }
            }];
            
            const merged = testCorrectedMerge(validSuggestions, enhancedSuggestions);
            
            const results = [
                {
                    success: merged[0].message.includes("True Peak"),
                    description: `s.message preservado: "${merged[0].message}"`
                },
                {
                    success: merged[0].hasOriginalMessage === true,
                    description: `hasOriginalMessage: ${merged[0].hasOriginalMessage}`
                },
                {
                    success: merged[0].messageSource === "restored",
                    description: `messageSource: ${merged[0].messageSource}`
                },
                {
                    success: merged[0].action?.includes("FabFilter"),
                    description: `Action preservada: "${merged[0].action}"`
                }
            ];
            
            log('ğŸ¯ Direct AI message test:', results);
            
            displayResult("s.message direto da IA", results, "s.message deve ter prioridade sobre todas as outras fontes");
        }

        function testTruePeakPriority() {
            log('âš¡ CenÃ¡rio: True Peak no topo com ordenaÃ§Ã£o');
            
            const validSuggestions = [
                { message: "LUFS baixo", priority: 2 },
                { message: "DR adequado", priority: 3 },
                { message: "True Peak original", priority: 1 }
            ];
            
            const enhancedSuggestions = [
                {
                    message: "ğŸ“Š LUFS estÃ¡ em -18.5, ideal para streaming",
                    priority: 2
                },
                {
                    message: "ğŸµ Dynamic Range adequado para o gÃªnero",
                    priority: 3
                },
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (1.2 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar limitador suave FabFilter Pro-L2",
                    priority: 1
                }
            ];
            
            const merged = testCorrectedMerge(validSuggestions, enhancedSuggestions);
            const sorted = merged.sort((a, b) => {
                if (a.message?.includes("True Peak") && !b.message?.includes("True Peak")) return -1;
                if (!a.message?.includes("True Peak") && b.message?.includes("True Peak")) return 1;
                return (a.priority || 1) - (b.priority || 1);
            });
            
            const results = [
                {
                    success: sorted[0].message.includes("True Peak"),
                    description: `True Peak no topo: "${sorted[0].message.substring(0, 40)}..."`
                },
                {
                    success: sorted.every(s => s.hasOriginalMessage),
                    description: `Todas as mensagens preservadas: ${sorted.every(s => s.hasOriginalMessage)}`
                },
                {
                    success: sorted[0].action?.includes("FabFilter"),
                    description: `Plugin especÃ­fico preservado: ${sorted[0].action?.includes("FabFilter") ? 'SIM' : 'NÃƒO'}`
                }
            ];
            
            log('âš¡ True Peak priority test:', {
                beforeSort: merged.map(s => s.message.substring(0, 30)),
                afterSort: sorted.map(s => s.message.substring(0, 30)),
                truePeakFirst: sorted[0].message.includes("True Peak")
            });
            
            displayResult("True Peak prioritÃ¡rio", results, "True Peak deve aparecer sempre primeiro apÃ³s ordenaÃ§Ã£o");
        }

        function testUIFallback() {
            log('ğŸ–¥ï¸ CenÃ¡rio: Fallback UI quando blocos especÃ­ficos nÃ£o existem');
            
            const suggestions = [
                {
                    message: "âš¡ True Peak crÃ­tico detectado",
                    action: "Aplicar limitador",
                    hasOriginalMessage: true,
                    messageSource: "restored",
                    // Sem campos problema/solucao especÃ­ficos
                },
                {
                    message: "ğŸ“Š LUFS adequado para streaming",
                    action: "Manter nÃ­veis atuais",
                    hasOriginalMessage: true,
                    messageSource: "restored",
                    problema: "Campo especÃ­fico existente", // Este tem campo especÃ­fico
                }
            ];
            
            const rendered = simulateUIRendering([...suggestions]);
            
            const results = [
                {
                    success: rendered[0].fallbackUsed === true,
                    description: `Fallback ativado para True Peak: ${rendered[0].fallbackUsed}`
                },
                {
                    success: rendered[0].renderedBlocks.problem === "âš¡ True Peak crÃ­tico detectado",
                    description: `Message usado como problema: "${rendered[0].renderedBlocks.problem}"`
                },
                {
                    success: rendered[0].willDisplay === true,
                    description: `Card serÃ¡ exibido: ${rendered[0].willDisplay}`
                },
                {
                    success: rendered[1].fallbackUsed === false,
                    description: `Campo especÃ­fico preservado: ${rendered[1].fallbackUsed === false}`
                }
            ];
            
            log('ğŸ–¥ï¸ UI Fallback test:', rendered);
            
            displayResult("Fallback UI", results, "UI deve usar message como fallback quando blocos especÃ­ficos nÃ£o existem");
        }

        function testCompleteFlow() {
            log('ğŸš€ CenÃ¡rio: Fluxo completo - merge + ordenaÃ§Ã£o + UI');
            
            // Simular resposta real do backend
            const validSuggestions = [
                { message: "LUFS original", priority: 2 },
                { message: "True Peak original", priority: 1 }
            ];
            
            const enhancedSuggestions = [
                {
                    message: "ğŸ“Š LUFS ideal para plataformas digitais",
                    action: "Ajustar gain para -14 LUFS",
                    priority: 2
                },
                {
                    message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA (1.2 dBTP â†’ -1.0 dBTP)",
                    action: "Aplicar FabFilter Pro-L2 com threshold suave",
                    priority: 1
                }
            ];
            
            // Executar fluxo completo
            const merged = testCorrectedMerge(validSuggestions, enhancedSuggestions);
            const sorted = merged.sort((a, b) => {
                if (a.message?.includes("True Peak") && !b.message?.includes("True Peak")) return -1;
                if (!a.message?.includes("True Peak") && b.message?.includes("True Peak")) return 1;
                return (a.priority || 1) - (b.priority || 1);
            });
            const rendered = simulateUIRendering(sorted);
            
            const results = [
                {
                    success: sorted.every(s => s.hasOriginalMessage && s.messageSource === "restored"),
                    description: `Todas as mensagens restauradas: ${sorted.every(s => s.hasOriginalMessage)}`
                },
                {
                    success: sorted[0].message.includes("True Peak"),
                    description: `True Peak no topo: "${sorted[0].message.substring(0, 40)}..."`
                },
                {
                    success: rendered.every(r => r.willDisplay),
                    description: `Todos os cards serÃ£o exibidos: ${rendered.every(r => r.willDisplay)}`
                },
                {
                    success: !sorted.some(s => s.message.includes("âš ï¸ Mensagem perdida")),
                    description: `Nenhum fallback de erro: ${!sorted.some(s => s.message.includes("âš ï¸ Mensagem perdida"))}`
                }
            ];
            
            log('ğŸš€ Complete flow results:', {
                mergedCount: merged.length,
                allRestored: sorted.every(s => s.hasOriginalMessage),
                truePeakFirst: sorted[0].message.includes("True Peak"),
                allWillDisplay: rendered.every(r => r.willDisplay),
                finalSuggestions: sorted.map(s => ({ 
                    message: s.message.substring(0, 50), 
                    action: s.action?.substring(0, 30),
                    willDisplay: rendered.find(r => r.message === s.message)?.willDisplay
                }))
            });
            
            displayResult("Fluxo completo", results, "Merge + OrdenaÃ§Ã£o + UI funcionando 100%");
        }

        function testValidationChecklist() {
            log('âœ… CenÃ¡rio: Checklist de validaÃ§Ã£o automÃ¡tica');
            
            // Simular caso mais complexo
            const validSuggestions = [{ message: "Original", priority: 1 }];
            const enhancedSuggestions = [{
                message: "âš¡ True Peak requer correÃ§Ã£o PRIORITÃRIA",
                action: "Aplicar limitador nativo da DAW ou FabFilter Pro-L2",
                priority: 1
            }];
            
            const merged = testCorrectedMerge(validSuggestions, enhancedSuggestions);
            const sorted = merged.sort((a, b) => {
                if (a.message?.includes("True Peak") && !b.message?.includes("True Peak")) return -1;
                if (!a.message?.includes("True Peak") && b.message?.includes("True Peak")) return 1;
                return (a.priority || 1) - (b.priority || 1);
            });
            const rendered = simulateUIRendering(sorted);
            
            const checklist = [
                {
                    success: !sorted.some(s => s.message.includes("âš ï¸ Mensagem perdida")),
                    description: "âŒ Nenhum 'âš ï¸ Mensagem perdida na integraÃ§Ã£o' Ã© exibido"
                },
                {
                    success: sorted[0].message.includes("True Peak"),
                    description: "âœ… True Peak aparece no topo com texto prioritÃ¡rio correto"
                },
                {
                    success: rendered.every(r => r.willDisplay && (r.renderedBlocks.problem || r.renderedBlocks.solution)),
                    description: "âœ… Todos os blocos da IA sÃ£o renderizados (Problema/SoluÃ§Ã£o)"
                },
                {
                    success: sorted.every(s => s.hasOriginalMessage === true),
                    description: "âœ… hasOriginalMessage: true no log"
                },
                {
                    success: sorted.every(s => s.messageSource === "restored"),
                    description: "âœ… messageSource: 'restored' no log"
                },
                {
                    success: sorted.every(s => s.message && s.title && s.message === s.title),
                    description: "âœ… Nenhum campo vÃ¡lido Ã© apagado (message = title)"
                }
            ];
            
            log('âœ… Validation checklist:', checklist);
            
            displayResult("Checklist de validaÃ§Ã£o", checklist, "Todos os critÃ©rios do checklist devem passar");
        }

        // Log inicial
        log("ğŸ” [AUDIT] Auditoria completa para True Peak iniciada");
        log("ğŸ¯ CorreÃ§Ãµes aplicadas: prioridade s.message, fallback UI, logs detalhados");
        log("âš¡ Meta: eliminar 'âš ï¸ Mensagem perdida' e exibir True Peak corretamente");
    </script>
</body>
</html>