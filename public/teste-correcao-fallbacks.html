<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Teste de Corre√ß√£o de Fallbacks - SoundyAI</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        h1 { color: #333; }
        h2 { color: #666; margin-top: 30px; }
        .metric-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .metric-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        .metric-item.fallback {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        .metric-item.real {
            border-left-color: #28a745;
            background: #f8fff8;
        }
        .metric-item.null {
            border-left-color: #6c757d;
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <h1>üß™ Teste de Corre√ß√£o de Fallbacks</h1>
    <p><strong>Objetivo:</strong> Verificar se a fun√ß√£o normalizeBackendAnalysisData agora retorna apenas valores reais ou null, sem fallbacks fict√≠cios.</p>

    <div class="test-section">
        <h2>üìã Resultado dos Testes</h2>
        <div id="testResults"></div>
    </div>

    <div class="test-section">
        <h2>üìä Compara√ß√£o Antes vs Depois</h2>
        <div id="comparisonResults"></div>
    </div>

    <script>
        // Copiar fun√ß√£o getRealValue da corre√ß√£o
        function getRealValue(source, ...paths) {
            for (const path of paths) {
                const value = path.split('.').reduce((obj, key) => obj?.[key], source);
                if (Number.isFinite(value)) {
                    return value;
                }
            }
            return null; // Retorna null se n√£o h√° valor real
        }

        // Simular normaliza√ß√£o ANTES da corre√ß√£o (com fallbacks)
        function normalizeBackendAnalysisDataOLD(backendData) {
            const normalized = {
                ...backendData,
                technicalData: backendData.technicalData || {}
            };
            
            const tech = normalized.technicalData;
            const source = backendData.technicalData || backendData.metrics || backendData;
            
            // ANTIGA FORMA COM FALLBACKS
            tech.peak = source.peak || source.peak_db || source.peakLevel || -60;
            tech.rms = source.rms || source.rms_db || source.rmsLevel || -65;
            tech.dynamicRange = source.dynamicRange || source.dynamic_range || source.dr || 8;
            tech.lufsIntegrated = source.lufsIntegrated || source.lufs_integrated || source.lufs || -23;
            tech.stereoCorrelation = source.stereoCorrelation || source.stereo_correlation || 0.5;
            
            // Bandas com fallbacks antigos
            if (!source.bandEnergies) {
                tech.bandEnergies = {
                    sub: { rms_db: -30, peak_db: -25 },
                    low_bass: { rms_db: -25, peak_db: -20 },
                    mid: { rms_db: -15, peak_db: -10 }
                };
            }
            
            return normalized;
        }

        // Simular normaliza√ß√£o DEPOIS da corre√ß√£o (sem fallbacks)
        function normalizeBackendAnalysisDataNEW(backendData) {
            const normalized = {
                ...backendData,
                technicalData: backendData.technicalData || {}
            };
            
            const tech = normalized.technicalData;
            const source = backendData.technicalData || backendData.metrics || backendData;
            
            // NOVA FORMA SEM FALLBACKS
            tech.peak = getRealValue(source, 'peak', 'peak_db', 'peakLevel');
            tech.rms = getRealValue(source, 'rms', 'rms_db', 'rmsLevel');
            tech.dynamicRange = getRealValue(source, 'dynamicRange', 'dynamic_range', 'dr');
            tech.lufsIntegrated = getRealValue(source, 'lufsIntegrated', 'lufs_integrated', 'lufs');
            tech.stereoCorrelation = getRealValue(source, 'stereoCorrelation', 'stereo_correlation');
            
            // Bandas sem fallbacks
            if (source.bandEnergies || source.band_energies) {
                const bandsSource = source.bandEnergies || source.band_energies || {};
                tech.bandEnergies = {};
                
                ['sub', 'low_bass', 'mid'].forEach(band => {
                    const bandData = bandsSource[band];
                    if (bandData && typeof bandData === 'object') {
                        const rms_db = Number.isFinite(bandData.rms_db) ? bandData.rms_db : null;
                        const peak_db = Number.isFinite(bandData.peak_db) ? bandData.peak_db : null;
                        
                        if (rms_db !== null || peak_db !== null) {
                            tech.bandEnergies[band] = { rms_db, peak_db };
                        }
                    }
                });
                
                if (Object.keys(tech.bandEnergies).length === 0) {
                    tech.bandEnergies = null;
                }
            } else {
                tech.bandEnergies = null;
            }
            
            return normalized;
        }

        // Cen√°rios de teste
        const testScenarios = [
            {
                name: "üî¥ Dados Completamente Vazios",
                data: {}
            },
            {
                name: "üü° Dados Parciais com Algumas M√©tricas",
                data: {
                    technicalData: {
                        peak: -12.5,
                        // rms ausente intencionalmente
                        lufsIntegrated: -18.2
                        // stereoCorrelation ausente
                    }
                }
            },
            {
                name: "üü¢ Dados Completos (Cen√°rio Ideal)",
                data: {
                    technicalData: {
                        peak: -6.2,
                        rms: -12.8,
                        dynamicRange: 14.5,
                        lufsIntegrated: -16.1,
                        stereoCorrelation: 0.75,
                        bandEnergies: {
                            sub: { rms_db: -25.2, peak_db: -18.1 },
                            low_bass: { rms_db: -20.5, peak_db: -14.2 },
                            mid: { rms_db: -12.1, peak_db: -8.5 }
                        }
                    }
                }
            },
            {
                name: "üî∂ Dados com Valores Inv√°lidos (NaN, undefined)",
                data: {
                    technicalData: {
                        peak: NaN,
                        rms: undefined,
                        dynamicRange: "invalid",
                        lufsIntegrated: -14.2, // Este √© v√°lido
                        stereoCorrelation: Infinity
                    }
                }
            }
        ];

        function runTests() {
            const resultsContainer = document.getElementById('testResults');
            const comparisonContainer = document.getElementById('comparisonResults');
            
            let allTestsPassed = true;
            let comparison = [];

            testScenarios.forEach((scenario, index) => {
                console.log(`\nüß™ TESTE ${index + 1}: ${scenario.name}`);
                console.log('üì• Input:', scenario.data);

                // Testar vers√£o antiga (com fallbacks)
                const oldResult = normalizeBackendAnalysisDataOLD(scenario.data);
                console.log('üìä OLD (com fallbacks):', oldResult.technicalData);

                // Testar vers√£o nova (sem fallbacks)
                const newResult = normalizeBackendAnalysisDataNEW(scenario.data);
                console.log('‚ú® NEW (sem fallbacks):', newResult.technicalData);

                // Verificar se a nova vers√£o n√£o tem fallbacks fict√≠cios
                const metrics = ['peak', 'rms', 'dynamicRange', 'lufsIntegrated', 'stereoCorrelation'];
                let hasFallbacks = false;
                let hasProperNulls = false;
                let testDetails = [];

                metrics.forEach(metric => {
                    const oldValue = oldResult.technicalData[metric];
                    const newValue = newResult.technicalData[metric];
                    
                    // Verificar se h√° valor real nos dados de entrada
                    const hasRealValue = Number.isFinite(scenario.data.technicalData?.[metric]);
                    
                    if (!hasRealValue) {
                        // N√£o deveria ter valor, mas vers√£o antiga criou fallback
                        if (Number.isFinite(oldValue)) {
                            testDetails.push(`‚ùå ${metric}: OLD=${oldValue} (fallback fict√≠cio)`);
                        }
                        
                        // Nova vers√£o deveria ser null
                        if (newValue === null) {
                            testDetails.push(`‚úÖ ${metric}: NEW=null (correto)`);
                            hasProperNulls = true;
                        } else {
                            testDetails.push(`‚ùå ${metric}: NEW=${newValue} (deveria ser null)`);
                            hasFallbacks = true;
                        }
                    } else {
                        // Deveria ter o valor real
                        testDetails.push(`‚úÖ ${metric}: NEW=${newValue} (valor real)`);
                    }
                });

                // Verificar bandEnergies
                const oldBands = oldResult.technicalData.bandEnergies;
                const newBands = newResult.technicalData.bandEnergies;
                
                if (!scenario.data.technicalData?.bandEnergies) {
                    if (oldBands && typeof oldBands === 'object' && Object.keys(oldBands).length > 0) {
                        testDetails.push(`‚ùå bandEnergies: OLD criou fallback fict√≠cio`);
                    }
                    if (newBands === null) {
                        testDetails.push(`‚úÖ bandEnergies: NEW=null (correto)`);
                        hasProperNulls = true;
                    } else {
                        testDetails.push(`‚ùå bandEnergies: NEW deveria ser null`);
                        hasFallbacks = true;
                    }
                }

                const testPassed = !hasFallbacks && hasProperNulls;
                if (!testPassed) allTestsPassed = false;

                // Adicionar resultado do teste
                const resultDiv = document.createElement('div');
                resultDiv.className = `test-result ${testPassed ? 'success' : 'error'}`;
                resultDiv.innerHTML = `
                    <h3>${scenario.name}</h3>
                    <p><strong>Status:</strong> ${testPassed ? '‚úÖ PASSOU' : '‚ùå FALHOU'}</p>
                    <div style="margin-top: 10px;">
                        ${testDetails.map(detail => `<div>${detail}</div>`).join('')}
                    </div>
                `;
                resultsContainer.appendChild(resultDiv);

                // Adicionar √† compara√ß√£o
                comparison.push({
                    scenario: scenario.name,
                    oldMetrics: oldResult.technicalData,
                    newMetrics: newResult.technicalData,
                    passed: testPassed
                });
            });

            // Exibir compara√ß√£o
            comparison.forEach(comp => {
                const compDiv = document.createElement('div');
                compDiv.className = 'test-section';
                compDiv.innerHTML = `
                    <h3>${comp.scenario}</h3>
                    <div class="metric-display">
                        ${Object.keys(comp.oldMetrics).map(key => {
                            const oldVal = comp.oldMetrics[key];
                            const newVal = comp.newMetrics[key];
                            
                            let oldClass = 'fallback';
                            let newClass = 'real';
                            
                            if (oldVal === null || oldVal === undefined) oldClass = 'null';
                            if (newVal === null || newVal === undefined) newClass = 'null';
                            if (Number.isFinite(newVal)) newClass = 'real';
                            
                            return `
                                <div class="metric-item ${newClass}">
                                    <strong>${key}</strong><br>
                                    OLD: ${JSON.stringify(oldVal)}<br>
                                    NEW: ${JSON.stringify(newVal)}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                comparisonContainer.appendChild(compDiv);
            });

            // Resultado final
            const finalResult = document.createElement('div');
            finalResult.className = `test-result ${allTestsPassed ? 'success' : 'error'}`;
            finalResult.innerHTML = `
                <h2>üéØ RESULTADO FINAL</h2>
                <p><strong>${allTestsPassed ? '‚úÖ TODOS OS TESTES PASSARAM!' : '‚ùå ALGUNS TESTES FALHARAM'}</strong></p>
                <p>${allTestsPassed ? 
                    'A corre√ß√£o foi implementada com sucesso. A fun√ß√£o normalizeBackendAnalysisData agora retorna apenas valores reais ou null, sem fallbacks fict√≠cios.' :
                    'Ainda existem problemas na implementa√ß√£o. Verifique os testes que falharam acima.'
                }</p>
            `;
            resultsContainer.insertBefore(finalResult, resultsContainer.firstChild);
        }

        // Executar testes quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>