<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ TESTE: Sub-Scores + IA + Ordena√ß√£o</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; background: #0a0e1a; color: #e0e6ed; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .fix-card { background: #0f3a0f; border: 2px solid #10b981; border-radius: 8px; padding: 20px; margin: 15px 0; }
        .test-card { background: #141b2d; border: 1px solid #2a3441; border-radius: 8px; padding: 20px; margin: 15px 0; }
        .result { padding: 10px; margin: 5px 0; border-radius: 4px; }
        .success { background: #0f4c3a; border-left: 4px solid #10b981; }
        .error { background: #4c1d1d; border-left: 4px solid #ef4444; }
        .warning { background: #4c3d1d; border-left: 4px solid #f59e0b; }
        .info { background: #1e3a8a; border-left: 4px solid #3b82f6; }
        button { background: #059669; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; margin: 8px; font-size: 14px; }
        button:hover { background: #047857; }
        pre { background: #0f1419; padding: 15px; border-radius: 6px; overflow-x: auto; font-size: 12px; border: 1px solid #374151; }
        .highlight { background: #fbbf24; color: #000; padding: 2px 6px; border-radius: 3px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ TESTE: Sub-Scores + IA + Ordena√ß√£o</h1>
        
        <div class="fix-card">
            <h3>üîß CORRE√á√ïES APLICADAS:</h3>
            <div class="result success">‚úÖ <strong>Recurs√£o Infinita Fixed:</strong> calculateMetricScore n√£o chama mais a si mesmo</div>
            <div class="result success">‚úÖ <strong>IA Ativada:</strong> Modo de desenvolvimento configurado com enriquecimentos simulados</div>
            <div class="result success">‚úÖ <strong>Ordena√ß√£o Fixed:</strong> True Peak aparece primeiro (priority decrescente)</div>
        </div>

        <div class="test-card">
            <h2>üß™ TESTE 1: Recurs√£o Infinita</h2>
            <button onclick="testRecursionFix()">üîç Testar calculateMetricScore</button>
            <div id="recursion-results"></div>
        </div>

        <div class="test-card">
            <h2>üìä TESTE 2: Sub-Scores</h2>
            <button onclick="testSubScores()">üìà Testar C√°lculo de Sub-Scores</button>
            <div id="subscores-results"></div>
        </div>

        <div class="test-card">
            <h2>ü§ñ TESTE 3: Sistema de IA</h2>
            <button onclick="testAISystem()">üöÄ Testar IA Dev Mode</button>
            <div id="ai-results"></div>
        </div>

        <div class="test-card">
            <h2>üéØ TESTE 4: Ordena√ß√£o</h2>
            <button onclick="testOrdering()">üìã Testar Ordena√ß√£o de Sugest√µes</button>
            <div id="ordering-results"></div>
        </div>

        <div class="test-card">
            <h2>‚úÖ TESTE INTEGRADO FINAL</h2>
            <button onclick="testCompleteSystem()">üéâ Testar Sistema Completo</button>
            <div id="complete-results"></div>
        </div>
    </div>

    <!-- Carregar scripts necess√°rios -->
    <script src="public/lib/audio/features/scoring.js"></script>
    <script src="public/suggestion-scorer.js"></script>
    <script src="public/enhanced-suggestion-engine.js"></script>
    <script src="public/ai-suggestion-layer.js"></script>

    <script>
        function log(message, type = 'info') {
            const classes = { success: 'success', error: 'error', warning: 'warning', info: 'info' };
            return `<div class="result ${classes[type]}">${message}</div>`;
        }

        function testRecursionFix() {
            let html = '<h3>üîç Teste de Recurs√£o Infinita</h3>';
            
            try {
                // Testar fun√ß√£o do arquivo atual (deveria usar fallback local)
                const testValue = -16;
                const testTarget = -14;
                const testTolerance = 1;
                
                html += log('Testando calculateMetricScore local...', 'info');
                
                // Simular que n√£o existe window.calculateMetricScore ou √© igual √† fun√ß√£o local
                const originalWindowFunc = window.calculateMetricScore;
                
                // Testar se a fun√ß√£o executa sem recurs√£o infinita
                const startTime = Date.now();
                const result = window.calculateMetricScore(testValue, testTarget, testTolerance, 'lufs');
                const endTime = Date.now();
                
                if (endTime - startTime < 100 && Number.isFinite(result)) {
                    html += log(`‚úÖ SUCCESS: Resultado ${result}% em ${endTime - startTime}ms`, 'success');
                    html += log('Recurs√£o infinita corrigida com sucesso!', 'success');
                } else {
                    html += log(`‚ö†Ô∏è Demorou muito (${endTime - startTime}ms) - poss√≠vel problema`, 'warning');
                }
                
            } catch (error) {
                if (error.message.includes('Maximum call stack size exceeded')) {
                    html += log('‚ùå RECURS√ÉO INFINITA AINDA EXISTE!', 'error');
                } else {
                    html += log(`‚ùå Erro inesperado: ${error.message}`, 'error');
                }
            }
            
            document.getElementById('recursion-results').innerHTML = html;
        }

        function testSubScores() {
            let html = '<h3>üìà Teste de Sub-Scores</h3>';
            
            try {
                // Testar se as fun√ß√µes de sub-score existem e funcionam
                const functions = [
                    'calculateLoudnessScore',
                    'calculateDynamicsScore', 
                    'calculateStereoScore',
                    'calculateFrequencyScore',
                    'calculateTechnicalScore'
                ];
                
                html += '<h4>üîç Fun√ß√µes Dispon√≠veis:</h4>';
                let functionsOk = 0;
                
                functions.forEach(funcName => {
                    const exists = typeof window[funcName] === 'function';
                    html += log(`${funcName}: ${exists ? 'DISPON√çVEL' : 'AUSENTE'}`, exists ? 'success' : 'error');
                    if (exists) functionsOk++;
                });
                
                // Testar calculateMetricScore (fun√ß√£o base)
                html += '<h4>üìä Teste da Fun√ß√£o Base:</h4>';
                if (typeof window.calculateMetricScore === 'function') {
                    try {
                        const lufsScore = window.calculateMetricScore(-16, -14, 1, 'lufs');
                        const truePeakScore = window.calculateMetricScore(-0.5, -1, 0.2, 'true_peak');
                        const drScore = window.calculateMetricScore(8, 12, 2, 'dr');
                        
                        html += log(`LUFS Score: ${lufsScore}%`, lufsScore > 0 ? 'success' : 'error');
                        html += log(`True Peak Score: ${truePeakScore}%`, truePeakScore > 0 ? 'success' : 'error');
                        html += log(`DR Score: ${drScore}%`, drScore > 0 ? 'success' : 'error');
                        
                        if (lufsScore > 0 && truePeakScore > 0 && drScore > 0) {
                            html += log('‚úÖ calculateMetricScore funcionando sem recurs√£o!', 'success');
                        }
                        
                    } catch (error) {
                        html += log(`‚ùå Erro ao testar calculateMetricScore: ${error.message}`, 'error');
                    }
                } else {
                    html += log('‚ùå calculateMetricScore n√£o dispon√≠vel', 'error');
                }
                
                // Status final
                if (functionsOk >= 3) {
                    html += log('‚úÖ Sub-scores devem funcionar corretamente!', 'success');
                } else {
                    html += log('‚ö†Ô∏è Algumas fun√ß√µes de sub-score ausentes', 'warning');
                }
                
            } catch (error) {
                html += log(`‚ùå Erro no teste: ${error.message}`, 'error');
            }
            
            document.getElementById('subscores-results').innerHTML = html;
        }

        function testAISystem() {
            let html = '<h3>ü§ñ Teste do Sistema de IA</h3>';
            
            try {
                // Verificar se aiSuggestionLayer existe
                if (typeof window.aiSuggestionLayer === 'object') {
                    html += log('‚úÖ aiSuggestionLayer encontrado', 'success');
                    
                    // Verificar se API key foi configurada
                    const stats = window.aiSuggestionLayer.getStats();
                    html += log(`API Key configurada: ${stats.hasApiKey ? 'SIM' : 'N√ÉO'}`, stats.hasApiKey ? 'success' : 'warning');
                    html += log(`Modo de desenvolvimento: ${stats.devMode ? 'SIM' : 'N√ÉO'}`, stats.devMode ? 'success' : 'info');
                    
                    // Testar processamento simulado
                    if (window.aiSuggestionLayer.simulateAIEnrichment) {
                        const testSuggestions = [
                            {
                                type: 'reference_true_peak',
                                message: '‚ö†Ô∏è True Peak alto',
                                action: 'Use limiter'
                            },
                            {
                                type: 'band_adjust',
                                message: 'Banda bass baixa',
                                action: 'Aumentar bass em 3 dB'
                            }
                        ];
                        
                        const enriched = window.aiSuggestionLayer.simulateAIEnrichment(testSuggestions, {});
                        
                        html += log(`Sugest√µes enriquecidas: ${enriched.length}`, 'info');
                        
                        enriched.forEach((suggestion, index) => {
                            const hasPlugin = !!suggestion.pluginSuggestion;
                            const hasTip = !!suggestion.dawTip;
                            const hasContext = !!suggestion.educationalContext;
                            
                            html += log(`Sugest√£o ${index + 1}: Plugin=${hasPlugin}, Tip=${hasTip}, Context=${hasContext}`, 
                                       (hasPlugin && hasTip) ? 'success' : 'warning');
                        });
                        
                        if (enriched.length > 0 && enriched[0].pluginSuggestion) {
                            html += log('‚úÖ Sistema de IA simulado funcionando!', 'success');
                        }
                    } else {
                        html += log('‚ö†Ô∏è Fun√ß√£o simulateAIEnrichment n√£o encontrada', 'warning');
                    }
                    
                } else {
                    html += log('‚ùå aiSuggestionLayer n√£o encontrado', 'error');
                }
                
            } catch (error) {
                html += log(`‚ùå Erro no teste IA: ${error.message}`, 'error');
            }
            
            document.getElementById('ai-results').innerHTML = html;
        }

        function testOrdering() {
            let html = '<h3>üìã Teste de Ordena√ß√£o</h3>';
            
            try {
                if (!window.EnhancedSuggestionEngine) {
                    html += log('‚ùå Enhanced Suggestion Engine n√£o dispon√≠vel', 'error');
                    document.getElementById('ordering-results').innerHTML = html;
                    return;
                }
                
                const engine = new window.EnhancedSuggestionEngine();
                
                // Dados que devem gerar True Peak primeiro
                const testAnalysis = {
                    technicalData: {
                        lufs: { value: -15, lufs: -15 },           // Problema pequeno
                        true_peak: { value: -0.1, true_peak: -0.1 }, // üö® PROBLEMA CR√çTICO
                        dr: { value: 10, dr: 10 }                  // Problema pequeno
                    }
                };
                
                const testReference = {
                    lufs_target: -14, tol_lufs: 1,
                    true_peak_target: -1, tol_true_peak: 0.2,
                    dr_target: 12, tol_dr: 2
                };
                
                const suggestions = engine.generateSuggestions(testAnalysis, testReference);
                
                html += log(`Sugest√µes geradas: ${suggestions.length}`, 'info');
                
                if (suggestions.length > 0) {
                    const first = suggestions[0];
                    const isTruePeakFirst = first.type === 'reference_true_peak' || first.type === 'heuristic_true_peak';
                    
                    html += log(`Primeira sugest√£o: ${first.type} (priority: ${first.priority})`, 'info');
                    html += log(`True Peak √© primeiro: ${isTruePeakFirst ? 'SIM' : 'N√ÉO'}`, 
                               isTruePeakFirst ? 'success' : 'error');
                    
                    // Mostrar as primeiras 3 sugest√µes
                    html += '<h4>üîç Ordem das Sugest√µes:</h4>';
                    suggestions.slice(0, 3).forEach((s, i) => {
                        const priorityText = s.priority ? s.priority.toFixed(1) : 'N/A';
                        html += log(`${i + 1}¬∞: ${s.type} (priority: ${priorityText})`, 'info');
                    });
                    
                    if (isTruePeakFirst) {
                        html += log('‚úÖ ORDENA√á√ÉO CORRETA: True Peak est√° primeiro!', 'success');
                    } else {
                        html += log('‚ùå ORDENA√á√ÉO INCORRETA: True Peak deveria estar primeiro', 'error');
                    }
                }
                
            } catch (error) {
                html += log(`‚ùå Erro no teste: ${error.message}`, 'error');
            }
            
            document.getElementById('ordering-results').innerHTML = html;
        }

        function testCompleteSystem() {
            let html = '<h3>üéâ Teste do Sistema Completo</h3>';
            
            try {
                html += '<h4>üîß Verifica√ß√£o dos Componentes:</h4>';
                
                // 1. Sub-scores sem recurs√£o
                let subScoresOk = false;
                try {
                    const testScore = window.calculateMetricScore(-16, -14, 1, 'lufs');
                    subScoresOk = Number.isFinite(testScore) && testScore > 0;
                    html += log(`1. Sub-scores: ${subScoresOk ? 'OK' : 'ERRO'}`, subScoresOk ? 'success' : 'error');
                } catch (e) {
                    html += log(`1. Sub-scores: ERRO (${e.message})`, 'error');
                }
                
                // 2. IA configurada
                const aiConfigured = window.aiSuggestionLayer?.getStats()?.hasApiKey;
                html += log(`2. IA configurada: ${aiConfigured ? 'OK' : 'ERRO'}`, aiConfigured ? 'success' : 'error');
                
                // 3. Ordena√ß√£o funcionando
                let orderingOk = false;
                try {
                    const engine = new window.EnhancedSuggestionEngine();
                    const testSuggs = engine.generateSuggestions({
                        technicalData: {
                            true_peak: { value: -0.1, true_peak: -0.1 },
                            lufs: { value: -15, lufs: -15 }
                        }
                    }, {
                        true_peak_target: -1, tol_true_peak: 0.2,
                        lufs_target: -14, tol_lufs: 1
                    });
                    
                    orderingOk = testSuggs.length > 0 && 
                        (testSuggs[0].type === 'reference_true_peak' || testSuggs[0].type === 'heuristic_true_peak');
                    
                    html += log(`3. Ordena√ß√£o: ${orderingOk ? 'OK' : 'ERRO'}`, orderingOk ? 'success' : 'error');
                } catch (e) {
                    html += log(`3. Ordena√ß√£o: ERRO (${e.message})`, 'error');
                }
                
                // 4. Enhanced Suggestion Engine
                const engineOk = typeof window.EnhancedSuggestionEngine === 'function';
                html += log(`4. Enhanced Engine: ${engineOk ? 'OK' : 'ERRO'}`, engineOk ? 'success' : 'error');
                
                // 5. Suggestion Scorer
                const scorerOk = typeof window.suggestionScorer === 'object';
                html += log(`5. Suggestion Scorer: ${scorerOk ? 'OK' : 'ERRO'}`, scorerOk ? 'success' : 'error');
                
                // Resultado final
                const allSystemsOk = subScoresOk && aiConfigured && orderingOk && engineOk && scorerOk;
                
                html += '<br><div class="fix-card">';
                html += '<h4>üìã RESULTADO FINAL:</h4>';
                if (allSystemsOk) {
                    html += log('üéâ SISTEMA COMPLETAMENTE FUNCIONAL!', 'success');
                    html += log('‚úÖ Sub-scores funcionando sem recurs√£o', 'success');
                    html += log('‚úÖ IA configurada com enriquecimentos', 'success');
                    html += log('‚úÖ Ordena√ß√£o correta (True Peak primeiro)', 'success');
                    html += log('‚úÖ Todos os componentes operacionais', 'success');
                } else {
                    html += log('‚ö†Ô∏è Sistema parcialmente funcional', 'warning');
                    html += log('Alguns componentes podem precisar de ajustes', 'info');
                }
                html += '</div>';
                
            } catch (error) {
                html += log(`‚ùå Erro no teste completo: ${error.message}`, 'error');
            }
            
            document.getElementById('complete-results').innerHTML = html;
        }

        // Auto-executar teste b√°sico ao carregar
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('üéØ Executando teste autom√°tico...');
                testRecursionFix();
                testAISystem();
            }, 1000);
        });
    </script>
</body>
</html>