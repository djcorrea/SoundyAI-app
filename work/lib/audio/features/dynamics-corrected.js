// üéöÔ∏è DYNAMICS METRICS CORRECTED - DR, LRA, Crest Factor
// Implementa√ß√£o profissional com valores realistas para produ√ß√£o musical

import { logAudio, makeErr } from '../error-handling.js';

/**
 * üéØ Configura√ß√µes para m√©tricas de din√¢mica
 */
const DYNAMICS_CONFIG = {
  // Dynamic Range
  DR_WINDOW_MS: 300,      // Janela RMS para an√°lise (conforme padr√£o)
  DR_HOP_MS: 100,         // Sobreposi√ß√£o de janelas
  DR_MIN_WINDOWS: 10,     // M√≠nimo de janelas para an√°lise v√°lida
  
  // Crest Factor
  CREST_MIN_RMS: 1e-10,   // RMS m√≠nimo para c√°lculo v√°lido
  CREST_MIN_PEAK: 1e-10,  // Peak m√≠nimo para c√°lculo v√°lido
  
  // Valores de refer√™ncia profissionais
  DR_REFERENCE: {
    funk: { min: 3, max: 6, typical: 4.5 },
    trance: { min: 6, max: 10, typical: 8 },
    classical: { min: 12, max: 20, typical: 16 },
    pop: { min: 4, max: 8, typical: 6 },
    rock: { min: 5, max: 12, typical: 8.5 }
  }
};

/**
 * üéöÔ∏è DYNAMIC RANGE CORRETO: Diferen√ßa entre pico RMS e RMS m√©dio
 * Implementa√ß√£o profissional com janelas deslizantes
 */
export class DynamicRangeCalculator {
  
  /**
   * üìä Calcular RMS em janelas deslizantes
   */
  static calculateWindowedRMS(audioData, sampleRate, windowMs = 300, hopMs = 100) {
    const windowSamples = Math.round((windowMs / 1000) * sampleRate);
    const hopSamples = Math.round((hopMs / 1000) * sampleRate);
    const rmsValues = [];
    
    for (let start = 0; start + windowSamples <= audioData.length; start += hopSamples) {
      let sumSquares = 0;
      
      for (let i = start; i < start + windowSamples; i++) {
        sumSquares += audioData[i] * audioData[i];
      }
      
      const rms = Math.sqrt(sumSquares / windowSamples);
      if (rms > DYNAMICS_CONFIG.CREST_MIN_RMS) {
        rmsValues.push(20 * Math.log10(rms)); // Converter para dB
      }
    }
    
    return rmsValues;
  }
  
  /**
   * üéØ Calcular Dynamic Range profissional
   * DR = Pico RMS mais alto - RMS m√©dio
   */
  static calculateDynamicRange(leftChannel, rightChannel, sampleRate = 48000) {
    try {
      // Combinar canais em mono para an√°lise consistente
      const length = Math.min(leftChannel.length, rightChannel.length);
      const monoData = new Float32Array(length);
      
      for (let i = 0; i < length; i++) {
        monoData[i] = (leftChannel[i] + rightChannel[i]) / 2;
      }
      
      // Calcular RMS em janelas
      const rmsValues = this.calculateWindowedRMS(
        monoData, 
        sampleRate, 
        DYNAMICS_CONFIG.DR_WINDOW_MS, 
        DYNAMICS_CONFIG.DR_HOP_MS
      );
      
      if (rmsValues.length < DYNAMICS_CONFIG.DR_MIN_WINDOWS) {
        logAudio('dynamics', 'insufficient_windows', { 
          windows: rmsValues.length, 
          required: DYNAMICS_CONFIG.DR_MIN_WINDOWS 
        });
        return null;
      }
      
      // Encontrar pico RMS e calcular m√©dia
      const peakRMS = Math.max(...rmsValues);
      const averageRMS = rmsValues.reduce((sum, val) => sum + val, 0) / rmsValues.length;
      const dynamicRange = peakRMS - averageRMS;
      
      // Validar resultado
      if (!isFinite(dynamicRange) || dynamicRange < 0) {
        logAudio('dynamics', 'invalid_dr', { 
          peakRMS: peakRMS.toFixed(2), 
          averageRMS: averageRMS.toFixed(2), 
          dr: dynamicRange.toFixed(2) 
        });
        return null;
      }
      
      // Log para auditoria
      logAudio('dynamics', 'dr_calculated', {
        peakRmsDb: peakRMS.toFixed(2),
        averageRmsDb: averageRMS.toFixed(2),
        dynamicRangeDb: dynamicRange.toFixed(2),
        windows: rmsValues.length,
        windowMs: DYNAMICS_CONFIG.DR_WINDOW_MS
      });
      
      return {
        dynamicRange: dynamicRange,
        peakRmsDb: peakRMS,
        averageRmsDb: averageRMS,
        windowCount: rmsValues.length,
        algorithm: 'Peak_RMS_minus_Average_RMS',
        referenceGenres: this.classifyDynamicRange(dynamicRange)
      };
      
    } catch (error) {
      logAudio('dynamics', 'dr_error', { error: error.message });
      return null;
    }
  }
  
  /**
   * üéµ Classificar g√™nero baseado em Dynamic Range
   */
  static classifyDynamicRange(dr) {
    const genres = [];
    const ref = DYNAMICS_CONFIG.DR_REFERENCE;
    
    for (const [genre, range] of Object.entries(ref)) {
      if (dr >= range.min && dr <= range.max) {
        genres.push({
          genre,
          match: 'typical',
          confidence: this.calculateConfidence(dr, range)
        });
      }
    }
    
    return genres.length > 0 ? genres : [{ 
      genre: 'unknown', 
      match: 'atypical', 
      confidence: 0 
    }];
  }
  
  /**
   * üìà Calcular confian√ßa da classifica√ß√£o
   */
  static calculateConfidence(dr, range) {
    const center = range.typical;
    const tolerance = (range.max - range.min) / 2;
    const distance = Math.abs(dr - center);
    return Math.max(0, 1 - (distance / tolerance));
  }
}

/**
 * üèîÔ∏è CREST FACTOR CORRETO: conforme especifica√ß√£o
 * Regra: tudo em dBFS
 * crestDb = truePeakDbtp - rmsDbfs
 * assert(crestDb >= 0 && crestDb <= 20)
 */
export class CrestFactorCalculator {
  
  /**
   * üéØ Calcular Crest Factor seguindo especifica√ß√£o exata
   * @param {Float32Array} leftChannel - Canal esquerdo
   * @param {Float32Array} rightChannel - Canal direito  
   * @param {number} truePeakDbtp - True Peak em dBTP (ser√° tratado como dBFS)
   * @returns {Object} Resultado do c√°lculo do Crest Factor
   */
  static calculateCrestFactor(leftChannel, rightChannel, truePeakDbtp = null) {
    try {
      const length = Math.min(leftChannel.length, rightChannel.length);
      
      if (length === 0) {
        return null;
      }
      
      let sumSquares = 0;
      
      // Calcular RMS do canal m√©dio
      for (let i = 0; i < length; i++) {
        const midSample = (leftChannel[i] + rightChannel[i]) / 2;
        sumSquares += midSample * midSample;
      }
      
      if (sumSquares === 0) {
        logAudio('dynamics', 'crest_silence_detected', { samples: length });
        return null;
      }
      
      const rmsLinear = Math.sqrt(sumSquares / length);
      
      if (rmsLinear < DYNAMICS_CONFIG.CREST_MIN_RMS) {
        logAudio('dynamics', 'crest_insufficient_rms', { 
          rmsLinear: rmsLinear.toExponential(3) 
        });
        return null;
      }
      
      // ESPECIFICA√á√ÉO: tudo em dBFS
      const rmsDbfs = 20 * Math.log10(rmsLinear);   // se ainda estiver em linear
      const peakDbfs = truePeakDbtp;                // trate dBTP como dBFS para crest
      
      if (peakDbfs === null || !isFinite(peakDbfs)) {
        logAudio('dynamics', 'crest_no_true_peak', { truePeakDbtp });
        return null;
      }
      
      const crestDb = peakDbfs - rmsDbfs;
      
      // ESPECIFICA√á√ÉO: assert(crestDb >= 0 && crestDb <= 20)
      if (crestDb < 0 || crestDb > 20 || !isFinite(crestDb)) {
        logAudio('dynamics', 'crest_out_of_range', { 
          peakDbfs: peakDbfs.toFixed(2), 
          rmsDbfs: rmsDbfs.toFixed(2), 
          crestDb: crestDb.toFixed(2),
          valid: false
        });
        
        // Retornar mesmo assim, mas marcar como inv√°lido
        return {
          crestFactorDb: crestDb,
          peakDbfs: peakDbfs,
          rmsDbfs: rmsDbfs,
          rmsLinear: rmsLinear,
          valid: false,
          outOfRange: true,
          algorithm: 'TruePeak_dBTP_minus_RMS_dBFS',
          assertion: 'FAILED: crestDb should be 0-20 dB'
        };
      }
      
      // Log para auditoria
      logAudio('dynamics', 'crest_calculated', {
        peakDbfs: peakDbfs.toFixed(2),
        rmsDbfs: rmsDbfs.toFixed(2),
        crestFactorDb: crestDb.toFixed(2),
        samples: length,
        assertion: 'PASSED: 0 <= crestDb <= 20'
      });
      
      return {
        crestFactorDb: crestDb,
        peakDbfs: peakDbfs,
        rmsDbfs: rmsDbfs,
        rmsLinear: rmsLinear,
        valid: true,
        outOfRange: false,
        algorithm: 'TruePeak_dBTP_minus_RMS_dBFS',
        assertion: 'PASSED: 0 <= crestDb <= 20',
        interpretation: this.interpretCrestFactor(crestDb)
      };
      
    } catch (error) {
      logAudio('dynamics', 'crest_error', { error: error.message });
      return null;
    }
  }
  
  /**
   * üìä Interpretar valor do Crest Factor
   */
  static interpretCrestFactor(crestDb) {
    if (crestDb < 6) {
      return { level: 'heavily_compressed', description: 'Muito comprimido' };
    } else if (crestDb < 12) {
      return { level: 'moderately_compressed', description: 'Moderadamente comprimido' };
    } else if (crestDb < 18) {
      return { level: 'lightly_compressed', description: 'Levemente comprimido' };
    } else {
      return { level: 'natural_dynamics', description: 'Din√¢mica natural' };
    }
  }
}

/**
 * üìä LRA (Loudness Range) Helper - para extens√£o futura
 * Nota: LRA principal est√° em loudness.js, esta √© extens√£o
 */
export class LRACalculator {
  
  /**
   * üéØ Validar LRA existente e adicionar contexto
   */
  static validateAndEnhanceLRA(lraValue, shortTermValues = []) {
    if (lraValue === null || !isFinite(lraValue)) {
      return null;
    }
    
    // Adicionar contexto profissional
    const interpretation = this.interpretLRA(lraValue);
    
    return {
      lra: lraValue,
      interpretation,
      silenceDetected: lraValue < 0.5,
      validMeasurement: lraValue >= 0.1 && isFinite(lraValue),
      algorithm: 'ITU_BS_1770_4_with_gating'
    };
  }
  
  /**
   * üìà Interpretar valor LRA
   */
  static interpretLRA(lra) {
    if (lra < 1) {
      return { level: 'very_compressed', description: 'Extremamente comprimido' };
    } else if (lra < 3) {
      return { level: 'compressed', description: 'Muito comprimido' };
    } else if (lra < 6) {
      return { level: 'moderate', description: 'Moderadamente din√¢mico' };
    } else if (lra < 10) {
      return { level: 'dynamic', description: 'Din√¢mico' };
    } else {
      return { level: 'very_dynamic', description: 'Muito din√¢mico' };
    }
  }
}

/**
 * üéõÔ∏è Agregador principal das m√©tricas de din√¢mica
 */
export function calculateDynamicsMetrics(leftChannel, rightChannel, sampleRate = 48000, existingLRA = null, truePeakDbtp = null) {
  const dr = DynamicRangeCalculator.calculateDynamicRange(leftChannel, rightChannel, sampleRate);
  const crest = CrestFactorCalculator.calculateCrestFactor(leftChannel, rightChannel, truePeakDbtp);
  const lra = LRACalculator.validateAndEnhanceLRA(existingLRA);
  
  return {
    dynamicRange: dr?.dynamicRange || null,
    dynamicRangeDetails: dr,
    crestFactor: crest?.crestFactorDb || null,  // Atualizado para usar crestFactorDb
    crestFactorDetails: crest,
    lra: lra?.lra || null,
    lraDetails: lra
  };
}

console.log('üéöÔ∏è Dynamics Metrics Calculator carregado - DR, Crest Factor e LRA profissionais');